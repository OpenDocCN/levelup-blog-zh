<html>
<head>
<title>How to embed a web server inside desktop applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在桌面应用程序中嵌入web服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-embed-a-web-server-inside-desktop-applications-643ce3cb51bf?source=collection_archive---------2-----------------------#2020-07-29">https://levelup.gitconnected.com/how-to-embed-a-web-server-inside-desktop-applications-643ce3cb51bf?source=collection_archive---------2-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7343" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用一个扩展javascript开发的应用程序的案例研究的逐步指南</h2></div><p id="72ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解如何在桌面应用程序中嵌入web服务器。这是使用ASP.NET核心和WPF应用程序完成的，但同样的体验可以移植到Windows窗体或控制台应用程序，没有任何大的区别。这是一个非常不寻常的场景，因为我们通常有一个客户端连接到API，并且两者在不同的地方。无论如何，在某些情况下，将可视化UI与web服务器集成到客户端可能是有用的。我在考虑必须远程控制的嵌入式设备或想要共享数据的工作站，但我相信你比我更有想象力，你已经发现了更多有趣的用例😃</p><p id="377e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我用这种情况创建了<a class="ae le" href="https://github.com/zeppaman/jSOS" rel="noopener ugc nofollow" target="_blank"> jSOS </a>，这是一个用于扩展javascript功能的通用API系统，例如添加直接打印或文件系统访问。结果托管在Github上，它是一个完全正常工作的应用程序。古玩？嗯，我将用这个项目作为一个用例来解释如何配置一个WPF应用程序作为一个web服务器！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/d150d1ff6f8e68f423f0fe442e369aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8atrlcmd8276k3qskIx17A.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">福托迪<a class="ae le" href="https://pixabay.com/it/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3428644" rel="noopener ugc nofollow" target="_blank">格尔德奥特曼</a>达<a class="ae le" href="https://pixabay.com/it/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3428644" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></figcaption></figure><h2 id="8b0e" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated"><strong class="ak">案例分析</strong></h2><p id="36af" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">上面几行我提到的应用程序叫做JSOS(JavaScript s . o . s .的缩写，无可奉告😅)并实现以下流程:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mt"><img src="../Images/ff8923fdc8059c92054a3bc7f541ec52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9IsBpLIukSDEeuRKctiNA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">来自https://github.com/zeppaman/jSOS<a class="ae le" href="https://github.com/zeppaman/jSOS" rel="noopener ugc nofollow" target="_blank">的JSOS模式</a></figcaption></figure><p id="2971" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，我们需要的是:</p><ul class=""><li id="11b9" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated">可以加载API服务的web服务器(简单)</li><li id="5aa5" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">一个API，当被调用时打开一个UI弹出窗口，这样用户可以允许一个网页访问某个范围(显然不容易)</li><li id="d2a8" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">一个UI应用程序(对于每个玩XAML的人来说都很简单，但是你也可以将同样的结果应用到一个web表单应用程序中)</li><li id="3d7a" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">API和UI之间的交互系统，用于实时刷新</li></ul><p id="e435" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单地说，我所做的正是我们在这篇文章中所说的:一个嵌入了web API服务器的简单桌面应用程序。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ni"><img src="../Images/fd7dd17bb3bff42c831aef75ea2fef53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8-wUAF8CO7mDkVZjQLLJw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">与❤️一起制作的图表</figcaption></figure><h2 id="759a" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">分步实施</h2><p id="a160" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">第一点是创建一个windows应用程序。我选择了一个WPF应用程序，因为我对实现一个可以跨平台移植的丰富应用程序感兴趣(使用Xamarin或<a class="ae le" href="https://github.com/dotnet/maui" rel="noopener ugc nofollow" target="_blank"> MAUI </a>框架，我可以很容易地从XAML开始，或者差不多就是我想的那样)。我们将在下一篇文章“如何将WPF应用程序移植到毛伊岛”中看到更多相关内容，但考虑到毛伊岛路线图，可能要到明年。第一步是创建一个新项目，选择正确的应用程序类型。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/26fbfe15e61d2f7b7720c8a797d068e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*JiS8KIPi5Q9lebpb5Uzoxg.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">选择WPF项目类型</figcaption></figure><p id="633f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">依赖设置</strong></p><p id="55f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要一个同时是桌面应用程序和web服务器的可执行文件…那么，将这两个角色都添加到项目配置中怎么样？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nk"><img src="../Images/a723514397ec9cf7c5c91be3743bdad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rT-Bn4lXQ6apE8Vuj1-41Q.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">项目文件配置</figcaption></figure><p id="8059" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除非您这样做，否则即使您手动添加依赖项，您仍然会在编译<code class="fe nl nm nn no b">Startup.cs</code>文件时发现问题，因为该文件需要一些由项目SDK类型驱动的预处理。</p><p id="a064" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成这一步后，您将得到一个混合的应用程序，如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4c344a7bef59d5d8faff28d999ff8860.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*caaQJCZYLngz_cs9fKqOmg.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">混合应用</figcaption></figure><p id="66bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是将API的代码与应用程序的代码分开。我创建了两个主要的文件夹，充满幻想地叫做APP和API，但是其他的解决方案也可以。</p><p id="ce86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我的项目设置:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c1bedc01717a21b9507465b91e08512d.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*cLzLfugOG2sIteSfO3vOWg.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">项目设置</figcaption></figure><p id="5f86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在API文件夹中，我有APIStartup.cs和一个用于控制器的文件夹。对于扩展，你也可以有wwwroot或其他你需要的ASP.NET核心东西，只需正确配置启动文件(像在每个常规的。net应用)。</p><p id="27bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">服务器服务</strong></p><p id="3ee1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要创建一个控制服务器的服务。很抱歉命名错误，但是按照惯例，提供服务器功能的服务必须被称为ServerService😆</p><p id="ea80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个服务中，我们有一个非常小的激活Krestel服务器实例的逻辑。唯一棘手的部分是，运行必须是异步的，以避免停止应用程序的主线程，我的意思是…异步启动它，没有等待。在我的例子中，非异步方法中的“Task.Run”运行良好。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1e6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">启动服务器</strong></p><p id="791c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于启动服务器来说，任何点都是好的:你可以使用一个按钮或者让我们从头开始。我使用了启动时触发的app.xml.cs，所以我的主窗口打开时服务器已经打开。</p><p id="f13d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">消息总线</strong></p><p id="158e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们有两个位于不同范围的模块，所以我们需要一些工具来让它们进行通信。受WPF消息服务和伟大的MVVMLight实现的启发，我为此创建了一个服务。该服务只有两种方法，一种用于注册事件，一种用于触发事件。基于这个简单的用例，我使用一个对象作为参数，委托实时注册向下转换。更好的实现可能是使用泛型方法和强类型输入进行注册\发射。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="721b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">关于依赖注入的说明</strong></p><p id="4ce4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而ASP.NET核心战舰的依附性注入，为什么不用它也注入WPF部分呢？Asp.net核心的容器是在托管环境启动期间构建的，这发生在WPF启动之后，进入另一个线程。我在我的例子中实现的解决方案很简单，我需要共享完全相同的实例。我只是将所有服务添加到一个静态服务提供者，然后获取所有注册的实例，并将它们添加到ASP.NET核心容器中。这让应用程序的每个模块照常工作，但是共享类实例。</p><p id="5424" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码片段做了我们需要的事情:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a0f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">带什么回家</strong></p><p id="d80c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让ASP.NET和WPF一起工作是非常容易的，并且会出现一些非常不寻常但非常强大的场景，比如有人调用等待用户响应的API，比如我向用户显示的用于授权许可请求的弹出窗口。此外，我们可以发布一个自容器web应用程序，用一个UI来启动和停止服务。我在这篇文章的开头让你尝试一下，想象一下你可以用这个解决方案做些什么……我希望读完这篇文章后，你对Aspe.net和WPF的混合选项有一个更好的了解，所以我在等待你的建议！</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="713d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oa">喜欢这篇文章吗？成为</em> <a class="ae le" href="https://daniele-fontani.medium.com/membership" rel="noopener"> <em class="oa">中等会员</em> </a> <em class="oa">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><p id="032a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考文献</strong></p><ul class=""><li id="a9a3" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><a class="ae le" href="https://github.com/zeppaman/jSOS" rel="noopener ugc nofollow" target="_blank">https://github.com/zeppaman/jSOS</a>样板工程</li></ul></div></div>    
</body>
</html>