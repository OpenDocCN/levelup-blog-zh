<html>
<head>
<title>5 Ways to Clone An Object in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中克隆对象的5种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-ways-to-clone-an-object-in-c-d1374ec28efa?source=collection_archive---------0-----------------------#2021-01-10">https://levelup.gitconnected.com/5-ways-to-clone-an-object-in-c-d1374ec28efa?source=collection_archive---------0-----------------------#2021-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="728c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">各有利弊</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/85937d7abe61214ae15ee8680472049d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_5DlCw66bB1_e2dk"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@ammar_sab3?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ammar sabaa </a>拍摄</figcaption></figure><p id="df30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个软件工程师的成熟度是由很多因素决定的，比如算法知识、分析思维、大局观、调试技巧等等。此外，在我看来，以下两个因素很重要:</p><ul class=""><li id="8760" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">一个软件工程师知道解决同一个问题的几种方法。</strong></li><li id="da81" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">软件工程师在分析利弊的基础上选择一种方法。</li></ul><p id="8c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助你变得更加成熟，我总结了5种用C#克隆对象的方法，并准备了每种方法的优缺点。</p><p id="4858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将使用两个简单的类Person和Address。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">人员和地址分类</figcaption></figure><p id="73e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但在我们开始之前，我想提醒你一个. NET中的浅拷贝和深拷贝概念，浅拷贝有自己的值类型，但它与原对象共享引用类型。深层副本有自己的值和引用类型，也就是说，它与原始对象完全断开连接。软件工程师可以简单地通过调用MemberwiseClone方法来创建浅层副本，但是深层副本需要编写一些额外的自定义代码。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9dea" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">可克隆接口</h1><p id="5765" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">克隆对象的第一种方法就是简单的实现. NET提供的Icloneable接口，这个接口有一个单独的Clone方法，在这个方法里面我们应该调用object类的MemberwiseClone方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">可克隆接口实现</figcaption></figure><h2 id="bc78" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">优点:</h2><ul class=""><li id="547a" class="lv lw it lb b lc nk lf nl li ob lm oc lq od lu ma mb mc md bi translated">不需要定义自己的接口。</li><li id="568e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">完全控制我们克隆的东西。假设Person类包含用于审计目的的AccountHistory属性。当克隆一个人对象时，我们可能需要一个空的帐户历史。这样的需求可以用如下代码来表达:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">自定义可克隆接口实现</figcaption></figure><h2 id="3e61" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">缺点:</h2><ul class=""><li id="64ca" class="lv lw it lb b lc nk lf nl li ob lm oc lq od lu ma mb mc md bi translated">方法克隆返回对象类型。调用代码必须将对象转换为特定的数据类型。</li><li id="c793" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">必须为对象图中包含的每个类实现ICloneable接口。</li><li id="4eac" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">接口或方法名并不告诉调用者返回的是深层副本还是浅层副本。软件工程师需要钻研实现细节。</li></ul><p id="0c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔔<a class="ae ky" href="https://esashamathews.medium.com/subscribe" rel="noopener"> <strong class="lb iu">现在就订阅</strong> </a> <strong class="lb iu">，所以大家不要错过我接下来的文章。</strong></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="e0b1" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">自定义接口IPrototype</h1><p id="4aa9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为什么不创建自己的通用接口，而不是使用ICloneable？我们的自定义界面可以修复几个不可避免的问题。</p><p id="3019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们调用自定义接口IPrototype，并在其中定义一个CreateDeepCopy方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">自定义IPrototype接口</figcaption></figure><h2 id="0b60" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">优点:</h2><ul class=""><li id="c110" class="lv lw it lb b lc nk lf nl li ob lm oc lq od lu ma mb mc md bi translated">方法名CreateDeepCopy准确地描述了它的用途。</li><li id="6a6c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">IPrototype接口的使用者不再需要强制转换CreateDeepCopy方法的返回类型。</li><li id="433d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用ICloneable界面完全控制我们克隆的内容。</li></ul><h2 id="e0a3" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">缺点:</h2><ul class=""><li id="6f3d" class="lv lw it lb b lc nk lf nl li ob lm oc lq od lu ma mb mc md bi translated">接口必须由软件工程师手动定义。</li><li id="42f6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">必须为对象图中包含的每个类实现一个接口。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b9a6" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">二进制序列化</h1><p id="cddb" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">二进制序列化帮助您在不实现接口的情况下克隆对象。想法很简单——将对象图序列化到内存中，然后反序列化回对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">克隆对象的二进制序列化</figcaption></figure><h2 id="b115" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">优点:</h2><ul class=""><li id="4699" class="lv lw it lb b lc nk lf nl li ob lm oc lq od lu ma mb mc md bi translated">不再需要实现接口。</li><li id="15b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不管对象有多复杂，都会被完全克隆。</li><li id="5c4d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">克隆逻辑存在于一个地方。</li></ul><h2 id="52c5" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">缺点:</h2><ul class=""><li id="2ae0" class="lv lw it lb b lc nk lf nl li ob lm oc lq od lu ma mb mc md bi translated">类Person和所有相关的都需要用[Serializable]属性标记。</li><li id="d7eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">浅拷贝和深拷贝之间没有选择。使用序列化时，软件工程师只能使用深度复制选项。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="4d08" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">XML序列化</h1><p id="e62e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">XML序列化是二进制序列化的一种有趣的替代方法。以下代码示例与上一个非常相似，只做了一行调整:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">克隆对象的XML序列化</figcaption></figure><p id="e2fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">XML序列化不需要[Serializable]属性，这是个好消息。但是，XML序列化要求每个类都有一个无参数的构造函数。这样的要求看似无害，但事实并非总是如此。在Person类中拥有无参数的构造函数意味着可以在没有名字、姓氏等的情况下创建实例。我更喜欢在创建对象时设置所有必需的属性，以避免部分初始化对象。所以XML序列化在很多情况下对我不适用。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="ee52" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">复制构造函数</h1><p id="278c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">复制构造函数是一个简单的构造函数，带有一个封闭类类型的参数。在构造函数内部，我们只是逐个重新初始化对象的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">复制构造函数以克隆对象</figcaption></figure><h2 id="0b88" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">优点:</h2><ul class=""><li id="ccdf" class="lv lw it lb b lc nk lf nl li ob lm oc lq od lu ma mb mc md bi translated">完全控制我们克隆的东西。</li></ul><h2 id="cec7" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">缺点:</h2><ul class=""><li id="a19e" class="lv lw it lb b lc nk lf nl li ob lm oc lq od lu ma mb mc md bi translated">复制构造函数必须在对象图中包含的每个类中实现。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c6ea" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">最后的想法</h1><p id="f171" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">接口和复制构造函数使软件工程师能够完全控制克隆过程。基于串行化的克隆技术减轻了软件工程师每次修改对象图时调整克隆逻辑的需要。</p><p id="0391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，没有灵丹妙药，所以我们软件工程师需要仔细分析每一个特定的案例，并选择最合适的解决方案，考虑其利弊。</p><p id="6f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在给你一个小任务，亲爱的读者:我跳过了什么克隆方法？</p><p id="0e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="cceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉订阅我的<a class="ae ky" href="https://t.me/sd_daily" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">软件开发日报</strong> </a>电报频道，从我这里获取实用的编程技巧，供您日常工作使用。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="f179" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">分级编码</h1><p id="9489" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">感谢您成为我们社区的一员！升级正在改变技术招聘。<a class="ae ky" href="https://jobs.levelup.dev/talent" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">在最好的公司</strong>找到你最理想的工作 </a> <strong class="lb iu">。</strong></p><div class="oe of gp gr og oh"><a href="https://jobs.levelup.dev/talent" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">提升——改变招聘流程</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">🔥让软件工程师找到他们热爱的完美角色🧠寻找人才是最痛苦的部分…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">作业. levelup.dev</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div></div></div>    
</body>
</html>