<html>
<head>
<title>You Don’t Know Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不知道Node</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/you-dont-know-node-ecdad3b6eb47?source=collection_archive---------2-----------------------#2017-10-25">https://levelup.gitconnected.com/you-dont-know-node-ecdad3b6eb47?source=collection_archive---------2-----------------------#2017-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2649506b389b7738201d2eca1ca54efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Nq1fQSPq9aeoWxn4WFbhg.png"/></div></div></figure><div class=""/><p id="5019" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很长一段时间，当我想到服务器端语言时，JavaScript不在其中。虽然它在很大程度上是当今使用的最流行的编程语言之一，而且功能强大得令人难以置信，但我认为它严格来说是一种浏览器语言——后来我发现了Node。</p><p id="8df2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Node建于2009年，是一个服务器端JavaScript环境。那么什么是<em class="kw">节点呢？网站本身的官方定义如下:</em></p><blockquote class="kx ky kz"><p id="dfa3" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">Node.js是建立在<a class="ae ld" href="https://developers.google.com/v8/" rel="noopener ugc nofollow" target="_blank"> Chrome的V8 JavaScript引擎</a>之上的JavaScript运行时。Node.js使用事件驱动的非阻塞I/O模型，这使它变得轻量级和高效。Node.js的包生态系统，<a class="ae ld" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>，是世界上最大的开源库生态系统。<em class="jb">—</em><a class="ae ld" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"><em class="jb">node . js Foundation</em></a></p></blockquote><p id="4172" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷毙了。但是这意味着什么呢？让我们把它分解一下。</p><h2 id="59d6" class="le lf jb bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">事件驱动编程:</h2><p id="8cf0" class="pw-post-body-paragraph jy jz jb ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">在Node中，我们在一个称为“事件循环”的架构中工作，这是Node如何通过使用一系列事件侦听器来处理高吞吐量场景，这些事件侦听器在检测到事件时执行回调；这些回调可以是同步的，也可以是异步的。如果这听起来仍然像基本的JavaScript，很好——确实如此。对于React.js的任何用户来说，下面的定义听起来都非常熟悉:</p><blockquote class="kx ky kz"><p id="5424" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">事件驱动编程是由事件或状态变化决定的应用程序流控制。— <a class="ae ld" href="http://nodesource.com/blog/understanding-the-nodejs-event-loop/" rel="noopener ugc nofollow" target="_blank"> <em class="jb">特雷弗·诺里斯；理解Node.js事件循环'</em> </a></p></blockquote><p id="862c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与浏览器中使用事件监听器如<code class="fe mc md me mf b">.onclick()</code>或<code class="fe mc md me mf b">.onsubmit()</code>的普通JavaScript相比，Node使用了<code class="fe mc md me mf b">EventEmitter</code>模块:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d50f" class="le lf jb mf b gy mo mp l mq mr">const EventEmitter = require('events');</span></pre><p id="68ce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">节点对象(即套接字、服务器、流、HTTP请求等。)通过<code class="fe mc md me mf b">Event Emitter</code>的实例发出事件。值得注意的是，节点的内置模块<em class="kw">继承了<code class="fe mc md me mf b">EventEmitter</code>的</em>，而定制模块需要成为<em class="kw">扩展</em>的类。下面是一个常见的例子:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d8d5" class="le lf jb mf b gy mo mp l mq mr">class MyEmitter extends EventEmitter {<br/>  //enter some emitter functionality here<br/>}</span></pre><p id="8a24" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们实例化发射器对象，并使用<code class="fe mc md me mf b">.emit</code>函数来指示要发射的事件。例如，我们可以使用一个定制的事件发射器<code class="fe mc md me mf b">WithLog</code>和<code class="fe mc md me mf b">.on()</code>监听器来监听一个控制台日志，一旦检测到想要记录的字符串(即‘Hello World’)，它将执行一个回调函数(即console . log(‘Hello to You Too！’)).</p><p id="4f4d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种事件驱动编程是Node比传统的服务器端语言(如Ruby、Python或Perl)更快的主要原因之一。</p><p id="9b4f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，我们应该绝对清楚，尽管Node通过异步事件促进了并发性，并且具有高度可伸缩性，但它仍然被认为是<em class="kw">单线程</em>。正如之前的文章所讨论的，并发仅仅是构建结构来<em class="kw">促进</em>并行和多线程。与其他原生支持多线程的语言(比如Ruby)相比，这可能是一个缺点。也就是说，让我们通过Node的另一个主要方面来进一步探索这种并发性:</p><h2 id="345f" class="le lf jb bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">非阻塞I/O模式:</h2><p id="2775" class="pw-post-body-paragraph jy jz jb ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">Node.js构建在几个依赖项之上。首先，我们将参考<a class="ae ld" href="https://github.com/libuv/libuv" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> libuv </em> </a>，这是一个跨平台的库，<em class="kw">抽象了运行它的设备的操作系统所支持的</em>异步输入/输出调用。这使得Node可以在单个执行流中处理成千上万个异步调用，看起来像是同步的，而不是并行的。</p><p id="76a4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以把它想象成一只非常非常擅长多任务处理的章鱼。它有有限数量的手臂，但可以分散注意力，协调各种任务之间的行动和时间，而不会错过任何一步。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="97c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们提到非阻塞时，我们指的是一种算法，它可以执行它的功能，而不会阻塞线程和阻止其他任务执行，直到它完成；<em class="kw">这个</em>是异步函数的美妙之处，它使得JavaScript比传统的服务器端编程语言更快更强大。</p><p id="5689" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举一个非常简单的例子，假设我们用一个工作站和一个一次只能放一层烤盘的烤箱烘烤一个分层蛋糕。这是一个极其复杂的过程，需要注意力、时间和几个步骤的协调。在为蛋糕制作面糊并将底层平底锅放入烤箱烘烤后，我们现在必须等待一段时间——但是，我们也有一个凌乱的工作站，有面糊碗、勺子、碎蛋壳等。因为我们只有这么大的工作空间，而且我们知道一旦蛋糕烤好了，我们需要用这些空间来装饰蛋糕<em class="kw">和</em>我们需要把下一个平底锅放进去，我们可以通过多任务来节省时间。我们将第一层放入烤箱烘烤，在烘烤的同时，清理工作台，洗碗，只留下必要的装饰和糖霜材料。一旦这一层完成，我们将插入下一层，并重复这一过程，直到所有被清理和完成！</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/497a2432671df3b1c9ff6fe663e0c150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*mARV_dYY8MOTI2MyI02rew.gif"/></div></figure><p id="d28f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也是Node为服务器端应用程序处理和执行事件的方式。这也使我们能够最大限度地利用CPU和内存。</p><p id="4b83" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么Node.js和JavaScript有什么区别呢？记住，<em class="kw"> JavaScript是一种编程语言</em>。Node是一个<em class="kw"> JavaScript </em> <em class="kw">运行时环境</em>，使用V8引擎(谷歌Chrome的引擎)和几个库依赖来处理事件驱动的非阻塞I/O。而在浏览器中，我们使用JavaScript来修改网页(文本、图形、样式表等)，<em class="kw"> Node </em>使我们能够在浏览器外使用JavaScript来创建shell脚本并在硬件上运行，以便我们可以创建服务器或操作文件。</p></div></div>    
</body>
</html>