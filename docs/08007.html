<html>
<head>
<title>Backend-to-Backend Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后端到后端通信</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/backend-to-backend-communication-d9fe85234ead?source=collection_archive---------11-----------------------#2021-03-28">https://levelup.gitconnected.com/backend-to-backend-communication-d9fe85234ead?source=collection_archive---------11-----------------------#2021-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8071" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何分布式系统都解决了在其不同的组件(前端或后端)之间共享信息的问题。在本文中，我将重点关注在不同的后端之间建立通信。为了让读者从各个角度理解这个概念，我概述了交流的原因、目标和方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f8a59555e3b2bf1d69252af2329387f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LWCsRAk-edrFjEaX"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">帕万·特里库塔姆在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="1368" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">交流的原因</h1><p id="8b06" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">由于以下原因，后端必须到达分布式系统中的其他后端:</p><ul class=""><li id="92af" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">一个<em class="mo">显式用户动作</em>(有时充当他们的代理)，</li><li id="c7b1" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated">一个<em class="mo">隐式系统操作</em>(例如周期性任务)。</li></ul><p id="ed26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据经验，用户操作<em class="mo">比系统操作<em class="mo">需要更少的权限。如果可行的话，后端应该只使用相关用户的权限在不同的服务上执行命令。</em></em></p><p id="dad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，下图显示了在线游戏中的示例性<em class="mo">用户动作</em>，其中<em class="mo">用户</em>可以向<em class="mo">游戏后端</em>发送命令以离开特定游戏。接受命令后，<em class="mo">会话后端</em>需要请求<em class="mo">通知后端</em>通知其他游戏参与者用户已经离开，因为前者没有发送通知的能力。热心的读者可能会指出<em class="mo">会话后端</em>应该对通知一无所知；另一方面，这样的关注点分离需要切换到基于<em class="mo">事件的</em>或基于<em class="mo">命令的</em>架构。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/cedad6e795703f6264baac20fb922e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*kPw2CGghILSQwoFsxu49TQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">(显式)用户操作的示例。使用PlantUML创建。</figcaption></figure><p id="52e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，下图显示了一个由<em class="mo">代理的用户动作</em>的例子。<em class="mo">用户</em>可以从<em class="mo">游戏后端</em>请求关于特定游戏的信息，游戏后端需要先从<em class="mo">用户后端</em>收集数据来完成请求。<em class="mo">游戏后端</em>可以获取用户信息，其权限仅限于所述<em class="mo">用户</em>的权限。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/0fd2a2b2bcb7b9e31c91a04832f4efac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*sCq1MKWbbLfGj2GGcTcqLA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">代理用户操作的示例。使用PlantUML创建。</figcaption></figure><p id="8a31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，下图说明了一个典型的<em class="mo">预定系统操作</em>。<em class="mo">调度器</em>周期性地请求<em class="mo">会话后端</em>注销所有不活动的用户，这迫使前述后端请求<em class="mo">通知后端</em>通知所有游戏的参与者关于终止的会话。澄清一下，<em class="mo">会话后端</em>并不充当代理，因为没有物理用户执行<em class="mo">调度程序</em>，而正是这个系统执行了调度程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e8c7404c7ebd16e39f0ec69a486023cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*jik6rvpH6HV8HZ-LNQIdiw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">(隐式)系统操作的一个例子。使用PlantUML创建。</figcaption></figure><h1 id="ae8e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">沟通的目标</h1><p id="a3d9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在下列情况下，后端需要向其他后端发送消息:</p><ul class=""><li id="b089" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">他们需要从他们那里得到一些信息，</li><li id="5d6c" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated">他们想要改变另一个系统组件的状态。</li></ul><p id="7e60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管有人认为<em class="mo">不可变操作</em>比<em class="mo">可变操作</em>更安全，但是<em class="mo">被调用者</em>无论如何都应该验证<em class="mo">调用者</em>的权限。同样，有问题的系统可能不允许某些用户访问特定信息。</p><p id="40fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，<em class="mo">会话后端</em>可能会向<em class="mo">认证后端</em>询问令牌有效性，如下图所示。验证令牌是不可变请求的最基本的例子，因为这样的操作要么确认要么否定有效性，仅此而已。不可变请求不会产生分布式事务的问题，因为即使它们失败了，也没有任何更改需要回滚。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/bf2e96c2594d2c0de570ae6c734fdaee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJNRCvIMsANlfhv7WQOCfg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">不可变操作的一个例子。使用PlantUML创建。</figcaption></figure><p id="f368" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，用可变命令设计系统需要关于分布式事务的基本知识。这样的事务可能跨越多个微服务，从而触发许多容易出错的操作。即使一个操作失败，系统也需要:</p><ul class=""><li id="c077" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">取消剩余操作执行的更改，或</li><li id="ca4e" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated">提交由剩余操作进行的更改，并执行一个<em class="mo">补偿操作。</em></li></ul><p id="547b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">软件开发人员可以使用<em class="mo">两阶段提交协议</em>在多个服务上回滚变更。该协议假设服务之间的稳定通信、它们的运行时稳定性(无崩溃)以及所述服务使用的相关数据库的原子性。该算法要求一个服务充当<em class="mo">分布式事务协调器</em>，它管理提交的两个阶段:</p><ul class=""><li id="2b11" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><em class="mo">投票</em>阶段——当协调器告诉每个服务提交什么，并且它们以成功或失败来响应时，</li><li id="4d79" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated"><em class="mo">提交</em>阶段——协调器收集投票并要求所有服务提交或回滚。</li></ul><p id="4fe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于外部系统的原因，完成某些交易所需的时间可能会超过几分钟。这种<em class="mo">长时间运行的事务</em>，由于它们不能依赖两阶段提交协议，所以当失败发生时，使用<em class="mo">补偿事务</em>。例如，如果用户预订了一张音乐会门票并已付款，而音乐会主持人没有在指定的时间范围内确认该门票，系统需要通知用户该问题，取消该门票并退款，如下所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/49babddf966c12e209109d78a3cea280.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*rxKqC3aI0SaKLcS5kIFUfg.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">一个长时间运行的事务的例子。使用PlantUML创建。</figcaption></figure><h1 id="92ff" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">交流的方法</h1><p id="2120" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">后端可以使用以下方式与其他后端通信:</p><ul class=""><li id="211d" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">显式和同步消息(例如，通过HTTP请求)，</li><li id="5ecb" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated">隐式和异步消息(例如，通过基于事件的系统)。</li></ul><p id="5db0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论选择何种通信方法，每条消息都应包含一条信息，以便能够识别发送者。即使后端使用隔离的子网进行数据交换，了解消息的来源也有助于在整个系统中实施<em class="mo">访问控制</em>。</p><p id="73a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优先考虑速度的系统，比如关注点分离，可能更喜欢使用<em class="mo">同步消息</em>，特别是对于不可变的操作。对于HTTP，服务可能使用CDN ( <em class="mo">内容交付网络</em>)或其他缓存层调用<em class="mo">等幂</em>端点，从而随着时间的推移更快地获得结果。使用同步消息意味着在接收方做出响应之前，调用方一直处于阻塞状态；在一个线程后端同时阻塞太多线程可能会阻止整个实例接受新连接。</p><p id="98d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于命令或基于事件的系统使用<em class="mo">异步消息</em>，这意味着后端可能会向消息管道发送一个命令(或一个事件)供其他后端进一步处理，如下所示。系统最终会处理这样的消息，但是原始发送者从不明确地等待任何结果。使用消息驱动的系统允许服务解耦，因为具有特定功能的后端不需要知道彼此的存在。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/e220b233a4b1d6f39e8b51bd1b3e3165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r8_W1DPZ-hd2UHz_8pzVZQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">基于命令的系统的一个例子。使用PlantUML创建。</figcaption></figure><h1 id="b53f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="a165" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">随着现代软件开发抛弃了单片后端，转而支持微服务，从而支持分布式系统，软件专业人员需要建立后端到后端的通信。这种通信有多种方式，取决于将两个服务连接在一起的确切原因和要实现的目标。我发现理解这一点很重要，一旦开发人员在两个后端之间建立了通信，迁移到不同的信息交换方法可能会使整个系统设计颠倒过来。</p></div></div>    
</body>
</html>