<html>
<head>
<title>Per My Last Comment: Creating Reply Threads in Your React/Rails App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据我最后的评论:在React/Rails应用程序中创建回复线程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/per-my-last-comment-creating-reply-threads-in-your-react-rails-app-d8334a00dfa1?source=collection_archive---------3-----------------------#2020-05-11">https://levelup.gitconnected.com/per-my-last-comment-creating-reply-threads-in-your-react-rails-app-d8334a00dfa1?source=collection_archive---------3-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/08280bbce8db0f0cebe47930823269ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*puHPS0RYtKkfO0OiRimVyw.jpeg"/></div></div></figure><p id="5a32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近一直在为我正在构建的社区论坛web应用程序添加更多功能，并发现自己希望让用户能够对帖子添加评论。在引入回复和线程响应的概念之前，这似乎是一个非常简单的任务。然后Rails模型和React组件呈现变得有点棘手。这篇文章将带您了解我的全栈实现，后端使用Rails，前端使用React，组件样式使用Ant Design。我们开始吧🎉！</p><h2 id="9eec" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">设置这些模型</h2><p id="ccba" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">你需要做的第一件事是设计出你的模型。对于这个功能，我有一个<strong class="ka ir">帖子</strong>、<strong class="ka ir">用户</strong>和<strong class="ka ir">评论</strong>模型。帖子和用户都有很多评论，一个评论属于一个帖子。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9eb6" class="kw kx iq lz b gy md me l mf mg">class Post &lt; ApplicationRecord<br/>  has_many :comments, dependent: :destroy<br/>end</span><span id="b3eb" class="kw kx iq lz b gy mh me l mf mg">class User &lt; ApplicationRecord<br/>  has_many :comments, dependent: :destroy<br/>end</span><span id="3acd" class="kw kx iq lz b gy mh me l mf mg">class Comment &lt; ApplicationRecord<br/>  belongs_to :post<br/>  belongs_to :user<br/>end</span></pre><p id="bd8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">❗️Curious关于那个<strong class="ka ir">依赖::摧毁</strong>选项？它确保如果这个帖子或用户被删除，他们的评论也会被删除。关于<strong class="ka ir">依赖</strong>选项的实现，请阅读Rails文档<a class="ae mi" href="https://guides.rubyonrails.org/association_basics.html#dependent" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h2 id="6e60" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创建回复关系</h2><p id="9c29" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">接下来，我们需要定义<em class="mj">回复</em>的关系。这实质上是在两个注释之间创建了一个<strong class="ka ir">自连接</strong>关系。在这种情况下，一个评论可以有很多回复，但是一个回复应该只属于一个评论。根据has_many/belongs_to，一个评论可以有多个回复(或子评论)，一个回复(或子评论)必须属于一个评论(或父评论)。</p><p id="3036" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了建立这种关系，我们需要在comments表上存储一个外键，该外键引用原始评论的主键。我选择将我的列命名为parent_id。如果注释表中的记录具有parent_id的值，则表明它是对主键与parent_id匹配的注释的回复。或者，如果记录没有parent_id的值，则推断这是顶级注释(或原始注释)。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="330f" class="kw kx iq lz b gy md me l mf mg">| id | text                 | user_id | post_id | parent_id</span><span id="ef40" class="kw kx iq lz b gy mh me l mf mg"><strong class="lz ir">------------------------------------------------------------</strong></span><span id="4aac" class="kw kx iq lz b gy mh me l mf mg">|  1 | 'original comment'   |  3      | 12      | null</span><span id="fdd4" class="kw kx iq lz b gy mh me l mf mg">|  2 | 'reply to comment 1' |  6      | 12      | 1</span><span id="06e2" class="kw kx iq lz b gy mh me l mf mg">|  3 | 'reply to the reply' |  3      | 12      | 2</span></pre><p id="2618" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，第二条记录是第一条注释的子记录，也是第三条注释的父记录🤯。</p><p id="15ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然数据库设置正确，我们需要更新我们的<strong class="ka ir">评论</strong>模型来反映评论之间的关系。为此，我们将告诉ActiveRecord在comments表上创建一个自连接，并将其引用到parent_id外键。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c7b0" class="kw kx iq lz b gy md me l mf mg">class Comment &lt; ApplicationRecord<br/>  belongs_to :post<br/>  belongs_to :user</span><span id="3fd6" class="kw kx iq lz b gy mh me l mf mg">  belongs_to :parent, class_name: 'Comment', optional: true<br/>  has_many :replies, class_name: 'Comment', foreign_key: :parent_id, dependent: :destroy</span><span id="9fab" class="kw kx iq lz b gy mh me l mf mg">end</span></pre><p id="73b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们一个论点一个论点地分析这里发生的事情:</p><ol class=""><li id="7390" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">首先，我们在Comment类上创建一个实例变量<strong class="ka ir"> parent </strong>。默认情况下，ActiveRecord将使用这个名称和append _id，并将其用作SQL连接的外键。所以实际上，我们都在创建实例方法<em class="mj">和</em>来创建parent_id上的连接。</li><li id="10c2" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">第二，默认情况下，ActiveRecord将从第一个参数中查找具有复数名称的表。由于没有父表，我们需要通过指定class_name来覆盖这个默认行为。这里我们告诉ActiveRecord将外键与comments表上的主键相关联。</li><li id="9f1c" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">最后，我们允许这种关系是可选的。原因是注释可能没有父级。记住，一个评论可以有很多回复，也可以属于一个父评论。如果我们不包含可选的:true参数，我们将<em class="mj">只有</em>能够创建回复，而不能创建顶级父项(即原始评论)😨。</li></ol><p id="4c06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当设置回复的has_many端时，我们经历了相同的步骤，只有一个例外➡️，我们必须显式地指定外键来进行连接，因为没有reply_id列，也不应该有。孩子应该记录这段关系，而不是父母。这意味着parent_id应该存储在回复中。你现在当然知道了，但只是想再确认一下😉。</p><p id="141e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">❗️Pro-tip:，在继续前进之前，一定要测试你的人际关系！我总是告诉我的学生:在你建立了你的关系之后，跳进<strong class="ka ir"> rails控制台</strong>并使用一些实例来确保你得到了你想要的数据。</p><p id="2a2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我在一个post实例上调用<code class="fe my mz na lz b">#comments</code>时，我现在能够在一个数组中获得所有的评论和回复。这是预期的结果。我们将在下一节讨论如何以嵌套格式显示这些注释。</p><p id="492c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，您需要设置Rails路线和控制器动作。我不打算在这里深入讨论，因为我不想让它变得太长，而且设置应该非常简单。很高兴在评论区回答这方面的问题！</p><h2 id="c1e6" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">使用React和Ant设计进行渲染</h2><p id="18de" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让我们来谈谈React组件！现在我们已经有了我们想要的数据，是时候以一种对用户有意义的方式显示它了。这意味着React组件相互嵌套。对于样式，我将使用Ant设计库——特别是<a class="ae mi" href="https://ant.design/components/comment/" rel="noopener ugc nofollow" target="_blank">注释组件</a>。</p><p id="f7e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，为了渲染这个:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/18f79e5fa0767b7624f4cb573858d81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3xdWNC3N78O1WFyVipj-A.png"/></div></div></figure><p id="4d78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须将父组件包装在其子组件上，如下所示:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/ef8aadf2ab46ea7d253b84c77c88ad28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DG3DucbLUoY64RJ67ov-XA.png"/></div></div></figure><p id="b2af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的第一个问题是:我们如何知道嵌套评论的深度？出于我的应用程序的目的，我选择不限制嵌套回复的数量(为了可读性，我可能会在以后更新)。我确信这个问题可以迭代解决，但是我决定采用<em class="mj">递归</em>。</p><p id="9966" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了CommentsContainer组件。在这里，我可以访问特定帖子的评论数组，并通过映射来呈现每个帖子的MyComment组件。</p><p id="7ce2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我过滤掉顶级父注释(即parent_id值为空的注释)并映射到数组上，为每个注释呈现我的自定义MyComment组件。这个注释组件需要接受一个注释对象和完整的注释数组，作为下一步工作的道具:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="13a7" class="kw kx iq lz b gy md me l mf mg">getParentComments().map(c =&gt; &lt;MyComment <em class="mj">key</em>={c.id} <em class="mj">comment</em>={c} <em class="mj">allComments</em>={comments} /&gt;)</span></pre><p id="37bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">真正的动作发生在MyComment组件中。使用传入的comment和allComments属性，我进行过滤以确定这个特定的注释是否有任何子元素。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="242a" class="kw kx iq lz b gy md me l mf mg">childComments = () =&gt; {<br/>  const { comment, allComments } = this.props<br/>  return allComments.filter(c =&gt; c.parent_id === comment.id)<br/>}</span></pre><p id="7f75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在MyComment的return语句中，我调用Ant Design Comment组件。在JSX之间，我映射从childComments方法调用返回的数组，并再次递归调用MyComment:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ed64" class="kw kx iq lz b gy md me l mf mg">&lt;AntComment<br/>  <em class="mj">author</em>={&lt;p&gt;{comment.user.name}&lt;/p&gt;}<br/>  <em class="mj">content</em>={&lt;p&gt;{comment.text}&lt;/p&gt;}<br/>  <em class="mj">datetime</em>={displayPostDate(comment.created_at)}<br/>&gt;<br/>  {<br/>    this.childComments().map(c =&gt; (<br/>      &lt;MyComment<br/>        <em class="mj">key</em>={c.id}<br/>        <em class="mj">comment</em>={c}<br/>        <em class="mj">allComments</em>={allComments}<br/>      /&gt;<br/>    ))<br/>  }<br/>&lt;/AntComment&gt;</span></pre><p id="9d44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当childComments方法返回一个空数组时，递归调用停止(或到达一个基本用例)。在这种情况下，嵌套在AntComment组件中的内容是空的。下面是最终的重构代码:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="657a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是注释按照我想要的顺序嵌套在各自的父注释下:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/85ec4dff0a5f966dd3407a6b0aee99b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCvF7cxbtzfvjA5ZPmLSew.png"/></div></div></figure><p id="90f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这有帮助！请让我知道你对我下面的实现的想法，和/或如果有任何事情我可以更好地澄清或深入探讨。编码快乐，❤️人！</p><p id="5473" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更新:</strong>我最终将Comment.js转换成一个类组件来处理回复，但是我想分享一下函数式方法，因为它用最少的代码展示了主要的解决方案。</p></div></div>    
</body>
</html>