<html>
<head>
<title>Scroll to a newly added DOM element</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">滚动到新添加的DOM元素</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scroll-to-newly-added-element-63d1b093b53d?source=collection_archive---------3-----------------------#2021-11-27">https://levelup.gitconnected.com/scroll-to-newly-added-element-63d1b093b53d?source=collection_archive---------3-----------------------#2021-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dd44369831d74a1b73317cd9fc68283d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rkINuIqHTjILA0SG"/></div></div></figure><p id="26d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前提——父组件根据某个本地状态呈现子组件，我们希望滚动到第一个新呈现的子组件。</p><p id="dd69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TLDR:这里有一个<a class="ae kw" href="https://codesandbox.io/s/nifty-mendel-8diiq?file=/src/App.js:1001-1029" rel="noopener ugc nofollow" target="_blank">链接</a>到codesandbox。</p><p id="0f09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看下面的父组件——现在，它什么都做，除了滚动部分。它有一个“添加项目”按钮，当按下该按钮时，将向项目的现有状态添加10个以上的项目:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="8871" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要实现这一目标，我们需要两条关键信息:</p><ol class=""><li id="4f4e" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">这些新添加项目中第一个项目的索引</li><li id="ffe4" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">我们希望滚动到的项目已经安装的事实</li></ol><h1 id="6150" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">第一个新添加项目的轨道索引</h1><p id="ea90" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">为此，我们将使用<code class="fe mu mv mw mx b">useRef</code> hook，它给出了一个实例变量，我们可以用它来存储渲染之间的值。然后，当我们将新闻条目添加到<code class="fe mu mv mw mx b">items</code>状态变量时，我们将测量<code class="fe mu mv mw mx b">previousItems</code>的长度，它是我们在传递给<code class="fe mu mv mw mx b">setItems</code>的回调函数中作为参数接收的。如果我们将<code class="fe mu mv mw mx b">+1</code>加到这个长度上，我们将得到最近添加的第一个条目的索引:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="a060" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">在挂载时滚动到新项目</h1><p id="ec06" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">要滚动到项目，我们实际上需要打开我们为处于<code class="fe mu mv mw mx b">items</code>状态的每个项目呈现的<code class="fe mu mv mw mx b">element</code>，我们需要这样做，因为我们需要挂钩到它自己的生命周期，即跟踪它何时被挂载。</p><p id="5cc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个组件被添加到真实的dom中时，它被认为是挂载的(当您打开开发工具时，您可以看到它，并且可以在“Elements”选项卡中找到一个表示该组件的DOM节点)。</p><p id="2221" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在基于类的组件中，我们将使用<code class="fe mu mv mw mx b">componentDidMount</code>生命周期方法，但是在钩子的世界中，呈现项目的子组件将如下所示:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="66f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当渲染<code class="fe mu mv mw mx b">items</code>时，我们需要以某种方式告诉子组件的第一个“新”实例应该滚动到哪个视口。为此，我们将通过一个<code class="fe mu mv mw mx b">shouldScrollTo</code>如下:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="40d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们简单地比较我们正在渲染的项目是否具有与<code class="fe mu mv mw mx b">firstNewItemIndex</code>相同的<code class="fe mu mv mw mx b">index</code>，以告诉<code class="fe mu mv mw mx b">Child</code>实例它应该在具有<code class="fe mu mv mw mx b">mounted</code>之后滚动到。</p><p id="0478" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要使用<code class="fe mu mv mw mx b">shouldScrollTo</code>来实际滚动，我们这样做如下:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="b3cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每次添加新项目时，应用程序都会自动滚动到最近添加的第一个项目。</p></div></div>    
</body>
</html>