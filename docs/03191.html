<html>
<head>
<title>Infinite Board for Drag-And-Drop Notes using Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无限板的拖放笔记使用角</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/infinite-board-for-drag-and-drop-notes-using-angular-6e2e1280b383?source=collection_archive---------9-----------------------#2020-04-24">https://levelup.gitconnected.com/infinite-board-for-drag-and-drop-notes-using-angular-6e2e1280b383?source=collection_archive---------9-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="76a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">界面、转换、缩放和方法…</p><p id="5789" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你好。在过去的几天里，我一直在做一个项目，我必须实现一个无限白板并放置便签。这个想法是建立一个可以无限滚动的组件。用户应该能够在这个无限空间的任何地方拖放部件。此外，添加缩放工具会变得非常有趣，这是一个方便的工具。在构建这个项目的过程中，我学到了很多关于转换和扩展机制的知识。请继续阅读，了解如何从头开始构建它！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8c30a42536065ef4b32e1a9ae1746e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*emTJ8NWlZCnjIm9Y2-RCrw.gif"/></div></div></figure><p id="c508" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">组件故障</strong></p><p id="a458" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从决定需要什么模型和组件开始。显然，有两件事是显而易见的:需要<em class="la">注释</em>来表示可拖动的小部件，需要<em class="la">面板</em>来包装里面的所有东西。看看我们的无限拖放空间的目标，我们的<em class="la"> Notes </em>容器应该自己扩展，<em class="la"> Board </em>应该允许我们滚动到大白板的任何区域。这可以通过添加另一个中间包装器组件来实现:<em class="la">背景。</em>该组件将在需要时展开，从而给人一种无限的空间体验。</p><p id="83b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们最终的组件结构，以自下而上的方式，将是:</p><ol class=""><li id="5144" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">注意:这是一个可拖动的小部件。</li><li id="e3a9" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">背景:这包含所有节点。默认情况下，它占据其父<em class="la">板</em>宽度和高度的100%。当一个节点被拖到它外面时，它将会展开。</li><li id="1024" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">Board:所有其他组件的最外层包装。它的宽度和高度是固定的。当<em class="la">背景</em>展开时，滚动条会自动在<em class="la">面板</em>中触发。</li></ol><p id="7e6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如何实现无限空间效果？</strong></p><p id="be6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仔细观察，我们发现只有4种情况需要增加<em class="la">背景</em>的尺寸:向上、下、左、右四个方向溢出。这可以简单地通过跟踪被拖动的纸币的当前位置并检查它是否在背景的边界位置<em class="la">附近</em>来完成。如果是，根据需要增加宽度和高度。</p><p id="2969" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">增加宽度或高度将触发滚动条自动出现。</p><p id="97ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">鼠标位置如何缩放？</strong></p><p id="1145" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这实现起来有点棘手。我将给出一个有助于您开始的概述。当我们说我们想放大某一点时，我们想放大所有的东西。更准确地说，每个物体都相对于我们的“缩放中心”被放大了。或者，我们可以说每个点都从我们的ZoomCenter移开一定的距离。</p><p id="fe18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以通过使用以下公式转换我们的(x，y)值来实现:</p><blockquote class="lp"><p id="1aea" class="lq lr it bd ls lt lu lv lw lx ly kn dk translated">newX = zoom factor *(x-zoom center . x)+zoom center . x</p><p id="86d3" class="lq lr it bd ls lt lu lv lw lx ly kn dk translated">newY = zoom factor *(y-zoom center . y)+zoom center . y</p><p id="43c0" class="lq lr it bd ls lt lu lv lw lx ly kn dk translated">newWidth = zoomFactor*width</p><p id="b8e3" class="lq lr it bd ls lt lu lv lw lx ly kn dk translated">newHeight = zoomFactor*height</p></blockquote><p id="b1a4" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">不过，这里有一个陷阱。我们默认的缩放因子是1.0</p><p id="5c8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们想要放大时，我们把T2放大0.1倍</p><p id="3c4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们想要缩小时，我们将T4的缩放因子T5减少0.1</p><p id="3fe9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，假设我们放大到1.1。现在，当我们缩小时，我们的<em class="la"> zoomFactor </em>将变成1.0。根据我们上面的变换操作，没有发生任何变化，因为1.0的乘数不会改变任何东西。这可以通过在应用转换之前将我们的值重置为默认值来处理。</p><p id="afe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个变换可以简单地通过除以最后一个<em class="la"> zoomFactor </em>来重置。在使用上述规则应用转换之前，我们将使用以下转换来重置值:</p><blockquote class="lp"><p id="b5bd" class="lq lr it bd ls lt lu lv lw lx ly kn dk translated">x =((x-lastzoomcenter . x)/oldZoomFactor)+lastzoomcenter . x</p><p id="a810" class="lq lr it bd ls lt lu lv lw lx ly kn dk translated">y =((y-lastzoomcenter . y)/oldZoomFactor)+lastzoomcenter . y</p><p id="9d82" class="lq lr it bd ls lt lu lv lw lx ly kn dk translated">width = width/oldZoomFactor</p><p id="5293" class="lq lr it bd ls lt lu lv lw lx ly kn dk translated">height = height/oldZoomFactor</p></blockquote><p id="2328" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">就是这样。这应该让你去。</p><p id="5171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">型号、控制器和实用程序</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi me"><img src="../Images/7c4ed7d86e89b54f658113b441c661e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0sPE6hnhgE39t0QeWtaGQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">位置</figcaption></figure><p id="d51c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">位置<br/> </strong>一个简单的<em class="la">位置</em>模型将用于表示白板上的坐标。<br/>我们需要跟踪鼠标的移动，并在拖动过程中保持光标的初始和最终状态。这是通过创建一个<em class="la">鼠标控制器</em>来完成的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/f2a7085782a931dd37ce0ee31b4c52c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVzqPuhiZuF477HnANTN9A.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">鼠标控制器</figcaption></figure><p id="7bf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">鼠标控制器<br/>它帮助我们模拟鼠标的行为。这在逻辑上是通过保持最后的“<em class="la">鼠标按下</em>”坐标和存储当前的“<em class="la"/>”光标位置来实现的。此外，我们将只在“拖放”事件中使用这个控制器。这就是为什么我们有“<em class="la"> isPressed </em>”旗的原因。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mr"><img src="../Images/b8c9311f07cec08bf62193abc0260fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JU8rZgtyxNoPyrkB0rXURA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">注意</figcaption></figure><p id="073e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个注释总结了我们的文本材料的属性。我们将为这个模型提供一个控制器，用户大部分时间都可以直接与之交互。<br/>这里提供了一个小的DOM交互，只是为了方便通过<em class="la"> BoardController重新定位音符。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="2232" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我继续讨论最后一个组件之前:<em class="la"> NoteController </em>和<em class="la"> BoardController，</em>让我们分解一下我们的应用程序行为:</p><ol class=""><li id="30a2" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">拖放笔记:我们需要知道笔记的拖放起点。音符的位置将用于在屏幕上呈现音符。该操作可以使用上述<em class="la">位置、鼠标控制器、</em>和<em class="la">注释</em>来完成。但是，我们仍然需要告诉<em class="la"> Note </em>已经启动了“拖动事件”。这将通过<em class="la"> NoteController </em>完成，该控制器将在下面定义。</li><li id="5d1c" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">检测越界拖动:应该有一种方法来检测节点是否在“边界区域”,这样我们的<em class="la">背景</em>元素可以增加它的宽度或高度。</li></ol><p id="eaca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不需要有单独的角度分量来表示背景。它可以直接集成在<em class="la">板</em>组件HTML中。</p><p id="64af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">板控制器-通知控制器交互</strong></p><p id="b012" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个想法是将<em class="la"> NoteController </em>呈现为一个“传感器”元素，它将向<em class="la"> BoardController </em>发送拖放事件信号。所有<em class="la">票据</em>涉及票据定位和处理越界拖动的逻辑都在<em class="la"> BoardController </em>中定义。</p><p id="912c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是NoteController如何发送信号的概述。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/f01b77906569eaaa97b0d0f6e2d2b466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCuXFtA6sgEZUQ2iwmJISg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">注意控制器</figcaption></figure><p id="ceb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里<strong class="js iu">，</strong></p><ul class=""><li id="8572" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ms lh li lj bi translated"><strong class="js iu"> startDrag() </strong>在<em class="la"> mousedown </em>上被调用。</li><li id="47e0" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ms lh li lj bi translated"><strong class="js iu">拖()</strong>叫上<em class="la">鼠标移动</em><em class="la">。</em>它只是向<em class="la">板控制器</em>发送一个信号，表明<em class="la">这个</em>节点被拖动了。</li><li id="5d9f" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ms lh li lj bi translated"><strong class="js iu"> stopDrag() </strong>在<em class="la"> mouseup </em>上被调用。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/f6691375fa6482892eb312fba7cee680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StzzQLztOyezqZCCF0BC7w.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">电路板控制器</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mu"><img src="../Images/206d482ce5567d4ed635d40142c7c535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XB6Xexipuqh2JT9KVhspBQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">缩放处理器</figcaption></figure><p id="c1b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">BoardController处理所有的逻辑转换。此外，使用<strong class="js iu"> MVC </strong>架构编写模块化的东西将使编码变得容易。</p><p id="1495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望这些示例代码片段能让您了解实际的实现。</p><p id="0319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是所有的乡亲。<br/> Boiboi。</p></div></div>    
</body>
</html>