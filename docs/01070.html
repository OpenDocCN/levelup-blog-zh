<html>
<head>
<title>An Introduction to Sliding Window Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">滑动窗口算法简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-introduction-to-sliding-window-algorithms-5533c4fe1cc7?source=collection_archive---------0-----------------------#2019-11-04">https://levelup.gitconnected.com/an-introduction-to-sliding-window-algorithms-5533c4fe1cc7?source=collection_archive---------0-----------------------#2019-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eaea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用两个指针、一个循环和一点耐心滑入线性时间。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ce38e3c2de2ace2f5b6096f993943e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTeOHJWyLhInAWW7Qg_9HQ.jpeg"/></div></div></figure><p id="206c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在使用滑动窗口算法进入线性时间之前，应该理解算法被认为是有效的度量标准。</p><p id="836e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了说明这一点，引用《小王子》的作者安托万·德·圣·埃克苏佩里的话就足够了。</p><blockquote class="lr ls lt"><p id="f012" class="ku kv lq kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">完美的实现，不是当没有更多可以添加的时候，而是当没有什么可以拿走的时候。</p></blockquote><p id="61c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这写得很漂亮，看起来很深奥，但是它与软件工程师、开发人员和他们的算法有什么关系呢？</p><p id="3487" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，<strong class="kw iu">算法</strong>是用来实现某个目标的一组步骤。人们每天都在使用算法。以早上的通勤为例。一个人在选定的时间醒来，然后执行一系列步骤让他们按时工作。</p><p id="6ffa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些步骤可以分解成具体的列表:</p><ol class=""><li id="4ac8" class="lx ly it kw b kx ky la lb ld lz lh ma ll mb lp mc md me mf bi translated">早上八点半醒来。</li><li id="c0d6" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">做10分钟的轻度健身操。</li><li id="8872" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">穿上裤子、衬衫和袜子。</li><li id="9247" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">记得穿上内衣。</li><li id="10b9" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">下楼去做一碗燕麦粥。</li><li id="eb6c" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">在<strong class="kw iu">吃燕麦片n ≤ 20分钟。</strong></li><li id="3b9c" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">刷牙。</li><li id="2bb4" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">上车，祈祷它能打开。</li></ol><p id="67e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以看出，这是一个算法。它是实现一个目标的一系列步骤。</p><p id="f0df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于软件工程师和开发人员来说，最有效的算法是使用最少步骤的算法。换句话说，计算机程序员最有效的算法是使用最少的时间，占用最少的空间，以最低的复杂度运行的算法。</p><p id="4142" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，程序员的目标不是<strong class="kw iu">给算法增加</strong>个步骤；相反，程序员的目标是从算法中删除步骤。<em class="lq">当什么都没带走的时候</em>，算法就完美了。</p><p id="f221" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个人从程序的算法中删除不必要的步骤、变量和迭代时，程序的运行效率会高得多。为此，程序员的目标是严格规划的简单性，而不是复杂性。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="ddda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实现代码的简单性，需要有一个策略。这个策略不需要一开始就尽善尽美，但是在创建时应该考虑到优化。</p><p id="7440" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">滑动窗口算法是程序员简化代码的一种方式。这个算法听起来一模一样；一个<strong class="kw iu">窗口</strong>形成在数据的某一部分上，该窗口可以在数据上滑动以捕捉数据的不同部分。</p><p id="53f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解释这个模糊的定义，请看下面这个可以使用滑动窗口的问题的例子。</p><blockquote class="lr ls lt"><p id="a009" class="ku kv lq kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">给定一个数组作为输入，提取所有对中总和最高的一对连续整数。将该对作为数组返回。</p></blockquote><p id="9a4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">连续意味着连续，这意味着元素必须彼此紧挨着才能算作一对。这是一个巨大的线索，滑动窗口可以很好地解决这个问题。</p><p id="82bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个问题的上下文中，contiguous还意味着不能简单地对数组进行排序并返回数组中的最后两个整数，因为我们希望数组中的一对<strong class="kw iu">连续的</strong>整数具有最高的和，因为它已经被排序。</p><p id="0b26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个问题，取输入<code class="fe ms mt mu mv b">[5, 2, 4, 6, 3, 1]</code>作为输入。</p><p id="ce56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里不会详细解释滑动窗口，但会在下一节中介绍。这一部分作为一个带有轻松注释的视觉介绍。下图是这个问题的滑动窗口的第一次迭代。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8d59bc185a34740275721add76daa034.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*1hu3BaZC-GrTD7QuouNfyw.png"/></div></figure><p id="3e17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该窗口有红色边框和薄荷色背景。该对的当前总和<code class="fe ms mt mu mv b">[5,2]</code>为7。继续遍历整个数组，看看是否仍然是最高的和。必须<strong class="kw iu">将窗口向上滑动</strong>1，以到达下一个迭代。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4ac5a843cbea1c6be12af8f3f85e3563.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*e1kdpn8VHcOiqmrziOdmEA.png"/></div></figure><p id="8c4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个窗口评估为<code class="fe ms mt mu mv b">6</code>，所以它不是更高。继续迭代。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/30f55a60b2eff01da7074ecdbfcca7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*C7XXkKWBiP9W-AYAdNnSCQ.png"/></div></figure><p id="a885" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个窗口的对子是目前为止最高的。跟踪它，并将其与最后两次迭代进行比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ec58d41c3bbc2bb3f524de728d58afe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*O4qyE0HtMGLPJ9Rl_vLLWw.png"/></div></figure><p id="c6ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接近，但仍然没有高于前一对。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/0a7dbfff6163aac2a639d0bf33ec31e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*itJDUClozdWOTfBr_yShSg.png"/></div></figure><p id="9aa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这次迭代的对子肯定不是最高的。在所有迭代之后，最高和对是<code class="fe ms mt mu mv b">[4, 6]</code>。</p><p id="c886" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">迭代次数在这里值得注意:迭代次数是5，这使得这个问题的滑动窗口解决方案比<code class="fe ms mt mu mv b">O(n)</code>略快。对于小型和大型输入，线性时间是一个理想的目标。</p><p id="07d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然心智模型开始形成，人们可能会想<strong class="kw iu">如何</strong>识别可以成功使用滑动窗口的问题。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="ce79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，作者要求以下任何返回值的任何问题都可以使用滑动窗口:</p><ol class=""><li id="d72a" class="lx ly it kw b kx ky la lb ld lz lh ma ll mb lp mc md me mf bi translated">最小值</li><li id="dd9a" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">最大值</li><li id="0be4" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">最长值</li><li id="20b4" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">最短值</li><li id="bac0" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated"><em class="lq"> K </em>大小的值</li></ol><p id="dfb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前一个问题要求既有<em class="lq"> K- </em>大小的值(一对)又有最大值(最大和)。</p><p id="c87b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，使用必须按顺序迭代的列表或数据类型的问题非常适合滑动窗口。前一个问题也符合这个标准，因为它有一个数组输入，并且需要顺序迭代。</p><p id="d117" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，可以使用滑动窗口的最大线索之一是单词<strong class="kw iu"> contiguous </strong>。请记住:在编程的上下文中，连续意味着元素是按顺序一个接一个放置的。</p><p id="8097" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">人们将使用滑动窗口的一些常见数据结构是<strong class="kw iu">字符串、</strong> <strong class="kw iu">数组、</strong>甚至<strong class="kw iu">链表。</strong></p><p id="c868" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于使用数组的问题已经被使用过，下一个问题将使用一个<strong class="kw iu">字符串</strong>作为它的输入。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="1f0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一个问题如下:</p><blockquote class="lr ls lt"><p id="618f" class="ku kv lq kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">给定一个字符串，找出没有重复字符的<strong class="kw iu">最长子串</strong>的长度。</p></blockquote><p id="b98c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">子串</strong>是字符串中一组连续的字符。就本问题而言，子字符串不能包含任何重复字符。</p><p id="eb90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，这个问题要求给定字符串中没有重复字符的最长子串的<strong class="kw iu">长度。</strong></p><p id="606b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题检查了上面提到的几乎所有使用滑动窗口的标准。它具有:</p><ol class=""><li id="3697" class="lx ly it kw b kx ky la lb ld lz lh ma ll mb lp mc md me mf bi translated">字符串作为输入。</li><li id="177f" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">连续元素要求。</li><li id="4fae" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">必须遍历整个字符串。</li><li id="324d" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">必须找到最长的<strong class="kw iu">子串。</strong></li></ol><p id="93fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在深入研究这个问题之前，有必要了解程序员是如何实现滑动窗口的。</p><p id="d3e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">遵循即将出现的代码可能具有挑战性。在代码部分的下面是一个说明实现如何工作的示例，所以可以随意向下滚动来查看算法如何工作。到本文结束时，实现将变得有意义。</p><p id="45bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，需要一个<strong class="kw iu">起始索引。</strong>称之为<code class="fe ms mt mu mv b">leftWindow</code>，因为它是用于查看当前子串的窗口的左侧。此外，变量<code class="fe ms mt mu mv b">longest</code>可用于跟踪所有迭代子串的最大长度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="741c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里还需要一个<strong class="kw iu">对象</strong>，因为需要检查重复的字符。在其他语言中，<strong class="kw iu">对象</strong>或<strong class="kw iu">散列表</strong>的一个重要用途是存储某些字符的计数。从一个<strong class="kw iu">对象</strong>中查找一个键值对的时间是一个常数时间，<code class="fe ms mt mu mv b">O(1)</code>，因此与需要遍历部分或全部值来找到正确值的数据结构相比，它节省了大量时间。命名这个<code class="fe ms mt mu mv b">counts</code>或者类似的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="18e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，调用一个<code class="fe ms mt mu mv b">for</code>循环。声明并初始化一个名为<code class="fe ms mt mu mv b">rightWindow</code>到<code class="fe ms mt mu mv b">0</code>的块范围变量。此变量指向窗口右侧延伸到的索引。它最初指向<code class="fe ms mt mu mv b">0</code>，因为当它满足某些条件时，窗口的大小只在循环内部增长。</p><p id="ecf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要设置递增条件:循环的块将包含何时递增<code class="fe ms mt mu mv b">leftWindow</code>或<code class="fe ms mt mu mv b">rightWindow</code>的指令。</p><p id="1de5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦<code class="fe ms mt mu mv b">rightWindow</code>到达字符串的末尾，就退出循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d83b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在编写滑动窗口的指令之前还有一个步骤。必须设置一个字符的<strong class="kw iu">计数</strong>递增的条件。在这个例子中，当字符是包含在滑动窗口中的<strong class="kw iu">时，字符的计数增加。</strong></p><p id="b4dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着<code class="fe ms mt mu mv b">rightWindow</code>的增加，滑动窗口中包含更多的字符。所以，在循环的顶部写一个<code class="fe ms mt mu mv b">if</code>语句:如果<code class="fe ms mt mu mv b">rightWindow</code>索引处的当前字符不作为<code class="fe ms mt mu mv b">counts</code>变量中的<code class="fe ms mt mu mv b">key</code>存在，则将当前字符作为键追加到<code class="fe ms mt mu mv b">counts</code>中，值为<code class="fe ms mt mu mv b">0</code>。然后，在<code class="fe ms mt mu mv b">if</code>语句之外，用<code class="fe ms mt mu mv b">1</code>增加键值对。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9646" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">终于到了分解<strong class="kw iu">何时</strong>和<strong class="kw iu">如何</strong>滑动窗户的步骤了。由于窗口由索引<code class="fe ms mt mu mv b">leftWindow</code>和<code class="fe ms mt mu mv b">rightWindow</code>构成，两个索引之间的所有元素都将包含在子串中。随着<code class="fe ms mt mu mv b">rightWindow</code>的增加，子串中将包含更多的元素。</p><p id="2d35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着是<strong class="kw iu">而不是</strong>重复的字符导致<code class="fe ms mt mu mv b">rightWindow</code>递增，因为它<strong class="kw iu">应该被包括在窗口中，因为它符合适合当前窗口的标准。</strong></p><p id="5e7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于<code class="fe ms mt mu mv b">leftWindow</code>来说，情况正好相反:任何重复的字符都会迫使窗口收缩。随着<code class="fe ms mt mu mv b">leftWindow</code>的增加，窗口变小，因为当前字符不能包含在内，因此当前子串不能变大。接下来必须评估从<code class="fe ms mt mu mv b">leftWindow + 1</code>开始的子串，因为它可能大于前一个从<code class="fe ms mt mu mv b">leftWindow</code>开始的子串。</p><p id="a8c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，首先检查<code class="fe ms mt mu mv b">counts</code>中的<strong class="kw iu">某元素</strong>大于<code class="fe ms mt mu mv b">1</code>的情况。这意味着它是重复的。如果是这样，我们需要做以下事情:</p><ol class=""><li id="e1ec" class="lx ly it kw b kx ky la lb ld lz lh ma ll mb lp mc md me mf bi translated">随着窗口的收缩，减少<code class="fe ms mt mu mv b">leftWindow</code>处的字符，该字符不再出现在窗口的视图中。</li><li id="a6c8" class="lx ly it kw b kx mg la mh ld mi lh mj ll mk lp mc md me mf bi translated">将<code class="fe ms mt mu mv b">leftWindow</code>增加<code class="fe ms mt mu mv b">1</code>，看看下一个子串是否会比上一个子串更长，从<code class="fe ms mt mu mv b">leftWindow</code>开始，到<code class="fe ms mt mu mv b">rightWindow</code>结束。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e5dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，需要检查当前子串的长度是否大于由<code class="fe ms mt mu mv b">longest</code>指向的整数，该整数代表目前看到的<code class="fe ms mt mu mv b">longest</code>子串长度。之后，窗口必须扩展以包含另一个字符，并查看当前子字符串是否可以变得更长。将<code class="fe ms mt mu mv b">rightWindow</code>增加<code class="fe ms mt mu mv b">1</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="43f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了—滑动窗口已经创建好了。但是对于一个具体的例子来说，这会是什么样子呢？</p><p id="c954" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">取输入<code class="fe ms mt mu mv b">'pwwkew'</code>。这个问题的答案是<code class="fe ms mt mu mv b">3</code>，有那个长度的两个子串是<code class="fe ms mt mu mv b">'wke’</code>和<code class="fe ms mt mu mv b">'kew'</code>。</p><p id="3ffa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个窗口如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/fac343128981ad277e7572a7211fda13.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*Aexk54XCtVvbpMhDhoSZrw.png"/></div></figure><p id="0106" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ms mt mu mv b">rightWindow </code>为0，因此<code class="fe ms mt mu mv b">leftWindow</code>也为0。循环增量为<code class="fe ms mt mu mv b">1</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/475d4360df2a3ea79dd3482fa09fa515.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*HZjb24pwV10pND4cxY2X8g.png"/></div></figure><p id="6ff9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，该窗口的长度为<code class="fe ms mt mu mv b">2</code>个字符，并且没有副本。<code class="fe ms mt mu mv b">longest</code>被重新赋值给当前长度的子串。增量<code class="fe ms mt mu mv b">rightWindow</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7e282a57b3e5bc3d1c64c568bd5ecb44.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*lbhm1EMdNzdLFsKxK6vdQA.png"/></div></figure><p id="d51c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">子字符串重复。在<code class="fe ms mt mu mv b">counts</code>中<code class="fe ms mt mu mv b">leftWindow</code>将增加，而<code class="fe ms mt mu mv b">p</code>的计数将减少。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9b130e5f2a9af3d34e063e11080fa738.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*SAiy1bdpMeTrE9dIccnbfA.png"/></div></figure><p id="3429" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仍然有一个副本。<code class="fe ms mt mu mv b">leftWindow</code>再次增加，并且<code class="fe ms mt mu mv b">counts</code>中的<code class="fe ms mt mu mv b">w</code>的计数减少。一旦没有发现重复，<code class="fe ms mt mu mv b">rightWindow</code>再次递增。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/64b18da12ee7ab9aa60786a0f2cb6ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*iXGuOcytp_BUSsLWjvtaYw.png"/></div></figure><p id="bb01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里没有副本。再次增加<code class="fe ms mt mu mv b">rightWindow</code>,看看车窗是否能达到<code class="fe ms mt mu mv b">3</code>的长度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/bd15ea2b1a150cdfde47865bdd017ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*V_r9EJpfc-XZNaIaxGwNSg.png"/></div></figure><p id="a292" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">成功！发现了一个新的最大长度。<code class="fe ms mt mu mv b">longest</code>被重新分配，并且<code class="fe ms mt mu mv b">rightWindow</code>增加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/acecebad0bad7d1e79757f26d02a4009.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*PBRkpmI0ICatuREMp_yesw.png"/></div></figure><p id="d604" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">又发现一个重复的，<code class="fe ms mt mu mv b">w</code>。将<code class="fe ms mt mu mv b">counts</code>中的<code class="fe ms mt mu mv b">w</code>减1，增加<code class="fe ms mt mu mv b">leftWindow</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ab4edcac436a04ae61571c0eccb03684.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*ICj4ddQAbR5bpy74lZ8tcw.png"/></div></figure><p id="f678" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是最后一个子字符串，因为<code class="fe ms mt mu mv b">rightWindow</code>不能再增加了。<code class="fe ms mt mu mv b">break</code>出循环返回<code class="fe ms mt mu mv b">longest</code>，也就是<code class="fe ms mt mu mv b">3</code>，正确答案。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="510b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的解决方案不仅返回正确的值，而且运行时间接近线性。考虑到<strong class="kw iu">子串</strong>可以是≤ 26的任意长度，这可不是一件小事。在具有较少重复字符的示例中，该解决方案甚至可以在严格的线性时间内运行。</p><p id="ef70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是<strong class="kw iu">滑动窗口</strong>算法的强大之处:防止集合中不必要的迭代。此外，它还提供了一个直观的视角来查看子部分中的数据。</p><p id="3c62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于接下来的步骤，人们可以进入他们已解决问题的档案，寻找一个可以用滑动窗口解决的问题。然后，重构该解决方案，直到它以线性时间运行。</p><p id="5901" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">祝你好运！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="a18a" class="nk nl it bd nm nn no np nq nr ns nt nu jz nv ka nw kc nx kd ny kf nz kg oa ob bi translated">分级编码</h1><p id="6f9c" class="pw-post-body-paragraph ku kv it kw b kx oc ju kz la od jx lc ld oe lf lg lh of lj lk ll og ln lo lp im bi translated">感谢您成为我们社区的一员！<a class="ae oh" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae oh" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="oi oj gp gr ok ol"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">编写面试问题</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">掌握编码面试的过程</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">技术开发</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>