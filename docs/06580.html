<html>
<head>
<title>Deploy a Predictive Model with Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask部署预测模型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploy-a-predictive-model-with-flask-33c1976293cc?source=collection_archive---------4-----------------------#2020-12-09">https://levelup.gitconnected.com/deploy-a-predictive-model-with-flask-33c1976293cc?source=collection_archive---------4-----------------------#2020-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d5bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为您的ML项目制作并部署一个简单的Flask应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/7193d91821de9f490b198be3ea4e4898.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*DkdSdaBvzE6VFfcY-7VesQ.png"/></div></figure><p id="020b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本文的目的是向您展示一个使用Flask、Heroku和GitHub的机器学习模型的非常简单的“生产化”。本文假设您对Python代码有很好的理解，并且您已经用Python训练了一个机器学习模型，但是之前没有为此目的制作过Flask应用程序。你将需要访问GitHub和一个Heroku帐户；我们将为我们的应用程序创建一个存储库，并通过repo部署到Heroku。有HTML和Jinja的经验也很好，但不是必须的。</p><p id="1565" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Flask是一个轻量级的web应用框架，使用起来非常简单，并且有很好的文档记录。在Heroku这样的云平台上启动并运行它也有些琐碎。</p><p id="28c0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最近给自己的一个模特做了一个Flask app。我建立了一个CNN模型来预测使用胸部x射线的肺炎结果，并希望为一个非技术演示提供一个交互式的初步模型。使用ide和笔记本可能很难做到这一点，所以我制作了一个快速烧瓶应用程序，作为我的模型进行预测的“概念验证”演示。</p><h1 id="c788" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">我的行动模型</h1><p id="e719" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">在我们开始之前，你可以看看我用同样的方法制作的应用程序，让你对我们正在制作的东西有个概念。我在项目中使用的数据集来自kaggle.com，链接如下。</p><div class="mg mh gp gr mi mj"><a href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">胸部x光图像(肺炎)</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">5，863张图片，2个类别</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">www.kaggle.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kl mj"/></div></div></a></div><p id="4b0b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我的Flask app 托管在Heroku上。该模型是keras中的CNN h5模型，但是几乎任何ML模型都会以相同的方式工作。如果你能做一个model.predict()，你就有足够的能力做一个预测app。</p><p id="ca94" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">欢迎<a class="ae my" href="https://xray-pred.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">访问app </a>上传胸片(jpg或png)预测是‘正常’还是‘肺炎’。您可以使用数据集中的图像输入到模型中，或者尝试自己的图像。</p><p id="2e0d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在让我们一起做一个‘简洁’的应用程序。</p><h1 id="de1b" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">步骤1:制作一个烧瓶文件夹结构</h1><p id="f195" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我们首先为我们的项目创建一个虚拟环境(我推荐使用Python 3.7)。使用您的正常工作流程将您的项目推送到GitHub。如果我们保持一个有组织的存储库，以后通过Github在Heroku上部署将是轻而易举的事情。</p><p id="b855" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是一个初学者友好的应用程序结构，我用在学生身上。更复杂的应用程序可能需要更复杂的结构。在开始之前，花点时间构建文件夹结构。这是在编码前可视化项目的好方法。更多关于烧瓶夹结构的信息可以在<a class="ae my" href="https://flask.palletsprojects.com/en/1.1.x/tutorial/layout/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="9516" class="ne lk iq na b gy nf ng l nh ni">My Project/<br/>├── app.py<br/>├── requirements.txt<br/>├── Procfile<br/>├── templates/<br/>│   └── main.html<br/>├── static/<br/>│   ├── images/<br/>│   ├── stylesheets/<br/>│   └── fonts/<br/>├── model/<br/>│   └── my_model.pkl</span></pre><h1 id="264a" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">第二步:制作一个基本的Flask应用程序</h1><p id="8876" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">首先在你的venv中安装Flask库。在<a class="ae my" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask网站</a>上的设置和安装说明可以帮助你开始。如果你不确定任何步骤，参考Flask网站让你远离麻烦是非常重要的。</p><p id="56cf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，我们将从Hello World Flask应用程序开始。我将创建一个名为<strong class="kp ir"> app.py </strong>的文件(在我的文件夹结构的根目录下，如步骤1所示)。将以下代码插入<strong class="kp ir"> app.py </strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="667f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">那是弗拉斯克的“你好，世界”暗号。它导入Flask类，创建一个名为<strong class="kp ir"> app </strong>的Flask对象，并定义一个返回“<strong class="kp ir"> Hello，World！”的路由</strong>。要运行flask应用程序，只需在CLI中导航到“<strong class="kp ir">我的项目</strong>”文件夹，然后键入</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="75f7" class="ne lk iq na b gy nf ng l nh ni">% <strong class="na ir">flask run</strong></span></pre><p id="d14d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这将启动一个内置服务器，这对于开发和故障排除来说已经足够了，但不是您在生产中使用的。在你的浏览器中点击默认的应用位置<a class="ae my" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/ </a>，你应该会看到你的信息。</p><h2 id="8e96" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">我函数上面的代码是什么？</h2><p id="64c5" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我们正在制作一个web应用程序。一切都是通过Flask中的路线完成的。您实际上是将URL映射到操作。当您开始使用Flask时，可能最令人困惑的是下面这一行。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="92db" class="ne lk iq na b gy nf ng l nh ni"><strong class="na ir">@app.route(‘/’)</strong></span></pre><p id="0af8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> @ </strong>符号只是一个Python装饰器。装饰器是Python中一个相当晦涩的语法术语。它修改功能；更具体地说，它是一个<em class="nw"> </em>函数，将另一个函数作为参数，返回另一个函数。如果这令人困惑…我同意你。幸运的是，我们不必完全掌握它来使用它。</p><p id="cf8c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们<em class="nw">需要</em>知道的:装饰器将我们应用程序中的相对URL(路径)链接到它正在装饰的函数。这意味着hello_world函数与路由<strong class="kp ir"> ('/') </strong>相关联，这是我们的web应用程序的根。</p><p id="c23d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我们运行应用程序时，我们访问“触发”hello_world函数的根URL，而没有专门调用该函数。<strong class="kp ir"> hello_world </strong>函数将消息返回给路由，我们看到它神奇地出现在我们服务器的根URL上。</p><p id="e1d1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有时，通过路由URL来实现交互性可能会令人困惑和麻烦。在其他时候，你可以看到整个事情的绝对天才。</p><h1 id="65d3" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">步骤3:加载您的模型</h1><p id="69b2" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我们在文件结构中创建了一个文件夹来保存我们的模型。根据您制作的模型类型，有不同的存储方式。也许最简单的方法就是用泡菜。Pickling只是在Python中序列化一个对象以备后用。Pickling保留Python对象的当前状态。</p><p id="b3ef" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设您已经在一个编码会话中创建了一个线性回归模型，其对象名为<strong class="kp ir"> LR_model。</strong>要腌制它，只需执行以下操作:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1a60" class="ne lk iq na b gy nf ng l nh ni">import pickle</span><span id="3057" class="ne lk iq na b gy nx ng l nh ni">with open("my_model.pkl", 'wb') as file:  <br/>    pickle.dump(LR_model, file)</span></pre><p id="866d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在在当前目录下会弹出一个新文件，名为<strong class="kp ir"> my_model.pkl </strong>。这是放入名为<strong class="kp ir">型号</strong>的文件夹中的文件，如步骤1文件夹结构所示。在<strong class="kp ir"> app.py </strong>中，我们可以通过使用以下命令来撤销酸洗并检索模型。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="5eb7" class="ne lk iq na b gy nf ng l nh ni">import pickle</span><span id="f7b8" class="ne lk iq na b gy nx ng l nh ni">with open('model/my_model.pkl', 'rb') as file:  <br/>    model = pickle.load(file)</span></pre><p id="fa2e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们继续将它集成到我们的应用程序中。将我们的腌泡模型放入我们的文件夹结构后，我们可以打开它并进行预测，然后我们可以将预测输出到Flask应用程序的根目录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="55a8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个假设中，模型接受一个长度为3的数组，进行预测，并将预测作为字符串返回给用户。</p><h2 id="09c2" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">我们改变了什么:</h2><ul class=""><li id="3f99" class="ny nz iq kp b kq mb kt mc kw oa la ob le oc li od oe of og bi translated">增加第2、3、4、6、7和13行。</li><li id="f2ca" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">将<strong class="kp ir"> def hello_world </strong>改为<strong class="kp ir"> def index </strong></li><li id="87c3" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">返回预测<strong class="kp ir"> pred </strong>(转换为字符串)，而不仅仅是<strong class="kp ir">“hello world”</strong>。</li><li id="b66d" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">添加到第16–17行，因为这是一个好的做法。</li></ul><h1 id="91d3" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated"><strong class="ak">第四步:添加模板</strong></h1><p id="80d4" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这很好，但是我们想要的不仅仅是网页上的一个数字。Flask有一个很棒的工具可以让复杂的web界面变得简单。让我们看看如何使用烧瓶模板。</p><p id="7f92" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你熟悉HTML(和CSS ),你会觉得这一部分很轻松。我们需要制作一个HTML页面。我将调用我的<strong class="kp ir">index.html</strong>并将它放在<strong class="kp ir">模板</strong>文件夹中(模板的默认位置)。这个页面将作为我的web应用程序的新“主页”。在<strong class="kp ir">index.html</strong>文件中，我放置了以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="om on gj gh gi oo op bd b be z dk translated">index.html</figcaption></figure><p id="3c31" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了访问我的模板，flask有一个名为<strong class="kp ir"> render_template </strong>的函数，它可以“渲染”一个存储在templates文件夹中的html文件。当您从一个函数中<strong class="kp ir">返回</strong> <strong class="kp ir"> render_template </strong>时，它将在该函数的指定路径/URL(装饰器中的那个)中可用。在下面的代码中，<strong class="kp ir">index.html</strong>位于根文件夹中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="om on gj gh gi oo op bd b be z dk translated">flask_app_step4.py</figcaption></figure><h2 id="55ff" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">我们改变了什么:</h2><ul class=""><li id="fc76" class="ny nz iq kp b kq mb kt mc kw oa la ob le oc li od oe of og bi translated">在导入中添加了render_template函数</li><li id="ef1d" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">更改第14行以返回render_template函数调用</li></ul><p id="42da" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有了这两个文件，<strong class="kp ir"> flask run </strong>命令现在应该可以调出html模板了。</p><p id="ed56" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们可以看到网页，但我们也希望能够在模板中显示预测。为此，我们只需修改两行代码。首先，更改<strong class="kp ir"> render_template </strong>函数，使其包含您希望在模板中使用的每个值的关键字参数。这些值将可在网页上显示或操作。现在，将只发送一个字符串形式的单个值<strong class="kp ir"> pred </strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="1f4f" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">我们改变了什么:</h2><ul class=""><li id="99b0" class="ny nz iq kp b kq mb kt mc kw oa la ob le oc li od oe of og bi translated">在我们的render_template函数中添加了一个kwarg(上面的第4行)</li></ul><p id="bea5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在切换到你的index.html模板<strong class="kp ir">。我们将在html中添加一点Jinja模板符号。Jinja是一种模板语言，用于将python代码集成到我们的html页面中。最简单的实现如下所示。运行时，flask应用程序现在应该显示传递的<strong class="kp ir"> pred </strong>变量。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="7795" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">我们改变了什么:</h2><ul class=""><li id="5428" class="ny nz iq kp b kq mb kt mc kw oa la ob le oc li od oe of og bi translated">唯一改变的是第8行。<strong class="kp ir"> {{ }} </strong> Jinja符号允许您在html中的任何地方显示从<strong class="kp ir"> render_template </strong>函数发送的同名“变量”。</li></ul><p id="b876" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Jinja可以为我们做更多的工作，我鼓励你去看看。我们可以在HTML模板中直接实现类似Python的结构，比如循环和条件，还可以动态实现许多格式化特性。</p><h1 id="12ef" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">步骤5:使用一个Web表单来发布您的模型的输入</h1><p id="310b" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">如果我们不为用户提供一种输入预测数据的方式，这个web应用程序就不会非常有用。在我自己的模型中，用户提交的是x光图像数据。对于这个模型，我们将只传递几个数字。</p><p id="7867" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们假设的模型将是决定房价的线性回归。我们将把床、浴室和平方英尺的数量发送到这个简单的模型来预测价格。所有的数据都将显示在一个页面上。</p><p id="acca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将在HTML模板中添加一个表单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="1541" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">我们改变了什么:</h2><ul class=""><li id="58be" class="ny nz iq kp b kq mb kt mc kw oa la ob le oc li od oe of og bi translated">在第8行添加了一个表单标签(在第13行关闭)。将指定的方法和编码类型发布到多部分/格式数据。</li><li id="ae25" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">在我的表格的第9–11行添加了三个数字输入，这将要求在一个框中输入数字</li><li id="b9b2" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">在第12行增加了一个提交按钮</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/db6f92c26cb9c7ee7bda01b5b11b8a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*1G6QN78F1nZ1VCUsiPt3ug.png"/></div><figcaption class="om on gj gh gi oo op bd b be z dk translated">您的页面看起来会像这样。</figcaption></figure><p id="0998" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里我们使用一个<strong class="kp ir"> &lt;表单&gt; </strong>标签来包含用户输入元素。在<strong class="kp ir"> &lt;表单&gt; </strong>的属性中，我们在这里指定方法和编码类型。重要的是，你要保持这些相同的显示。在该表单中，我们为期望的房屋特征添加了三个数字输入，并添加了一个提交按钮来发布(提交)信息。按照目前的写法，只有当您单击提交按钮时，表单数据才会提交。</p><p id="8b1a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在切换回<strong class="kp ir"> app.py </strong>，这样我们就可以添加一个机制来接受这些提交到Python中的值。将<strong class="kp ir"> &lt;表单&gt; </strong>标签的方法设置为POST。我们将设置我们的路由方法来接受POST信息进行匹配。默认情况下，除非另外指定，否则路由只有GET方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="3e3f" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">我们改变了什么:</h2><ul class=""><li id="009d" class="ny nz iq kp b kq mb kt mc kw oa la ob le oc li od oe of og bi translated">第1行——我们将请求对象添加到flask import以接收表单数据</li><li id="4b1f" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">第11行——我们向decorator添加了POST以允许表单提交</li><li id="25b5" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">第13行—添加了if语句，以检查是否有任何内容已发布。如果有帖子，我们获取数据并呈现模板。否则，我们不使用它来渲染模板。</li><li id="9933" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">第14到15行——我们使用请求对象和“类似字典”的符号将表单POST中的值读入python。用于访问该值的键与模板中表单输入的名称值相同。</li><li id="30ed" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">第17行——我们现在使用发布的表单数据来为模型提供信息并进行预测(然后通过返回的<strong class="kp ir">render _ template</strong>将预测信息发送回网页)</li></ul><p id="312a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">基本的功能是有的。客户将输入三个数字，点击提交，然后看到一个结果。</p><h2 id="d4fd" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">重要的</h2><ul class=""><li id="b64d" class="ny nz iq kp b kq mb kt mc kw oa la ob le oc li od oe of og bi translated">您应该添加一些检查来验证表单数据。</li><li id="2e69" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">在运行predict方法之前，您还应该确保您的预测输入对您的模型有效。</li><li id="1da2" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">测试你的应用程序不会因为各种表单输入而崩溃。</li><li id="24c0" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li od oe of og bi translated">你可能想看看flask网站如何使用<strong class="kp ir"> Werkzeug </strong>来验证表单输入，以使你的应用程序更加安全并防止黑客入侵。</li></ul><h1 id="fbbb" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">第六步:设计风格</h1><p id="02c3" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我将把这个留给你的个人偏好，因为它很耗时，并且涉及到你的应用/模型的许多个人选择。在部署这样的应用程序之前，您不必完全设计好它，这实际上取决于您的受众和部署原因。</p><h2 id="1637" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">静态文件夹</h2><p id="1136" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">如果您正在添加文件(图像、样式表、脚本、数据集等。)添加到您的网页/模板中，所有这些资源都放在静态文件夹中。静态文件夹就是为此目的而存在的；你可以像对待任何网站一样提供图片、样式表和脚本。考虑到网页设计的目的，你的文件夹的其余部分是不可访问的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/8ba5a69eba5ac96f02160510347f7d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*4lBUc_4Is69now4ARHqnyA.png"/></div><figcaption class="om on gj gh gi oo op bd b be z dk translated">这款车型的造型过于简单</figcaption></figure><h1 id="6bad" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">步骤7:为Heroku准备好你的应用程序</h1><p id="7033" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我们的最终目标是将我们的项目迁移到云中。我们需要添加两个文件到我们的项目中，使它更适合在Heroku上构建。</p><h2 id="0943" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">requirements.txt</h2><p id="6f8c" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这个文件进入你的根目录(见文件夹结构)。这是一个简单的文本文件，列出了您的所有导入。当您构建应用程序时，Heroku将遍历您的<strong class="kp ir"> requirements.txt </strong>文件中的每一行，为您的应用程序安装必要的库。</p><p id="08d8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">需求文件中的错误会导致应用程序在构建过程中崩溃。排除故障也非常困难，所以要确保它们都是正确的。</p><p id="4129" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是我在项目中使用的文件。这是我使用的每个外部库的导入和特定版本号。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="7ba4" class="ne lk iq na b gy nf ng l nh ni"><strong class="na ir">Flask</strong>==<strong class="na ir">1.1.2<br/>Jinja2</strong>==<strong class="na ir">2.11.2<br/>keras<br/>numpy</strong>==<strong class="na ir">1.18.5<br/>Werkzeug</strong>==<strong class="na ir">1.0.1<br/>requests<br/>gunicorn<br/>tensorflow</strong>==<strong class="na ir">2.3.1<br/>h5py</strong>==<strong class="na ir">2.10<br/>Pillow</strong>==<strong class="na ir">8.0.1</strong></span></pre><p id="00b4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了避免麻烦，仔细检查每一行，并确保您可以针对本地虚拟环境的每个需求进行pip安装。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="0ee0" class="ne lk iq na b gy nf ng l nh ni"><strong class="na ir">% pip install Flask==1.1.2</strong></span></pre><p id="baaf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">运行这些pip命令也是Heroku将要做的事情。如果您的机器有冲突，或者必须卸载并重新安装不同的版本，请确保您在<strong class="kp ir"> requirements.txt. </strong>中指定了每个库的正确最终版本</p><h2 id="999e" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">Procfile</h2><p id="2b69" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">创建一个名为Procfile的文件，并将其放在根目录中，如本文顶部的文件夹结构所示。不要添加扩展名使其成为Procfile.txt或其他任何文件，它只是Procfile。</p><p id="dbf7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Procfile只是告诉Heroku如何为你的项目处理不同的过程。对于我们的程序，只需在Procfile中放置下面一行代码。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="d910" class="ne lk iq na b gy nf ng l nh ni">web: gunicorn app:app</span></pre><p id="70f0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> Gunicorn </strong>是一个Web服务器网关接口(WSGI)服务器，用于管理我们的应用程序。我们的应用程序的名称是app，所以如果您将您的app.py命名为其他名称，您也必须在这里进行更改。</p><h2 id="1fbd" class="ne lk iq bd ll nl nm dn lp nn no dp lt kw np nq lv la nr ns lx le nt nu lz nv bi translated">开源代码库</h2><p id="40ca" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">最后，将所有内容推送到github repo中。确保将<strong class="kp ir"> Procfile </strong>和<strong class="kp ir"> requirements.txt </strong>添加到提交中。您已准备好部署。Heroku和GitHub配合得非常好。您必须向Heroku授予GitHub访问权限，但是Heroku会通过用户友好的提示引导您添加身份验证。</p><h1 id="e761" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">步骤8:在Heroku上部署你的应用</h1><p id="7acd" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">创建一个帐户并登录Heroku。你可以用免费账户轻松运行这样的应用，但当然他们有付费账户的升级。</p><ol class=""><li id="b4e2" class="ny nz iq kp b kq kr kt ku kw os la ot le ou li ov oe of og bi translated">去你的Heroku仪表板。</li><li id="a6af" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li ov oe of og bi translated">点击“新建”按钮，创建一个新的应用程序。</li><li id="cd6f" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li ov oe of og bi translated">给你的应用取一个唯一的名字。它在整个Heroku一定是独一无二的。</li><li id="8f5e" class="ny nz iq kp b kq oh kt oi kw oj la ok le ol li ov oe of og bi translated">一个新的屏幕弹出。对于“部署方法”，选择“GitHub”</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ox oy di oz bf pa"><div class="gh gi ow"><img src="../Images/6056bfe8cc215a195a9c67bf1922a72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkBrLt2UNB85ueaOuVmEzQ.png"/></div></div></figure><p id="531b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">5.搜索您的应用程序的回购名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ox oy di oz bf pa"><div class="gh gi pb"><img src="../Images/b4d43eea21dfa9d55f3df994ec0f8cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGtDiwTxMLOAJ2cxQm7BJg.png"/></div></div></figure><p id="953d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">6.我建议启用自动部署。这意味着每次你将项目的主分支推送到GitHub，Heroku都会自动构建并重新部署你的app。这是一个真正的节省时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ox oy di oz bf pa"><div class="gh gi pc"><img src="../Images/c400027c883bfd0d59e2303001914b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIicoOWUKQK4GnDbIl1HBg.png"/></div></div></figure><h1 id="a4dc" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">试用您的应用</h1><p id="5e49" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">如果构建成功，您将能够在任何计算机上打开“打开应用程序”链接。您的模型已经部署，您可以将链接转发给用户。</p><p id="c8a7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">祝你好运！</p></div></div>    
</body>
</html>