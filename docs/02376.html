<html>
<head>
<title>An Introduction to Binary Heaps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二进制堆介绍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-introduction-to-binary-heaps-c95b3025977?source=collection_archive---------10-----------------------#2020-03-09">https://levelup.gitconnected.com/an-introduction-to-binary-heaps-c95b3025977?source=collection_archive---------10-----------------------#2020-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="26db" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背景</h1><p id="5b88" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">是时候介绍另一种利基数据结构了！对于这个博客，这将是二进制堆。如果你熟悉二分搜索法树，这个数据结构看起来会很熟悉。如果没有，不要担心，我们将一步一步地学习二进制堆的概念。</p><h1 id="2cc3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是堆？</h1><p id="3f66" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们深入研究二进制堆之前，我们应该理解什么是堆。堆是一种类似树的数据结构，其中父节点和子节点之间存在关系。下图是一个堆的例子。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/039dbe58384f6cff2569f79515b9539f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrTegmb_97-cVaXFb08Xew.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">堆示例</figcaption></figure><p id="f9a8" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">在这个堆示例中，父和子之间的关系是父总是大于它的所有子。父节点100有两个子节点90和80。100大于90和80。父节点90有三个子节点40、50和1。90大于40，50，1。</p><p id="67c0" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">不同父母的孩子之间的关系并不重要。我们来看看家长80。它只有一个孩子，10岁。虽然10大于1，但1是父90的子，这在技术上还是堆。我们只关心父母和孩子之间的直接关系。</p><p id="d33d" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">堆示例也可以称为最大堆。这意味着父代比所有子代更伟大。由于这种含义，最大的数字总是在堆的顶部，也称为根。在本例中，100将是这个最大堆的根。</p><p id="4eb6" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">类似地，最小堆意味着父堆小于它的所有子堆。由于这个暗示，最小的数字总是在堆的顶部。</p><p id="daa2" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">现在我们已经对堆有了基本的了解，我们可以深入二进制堆了。</p><h1 id="2ee1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是二进制堆？</h1><p id="355f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">二进制堆是这样一种堆，其中每个父堆最多有两(2)个子堆(因此在二进制堆中称为“二进制”)。在前面的堆示例中，这将是一个标准堆，因为父堆90有三个子堆，父堆80有一个子堆。</p><p id="a85b" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">使用和以前一样的数字，下图显示了二进制堆的样子。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/72473576f9c473f44bb7946b80cb1200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*CfAMqWfiekSpa11lQ4fmzw.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">二进制堆示例</figcaption></figure><p id="b23c" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">在二进制堆示例中，每个父级有两个子级。这位100岁的父母有两个孩子，一个90岁，一个80岁。这位90岁的父母有两个孩子，一个40岁，一个50岁。这位80岁的父母有两个孩子，一个1岁，一个10岁。</p><p id="9c3c" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">父子关系是父堆大于所有子堆，这使得它成为最大二进制堆。</p><p id="f3c9" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">一个主要的约束是，二进制堆是完全T2的。完成意味着树的所有级别都被正确填充。从形状的角度来看，这意味着每一层的空间都是从左到右填满的。</p><p id="56e7" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">下面的截图显示了堆不完整意味着什么。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mg"><img src="../Images/eb17c16d74f47d58e2fbb6071731feba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jq9pw-rWkR9DDhautyfmEQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">不完整的堆示例</figcaption></figure><p id="c58f" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">在第三层有一个空位，50、1和10被填充。40岁的人开始了一个新的层次，第四个层次，这时有一个空位让它成为90岁的第二个孩子。</p><p id="c4d5" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">通常对于树，我们会使用链表来表示数据结构(例如，二分搜索法树)。然而，由于二进制堆是完整的这一重要约束，我们可以将这种数据结构表示为一个数组。</p><p id="cdd0" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">在二进制堆示例中，它可以由下面的数组表示:</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="18d0" class="mm jo iq mi b gy mn mo l mp mq">[100, 90, 80, 40, 50, 1, 10]</span></pre><p id="8d8c" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">但是等等，你怎么确定数组形式中哪个父有哪个子呢？</p><h1 id="a5f0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">作为数组的二进制堆</h1><p id="4449" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">秘密在于索引。</p><p id="3d10" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">让我们用同样的二进制堆例子来分解。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mr"><img src="../Images/e9f1fca9a00b6724dafd6f0a80e54db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mBouzzNUip5VbluAOjC2_g.png"/></div></div></figure><p id="e5ca" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">在上图中，我使用的是同一个二进制堆。红色背景代表我们正在查看的当前父代，绿色背景代表当前父代的子代。这里，父索引位于0，而子索引位于1和2。似乎还没有太多的模式可循，但让我们继续追踪它。</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="fd51" class="mm jo iq mi b gy mn mo l mp mq">Parent-Child Tracker<br/>0 =&gt; 1, 2</span></pre><p id="2ba7" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">让我们看下一个家长，90岁。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ms"><img src="../Images/6c80b330c6173b5b44f48401647db701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpTZtO_B09ddarOVXsPPxQ.png"/></div></div></figure><p id="71a0" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">父节点在索引1上，子节点在索引3和4上。</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="40fc" class="mm jo iq mi b gy mn mo l mp mq">Parent-Child Tracker<br/>0 =&gt; 1, 2<br/>1 =&gt; 3, 4</span></pre><p id="bb5e" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">现在，让我们做最后一个家长，80。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mt"><img src="../Images/d6a564407468758f2aa1c45dfcece42c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmBdY9ELbHhEc-T09yxoXg.png"/></div></div></figure><p id="962e" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">父节点在索引2上，子节点在索引5和6上。</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="6b38" class="mm jo iq mi b gy mn mo l mp mq">Parent-Child Tracker<br/>0 =&gt; 1, 2<br/>1 =&gt; 3, 4<br/>2 =&gt; 5, 6</span></pre><p id="d79c" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">嗯，看起来父母和孩子的关系是:</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="717c" class="mm jo iq mi b gy mn mo l mp mq">childIndex = 2n+1 or 2n+2</span></pre><p id="5ba1" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">其中<code class="fe mu mv mw mi b">n</code>表示父节点的索引。左边的孩子会使用<code class="fe mu mv mw mi b">2n+1</code>，而右边的孩子会使用<code class="fe mu mv mw mi b">2n+2</code>。</p><p id="b99e" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">但是，如果我们的索引是一个子索引，而我们想找到它的父索引，该怎么办呢？</p><p id="0583" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">从孩子到父母的关系是:</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="3742" class="mm jo iq mi b gy mn mo l mp mq">parentIndex = Math.floor((n-1)/2)</span></pre><p id="dd75" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">其中<code class="fe mu mv mw mi b">n</code>代表孩子的索引。</p><p id="189c" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">现在我们理解了数组形式的二进制堆的子堆和父堆之间的关系！</p><h1 id="0721" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">插入</h1><p id="6d38" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然我不会深入研究代码，但我想解释一下二进制堆的插入和提取的概念。</p><p id="eb30" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">对于插入，您可以将新节点插入到现有的二进制堆中。插入后，二进制堆可能需要重新组织自己，以保持父子关系。</p><p id="60be" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">为了给人一种插入感，我们把95插入到例子中。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mx"><img src="../Images/df61f68f7dfc940e7c3b33539b33a2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNYrsNCQSpkA90WXM6JG8w.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">将95插入二进制堆</figcaption></figure><p id="fe7f" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">回想一下，二进制堆是完整的。当我们插入一个新节点时，堆从左到右被填充。由于在第三层的最右边没有空位，我们将为95层开始一个新的层。</p><p id="c0de" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">接下来我们需要检查父和子之间的关系是否得到了维护。这就是重组开始的时候。因为这是一个最大二进制堆，所以关系是父堆必须大于它的所有子堆。95是40的子代，大于其父代。因此，我们需要交换40和95的位置。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi my"><img src="../Images/51754da25b44b3169522fe24b514e510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqSGenC4NCL-mMzzo4fj1A.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">交换40和95</figcaption></figure><p id="7385" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">现在，95是40的父母。接下来，我们检查95的新父代，在本例中是90。如果新父母少于95，交换他们的位置。如果没有，那么我们就完成了二进制堆的重组。我们不断重复这个过程，直到父节点大于我们插入的节点，或者它一直到达根节点，成为新的根节点。</p><p id="e94f" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">由于90小于95，我们需要交换他们的位置。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mz"><img src="../Images/8f5cc0dee79483f01ce6fb50b19e9c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rp66kd8WEuCaL8P-8afIqQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">交换90和95</figcaption></figure><p id="4440" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">95的新父代是100，大于95。我们终于可以停止重组堆了。上图现在是我们更新后的二进制堆。有了这个更新的二进制堆，数组现在应该如下所示:</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="9613" class="mm jo iq mi b gy mn mo l mp mq">[100, 95, 80, 90, 50, 1, 10, 40]</span></pre><p id="c7c2" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">作为快速检查，让我们使用父子公式，以95为例，看看这个数组是否准确。</p><p id="96de" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">如果95是父代，那么它的子代是90和50。如果95是子节点，那么它的父节点就是100。95在索引1处。</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="6093" class="mm jo iq mi b gy mn mo l mp mq">Reference Index: n = 1<br/>Left Child Index: 2n+1 = 2(1)+1 = 3<br/>Right Child Index: 2n+2 = 2(1)+2 = 4<br/>Parent Index: Math.floor((1-1)/2) = Math.floor((1-1)/2) = Math.floor(0/2) = 0</span></pre><p id="4c0f" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">看起来一切正常！</p><h1 id="6dae" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">提取，血统</h1><p id="2f9b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">根据二进制堆的性质，最小数量(即最小二进制堆)或最大数量(即最大二进制堆)将是根。二进制堆或一般堆的主要目的是找到最大值或最小值。因为这个数总是根，所以时间复杂度为O(1)。</p><p id="57fb" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">在使用这个数字之后，应该从二进制堆中提取或删除它。然而，现在旧的根已经被移除了，我们如何知道堆中的哪个数应该是新的根呢？这与插入的工作原理非常相似。</p><p id="79cc" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">在插入时，我们从堆的底部“冒泡”到适当的位置，保持适当的父子关系。在提取中，我们将从堆的顶部“传播”到适当的位置。我们将使用与插入相同的方法，只是方向相反。</p><p id="dcb9" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">为了提供视觉效果，让我们从示例中提取100。在提取过程中，我们将在通过堆传播之前用根交换最后一个节点。最后使用的数字将是我们开始的地方。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi na"><img src="../Images/5293d02381ef2befb8eb49ffc6da224b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58GfI9Igqki55wKzXUwi8Q.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">交换了40和100</figcaption></figure><p id="2b6f" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">上图中，100这个老根，被换成了40。接下来，我们将从堆中提取100。我们这样做有两个原因:</p><ol class=""><li id="053c" class="nb nc iq kn b ko lz ks ma kw nd la ne le nf li ng nh ni nj bi translated">这保证了二进制堆仍然是完整的。</li><li id="127b" class="nb nc iq kn b ko nk ks nl kw nm la nn le no li ng nh ni nj bi translated">从数组中删除最后一个节点的时间复杂度为O(1)。</li></ol><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/07e074f26963d16729fb377da271f12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*tQEn4eWOqKEp2ihXCEG8ng.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">移除旧根(100)</figcaption></figure><p id="78d2" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">接下来，我们使用与插入相同的方法。我们将从根开始比较父节点，并确认父节点和子节点之间的关系是否保持。如果是，则不需要执行任何操作。如果没有，那么我们需要交换父节点和子节点的位置，并使用新的位置重新开始这个过程。</p><p id="fd03" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">如果两个孩子都比父母大，那么与大的孩子交换。</p><p id="5fe1" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">从40的新根开始，这个父节点比它的两个子节点95和80都小。这意味着40应该与95交换。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nq"><img src="../Images/ce438d251f98db18095571e5fd09f5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8nWBhlP0YCAlIDLBNxS0A.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">交换了40和95</figcaption></figure><p id="37dc" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">现在，40的新子女是90和50。两个孩子仍然大于40，这意味着40和90需要交换。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/7bc5803cc81a1b7e34ecfeac75f1842f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*gnC1GvE-mm6SEyEA9yaIIQ.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">交换了40和90。最终更新的堆。</figcaption></figure><p id="c2b8" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">现在，如果我们检查这个更新的堆中的每一个父子关系，它满足父大于子的关系。更新后的数组现在应该如下所示:</p><pre class="lk ll lm ln gt mh mi mj mk aw ml bi"><span id="47df" class="mm jo iq mi b gy mn mo l mp mq">[95, 90, 80, 40, 50, 1, 10]</span></pre><p id="785c" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">作为一个快速的检查，95是整个堆中最大的数字，它位于根中，这是应该的。</p><h1 id="d745" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="e843" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">恭喜您，现在您已经了解了二进制堆及其实现！您了解了如何在维护父子关系的同时将节点/值插入到二进制堆中，以及如何在提取其根之后更新二进制堆。</p><p id="69d9" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">如果您想要一个挑战，尝试用插入和提取方法创建您自己的二进制堆类。</p></div></div>    
</body>
</html>