<html>
<head>
<title>“Markers” in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的“标记”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/markers-in-go-a69af5dc95e6?source=collection_archive---------9-----------------------#2021-11-29">https://levelup.gitconnected.com/markers-in-go-a69af5dc95e6?source=collection_archive---------9-----------------------#2021-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="460a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">生成带注释的文件和代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6930e0cd23713cc89db0e1b555a2e6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z91ftVn3ZvxUPpNA"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">出自unsplash，<a class="ae ky" href="https://unsplash.com/photos/NROHA1B-NYk" rel="noopener ugc nofollow" target="_blank">@米切尔罗</a></figcaption></figure><p id="f149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">食欲伴随着进食而来，尤其是当面对一桌子让你味蕾发痒的食物时。一旦晚餐开始，你永远不会满足于只吃一口美味。这是我在使用Kubernetes操作符和遇到那些不同的标记时的感觉，它们可以帮助避免样板代码和简化代码逻辑。我知道我能学到更多。</p><p id="5268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一个开胃酒的例子。下面是我创建的操作符中用于<a class="ae ky" href="https://github.com/slaise/operator-test/blob/01abdc47d8bfc4fed578b0b2c5ffd57912c97112/kubebuilder-test/controllers/useridentityv3_controller.go#L66" rel="noopener ugc nofollow" target="_blank">生成RBAC </a>文件的标记。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5ce3" class="ma mb it lw b gy mc md l me mf"><em class="mg">//+kubebuilder:rbac:groups=identity.company.org,resources=useridentityv3s,verbs=get;list;watch;create;update;patch;delete</em></span><span id="8b26" class="ma mb it lw b gy mh md l me mf"><em class="mg">//+kubebuilder:rbac:groups=identity.company.org,resources=useridentityv3s/status,verbs=get;update;patch</em></span></pre><p id="b3bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe mi mj mk lw b"><a class="ae ky" href="https://github.com/slaise/operator-test/blob/01abdc47d8bfc4fed578b0b2c5ffd57912c97112/kubebuilder-test/Makefile#L42" rel="noopener ugc nofollow" target="_blank">manifests</a></code>命令后，会在<code class="fe mi mj mk lw b">config/rbac</code>目录下生成相应的资源YAML文件，并打包成相应的操作员映像，然后在部署CRD时应用到集群中。</p><p id="cd51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看非常类似于一些Java注释特性，对吗？并且可以类似地注入或生成附加代码。作为一名多年的Java开发人员，我不禁要进行比较🤷🏻‍♀️.</p><p id="9a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备好吃主菜了吗？关注我，了解这个特性在Kubebuilder中是如何搭建的，在Go中又是如何应用的。说实话，它在Go中还没有名字，所以我称它为“Marker”，和Kubebuilder文档中的一样。</p><h1 id="32dd" class="ml mb it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">记号笔如何工作</h1><h2 id="53d3" class="ma mb it bd mm nc nd dn mq ne nf dp mu li ng nh mw lm ni nj my lq nk nl na nm bi translated">控制器-gen投入使用</h2><p id="c326" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">Kubebuilder通过将真正的实现者<code class="fe mi mj mk lw b">controller-gen</code>包装到Makefile中来实现标记。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1ea2" class="ma mb it lw b gy mc md l me mf">$(CONTROLLER_GEN) $(CRD_OPTIONS) rbac:roleName=manager-role webhook paths="./..." output:crd:artifacts:config=config/crd/bases</span></pre><p id="f2cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">巨大的Kubernetes <a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools" rel="noopener ugc nofollow" target="_blank">控制器工具</a>的三个命令行工具之一<code class="fe mi mj mk lw b"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/tree/master/cmd/controller-gen" rel="noopener ugc nofollow" target="_blank">controller-gen</a></code>，只有一个功能:<strong class="lb iu">通过定义</strong>生成相应的文件或代码。为了快速理解它，阅读源代码似乎是唯一的方法，因为文档很差。</p><p id="e011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mi mj mk lw b">controller-gen</code>支持5台发电机。</p><ul class=""><li id="971e" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/blob/ab52f76cc7d167925b2d5942f24bf22e30f49a02/pkg/crd/gen.go#L43" rel="noopener ugc nofollow" target="_blank"> CRD </a>，生成CRD YAML格式的资源文件</li><li id="d176" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/blob/ab52f76cc7d167925b2d5942f24bf22e30f49a02/pkg/rbac/parser.go#L149" rel="noopener ugc nofollow" target="_blank"> RBAC </a>，生成<code class="fe mi mj mk lw b">ClusterRole</code>和<code class="fe mi mj mk lw b">ClusterRoleBinding</code> YAML文件</li><li id="b93c" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/blob/ab52f76cc7d167925b2d5942f24bf22e30f49a02/pkg/deepcopy/gen.go#L54" rel="noopener ugc nofollow" target="_blank">对象</a>、<strong class="lb iu">、</strong>生成由CRD定义的<code class="fe mi mj mk lw b">deepCopy</code>代码</li><li id="aafb" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/blob/ab52f76cc7d167925b2d5942f24bf22e30f49a02/pkg/webhook/parser.go#L284" rel="noopener ugc nofollow" target="_blank"> Webhook </a>，支持生成变异和验证的webhook YAML</li><li id="401a" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/blob/ab52f76cc7d167925b2d5942f24bf22e30f49a02/pkg/schemapatcher/gen.go#L65" rel="noopener ugc nofollow" target="_blank">模式</a>，根据API包生成支持OpenAPI v3的模式</li></ul><p id="2fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回头看看Kubebuilder，你会发现它使用了所有生成器，并将执行命令封装在Makefile <code class="fe mi mj mk lw b">generate</code>命令中。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5676" class="ma mb it lw b gy mc md l me mf">$(CONTROLLER_GEN) object:headerFile="hack/boilerplate.go.txt" paths="./..."</span></pre><p id="431b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，<code class="fe mi mj mk lw b">controller-gen</code>还支持4种<a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/blob/ab52f76cc7d167925b2d5942f24bf22e30f49a02/cmd/controller-gen/main.go#L63" rel="noopener ugc nofollow" target="_blank">输出方式</a>。</p><ul class=""><li id="de0e" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><strong class="lb iu"> dir </strong>，输出到一个目录</li><li id="a2ff" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">无</strong>，无输出</li><li id="ecaa" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu"> stdout </strong>，输出至标准输出</li><li id="81a3" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">工件</strong>，输出到其他目录或文件</li></ul><p id="222d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是<code class="fe mi mj mk lw b">manifests</code>命令中<code class="fe mi mj mk lw b">output</code>选项的功能。而且除此之外，在使用Kubebuilder的时候，应该已经安装了<code class="fe mi mj mk lw b">controller-gen</code>，所以你可以在命令行查看<code class="fe mi mj mk lw b">help</code>的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/456b242e03b5af7a8270c079709e7bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qdlqAfiYUxNz3QCp"/></div></div></figure><h2 id="fa54" class="ma mb it bd mm nc nd dn mq ne nf dp mu li ng nh mw lm ni nj my lq nk nl na nm bi translated">解析标记</h2><p id="a1ce" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">然后跳出了这样一个问题:如何将注释行解析成一个标记对象？</p><p id="2fc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应的逻辑在<a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/tree/ab52f76cc7d167925b2d5942f24bf22e30f49a02/pkg/markers" rel="noopener ugc nofollow" target="_blank">控制器-工具/pkg/标记器</a>包中。通读完<code class="fe mi mj mk lw b">Marker</code>代码后，简单地解释一下:将一行注释解析成一个<code class="fe mi mj mk lw b"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-tools/blob/ab52f76cc7d167925b2d5942f24bf22e30f49a02/pkg/markers/parse.go#L652" rel="noopener ugc nofollow" target="_blank">Definition</a></code>对象，该对象包含类似<code class="fe mi mj mk lw b">Name</code>、<code class="fe mi mj mk lw b">Target</code>、<code class="fe mi mj mk lw b">Fields</code>、<code class="fe mi mj mk lw b">FieldsNames</code>等字段。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3733" class="ma mb it lw b gy mc md l me mf"><em class="mg">// Definition is a parsed definition of a marker.<br/></em>type Definition struct {Solly Ross, 3 years ago: • Marker parsing<br/>   <em class="mg">// Output is the deserialized Go type of the marker.<br/>   </em>Output reflect.Type<br/>   <em class="mg">// Name is the marker's name.<br/>   </em>Name string<br/>   <em class="mg">// Target indicates which kind of node this marker can be associated with.<br/>   </em>Target TargetType<br/>   <em class="mg">// Fields lists out the types of each field that this marker has, by<br/>   // argument name as used in the marker (if the output type isn't a struct,<br/>   // it'll have a single, blank field name).  This only lists exported fields,<br/>   // (as per reflection rules).<br/>   </em>Fields map[string]Argument<br/>   <em class="mg">// FieldNames maps argument names (as used in the marker) to struct field name<br/>   // in the output type.<br/>   </em>FieldNames map[string]string<br/>   <em class="mg">// Strict indicates that this definition should error out when parsing if<br/>   // not all non-optional fields were seen.<br/>   </em>Strict bool<br/>}</span></pre><p id="f7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，<code class="fe mi mj mk lw b">Definition</code>对象的类别(<code class="fe mi mj mk lw b">package</code>、<code class="fe mi mj mk lw b">type</code>和<code class="fe mi mj mk lw b">field</code>)让你想起了什么？有，Java注释里的<code class="fe mi mj mk lw b">class</code>、<code class="fe mi mj mk lw b">field</code>和<code class="fe mi mj mk lw b">method</code>。🙈</p><h1 id="6d44" class="ml mb it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">围棋中的标记</h1><p id="b92d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当我在研究Kubebuilder标记背后的逻辑时，我的脑海中出现了一个想法:看看这种便利性，难道不应该有对这一特性的本机支持吗？</p><p id="ed48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细想想，我发现自己对这些类似的功能并不陌生，比如我在<code class="fe mi mj mk lw b">go-lint</code>中关闭一个警报时采用了<code class="fe mi mj mk lw b">var bad_name int // nolint</code>，或者在屏蔽某个错误时采用了<code class="fe mi mj mk lw b">var bad_name int // nolint:golint,unused</code>。</p><p id="9510" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Go还支持两种类型的标记。</p><ul class=""><li id="e661" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe mi mj mk lw b">go:build</code></li><li id="6036" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe mi mj mk lw b">go:generate</code></li></ul><h2 id="da76" class="ma mb it bd mm nc nd dn mq ne nf dp mu li ng nh mw lm ni nj my lq nk nl na nm bi translated">开始:构建</h2><p id="7704" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">构建标记限制了代码的构建OS/平台。举个例子，</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f071" class="ma mb it lw b gy mc md l me mf">// +build linux darwin<br/>package main</span></pre><p id="e8a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同一个文件中可以有多个标签。但是，不要错过构建标记和包定义之间的空行。当然，你可以用<code class="fe mi mj mk lw b">go vet</code>来避免。</p><h2 id="5c5a" class="ma mb it bd mm nc nd dn mq ne nf dp mu li ng nh mw lm ni nj my lq nk nl na nm bi translated">开始:生成</h2><p id="3933" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe mi mj mk lw b">go:generate</code>标记与<code class="fe mi mj mk lw b">go generate</code>命令捆绑，通过<code class="fe mi mj mk lw b">help</code>命令查看官方解释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0e302ee116958bcaaef6d7eb67208fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5G3p_UY2PDQj6tlK"/></div></div></figure><p id="693a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mi mj mk lw b">go generate</code>使您能够在Go代码中运行当前系统的已安装程序，尽管它最初是用于创建或更新Go源文件。运行下面的命令，当前目录下的所有<code class="fe mi mj mk lw b">go:generate</code>标记都将被执行。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ce18" class="ma mb it lw b gy mc md l me mf">go generate ./...</span></pre><p id="7958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且<code class="fe mi mj mk lw b">go generate</code>提供了更多，一个典型的例子是使用<a class="ae ky" href="https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go" rel="noopener ugc nofollow" target="_blank"> stringer </a>生成错误信息。</p><p id="5e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常我们用一个包含<em class="mg"> int </em> ( <code class="fe mi mj mk lw b">code</code>)和<em class="mg"> string </em> ( <code class="fe mi mj mk lw b">description</code>)的对象来映射设计web程序返回时对应的错误。在Java中，我们经常会挑<code class="fe mi mj mk lw b">Enum</code>，这个比合适的多。但是在Go中，我们只能通过<code class="fe mi mj mk lw b">itoa</code>生成<code class="fe mi mj mk lw b">ErrorCode</code>，而不能同步保存描述。</p><p id="1137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例中的<code class="fe mi mj mk lw b">errorcode.go</code>包含一个<code class="fe mi mj mk lw b">//go:generate </code>标记和3个<code class="fe mi mj mk lw b">ErrorCodes</code>，每个标记定义了下面注释中对应的<code class="fe mi mj mk lw b">Error Message</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="828c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在命令行上执行<code class="fe mi mj mk lw b">go generate</code>，生成下面的<code class="fe mi mj mk lw b">errorcode_string.go</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="a59c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后用<code class="fe mi mj mk lw b">fmt.Println(NOT_FOUND)</code>返回相应的错误信息。</p><h1 id="806b" class="ml mb it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">围棋不是记号笔的爱好者</h1><p id="39c4" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe mi mj mk lw b">go:generate</code>在Go源代码中出现的多，除此之外别无其他。Go既没有在标记上投入更多，也没有在更便于定制的方法上投入更多。所以，我们仍然依靠<code class="fe mi mj mk lw b">Kubernetes/controller-tool</code>中那些复杂的解析器来实现支架功能。</p><p id="eb39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使Github问题中有相关提案，如<a class="ae ky" href="https://github.com/golang/go/issues/36669" rel="noopener ugc nofollow" target="_blank"> #36669 </a>、<a class="ae ky" href="https://github.com/golang/go/issues/38672" rel="noopener ugc nofollow" target="_blank"> #38672 </a>，但无论如何都被否决了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/fa141f3a16f52aaee778cc39841274d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1YR_yQnopqTj38ph"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/8c459b799ac95afb5860b53b10ee8cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IJOEYhDr2yaJ6BGi"/></div></div></figure><p id="199e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么拒绝？我引用@ <a class="ae ky" href="https://github.com/ianlancetaylor" rel="noopener ugc nofollow" target="_blank"> ianlancetaylor </a>来回答。</p><blockquote class="ol om on"><p id="3d61" class="kz la mg lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">Go喜欢显式的编程风格。</p><p id="ed51" class="kz la mg lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">Go认为可读性方面的好处值得额外的代码。</p></blockquote><p id="1672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go完全有理由拒绝但无法阻止那些有想法的地鼠去实现自己。而且除了之前的<code class="fe mi mj mk lw b">controller-gen</code>，我还在Github上发现了这两个有趣的包。</p><ul class=""><li id="75af" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe mi mj mk lw b"><a class="ae ky" href="https://github.com/kubernetes/code-generator" rel="noopener ugc nofollow" target="_blank">Kubernetes/code-generator</a></code>，也生成控制器相关的模板代码。</li><li id="d0ce" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe mi mj mk lw b"><a class="ae ky" href="https://github.com/MarcGrol/golangAnnotations" rel="noopener ugc nofollow" target="_blank">golangAnnotations</a></code>，支持生成web相关模板代码，如<code class="fe mi mj mk lw b"><a class="ae ky" href="http://twitter.com/RestOperator" rel="noopener ugc nofollow" target="_blank">@RestOperator</a></code>。</li></ul><p id="fce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你感兴趣，可以去看看。</p><h1 id="6db7" class="ml mb it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结束了</h1><p id="c3b2" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">作为一种静态语言，Go与Java有着本质的不同。与Java注释相比，Go标记也是如此。Go标记通常用于生成或验证代码，但在运行时不添加任何逻辑。然而，Java注释通常可以与拦截器结合使用，增加运行时日志和参数验证。</p><p id="b018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过学习上面的例子，我们对标记的内部原理有了更多的了解，这样我们就可以在应对样板文件不足的情况时做好准备。我们是否可以编写一些静态语法检查作为lint工具，作为公司内部操作员的最佳实践，这是一个有待讨论的问题。</p><h1 id="c550" class="ml mb it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">参考</h1><div class="or os gp gr ot ou"><a href="https://book.kubebuilder.io/reference/markers.html" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">用于配置/代码生成的标记</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">我们声援黑人社区。种族主义是不可接受的。这与……的核心价值观相冲突</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">book.kubebuilder.io</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://go.dev/blog/generate" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">生成代码</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">rob Pike 2014年12月22日通用计算的一个特性——图灵完备性——是计算机程序可以写…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">go.dev</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>