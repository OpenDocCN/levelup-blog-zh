<html>
<head>
<title>Polling in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的轮询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/polling-in-javascript-ab2d6378705a?source=collection_archive---------1-----------------------#2020-01-15">https://levelup.gitconnected.com/polling-in-javascript-ab2d6378705a?source=collection_archive---------1-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建自己的轮询函数来查询更新的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0bf1869550f4651e8eb8be8bed175028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSl-yLC_e7xq63nNYo_Sog.jpeg"/></div></div></figure><p id="2d4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">轮询是一种技术，我们通过定期向服务器发出API请求来检查给定时间间隔内的新数据。例如，如果有频繁更改的数据，或者我们需要等待服务器转换给定的状态，我们可以使用轮询。轮询是web套接字或服务器事件的简单替代方法。</p><p id="3b1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将首先描述何时需要轮询，提供一个JavaScript中的<code class="fe lq lr ls lt b">poll</code>函数实现，然后展示如何在模拟API中使用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><p id="c0da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想教你如何<a class="ae lv" href="https://skilled.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> ace你的编码面试➡️ </strong> </a>。</p><div class="lw lx gp gr ly lz"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">编写面试问题</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">掌握编码面试的过程</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">技术开发</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h1 id="02f8" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">当我们使用轮询时</h1><p id="2bda" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">轮询的一个真实用例是，如果我们使用第三方身份验证提供者(比如Firebase或Auth0 ),并且在继续之前需要等待结果。当用户注册时，我们将用户的数据从客户端发送到身份验证提供者。然后在服务器上，我们等待来自身份验证提供者的响应，然后在我们的数据库中创建一个用户。</p><p id="433f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在整个过程中，客户端必须等待服务器上的身份验证和用户创建。因为我们知道这个过程会很快成功或失败，所以我们可以放心地实现一个轮询，每1秒钟向我们的服务器发出一次API请求，直到我们完成注册和创建新用户的过程。</p><p id="63b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个投票有用的例子是我们在地图上追踪用户的位置。在像优步这样的应用程序中，我们可以通过反复查询最近的坐标来观察司机来接我们。由于这些数据经常变化，我们将设置一个时间间隔来轮询位置，以确保我们拥有最新的数据。</p><h1 id="465c" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">轮询实现</h1><p id="9444" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们将编写一个简单的<code class="fe lq lr ls lt b">poll</code>函数，它使用承诺来解析获取的结果。我将粘贴下面的代码并解释它是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2a24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe lq lr ls lt b">poll</code>函数是一个返回函数<code class="fe lq lr ls lt b">executePoll</code>的高阶函数。<code class="fe lq lr ls lt b">executePoll</code>函数返回一个承诺，并将递归运行，直到满足停止条件。<code class="fe lq lr ls lt b">poll</code>函数将4个变量作为参数:</p><ul class=""><li id="8526" class="nn no it kw b kx ky la lb ld np lh nq ll nr lp ns nt nu nv bi translated"><code class="fe lq lr ls lt b">fn</code>:这是我们将在给定时间间隔内执行的功能。通常这是一个API请求。</li><li id="46e5" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">这也是一个函数，我们定义一个测试，看看数据是否符合我们想要的，这将结束投票。例如，我们可以简单地测试数据是否存在，或者我们可以检查响应的嵌套属性是否达到了某个状态</li></ul><p id="6ca4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">《出埃及记》<code class="fe lq lr ls lt b">validate = user =&gt; !!user</code></p><p id="db74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">《出埃及记》<code class="fe lq lr ls lt b">validate = checkout =&gt; checkout.status === 'COMPLETE'</code></p><ul class=""><li id="0052" class="nn no it kw b kx ky la lb ld np lh nq ll nr lp ns nt nu nv bi translated"><code class="fe lq lr ls lt b">interval</code>:这是我们希望在轮询请求之间等待的时间。这完全由您的应用中的用例决定，拥有最新信息的重要性越高，轮询请求之间的间隔就需要越短。</li><li id="4f15" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated"><code class="fe lq lr ls lt b">maxAttempts</code>:我们需要能够为轮询请求的数量设置一些合理的上限，以防止它无限运行。</li></ul><p id="aa0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe lq lr ls lt b">poll</code>函数从声明一个<code class="fe lq lr ls lt b">attempts</code>变量开始，我们围绕这个变量形成一个闭包，以跟踪我们对API进行了多少次轮询。然后我们声明返回承诺的<code class="fe lq lr ls lt b">excutePoll</code>函数。这允许我们连续递归地调用<code class="fe lq lr ls lt b">executePoll</code>，并且只有在达到有效值时才调用<code class="fe lq lr ls lt b">resolve</code>。</p><p id="e045" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">executePoll</code>函数也被声明为<code class="fe lq lr ls lt b">async</code>，因此我们可以通过使用<code class="fe lq lr ls lt b">await</code>轻松执行<code class="fe lq lr ls lt b">fn</code>。一旦它返回，我们就增加我们的<code class="fe lq lr ls lt b">attempts</code>。我们从<code class="fe lq lr ls lt b">fn</code>调用<code class="fe lq lr ls lt b">result</code>上的<code class="fe lq lr ls lt b">validate</code>，如果它返回true，我们就成功地<code class="fe lq lr ls lt b">resolve</code>这个值。如果结果无效，我们将检查是否达到了最大轮询次数，如果达到，将抛出一个错误。否则，我们对给定的<code class="fe lq lr ls lt b">interval</code>执行<code class="fe lq lr ls lt b">setTimeout</code>，然后递归调用该函数，再次尝试轮询。</p><h1 id="1676" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">轮询示例</h1><p id="b3f2" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">下面的例子是一旦你可以粘贴到一个本地的JavaScript文件，并使用<code class="fe lq lr ls lt b">node</code>运行它。它采用我们在上一节中构建的相同的poll函数，并将其应用于一个假的API请求。它模拟等待用户被创建，在本例中，这将在12秒后发生。我们每秒轮询一次模拟API，直到它返回一个用户，然后解析到我们链接的<code class="fe lq lr ls lt b">then</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="8f4f" class="ob mp it bd mq oc od dn mu oe of dp my ld og oh na lh oi oj nc ll ok ol ne om bi translated">包裹</h2><p id="55cb" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">就是这样！轮询是一种简单但功能强大的技术，它使您能够定期检查数据的最新值，并在数据进入所需状态时阻止进一步的请求。</p><p id="466f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">—<a class="ae lv" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank">@ trey huffine</a>|<a class="ae lv" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">@ git connected</a></p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="090d" class="mo mp it bd mq mr ou mt mu mv ov mx my jz ow ka na kc ox kd nc kf oy kg ne nf bi translated">分级编码</h1><p id="bfcf" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">感谢您成为我们社区的一员！<a class="ae lv" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae lv" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="lw lx gp gr ly lz"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">编写面试问题</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">掌握编码面试的过程</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">技术开发</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div></div></div>    
</body>
</html>