<html>
<head>
<title>Firestore query limitations and how to work around them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firestore查询限制以及如何解决这些限制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/firestore-query-limitations-and-how-to-work-around-them-e058a844ae57?source=collection_archive---------1-----------------------#2022-12-29">https://levelup.gitconnected.com/firestore-query-limitations-and-how-to-work-around-them-e058a844ae57?source=collection_archive---------1-----------------------#2022-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f8bb0d9973cf93d775d4f641a0e0f4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a2Da_CQHUsSKTCTRI2tYhQ.png"/></div></div></figure><h1 id="cfdf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="7811" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇博文的引言中，我们将概述Firestore查询功能以及理解查询限制的重要性。</p><p id="985a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Firestore是一个灵活、可扩展的NoSQL云数据库，允许您实时存储和查询数据。它提供了广泛的查询选项，包括使用多个条件对数据进行筛选和排序的能力，使用and、OR和IN子句执行复合查询的能力，以及使用范围筛选器缩小结果范围的能力。</p><p id="32ff" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，像任何数据库一样，Firestore在查询数据时也有自己的一套限制和约束。理解这些限制对于构建高效且可伸缩的应用程序至关重要，因为它们会影响查询的性能和应用程序的整体可伸缩性。</p><p id="68ce" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这篇博文中，我们将深入研究Firestore中特定的查询限制，并探索这些限制的一些常见解决方法。通过理解这些限制并知道如何解决它们，您可以确保您的Firestore查询在性能和可伸缩性方面得到优化。</p><h1 id="ebde" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">限制#1:多个字段上的不等式查询</h1><p id="4771" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这一节中，我们将仔细研究在Firestore中对多个字段使用不等式查询的局限性，并探索一些可能的解决方法。</p><p id="a7a3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先，让我们回顾一下不等查询在Firestore中是如何工作的。不等式查询允许您使用诸如“小于”、“大于”、“小于或等于”和“大于或等于”等运算符，根据值的范围来筛选数据例如，您可以使用不等式查询来查找特定得分大于50的所有用户，或者价格小于100美元的所有产品。</p><p id="bca1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在Firestore中，通过使用<code class="fe lz ma mb mc b">where</code>方法并指定字段、操作符和值，可以在单个字段上使用不等式查询。例如:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="0b01" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").where("score", "&gt;", 50).get()</span></pre><p id="a932" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您需要基于多个字段中的一系列值来筛选数据，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。</p><p id="56d9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一种选择是使用复合索引来支持您的查询。复合索引允许您在多个字段上创建一个索引，然后可以用它来支持高级查询。通过在“分数”和“年龄”字段上创建复合索引，可以使用以下查询来筛选数据:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="d578" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").orderBy("score").orderBy("age").startAt([50, 30]).get()</span></pre><p id="9555" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">另一种选择是使用云函数在后端执行查询，并将过滤后的结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受Firestore的查询功能的限制。</p><p id="84c8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过使用这些变通方法之一，您可以有效地对Firestore中的多个字段执行不等式查询，尽管存在限制。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。</p><p id="6d8d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还值得注意的是，对多个字段的不等式查询可能效率低下，并影响数据库的性能。如果可能的话，通常最好避免在多个字段上使用不等式查询，并在决定是否使用这种类型的查询时仔细考虑应用程序的特定需求和要求。</p><p id="3f57" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">总的来说，理解Firestore中多个字段上的不等式查询的限制并知道如何解决这个限制对于构建高效和可伸缩的应用程序来说是至关重要的。通过使用复合索引或云函数，您可以有效地在多个字段上执行不等式查询，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。</p><h1 id="93b4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">限制#2:在不同字段上使用范围过滤器的查询</h1><p id="6eec" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这一节中，我们将仔细研究在Firestore的同一个查询中的不同字段上使用范围过滤器的局限性，并探索一些可能的解决方法。</p><p id="0ea5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">范围筛选器允许您使用诸如“小于”、“大于”、“小于或等于”和“大于或等于”等运算符，根据值的范围来筛选数据例如，您可以使用范围筛选器来查找得分在50到100之间的所有用户，或者价格在50到100美元之间的所有产品。</p><p id="82fd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在Firestore中，通过使用<code class="fe lz ma mb mc b">where</code>方法并指定字段、运算符和值，您可以在单个字段上使用范围过滤器。例如:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="d63d" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").where("score", "&gt;=", 50).where("score", "&lt;=", 100).get()</span></pre><p id="ec3f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该查询从“users”集合中检索“score”字段在50到100之间的所有文档。</p><p id="8baf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，Firestore在对同一查询中的不同字段使用范围过滤器时有一个限制。具体来说，不能在同一个查询中的不同字段上使用范围筛选器。例如，Firestore中不允许以下查询:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="0fa3" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").where("score", "&gt;=", 50).where("age", "&gt;=", 30).get()</span></pre><p id="d42b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您需要基于多个字段的值范围来筛选数据，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。</p><p id="699b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一种选择是使用复合索引来支持您的查询。复合索引允许您在多个字段上创建一个索引，然后可以用它来支持高级查询。通过在“分数”和“年龄”字段上创建复合索引，可以使用以下查询来筛选数据:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="6716" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").orderBy("score").orderBy("age").startAt([50, 30]).endAt([100, 60]).get()</span></pre><p id="8a29" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">另一种选择是使用云函数在后端执行查询，并将过滤后的结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受Firestore的查询功能的限制。</p><p id="d353" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">尽管存在限制，但通过使用这些变通办法之一，您可以在Firestore中的不同字段上有效地执行范围过滤。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。</p><p id="f441" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还值得注意的是，在不同的字段上使用范围过滤器可能会效率低下，并影响数据库的性能。如果可能的话，通常最好避免在不同的字段上使用范围筛选器，并在决定是否使用这种类型的查询时，仔细考虑应用程序的特定需求和要求。</p><p id="febc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">总的来说，理解Firestore中不同字段的范围过滤器的限制并知道如何解决这一限制对于构建高效和可伸缩的应用程序至关重要。通过使用复合索引或云函数，您可以有效地对不同的字段执行范围过滤，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。</p><h1 id="22b7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">限制#3:在不同字段上使用limit和orderBy的查询</h1><p id="263f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这一节中，我们将仔细研究在Firestore的同一个查询中的不同字段上使用limit和orderBy的局限性，并探索一些可能的解决方法。</p><p id="4673" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Firestore中的<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">orderBy</code>方法允许您限制查询返回的结果数量，并指定返回结果的顺序。例如，您可以使用<code class="fe lz ma mb mc b">limit</code>方法来检索数据库中的前10个用户，或者使用<code class="fe lz ma mb mc b">orderBy</code>方法来检索按分数升序排序的所有用户。</p><p id="0c25" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在Firestore中，您可以在同一个字段上使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">orderBy</code>方法，方法是在查询中将它们链接在一起。例如:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="e550" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").orderBy("score").limit(10).get()</span></pre><p id="4545" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该查询从“users”集合中检索前10个文档，按照“score”字段以升序排序。</p><p id="6913" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，Firestore在对同一查询中的不同字段使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">orderBy</code>方法时有一个限制。具体来说，您不能在不同的字段上使用<code class="fe lz ma mb mc b">limit</code>方法和<code class="fe lz ma mb mc b">orderBy</code>方法。例如，Firestore中不允许以下查询:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="39ce" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").orderBy("age").limit(10).get()</span></pre><p id="e86a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您需要根据一个字段的值限制查询结果，并根据另一个字段的值对结果进行排序，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。</p><p id="3826" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一种选择是使用复合索引来支持您的查询。复合索引允许您在多个字段上创建一个索引，然后可以用它来支持高级查询。通过在“年龄”和“分数”字段上创建复合索引，可以使用以下查询对数据进行筛选和排序:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="5752" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").orderBy("age").orderBy("score").limit(10).get()</span></pre><p id="1db8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">另一种选择是使用云函数在后端执行查询，并将过滤和排序后的结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受Firestore的查询功能的限制。</p><p id="e227" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过使用这些变通方法之一，您可以在Firestore的不同字段上有效地使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">orderBy</code>方法，尽管存在限制。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。</p><p id="6949" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">同样值得注意的是，在不同的字段上使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">orderBy </code>方法可能效率低下，并且会影响数据库的性能。如果可能的话，通常最好避免在不同的字段上使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">orderBy</code>方法，并在决定是否使用这种类型的查询时仔细考虑您的应用程序的特定需求和要求。</p><p id="1b2d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">总的来说，理解在Firestore的不同领域使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">orderBy</code>方法的局限性，并知道如何解决这一局限性，对于构建高效和可伸缩的应用程序至关重要。通过使用复合索引或云函数，您可以在不同的字段上有效地使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">orderBy</code>方法，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。</p><h1 id="5f7b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">限制#4:带有limit和startAt/endAt的查询</h1><p id="bfeb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这一节中，我们将仔细研究在Firestore的同一个查询中使用limit和startAt/endAt的局限性，并探索一些可能的解决方法。</p><p id="89b8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Firestore中的<code class="fe lz ma mb mc b">limit</code>方法允许您限制查询返回的结果数量，而<code class="fe lz ma mb mc b">startAt</code>和<code class="fe lz ma mb mc b">endAt</code>方法允许您指定查询结果的起点和终点。例如，您可以使用<code class="fe lz ma mb mc b">limit</code>方法仅检索数据库中的前10个用户，或者使用<code class="fe lz ma mb mc b">startAt</code>和<code class="fe lz ma mb mc b">endAt</code>方法检索得分在50到100之间的所有用户。</p><p id="2ba1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在Firestore中，您可以通过将<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">startAt</code> / <code class="fe lz ma mb mc b">endAt</code>方法链接在一起，在同一个查询中使用它们。例如:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="88f5" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").orderBy("score").startAt(50).endAt(100).limit(10).get()</span></pre><p id="1ae5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该查询从“users”集合中检索“score”字段在50到100之间的前10个文档，按照“score”字段以升序排序。</p><p id="b75e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，Firestore在同一个查询中使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">startAt</code> / <code class="fe lz ma mb mc b">endAt</code>方法时有一个限制。具体来说，不能在同一个查询中同时使用<code class="fe lz ma mb mc b">limit</code>方法和<code class="fe lz ma mb mc b">startAt</code> / <code class="fe lz ma mb mc b">endAt</code>方法。例如，Firestore中不允许以下查询:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="d447" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").orderBy("score").startAt(50).limit(10).get()</span></pre><p id="7217" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您需要根据某个范围的值来限制查询结果并指定结果的起点，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。</p><p id="e967" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一种选择是使用复合索引来支持您的查询。复合索引允许您在多个字段上创建一个索引，然后可以用它来支持高级查询。通过在“score”和“age”字段上创建一个复合索引，您可以使用下面的查询来过滤和排序您的数据，同时仍然使用<code class="fe lz ma mb mc b">limit</code>方法:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="b656" class="ml jz iq mc b be mm mn l mo mp">db.collection("users").orderBy("score").orderBy("age").startAt([50]).limit(10).get()</span></pre><p id="2ca9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">另一种选择是使用云函数在后端执行查询，并将过滤和排序后的结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受Firestore的查询功能的限制。</p><p id="50f9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过使用这些变通办法之一，尽管有限制，您可以在Firestore的同一个查询中有效地使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">startAt</code> / <code class="fe lz ma mb mc b">endAt</code>方法。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。</p><p id="29b2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">同样值得注意的是，在同一个查询中使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">startAt</code> / <code class="fe lz ma mb mc b">endAt</code>方法可能会效率低下，并影响数据库的性能。如果可能的话，通常最好避免在同一个查询中使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">startAt</code> / <code class="fe lz ma mb mc b">endAt</code>方法，并在决定是否使用这种类型的查询时仔细考虑您的应用程序的特定需求和要求。</p><p id="20d2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">总的来说，理解在Firestore的同一个查询中使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">startAt</code> / <code class="fe lz ma mb mc b">endAt</code>方法的局限性，并知道如何解决这一局限性，对于构建高效且可伸缩的应用程序至关重要。通过使用复合索引或云函数，您可以在同一个查询中有效地使用<code class="fe lz ma mb mc b">limit</code>和<code class="fe lz ma mb mc b">startAt</code> / <code class="fe lz ma mb mc b">endAt</code>方法，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。</p><h1 id="741a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">限制#5:使用数组的查询</h1><p id="eb68" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这一节中，我们将仔细研究Firestore中查询阵列的局限性，并探索一些可能的解决方法。</p><p id="c2cc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Firestore是一个NoSQL数据库，这意味着它以一种灵活的类似JSON的格式存储数据，称为“文档”每个文档可以包含多个键值对，或“字段”，它们可以是各种数据类型，包括字符串、数字、布尔值，甚至数组。</p><p id="42c2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Firestore中的数组可以方便地存储和检索数据列表，如标签列表或用户id列表。但是，在Firestore中查询阵列时，需要考虑一些限制。</p><p id="c838" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一个限制是Firestore不支持对数组的“包含”查询。这意味着您不能使用<code class="fe lz ma mb mc b">array-contains</code>操作符来检查数组字段是否包含特定的值。例如，Firestore中不允许以下查询:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="95b4" class="ml jz iq mc b be mm mn l mo mp">db.collection("posts").where("tags", "array-contains", "firebase").get()</span></pre><p id="5456" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您需要查询在数组字段中包含特定值的文档，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。</p><p id="ac7d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一种选择是使用云函数在后端执行查询，并将结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受Firestore的查询功能的限制。</p><p id="8ed5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">另一种选择是对数据进行反规范化，并为数组中的每个元素创建单独的集合。例如，您可以创建一个单独的“tags”集合，其中包含每个标记的文档，以及一个引用父“posts”文档的字段。然后，您可以使用一个简单的“equals”查询来检索匹配特定值的所有“tags”文档:</p><pre class="md me mf mg gt mh mc mi bn mj mk bi"><span id="1f5c" class="ml jz iq mc b be mm mn l mo mp">db.collection("tags").where("name", "==", "firebase").get()</span></pre><p id="9916" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过使用这些变通方法之一，您可以在Firestore中有效地查询在数组字段中包含特定值的文档，尽管存在限制。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。</p><p id="26eb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还值得注意的是，对数据进行反规范化会增加数据库结构的复杂性，并且可能需要额外的维护来保持数据同步。如果可能的话，通常最好避免对数据进行反规范化，并在决定是否使用这种方法时仔细考虑应用程序的特定需求和要求。</p><p id="be35" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">总的来说，理解Firestore中查询阵列的限制并知道如何解决这一限制对于构建高效和可伸缩的应用程序至关重要。通过使用云函数或对数据进行反规范化，您可以有效地查询在数组字段中包含特定值的文档，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。</p><h1 id="c2d6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="1440" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本文中，我们研究了在Firestore中查询数据的一些限制，并探索了一些可能的解决方法。这些限制包括:</p><ul class=""><li id="7e29" class="mq mr iq ky b kz lu ld lv lh ms ll mt lp mu lt mv mw mx my bi translated">多个字段上的不等式查询</li><li id="1a5b" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">对不同字段使用范围筛选器的查询</li><li id="40bc" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">对不同字段使用limit和orderBy的查询</li><li id="1d6f" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">具有limit和startAt/endAt的查询</li><li id="ce3b" class="mq mr iq ky b kz mz ld na lh nb ll nc lp nd lt mv mw mx my bi translated">使用数组的查询</li></ul><p id="6c20" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">理解这些限制并知道如何解决它们对于使用Firestore构建高效且可扩展的应用程序至关重要。尽管有这些限制，但通过使用复合索引、云函数或对数据进行反规范化，您可以有效地查询数据。</p><p id="7cde" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还需要注意的是，其中一些变通方法可能效率低下，或者会影响数据库的性能。如果可能的话，通常最好避免使用这些变通方法，并在决定是否使用它们时仔细考虑应用程序的特定需求和要求。</p><p id="ae43" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">总的来说，理解在Firestore中查询数据的局限性并知道如何解决它们对于构建健壮的可伸缩的应用程序来说是必不可少的。通过使用正确的工具和方法，即使面对这些限制，您也可以有效地查询数据并满足用户的需求。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="7482" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">不要错过我即将推出的内容和技术指南:</strong></p><div class="nl nm gp gr nn no"><a href="https://medium.com/@nicchong/subscribe" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">每当Nic Chong发布时收到电子邮件。</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">每当Nic Chong发布时收到电子邮件。注册后，如果您还没有，您将创建一个中型帐户…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jw no"/></div></div></a></div><p id="cd18" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果你有什么问题，我在这里帮忙，在评论区等你:)</p></div></div>    
</body>
</html>