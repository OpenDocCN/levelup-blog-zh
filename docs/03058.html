<html>
<head>
<title>How to Create a Highly Available NGINX Load Balancer on Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Google云平台上创建高可用的NGINX负载均衡器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-highly-available-nginx-load-balancer-on-google-cloud-platform-9ebc8b6abb09?source=collection_archive---------9-----------------------#2020-04-17">https://levelup.gitconnected.com/how-to-create-a-highly-available-nginx-load-balancer-on-google-cloud-platform-9ebc8b6abb09?source=collection_archive---------9-----------------------#2020-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="242e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在CentOS 7上使用Pacemaker、Corosync和Static IPs的Google Cloud上的高可用性NGINX负载平衡器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f0ecf36af65c4fb3c4ef15ec35097944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YAyaoqQvRKDVEzLq"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">泰勒·米利根在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着虚拟化的基于云的基础设施的出现，越来越多的组织正在向云迁移。这样做有很多好处，但是近乎无限的可伸缩性、高可用性、成本降低和性能提高是重要的驱动因素。</p><p id="b1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数可伸缩且高度可用的应用程序都运行在某种形式的负载平衡器之后。Google Cloud Platform是领先的云提供商之一，支持多种类型的负载平衡，作为满足您需求的托管服务。如果你想了解更多，那么请查看<a class="ae ky" href="https://cloud.google.com/load-balancing/docs/choosing-load-balancer" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/load-balancing/docs/choosing-load-balancer</a>。</p><p id="1142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Google Cloud还提供了一个很棒的流程图，可以根据您的特定需求选择负载平衡器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/351dbb7b1bc2f0006e7735ef1990a343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2845Opd_ZBdFZPpFymXGg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://cloud.google.com/load-balancing/images/choose-lb.svg" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a></figcaption></figure><p id="d1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们鼓励您在可用的负载平衡器之间进行选择，但是有些情况下这些负载平衡器可能不符合您的需求。例如，让我们考虑一种情况，如果您在本地环境中使用一个负载平衡器，如NGINX或HAProxy，在该环境中，您在不同的端口上处理多种请求。如果您想迁移到云，而不是使用一个NGINX实例，您将不得不创建多个负载平衡器，这对您来说可能是一件昂贵的事情，尤其是如果您有一个最小的负载。此外，大多数向云迁移的组织都希望进行类似的迁移，并希望避免改变他们的应用程序架构来适应云。在这种情况下，您可能不会选择切换到Google云负载平衡。</p><p id="5220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您总是可以在Google计算引擎实例上配置NGINX或HA代理。然而，问题是Google计算引擎实例是一个区域资源。因此，它无法经受住区域性破坏。为了解决这个问题，您需要在每个区域都有冗余的负载平衡器，以便在某个区域发生故障时能够在这些实例上进行故障转移。在内部部署环境中，您可以使用keepalived等工具，该工具使用VRRP协议来自动执行故障转移。然而，由于谷歌云使用完全虚拟化的基础设施，VRRP不在那里工作，我们需要寻找替代方式来做到这一点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cbe5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决办法</h1><p id="a4d8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">谷歌云平台提供虚拟静态IP，你可以提前预约。这些IP可以是内部或外部的。您需要将内部IP作为现有虚拟以太网适配器的别名，而外部IP作为资源直接连接到计算实例。您可以利用这一原则，通过编写自定义脚本来实现主节点和辅助节点之间的自动故障转移。已经有一些写得很好并且经过测试的解决方案，比如今天我们将使用的<a class="ae ky" href="https://github.com/bharatmicrosystems/gcp-failoverd" rel="noopener ugc nofollow" target="_blank"> this </a>。</p><h1 id="7ba3" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">基础设施设计</h1><p id="15e4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们有两个运行在两个不同区域的Google计算引擎实例。两者都安装了充当负载平衡器的NGINX。我们还安装了Pacemaker和Corosync，它们有助于管理集群。</p><p id="c7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Corosync是一个允许集群多个服务器的实用程序，它们使用UDP相互通信。它们充当对等体之间的消息传递层。</p><p id="b318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“Pacemaker”是一个集群资源管理器，管理集群内的资源代理，比如选举leader资源并对其进行监控，当leader不再响应时，选择另一个代理作为leader。</p><p id="ae46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">资源代理是一个响应Pacemaker的启动、监控和停止请求的脚本。这是连接集群和Google Cloud API的核心。</p><ol class=""><li id="0584" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">Corosync和Pacemaker启动并建立集群。</li><li id="522b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">Pacemaker选举一个资源作为领导者，并执行资源代理的启动命令。资源代理响应启动请求并启动nginx</li><li id="3c18" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">一旦NGINX启动，资源代理调用Google Cloud APIs将静态IP分配给运行它的服务器。</li><li id="34bf" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">“Pacemaker”然后监控资源代理，查看NGINX是否在服务器上运行，并响应健康检查请求。</li><li id="4ba0" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">如果在监控期间没有收到响应，备用实例的起搏器会检测到它，并认为它需要接管。</li><li id="22cb" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">备用实例中的“起搏器”选举备用实例资源代理作为领导者，并且它变成活动的。资源代理响应启动请求并启动nginx</li><li id="0c0a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">NGINX启动后，资源代理调用Google Cloud APIs将静态IP分配给备用服务器。</li><li id="dfa3" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">“Pacemaker”然后监控资源代理，查看NGINX是否在服务器上运行，并响应健康检查请求。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/b421cc76d7df1bfb20d02a7c2974a31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAY5z0qe4pAvezGs67IY7Q.png"/></div></div></figure><h1 id="9853" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">资源代理脚本</h1><p id="8f5d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">资源代理脚本构成了Pacemaker与Google云平台集成的主干。它负责调用相关的Google Cloud APIs来监控和分配VIP给请求它的实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">资源代理脚本</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">分配VIP脚本</figcaption></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="389a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示范</h1><p id="244e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我现在将使用两个运行NGINX的Google计算引擎实例来演示如何在Google Cloud上实现这一点。我们将使用Terraform来启动我们的服务器，然后我们将运行一些脚本来设置解决方案。</p><p id="9d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要安装Terraform CLI并设置一个服务帐户才能启动。</p><p id="99a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请阅读“<a class="ae ky" href="https://medium.com/better-programming/how-to-terraform-with-jenkins-and-slack-on-googles-cloud-platform-56c5e8b3aeeb?source=friends_link&amp;sk=bcaf32a62085e1ff98d44e87eb9d9c85#f1cb" rel="noopener">设置您的云环境</a>”和“<a class="ae ky" href="https://medium.com/better-programming/how-to-terraform-with-jenkins-and-slack-on-googles-cloud-platform-56c5e8b3aeeb?source=friends_link&amp;sk=bcaf32a62085e1ff98d44e87eb9d9c85#22c1" rel="noopener">安装Terraform </a>”以了解有关如何操作的更多详细信息。</p><h1 id="6fc7" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">加速您的基础设施</h1><p id="7f3e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们现在将启动运行设置所需的基础架构。当您应用Terraform时，它将启动两个GCE实例，其中NGINX安装了一个bastion主机服务器、一个内部静态VIP、一个外部静态VIP和一个用于出站互联网流量的云NAT。它还将配置防火墙规则，向您指定的源范围开放端口22和80，并开放UDP端口5404–5406，以便Corosync在节点之间进行通信。</p><p id="b0ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对Terraform运行以下命令来加速您的基础架构。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="f564" class="ob me it nx b gy oc od l oe of">git clone <a class="ae ky" href="https://github.com/bharatmicrosystems/gcp-failoverd.git" rel="noopener ugc nofollow" target="_blank">https://github.com/bharatmicrosystems/gcp-failoverd.git</a><br/>cd gcp-failoverd/<br/>cp terraform.tfvars.example terraform.tfvars</span></pre><p id="7d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修改<code class="fe og oh oi nx b">terraform.tfvars</code>文件，用<code class="fe og oh oi nx b">project</code>、<code class="fe og oh oi nx b">region</code>和<code class="fe og oh oi nx b">source_ranges</code>的相关值替换变量。</p><p id="afb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将你下载的JSON key复制到<code class="fe og oh oi nx b">gcp-failoverd/</code>中，重命名为<code class="fe og oh oi nx b">credentials.json</code>。</p><p id="117d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下内容</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="c71a" class="ob me it nx b gy oc od l oe of">terraform init<br/>terraform plan<br/>terraform apply</span></pre><h1 id="5b3c" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">设置高可用性</h1><p id="3dde" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们现在将在负载平衡器之间设置高可用性。</p><h2 id="96a6" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">登录到堡垒主机</h2><p id="ba55" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通过运行<code class="fe og oh oi nx b">gcloud compute ssh</code>命令从本地系统SSH到bastion主机。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="2df2" class="ob me it nx b gy oc od l oe of">gcloud compute ssh bastion --zone europe-west2-a</span></pre><p id="f22a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该打开一个与bastion主机的SSH会话。在bastion主机中，克隆<code class="fe og oh oi nx b">gcp-failoverd</code>存储库。</p><p id="99eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该存储库包含已经为您编写并在Google云平台上测试过的脚本。我们将浏览这些脚本，并探索它们的功能。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="c30d" class="ob me it nx b gy oc od l oe of">git clone <a class="ae ky" href="https://github.com/bharatmicrosystems/gcp-failoverd.git" rel="noopener ugc nofollow" target="_blank">https://github.com/bharatmicrosystems/gcp-failoverd.git</a><br/>cd gcp-failoverd/<br/>cp -a scripts/ exec/</span></pre><h1 id="0e46" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">快速启动</h1><p id="ba83" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">已经有一个自动脚本可以为您设置解决方案，并运行自动冒烟测试。你可以利用它来快速周转。</p><p id="e23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该脚本有以下用法</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="67b3" class="ob me it nx b gy oc od l oe of">sh -x setup-gcp-failoverd.sh -i [internal_vip_name] -e [external_vip_name] -l [load_balancers] -c [cluster_name] -h [health_check_endpoint]</span><span id="7e41" class="ob me it nx b gy ou od l oe of">Where:<br/>internal_vip_name : name of the static internal ip which needs to be attached to the active instance<br/>external_vip_name : name of the static external ip which needs to be attached to the active instance<br/>load_balancers : comma-separated list of load balancers part of the cluster<br/>health_check_endpoint : The endpoint that the agent needs to monitor to declare your service healthy. If you are serving the health endpoint on localhost:80/healthz, then write :80/healthz</span></pre><p id="1071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在我们的演示中使用自动化脚本，请运行以下命令:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="9c60" class="ob me it nx b gy oc od l oe of">cd exec/<br/>sh -x setup-gcp-failoverd.sh -i nginx-internal-vip -e nginx-external-vip -l nginx-instance01,nginx-instance02 -c nginx-cluster -h :80/</span></pre><h1 id="eed1" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">艰难的道路</h1><h2 id="aaca" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">安装起搏器和个人电脑</h2><p id="b1c8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">“Pacemaker”有助于管理集群，因此将corosync作为一个依赖项。PCS是一个命令行工具，有助于与起搏器互动。我们将在所有Nginx负载平衡器实例中安装它们。使用<code class="fe og oh oi nx b">gcloud compute ssh [instance_hostname] --internal-ip</code>登录虚拟机。您需要选择一个密码，确保在所有虚拟机上使用一致的密码。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="1f9b" class="ob me it nx b gy oc od l oe of">PASSWORD=[YOUR_CLUSTER_PASSWORD]<br/>sudo yum install -y pacemaker pcs<br/>sudo usermod --password $(openssl passwd -1 $PASSWORD) hacluster<br/>sudo systemctl enable pcsd.service<br/>sudo systemctl start pcsd.service<br/>sudo systemctl restart pcsd.service</span></pre><h2 id="c15c" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">配置集群</h2><p id="5395" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">仅登录到主实例<code class="fe og oh oi nx b">nginx-instance01</code></p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="06f0" class="ob me it nx b gy oc od l oe of">PASSWORD=[YOUR_CLUSTER_PASSWORD]<br/>CLUSTER_NAME=nginx-instance<br/>sudo pcs cluster auth nginx_instance01 nginx_instance02 -u hacluster -p $PASSWORD<br/>sudo pcs cluster setup --name $CLUSTER_NAME nginx_instance01 nginx_instance02<br/>sudo pcs cluster start --all<br/>sudo pcs status corosync<br/>sudo pcs cluster status<br/>sudo pcs property set stonith-enabled=false</span></pre><p id="bfab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="f521" class="ob me it nx b gy oc od l oe of">+ sudo pcs cluster auth nginx-instance01 nginx-instance02 -u hacluster -p $PASSWORD<br/>nginx-instance01: Authorized<br/>nginx-instance02: Authorized<br/>+ sudo pcs cluster setup --name nginx-cluster nginx-instance01 nginx-instance02<br/>Destroying cluster on nodes: nginx-instance01, nginx-instance02...<br/>nginx-instance01: Stopping Cluster (pacemaker)...<br/>nginx-instance02: Stopping Cluster (pacemaker)...<br/>nginx-instance02: Successfully destroyed cluster<br/>nginx-instance01: Successfully destroyed cluster</span><span id="001c" class="ob me it nx b gy ou od l oe of">Sending 'pacemaker_remote authkey' to 'nginx-instance01', 'nginx-instance02'<br/>nginx-instance01: successful distribution of the file 'pacemaker_remote authkey'<br/>nginx-instance02: successful distribution of the file 'pacemaker_remote authkey'<br/>Sending cluster config files to the nodes...<br/>nginx-instance01: Succeeded<br/>nginx-instance02: Succeeded</span><span id="1fad" class="ob me it nx b gy ou od l oe of">Synchronizing pcsd certificates on nodes nginx-instance01, nginx-instance02...<br/>nginx-instance01: Success<br/>nginx-instance02: Success<br/>Restarting pcsd on the nodes in order to reload the certificates...<br/>nginx-instance01: Success<br/>nginx-instance02: Success<br/>+ sudo pcs cluster start --all<br/>nginx-instance01: Starting Cluster (corosync)...<br/>nginx-instance02: Starting Cluster (corosync)...<br/>nginx-instance01: Starting Cluster (pacemaker)...<br/>nginx-instance02: Starting Cluster (pacemaker)...<br/>+ sudo pcs status corosync</span><span id="0a2c" class="ob me it nx b gy ou od l oe of">Membership information<br/>----------------------<br/>    Nodeid      Votes Name<br/>         1          1 nginx-instance01 (local)<br/>         2          1 nginx-instance02<br/>+ sudo pcs cluster status<br/>Cluster Status:<br/> Critical: Unable to get stonith-history<br/> Connection to the cluster-daemons terminated<br/> Reading stonith-history failed</span><span id="97e6" class="ob me it nx b gy ou od l oe of">PCSD Status:<br/>  nginx-instance01: Online<br/>  nginx-instance02: Online<br/>+ sudo pcs property set stonith-enabled=false</span></pre><h2 id="06f9" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">配置资源代理</h2><p id="32b8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">将资源代理文件复制到两台服务器上</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="c8b6" class="ob me it nx b gy oc od l oe of">loadbalancers=nginx_instance01,nginx_instance02<br/>for instance in $(echo $loadbalancers | tr ',' ' '); do<br/>  ZONE=`gcloud compute instances list --filter="name=${instance}"|grep ${instance} | awk '{ print $2 }'`<br/>  gcloud compute scp --zone=$ZONE --internal-ip gcp-failoverd.sh gcp-assign-vip.sh ${instance}:~/<br/>done</span></pre><p id="ac75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">登录到两个虚拟机并运行</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="54a6" class="ob me it nx b gy oc od l oe of">sudo systemctl enable corosync.service pacemaker.service<br/>sudo mkdir -p /usr/lib/ocf/resource.d/gcp<br/>sudo mv gcp-failoverd.sh /usr/lib/ocf/resource.d/gcp/gcp-failoverd<br/>sudo mv gcp-assign-vip.sh /usr/bin/gcp-assign-vip.sh<br/>sudo chmod +x /usr/lib/ocf/resource.d/gcp/gcp-failoverd<br/>sudo chmod +x /usr/bin/gcp-assign-vip.sh<br/>sudo chown -R root:root /usr/lib/ocf/resource.d/gcp<br/>sudo chown root:root /usr/bin/gcp-assign-vip.sh</span></pre><h2 id="5197" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">启动资源代理</h2><p id="d697" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">登录到活动服务器nginx-instance01</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="b18d" class="ob me it nx b gy oc od l oe of">sudo pcs resource create GCPFailoverd ocf:gcp:gcp-failoverd internal_vip=nginx-internal-vip external_vip=nginx-external-vip healthz=:80/<br/>sudo pcs status</span></pre><p id="5a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="0d9e" class="ob me it nx b gy oc od l oe of">+ sudo pcs status<br/>Cluster name: nginx-cluster<br/>Stack: corosync<br/>Current DC: nginx-instance02 (version 1.1.20-5.el7_7.2-3c4c782f70) - partition with quorum<br/>Last updated: Thu Apr 16 15:09:13 2020<br/>Last change: Thu Apr 16 14:49:31 2020 by hacluster via crmd on nginx-instance02</span><span id="cc71" class="ob me it nx b gy ou od l oe of">2 nodes configured<br/>1 resource configured</span><span id="dd07" class="ob me it nx b gy ou od l oe of">Online: [ nginx-instance01 nginx-instance02 ]</span><span id="7453" class="ob me it nx b gy ou od l oe of">Full list of resources:</span><span id="9db7" class="ob me it nx b gy ou od l oe of">GCPFailoverd   (ocf::gcp:gcp-failoverd):       Started nginx-instance01</span><span id="1baa" class="ob me it nx b gy ou od l oe of">Daemon Status:<br/>  corosync: active/enabled<br/>  pacemaker: active/enabled<br/>  pcsd: active/enabled</span></pre><h1 id="cc75" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">烟气试验</h1><p id="db93" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们现在将运行一些冒烟测试，以查看设置是否按预期工作</p><h2 id="c24e" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">获取内部IP</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="1103" class="ob me it nx b gy oc od l oe of">healthz=:80/<br/>internal_vip=nginx-internal-vip<br/>external_vip=nginx-external-vip<br/>INTERNAL_IP=`gcloud compute addresses list --filter="name=$internal_vip"| grep $internal_vip | awk '{ print $2 }'`</span></pre><h2 id="2dfe" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">等待IP分配</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="f6da" class="ob me it nx b gy oc od l oe of">INTERNAL_IP_STATUS=`gcloud compute addresses list --filter="name=$internal_vip"| grep $internal_vip | awk '{ print $NF }'`<br/>while [[ $INTERNAL_IP_STATUS != "IN_USE" ]]; do<br/>  INTERNAL_IP_STATUS=`gcloud compute addresses list --filter="name=$internal_vip"| grep $internal_vip | awk '{ print $NF }'`<br/>  echo "Waiting for the IP $INTERNAL_IP to be alloted to an instance"<br/>  echo "Sleeping for 10 secs..."<br/>  sleep 10<br/>done</span></pre><p id="e4bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="1dc8" class="ob me it nx b gy oc od l oe of">INTERNAL_IP_STATUS=RESERVED<br/>Waiting for the IP 10.154.15.192 to be alloted to an instance<br/>Sleeping for 10 secs...<br/>INTERNAL_IP_STATUS=RESERVED<br/>Waiting for the IP 10.154.15.192 to be alloted to an instance<br/>Sleeping for 10 secs...<br/>INTERNAL_IP_STATUS=IN_USE</span></pre><h2 id="a54c" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">获取分配给内部IP的GCE实例</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="be16" class="ob me it nx b gy oc od l oe of">INTERNAL_INSTANCE_REGION=$(gcloud compute addresses list --filter="name=${internal_vip}"|grep ${internal_vip}|awk '{print $(NF-2)}')<br/>INTERNAL_INSTANCE_NAME=$(gcloud compute addresses describe ${internal_vip} --region=${INTERNAL_INSTANCE_REGION} --format='get(users[0])'|awk -F'/' '{print $NF}')<br/>INTERNAL_INSTANCE_ZONE=$(gcloud compute instances list --filter="name=${INTERNAL_INSTANCE_NAME}"|grep ${INTERNAL_INSTANCE_NAME}|awk '{print $2}')<br/>INTERNAL_INSTANCE_STATUS=$(gcloud compute instances describe --zone=${INTERNAL_INSTANCE_ZONE} $INTERNAL_INSTANCE_NAME --format='get(status)')<br/>echo "$INTERNAL_IP has been allocated to $INTERNAL_INSTANCE_NAME at $(date)"</span></pre><p id="dc27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="f75a" class="ob me it nx b gy oc od l oe of">10.154.15.192 has been allocated to nginx-instance01 at Thu Apr 16 14:52:00 UTC 2020</span></pre><h2 id="c22f" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">调用NGINX端点</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="9855" class="ob me it nx b gy oc od l oe of">$ status=$(curl -s -o /dev/null -w '%{http_code}' <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/$EXTERNAL_IP$healthz">http://$INTERNAL_IP$healthz</a>)<br/>$ echo "$(date): internal status: $status"</span></pre><p id="0cde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="970e" class="ob me it nx b gy oc od l oe of">Thu Apr 16 14:49:58 UTC 2020: internal status: 200</span></pre><h2 id="15f9" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">获取外部IP</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="6911" class="ob me it nx b gy oc od l oe of">EXTERNAL_IP=`gcloud compute addresses list --filter="name=$external_vip"| grep $external_vip | awk '{ print $2 }'`</span></pre><h2 id="bdc5" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">等待IP分配</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="82bc" class="ob me it nx b gy oc od l oe of">EXTERNAL_IP_STATUS=`gcloud compute addresses list --filter="name=$external_vip"| grep $external_vip | awk '{ print $NF }'`<br/>while [[ $EXTERNAL_IP_STATUS != "IN_USE" ]]; do<br/>  EXTERNAL_IP_STATUS=`gcloud compute addresses list --filter="name=$external_vip"| grep $external_vip | awk '{ print $NF }'`<br/>  echo "Waiting for the IP $EXTERNAL_IP to be alloted to an instance"<br/>  echo "Sleeping for 10 secs..."<br/>  sleep 10<br/>done</span></pre><p id="1223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="1f57" class="ob me it nx b gy oc od l oe of">EXTERNAL_IP_STATUS=IN_USE</span></pre><h2 id="f7b9" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">获取分配给外部IP的GCE实例</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="46f4" class="ob me it nx b gy oc od l oe of">EXTERNAL_INSTANCE_REGION=$(gcloud compute addresses list --filter="name=${external_vip}"|grep ${external_vip}|awk '{print $(NF-1)}')<br/>EXTERNAL_INSTANCE_NAME=$(gcloud compute addresses describe ${external_vip} --region=${EXTERNAL_INSTANCE_REGION} --format='get(users[0])'|awk -F'/' '{print $NF}')<br/>EXTERNAL_INSTANCE_ZONE=$(gcloud compute instances list --filter="name=${EXTERNAL_INSTANCE_NAME}"|grep ${EXTERNAL_INSTANCE_NAME}|awk '{print $2}')<br/>EXTERNAL_INSTANCE_STATUS=$(gcloud compute instances describe --zone=${EXTERNAL_INSTANCE_ZONE} $EXTERNAL_INSTANCE_NAME --format='get(status)')<br/>echo "$EXTERNAL_IP has been allocated to $EXTERNAL_INSTANCE_NAME at $(date)"</span></pre><p id="efac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="e742" class="ob me it nx b gy oc od l oe of">35.230.154.167 has been allocated to nginx-instance01 at Thu Apr 16 14:52:17 UTC 2020</span></pre><h2 id="8af0" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">调用NGINX端点</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="376a" class="ob me it nx b gy oc od l oe of">$ status=$(curl -s -o /dev/null -w '%{http_code}' <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/$EXTERNAL_IP$healthz">http://$EXTERNAL_IP$healthz</a>)<br/>$ echo "$(date): external status: $status"</span></pre><p id="9bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="df2e" class="ob me it nx b gy oc od l oe of">Thu Apr 16 14:52:17 UTC 2020: external status: 200</span></pre><h2 id="5eab" class="ob me it bd mf oj ok dn mj ol om dp mn li on oo mp lm op oq mr lq or os mt ot bi translated">停止运行NGINX的实例</h2><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="5f9d" class="ob me it nx b gy oc od l oe of">gcloud compute instances stop -q --zone europe-west2-a nginx-instance01</span></pre><p id="40a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="f959" class="ob me it nx b gy oc od l oe of">Stopping instance(s) nginx-instance01...done.<br/>Updated [<a class="ae ky" href="https://compute.googleapis.com/compute/v1/projects/my-project-1505734237566/zones/europe-west2-a/instances/nginx-instance01" rel="noopener ugc nofollow" target="_blank">https://compute.googleapis.com/compute/v1/projects/my-project-1505734237566/zones/europe-west2-a/instances/nginx-instance01</a>].</span></pre><p id="cfbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等待60秒，然后重复这些步骤。您会发现IP已成功切换到第二个实例。</p><h1 id="5156" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">结论</h1><p id="dc2f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">感谢阅读，我希望你喜欢这篇文章。请在下面找到一些我在故事中使用的有用链接</p><div class="ov ow gp gr ox oy"><a href="https://github.com/bharatmicrosystems/gcp-failoverd/blob/master/scripts/configure-gcp-failoverd-start.sh" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">bharat Microsystems/GCP-failoved</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">Permalink GitHub是4000多万开发人员的家园，他们一起工作来托管和审查代码、管理项目以及…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://cloud.google.com/load-balancing/docs/choosing-load-balancer" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">选择负载平衡器|负载平衡|谷歌云</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">本文档帮助您确定哪种Google云负载平衡器最能满足您的需求。要决定哪个负载平衡器…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">cloud.google.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ks oy"/></div></div></a></div></div></div>    
</body>
</html>