# 增强创造性的设计模式

> 原文：<https://levelup.gitconnected.com/enhancing-creational-design-patterns-a75532c39d87>

![](img/4405fea7b3b148fe305eafce25d3ac95.png)

照片由 [JJ 英](https://unsplash.com/@jjying?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

多年来，我已经使用不同的技术栈成功地应用了许多不同的设计模式。由于将它们写下来的想法是在 20 世纪 90 年代出现的，并且很大程度上基于当时最流行的编程语言的面向对象的内在特性，所以在将模式移植到我选择的语言和框架时，我需要做出某些让步以及特定的增强。这篇文章总结了我所有关于修改*创造性设计模式*的想法。

## 免责声明:

*   我所说的*抽象类*本质上是指用于创建派生类的模板(不能存在*抽象类*的直接实例)——在一些语言中，这个概念可以通过声明一个简单的*接口*来实现
*   一个*类*可能从一个*抽象类*继承，类似地，在某些语言中，一个*接口*或者一个*类*可能实现另一个*接口*
*   一个*类型*是一个特定类型系统的每个可定义组件(类、接口、枚举、联合、类型文字等等)。

# 工厂方法

一些编程语言——可以说是那些受函数式编程影响很大的语言——支持 [*类型联合*](https://gregoryppabian.medium.com/creating-tagged-unions-in-typescript-ce727a306878) 的概念，在创建普通类型层次结构时可以利用这种概念。使用经典的 OOP 方法，如果我要为水果构建一个层次结构，我将定义如下:

*   一个叫做`Fruit`的抽象类，
*   一个名为`Apple`(继承自`Fruit`)的类，
*   一个叫做`Banana`的类(继承自`Fruit`)。

上述方法要求首先定义抽象类型，然后开发人员才能写下具体类型。有人可能会说颠倒这个顺序违背了坚实规则的精神，但是一个自包含的项目不需要考虑那么多第三方可扩展性。定义层次结构的函数式编程方法包括定义:

*   一种叫`Apple`的类型，
*   一种叫做`Banana`的类型，
*   被称为`Fruit`的*联合类型*是`Apple`和`Banana`的联合。

*联合类型*可以在运行时轻松转换为其具体类型(例如，通过使用类型鉴别器属性)，而从接口或抽象类的实例获取具体类型需要 RTTI，这被许多开发人员认为是不良做法。

因此，工厂方法模式的扩展建议使用一个*联合类型*而不是一个*抽象类*作为工厂方法的返回类型。

# 抽象工厂

抽象工厂模式允许开发人员创建不同的域连接实例组。因为我发现这种模式本身定义得很好，因此没有太多改进的空间，所以我在这里只关注数据结构方面。

该模式的核心组件是*抽象工厂*，它通常被实现为一个抽象类，带有几个虚拟方法，旨在产生一个不同的、但与域相关的抽象类的实例。所有生成的实例都属于同一个域，但是它们不应该自然地组合成另一个类的实例。

作为一个例子，我可以想到一个名为`TokenFactory`的抽象类，它为独立的消费者产生不同类型的令牌。出于本文的目的，假设有两种虚拟(抽象)方法可用:

*   返回一个`BasicAuthToken`实例的`buildBasicAuthToken`方法，
*   返回一个`JsonWebToken`实例的`buildJsonWebToken`方法。

两个返回的类型都符合同一个*令牌*域，它们不能组合成更大的东西(因为这些令牌通常不会一起使用)。`TokenFactory`的可能实现包括:

*   创建令牌供用户与后端通信的`UserTokenFactory`类，
*   为后端间通信创建后端令牌的`BackendTokenFactory`类。

这两个新工厂增加了 4 个具体的令牌类:

*   扩展了`BasicAuthToken`抽象类的`UserBasicAuthToken`和`BackendBasicAuthToken`类。
*   扩展了`JsonWebToken`抽象类的`UserJsonWebToken`和`BackendJsonWebToken`类。

有经验的软件开发人员知道，当编写同一抽象类的另一个实现时，代码片段通常会被复制。假设`UserTokenFactory`首先被实现，然后为了创建`BackendTokenFactory`而被复制。可能会发生这样的情况，它可能被覆盖的`buildBasicAuthToken`方法仍然返回一个`UserBasicAuthToken`类的实例，这个明显的错误可能不会被编译器发现，因为`UserBasicAuthToken`类确实扩展了`BasicAuthToken`抽象类。

如果所选编程语言的类型系统允许的话，解决这个问题的正确方法是将工厂和类型绑定到具体的组标识。最流行的语言允许使用*泛型*实现这样的绑定。出于向编译器告知业务逻辑概念的目的，可以将它视为增加代码库的复杂性。

首先，我先介绍一种叫做`Actor`的新类型。它可以是枚举类型、文字类型或空抽象类，这取决于所选语言支持的内容。它只有两个相当明显的亚型——`User`和`Backend`。

`TokenFactory`抽象类现在变成了参数化的`TokenFactory<A extends Actor>`抽象类——这意味着在代码的任何位置，如果不指定任何参数，就不可能存在扩展上述类型的具体类。因此，必须发生以下变化:

*   `UserTokenFactory`类现在扩展了`TokenFactory<User>`类，
*   `BackendTokenFactory`类现在扩展了`TokenFactory<Backend>`类。

如果类方法不依赖于泛型，那么泛型就没有用，这就需要额外的改变:

*   `BaseToken`抽象类现在变成了`BasicAuthToken<A extends Actor>`抽象类，
*   `UserBasicAuthToken`类现在扩展了`BasicAuthToken<User>`类，
*   `BackendBasicAuthToken`类现在扩展了`BasicAuthToken<Backend>`类，
*   `JsonWebToken`抽象类现在变成了`JsonWebToken<A extends Actor>`抽象类，
*   `UserJsonWebToken`类现在扩展了`JsonWebToken<User>`类，
*   `BackendJsonWebToken`级现在扩展了`JsonWebToken<Backend>`级，
*   现在返回一个`BasicAuthToken<A extends Actor>`实例的`buildBasicAuthToken`方法，
*   现在返回一个`JsonWebToken<A extends Actor>`实例的`buildJsonWebToken`方法。

为了充分理解这里解释的基于泛型的增强，我建议读者尝试用自己选择的语言实现前面解释的架构。请注意，根据类型系统的不同，并不是我在这里做的所有操作和假设都是可能的。

# 建设者

在非常基础的层面上，可以说构建器设计模式是复杂构造器的替代策略。通常，我会建议立即减少上述的复杂性，但我确实意识到解决这样的问题并不总是可行的。然而，对于每一种语言，对于函数的复杂性都存在着完全不同的想法:

*   在 Java 中，方法参数是位置性的——为了简化方法调用，可以声明多个(*重载*)方法，因为没有默认参数值的概念，
*   在 Python 中，函数参数可以是位置参数，也可以是关键字参数，它们可以通过多种方式传递，这大大降低了调用的复杂性，
*   在 JavaScript 中，函数参数是位置性的，可能有默认值。

通过分析这些案例，很容易确定三个不同的问题:

*   默认参数值的存在，
*   位置和关键字参数，
*   允许的参数子集。

根据我的经验，( *implicit* )默认参数值应该是永远不需要的，因为它们可以从调用函数中显式传递。一些默认值作为一种隐藏的方式来执行某些业务逻辑需求。最后，有些语言甚至根本不支持函数中有默认值的概念。

在支持关键字参数的语言中有一个*生成器*，与只支持位置参数的语言相比，关键字参数的重要性较低。如果可以现场创建字典，那么可以将函数重新定义为只有一个参数，即由前面的位置参数组成的字典。这种模式在 JavaScript 和 TypeScript 中是可用的。

当只允许构造函数使用预定义的参数子集时，*构建器模式*就派上了用场，前提是它不能被相关语言的类型系统强制执行(这里考虑一下 TypeScript)。在这样的配置中，构建器负责检查需求并抛出异常，而对象构造器只是创建对象。更不用说*生成器*可以为没有提供的参数分配默认值。

# 原型

在我们开始钻研*原型设计模式*之前，让我们定义一下在大多数现代语言中复制一个对象通常有哪些方法:

*   深度复制(对象属性值被递归复制)，
*   浅层复制(不复制对象属性值)。

如果我们主要使用不可变的结构，我们根本不需要依赖深度复制。毕竟，对于大型结构来说，深度复制可能是一项开销很大的操作:

*   耗时，因为无法保证数据本身在内存中的布局(内存分页)，
*   空间昂贵，因为我们必须为数据保留相同的空间，并为管理这些数据保留一些开销空间。

此外，深度复制容易出现循环引用的问题。如果我们决定只使用浅层复制，在一些编程语言(例如 JavaScript、Python)中，这个操作已经可以作为一个单行代码来完成。这种情况使得传统形式的原型模式几乎过时了。

一些语言(JavaScript、TypeScript)是基于原型的，如果我们同意遵循这种特殊的范式，这使得浅层复制更加容易。

# 一个

在与语言无关的层面上，我将把*单例模式*定义为一种机制，在运行时，从预定义的对象家族中最多存在一个对象。对于面向对象的语言，这自然可以归结为一个类的单个实例——对于功能性更强的语言，这就变成了从原型创建的单个对象。

独生子女的有效性可以用以下标准来衡量:

*   创建和维护的复杂性，
*   它对其余代码库和测试设置的影响，
*   它在单线程和多线程系统中的行为。

当依赖注入机制管理单例实例而不是利用定义单例的编程语言中的全局变量支持时，推断单例实例的副作用肯定更容易。

事实上，没有必要在整个代码库中使用跨越依赖注入容器的框架。如果代码库是以支持传递显式依赖关系的方式构建的，并且可以在程序执行的开始初始化单例，那么就可以创建它的实例并将其传递给必要的组件。

# 摘要

正如我所展示的，设计模式的大多数增强来自于在当代多范例编程语言中实现类型系统的潜力。某些软件实践的新颖性使得一些模式变得过时，或者更确切地说，从根本上改变了。我相信，在不久的将来，许多当前新奇的解决方案将被添加到无处不在的设计模式中。