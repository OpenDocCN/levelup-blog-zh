<html>
<head>
<title>Understanding Variables, Scope, and Hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的变量、范围和提升</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-variables-scope-and-hoisting-in-javascript-93018bf29190?source=collection_archive---------20-----------------------#2020-07-29">https://levelup.gitconnected.com/understanding-variables-scope-and-hoisting-in-javascript-93018bf29190?source=collection_archive---------20-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5064" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">更好的编程</h2><div class=""/><div class=""><h2 id="1f5f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们来详细看看var，Let和const。它们是如何工作的？他们的不同？以及为什么了解它们如此重要</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/36998603b1c780c8e8794457403a5524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNX29hLlIkq5tAJMxvacHQ.jpeg"/></div></div></figure><p id="456a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">变量是任何编程语言的基本块之一，每种语言定义我们如何声明变量并与变量交互的方式可以成就或毁灭一种编程语言。因此，任何开发人员都需要了解如何有效地处理变量、它们的规则和特性。在今天的教程中，我们将学习如何在JavaScript中声明、交互和作用域变量。我们将介绍新概念和重要的JavaScript关键字，如<code class="fe lz ma mb mc b">var</code>、<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code>。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="e667" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">声明变量</h1><p id="4289" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">现在JavaScript有三个不同的关键字来声明一个变量，<code class="fe lz ma mb mc b">var</code>、<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code>。每一种都有自己的属性和特点。让我们先做一个三者的简单对比表，然后进入细节。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nh"><img src="../Images/216180fcddbbb1653a3d2ca791d82daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWdnP1Nsm63HXlqlvGIW1A.png"/></div></div></figure><p id="4c27" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果现在您不确定我们所说的范围、提升或任何其他属性是什么意思，请不要担心。接下来我们将详细介绍它们。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="d35e" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">变量作用域</h1><p id="8396" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">JavaScript中的作用域指的是代码的上下文(或部分)，它决定了变量的可访问性(可见性)。在JavaScript中，我们有两种类型的作用域，<strong class="lf jd">局部</strong>和<strong class="lf jd">全局</strong>。尽管局部范围可能有不同的含义。</p><p id="354f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们通过给出一些作用域如何工作的例子来完成定义。假设您定义了一个变量<code class="fe lz ma mb mc b">message</code>:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="39a0" class="nm ml it mc b gy nn no l np nq">const message = 'Hello World'<br/>console.log(message) // 'Hello World'</span></pre><p id="676b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如您所料，在<code class="fe lz ma mb mc b">console.log</code>中使用的变量<code class="fe lz ma mb mc b">message</code>将会存在，并具有值<code class="fe lz ma mb mc b">Hello World</code>。毫无疑问，但是如果我稍微改变一下声明变量的地方，会发生什么呢？</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="4d33" class="nm ml it mc b gy nn no l np nq">if (true) {<br/>    const message = 'Hello World'<br/>}<br/>console.log(message) // ReferenceError: message is not defined</span></pre><p id="7c7e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Ups…看起来我们把它弄坏了，但是为什么？事情是这样的，<code class="fe lz ma mb mc b">if</code>语句创建了一个本地<strong class="lf jd">块作用域</strong>，由于我们使用了<code class="fe lz ma mb mc b">const</code>，该变量只为那个<strong class="lf jd">块作用域</strong>声明，不能从外部访问。</p><p id="fffd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们再多谈谈块和函数作用域。</p><h1 id="9f6c" class="mk ml it bd mm mn nr mp mq mr ns mt mu ki nt kj mw kl nu km my ko nv kp na nb bi translated">块范围</h1><p id="0bfc" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">一个块基本上是一段代码(零个或多个语句),由一对花括号分隔，可以选择标记。</p><p id="cf3f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如我们已经讨论过的，使用<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code>允许我们定义存在于块范围内的变量。接下来，我们将通过使用不同的关键字生成新的范围来构建非常相似的示例:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="36df" class="nm ml it mc b gy nn no l np nq">const x1 = 1<br/>{<br/>    const x1 = 2<br/>    console.log(x1) // 2<br/>}<br/>console.log(x1) // 1</span></pre><p id="3e12" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们解释一下这个，因为它乍一看可能有点奇怪。在我们的外部作用域中，我们用值<code class="fe lz ma mb mc b">1</code>定义变量<code class="fe lz ma mb mc b">x1</code>。然后我们通过简单地使用花括号创建一个新的块范围，这很奇怪，但是在JavaScript中完全合法，在这个新的范围中，我们创建了一个新的变量(与外部范围中的变量分开)，也命名为<code class="fe lz ma mb mc b">x1</code>。但是不要搞混了，这是一个全新的变量，只会在那个范围内可用。</p><p id="1bb2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样的例子现在有一个命名的作用域:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="b854" class="nm ml it mc b gy nn no l np nq">const x2 = 1<br/>myNewScope: { // Named scope<br/>    const x2 = 2<br/>    console.log(x2) // 2<br/>}<br/>console.log(x2) // 1</span></pre><p id="8626" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">While示例(<strong class="lf jd">不运行下面的代码！！！！！！！！！！！！！！！！</strong>)</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="a15d" class="nm ml it mc b gy nn no l np nq">const x3 = 1<br/>while(x3 === 1) {<br/>    const x3 = 2<br/>    console.log(x3) // 2<br/>}<br/>console.log(x3) // Never executed</span></pre><p id="6972" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你能猜出那个代码有什么问题吗？如果你运行它会发生什么？…让我解释一下，外部作用域中声明的<code class="fe lz ma mb mc b">x3</code>用于while比较<code class="fe lz ma mb mc b">x3 === 1</code>，通常在while语句中，我可以给<code class="fe lz ma mb mc b">x3</code>重新分配一个新值并退出循环，但是由于我们在块作用域中声明了一个新的<code class="fe lz ma mb mc b">x3</code>，我们不能再从外部作用域中更改<code class="fe lz ma mb mc b">x3</code>，因此while条件将始终计算为<code class="fe lz ma mb mc b">true</code>，产生一个无限循环，这将挂起您的浏览器，或者如果您使用终端在NodeJS上运行它，将打印大量的<code class="fe lz ma mb mc b">2</code>。</p><p id="bbdf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">修复这段特殊的代码可能会很棘手，除非您实际重命名这两个变量中的任何一个。</p><p id="8139" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">到目前为止，在我们的例子中，我们使用了<code class="fe lz ma mb mc b">const</code>，但是完全相同的行为会发生在<code class="fe lz ma mb mc b">let</code>中。然而，我们在我们的对照表中看到，关键字<code class="fe lz ma mb mc b">var</code>实际上是函数作用域，那么它对我们的例子意味着什么呢？嗯……让我们来看看:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="2fc6" class="nm ml it mc b gy nn no l np nq">var x4 = 1<br/>{<br/>    var x4 = 2<br/>    console.log(x4) // 2<br/>}<br/>console.log(x4) // 2</span></pre><p id="998c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">太神奇了！即使我们在作用域内重新声明了<code class="fe lz ma mb mc b">x4</code>,它也在内部作用域和外部作用域上将值更改为<code class="fe lz ma mb mc b">2</code>。这是<code class="fe lz ma mb mc b">let</code>、<code class="fe lz ma mb mc b">const</code>和<code class="fe lz ma mb mc b">var</code>之间最重要的区别之一，通常是面试问题的主题(以这样或那样的方式)。</p><h1 id="723f" class="mk ml it bd mm mn nr mp mq mr ns mt mu ki nt kj mw kl nu km my ko nv kp na nb bi translated">功能范围</h1><p id="ce87" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">函数作用域在某种程度上也是块作用域，所以<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code>的行为方式与我们之前的例子中的相同。然而，函数作用域也封装了用<code class="fe lz ma mb mc b">var</code>声明的变量。但是让我们继续看我们的<code class="fe lz ma mb mc b">xn</code>例子:</p><p id="1079" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe lz ma mb mc b">const</code>或<code class="fe lz ma mb mc b">let</code>示例:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="d5b8" class="nm ml it mc b gy nn no l np nq">const x5 = 1<br/>function myFunction() {<br/>    const x5 = 2<br/>    console.log(x5) // 2<br/>}<br/>myFunction()<br/>console.log(x5) // 1</span></pre><p id="b488" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如我们所料，现在有了<code class="fe lz ma mb mc b">var</code></p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="53fb" class="nm ml it mc b gy nn no l np nq">var x6 = 1<br/>function myFunction() {<br/>    var x6 = 2<br/>    console.log(x6) // 2<br/>}<br/>myFunction()<br/>console.log(x6) // 1</span></pre><p id="1109" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这种情况下，var的工作方式与<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code>相同。此外:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="4a76" class="nm ml it mc b gy nn no l np nq">function myFunction() {<br/>    var x7 = 1<br/>}<br/>console.log(x7) // ReferenceError: x7 is not defined</span></pre><p id="a401" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如我们所见，<code class="fe lz ma mb mc b">var</code>声明只存在于创建它们的函数中，不能从外部访问。</p><p id="9b18" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是还有更多，因为JS一直在发展，新类型的作用域已经被创建。</p><h1 id="eb22" class="mk ml it bd mm mn nr mp mq mr ns mt mu ki nt kj mw kl nu km my ko nv kp na nb bi translated">模块范围</h1><p id="9fe5" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">随着ES6中模块的引入，模块中的变量不直接影响其他模块中的变量变得非常重要。你能想象从一个库中导入模块会与你的变量发生冲突吗？连JS都没那么乱！因此根据定义，模块创建自己的作用域，它封装了所有用<code class="fe lz ma mb mc b">var</code>、<code class="fe lz ma mb mc b">let</code>或<code class="fe lz ma mb mc b">const</code>创建的变量，类似于函数作用域。</p><p id="0a66" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">尽管模块提供了导出变量的方法，因此可以从模块外部访问它们，我已经在文章<a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/an-intro-to-javascript-modules-36c07c5d4c9c">JavaScript模块简介</a>中介绍过了。</p><p id="3ba6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">到目前为止，我们已经讨论了不同类型的<strong class="lf jd">局部</strong>作用域，现在让我们深入到<strong class="lf jd">全局</strong>作用域。</p><h1 id="58b9" class="mk ml it bd mm mn nr mp mq mr ns mt mu ki nt kj mw kl nu km my ko nv kp na nb bi translated">全球范围</h1><p id="9783" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">在任何函数、块或模块范围之外定义的变量都具有全局范围。可以从应用程序的任何地方访问全局范围内的变量。</p><p id="05c9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">全局作用域有时会与模块作用域混淆，但事实并非如此，全局作用域变量可以跨模块使用，尽管这被认为是一种不好的做法，而且理由很充分。</p><p id="bd12" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你将如何声明一个全局变量？这取决于上下文，它在浏览器和NodeJS应用程序上是不同的。在浏览器的上下文中，您可以做一些简单的事情，如:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="3789" class="nm ml it mc b gy nn no l np nq">&lt;script&gt;<br/>    let MESSAGE = 'Hello World'<br/>    console.log(MESSAGE)<br/>&lt;/script&gt;</span></pre><p id="55b7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">或者使用窗口对象:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="4d41" class="nm ml it mc b gy nn no l np nq">&lt;script&gt;<br/>    window.MESSAGE = 'Hello World'<br/>    console.log(MESSAGE)<br/>&lt;/script&gt;</span></pre><p id="4a21" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你想做这样的事情是有原因的，但是，做的时候要小心。</p><h1 id="f45b" class="mk ml it bd mm mn nr mp mq mr ns mt mu ki nt kj mw kl nu km my ko nv kp na nb bi translated">嵌套范围</h1><p id="ac0d" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">您可能已经猜到了，嵌套作用域是可能的，这意味着在另一个作用域中创建一个作用域，这是一种非常常见的做法。简单地通过在函数中添加一个<code class="fe lz ma mb mc b">if</code>语句，我们就可以做到这一点。让我们看一个例子:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="31f2" class="nm ml it mc b gy nn no l np nq">function nextedScopes() {<br/>    const message = 'Hello World!'</span><span id="67ae" class="nm ml it mc b gy nx no l np nq">    if (true) {<br/>        const fromIf = 'Hello If Block!'<br/>        console.log(message) // Hello World!<br/>    }</span><span id="5d53" class="nm ml it mc b gy nx no l np nq">    console.log(fromIf) // ReferenceError: fromIf is not defined<br/>}</span><span id="06c3" class="nm ml it mc b gy nx no l np nq">nextedScopes()</span></pre><h1 id="e92c" class="mk ml it bd mm mn nr mp mq mr ns mt mu ki nt kj mw kl nu km my ko nv kp na nb bi translated">词汇范围</h1><p id="7fef" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">在某种程度上，我们已经利用了词法范围，尽管我们并不知道它。词法范围仅仅意味着子范围可以访问外部范围中定义的变量。</p><p id="eb4a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们来看一个例子:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="b756" class="nm ml it mc b gy nn no l np nq">function outerScope() {<br/>    var name = 'Juan'<br/>    function innerScope() {<br/>        console.log(name) // 'Juan'<br/>    }</span><span id="9bad" class="nm ml it mc b gy nx no l np nq">    return innerScope<br/>}</span><span id="bffb" class="nm ml it mc b gy nx no l np nq">const inner = outerScope()<br/>inner()</span></pre><p id="1bfe" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">那看起来比实际情况更奇怪，所以我们来解释一下。函数<code class="fe lz ma mb mc b">outerScope</code>声明了一个值为<code class="fe lz ma mb mc b">Juan</code>的变量<code class="fe lz ma mb mc b">name</code>和一个名为<code class="fe lz ma mb mc b">innerScope</code>的函数。后者没有为自己的作用域声明任何变量，而是使用了在外部函数作用域中声明的变量<code class="fe lz ma mb mc b">name</code>。</p><p id="c670" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当<code class="fe lz ma mb mc b">outerScope()</code>被调用时，它返回对<code class="fe lz ma mb mc b">innerScope</code>函数的引用，稍后从最外层的作用域调用该函数。当第一次阅读这段代码时，你可能会感到困惑，为什么<code class="fe lz ma mb mc b">innerScope</code>将<code class="fe lz ma mb mc b">console.log</code>的值<code class="fe lz ma mb mc b">Juan</code>作为我们从全局作用域或模块作用域调用它，而<code class="fe lz ma mb mc b">name</code>并未声明。</p><p id="cb06" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这之所以有效是因为JavaScript闭包。闭包是一个独立的主题，你可以在MDN文档中读到更多。我正计划写一篇文章，用简单的术语解释闭包，但在撰写本文时还没有准备好。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="53c1" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">提升</h1><p id="6afd" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">就JavaScript而言，提升意味着在编译阶段会在内存中创建一个变量，因此在实际声明之前就可以使用它们。听起来超级混乱，我们最好在代码中看到它。</p><p id="7476" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是正常流程的样子:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="b325" class="nm ml it mc b gy nn no l np nq">function displayName(name) {<br/>    console.log(name)<br/>}</span><span id="1ad1" class="nm ml it mc b gy nx no l np nq">displayName('Juan')</span><span id="cc66" class="nm ml it mc b gy nx no l np nq">//***********************<br/>// Outputs<br/>//***********************<br/>// 'Juan'</span></pre><p id="cae6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">厉害！正如所料，这是可行的，但您对以下内容有什么看法:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="d39f" class="nm ml it mc b gy nn no l np nq">hoistedDisplayName('Juan')</span><span id="5673" class="nm ml it mc b gy nx no l np nq">function hoistedDisplayName(name) {<br/>    console.log(name)<br/>}</span><span id="0d73" class="nm ml it mc b gy nx no l np nq">//***********************<br/>// Outputs<br/>//***********************<br/>// 'Juan'</span></pre><p id="1cd0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">等等等等。什么？听起来很疯狂，因为函数是在代码实际运行之前分配给内存的，所以函数<code class="fe lz ma mb mc b">hoistedDisplayName</code>在它的实际定义之前是可用的，至少在代码行方面是如此。</p><p id="c0c0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">函数有这个特殊的属性，但是用<code class="fe lz ma mb mc b">var</code>声明的变量也有。让我们看一个例子:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="d0e9" class="nm ml it mc b gy nn no l np nq">console.log(x8) // undefined<br/>var x8 = 'Hello World!'</span></pre><p id="2b80" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不是你猜的那样？变量在代码中实际定义之前被“创建”的事实并不意味着它的值已经被赋值，这就是为什么当我们执行<code class="fe lz ma mb mc b">console.log(x8)</code>时，我们没有得到一个错误说变量没有被声明，而是变量有值<code class="fe lz ma mb mc b">undefined</code>。非常有趣，但是如果我们使用<code class="fe lz ma mb mc b">let</code>或<code class="fe lz ma mb mc b">const</code>会发生什么？请记住，在我们的表中，他们不共享此属性。</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="1c95" class="nm ml it mc b gy nn no l np nq">console.log(x9) // Cannot access 'x9' before initialization<br/>const x9 = 'Hello World!'</span></pre><p id="031f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它抛出了一个错误。</p><p id="ebaf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">提升是JavaScript变量的一个鲜为人知的属性，但也是一个重要的属性。确保你理解了不同之处，这对你的代码很重要，它可能是一个面试问题的主题。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="0a4b" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">变量的重新分配</h1><p id="71de" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">本主题专门介绍用关键字<code class="fe lz ma mb mc b">const</code>声明的变量。用<code class="fe lz ma mb mc b">const</code>声明的变量不能被重新赋值，这意味着我们不能为一个新的变量改变它的值，但是有一个技巧。让我们看一些例子:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="df64" class="nm ml it mc b gy nn no l np nq">const c1 = 'hello world!'<br/>c1 = 'Hello World' // TypeError: Assignment to constant variable.</span></pre><p id="8938" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如我们所料，我们不能改变一个常量的值，是吗？</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="794a" class="nm ml it mc b gy nn no l np nq">const c2 = { name: 'Juan' }<br/>console.log(c2.name) // 'Juan'<br/>c2.name = 'Gera'<br/>console.log(c2.name) // 'Gera'</span></pre><p id="30d0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们刚刚改变了一个<code class="fe lz ma mb mc b">const</code>值的值吗？简短的回答是<strong class="lf jd">不</strong>。我们的常量<code class="fe lz ma mb mc b">c2</code>引用了一个具有属性<code class="fe lz ma mb mc b">name</code>的对象。<code class="fe lz ma mb mc b">c2</code>是对那个对象的引用，那是它的值。当我们执行<code class="fe lz ma mb mc b">c2.name</code>时，我们实际上是将指针指向<code class="fe lz ma mb mc b">c2</code>对象，并从那里访问属性。当我们做<code class="fe lz ma mb mc b">c2.name</code>时，我们改变的是对象中属性<code class="fe lz ma mb mc b">name</code>的值，而不是存储在<code class="fe lz ma mb mc b">c2</code>中的引用，因此<code class="fe lz ma mb mc b">c2</code>保持不变，尽管属性值现在不同了。</p><p id="1d1c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">看看当我们实际尝试不同地更新值时会发生什么:</p><pre class="ks kt ku kv gt ni mc nj nk aw nl bi"><span id="962f" class="nm ml it mc b gy nn no l np nq">const c3 = { name: 'Juan' }<br/>console.log(c3.name) // 'Juan'<br/>c3 = { name: 'Gera' } // TypeError: Assignment to constant variable.<br/>console.log(c3.name)</span></pre><p id="6cb4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">尽管这个对象看起来是一样的，我们实际上是在创建一个新的对象<code class="fe lz ma mb mc b">{ name: 'Gera' }</code>并试图将这个新对象赋给<code class="fe lz ma mb mc b">c3</code>，但是我们不能这样做，因为它被声明为常量。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="e836" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">结论</h1><p id="f998" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">今天我讨论了JavaScript中变量声明和作用域的主题。这是一个非常重要的主题，可以解释我们的代码可能会出现的许多奇怪的情况。这是一个常见的面试问题。这是所有JavaScript开发人员必须学习和理解的。</p><p id="b26d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不久前，我发布了一篇关于测试你技能的5个JavaScript问题和答案的文章，其中2个问题(#4和#5)是真实的面试问题。整篇文章都很有趣，但是这两个问题是很好的例子，说明了作用域和闭包如何对代码的结果产生很大的影响。</p><p id="f6ea" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">非常感谢你的阅读！</p></div></div>    
</body>
</html>