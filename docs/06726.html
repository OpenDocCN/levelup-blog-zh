<html>
<head>
<title>Patterns for Constructing Stateful Programs without Any Mutation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建无任何突变的有状态程序的模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/patterns-for-constructing-stateful-programs-without-any-mutation-9c002407d050?source=collection_archive---------17-----------------------#2020-12-22">https://levelup.gitconnected.com/patterns-for-constructing-stateful-programs-without-any-mutation-9c002407d050?source=collection_archive---------17-----------------------#2020-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/048f5d8df06ec388d7a4be468a2d1ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eKuAA94YmCYtCo7o.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">原载于</em><a class="ae kg" href="https://edward-huang.com/scala/functional-programming/monad/programming/2020/12/21/must-know-patterns-for-constructing-stateful-programs-without-any-mutation/" rel="noopener ugc nofollow" target="_blank"><em class="kf"/></a><em class="kf">。</em></figcaption></figure><p id="c2bd" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当开发一个应用程序时，在应用程序中有一些状态来检测程序执行的当前点通常是有用的。通常，我们希望在顺序数据流中操作，例如解析器、防火墙、通信协议或数据流。在其中一些操作中，先前计算的数据存储在某个变量(状态)中，并且通常会影响程序当前的执行决策。</p><p id="1d96" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可以称这些操作为有状态操作，其中程序先前的执行被延续到当前的实现。用程序状态和状态将会改变的语句来描述程序通常被用来将他们的编程范例称为命令式编程。</p><p id="04cc" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">通常，我们可以使用变量来存储我们之前计算的值，以用于当前的计算。然而，您也可以用状态单子编写命令式编程。如果你不知道那是什么，看看我以前的文章<a class="ae kg" href="https://edward-huang.com/scala/functional-programming/monad/programming/2020/08/16/how-to-create-a-random-number-generator-function-without-side-effects/" rel="noopener ugc nofollow" target="_blank">如何创建一个没有副作用的随机数发生器函数</a>。</p><p id="b2cb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">状态单子是一个简单的函数，它通过首先描述你的程序应该表现什么来帮助你构造一个有限状态机。然后，您可以插入您的初始状态，并期望在程序执行时获得最终结果和最终状态。</p><p id="5233" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">一个简单的值是:<code class="fe lf lg lh li b">S =&gt; (A,S)</code>其中函数接受<code class="fe lf lg lh li b">S</code>，即您的初始状态，并在用值<code class="fe lf lg lh li b">A</code>和新状态<code class="fe lf lg lh li b">S</code>计算初始状态后返回一个结果。例如，如果你想创建一个程序，用它相应的索引<code class="fe lf lg lh li b">zipWithIndex</code>压缩一个数组。创建该函数的常规方法需要一个for循环，该循环将遍历序列中的一个元素，并用索引压缩它——如下所示:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="151b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您也可以使用State将状态传递给函数。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="51d0" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们首先实例化元组<code class="fe lf lg lh li b">(A, Int)</code>和<code class="fe lf lg lh li b">0</code>的空列表作为<code class="fe lf lg lh li b">foldLeft</code>中的第一个索引。然后在每次迭代中，我们调用<code class="fe lf lg lh li b">op</code>函数，创建一个元组和下一个索引元素。计算值将返回当前结果和下一个状态。我们将元组预先放置到元组的累积列表中，并将<code class="fe lf lg lh li b">nextI</code>与我们的<code class="fe lf lg lh li b">foldLeft</code>函数一起传递。我们只需要获得第一个元组，我们还需要反转列表，因为我们将元组预先放置到累积列表中。</p><p id="f9ac" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果我们有一个状态单子，我们也可以用一个<code class="fe lf lg lh li b">State</code>单子来实现。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="7b73" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们首先遍历<code class="fe lf lg lh li b">List[State[Int, (A, Int)]]</code>到<code class="fe lf lg lh li b">State[Int, List[(A,Int)]]</code>。我们设置<code class="fe lf lg lh li b">State</code>单子以状态为索引，结果<code class="fe lf lg lh li b">A</code>将是<code class="fe lf lg lh li b">(A, Int)</code>。首先获取状态，<code class="fe lf lg lh li b">State.get[Int]</code>，然后将状态设置为<code class="fe lf lg lh li b">index + 1</code>。for-comprehension的<code class="fe lf lg lh li b">yield</code>语句返回每个状态的结果。最后，我们实例化初始状态值，索引为0，以执行程序。</p><p id="656c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这篇文章中，我想深入探讨当我们想使用状态单子时的思考过程，并向您展示如何基于状态单子构造一个程序。</p><p id="e318" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当我第一次尝试实现状态单子的概念来构造一个需要某种状态的程序时，我不知道如何解决这个问题。然而，在本文中，我将向您展示在解决这些问题时观察到的模式。</p><h1 id="98ab" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">跑步机器人</h1><p id="094e" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">一个例子是，你需要创建一个机器人站在一个点上的游戏。会有一个指令列表和一个目的地。您将需要对机器人进行编程，以验证机器人是否根据用户给出的指令列表达到了目标。</p><p id="1b47" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们来定义这个函数:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="eb82" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe lf lg lh li b">Int</code>的元组代表坐标。每条指令将从起点增加或减少x或y坐标。在指令结束时，我们可以检查机器人是否到达最终目的地。</p><p id="634c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们尝试使用状态单子来解决这个问题。我们需要创建一个机器人可以执行的动作操作来确定机器人的当前状态。</p><p id="31d1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">状态将是<code class="fe lf lg lh li b">startPoint</code>。</p><p id="cb87" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">结果也将是一个<code class="fe lf lg lh li b">Int</code>的元组。</p><pre class="lj lk ll lm gt ms li mt mu aw mv bi"><span id="3895" class="mw lq it li b gy mx my l mz na">type RobotState = State[(Int,Int), (Int,Int)]</span></pre><p id="afa7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当指令执行完毕时，我们可以看到机器人在坐标中的位置。</p><p id="4bd8" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们创建一个操作，在该操作中状态应该表现为:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="a9cf" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">该函数接收指令和机器人的当前坐标，并返回机器人的下一个坐标。</p><p id="23c8" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">接下来，让我们在状态中执行函数。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="15f9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们得到当前坐标。然后，我们执行指令的动作。最后，我们在状态上设置新的坐标，并产生当前坐标。在这个场景中，<code class="fe lf lg lh li b">State[S,A]</code>中的<code class="fe lf lg lh li b">S</code>成为最终结果，<code class="fe lf lg lh li b">A</code>成为我们在执行程序时得到的历史或轨迹。</p><h1 id="bc40" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">邮购计算器</h1><p id="7566" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">这里指的是Cats练习册，我们需要在其中实现一个后序计算器。</p><pre class="lj lk ll lm gt ms li mt mu aw mv bi"><span id="d39b" class="mw lq it li b gy mx my l mz na">1 2 + 3 * // see 1, push onto stack<br/>2 + 3 * // see 2, push onto stack<br/>+ 3 * // see +, pop 1 and 2 off of stack,<br/>// push (1 + 2) = 3 in their place<br/>3 3 * // see 3, push onto stack<br/>3 * // see 3, push onto stack<br/>* // see *, pop 3 and 3 off of stack,<br/>// push (3 * 3) = 9 in their place</span></pre><p id="92e3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可以使用一个链表来实现一个栈。我们可以让状态单子中的<code class="fe lf lg lh li b">S</code>成为堆栈。</p><p id="2fab" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">的算法是这样的:</p><ul class=""><li id="7723" class="nb nc it kj b kk kl ko kp ks nd kw ne la nf le ng nh ni nj bi translated">检查当前令牌是否为数字；如果是一个数字，就把它压入堆栈</li><li id="477e" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ng nh ni nj bi translated">如果它不是一个数字，那么从堆栈中弹出两个值，用操作符应用操作数，并将其推回堆栈。</li></ul><p id="a71e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">因此，让我们用转换函数来分解整个流程。我们知道我们将循环遍历所有的令牌并做一些转换。在这个过程结束时，我们将到达堆栈的顶部。</p><p id="f32c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们实现转换函数:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="2da4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后我们给出一个令牌列表，我们要解析它们:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="5012" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这种情况下，既然我们不使用<code class="fe lf lg lh li b">A</code>状态单子。我们可以用<code class="fe lf lg lh li b">modify</code>来修改所有的状态，然后得到栈头。</p><p id="978f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们看一个更复杂的问题，使用模拟简单玩家分配的有限状态自动机来分配玩家。</p><h1 id="bc7e" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">玩家分配</h1><p id="8ac3" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">一个最好的例子就是创建一个有限状态机，在这里你给程序不同的指令，然后得到程序的最终结果。</p><p id="186f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">假设你需要设计一个游戏，其中n个玩家根据某种标准从n个点的集合中被分配n个点。</p><p id="8644" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你想迭代点数并交替分配分数给n个玩家。因此，给定一个分数和玩家数量的列表，您将返回玩家的地图和分配给这些玩家的分数。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="4481" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们如何解决这个问题？</p><p id="fc88" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我将向你介绍我将如何解决这个问题的过程。</p><p id="e059" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可以先创建一个状态为<code class="fe lf lg lh li b">Map[Int, Vector[Int]]</code>的状态单子。然后，我们需要考虑我们对分数列表的每次遍历的操作。</p><p id="b9b9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当我们遍历分数列表时，如何知道分数分配给哪个玩家？</p><p id="1bee" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们知道，如果我们想通过每个玩家来分配分数，我们可以用玩家总数来修改当前索引，以给玩家<code class="fe lf lg lh li b">A</code>打分<code class="fe lf lg lh li b">A</code>。因此，在遍历链表的同时，我们还需要知道当前遍历的是什么索引。</p><p id="b938" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们创建一个<code class="fe lf lg lh li b">op</code>函数，它接受该序列的索引、分数、先前的地图值和玩家总数，并返回玩家将为其赋值的新地图值。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="1a65" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，我们需要定义我们的状态单子。我们知道状态会是一个<code class="fe lf lg lh li b">Map[Int, Vector[Int]]</code>。结果会怎样？</p><p id="730b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">结果可以是当前索引。因此，我们可以创建一个状态单子，返回一个新的<code class="fe lf lg lh li b">Map</code>赋值和下一个迭代的索引值。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="e9a3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在我们已经创建了我们的操作和状态定义，我们终于可以实现<code class="fe lf lg lh li b">assignedN</code>了。我们来实现<code class="fe lf lg lh li b">assignedN</code>。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="f623" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这就是我们意识到需要将索引作为一个状态来检索它的地方。让我们创建一个包含<code class="fe lf lg lh li b">Map</code>和<code class="fe lf lg lh li b">currIndex</code>的<code class="fe lf lg lh li b">StatePlayer</code>案例类。然后，稍后我们检索<code class="fe lf lg lh li b">Map</code>而不是下一个玩家。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="7782" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，我们可以尝试重构<code class="fe lf lg lh li b">op</code>函数来调用收到的一个<code class="fe lf lg lh li b">Player</code>来代替:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="1d12" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">之后，我们可以通过使用新的<code class="fe lf lg lh li b">State</code>定义来尝试实现<code class="fe lf lg lh li b">assignedN</code>:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="f6b4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你现在可能会看到这个模式，我们在<code class="fe lf lg lh li b">lstOfScore</code>上再次使用了<code class="fe lf lg lh li b">traverse</code>。然而，我们想只使用<code class="fe lf lg lh li b">State.modify</code>的<code class="fe lf lg lh li b">modify</code>状态，这将返回一个<code class="fe lf lg lh li b">State[Player, Unit]</code>。我们想在<code class="fe lf lg lh li b">lstOfScore</code>上使用<code class="fe lf lg lh li b">traverse</code>的原因是启用了遍历来将<code class="fe lf lg lh li b">List[State[Player,Unit]]</code>转到<code class="fe lf lg lh li b">State[Player, List[Unit]]</code>并应用列表中的所有状态。然后我们得到<code class="fe lf lg lh li b">Player</code>最后一次修改的状态。</p><p id="a695" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在我们构造了我们的程序之后，我们为我们的程序提供了空状态— <code class="fe lf lg lh li b">Players(Map.empty[Int,Vector[Int]], 0)</code>。</p><p id="1bfb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">大多数实现命令式程序的有限状态自动机类型的程序都是以这种模式执行的。在这种情况下，我们不需要给定状态单子的结果。因此，我们使用<code class="fe lf lg lh li b">modify</code>，因为modify是<code class="fe lf lg lh li b">get</code>和<code class="fe lf lg lh li b">set</code>的组合，不返回任何产品。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="2727" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">事实上，我后来注意到，这个操作经常被使用，它可以被抽象，它通常被称为<code class="fe lf lg lh li b">mapAccum</code>:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h1 id="8106" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="61ec" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">用命令式编程实现状态单子有时会很棘手。然而，通过创建几个程序，我们可以找到一种模式，以一种纯函数的方式生成命令式代码。</p><p id="9c68" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们通常使用当前状态，计算下一个状态，设置它，并产生一些值。</p><p id="412c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我希望这篇文章对开始使用状态单子创建命令式程序和以纯函数方式实现算法有用。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="5df0" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae kg" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="kj iu"/></a><strong class="kj iu">以获得关于科技职业的文章、有趣的链接和内容的通知！</strong></p><p id="134b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可以关注我，也可以在<a class="ae kg" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p></div></div>    
</body>
</html>