<html>
<head>
<title>An animated guide to Depth-First Search in Python to find a path</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中深度优先搜索路径的动画指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-animated-guide-to-implementing-dfs-in-python-to-find-a-path-1e939b7b8599?source=collection_archive---------2-----------------------#2021-03-21">https://levelup.gitconnected.com/an-animated-guide-to-implementing-dfs-in-python-to-find-a-path-1e939b7b8599?source=collection_archive---------2-----------------------#2021-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="adf8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深度优先搜索教程。递归算法介绍。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/845b2fa0b3d23b14a9ce95f68db19be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*h5Xvv83bvxDtMC4g2oToLQ.gif"/></div></figure><p id="8e9b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">寻找路径的方法之一是一种称为“深度优先搜索”的递归算法。如果你认为递归只在寻找阶乘时需要，你会感到惊讶。</p><p id="a6c5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为我们动画化了我们的算法，所以我们不会遍历所有组合并找到最短路径。我们至少会找到一条路，并且会很开心。但是你当然可以继续下去，找到所有可能的组合，但是你最好在一个正常的图形中，而不是在一个迷宫中。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h2 id="271b" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">我们什么时候需要它？</h2><p id="f299" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">好问题，谢谢提问。</p><p id="25d4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">用它在迷宫中寻找路径并不是一个好主意，但我们在这里这样做是为了简化可视化。</p><p id="9a38" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你需要寻找不同的路径组合，使用这个算法是很好的。例如，如果您有5栋房子，并且您想要查看哪条路径最适合访问每栋房子。广度优先搜索算法只会显示到每个房子的最短路径，而不是穿过所有房子的路径。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h2 id="8b17" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">复杂吗？</h2><p id="3a4f" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">嗯。你什么意思？</p><p id="20b9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从复杂性的角度来说，的确非常复杂。它甚至不是多项式，而是指数。使用之前请三思:)有时，我们没有其他选择。而且是NP完全的。</p><p id="58a9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从实施起来有多复杂的意义上来说，不，它很简单。但是你需要理解递归。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h2 id="68a8" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">很好。什么是递归？</h2><p id="72d1" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">递归函数是调用自身的函数。</p><p id="ea8b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们看看犹他大学网站上的一个Matlab例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/08c823f99bf6f8d59b491ea2e4dc8ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*6KzPEDxGR4TCOq5_eGfQXQ.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">来源:https://www.cs.utah.edu/</figcaption></figure><p id="701d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里可以看到第4行又在调用“find_way_out”了。慢慢看这个例子，写的很好，应该很清楚。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h2 id="a22b" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">初始化迷宫</h2><p id="9939" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">这是我们的迷宫，我取自<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/solve-a-maze-with-python-e9f0580979a1">我的另一篇文章，在那里我们使用广度优先搜索找到一条路径</a>:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="8135" class="lt lu it my b gy nc nd l ne nf">a = [<br/>    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],<br/>    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 1],<br/>    [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 1],<br/>    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 1],<br/>    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0 ,0, 0, 0, 1, 0, 1, 1, 1, 1],<br/>    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0 ,0, 0, 0, 1, 0, 0, 0, 0, 0],<br/>    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0 ,0, 0, 0, 1, 1, 1, 1, 1, 1],<br/>    [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 1],<br/>    [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0 ,0, 0, 0, 0, 0, 0, 0, 0, 1],<br/>    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],<br/>]<br/>start_i, start_j = 1,1<br/>end_i, end_j = 5,19</span></pre><p id="b786" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们想找到一条从左上角到右边界中间出口的路径。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h2 id="9ac5" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">主要功能</h2><p id="cbb3" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">下面是查找路径的递归函数:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="d1f6" class="lt lu it my b gy nc nd l ne nf"><strong class="my iu">def </strong>go_to(i, j):<br/>    <strong class="my iu">global </strong>path_so_far, end_i, end_j, a<br/>    <strong class="my iu">if </strong>i &lt; 0 <strong class="my iu">or </strong>j &lt; 0 <strong class="my iu">or </strong>i &gt; len(a)-1 <strong class="my iu">or </strong>j &gt; len(a[0])-1:<br/>        <strong class="my iu">return<br/>    </strong><em class="ng"># If we've already been there or there is a wall, quit<br/>    </em><strong class="my iu">if </strong>(i, j) <strong class="my iu">in </strong>path_so_far <strong class="my iu">or </strong>a[i][j] &gt; 0:<br/>        <strong class="my iu">return<br/>    </strong>path_so_far.append((i, j))<br/>    a[i][j] = 2<br/>    <strong class="my iu">if </strong>(i, j) == (end_i, end_j):<br/>        print(<strong class="my iu">"Found!"</strong>, path_so_far)<br/>        path_so_far.pop()<br/>        <strong class="my iu">return<br/>    else</strong>:<br/>        go_to(i - 1, j)  <em class="ng"># check top<br/>        </em>go_to(i + 1, j)  <em class="ng"># check bottom<br/>        </em>go_to(i, j + 1)  <em class="ng"># check right<br/>        </em>go_to(i, j - 1)  <em class="ng"># check left<br/>    </em>path_so_far.pop()<br/>    <strong class="my iu">return</strong></span></pre><p id="af8e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个函数相对简单:</p><ol class=""><li id="7995" class="nh ni it ks b kt ku kw kx kz nj ld nk lh nl ll nm nn no np bi translated">检查我们是否在边界之外</li><li id="515e" class="nh ni it ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated">检查我们是否已经去过那里</li><li id="285a" class="nh ni it ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated">如果没有，将这个单元格添加到我们的路径中(我们将在函数的末尾删除它):path_so_far.append((i，j))</li><li id="8706" class="nh ni it ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated">将此单元格标记为已访问(a[i][j] = 2)</li><li id="ea99" class="nh ni it ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated">检查我们是否到达了终点，如果是，显示路径，移除此单元格并返回</li><li id="d944" class="nh ni it ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated">否则，对所有相邻单元格调用此函数</li><li id="4db6" class="nh ni it ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated">从路径中移除此单元格并返回</li></ol></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h2 id="1c5b" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">不行，太复杂了。有简单的版本吗？</h2><p id="b15b" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">当然可以。这叫做广度优先搜索。</p><p id="2461" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请看这里:</p><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/solve-a-maze-with-python-e9f0580979a1"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">如何在Python中使用BFS解决迷宫</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">广度优先搜索算法</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ko ny"/></div></div></a></div><p id="85dc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您想要可视化的完整代码，这里有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div></div>    
</body>
</html>