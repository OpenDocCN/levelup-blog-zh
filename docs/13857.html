<html>
<head>
<title>How to implement a Java object pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现Java对象池</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-a-java-object-pool-9b185b9924c2?source=collection_archive---------3-----------------------#2022-10-12">https://levelup.gitconnected.com/how-to-implement-a-java-object-pool-9b185b9924c2?source=collection_archive---------3-----------------------#2022-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/b29abac247edd1b8b3f7552b9d275ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*D5inEQgeW5aJYB_G3lDBoA.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">托马斯·杜莫提尔在<a class="ae kb" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6832" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">什么是对象池？</strong></p><p id="283c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">池化并不是一项新技术，它更像是一种软件设计模式，主要功能是缓存一组已初始化的对象，随时可用。</p><p id="32e1" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在大多数情况下，对象池缓存那些创建成本太高或者需要重复创建和使用的对象。从池中获取对象的时间是可预测的，但是创建新对象的时间是不确定的。</p><p id="1b72" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">当需要一个新对象时，一个对象被借出到池中，然后对象池将当前对象标记为正在使用，并在使用后将其返回到对象池，以便可以再次借出。</p><p id="ab69" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">对象池场景的常见用法:</p><ul class=""><li id="21a3" class="la lb it ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">对象创建成本太高。</li><li id="124d" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">需要频繁创建大量重复对象，造成大量内存碎片。</li><li id="8df3" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">不要同时使用太多的对象。</li><li id="43ef" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">常见的特定场景如数据库连接池、线程池等。</li></ul></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="0dca" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">对象池可以解决哪些问题？</strong></p><p id="aed1" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果对象的创建成本很高，比如建立到数据库的连接需要很长时间，那么在没有使用池技术的情况下，我们的查询过程可能是这样的。</p><ul class=""><li id="db88" class="la lb it ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">查询1:建立数据库连接-&gt;发起查询-&gt;接收响应-&gt;关闭连接。</li><li id="144d" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">查询2:建立数据库连接-&gt;发起查询-&gt;接收响应-&gt;关闭连接。</li><li id="3728" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">查询3:建立数据库连接-&gt;发起查询-&gt;接收响应-&gt;关闭连接。</li></ul><p id="d002" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这种模式下，每个查询都要重新建立和关闭连接，因为建立连接是一个耗时的操作，所以这种模式会影响程序的整体性能。</p><p id="4501" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">那么使用联营的想法是什么样的呢？同样的过程转化为以下步骤。</p><ul class=""><li id="cf61" class="la lb it ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">初始化:建立N个数据库连接-&gt;缓存它们。</li><li id="940b" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">查询1:从缓存中借用数据库连接-&gt;发起查询-&gt;接收响应-&gt;将数据库连接对象返回到缓存中。</li><li id="d958" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">查询2:从缓存中借用数据库连接-&gt;发起查询-&gt;接收响应-&gt;将数据库连接对象返回到缓存中。</li><li id="eb10" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">查询3:从缓存中借用数据库连接-&gt;发起查询-&gt;接收响应-&gt;将数据库连接对象返回到缓存中。</li></ul><p id="c8b8" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">使用池化思想后，不频繁创建和关闭数据库连接，而是启动后初始化N个连接供后续使用，使用后返回对象，从而提高程序的整体性能。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="6f2c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">如何实现对象池？</strong></p><p id="e537" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">通过上面的例子，还可以发现统筹思想的几个关键步骤:<code class="fe lv lw lx ly b">initialization</code>、<code class="fe lv lw lx ly b">lending</code>、<code class="fe lv lw lx ly b">returning</code>。</p><p id="f725" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">上面没有显示销毁步骤。在某些场景中，还需要对象销毁的过程，比如释放连接。</p><p id="a96d" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">接下来，我们手动实现一个简单的对象池，以加深我们对对象池的理解。主要是设置一个对象池管理类，然后在里面实现对象的初始化、借出、归还销毁等操作。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e231" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">代码相对简单，只是一个简单的例子，让我们通过池化一个<code class="fe lv lw lx ly b">Redis</code>连接对象<code class="fe lv lw lx ly b">Jedis</code>来演示如何使用它。</p><p id="d04d" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">实际上，<code class="fe lv lw lx ly b">Jedis</code>已经有了对应的<code class="fe lv lw lx ly b">Jedis</code>池化管理对象<code class="fe lv lw lx ly b">JedisPool</code>，但是为了演示对象池的实现，我们不会使用官方提供的<code class="fe lv lw lx ly b">JedisPool</code>。</p><p id="656e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这里就不介绍启动Redis服务了。假设您已经有一个Redis服务，下面介绍用Java连接Redis所需的Maven依赖项。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e819" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">正常情况下如何使用Jedis对象。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="a6a9" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果使用上面的对象池，可以像下面这样使用。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="fdaf" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">输出日志:</p><pre class="lz ma mb mc gt mf ly mg mh aw mi bi"><span id="a144" class="mj mk it ly b gy ml mm l mn mo">Added object: 1556956098<br/>Added object: 1252585652<br/>Loaned objects: 1252585652<br/>redis get: name_foo<br/>Returned object: 1252585652<br/>All objects have been destroyed<br/>There are no objects that can be lent out</span></pre><p id="6a5a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果您使用JMH来比较使用对象池的Redis查询与创建Redis连接然后查询关闭连接的正常方式的性能，您会发现两者的性能有很大不同。</p><p id="9159" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">以下是测试结果。可以发现，使用对象池的性能大约是非池方法的5倍。</p><pre class="lz ma mb mc gt mf ly mg mh aw mi bi"><span id="25c2" class="mj mk it ly b gy ml mm l mn mo">Benchmark                   Mode  Cnt      Score       Error  Units<br/>MyObjectPoolTest.test      thrpt   15   2612.689 ±   358.767  ops/s<br/>MyObjectPoolTest.testPool  thrpt    9  12414.228 ± 11669.484  ops/s</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="0888" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">有哪些开源对象池工具？</strong></p><p id="294e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">上面自己实现的对象池总是有点简陋。事实上，开源工具中已经有非常有用的对象池实现，比如Apache的<code class="fe lv lw lx ly b">commons-pool2</code>工具。许多开源工具中的对象池都是基于这个工具实现的。下面介绍了如何使用该工具。</p><p id="e740" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">添加maven依赖项:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8743" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在<code class="fe lv lw lx ly b">commons-pool2</code>对象池工具中有几个关键的类。</p><ul class=""><li id="1e45" class="la lb it ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><code class="fe lv lw lx ly b">PooledObjectFactory</code>类是一个工厂接口，用于创建、验证和销毁您想要共享的对象。</li><li id="bf57" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe lv lw lx ly b">GenericObjectPool</code>类是一个通用对象池管理类，可以执行诸如借出和归还对象的操作。</li><li id="e876" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe lv lw lx ly b">GenericObjectPoolConfig</code>类是对象池的配置类，可以配置对象的最大和最小容量信息。</li></ul><p id="9070" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">下面通过一个具体的例子演示了<code class="fe lv lw lx ly b">commons-pool2</code>工具类的使用。这里仍然选择Redis连接对象Jedis作为演示。</p><p id="6b42" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">首先，我们需要实现<code class="fe lv lw lx ly b">PooledObjectFactory</code>工厂类来实现其中的对象创建和销毁方法。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="02e8" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">然后，继承GenericObjectPool类来实现借出和返回对象等操作。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="0068" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">可以看到<code class="fe lv lw lx ly b">MyGenericObjectPool</code>类的构造函数中的输入参数有<code class="fe lv lw lx ly b">GenericObjectPoolConfig</code>对象，是对象池的一个配置对象，可以配置对象池的容量和大小等信息。这里不会对其进行配置，将使用默认配置。</p><p id="362e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">通过<code class="fe lv lw lx ly b">GenericObjectPoolConfig</code>的源代码可以看到，在默认配置下，对象池的容量是<code class="fe lv lw lx ly b">8</code>。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d618" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">让我们使用测试类编写一个对象池。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6f7a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">输出日志:</p><pre class="lz ma mb mc gt mf ly mg mh aw mi bi"><span id="88fe" class="mj mk it ly b gy ml mm l mn mo">redis get: name_foo<br/>release the connection</span></pre><p id="53d5" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">上面已经演示了在<code class="fe lv lw lx ly b">commons-pool2</code>工具中对象池的使用。从上面的例子可以发现，只有相同初始化条件的对象才能存储在这个对象池中。如果Redis在这里，我们需要存储一个本地连接，远程连接的两种Jedis对象不能满足。那怎么办呢？</p><p id="6e6c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">事实上，<code class="fe lv lw lx ly b">commons-pool2</code>工具已经考虑到了这种情况。通过添加一个键值，可以在同一个对象池管理中进行区分。代码和上面类似，完整的代码实现直接贴出来。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="2fa5" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">输出日志:</p><pre class="lz ma mb mc gt mf ly mg mh aw mi bi"><span id="94cf" class="mj mk it ly b gy ml mm l mn mo">redis get: name_foo</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="f1b3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">JedisPool对象池实现分析。</strong></p><p id="efc1" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">本文中的演示都使用Jedis连接对象。其实在Jedis SDK中已经实现了相应的对象池，也就是我们常用的JedisPool类。</p><p id="7393" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">那么这里的JedisPool是如何实现的呢？我们先来看看JedisPool是怎么用的。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="fcfd" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">代码中添加了注释，可以看到通过<code class="fe lv lw lx ly b">jedisPool.getResource()</code>获得了一个对象，这与上面的<code class="fe lv lw lx ly b">commons-pool2</code>工具中的<code class="fe lv lw lx ly b">borrowObject</code>非常相似。如果继续跟踪它的代码实现，可以看到下面的代码。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4dd5" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">看到了<code class="fe lv lw lx ly b">super.borrowObject()</code>，多么熟悉的方法，如果继续分析代码，可以发现Jedis对象池也是用<code class="fe lv lw lx ly b">commons-pool2</code>工具实现的。在这种情况下，我们也应该能够猜出<code class="fe lv lw lx ly b">jedis.close()</code>方法的逻辑。应该有退货操作。检查代码，发现确实如此。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3afb" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">通过上面的分析可以看出，Jedis确实使用了<code class="fe lv lw lx ly b">commons-pool2</code>工具来管理对象池，这也可以通过分析<code class="fe lv lw lx ly b">JedisPool</code>类的继承关系图来发现。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="e66e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">总结。</strong></p><p id="8673" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">通过本文的介绍，可以发现统筹思想有几个明显的优点。</p><ul class=""><li id="d3e3" class="la lb it ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">可以显著提高应用程序性能。</li><li id="1175" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">如果创建一个对象太昂贵，那么使用池是非常有效的。</li><li id="7a21" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">池提供了一种管理和重用对象的方法，减少了内存碎片。</li><li id="c834" class="la lb it ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">您可以对可以创建的对象数量进行限制，并为不能创建过多对象的场景提供保护。</li></ul><p id="adbd" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">但是，使用对象池有一些注意事项，例如返回一个对象以确保该对象已被重置为可重用状态。</p><p id="49fd" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">同时还需要注意的是，在使用池化时，要根据具体场景合理设置池的大小。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="faae" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">感谢阅读。</p><p id="f9cd" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果你喜欢这样的故事，想支持我，请给我鼓掌。</p><p id="60fd" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你的支持对我来说非常重要，谢谢你。</p></div></div>    
</body>
</html>