<html>
<head>
<title>Refactoring Your Switch to Ad-Hoc Polymorphism for Better Code Quality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为了更好的代码质量，重构您到特别多态性的切换</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/refactoring-your-switch-to-ad-hoc-polymorphism-for-better-code-quality-cf70d9a27e65?source=collection_archive---------4-----------------------#2021-10-30">https://levelup.gitconnected.com/refactoring-your-switch-to-ad-hoc-polymorphism-for-better-code-quality-cf70d9a27e65?source=collection_archive---------4-----------------------#2021-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5792" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">实际编程示例</h2><div class=""/><div class=""><h2 id="adf2" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">你很少需要对一个离散值进行分支。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/210b25c72bc9418a53653fa16487d693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zynuTiV83lA1Y_x4FOjzuw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="lh li ep" href="https://medium.com/u/7c7a43b3d9de?source=post_page-----cf70d9a27e65--------------------------------" rel="noopener" target="_blank">尼可拉斯·米勒德</a></figcaption></figure><p id="fedb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我已经提到过很多次了，这不会是我的最后一次，但是使用switch cases和if-else语句对离散值进行分支通常是一个糟糕的想法。</p><p id="7431" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每一个<code class="fe mf mg mh mi b">if</code>、每一个<code class="fe mf mg mh mi b">else</code>和每一个<code class="fe mf mg mh mi b">case</code>都会给你的代码库增加<a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/why-cognitive-and-cyclomatic-complexity-matters-in-software-development-5fce1efb56ab">针认知和圈复杂度</a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mk"><img src="../Images/fe79b02b1aefcddcba1ee69c09fc3761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ScqqaDHSc5NJuCB0mV3zA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">开关示例。</figcaption></figure><p id="aa2c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果你对<a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/writing-cleaner-code-with-examples-69be2160b4c1">干净、可读的代码</a>(像我一样)情有独钟，那么我敢肯定，每次你写传统的分支代码时，你已经感到厌恶了。</p><p id="43ca" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是，找出如何避免原始分支技术并不总是容易的。即使有经验的开发人员有时也会发现这很困难。</p><p id="ef37" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在本文中，我将尝试为您提供一种替代方法来处理编写可扩展软件，而不使用传统的分支语句。</p><p id="1a8c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">🔔想要更多这样的文章？在这里签名。</p><h2 id="842f" class="ml mm it bd mn mo mp dn mq mr ms dp mt ls mu mv mw lw mx my mz ma na nb nc iz bi translated">让我们检查一下重构候选对象。</h2><p id="ff21" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">现在，这是一个非常普通的、典型的例子，你会在许多代码库中遇到，我相信你会经常遇到这个问题:你想基于一些提供的输入执行不同的操作。</p><p id="857b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下面的代码是一个虚构的例子，展示了我们如何存储一个文件。它要么存储在数据库中，要么存储在文件系统中。依赖关系的实际实现并不重要。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/efe3386ccafc1b507651b6a402d720b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIA0JPLP5INflGHMbf9zxA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">设计很差的类。</figcaption></figure><p id="c331" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">花几秒钟时间研究代码，并想出为什么这很糟糕的想法。</p><p id="d38c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">添加新存储选项的流程是什么？如果其中一个分支的参数发生变化会怎样？测试这个单一的方法需要多少个单元测试？编写这些测试有多容易？</p><p id="fdc7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我想每个人都可以欣赏上面的例子，以及它如何很好地转化为你在日常工作中实施的许多其他任务。</p><h2 id="9406" class="ml mm it bd mn mo mp dn mq mr ms dp mt ls mu mv mw lw mx my mz ma na nb nc iz bi translated">近距离观察开-闭连续体。</h2><p id="42ae" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">在我们进入真正的重构之前，让我花点时间从我的角度解释一下，我是如何看待开闭原则的。</p><p id="d554" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有不同程度的坚持开闭原则。我试图从我的角度来说明方法的位置。</p><p id="1044" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在最左边，尽可能的封闭，我们有硬编码的，传统的分支，其中if-else和switch cases是前端和中心。在不修改现有代码的情况下，添加新功能的可能性为零。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nj"><img src="../Images/d0085942f4bac316c38cae0db77cf1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwriBWARZeGU9sPEckOBcA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">开放和封闭的程度。</figcaption></figure><p id="c704" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然后是特别多态性，这是一个我很少涉及的话题。大多数文章、教程、书籍、会议演讲等等，每当你问及开闭原则时，都聚焦于抽象——包括我自己。抽象为你提供了模块化，我们可以在不修改现有代码的情况下改变实现，只需要创建一个新的子类型。好东西——绝对是朝着正确方向迈出的一大步。抽象为所有后续程度的“开放”奠定了基础。</p><p id="9704" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是，您有时只想在不同的类型上定义方法，以不同的方式操作(特别多态性)，而不是在不同的类型上以相同的方式操作(参数多态性)。</p><p id="4d8d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">乐趣不止于抽象。有了抽象的经验，你就可以编写更高级的代码，在运行时将新的包加载到你的应用程序域中。</p><p id="a0d5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在本文的剩余部分，我将重点关注从最“封闭”的多态向特别多态的过渡，以及它如何增加您的内部代码质量度量，比如认知和圈复杂度。</p><h2 id="edeb" class="ml mm it bd mn mo mp dn mq mr ms dp mt ls mu mv mw lw mx my mz ma na nb nc iz bi translated">重构每个分支以获得更好的代码质量。</h2><p id="5cb3" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">任何一个有经验的OOP开发人员都会立刻大叫“多态”，想要摆脱那种恐怖的switch语句。</p><p id="a068" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">花几秒钟时间研究方法签名。它看起来不优雅。我们有一个用于分支的枚举，这通常意味着灾难，而<code class="fe mf mg mh mi b">folderName</code>只在保存到文件系统时使用(一个依赖于分支的参数)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nk"><img src="../Images/ff8604a84196a488a69fb3aeb3bed7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0J1GX0SmvrNro_0Zlrw7vQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">方法签名。</figcaption></figure><p id="66be" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">你需要多态的一个最明显的迹象是当你有只在特定场景中使用的参数时。在表示意图和目的的专门类中“捆绑”参数的更好方法。</p><p id="440c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正确的一步是将每个分支中不同的逻辑放在不同的方法中——然后，我们可以很容易地提取出符合意图的类，比如<code class="fe mf mg mh mi b">DatabaseContext</code>和<code class="fe mf mg mh mi b">FileSystemContext</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nl"><img src="../Images/caaeff18f55e422ebe0207db35e8666e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxFzCYiTzYC4qjhdxpMm8A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">重构切换到即席多态。</figcaption></figure><p id="c68b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">基于多态而不是<code class="fe mf mg mh mi b">switch</code>的方法有很多好处，例如:</p><ol class=""><li id="ddfe" class="nm nn it ll b lm ln lp lq ls no lw np ma nq me nr ns nt nu bi translated">降低认知和圈复杂度，以及</li><li id="ed25" class="nm nn it ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">它更容易阅读、维护和调试。</li><li id="6312" class="nm nn it ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">您可以通过引入新方法而不是修改现有方法来添加新功能。</li><li id="90f6" class="nm nn it ll b lm nv lp nw ls nx lw ny ma nz me nr ns nt nu bi translated">操作是独立发展的，可以引入新的参数而不会混淆方法的意图</li></ol><p id="f708" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">尽管这种新设计提高了内部代码的质量，但最初的痛苦依然存在；由分支耦合依赖引起的构造函数膨胀和笨拙— <a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/your-software-quality-is-ruined-by-branch-coupled-dependencies-d55833e17e74">我在这里有一篇关于这个主题的文章</a>，使用了相同的示例代码。</p><h1 id="bd26" class="oa mm it bd mn ob oc od mq oe of og mt ki oh kj mw kl oi km mz ko oj kp nc ok bi translated">总之…</h1><p id="9581" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated">传统的分支，比如if-else和switch cases，就像硬编码应用程序一样。更改现有代码容易出错，添加新功能可能令人望而生畏。</p><p id="b2e2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一种更容易但有时被忽视的方法是简单的特别多态性，这是一种相当原始但有效的方法，可以为不同的参数类型引入不同的实现。</p><p id="d324" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">开闭原则可以在不同的层次、不同的目的、以多种方式实施。选择您想要或需要的灵活性级别，并选择合适的策略。</p><h1 id="48da" class="oa mm it bd mn ob oc od mq oe of og mt ki oh kj mw kl oi km mz ko oj kp nc ok bi translated">让我们保持联系！</h1><p id="c3ac" class="pw-post-body-paragraph lj lk it ll b lm nd kd lo lp ne kg lr ls nf lu lv lw ng ly lz ma nh mc md me im bi translated"><a class="ae mj" href="https://nmillard.medium.com/subscribe" rel="noopener">点击这里</a>订阅时事通讯，获得类似文章的通知，并查看新的YouTube频道<a class="ae mj" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank"><em class="ol">(@ Nicklas Millard)</em></a></p><p id="74b2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><em class="ol">连接上</em> <a class="ae mj" href="https://www.linkedin.com/in/nicklasmillard/" rel="noopener ugc nofollow" target="_blank"> <em class="ol"> LinkedIn </em> </a></p></div></div>    
</body>
</html>