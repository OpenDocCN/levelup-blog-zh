<html>
<head>
<title>A Guide to Integrating Swift and gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift和gRPC集成指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/swift-grpc-577ce1a4d1b7?source=collection_archive---------0-----------------------#2019-09-13">https://levelup.gitconnected.com/swift-grpc-577ce1a4d1b7?source=collection_archive---------0-----------------------#2019-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="41ed" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文将向您介绍如何将gRPC添加到Swift项目中，以及如何使用它向您的后端服务发出请求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/47d99dd8b46fecab598a323253634292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ib3Xb4TibYX7RKfA_d7hXA.png"/></div></div></figure><p id="a42b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">gRPC</strong>(<strong class="kt ir">gRPC</strong><strong class="kt ir">远程过程调用</strong>)是Google最初开发的开源<a class="ae ln" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank">远程过程调用</a> (RPC)系统。它使用<a class="ae ln" href="https://en.wikipedia.org/wiki/HTTP/2" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a>进行传输，使用<a class="ae ln" href="https://en.wikipedia.org/wiki/Protocol_Buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>作为<a class="ae ln" href="https://en.wikipedia.org/wiki/Interface_description_language" rel="noopener ugc nofollow" target="_blank">接口描述语言</a>。它有助于在<a class="ae ln" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">微服务</a>风格的架构中连接服务，并将移动设备和浏览器客户端连接到后端服务器。它是HTTP连接的一种更快、类型更安全的替代方式。</p><p id="6724" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将gRPC集成到您的项目中需要两件事情。</p><ol class=""><li id="3a94" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">您需要一个原型文件(<code class="fe lx ly lz ma b">.proto</code>)来在Swift中创建<code class="fe lx ly lz ma b">.pb</code>和<code class="fe lx ly lz ma b">.grpc</code>文件。</li><li id="e93e" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">将SwiftGRPC纳入您的项目，以建立GRPC连接。</li></ol><p id="b888" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们详细了解这两点:</p><ol class=""><li id="7767" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">protofile是一个通用的定义文件，它包含关于您调用的服务的所有描述、您可以发出的请求(它包含主体中需要包含的所有细节)，以及服务预期的响应模型。</li></ol><p id="e444" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个示例原型文件(<code class="fe lx ly lz ma b">authenticate.proto</code>):</p><pre class="kg kh ki kj gt mg ma mh mi aw mj bi"><span id="a013" class="mk ml iq ma b gy mm mn l mo mp">syntax = “proto3”;</span><span id="c36a" class="mk ml iq ma b gy mq mn l mo mp">option java_package = “authenticate.service”;</span><span id="6f21" class="mk ml iq ma b gy mq mn l mo mp">package authenticate;</span><span id="bda2" class="mk ml iq ma b gy mq mn l mo mp">service authenticate {<br/> rpc authenticate(AuthenticateRequest) returns (AuthenticateResponse);<br/>}</span><span id="a3f5" class="mk ml iq ma b gy mq mn l mo mp">message AuthenticateRequest {<br/> string username = 4;<br/> string password = 5;<br/>}</span><span id="ab11" class="mk ml iq ma b gy mq mn l mo mp">message Profile {<br/> string name = 1;<br/> string gender = 2;<br/> string adress = 3;<br/>}</span><span id="b745" class="mk ml iq ma b gy mq mn l mo mp">message Error {<br/> int32 code = 1;<br/> string message = 2;<br/> string trace = 3;<br/>}</span><span id="eaf5" class="mk ml iq ma b gy mq mn l mo mp">message AuthenticateResponse {<br/> string accesstoken = 2;<br/> string refreshtoken = 3;<br/> Profile profile = 4;<br/> Error error = 7;<br/>}</span></pre><p id="04e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个原型文件由三部分组成:</p><ol class=""><li id="b119" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">SwiftGRPC客户端将使用的微服务(后端)的详细信息</li><li id="af51" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">我们可以发送的请求</li><li id="cb32" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">我们可以期待从这些请求中得到的回应</li></ol><p id="191a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦有了<code class="fe lx ly lz ma b">.proto</code>文件，我们需要一个SwiftGRPC插件将<code class="fe lx ly lz ma b">.proto</code>文件转换成<code class="fe lx ly lz ma b">.swift</code>和<code class="fe lx ly lz ma b">.pb.swift</code>文件。为了做到这一点，我们需要克隆<a class="ae ln" href="https://github.com/grpc/grpc-swift" rel="noopener ugc nofollow" target="_blank"> SwiftGRPC开源项目</a>。按照流程创建插件，并将其放在系统的系统文件夹或<code class="fe lx ly lz ma b">usr/bin</code>文件夹中，并设置<code class="fe lx ly lz ma b">PATH</code>，以便它可以用作终端中的任何其他命令。这是最令人困惑的部分，但是请严格按照GitHub页面中给出的步骤来完成。</p><p id="dc7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成后，我们将通过运行以下两个命令来转换我们的<code class="fe lx ly lz ma b">authenticate.proto</code>文件:</p><pre class="kg kh ki kj gt mg ma mh mi aw mj bi"><span id="10f3" class="mk ml iq ma b gy mm mn l mo mp">protoc --swift_out=. authenticate.proto</span><span id="a6a7" class="mk ml iq ma b gy mq mn l mo mp">// 'Running ProtoBuf Compiler to convert .proto schema to Swift'</span><span id="5c8b" class="mk ml iq ma b gy mq mn l mo mp">This will create authenticate.pb.swift file . This contains both the request body and response body. </span></pre><p id="c96f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来:</p><pre class="kg kh ki kj gt mg ma mh mi aw mj bi"><span id="a884" class="mk ml iq ma b gy mm mn l mo mp">protoc --swiftgrpc_out=. authenticate.proto<br/>// 'Running ProtoBuf Compiler to convert .proto schema to Swift GRPC'</span><span id="d30b" class="mk ml iq ma b gy mq mn l mo mp">This will create authenticate.grpc.swift . This contains the methods to establish the gRPC connection. We dont need to be worried about this. Its created from the .proto file service details. </span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ed0c3052138ae6266a768ff532ab2329.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*08YraO4W4t8MQE9iQNso9g.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">这3个文件将在文件夹中。</figcaption></figure><p id="1a53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">拖放<code class="fe lx ly lz ma b">.grpc</code>和<code class="fe lx ly lz ma b">.pb.swift</code>文件，并将它们包含在您的项目中。仔细阅读这些文件，了解它们包含的内容。</p><p id="ecd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.现在我们需要将SwiftGRPC库包含到我们来自cocoapod的项目中。像所有其他库一样，将这两个pod包含到podfiles并运行pod install。</p><pre class="kg kh ki kj gt mg ma mh mi aw mj bi"><span id="c3f2" class="mk ml iq ma b gy mm mn l mo mp">pod 'SwiftGRPC'</span><span id="625c" class="mk ml iq ma b gy mq mn l mo mp">pod 'SwiftProtobuf'</span></pre><p id="4a0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，您需要使用gRPC进行身份验证调用。因此，创建一个<code class="fe lx ly lz ma b">GRPCServiceManager.swift</code>文件并添加以下内容:</p><pre class="kg kh ki kj gt mg ma mh mi aw mj bi"><span id="204e" class="mk ml iq ma b gy mm mn l mo mp">import Foundation</span><span id="9a5e" class="mk ml iq ma b gy mq mn l mo mp">import SwiftGRPC</span><span id="45fa" class="mk ml iq ma b gy mq mn l mo mp">class GRPCServiceManager: NSObject {</span><span id="3662" class="mk ml iq ma b gy mq mn l mo mp">var grpc_service : Authenticate_authenticateServiceClient?<br/>public override init()<br/>{<br/>  super.init() <br/>  preparegRPCService()<br/>}</span><span id="9cd3" class="mk ml iq ma b gy mq mn l mo mp">func preparegRPCService() {<br/>  grpc_service Authenticate_authenticateServiceClient(address:'192.168.XYZ.XYZ:8000 , secure: false)<br/>}</span><span id="0fbb" class="mk ml iq ma b gy mq mn l mo mp">func authenticate(for username:String , and password:String  onSuccess successCompletionHandler: @escaping (Authenticate_AuthenticateResponse) -&gt; Void ,onFailure  failureCompletionHandler: @escaping (Any) -&gt; Void)     {</span><span id="1bf9" class="mk ml iq ma b gy mq mn l mo mp"><br/>var requestMessage = Authenticate_AuthenticateRequest()<br/>requestMessage.username = username<br/>requestMessage.password = password</span><span id="c66d" class="mk ml iq ma b gy mq mn l mo mp">do {</span><span id="9c16" class="mk ml iq ma b gy mq mn l mo mp">_ = try self.grpc_service?.authenticate(requestMessage, completion: { (response, callresult) in</span><span id="408f" class="mk ml iq ma b gy mq mn l mo mp">DispatchQueue.main.async {<br/>print (callresult.statusCode)<br/>switch callresult.statusCode {<br/> case .ok:<br/>   successCompletionHandler(response!)<br/>   print(response)<br/>   break<br/> case .unauthenticated:<br/>    print("GRPC_UnauthenticateMessage")<br/>    failureCompletionHandler("Sorry!!! Please Try again.")<br/>  break<br/> default :<br/>   print("GRPC_ServerErrorMessage")<br/>   failureCompletionHandler("Sorry!!! Please Try again.")<br/>  break<br/>   }<br/>  }<br/> })<br/>} catch {<br/>print("Catch \(error)")<br/>   failureCompletionHandler("Sorry!!! Please Try again.")<br/>  } <br/> }<br/>}</span></pre><p id="92c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单击登录按钮，从您的登录页面调用身份验证功能:</p><pre class="kg kh ki kj gt mg ma mh mi aw mj bi"><span id="9832" class="mk ml iq ma b gy mm mn l mo mp">GRPCServiceManager().authenticate(for: "username@XYZ.com" , and: "password" ,  onSuccess: {[unowned self](response) in {</span><span id="4cda" class="mk ml iq ma b gy mq mn l mo mp">// Do whatever you want to do with the response.<br/>} onFailure: { error in</span><span id="1472" class="mk ml iq ma b gy mq mn l mo mp">// Show error<br/>})</span></pre><p id="8c2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，你可以从这个过程中用后端开发团队更新的<code class="fe lx ly lz ma b">.proto</code>文件创建更多的请求。您不需要创建请求或解析响应。SwiftGRPC为您做一切！您所需要做的就是为要集成的新服务维护GRPCManager类。</p><p id="b892" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这有助于节省一些时间。在以后的文章中，我们将看到对<code class="fe lx ly lz ma b">.proto</code>文件的高级见解，包括gRPC客户端中的证书和设置元数据。</p><p id="3113" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">编码快乐！</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ec133f3d28099c46f291087def7abd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/1*FZPd5b7Nzee_vBbVYfI1Fw.gif"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">如果有帮助，请少鼓掌</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f7fb6a6ad080ade375c49895b36fde20.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/1*9Zn7SnZV2w4SM7HZlDjB0A.gif"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">更多高级主题请关注我</figcaption></figure></div></div>    
</body>
</html>