<html>
<head>
<title>Over-Mocking in Unit Tests and How to Think About Units</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试中的过度嘲讽以及如何思考单元</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/over-mocking-in-unit-tests-and-how-to-think-about-units-a8c4828c5d68?source=collection_archive---------16-----------------------#2022-11-01">https://levelup.gitconnected.com/over-mocking-in-unit-tests-and-how-to-think-about-units-a8c4828c5d68?source=collection_archive---------16-----------------------#2022-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">代码中有太多的模仿是不好的，很多模仿的原因之一是对单元的误解。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe6359f2206f59119735a117d78d694f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YHbBmicpO2rlGv6B"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="68d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多单元测试经常会有一个大问题。事实上，有很多，但我今天想集中讨论一个。过度模仿的问题，当你在一次测试中有很多被模仿的类。</p><p id="2af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么可能导致这个问题？为了回答这个问题，我们先来探讨一下什么是单元，什么是单元测试。</p><h1 id="8d79" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对单位的误解</h1><p id="b7b4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">人们说单元测试是一种孤立地测试一小块软件以验证其正确性的方法。然而，那块软件(单元)是什么？理解单位的概念非常重要。</p><p id="b512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一个关于什么是单位的常见误解。人们认为一个单位就是一个类或者一个函数。这种信念有一定的道理。然而，事情是，一个单元不一定是一个类或一个函数，它<em class="ms">可以</em>是一个类或一个函数，但这并不意味着它总是这样。</p><p id="7598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致了对单元测试的误解，人们测试类和方法，当他们创建一个类或编写一个新方法时，他们会创建一个新的单元测试。</p><blockquote class="mt mu mv"><p id="5534" class="kz la ms lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">你不能一创建类或函数就编写新的单元测试。</p></blockquote><p id="bf13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你创建一个新的单元时，你编写一个单元测试(实际上，如果你正在进行TDD(测试驱动开发)，你首先编写测试，然后创建单元，但是，现在，让我们坚持大多数人习惯的方法，因为，如果你正在进行适当的TDD，这篇文章可能与你无关，因为TDD是一个驱动代码设计的强大工具，它有助于消除过度模仿的问题)。</p><p id="121c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">认为类或函数总是定义一个单元的误解是危险的。这是过度嘲讽的主要原因之一。</p><h1 id="2604" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是单位</h1><p id="0234" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">好了，回到什么是单位。一个单元由一个单独的功能来定义。单个功能可以是代码模块、类的集合或编程语言中的单个函数。重要的是一个单位做一件事。</p><p id="55bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看一个单位公开合同的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会指出一件显而易见的事情，那就是一个面包店不应该为了可扩展而关心它生产的产品的种类，你是对的。我只是把例子做得简单一些，这样每个人都能容易理解，它的目的只是为了说明一个观点。因此，为了这个例子，让我们假设一个面包店必须只做馅饼。</p><h2 id="acd5" class="nb lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">单元是一种功能，而不是语言结构</h2><p id="1bc6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可能会争辩说<strong class="lb iu"> PieRecipe </strong>类本身是一个单元，或者<strong class="lb iu"> Pie </strong>类本身是一个单元，或者<strong class="lb iu"> Bakery </strong>类本身是一个单元。我更倾向于他们不是一个整体。为什么？如果你单独看它们，它们没有完成任何一项功能。</p><p id="556d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从代码的角度来看，所有的类本身都可以是单元，但是从功能的角度来看，它们不能，一个食谱本身什么都不做，它只是信息，它什么都不做，一个馅饼本身什么都不做，它只是一个可消费的产品，它只是存在，一个没有馅饼的面包店不能做任何有用的事情。</p><p id="7ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这三个类一起组成一个单元，完成一件事——做一个馅饼。</p><p id="79b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我见过很多真实的测试，其中的情况相当于馅饼的例子，人们模拟出几乎所有的东西，馅饼的配方、配料和馅饼本身，然后唯一被测试的东西是面包店类中的两行代码。测试的设置非常漫长和脆弱，简而言之，测试没有测试任何真实的东西，只是没有增加任何价值的额外维护。这样的情况是人们看不到测试价值的原因。</p><p id="6987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将单元视为编程语言结构而不是功能块的错误导致了测试中的过度模仿。我要说的是，所有关于自动化测试的思考都应该从功能的角度出发，而不是从细节或代码结构的角度出发，因为如果你关注细节和结构，你就把测试和实现联系在了一起，这是一个可怕的错误，使得测试难以维护。</p><h1 id="13d9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">单位内部的相互作用很重要</h1><p id="256b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通常一个单元不仅仅是一个类，它们只是组合起来做一件事情。当您开始单独测试一个单元的所有类时，您将一个单元分割成了更小的部分，这些部分本身没有什么意义——没有交互的上下文，它们就没有意义。单元中的类之间的交互是单元中最基本的事情之一。</p><p id="76b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个单元中类的相互作用是单元正常运行的基础，所以当你开始模仿组成一个单元的类时，你就去掉了你应该测试的一个重要部分，单元测试的价值也就失去了。</p><blockquote class="nn"><p id="7da4" class="no np it bd nq nr ns nt nu nv nw lu dk translated">最有价值的自动化测试模仿尽可能少的东西，并且覆盖更小部分之间的交互。</p></blockquote><p id="ea9e" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">单元测试也不例外。一个单元不是不可分割的，不可分割的是一个语句，所以，在我看来，说单元测试应该测试最小的软件是错误的，因为语句是最小的部分。你可以测试尽可能多的不可分割的部分，而不用覆盖它们之间的任何交互。你的测试就像潜水艇上的纱门一样有用。</p><p id="0468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你有过度模仿的问题时，你不是在测试任何真实的东西，你只是在测试你刚刚创建的模仿的设置做了一些事情，但是模仿的设置不是你真实的生产代码，所以你所做的只是在浪费时间。</p><p id="f044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该在单元测试中嘲笑的是资源密集型操作，以及应用程序外部的东西，比如IO操作。如果你发现自己嘲笑的不止这些，那么这要么是一个集成测试，你的测试范围是错误的，要么是代码的设计是糟糕的，无论哪种情况，情况看起来都不太好。适当的单元不需要你为一大堆类建立模型来测试一行真正的代码。</p><h1 id="d117" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="6111" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可以让类/函数在单元测试中交互，因为单元并不意味着它是一个没有交互的片段，单元从功能的角度定义了软件的最小片段，而不是代码本身，这是我们作为开发人员要处理的事情，大多数人不习惯从功能的角度来思考。</p><blockquote class="mt mu mv"><p id="7a2c" class="kz la ms lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">如果你想要解耦的和可维护的测试，当涉及到单元和测试时，从功能的角度考虑是必须的。</p></blockquote><p id="758c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元是共同完成一件事情的语句、函数和/或类的集合。</p><p id="bf6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不理解这一点会导致在测试单元时有太多的嘲笑，这将测试与实现结合起来，这使得测试难以维护，这使得人们不再相信测试的好处，这最终导致根本没有测试，这导致更糟糕的代码设计，这导致更多的bug和昂贵的维护，这导致人们记住有一种信念，即测试可以改进软件，这使得人们开始再次进行测试(带着相同的旧错误观念)…并重复。</p><blockquote class="mt mu mv"><p id="a092" class="kz la ms lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">仅仅说测试有益于事无补，因为有糟糕的测试比根本没有测试更糟糕。</p></blockquote><p id="42ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带有过度模仿问题的测试是白费力气，是第二个无用的实现，它不做任何实际的事情，只包含您需要维护的模仿设置。</p><p id="0cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试中有太多的模仿意味着要么你对单元有误解，要么你的代码设计很糟糕，后者是另一个故事了。</p></div></div>    
</body>
</html>