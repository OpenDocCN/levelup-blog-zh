<html>
<head>
<title>Working with front-end tools on Linux and Windows: the grand performance test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Linux和Windows上使用前端工具:大性能测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/working-with-front-end-tools-on-linux-and-windows-the-grand-performance-test-b51a77a71636?source=collection_archive---------0-----------------------#2019-08-05">https://levelup.gitconnected.com/working-with-front-end-tools-on-linux-and-windows-the-grand-performance-test-b51a77a71636?source=collection_archive---------0-----------------------#2019-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d3e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">node.js在Windows上真的比较慢吗？使用yarn代替npm对您的工作流程有何影响？实时杀毒软件会影响你的构建时间吗？让我试着用一个快速的基准和真实的、通过实验收集的数字来回答这个问题。</h2></div><p id="491b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我一直认为自己在操作系统、平台和浏览器领域远非虔诚。显然，我倾向于有所偏好——但我尽量避免激烈地将其推入讨论。有人用Linux？酷，如果对他们有好处的话。Windows？太好了，也许他们只是喜欢这种体验。MacOS？我不介意。火狐？歌剧？Chrome？没事的。</p><p id="18fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到操作系统，偏好很少是性能的问题——通常是方便、细节和美观的问题。显然，有人会说macOS快得惊人——但这主要是Mac/MacBook平台精确选择高性能硬件的结果。</p><p id="af35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我要用各种项目和工具来解决团队同事的问题，所以我倾向于频繁地转换工作环境:我的部分工作是在macOS上用MacBook完成的，部分工作是在Windows上完成的，有时我会跳到Linux上。通常，我看不出有什么明显的不同。</p><p id="090a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，几个月前，我开始感到有点…痒。我有一种感觉，基于node.js的前端开发工具的性能在Windows环境下受到了制约。可以工作，但我无法摆脱这样的感觉，即<code class="fe le lf lg lh b">npm</code>、<code class="fe le lf lg lh b">node</code>、<code class="fe le lf lg lh b">yarn</code>和类似的工具工作起来……比在linux/macOS系统上慢。<a class="ae li" href="https://stackoverflow.com/questions/9243221/does-node-js-perform-badly-on-windows-surely-it-cant-be-slower-than-apache-for" rel="noopener ugc nofollow" target="_blank">显然</a> <a class="ae li" href="https://www.reddit.com/r/node/comments/4op7ey/npm_is_incredibly_slow_on_windows_10/" rel="noopener ugc nofollow" target="_blank">不止我一个人</a><a class="ae li" href="https://github.com/npm/npm/issues/21148" rel="noopener ugc nofollow" target="_blank"/>——有几个类似经历的报道，但没有合适的结论。</p><p id="72b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好奇心占了上风，我最终开始计算一些数字。</p><p id="005d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果是明确的。请耐心阅读这篇文章，看看我发现了什么。</p><h1 id="e4b4" class="lj lk it bd ll lm ln lo lp lq lr ls lt jz lu ka lv kc lw kd lx kf ly kg lz ma bi translated"><strong class="ak">方法</strong></h1><p id="96fc" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">主要目标是比较Windows和Linux的性能，在最常见的场景中测试它们:</p><ul class=""><li id="4bcd" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld ml mm mn mo bi translated">搭建新的web应用程序</li><li id="f0aa" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">安装节点依赖关系</li><li id="aca6" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">创建包，即构建web应用程序</li></ul><p id="bb40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也有计划将macOS纳入测试，但我没有机会在同一个硬件上运行Windows和macOS。最后，我们比较了两个流行系统的性能:</p><ul class=""><li id="b9d9" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld ml mm mn mo bi translated"><strong class="kk iu"> Windows 10 Pro </strong> (build 1809，2018年10月更新)</li><li id="18cb" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><strong class="kk iu">运行Linux 5 . 0 . 0–23内核的Ubuntu 18.04.2 LTS </strong></li></ul><p id="56f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在选择将提供最佳基准值的技术时，我接触了TypeScript和Webpack(来自create-react-app bundle)。此外，我已经决定在依赖性管理方面测试NPM和yarn。构建时间不仅针对少数文件进行了测试，也针对数百个文件进行了测试。我最终设计了由以下步骤组成的基准大纲:</p><ol class=""><li id="d5a0" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld mu mm mn mo bi translated">使用create-react-app并启用TypeScript来搭建应用程序<strong class="kk iu">(基准#1) </strong></li><li id="7186" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld mu mm mn mo bi translated">重置依赖关系(删除节点模块)并退出配置</li><li id="79f3" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld mu mm mn mo bi translated">安装依赖项:</li></ol><ul class=""><li id="fe17" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld ml mm mn mo bi translated">使用npm安装，同时保留<code class="fe le lf lg lh b">package-lock.json</code> <strong class="kk iu">(基准#2) </strong></li><li id="a17b" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">使用npm安装，同时在每次运行时移除<code class="fe le lf lg lh b">package-lock.json</code><strong class="kk iu">(基准#3) </strong></li><li id="4e44" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">使用纱线同时保留<code class="fe le lf lg lh b">yarn.lock</code> <strong class="kk iu">(基准#4) </strong></li><li id="d1a3" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">使用纱线安装，同时移除纱线。每次运行时锁定<strong class="kk iu">(基准#5) </strong></li></ul><p id="0cac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.构建搭建的应用程序:</p><ul class=""><li id="6101" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld ml mm mn mo bi translated">有少量(3个)源文件<strong class="kk iu">(基准#6) </strong></li><li id="d9cc" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">拥有大量(300多个)源文件<strong class="kk iu">(基准#7) </strong></li></ul></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="e003" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使基准测试的结果尽可能可靠和真实，应用了以下规则:</p><ul class=""><li id="5ada" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld ml mm mn mo bi translated">两个测试系统都在同一台没有虚拟化的机器上本机运行(华硕P25P20L，带i5–5200 u CPU和16GB RAM)。</li><li id="9117" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">两个系统都是新安装的。基准测试时没有其他应用程序在运行。</li><li id="5af3" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">每项测试至少进行5次，以尽量减少随意性。最终结果是测试运行的平均值。</li><li id="9407" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">机器连接到基于300/300 mbps吞吐量的光纤的稳定互联网链接。在这两个系统上，事先都进行了互联网连接测试。</li><li id="9294" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">在系列中每个测试的第一次运行之前，都会调用一次预运行，以便准备和预热应用程序缓存。</li></ul><p id="fcfd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在两个平台上使用了相同版本的node.js和其他工具:</p><ul class=""><li id="4353" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld ml mm mn mo bi translated"><strong class="kk iu">节点12.7.0 </strong></li><li id="73d3" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><strong class="kk iu">国家预防机制6.10.0 </strong></li><li id="1de9" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><strong class="kk iu">创建-反应-应用3.0.1 </strong></li><li id="bbdc" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><strong class="kk iu">纱线1.17.3 </strong></li></ul><p id="5c0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">时间显然是主要的衡量标准。当然，我没有为此使用手动秒表——为了精确地获得结果，我精心制作了一个小型node.js应用程序，它为我处理测试运行和测量。下面是应用程序搭建的情况:</p><figure class="nc nd ne nf gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7153" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，每个测试至少运行5次，计算平均值作为最终结果。</p><p id="1439" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Windows测试的情况下，还有另一个重要因素—在版本10中，安装了一个默认的防病毒软件，可以实时扫描所有文件活动。因为我认为它可能会严重影响(好家伙，我是对的！)npm和yarn、Windows的性能测试是在启用和禁用上述防病毒软件的情况下独立进行的。</p><h1 id="4f7e" class="lj lk it bd ll lm ln lo lp lq lr ls lt jz lu ka lv kc lw kd lx kf ly kg lz ma bi translated"><strong class="ak">结果</strong></h1><h2 id="b81f" class="nj lk it bd ll nk nl dn lp nm nn dp lt kr no np lv kv nq nr lx kz ns nt lz nu bi translated"><strong class="ak">基准#1:使用create react应用程序实例化应用程序</strong></h2><p id="9d85" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated"><strong class="kk iu">描述:</strong></p><p id="6d91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个测试运行期间，create-react-app命令被调用，以便在一个全新的目录中搭建react和TypeScript应用程序。</p><p id="4925" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结果:</strong></p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/35662059adb3dcc9c677c3c450947fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*Q1BXFiZxaU4r7Omz"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图1.1。:应用程序实例化时间比较，5次运行</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/63d56fd05e53273c909e1ce52c53ede5.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/0*1_wNwhN0EdwqtIA2"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图1.2。:图表上应用程序实例化时间和平均值的比较</figcaption></figure><p id="afd8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">评论:</strong></p><p id="37d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Ubuntu是明显的赢家，与Windows相比提升了25%!此外，我们可以看到防病毒软件对性能的影响有多严重——在启用时，它需要几乎两倍的时间来搭建应用程序。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="38b1" class="nj lk it bd ll nk nl dn lp nm nn dp lt kr no np lv kv nq nr lx kz ns nt lz nu bi translated"><strong class="ak">基准#2:使用npm install安装依赖项，同时保留package-lock.json </strong></h2><p id="a261" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated"><strong class="kk iu">描述:</strong></p><p id="f594" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个测试运行期间，都会调用npm install命令来重建依赖关系。之前，删除了“node_modules”目录，但保留了package-lock.json文件。</p><p id="bcc7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结果:</strong></p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8e2a69ea27cacf61a3e781f492869bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*gDKcDSLx2o-PgR41"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图2.1。:使用package-lock.json的NPM安装运行时间比较，5次运行</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3220ef5ac35576730982b989c4276c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/0*imF0XkNljDzjrQUs"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图2.2。:使用package-lock.json时NPM安装运行时间的比较，在图表上取平均值</figcaption></figure><p id="9589" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">备注:</strong></p><p id="c785" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Ubuntu和Windows之间有着巨大的差距——差距几乎是三倍。此外，Windows上的防病毒软件增加了100%的额外开销。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="a509" class="nj lk it bd ll nk nl dn lp nm nn dp lt kr no np lv kv nq nr lx kz ns nt lz nu bi translated"><strong class="ak">基准#3:使用npm install安装依赖项，同时在每次运行时删除package-lock . JSON</strong></h2><p id="39a7" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated"><strong class="kk iu">描述:</strong></p><p id="8b1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个测试运行期间，都会调用npm install命令来重建依赖关系。之前,“node_modules”和package-lock.json都被删除了。</p><p id="0746" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结果:</strong></p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi od"><img src="../Images/1c987c37b02d8b4c1e6151eb46569b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*dCnQ5yuY4RMizkO1"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图3.1。:不使用package-lock.json时NPM安装运行时间的比较，5次运行</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d69c0840aceb9442122c8c08772e242f.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/0*YWf1dhSJtbY3zO6k"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图3.2。:不使用package-lock.json的情况下NPM安装运行时间的比较，平均值显示在图表上</figcaption></figure><p id="b54f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">评论:</strong></p><p id="7ccd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，Ubuntu和Windows之间的差距也很大——但是，这个比例已经降低了。请注意，与磁盘操作的变化相比，删除package-lock.json最终会增加所需的计算量。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="dc72" class="nj lk it bd ll nk nl dn lp nm nn dp lt kr no np lv kv nq nr lx kz ns nt lz nu bi translated"><strong class="ak">基准#4:使用纱线安装依赖项，同时保留纱线</strong></h2><p id="a32e" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated"><strong class="kk iu">描述:</strong></p><p id="a932" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个测试运行期间，调用“yarn”命令以重建依赖关系。事先，` node_modules '目录被删除，但yarn.lock文件被保留在原处。</p><p id="01d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结果:</strong></p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/299039cbdd9d681d4e82eb89cb5688ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/0*cJn7ISuBOYCV5UES"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图4.1。:纱线运行时间与使用yarn.lock的比较，5次运行</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/dabec35eb67d6aaf53d87caefff30911.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/0*JC1klOTIHPWHph7a"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图4.2。:使用yarn.lock时纱线运行时间的比较，图表上的平均值</figcaption></figure><p id="6cd8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">评论:</strong></p><p id="9128" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与两个系统上的npm相比，Yarn的使用显示了显著的改进，但是它仍然揭示了Windows版本的弱点。启用和禁用防病毒之间的差异要小得多，这表明与npm相比，磁盘操作更少。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="5df2" class="nj lk it bd ll nk nl dn lp nm nn dp lt kr no np lv kv nq nr lx kz ns nt lz nu bi translated"><strong class="ak">基准测试#5:在每次运行时移除yarn.lock时使用yarn install安装依赖项</strong></h2><p id="ca85" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated"><strong class="kk iu">描述:</strong></p><p id="1507" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个测试运行期间，调用“yarn”命令以重建依赖关系。之前,“node_modules”和yarn.lock都被删除了。</p><p id="6c17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结果:</strong></p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e6399acd11fe8a9136de03926e03b2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/0*KviDMrqVHGmTd9Q2"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图5.1。:不使用纱线锁的纱线运行时间的比较，5次运行</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/fc5f7d32d6533349e3f44eb1bdceaeee.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/0*DsMy7m0rFemo8aVN"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图5.2。:未使用纱线锁时纱线运行时间的比较，图表上的平均值</figcaption></figure><p id="b58e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">备注:</strong></p><p id="2b4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用yarn安装依赖项时不使用lockfile会导致性能显著下降。此外，两个操作系统之间的差异已经适度缩小。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="810d" class="nj lk it bd ll nk nl dn lp nm nn dp lt kr no np lv kv nq nr lx kz ns nt lz nu bi translated"><strong class="ak">基准#6:构建具有少量(3个)源文件的搭建应用</strong></h2><p id="9b52" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated"><strong class="kk iu">描述:</strong></p><p id="21bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每次测试运行期间，通过“npm run build”命令调用Webpack和typescript transpiler。源代码由三个中等大小的类型脚本代码文件组成。在每次测试之前，包含包输出的目录被删除。</p><p id="5fe6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结果:</strong></p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/1a78f2367964f543edb68ae447c4c915.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/0*5elm-L702U47O3lY"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图6.1。:构建运行时间与3个源文件、5次运行的比较</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6505d701cd4bb4b2f0fec2f86faa3560.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/0*VXR1TPjP6WS2Z2SJ"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图6.2。:在图表上比较3个源文件的构建运行时间和平均值</figcaption></figure><p id="effb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">备注:</strong></p><p id="b4ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，运行在Windows上的node赶上来了，并显示出与运行在Ubuntu上的node相似的性能。这表明，尽管与磁盘/网络操作相比，我们正在处理更多的计算，但Windows并没有明显落后——只要我们没有启用实时防病毒。</p><h2 id="a607" class="nj lk it bd ll nk nl dn lp nm nn dp lt kr no np lv kv nq nr lx kz ns nt lz nu bi translated"><strong class="ak">基准#7:构建具有大量(300+)源文件的搭建应用</strong></h2><p id="c4a4" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated"><strong class="kk iu">描述:</strong></p><p id="89c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每次测试运行期间，通过“npm run build”命令调用Webpack和Typescript transpiler。源代码由300多个中等大小的打字稿代码文件组成。每个代码文件都包括10个可导出变量和一个默认导出(见附件测试报告)。它们使用具有很少文件级别的树形结构聚集在一起。最后，一切都被逐渐导入到主index.ts文件中。和以前一样，在每个测试运行之前，带有包的目录被删除。</p><p id="d4fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结果:</strong></p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e7106c8e34483000548064f1f5096863.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/0*GfJR4_DTd2P1Q2fm"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图7.1。:构建运行时间与300多个源文件的比较，5次运行</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/6c6ea1b9e06980ac0c2171ad70ddf03e.png" data-original-src="https://miro.medium.com/v2/0*QDwJnlp1TzbGZlPH"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">图7.2。:在图表上比较300多个源文件的构建运行时间和平均值</figcaption></figure><p id="c3d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">评论:</strong></p><p id="663f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与少文件版本相比，这个测试显示了运行在Ubuntu上的节点和运行在Windows上的节点之间更明显的差异。有趣的是，与上一次相反，这一次杀毒软件并没有对结果产生很大的影响。记住，我们没有输出很多文件(结果由Webpack连接)，这表明反病毒程序只关心被调用的可执行文件的数量。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="caa9" class="lj lk it bd ll lm og lo lp lq oh ls lt jz oi ka lv kc oj kd lx kf ok kg lz ma bi translated"><strong class="ak">结论和摘录</strong></h1><p id="553c" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">是总结的时候了！平均而言，在Ubuntu上运行的任务比在Windows上运行的任务有大约41%的性能提升。涉及的磁盘操作越多，差异就越大。</p><p id="2beb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到Windows，事实证明，启用防病毒功能会导致性能下降44%,这表明开发人员不应该忘记将节点和npm列入白名单——否则，会严重影响处理时间。</p><p id="84a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一不小心，原来实验是一个该死的利用纱线的好广告。在所有测试中，它的执行速度明显快于npm——平均来说，它的执行速度比NPM快大约32 %。</p><p id="6875" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到主要问题，数字是非常清楚的——基于node.js的工具在Windows上运行时会产生明显更差的性能。背后的原因可能是什么？问题可能不在于Windows或node.js本身——毕竟，在这两种情况下，它都是正在CPU上处理的本机可执行文件。</p><p id="d052" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为问题在于它们如何在I/O级别进行交互。</p><p id="1c27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，最显著的差异发生在基于<code class="fe le lf lg lh b">npm</code>的测试中——在那些场景中，成千上万的小磁盘操作是在小文件上进行的。这就是NTFS文件系统可能落后于Ubuntu的ext4系统的地方——它只是对许多较小的操作不太优化。请注意，此过程还会大量使用网络—当缓存为空时，npm会分别请求每个包。这可能表明，当数百个HTTP请求需要快速处理和交换时，Windows网络层的响应能力不足以产生最大的潜在性能。这个话题并不新鲜——在谷歌上搜索一番后，可能会找到描述直接测量文件系统性能的<a class="ae li" href="https://www.phoronix.com/forums/forum/software/general-linux-open-source/1468-performance-of-filesystems-compared-includes-reiser4-and-ext4?1765-PERFORMANCE-OF-FILESYSTEMS-COMPARED-(includes-Reiser4-and-Ext4)_=" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="ce23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我们这些前端开发者来说意味着什么？当然，在大多数情况下，与Linux相比，在Windows上工作每天只会损失几秒钟——对于许多人来说，放弃他们心爱的环境是不值得的。在Windows上使用NPM可能会慢一些——但毕竟，我们不会一天几次重新安装所有的依赖项。但是，如果您的项目很大(数百个源文件)，涉及更复杂的转换过程(例如多个加载器和TypeScript)，并且需要您经常构建它(例如频繁发布到不同的环境)，您可能会损失大量时间，为了节省时间，可以考虑迁移到Linux。这同样适用于大量使用的CI/CD管道—如果您使用基于Windows的管道(例如，在Azure DevOps上)，除了许可成本之外，仅由于消耗的构建时间，它的成本可能更高。</p><p id="cb4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是否意味着你应该抛弃窗户？没有。但现在你知道代价了。</p><p id="5cc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想自己去玩，产生自己的结果(和结论！)，请随意使用我用过的基准代码:<br/><a class="ae li" href="https://github.com/hzub/node-perf-test" rel="noopener ugc nofollow" target="_blank">【https://github.com/hzub/node-perf-test】</a><br/>该库包括本文中使用的基准代码和示例搭建应用程序。别忘了分享你的成果！</p><p id="953f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！</p></div></div>    
</body>
</html>