<html>
<head>
<title>Searching Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/searching-algorithms-d0bc22283a62?source=collection_archive---------18-----------------------#2021-03-02">https://levelup.gitconnected.com/searching-algorithms-d0bc22283a62?source=collection_archive---------18-----------------------#2021-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ff4f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解搜索算法的基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/690e9baa126f0bd20862e96a6fa09fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6guqfh6qdBUN5ee-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索算法的主要目的是检查一个元素或从任何数据结构中检索它。这些搜索算法通常根据搜索类型分为两个不同的部分。</p><ol class=""><li id="e758" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me">顺序搜索</em> </strong>:顺序遍历列表或数组，检查每个元素。</li></ol><p id="cda0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:线性搜索</p><p id="6bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu"> <em class="me">区间搜索</em> </strong>:设计用于排序数据结构，比顺序搜索算法更有效，因为这些算法反复以数据结构的中心为目标，并将搜索空间一分为二。</p><p id="3779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二分搜索法</p><p id="2631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论这两种不同的搜索算法，分别叫做<strong class="lb iu">线性搜索</strong>和<strong class="lb iu">二分搜索法</strong>。让我们开始讨论🎉</p><h1 id="bcdd" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">线性搜索</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/5b8ea1285c30515c240f688bab0973c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HHG_VBo-nqLIW32v.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">礼貌:<a class="ae ky" href="http://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank">www.geeksforgeeks.org</a></figcaption></figure><p id="d3e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个算法是一个非常简单的算法。在这里，对数据结构中的每个元素逐一进行顺序搜索。如果找到匹配，则返回匹配，否则搜索过程继续，直到数据结构结束。</p><h1 id="8d7c" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">线性搜索是如何工作的？</h1><p id="ca86" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设我们想在数组<strong class="lb iu"> A </strong>中找到值<strong class="lb iu"> x </strong>。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f580" class="ni mg it ne b gy nj nk l nl nm">Linear Search ( Array A, Value x)</span><span id="aa39" class="ni mg it ne b gy nn nk l nl nm">Step 1: Set i to 0<br/>Step 2: if i &gt;= n then go to step 7<br/>Step 3: if A[i] = x then go to step 6<br/>Step 4: Set i to i + 1<br/>Step 5: Go to Step 2<br/>Step 6: Print Element x Found at index i and go to step 8<br/>Step 7: Print element not found<br/>Step 8: Exit</span></pre><h1 id="b96d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">伪代码</h1><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d5cc" class="ni mg it ne b gy nj nk l nl nm">procedure linear_search (list, value)</span><span id="ee84" class="ni mg it ne b gy nn nk l nl nm">   for each item in the list<br/>      if match item == value<br/>         return the item's location<br/>      end if<br/>   end for</span><span id="5815" class="ni mg it ne b gy nn nk l nl nm">end procedure</span></pre><h1 id="5ff4" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Java代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="268d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">二进位检索</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/1453ada5e64f8dfb16bdc44765940a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8nPOEjRsuFL1Xv03.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">礼貌:<a class="ae ky" href="http://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank">www.geeksforgeeks.org</a></figcaption></figure><p id="ca82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个运行时间复杂度为O(log N)的快速搜索算法。</p><blockquote class="nr"><p id="4d33" class="ns nt it bd nu nv nw nx ny nz oa lu dk translated">O(log N)算法被认为是高效的，因为当N增加时，运算次数与输入大小的比率减小并趋于零。(N是表示输入所需的以比特为单位的输入大小)</p></blockquote><p id="ac36" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">数据收集应该以排序的形式进行，以便正确地运行该算法。</p><h1 id="a80b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">二分搜索法是如何工作的？</h1><p id="0f44" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">二分搜索法通过比较收藏品中最中间的物品来寻找特定的物品。如果出现匹配，则返回该项的索引。如果不匹配，它检查中间项是否大于项，然后在中间项左侧的子数组中搜索该项。否则，将在中间项目右侧的子数组中搜索该项目。在子阵列大小减小到零之前，该过程也在子阵列上继续。</p><blockquote class="oh oi oj"><p id="fac4" class="kz la me lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">为了让二分搜索法工作，应该首先对数组进行排序</em></p></blockquote><h1 id="dc85" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">算法</h1><p id="8ff8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设我们想要在排序数组<strong class="lb iu"> A </strong>中找到值<strong class="lb iu"> x </strong>。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4a75" class="ni mg it ne b gy nj nk l nl nm">Binary Search ( Array A, Value x)Step 1: Set R=0 and L=n-1<br/>Step 2: if L &gt; R then go to step 7<br/>Step 3: Set m (the position of the middle element) to the floor of (L+R)/2<br/>Step 4: If A[m] &lt; x, set L to m+1 and go to Step 2<br/>Step 5: If A[m] &gt; x, set R to m-1 and go to Step 2<br/>Step 6: Now A[m]= x, return m, and go to step 8<br/>Step 7: Print element not found<br/>Step 8: Exit</span></pre><h1 id="df47" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">伪代码</h1><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0895" class="ni mg it ne b gy nj nk l nl nm">Procedure binary_search<br/>   A ← sorted array<br/>   n ← size of array<br/>   x ← value to be searched<br/><br/>   Set lowerBound = 0<br/>   Set upperBound = n-1 <br/><br/>   while x not found<br/>      if upperBound &lt; lowerBound <br/>         EXIT: x does not exists.<br/>   <br/>      set midPoint = lowerBound + ( upperBound - lowerBound ) / 2<br/>      <br/>      if A[midPoint] &lt; x<br/>         set lowerBound = midPoint + 1<br/>         <br/>      if A[midPoint] &gt; x<br/>         set upperBound = midPoint - 1 <br/><br/>      if A[midPoint] = x <br/>         EXIT: x found at location midPoint<br/>   end while<br/>   <br/>end procedure</span></pre><h1 id="401b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Java代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cb73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我们讨论了最常用的搜索算法技术。让我们在下一篇文章中讨论排序算法。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="ae59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">资源<br/> </strong> <a class="ae ky" href="https://www.tutorialspoint.com/" rel="noopener ugc nofollow" target="_blank">教程观点</a> <br/> <a class="ae ky" href="https://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank">极客对于极客</a> <br/> <a class="ae ky" href="https://www.wikipedia.org/" rel="noopener ugc nofollow" target="_blank">百科</a></p></div></div>    
</body>
</html>