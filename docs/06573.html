<html>
<head>
<title>Use Authentication To Protect React Routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用身份验证来保护反应路由</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-authentication-to-protect-react-routes-fc2d812ad770?source=collection_archive---------1-----------------------#2020-12-08">https://levelup.gitconnected.com/use-authentication-to-protect-react-routes-fc2d812ad770?source=collection_archive---------1-----------------------#2020-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4cdabfd6a20c77fb97a9ff692401cf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvVyOlPzrnLebwJinLdTow.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这张照片是我自己拍的！</figcaption></figure><p id="72f1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你看了标题，就知道你为什么来了！想在2020年做出受保护的反应路线？我们走吧！(要遵循本指南，您需要熟悉路由器)</p><p id="d8ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先有一个react项目。我喜欢把我的路由器从我的app.js文件分离到它自己的router.js文件中。我的app.js文件如下所示:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4ad3" class="lj lk iq lf b gy ll lm l ln lo">//App.js<br/>import './App.css'<br/>import React from 'react'<br/>import Router from './components/application/router.js'</span><span id="b07f" class="lj lk iq lf b gy lp lm l ln lo">export default function App() {<br/>  return (<br/>    &lt;div className='App'&gt;<br/>      &lt;Router /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="9fb7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">没错，我不用分号；除了我的英语。</p><p id="26ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们设置router.js文件:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3472" class="lj lk iq lf b gy ll lm l ln lo">//router.js<br/>//pretend we imported all of our components<br/>import React from 'react'<br/>import { BrowserRouter, Switch, Route, Redirect } from 'react-router-dom'</span><span id="1111" class="lj lk iq lf b gy lp lm l ln lo">export default function Router() {<br/>  return (<br/>      &lt;BrowserRouter&gt;<br/>        &lt;Navigation /&gt; <br/>        // I like to put my nav links into a seperate file<br/>          &lt;Switch&gt;<br/>            &lt;Route exact path='/'&gt;<br/>              &lt;PublicComponent /&gt;<br/>            &lt;/Route&gt;<br/>          &lt;/Switch&gt;<br/>      &lt;/BrowserRouter&gt;<br/>  )<br/>}</span></pre><p id="f11a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里我们有一个简单的路由器，只有一条路由，根路由是公共的。为了给即将创建的私有路由添加身份验证，我们需要为路由器创建一个上下文。如果你遵循这个教程，你不需要对一个上下文有很强的理解，但这里是官方的描述:</p><blockquote class="lq lr ls"><p id="a157" class="kc kd lt ke b kf kg kh ki kj kk kl km lu ko kp kq lv ks kt ku lw kw kx ky kz ij bi translated">“上下文提供了一种通过组件树传递数据的方式，而不必在每一级手动向下传递属性。”</p></blockquote><p id="9e6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请阅读<a class="ae lx" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文—反应(reactjs.org)</a>了解更多详情。</p><p id="fbdd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好的，我们将开始创建一个上下文和一个钩子，你可以在这里读到:<a class="ae lx" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">介绍钩子——React(reactjs.org)</a>。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="a026" class="lj lk iq lf b gy ll lm l ln lo">//hooks/auth.js<br/>import React, { useState, useEffect, useContext, createContext } from 'react'</span><span id="db0e" class="lj lk iq lf b gy lp lm l ln lo">const authContext = createContext()</span><span id="eca3" class="lj lk iq lf b gy lp lm l ln lo">export function ProvideAuth({ children }) {<br/>  const auth = useProvideAuth()<br/>  return &lt;authContext.Provider value={auth}&gt; { children } &lt;/authContext.Provider&gt;<br/>}</span><span id="67d0" class="lj lk iq lf b gy lp lm l ln lo">export const useAuth = () =&gt; useContext(authContext)</span><span id="b743" class="lj lk iq lf b gy lp lm l ln lo">function useProvideAuth() {<br/>  return []<br/>}</span></pre><p id="790a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我们的上下文和钩子。来说说我们目前掌握的情况，(提示:不多)。</p><p id="a9d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">导入必要的需求后，我们创建一个上下文。然后，我们将上下文作为组件导出。不要太担心这些是如何工作的，这超出了我们的讨论范围。真正要注意的最重要的事情是，无论什么由<code class="fe ly lz ma lf b">useProvideAuth()</code>返回，现在都可以通过使用<code class="fe ly lz ma lf b">useAuth()</code>钩子来访问。</p><p id="1423" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">考虑到这一点，让我们创建一个有用的返回值！</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="43d9" class="lj lk iq lf b gy ll lm l ln lo">//hooks/auth.js</span><span id="eff7" class="lj lk iq lf b gy lp lm l ln lo">//we need a base URL for our sign in function<br/>const baseUrl = process.env.REACT_APP_BASE_URL</span><span id="e46d" class="lj lk iq lf b gy lp lm l ln lo">***</span><span id="e43c" class="lj lk iq lf b gy lp lm l ln lo">function useProvideAuth() {<br/>  const [user, setUser] = useState(null)</span><span id="2ede" class="lj lk iq lf b gy lp lm l ln lo">  const signin = (credentials) =&gt; {<br/>    fetch(baseUrl + 'login', {<br/>      method: 'POST',<br/>      credentials: 'include',<br/>      headers: {<br/>        'Content-Type': 'application/json',<br/>        'Accepts': 'application/json'<br/>      },<br/>      body: JSON.stringify(credentials)<br/>    })<br/>    .then(res =&gt; res.json())<br/>    .then(json =&gt; setUser(json.user))<br/>  }</span><span id="cd00" class="lj lk iq lf b gy lp lm l ln lo">useEffect(() =&gt; {<br/>    //check authentication<br/>  }, [])</span><span id="96e7" class="lj lk iq lf b gy lp lm l ln lo">return {<br/>    user,<br/>    signin<br/>  }<br/>}</span></pre><p id="5e2e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用React的<code class="fe ly lz ma lf b">useState()</code>功能来设置一个名为user的常量，并创建一个函数来更新它。如你所见，在我们的<code class="fe ly lz ma lf b">fetch()</code>之后的第二个<code class="fe ly lz ma lf b">.then()</code>中，我们有<code class="fe ly lz ma lf b">setUser(json.user)</code>。</p><p id="fc3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您想包含检查用户访问网站时是否登录的功能，应该在<code class="fe ly lz ma lf b">useEffect()</code>回调中完成。</p><p id="243b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">回到路由器，让我们使用新创建的上下文:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3cb7" class="lj lk iq lf b gy ll lm l ln lo">//router.js</span><span id="2588" class="lj lk iq lf b gy lp lm l ln lo">***</span><span id="6032" class="lj lk iq lf b gy lp lm l ln lo">export default function Router() {<br/>  return (<br/>    &lt;ProvideAuth&gt;<br/>      &lt;BrowserRouter&gt;<br/>        &lt;Navigation /&gt; <br/>        // I like to put my nav links into a seperate file<br/>          &lt;Switch&gt;<br/>            &lt;Route exact path='/'&gt;<br/>              &lt;PublicComponent /&gt;<br/>            &lt;/Route&gt;<br/>          &lt;/Switch&gt;<br/>      &lt;/BrowserRouter&gt;<br/>    &lt;/ProvideAuth&gt;<br/>  )<br/>}</span></pre><p id="94c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来呢？我们如何在上下文中使用auth变量的值？让我们创建一条私人路线。如果你不知道你可以随时创建自己喜欢的定制路线，那么，你的想法就要被打破了！</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="945c" class="lj lk iq lf b gy ll lm l ln lo">//router.js</span><span id="c197" class="lj lk iq lf b gy lp lm l ln lo">***</span><span id="02f5" class="lj lk iq lf b gy lp lm l ln lo">function PrivateRoute({ children, ...rest }) {<br/>  const auth = useAuth()<br/>  return (<br/>    &lt;Route {...rest} render={({ location }) =&gt;<br/>        auth.user ? (children) :<br/>        (&lt;Redirect to={{ pathname: '/login', state: { from: location } }} /&gt;)<br/>      }<br/>    /&gt;<br/>  )<br/>}</span></pre><p id="2ada" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">路由基本上只是组件！第一个参数总是路由的子节点。<code class="fe ly lz ma lf b">...rest</code>是路线标签中剩余的参数(如果有的话)。如你所见，我们初始化了我们的<code class="fe ly lz ma lf b">useAuth()</code>钩子。</p><p id="a22b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的返回值中，我们只需要一个标准的React route组件，并在渲染参数中给它<code class="fe ly lz ma lf b">...rest</code>,我们传入一个可爱的函数，该函数将位置作为参数。这个函数返回一个三元“if”语句，该语句检查<code class="fe ly lz ma lf b">auth.user</code>的值，并返回嵌套在<code class="fe ly lz ma lf b">&lt;PrivateRoute&gt;&lt;/PrivateRoute&gt;</code>之间的组件，或者将我们重定向到登录路径。</p><p id="10a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">回到我们的路由器，我们可以实现<code class="fe ly lz ma lf b">PrivateRoute</code>:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b2c3" class="lj lk iq lf b gy ll lm l ln lo">//router.js</span><span id="1839" class="lj lk iq lf b gy lp lm l ln lo">***</span><span id="af9a" class="lj lk iq lf b gy lp lm l ln lo">export default function Router() {<br/>  return (<br/>    &lt;ProvideAuth&gt;<br/>      &lt;BrowserRouter&gt;<br/>        &lt;Navigation /&gt; <br/>        // I like to put my nav links into a seperate file<br/>          &lt;Switch&gt;<br/>            &lt;Route exact path='/'&gt;<br/>              &lt;PublicComponent /&gt;<br/>            &lt;/Route&gt;<br/>            <!-- -->&lt;PrivateRoute path='private'&gt;<br/>               &lt;PrivateComponent /&gt;<br/>            &lt;/PrivateRoute&gt;<br/>          &lt;/Switch&gt;<br/>      &lt;/BrowserRouter&gt;<br/>    &lt;/ProvideAuth&gt;<br/>  )<br/>}</span></pre><p id="1f0b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是的，就是这么简单！但是我们还没有完成。</p><p id="39de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的登录组件中，(你自己处理这个)我们需要包含一个对我们的登录函数的引用。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="418a" class="lj lk iq lf b gy ll lm l ln lo">//hypotheticalLoginComponent.js</span><span id="d142" class="lj lk iq lf b gy lp lm l ln lo">const auth = useAuth()</span><span id="0d5c" class="lj lk iq lf b gy lp lm l ln lo">*** </span><span id="26d1" class="lj lk iq lf b gy lp lm l ln lo">const onSubmit = () =&gt; {<br/> auth.signin(credentials)<br/>}</span></pre><p id="4f8b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在您的登录组件中，您应该使用<code class="fe ly lz ma lf b">useAuth()</code>将登录凭证提交给我们出色的auth hook。</p><p id="4b2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您想将所有API调用抽象到另一个文件，您也可以只让您的<code class="fe ly lz ma lf b">signin()</code>函数调用<code class="fe ly lz ma lf b">setUser()</code>，并在API调用解析后调用那个登录函数。</p><p id="f9eb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里是<code class="fe ly lz ma lf b">router.js</code>和<code class="fe ly lz ma lf b">auth.js</code>的最终文件</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="598a" class="lj lk iq lf b gy ll lm l ln lo">//router.js<br/>import React from 'react'<br/>import { BrowserRouter, Switch, Route, Redirect } from 'react-router-dom'<br/>import { ProvideAuth, useAuth } from '../../hooks/auth.js'</span><span id="e9b6" class="lj lk iq lf b gy lp lm l ln lo">export default function Router() {<br/>  return (<br/>    &lt;ProvideAuth&gt;<br/>      &lt;BrowserRouter&gt;<br/>        &lt;Navigation /&gt; <br/>        // I like to put my nav links into a seperate file<br/>          &lt;Switch&gt;<br/>            &lt;Route exact path='/'&gt;<br/>              &lt;PublicComponent /&gt;<br/>            &lt;/Route&gt;<br/>            <!-- -->&lt;PrivateRoute path='private'&gt;<br/>               &lt;PrivateComponent /&gt;<br/>            &lt;/PrivateRoute&gt;<br/>          &lt;/Switch&gt;<br/>      &lt;/BrowserRouter&gt;<br/>    &lt;/ProvideAuth&gt;<br/>  )<br/>}</span><span id="d46c" class="lj lk iq lf b gy lp lm l ln lo">function PrivateRoute({ children, ...rest }) {<br/>  const auth = useAuth()<br/>  return (<br/>    &lt;Route {...rest} render={({ location }) =&gt;<br/>        auth.user ? (children) :<br/>        (&lt;Redirect to={{ pathname: '/login', state: { from: location } }} /&gt;)<br/>      }<br/>    /&gt;<br/>  )<br/>}</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><pre class="le lf lg lh aw li bi"><span id="44c1" class="lj lk iq lf b gy mi mj mk ml mm lm l ln lo">import React, { useState, useEffect, useContext, createContext } from 'react'</span><span id="1f48" class="lj lk iq lf b gy lp lm l ln lo">const baseUrl = process.env.REACT_APP_BASE_URL</span><span id="626b" class="lj lk iq lf b gy lp lm l ln lo">const authContext = createContext()</span><span id="2465" class="lj lk iq lf b gy lp lm l ln lo">export function ProvideAuth({ children }) {<br/>  const auth = useProvideAuth()<br/>  return &lt;authContext.Provider value={auth}&gt; { children } &lt;/authContext.Provider&gt;<br/>}</span><span id="b6a3" class="lj lk iq lf b gy lp lm l ln lo">export const useAuth = () =&gt; useContext(authContext)</span><span id="05b1" class="lj lk iq lf b gy lp lm l ln lo">function useProvideAuth() {<br/>  const [user, setUser] = useState(null)</span><span id="9ecc" class="lj lk iq lf b gy lp lm l ln lo">const signin = (credentials) =&gt; {<br/>    fetch(baseUrl + 'login', {<br/>      method: 'POST',<br/>      credentials: 'include',<br/>      headers: {<br/>        'Content-Type': 'application/json',<br/>        'Accepts': 'application/json'<br/>      },<br/>      body: JSON.stringify(credentials)<br/>    })<br/>    .then(res =&gt; res.json())<br/>    .then(json =&gt; setUser(json.user))<br/>  }</span><span id="02d7" class="lj lk iq lf b gy lp lm l ln lo">useEffect(() =&gt; {<br/>    //check authentication<br/>  }, [])</span><span id="8f35" class="lj lk iq lf b gy lp lm l ln lo">return {<br/>    user,<br/>    signin<br/>  }<br/>}</span></pre><p id="d784" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望这些对你有用。祝您愉快，感谢您的阅读！</p></div></div>    
</body>
</html>