<html>
<head>
<title>Canary release from legacy apps to micro-frontends via CloudFront functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过CloudFront函数将Canary从传统应用程序发布到微前端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-legacy-apps-to-micro-frontends-via-cloudfront-functions-1a7dd7f34be1?source=collection_archive---------4-----------------------#2021-09-19">https://levelup.gitconnected.com/from-legacy-apps-to-micro-frontends-via-cloudfront-functions-1a7dd7f34be1?source=collection_archive---------4-----------------------#2021-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cbb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遗留前端的迁移正在成为软件工程中非常常见的活动，部分原因是JavaScript生态系统和框架在过去十年中的不断发展。在这种情况下，微前端正在成为在新的框架中重写遗留应用程序的有效选择。让我们来看看一个有效而简单的方法，你可以通过<a class="ae kl" href="https://aws.amazon.com/blogs/aws/introducing-cloudfront-functions-run-your-code-at-the-edge-with-low-latency-at-any-scale/" rel="noopener ugc nofollow" target="_blank"> CloudFront函数</a>应用<a class="ae kl" href="https://martinfowler.com/bliki/CanaryRelease.html" rel="noopener ugc nofollow" target="_blank"> canary release </a>策略，通过扼杀遗留应用程序并将它们迁移到微前端应用程序。</p><h1 id="7598" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">冰冷矿井中的金丝雀前来救援</h1><p id="8531" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">虽然有时重写生产应用程序是必要的，但这对业务和客户体验来说是一个具体的风险。我们需要保守的方法来做局部的转变:释放金丝雀。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/b5669ef42a66a4b6c37c4162630c6218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*ZJSqowb1ZXEyxZY2EHOiMg.jpeg"/></div></figure><p id="28c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目标是慢慢地将一小部分用户流量从旧应用转移到新应用。看似对<a class="ae kl" href="https://share.america.gov/english-idiom-canary-coal-mine/" rel="noopener ugc nofollow" target="_blank">可怜的鸟儿</a>的工作来说，金丝雀放生是一种非常有效的方法:</p><ul class=""><li id="7a2c" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">当出现问题时，支持快速回滚策略。</li><li id="f040" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">通过快速了解新发布产品的功能、可扩展性和性能，提供即时反馈</li><li id="3457" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">学习失败的文化，然后可以通过收集的数据进行分析。</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="52c4" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">为什么CloudFront功能</h1><p id="927e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">CloudFront函数是已经庞大的AWS功能组合的最新成员。通俗地说，它们有点像类固醇上的<a class="ae kl" href="https://aws.amazon.com/lambda/edge" rel="noopener ugc nofollow" target="_blank"> Lambda@Edge </a>，它们的主要区别在于，通过在<a class="ae kl" href="https://wa.aws.amazon.com/wellarchitected/2020-07-02T19-33-23/wat.concept.edge-location.en.html" rel="noopener ugc nofollow" target="_blank">边缘位置</a>而不是<a class="ae kl" href="https://aws.amazon.com/about-aws/whats-new/2016/11/announcing-regional-edge-caches-for-amazon-cloudfront/" rel="noopener ugc nofollow" target="_blank">区域边缘缓存</a>上执行，它们在非常低的延迟下更容易扩展，甚至在地理上更接近客户。该功能将根据cookie策略在我们的旧应用和新应用之间重定向用户。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/82cdf37081c6863e37a27054334291e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AowGaeLGZ2tATcvAPKx3_A.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">传统和微前端之间的重定向</figcaption></figure><p id="483a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所示，假设我们既有一个现有的生产遗留应用程序(部署在AWS上或内部)，又有一个基于微前端架构的新web应用程序(在生产AWS上，但还不能公开访问)。让我们看看CloudFront函数如何向这两个设置分派流量。</p><h1 id="bc76" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">设置CloudFront功能</h1><p id="1cf4" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">函数可以在CloudFront收到来自查看器的请求(查看器请求)之后和CloudFront将响应转发给查看器(查看器响应)之前被触发。</p><p id="9a0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当创建函数时，我们需要将它们关联到CloudFront发行版，该发行版指向默认遗留应用程序所在的S3源。下面让我们来看看它的实际操作(AWS <a class="ae kl" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/create-function.html" rel="noopener ugc nofollow" target="_blank">指南在这里</a>)。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ng"><img src="../Images/a41f3aa86ddf1da1776db09063afb1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*u4vEDRi5gYx2UYe00f0cjQ.gif"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">创建CloudFront函数的步骤</figcaption></figure><p id="6262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要提示:</strong>对于这个概念验证，我选择指出传统应用程序的来源，但它可以很容易地转换为使用微前端。</p><p id="c7a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了该功能的内容:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="07e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数本身检查请求中是否存在一个<em class="nj"> X-Source </em> cookie。</p><ul class=""><li id="64b3" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">用户的百分比由实验流量常数决定。当设置为零时，所有流量都流向传统，否则，如果设置为1，所有流量都流向微前端。</li><li id="cf5d" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">如果<em class="nj"> X-Source </em>不存在(第一次访问者)，该函数随机选择其值(无论是传统还是微前端应用程序)并将其分配给请求cookie。</li><li id="dd30" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">如果<em class="nj"> X-Source </em>存在，该功能会将用户重定向到cookie值中定义的应用类型，即<em class="nj">传统应用</em>或<em class="nj"> mfe-app </em>。</li><li id="0f1d" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">当返回请求时，我们将index.html添加到CloudFront发行版的默认根url前面，因为spa需要这个技巧，<a class="ae kl" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/example-function-add-index.html" rel="noopener ugc nofollow" target="_blank">，如此处所示</a>。</li></ul><p id="c8b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，让我们看看查看器响应函数的内容:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0b62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个更简单的函数，因为它在我们从缓存返回后，在响应中用正确的值设置cookie。</p><h1 id="ea4b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结果</h1><p id="d719" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">当用户第一次访问URL分发时，他们将被分配一个cookie，该cookie将管理他们将被重定向到的状态。在下图中，我通过在web控制台中修改X-Source cookie来手动修改它以加快这个过程。传统应用程序是橙色的登录应用程序，而新的微前端只是典型的有棱角的蓝色应用程序。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ng"><img src="../Images/7236d7fe2b08917e7369d2388fae7420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XWFWY9JbrZKDXSdYG3vROA.gif"/></div></div></figure><h1 id="5577" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">局限性和想法</h1><p id="5864" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">以下限制和想法可以得到加强:</p><ul class=""><li id="df2e" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">与Lambda@Edge相比，最大的限制是缺乏对在CloudFront函数中获取外部配置的支持。在S3或DynamoDB中存储额外的配置很方便，不需要更新发行版代码，但代价可能是通过避免这种情况，CloudFront函数在可伸缩性和低延迟方面达到了更好的性能</li><li id="249e" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">使用console.log语句来监视函数。日志组将在<em class="nj"> CloudWatch中可见，</em>仅在北弗吉尼亚地区可见。</li><li id="6b71" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">流量配置可能比本PoC中所示的更复杂，在这种情况下，Lambda@Edge可能更合适。</li><li id="a302" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">可以使用类似的方法用新的URI替换旧应用程序的某些部分。</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="79a8" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">摘要</h1><p id="4696" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">重写工作是昂贵的，企业应该小心，并且有很好的商业和技术理由这样做(不支持的框架、修改产品、团队成长、处于危险中的商业案例等)..).Canary版本和CloudFront支持我们重新评估应用的性能和可用性，可能重新访问用户流，并通过数据获得关于架构决策(微前端)的见解和知识。</p><h1 id="c740" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><ul class=""><li id="2227" class="lx ly iq jp b jq lk ju ll jy nk kc nl kg nm kk mc md me mf bi translated"><a class="ae kl" href="https://aws.amazon.com/blogs/aws/introducing-cloudfront-functions-run-your-code-at-the-edge-with-low-latency-at-any-scale/" rel="noopener ugc nofollow" target="_blank">引入CloudFront功能——在任何规模下以低延迟在边缘运行您的代码</a></li><li id="44fc" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><a class="ae kl" href="https://www.youtube.com/watch?v=fT-5RHTtFNg" rel="noopener ugc nofollow" target="_blank">在边缘构建无服务器微前端</a> (Re:Invent 2019)</li></ul></div></div>    
</body>
</html>