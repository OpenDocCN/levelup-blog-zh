<html>
<head>
<title>Best practices when consuming an API through C# and .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过C#和使用API的最佳实践。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/best-practices-when-consuming-an-api-through-c-and-net-9807348b16b?source=collection_archive---------4-----------------------#2020-10-03">https://levelup.gitconnected.com/best-practices-when-consuming-an-api-through-c-and-net-9807348b16b?source=collection_archive---------4-----------------------#2020-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/66fb9d15467be9d0499d4f7b5d34b48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mX29gwM2MfVCE2NuPMF0w.jpeg"/></div></div></figure><p id="580c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来讨论一下使用第三方API的最佳实践——甚至是使用您自己的API的最佳实践！</p><h1 id="0dce" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">抢一个官方图书馆</h1><p id="406a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果你幸运的话，将会有一个官方的客户端库作为你正在使用的API的Nuget包。如果有，这通常是最好的路线，因为它会节省你很多工作。你只需安装软件包，就可以开始了。您可以通过Nuget跟踪库的任何更新。</p><p id="ad54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数真正流行的API都有官方的。NET库，但并不总是这样。有时你会得到一个没有针对性的API。NET开发人员，或者他们正在与微软竞争，或者类似性质的东西，然后可能很难找到。直接网支持。这完全取决于开发者社区。</p><h1 id="1992" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">不要抢非官方图书馆</h1><p id="71f8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果没有一个官方的客户端库，那么对于那些声称是为你想要使用的API开发的随机库，要非常小心。这些通常是实验，辅导项目，未完成的，或不受支持的。你可能会受到诱惑，认为使用别人开始的东西会节省你的时间，但最终你可能会浪费时间去解释它是如何工作的，并找到他们没有解决的问题。</p><p id="e31a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你是个很棒的程序员。你应该自己写API客户端库！</p><p id="5bb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编写自己的API客户端让您受益于了解代码，并且只包含您真正感兴趣或计划使用的API部分。当没有官方库时，你花在编写自己的代码上的时间通常是一项不错的投资。</p><h1 id="a222" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">创建API客户端的步骤</h1><p id="46a3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">拉起第三方API文档，让我们开始吧！</p><h1 id="0209" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">DTO班级</h1><p id="fb83" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我总是从将我需要的API部分映射到本地数据传输对象类开始。dto被用作保存数据并将其传递到应用程序其他区域的容器。DTO类不包含任何逻辑，只包含表示数据的属性。例如:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="091f" class="mi kx iq me b gy mj mk l ml mm">public class ExampleDTO<br/>{<br/>	public int Id { get; set; }<br/>	public string FirstName { get; set; }<br/>	public string LastName { get; set; }<br/>	public string DisplayName { get; set; }<br/>}</span></pre><p id="9448" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建属性与API文档中列出的对象的属性相匹配的类。您在这里所做的是将外部API建模为强类型对象，您可以在自己的本地代码中使用这些对象。</p><p id="04c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，有一点需要注意，API几乎只返回JSON。JSON属性命名约定与C#的不同之处在于它们通常是camelcase。C#中的属性“ExampleProperty”在JSON中可能会被表示为“exampleProperty”。即使API作者遵循惯例也是如此。你可能会发现他们使用下划线，比如“example_property”。</p><p id="e857" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将从API获得的JSON反序列化到本地dto可能需要DataContract的帮助。DataContract确切地告诉我们的类外部数据的内容。例如:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b6b5" class="mi kx iq me b gy mj mk l ml mm">using System.Runtime.Serialization;</span><span id="f42a" class="mi kx iq me b gy mn mk l ml mm">[DataContract]<br/>public class ExampleDTO<br/>{<br/>	[DataMember(Name = "id")]<br/>	public int Id { get; set; }<br/>	[DataMember(Name = "first_name")]<br/>	public string FirstName { get; set; }<br/>	[DataMember(Name = "last_name")]<br/>	public string LastName { get; set; }<br/>	[DataMember(Name = "display_name")]<br/>	public string DisplayName { get; set; }<br/>}</span></pre><p id="ad21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的[DataMember]注释将每个外部属性名转换为一个本地属性。如果你给本地属性取和API一样的名字，你不会得到任何编译错误或者让Intellisense生气…</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2291" class="mi kx iq me b gy mj mk l ml mm">public string first_name { get; set; }</span></pre><p id="346e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，那是糟糕的C#。努力使用[DataContract]和[DataMember]注释使数据代表C#标准。</p><p id="8a74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了将从API返回的内容映射到本地类之外，您还需要为它们期望您作为请求数据发送的所有内容创建DTO类。这是一条双行道。这些都是用同样的方法做的。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e356" class="mi kx iq me b gy mj mk l ml mm">using System.Runtime.Serialization;</span><span id="2e10" class="mi kx iq me b gy mn mk l ml mm">[DataContract]<br/>public class ExampleRequest<br/>{<br/>	[DataMember(Name = "id")]<br/>	public int Id { get; set; }<br/>}</span></pre><p id="e572" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您的属性“id”被正确地格式化为“Id”，这是他们所期望的。</p><h1 id="4458" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">创建可重用的RestClient</h1><p id="5beb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在您完全建模了API(或者只是您计划使用的部分)之后，下一步是编写一个客户端，它将完成您的应用程序和API之间的通信工作。客户端发送请求并接收数据作为回报。</p><p id="a223" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，您真的只需要编写一个RestClient，并且不需要做太多改变就可以使用不同的API。在<a class="ae mo" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a>中，调用API的方法只有这么多。通常它是一个GET或POST调用(虽然偶尔也有一个PUT调用来传输文件)。如果它是一个GET调用，那么您可能需要将查询字符串参数与URL放在一起。如果它是POST调用，您将向它发送JSON。您可以将所有这些简化成一个可重用的RestClient类。</p><p id="f912" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个客户端示例:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2860" class="mi kx iq me b gy mj mk l ml mm">using ExampleAPIClient.Models;<br/>using ExampleAPIClient.Utilities;<br/>using System;<br/>using System.Collections.Generic;<br/>using System.IO;<br/>using System.Net;<br/>using System.Net.Http;<br/>using System.Net.Http.Headers;<br/>using System.Text;<br/>using System.Threading.Tasks;</span><span id="82da" class="mi kx iq me b gy mn mk l ml mm">namespace ExampleAPIClient.Client<br/>{<br/>    public class RestClient : HttpClient<br/>    {<br/>        private string _baseUri = "https://external-api.com";</span><span id="96f1" class="mi kx iq me b gy mn mk l ml mm">        private TokenResponse _token;</span><span id="b754" class="mi kx iq me b gy mn mk l ml mm">        public RestClient()<br/>        {<br/>            InitializeTlsProtocol();<br/>        }</span><span id="9a22" class="mi kx iq me b gy mn mk l ml mm">        public async Task&lt;T&gt; GetAsync&lt;T&gt;(string url, Dictionary&lt;string, string&gt; query)<br/>        {<br/>            await SetTokenAsync();</span><span id="5106" class="mi kx iq me b gy mn mk l ml mm">            DefaultRequestHeaders.Clear();<br/>            DefaultRequestHeaders.CacheControl = new CacheControlHeaderValue() { NoCache = true };<br/>            DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _token.AccessToken);</span><span id="74ec" class="mi kx iq me b gy mn mk l ml mm">            using (HttpResponseMessage response = await GetAsync(Utils.AddQueryString(_baseUri + url, query)))<br/>            {<br/>                if (response.IsSuccessStatusCode)<br/>                {<br/>                    return await response.Content.ReadAsAsync&lt;T&gt;();<br/>                }</span><span id="881d" class="mi kx iq me b gy mn mk l ml mm">                throw new Exception(response.ReasonPhrase);<br/>            }<br/>        }</span><span id="c343" class="mi kx iq me b gy mn mk l ml mm">        public async Task&lt;T&gt; GetAsync&lt;T&gt;(string url)<br/>        {<br/>            await SetTokenAsync();</span><span id="df81" class="mi kx iq me b gy mn mk l ml mm">            DefaultRequestHeaders.Clear();<br/>            DefaultRequestHeaders.CacheControl = new CacheControlHeaderValue() { NoCache = true };<br/>            DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _token.AccessToken);</span><span id="7b70" class="mi kx iq me b gy mn mk l ml mm">            using (HttpResponseMessage response = await GetAsync(_baseUri + url))<br/>            {<br/>                if (response.IsSuccessStatusCode)<br/>                {<br/>                    return await response.Content.ReadAsAsync&lt;T&gt;();<br/>                }</span><span id="2fb4" class="mi kx iq me b gy mn mk l ml mm">                throw new Exception(response.ReasonPhrase);<br/>            }<br/>        }</span><span id="4783" class="mi kx iq me b gy mn mk l ml mm">        public async Task&lt;T&gt; PostAsync&lt;T&gt;(string url, string data)<br/>        {<br/>            await SetTokenAsync();</span><span id="426d" class="mi kx iq me b gy mn mk l ml mm">            DefaultRequestHeaders.Clear();<br/>            DefaultRequestHeaders.CacheControl = new CacheControlHeaderValue() { NoCache = true };<br/>            DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _token.AccessToken);</span><span id="baf3" class="mi kx iq me b gy mn mk l ml mm">            var content = new StringContent(data, Encoding.UTF8, "application/json");</span><span id="572e" class="mi kx iq me b gy mn mk l ml mm">            using (HttpResponseMessage response = await PostAsync(_baseUri + url, content))<br/>            {<br/>                if (response.IsSuccessStatusCode)<br/>                {<br/>                    return await response.Content.ReadAsAsync&lt;T&gt;();<br/>                }</span><span id="59e0" class="mi kx iq me b gy mn mk l ml mm">                throw new Exception(response.ReasonPhrase);<br/>            }<br/>        }</span><span id="9d32" class="mi kx iq me b gy mn mk l ml mm">        public async Task&lt;T&gt; PutAsync&lt;T&gt;(string url, FileStream fs)<br/>        {<br/>            await SetTokenAsync();</span><span id="dc63" class="mi kx iq me b gy mn mk l ml mm">            DefaultRequestHeaders.Clear();<br/>            DefaultRequestHeaders.CacheControl = new CacheControlHeaderValue() { NoCache = true };<br/>            DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _token.AccessToken);</span><span id="b353" class="mi kx iq me b gy mn mk l ml mm">            using (HttpResponseMessage response = await PutAsync(_baseUri + url, new StreamContent(fs)))<br/>            {<br/>                if (response.IsSuccessStatusCode)<br/>                {<br/>                    return await response.Content.ReadAsAsync&lt;T&gt;();<br/>                }</span><span id="f88f" class="mi kx iq me b gy mn mk l ml mm">                throw new Exception(response.ReasonPhrase);<br/>            }<br/>        }</span><span id="8105" class="mi kx iq me b gy mn mk l ml mm">        private void InitializeTlsProtocol()<br/>        {<br/>            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;<br/>        }</span><span id="4d1c" class="mi kx iq me b gy mn mk l ml mm">        private async Task SetTokenAsync()<br/>        {<br/>            if (_token == null || _token.Expiration &gt; DateTime.Now)<br/>            {<br/>                DefaultRequestHeaders.Clear();<br/>                DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", "SOME CREDENTIAL SCHEME");</span><span id="5862" class="mi kx iq me b gy mn mk l ml mm">                var content = new StringContent("grant_type=client_credentials", Encoding.UTF8, "application/x-www-form-urlencoded");</span><span id="6327" class="mi kx iq me b gy mn mk l ml mm">                using (HttpResponseMessage response = await PostAsync(_baseUri + "/some-path-to-get/token", content))<br/>                {<br/>                    if (response.IsSuccessStatusCode)<br/>                    {<br/>                        _token = await response.Content.ReadAsAsync&lt;TokenResponse&gt;();<br/>                    }<br/>                    else<br/>                    {<br/>                        throw new Exception(response.ReasonPhrase);<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="5260" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">RestClient的剖析</h1><h2 id="cfdb" class="mi kx iq bd ky mp mq dn lc mr ms dp lg kj mt mu lk kn mv mw lo kr mx my ls mz bi translated">任务</h2><p id="1349" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虽然这不是绝对必要的，但最佳实践是让所有调用都成为异步任务。您不知道请求需要多长时间才能完成，并且您不希望阻塞的调用占用您的用户界面。</p><h2 id="42f5" class="mi kx iq bd ky mp mq dn lc mr ms dp lg kj mt mu lk kn mv mw lo kr mx my ls mz bi translated">证明</h2><p id="5562" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在调用API时，通常会涉及到某种身份验证和授权。有标准的认证方案，比如OAuth2，但是单个API的认证也可以完全定制。大多数都涉及某种令牌或其他数据，您必须将它们作为查询字符串参数或头部添加到调用中。它们通常也会过期。您的代码应该持有这个令牌，并检查是否过期，只有在它过期时才调用获取新令牌。</p><h2 id="c1d8" class="mi kx iq bd ky mp mq dn lc mr ms dp lg kj mt mu lk kn mv mw lo kr mx my ls mz bi translated">HTTP方法</h2><p id="1063" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虽然POST请求作为单个字符串传递给JSON，但是GET请求通常需要多个查询字符串参数一起传递。在这里，我们通过将单个参数作为字典传递给方法来简化这一过程。我们还有一个实用程序，可以将字典翻译成查询字符串。看起来是这样的:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f2fc" class="mi kx iq me b gy mj mk l ml mm">using System;<br/>using System.Collections.Generic;<br/>using System.Net;<br/>using System.Text;</span><span id="9062" class="mi kx iq me b gy mn mk l ml mm">namespace ExampleAPIClient.Utilities<br/>{<br/>    public partial class Utils<br/>    {<br/>        public static string AddQueryString(string uri, IDictionary&lt;string, string&gt; queryString)<br/>        {<br/>            if (uri == null)<br/>            {<br/>                throw new ArgumentNullException(nameof(uri));<br/>            }</span><span id="a747" class="mi kx iq me b gy mn mk l ml mm">            if (queryString == null)<br/>            {<br/>                throw new ArgumentNullException(nameof(queryString));<br/>            }</span><span id="50af" class="mi kx iq me b gy mn mk l ml mm">            return AddQueryString(uri, (IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt;)queryString);<br/>        }</span><span id="1be5" class="mi kx iq me b gy mn mk l ml mm">        private static string AddQueryString(<br/>            string uri,<br/>            IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; queryString)<br/>        {<br/>            if (uri == null)<br/>            {<br/>                throw new ArgumentNullException(nameof(uri));<br/>            }</span><span id="100a" class="mi kx iq me b gy mn mk l ml mm">            if (queryString == null)<br/>            {<br/>                throw new ArgumentNullException(nameof(queryString));<br/>            }</span><span id="f005" class="mi kx iq me b gy mn mk l ml mm">            var anchorIndex = uri.IndexOf('#');<br/>            var uriToBeAppended = uri;<br/>            var anchorText = "";</span><span id="f45c" class="mi kx iq me b gy mn mk l ml mm">            if (anchorIndex != -1)<br/>            {<br/>                anchorText = uri.Substring(anchorIndex);<br/>                uriToBeAppended = uri.Substring(0, anchorIndex);<br/>            }</span><span id="300d" class="mi kx iq me b gy mn mk l ml mm">            var queryIndex = uriToBeAppended.IndexOf('?');<br/>            var hasQuery = queryIndex != -1;</span><span id="23ea" class="mi kx iq me b gy mn mk l ml mm">            var sb = new StringBuilder();<br/>            sb.Append(uriToBeAppended);<br/>            foreach (var parameter in queryString)<br/>            {<br/>                sb.Append(hasQuery ? '&amp;' : '?');<br/>                sb.Append(WebUtility.UrlEncode(parameter.Key));<br/>                sb.Append('=');<br/>                sb.Append(WebUtility.UrlEncode(parameter.Value));<br/>                hasQuery = true;<br/>            }</span><span id="d9f1" class="mi kx iq me b gy mn mk l ml mm">            sb.Append(anchorText);<br/>            return sb.ToString();<br/>        }<br/>    }<br/>}</span></pre><p id="49f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大概就是这么多了。现在，您已经准备好开始使用客户端打电话了！</p><h1 id="a79f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在代码中使用RestClient</h1><p id="f094" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您可以在控制器、服务或架构中任何有意义的地方使用RestClient。一般结构是:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9480" class="mi kx iq me b gy mj mk l ml mm">public async Task&lt;ExampleDTO&gt; ExampleMethod(ExampleRequest request)<br/>{<br/>	// Serialize the request into JSON.<br/>	var data = JsonConvert.SerializeObject(request);</span><span id="0f1b" class="mi kx iq me b gy mn mk l ml mm">	// Post the data and then deserialize the response into ExampleDTO.<br/>	return await _client.PostAsyc&lt;ExampleDTO&gt;("some-end-point-url", data);<br/>}</span></pre><p id="78de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这几行代码将成为所有API调用的要点。您已经完成了所有繁重的工作，现在您可以从坚实的基础架构中获益。</p><h1 id="e307" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">一些额外的事情要考虑</h1><h2 id="7dd2" class="mi kx iq bd ky mp mq dn lc mr ms dp lg kj mt mu lk kn mv mw lo kr mx my ls mz bi translated">您对外部API没有任何控制权，因此错误处理比您用自己的代码编程更重要。</h2><p id="5a6c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">你永远不应该假设一个API会正常工作，甚至在你需要的时候是可用的。诊断一个问题可能具有挑战性。有时返回的错误代码是有帮助的，其他时候它们只是增加了混乱。</p><h2 id="7650" class="mi kx iq bd ky mp mq dn lc mr ms dp lg kj mt mu lk kn mv mw lo kr mx my ls mz bi translated">大多数API在某种程度上都有速率限制。</h2><p id="4974" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这意味着你只能在特定的时间段内(每天、每小时等)接到一定数量的电话。也许这就是你花钱所能得到的全部，或者也许他们减少了通话量以限制服务器的压力。即使通话没有费率限制，你也可能要为计量使用付费，这意味着你打的电话越多，花费就越多。</p><p id="d0a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在与第三方系统集成时，最好考虑如何减少这种交互。你真的需要在每次用户请求你的页面时都给他们打电话吗？你能缓存数据并减少刷新频率吗？</p><p id="abbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na">示例场景:</em>您的任务是在页面上显示一个twitter feed。每次显示该页面时，你都可以获取最新的推文。然而，如果页面在一天内被访问1000次，那就是1000次调用。如果你知道你的营销部门实际上一天只发布四条推文，那么更有效的方法是缓存内容，并且每两个小时调用一次API，只有在缓存过期的时候，这样每天调用4次而不是1000次。这可能意味着你有一个稍微过时的推文列表，但它更有效率和成本效益。</p><h1 id="8ce3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">本次讨论的一些关键要点</h1><ul class=""><li id="7f62" class="nb nc iq ka b kb lu kf lv kj nd kn ne kr nf kv ng nh ni nj bi translated">使用第三方API时，尽量找一个定期维护的官方库。</li><li id="eb7a" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">如果没有官方库，不要害怕自己写代码。</li><li id="44a1" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">您应该按照文档将API建模成可以在本地使用的类。</li><li id="3c27" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">您的RestClient将成为一个有价值的基础设施，您只需编写一次，就可以反复使用。</li><li id="9efa" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">当您无法控制第三方服务时，错误处理是必须的。</li><li id="20c5" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">练习缓存，尽可能减少API消耗。</li></ul><p id="b9d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这绝不是使用API的所有最佳实践，但希望它能帮助您入门。编码快乐！</p></div></div>    
</body>
</html>