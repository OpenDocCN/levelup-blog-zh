<html>
<head>
<title>Validation with Metaprogramming Decorators in Python — Advanced Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的元编程装饰器进行验证—高级Python</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/validations-in-python-using-metaprogramming-and-decorators-advanced-python-ee4d4278a6b3?source=collection_archive---------0-----------------------#2022-01-01">https://levelup.gitconnected.com/validations-in-python-using-metaprogramming-and-decorators-advanced-python-ee4d4278a6b3?source=collection_archive---------0-----------------------#2022-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8854734f4063ce8d6265e6321272d37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IqzHW2PG5R4JpcP0KoO1Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">作者:<a class="ae jg" href="https://www.artstation.com/dukson" rel="noopener ugc nofollow" target="_blank"> <em class="jh">杜克森</em> </a></figcaption></figure><div class=""/><p id="070d" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">装饰器是一种特殊类型的声明，可以应用于一个函数来改进它的功能。这也是<strong class="kj jl">元编程</strong>的一种类型。我们试图在编译时改变函数的功能。在任何编程语言中，元编程都是一个迷人的概念。它可用于在执行实际功能之前执行某些检查。<br/>让我们看一个例子来更好地理解用例。</p><p id="b497" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">假设我们有一个接受分子和分母的函数<a class="ae jg" href="https://en.wikipedia.org/wiki/Division_(mathematics)" rel="noopener ugc nofollow" target="_blank"> divide </a>。在这种情况下，分子和分母应该是实数。分子和分母不能为零。让我们将该功能付诸实施。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="b24b" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj jl">说明:</strong></p><p id="7107" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果您查看上面的示例函数，您会注意到我们添加了一些额外的检查来验证传递的参数。这些额外的检查可以通过元编程实现，而不需要修改实际的函数。</p><h2 id="2e3c" class="ll lm jk bd ln lo lp dn lq lr ls dp lt ks lu lv lw kw lx ly lz la ma mb mc md bi translated">你应该知道</h2><p id="3732" class="pw-post-body-paragraph kh ki jk kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">在继续之前，您应该了解一些概念。这些想法将有助于装饰者的理解。</p><ol class=""><li id="4b23" class="mj mk jk kj b kk kl ko kp ks ml kw mm la mn le mo mp mq mr bi translated">一切都是事物。</li><li id="e965" class="mj mk jk kj b kk ms ko mt ks mu kw mv la mw le mo mp mq mr bi translated">该类是可调用的。</li></ol><p id="79e7" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj jl">在Python中一切都是对象</strong> : Python把一切都当作对象。是的，类也是一个对象。一个名字可以与多个变量相关联，包括函数。考虑下面的例子。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="cdb9" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们也可以将函数作为参数传递并使用该函数。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="2a17" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">一个函数也可以返回另一个函数。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="d053" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj jl">类是可调用的:</strong>你可以通过添加<code class="fe mx my mz na b"><strong class="kj jl">def</strong> <strong class="kj jl">__call__</strong>(self, *args, **kwargs)</code>函数使类成为可调用的对象。可调用对象是一个对象，但可以被称为函数。当我们执行或调用可调用对象时，它会在内部调用方法<code class="fe mx my mz na b"><strong class="kj jl">__call__</strong></code></p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="dc06" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">既然我们已经讨论了基础知识，让我们看看装饰者。</p><h2 id="21c3" class="ll lm jk bd ln lo lp dn lq lr ls dp lt ks lu lv lw kw lx ly lz la ma mb mc md bi translated">使用功能的装饰者</h2><p id="7da4" class="pw-post-body-paragraph kh ki jk kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">装饰函数是只有一个参数的函数。它将一个函数作为参数，并返回一个帮助函数。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="be6d" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">从上面的例子中可以看出，<strong class="kj jl">装饰器</strong>函数将<strong class="kj jl"> func </strong>作为函数，并添加前/后语句。一个<strong class="kj jl">装饰器</strong>功能可以使用<code class="fe mx my mz na b">@decorator</code>表达式来实现。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="4bca" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你也可以返回一个接受<strong class="kj jl">变量</strong>作为参数<strong class="kj jl">的函数。</strong>这对于覆盖功能行为非常有用，但仍能提供充分的灵活性。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><h2 id="87f3" class="ll lm jk bd ln lo lp dn lq lr ls dp lt ks lu lv lw kw lx ly lz la ma mb mc md bi translated"><strong class="ak">装修工使用类</strong></h2><p id="6f75" class="pw-post-body-paragraph kh ki jk kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated">可以像创建函数装饰器一样创建可调用的对象装饰器。与函数式装饰器相比，创建基于类的装饰器的主要优点是它看起来更具声明性和更简洁。</p><p id="1119" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">为了更好地理解这个概念，让我们回到前面的<strong class="kj jl">加法</strong>和<strong class="kj jl">除法</strong>函数的例子。您可能已经注意到，它们都是实数的通用验证。我们可以创建一个通用的验证器装饰类。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="8847" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在我们有两个参数验证器。让我们把这个用在实函数上。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="d1a1" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当您查看函数时，您会注意到它们比以前的版本要干净得多。</p><h2 id="0edc" class="ll lm jk bd ln lo lp dn lq lr ls dp lt ks lu lv lw kw lx ly lz la ma mb mc md bi translated">结论</h2><p id="1f5f" class="pw-post-body-paragraph kh ki jk kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le im bi translated"><strong class="kj jl">装饰师</strong>涉及的话题很广。我刚刚接触到水面。作为一个例子，考虑装饰者的<strong class="kj jl">链接。这对于共享和应用可重用验证非常有用。跟踪函数调用、窥探函数调用、编写自定义解析器等等都是元编程的常见应用。你可以调查一下，让我知道你在评论里发现了什么。</strong></p><h2 id="2e5d" class="ll lm jk bd ln lo lp dn lq lr ls dp lt ks lu lv lw kw lx ly lz la ma mb mc md bi translated">参考资料:</h2><ul class=""><li id="1ebc" class="mj mk jk kj b kk me ko mf ks nb kw nc la nd le ne mp mq mr bi translated"><a class="ae jg" href="https://python-course.eu/advanced-python/decorators-decoration.php" rel="noopener ugc nofollow" target="_blank">https://python-course . eu/advanced-python/decorators-decoration . PHP</a></li><li id="b50b" class="mj mk jk kj b kk ms ko mt ks mu kw mv la mw le ne mp mq mr bi translated"><a class="ae jg" href="https://realpython.com/python-metaclasses" rel="noopener ugc nofollow" target="_blank">https://realpython.com/python-metaclasses</a></li></ul></div></div>    
</body>
</html>