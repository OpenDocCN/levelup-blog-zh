<html>
<head>
<title>Let’s Write a Simple Event Bus in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们在Go中编写一个简单的事件总线</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-write-a-simple-event-bus-in-go-79b9480d8997?source=collection_archive---------0-----------------------#2019-03-12">https://levelup.gitconnected.com/lets-write-a-simple-event-bus-in-go-79b9480d8997?source=collection_archive---------0-----------------------#2019-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d34db9a8d39e52c4ae4808288a65d0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbPOa9BQUaf7qHQyBLLR0g.png"/></div></div></figure><p id="67f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">事件驱动架构是计算机科学中高度可扩展的范例。它允许我们通过多方异步处理事件。</p><p id="af0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事件总线是<a class="ae lf" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布/订阅模式</a>的一个实现，发布者发布数据，感兴趣的订阅者可以监听它们并根据数据采取行动。这允许发布者和订阅者的松散耦合。发布者将数据事件发布到事件总线，总线负责将它们传递给订阅者。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/0f872c952895aef703a4f07f029206b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*6jeHWE0f2Mgd2CWJLTAZjg.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">活动巴士</figcaption></figure><p id="cc9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现事件总线的传统方法包括使用回调。订户通常实现一个接口，然后事件总线通过该接口传播数据。</p><p id="bc23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过go的并发模型，我们知道通道可以在大多数地方用来代替回调。在本文中，我们关注如何使用通道来实现事件总线。</p><blockquote class="lp lq lr"><p id="1275" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated">我们关注基于<strong class="ka ir">主题的事件</strong>。发布者发布主题，订阅者可以收听。</p></blockquote><h1 id="a63e" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">定义数据结构</h1><p id="1105" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">对于这个任务，我们需要定义要传递的数据结构。我们可以简单地使用<code class="fe mz na nb nc b">struct</code>创建一个新的数据类型。让我们如下定义一个<code class="fe mz na nb nc b">DataEvent</code>结构:</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="b37d" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">type </strong>DataEvent <strong class="nc ir">struct </strong>{<br/>   Data <strong class="nc ir">interface</strong>{}<br/>   Topic string<br/>}</span></pre><p id="9e70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们将底层数据定义为一个接口，这意味着它可以是任何值。此外，我们还将主题定义为结构的成员。您的订户可能会收听不止一个主题。因此，传递主题是一个好的做法，这样订阅者就可以区分事件。</p><h1 id="d6b2" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">介绍渠道</h1><p id="b214" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">现在我们已经为任务定义了主要的数据结构，我们需要一种方法来传递它。为此，我们可以定义一个能够传播一个<code class="fe mz na nb nc b">DataEvent</code>的<code class="fe mz na nb nc b">DataChannel</code>。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="e836" class="nh lx iq nc b gy ni nj l nk nl"><em class="ls">// DataChannel is a channel which can accept an DataEvent<br/></em><strong class="nc ir">type </strong>DataChannel <strong class="nc ir">chan </strong>DataEvent</span><span id="12aa" class="nh lx iq nc b gy nm nj l nk nl"><em class="ls">// DataChannelSlice is a slice of DataChannels<br/></em><strong class="nc ir">type </strong>DataChannelSlice [] DataChannel</span></pre><p id="91db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mz na nb nc b">DataChannelSlice</code>是为了保存一部分频道并方便引用而创建的。</p><h1 id="3211" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">事件总线</h1><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="520a" class="nh lx iq nc b gy ni nj l nk nl"><em class="ls">// EventBus stores the information about subscribers interested for // a particular topic<br/></em><strong class="nc ir">type </strong>EventBus <strong class="nc ir">struct </strong>{<br/>   subscribers <strong class="nc ir">map</strong>[string]DataChannelSlice<br/>   rm sync.RWMutex<br/>}</span></pre><p id="981f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mz na nb nc b">EventBus</code>有<code class="fe mz na nb nc b">subscribers</code>是保存<code class="fe mz na nb nc b">DataChannelSlices</code>的地图。我们使用了一个<code class="fe mz na nb nc b">mutex</code>来保护它免受读写并发访问。</p><p id="b79b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用一个<code class="fe mz na nb nc b">map</code>并定义<code class="fe mz na nb nc b">topics</code>，它允许我们轻松地组织事件。主题被视为地图中的一个键。当有人发布到它时，我们可以很容易地通过关键字找到主题，然后将事件传播到通道进行进一步处理。</p><h1 id="4117" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">订阅主题</h1><p id="d57a" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">为了订阅主题，使用通道。它的作用类似于传统方法中的回调。当发布者将数据发布到主题时，通道将接收数据。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="e8fe" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">func </strong>(eb *EventBus)Subscribe(topic string, ch DataChannel)  {<br/>   eb.rm.Lock()<br/>   <strong class="nc ir">if </strong>prev, found := eb.subscribers[topic]; found {<br/>      eb.subscribers[topic] = append(prev, ch)<br/>   } <strong class="nc ir">else </strong>{<br/>      eb.subscribers[topic] = append([]DataChannel{}, ch)<br/>   }<br/>   eb.rm.Unlock()<br/>}</span></pre><p id="c756" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单地说，我们将订户附加到通道片，并在操作后锁定结构和解锁它。</p><h1 id="7970" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">发布到主题</h1><p id="2049" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">要发布事件，发布者需要为订阅者提供需要广播的主题和数据。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="14ed" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">func </strong>(eb *EventBus) Publish(topic string, data <strong class="nc ir">interface</strong>{}) {<br/>   eb.rm.RLock()<br/>   <strong class="nc ir">if </strong>chans, found := eb.subscribers[topic]; found {<br/>      <em class="ls">// this is done because the slices refer to same array even though they are passed by value<br/>      // thus we are creating a new slice with our elements thus preserve locking correctly.<br/>      </em>channels := append(DataChannelSlice{}, chans...)<br/>      <strong class="nc ir">go func</strong>(data DataEvent, dataChannelSlices DataChannelSlice) {<br/>         <strong class="nc ir">for </strong>_, ch := <strong class="nc ir">range </strong>dataChannelSlices {<br/>            ch &lt;- data<br/>         }<br/>      }(DataEvent{Data: data, Topic: topic}, channels)<br/>   }<br/>   eb.rm.RUnlock()<br/>}</span></pre><p id="10f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个方法中，首先我们检查是否有任何订阅者存在于这个主题中。然后，我们只需简单地遍历与主题相关联的通道片段并发布它。</p><blockquote class="lp lq lr"><p id="a68f" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated">请注意，我们在publish方法中使用了goroutine来避免阻塞发布者</p></blockquote><h1 id="e74a" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">让我们试试吧</h1><p id="f4af" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">首先，我们需要创建事件总线的一个实例。在一个真实的场景中，你可以从包<strong class="ka ir">中导出一个单独的<code class="fe mz na nb nc b">EventBus</code>，让它表现得像一个单独的</strong>。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="3201" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">var </strong>eb = &amp;EventBus{<br/>   subscribers: <strong class="nc ir">map</strong>[string]DataChannelSlice{},<br/>}</span></pre><p id="2645" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试新创建的事件总线，我们将创建一个以随机间隔发布给定主题的方法</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="2fce" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">func </strong>publisTo(topic string, data string)  {<br/>   <strong class="nc ir">for </strong>{<br/>      eb.Publish(topic, data)<br/>      time.Sleep(time.Duration(rand.Intn(1000)) * time.<strong class="nc ir"><em class="ls">Millisecond</em></strong>)<br/>   }<br/>}</span></pre><p id="9a2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要一个可以监听主题的主函数。它使用一个助手方法来打印事件数据。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="20ed" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">func </strong>printDataEvent(ch string, data DataEvent)  {<br/>   fmt.Printf(<strong class="nc ir">"Channel: %s; Topic: %s; DataEvent: %v\n"</strong>, ch, data.Topic, data.Data)<br/>}</span><span id="4492" class="nh lx iq nc b gy nm nj l nk nl"><strong class="nc ir">func </strong>main()  {<br/>   ch1 := make(<strong class="nc ir">chan </strong>DataEvent)<br/>   ch2 := make(<strong class="nc ir">chan </strong>DataEvent)<br/>   ch3 := make(<strong class="nc ir">chan </strong>DataEvent)</span><span id="3f4d" class="nh lx iq nc b gy nm nj l nk nl">   eb.Subscribe(<strong class="nc ir">"topic1"</strong>, ch1)<br/>   eb.Subscribe(<strong class="nc ir">"topic2"</strong>, ch2)<br/>   eb.Subscribe(<strong class="nc ir">"topic2"</strong>, ch3)</span><span id="0be8" class="nh lx iq nc b gy nm nj l nk nl">   <strong class="nc ir">go </strong>publisTo(<strong class="nc ir">"topic1"</strong>, <strong class="nc ir">"Hi topic 1"</strong>)<br/>   <strong class="nc ir">go </strong>publisTo(<strong class="nc ir">"topic2"</strong>, <strong class="nc ir">"Welcome to topic 2"</strong>)</span><span id="bebc" class="nh lx iq nc b gy nm nj l nk nl">   <strong class="nc ir">for </strong>{<br/>      <strong class="nc ir">select </strong>{<br/>      <strong class="nc ir">case </strong>d := &lt;-ch1:<br/>         <strong class="nc ir">go </strong>printDataEvent(<strong class="nc ir">"ch1"</strong>, d)<br/>      <strong class="nc ir">case </strong>d := &lt;-ch2:<br/>         <strong class="nc ir">go </strong>printDataEvent(<strong class="nc ir">"ch2"</strong>, d)<br/>      <strong class="nc ir">case </strong>d := &lt;-ch3:<br/>         <strong class="nc ir">go </strong>printDataEvent(<strong class="nc ir">"ch3"</strong>, d)<br/>      }<br/>   }<br/>}</span></pre><p id="da76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经创建了三个可以订阅主题的频道。其中两个ch2和ch3监听相同的事件。</p><p id="cafc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用select语句从最快的通道获取数据。然后它使用另一个goroutine来打印输出数据。这完全没有必要。但在某些情况下，您必须对事件进行一些繁重的操作。为了防止阻塞select，我们使用了goroutine。</p><p id="4ac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例输出将如下所示</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="92c8" class="nh lx iq nc b gy ni nj l nk nl">Channel: ch1; Topic: topic1; DataEvent: Hi topic 1<br/>Channel: ch2; Topic: topic2; DataEvent: Welcome to topic 2<br/>Channel: ch3; Topic: topic2; DataEvent: Welcome to topic 2<br/>Channel: ch3; Topic: topic2; DataEvent: Welcome to topic 2<br/>Channel: ch2; Topic: topic2; DataEvent: Welcome to topic 2<br/>Channel: ch1; Topic: topic1; DataEvent: Hi topic 1<br/>Channel: ch3; Topic: topic2; DataEvent: Welcome to topic 2<br/>...</span></pre><p id="0381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到事件总线通过通道传递事件。</p><p id="9ded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于事件总线的简单通道的源代码。</p><h1 id="67b8" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">完全码</h1><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">事件总线的完整代码</figcaption></figure><h1 id="5740" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">那么，为什么要用通道而不是回调呢？</h1><p id="1c16" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">传统的回调方式需要你实现某种接口。</p><p id="005e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举个例子，</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="5886" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">type </strong>Subscriber <strong class="nc ir">interface </strong>{<br/>   onData(event Event)<br/>}</span></pre><p id="35d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果您想订阅一个事件，您需要实现接口，以便事件总线可以传播它。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="ecdc" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">type </strong>MySubscriber <strong class="nc ir">struct </strong>{<br/>}</span><span id="19bf" class="nh lx iq nc b gy nm nj l nk nl"><strong class="nc ir">func </strong>(m MySubscriber) onData(event Event)  {<br/>   // do anything with event<br/>}</span></pre><p id="d2ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通道方法允许您在一个简单的函数中简单地注册一个订户，而不需要接口。</p><pre class="lh li lj lk gt nd nc ne nf aw ng bi"><span id="f303" class="nh lx iq nc b gy ni nj l nk nl"><strong class="nc ir">func </strong>main() {<br/>   ch1 := make(<strong class="nc ir">chan </strong>DataEvent)<br/>   eb.Subscribe(<strong class="nc ir">"topic1"</strong>, ch1)<br/>   fmt.Println((&lt;-ch1).Data)<br/>   ...<em class="ls"><br/></em>}</span></pre><h1 id="5e5d" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结论</h1><p id="cfff" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">本文的目标是指出编写事件总线的不同范例。</p><blockquote class="lp lq lr"><p id="1d50" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated">这可能不是理想的解决方案。</p></blockquote><p id="b3d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，频道被封锁，直到有人消费它们。它们有局限性。</p><blockquote class="lp lq lr"><p id="9f23" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated">我使用了一个片来存储一个主题的所有订阅者。这是用来简化文章的。这需要用一个<strong class="ka ir">集合</strong>来替换，这样列表中就不会出现重复的条目</p></blockquote><p id="f1fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传统的回调方法可以通过使用提供的相同机制来简单地实现。您可以很容易地在goroutine中实现异步包装发布。</p><p id="7389" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我很想听听你对这篇文章的看法。:)</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><figure class="lh li lj lk gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nw"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="nx ny gp gr nz oa"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">学习围棋-最佳围棋教程(2019) | gitconnected</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">23大围棋教程-免费学习围棋。课程由开发者提交和投票，使您能够找到…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">gitconnected.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo jw oa"/></div></div></a></div></div></div>    
</body>
</html>