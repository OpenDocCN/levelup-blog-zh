# C#中的泛型

> 原文：<https://levelup.gitconnected.com/generics-in-c-e650ccc8551c>

## 通过创建一个泛型 API 类来学习泛型

![](img/7cf361e270bde2f689fa4b0381995b0f.png)

卡里·谢伊在 [Unsplash](https://unsplash.com/photos/1SAnrIxw5OY) 上的照片

## 问题是

假设我们正在构建微服务，我们已经创建了一个共享文件夹，因此我们可以为所有现有的微服务创建一个 API 类，当我们想要在不同的服务之间进行通信时，可以调用该类。请查看下面的示例。

这些可能是每个微服务将拥有的基本 API，我们并不真正关心特定于任务的 API，因为它们将是特定于微服务的。

那么如果我们有 20 个或者更多的微服务会怎么样呢？我们需要编写 25-30 行代码，唯一的区别是进出的有效负载，以及路由中服务的名称。那种打破干(不重复自己)原则背后的想法。

[](https://medium.com/codex/become-a-better-programmer-with-these-software-engineering-principles-204fa93e8094) [## 用这些软件工程原则成为更好的程序员

### 干，吻，YAGNI 解释道

medium.com](https://medium.com/codex/become-a-better-programmer-with-these-software-engineering-principles-204fa93e8094) 

## 系统。目标解决方案

我们能想到的第一个解决方案是使用 C#中的 Object 类，并想办法使路线中的“客户”动态化。但是我们不会这么做，因为系统。对象在这里不是最优解。它所做的是装箱一个值类型，将它放入一个对象中，并存储在托管堆中。然而，这会导致一些性能问题，并使泛型更快更好地使用，所以让我们看看如何用它们来解决我们的问题。

## 什么是泛型

*Generic* 是一个允许用户用占位符定义类和方法的类。使用泛型背后的思想是允许类型作为方法、类和接口的参数。

## 使用泛型的解决方案

这就是我们的 *BaseApi* 类的样子，我们现在需要做的就是重构我们的 *CustomerAPI* 来实现我们的新类。

正如你在第一行看到的，我们正在指定我们想要被传递的类型，它们对于你拥有的其他服务可以是不同的(OrderPayload，AddressPayload 等)。).在构造函数中，我们还传递控制器名称，这样我们就知道我们调用的是哪个微服务，我们可以删除以前在 *CustomerApi 中的所有 CRUD APIs。*

现在，我们可以调用任何我们想要的微服务，并简单地调用我们的 *BaseApi* 中的任何函数，而不必编写许多行可重复的代码。

## 结论

泛型是 C#中最强大的特性之一。它们允许您定义类型安全的数据结构。这将带来更好性能和更高的代码质量，因为它有助于重用代码。它们也比*系统要好。Object* 选项，因为它们不会给我们带来性能损失，而且是. NET 开发人员必须了解。