<html>
<head>
<title>Enhance React Performance with Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过记忆增强反应性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enhance-react-performance-with-memoization-fb49f11ada4f?source=collection_archive---------5-----------------------#2022-01-04">https://levelup.gitconnected.com/enhance-react-performance-with-memoization-fb49f11ada4f?source=collection_archive---------5-----------------------#2022-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/90266ccc981d121c77cb3d49ae8abfd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lXCMykdWnTspQ5nJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="3617" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi li translated">这是我在Medium上发表的第一篇文章，近两年来，我一直在思考这篇文章的内容。它并不是covid的解药，也不是一些谈论生命意义的具体抽象的故事，而是我已经决定与你分享我作为一名软件工程师的学习和经验。一个自学成才的开发人员的旅程经常是孤独和令人沮丧的，我想通过分享这一行为多少让我感到与他人有联系。所以让我们一起成长吧😁</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="dc9f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">介绍</h1><p id="919e" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">React是一个前端Javascript库，允许无缝创建基于组件的单页面应用程序(spa)。作为2022年的web开发人员，很可能我们已经使用过React，或者至少在职业生涯的某个时候听说过它。如果你对React的体验和我一样，就很容易掌握一些基础知识，比如用<code class="fe mu mv mw mx b">useState</code>控制状态，或者用<code class="fe mu mv mw mx b">useEffect</code>管理副作用。然而，很快你就意识到，除了基本的React之外，世界是广阔的，如果我们想要构建高性能的web应用程序，特别是对于数据密集型用例，我们必须振作起来，开始像真正的软件工程师一样思考。因此，了解正确的工具对于提高React应用程序的性能至关重要。</p><p id="75d9" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">今天，我想和大家分享一些我一路走来学到的技巧，特别是如何使用<strong class="km ir">内存化</strong>来增强React应用程序。我们将从快速复习以下概念开始:</p><ul class=""><li id="d5b1" class="my mz iq km b kn ko kr ks kv na kz nb ld nc lh nd ne nf ng bi translated">记忆化</li><li id="7b30" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh nd ne nf ng bi translated">对组件功能重估做出反应</li></ul><p id="8d27" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">掌握了上述知识后，我们将看看如何使用以下工具在React中实现它:</p><ul class=""><li id="2a15" class="my mz iq km b kn ko kr ks kv na kz nb ld nc lh nd ne nf ng bi translated"><code class="fe mu mv mw mx b">React.memo()</code></li><li id="fa92" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh nd ne nf ng bi translated"><code class="fe mu mv mw mx b">useCallback()</code></li><li id="9d84" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh nd ne nf ng bi translated"><code class="fe mu mv mw mx b">useMemo()</code></li></ul><h1 id="7f80" class="lr ls iq bd lt lu nm lw lx ly nn ma mb mc no me mf mg np mi mj mk nq mm mn mo bi translated">记忆化</h1><p id="a271" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">记忆化只是缓存的一个花哨词。这是动态编程中广泛使用的代码优化概念。你可以在这里找到官方解释<a class="ae kc" href="https://en.wikipedia.org/wiki/Memoization#:~:text=In%20computing%2C%20memoization%20or%20memoisation,the%20same%20inputs%20occur%20again." rel="noopener ugc nofollow" target="_blank">，然而，在我们深入研究代码之前，这里有一个简短的定义:</a></p><p id="af51" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><em class="nr">记忆化是一种优化技术，它使用缓存来存储直接映射到生成这些结果的函数的输入的结果。当使用以前看到的输入调用函数时，缓存被用来直接返回结果，而不是运行计算，因此加快了函数的执行。</em></p><p id="a93a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">下面的代码用一个简单的场景和一些基准测试结果演示了Javascript中的记忆化。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><ol class=""><li id="80e2" class="my mz iq km b kn ko kr ks kv na kz nb ld nc lh ny ne nf ng bi translated">生成一个由0-10之间的1000万个随机数组成的数组，用于测试目的。这是全局定义的，在以下函数中用作测试数据。</li><li id="2e95" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh ny ne nf ng bi translated">为基准功能设置一些测试指标。</li><li id="99da" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh ny ne nf ng bi translated">简单的函数，将索引<code class="fe mu mv mw mx b">n</code>中<code class="fe mu mv mw mx b">data</code>的所有数字相加。</li><li id="89f8" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh ny ne nf ng bi translated">基准<code class="fe mu mv mw mx b">sumNumbersFrom</code>带输出:<code class="fe mu mv mw mx b">Result: 45004814; Duration: 75ms</code>。</li><li id="4b3d" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh ny ne nf ng bi translated">包装函数<code class="fe mu mv mw mx b">memoizeFunc</code>，用于产生其输入函数<code class="fe mu mv mw mx b">originalFunc</code>的记忆版本。包装器建立一个缓存<code class="fe mu mv mw mx b">cache</code>，该缓存由返回的内存化函数通过其<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>保留。返回的函数还带有一个参数<code class="fe mu mv mw mx b">input</code>，该参数应该与<code class="fe mu mv mw mx b">originalFunc</code>所需的输入相同。首先检查<code class="fe mu mv mw mx b">cache</code>以查看<code class="fe mu mv mw mx b">input</code>是否已被预先存储，如果没有，则使用<code class="fe mu mv mw mx b">originalFunc</code>根据<code class="fe mu mv mw mx b">input</code>计算结果，然后将结果存储在<code class="fe mu mv mw mx b">cache</code>中。如果在<code class="fe mu mv mw mx b">cache</code>中找到<code class="fe mu mv mw mx b">input</code>，则直接返回其相关结果，而不调用<code class="fe mu mv mw mx b">originalFunc</code>导致<code class="fe mu mv mw mx b">O(1)</code>操作。</li><li id="0339" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh ny ne nf ng bi translated">包装函数<code class="fe mu mv mw mx b">memoizeFunc</code>应用于<code class="fe mu mv mw mx b">sumNumbersFrom</code>以创建其记忆计数器部件<code class="fe mu mv mw mx b">memoizedSumNumberFrom</code>。</li><li id="e2eb" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh ny ne nf ng bi translated">当结果未缓存和缓存(对于输入= 100)时，对两种场景的<code class="fe mu mv mw mx b">memoizedSumNumberFrom</code>执行进行基准测试。我们看到，在结果未被缓存的实例中，函数花费了<code class="fe mu mv mw mx b">75ms</code>来运行，因为原始的<code class="fe mu mv mw mx b">sumNumbersFrom</code>必须被调用来计算结果。然而，当第二次将相同的输入100传递给<code class="fe mu mv mw mx b">memoizedSumNumberFrom</code>时，缓存的结果立即返回，导致<code class="fe mu mv mw mx b">0ms</code>执行时间。</li></ol><p id="8e4e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">从上面的例子中，我们可以看到记忆化是一种优化函数时间复杂度的巧妙技术。在这一点上我们应该注意，React中的组件实际上只是函数，记忆化非常适合于提高React应用程序的渲染速度。同样重要的是要注意，记忆化是以存储缓存的内存和将函数输入转换为缓存的键所需的计算为代价的。因此，我们应该考虑为计算密集型问题实现这种优化，而不是我们遇到的每个小任务！</p><h1 id="6baa" class="lr ls iq bd lt lu nm lw lx ly nn ma mb mc no me mf mg np mi mj mk nq mm mn mo bi translated">反应组件评估</h1><p id="2846" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">在本节中，我们将了解为什么需要优化，特别是对于React如何评估组件功能以及它们在应用程序中的子组件。</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/c538fcfae6a1acdd72f21f11d1b08a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFhDn1D3yxSPq3WBCqDRug.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图React应用程序结构示例</figcaption></figure><p id="a204" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">上图描绘了一个非常简单的React应用程序层次结构，每个模块都是一个组件，它们以树状结构设置。实现上述结构的关键方面是:</p><blockquote class="oa ob oc"><p id="df1e" class="kk kl nr km b kn ko kp kq kr ks kt ku od kw kx ky oe la lb lc of le lf lg lh ij bi translated">当在组件中注册了状态、属性或上下文变化时，React将评估/重新评估组件。</p><p id="4f84" class="kk kl nr km b kn ko kp kq kr ks kt ku od kw kx ky oe la lb lc of le lf lg lh ij bi translated">当React评估一个组件函数时，它的所有子组件都将被评估，不管该组件与其子组件之间存在任何依赖关系。简而言之，React并不关心<code class="fe mu mv mw mx b">Child 1</code>是否依赖于<code class="fe mu mv mw mx b">Parent</code>中的任何状态变化，只要<code class="fe mu mv mw mx b">Parent</code>被求值，那么<code class="fe mu mv mw mx b">Child 1</code>就会被求值。对于<code class="fe mu mv mw mx b">Child 2</code>和<code class="fe mu mv mw mx b">Child 3</code>也是如此。</p></blockquote><p id="1dcf" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了演示上述概念，我使用<a class="ae kc" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建了一个简单的应用程序，代码可以在这里访问<a class="ae kc" href="https://github.com/MasWho/medium-blog/tree/master/react-memo" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><blockquote class="oa ob oc"><p id="4726" class="kk kl nr km b kn ko kp kq kr ks kt ku od kw kx ky oe la lb lc of le lf lg lh ij bi translated">注意:在本文中，我将只讨论应用程序的相关代码部分。假设对提高React性能感兴趣的每个人都熟悉如何设置React项目。但是，如果您想复习一下如何设置React项目，主应用程序组件如何工作以及如何在DOM中呈现，请参考上面提供的代码链接。</p></blockquote><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6463bfb79a80676929bf2ba133c6c689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8iZCk1YWZkhpEGhLhhJGrA.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图2<code class="fe mu mv mw mx b">Revaluation</code>组件的浏览器控制台输出</figcaption></figure><p id="2889" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">上面的React代码使用了一个<code class="fe mu mv mw mx b">Revaluation</code>父组件来演示图1所示的结构，父组件包含三个子组件<code class="fe mu mv mw mx b">Child1</code>、<code class="fe mu mv mw mx b">Child2</code>和<code class="fe mu mv mw mx b">Child3</code>，其中<code class="fe mu mv mw mx b">Child2</code>嵌套在<code class="fe mu mv mw mx b">Child1</code>中。<code class="fe mu mv mw mx b">Revaluation</code>组件包含一个布尔状态<code class="fe mu mv mw mx b">toggle</code>，可由<code class="fe mu mv mw mx b">toggleHandler</code>更新。</p><p id="e68d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这里需要注意的是，改变<code class="fe mu mv mw mx b">toggle</code>状态将触发对<code class="fe mu mv mw mx b">Revaluation</code>组件及其所有子组件的重新评估。此外，<code class="fe mu mv mw mx b">Child1</code>、<code class="fe mu mv mw mx b">Child2</code>或<code class="fe mu mv mw mx b">Child3</code>都不依赖于<code class="fe mu mv mw mx b">Revaluation</code>中的状态变化。以<code class="fe mu mv mw mx b">Child1</code>为例，它接收一个硬连线到<code class="fe mu mv mw mx b">false</code>的<code class="fe mu mv mw mx b">show</code>道具，但图2所示的控制台输出清楚地表明，每次<code class="fe mu mv mw mx b">Revaluation</code>中的状态改变时<code class="fe mu mv mw mx b">Child1</code>都会被重新评估。对于<code class="fe mu mv mw mx b">Child2</code>和<code class="fe mu mv mw mx b">Child3</code>也可以说是同样的观察结果，即这些子组件中的逻辑与其父组件中的逻辑无关。</p><p id="51cc" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我希望此时您已经意识到，本节的示例展示了React应用程序中潜在的性能瓶颈。在现实世界中，<code class="fe mu mv mw mx b">Child1</code>、<code class="fe mu mv mw mx b">Child2</code>或<code class="fe mu mv mw mx b">Child3</code>可能包含计算密集型逻辑。每次由于不相关的父组件状态更新而重新评估这些子组件是浪费的。</p><p id="ba9d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这就是记忆化的作用。如前一节所述，我们可以使用这种优化技术来缓存基于输入的函数返回的结果。React应用程序可以使用内存化来加速，因为它们只不过是一堆嵌套在树状结构中的函数！</p><h1 id="f062" class="lr ls iq bd lt lu nm lw lx ly nn ma mb mc no me mf mg np mi mj mk nq mm mn mo bi translated">React .备忘录</h1><p id="4876" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">我们将讨论的第一个工具是<code class="fe mu mv mw mx b">React.memo</code>。它是一个高阶组件(HOC ),用于封装任何反应功能组件以进行记忆。下面的代码演示了它的用法。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a31786e74df28e45fd366071239a0a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*pOpM3kjuDRJwVgUocAg7JA.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图MemoExample组件的浏览器控制台输出</figcaption></figure><p id="f524" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这个例子由一个父组件<code class="fe mu mv mw mx b">MemoExample</code>和一个状态<code class="fe mu mv mw mx b">toggle</code>组成，父组件只包含一个子组件<code class="fe mu mv mw mx b">Child1</code>，状态<code class="fe mu mv mw mx b">toggle</code>可以被<code class="fe mu mv mw mx b">toggleHandler</code>更新。</p><p id="bd01" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">此外，我们将<code class="fe mu mv mw mx b">Child1</code>封装在<code class="fe mu mv mw mx b">React.memo</code>调用中，以便在DOM中第一次呈现子组件时对其进行记忆，也就是说，React为<code class="fe mu mv mw mx b">Child1</code>输出的html语法树现在缓存在内存中并映射到它的props。对于在<code class="fe mu mv mw mx b">MemoExample</code>中注册的每个后续状态更新，React检查<code class="fe mu mv mw mx b">Child1</code>属性是否有任何变化，如果没有发生变化，则将呈现<code class="fe mu mv mw mx b">Child1</code>的缓存输出，而不是再次评估组件。由于<code class="fe mu mv mw mx b">Child1</code>只接受一个道具<code class="fe mu mv mw mx b">show</code>并且我们已经将其硬连线到<code class="fe mu mv mw mx b">false</code>，这意味着<code class="fe mu mv mw mx b">Child1</code>在第一次渲染后将不再被评估，不管<code class="fe mu mv mw mx b">MemoExample</code>中的任何状态变化。这种行为可以在图3所示的控制台输出中看到，其中<code class="fe mu mv mw mx b">Child1</code>中的<code class="fe mu mv mw mx b">console.log</code>仅运行一次，并且对于<code class="fe mu mv mw mx b">MemoExample</code>中的<code class="fe mu mv mw mx b">toggle</code>状态的每一次后续变化都不会再次运行。</p><p id="9e86" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这一点上，我知道你在想什么，为什么我们不把<code class="fe mu mv mw mx b">React.memo</code>应用到太阳底下曾经存在过的每一个组件上呢？嗯，还记得前面提到的记忆是有成本的吗？让我们快速检查一下<code class="fe mu mv mw mx b">React.memo</code>的一些警告，以便理解为什么总是使用它实际上是一个坏主意:</p><ul class=""><li id="c208" class="my mz iq km b kn ko kr ks kv na kz nb ld nc lh nd ne nf ng bi translated">记忆一个React组件需要消耗内存，因为我们需要缓存该组件的渲染结果和道具。</li><li id="e42e" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh nd ne nf ng bi translated">仅检查props更改，因此对于内部状态更改，仍将评估包装的组件。</li><li id="5158" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh nd ne nf ng bi translated">默认情况下，<code class="fe mu mv mw mx b">React.memo</code>的props检查是一种浅层比较，这意味着只有原始数据类型(字符串、布尔值和数字)的变化才会被正确注册，因为更复杂的数据类型，如数组、对象甚至函数都是<a class="ae kc" href="https://www.dyn-web.com/javascript/arrays/value-vs-reference.php" rel="noopener ugc nofollow" target="_blank">引用类型</a>。为了克服浅层比较默认，我们可以将一个<a class="ae kc" href="https://reactjs.org/docs/react-api.html" rel="noopener ugc nofollow" target="_blank">比较函数</a>作为第二个参数传递给<code class="fe mu mv mw mx b">React.memo</code>来告诉React应该如何准确地比较道具。</li><li id="0ff0" class="my mz iq km b kn nh kr ni kv nj kz nk ld nl lh nd ne nf ng bi translated">如果组件的props包含大量数据，比较成本和内存成本可能会变得无法使用<code class="fe mu mv mw mx b">React.memo</code>。应该仔细考虑加速应用程序的这些权衡。</li></ul><h1 id="12f2" class="lr ls iq bd lt lu nm lw lx ly nn ma mb mc no me mf mg np mi mj mk nq mm mn mo bi translated">使用回调</h1><p id="322b" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">在我们继续学习React中的下一个记忆工具之前，让我们先解决上一节中提到的一个细节。当在带有复杂数据类型属性的组件上使用<code class="fe mu mv mw mx b">React.memo</code>时，我们需要解决浅层比较默认行为。对于对象和数组，我们可以使用比较函数<code class="fe mu mv mw mx b">React.memo</code>的第二个参数输入，但是如果一个prop是一个函数呢？在Javascript中，函数是与对象和数组相同的引用数据类型，因此函数的浅层比较总是会导致错误的返回。下面的例子演示了<code class="fe mu mv mw mx b">React.memo</code>用于带有功能属性的组件时的行为。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5851eb480ac2d3dd39877e37b507ed6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*92MWJwxFucuk-vpQKrZZxA.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图4带有功能属性的MemoAndCallback组件的浏览器控制台输出</figcaption></figure><p id="0c62" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">上面的<code class="fe mu mv mw mx b">MemoAndCallback</code>组件是上一节的<code class="fe mu mv mw mx b">MemoExample</code>组件的简单扩展。添加了一个<code class="fe mu mv mw mx b">Child2</code>组件，该组件接受一个函数属性<code class="fe mu mv mw mx b">func</code>，每当渲染<code class="fe mu mv mw mx b">Child2</code>时都会调用该属性。请注意，<code class="fe mu mv mw mx b">Child2</code>被包装在一个<code class="fe mu mv mw mx b">React.memo</code>调用中，但是正如我们从图4的控制台输出中可以看到的，对于<code class="fe mu mv mw mx b">MemoAndCallback</code>中的每个状态更新，<code class="fe mu mv mw mx b">Child2</code>都被呈现。这是因为函数<code class="fe mu mv mw mx b">child2Func</code>是为<code class="fe mu mv mw mx b">MemoAndCallback</code>的每次渲染而声明的，导致它每次都分配了不同的内存位置。因为函数是引用类型，并且<code class="fe mu mv mw mx b">React.memo</code>将新声明的<code class="fe mu mv mw mx b">child2Func</code>内存地址与缓存的<code class="fe mu mv mw mx b">child2Func</code>内存地址进行比较，这导致<code class="fe mu mv mw mx b">Child2</code>被渲染，即使对于每次父状态更新，其属性实际上保持不变。</p><p id="199f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这是在使用<code class="fe mu mv mw mx b">React.memo</code>或任何其他需要在渲染周期中检查数据依赖性的技术时遇到的常见问题。因此，React实际上有一个钩子来解决这个问题，那就是<code class="fe mu mv mw mx b">useCallback</code>钩子。下面是演示其用法的<code class="fe mu mv mw mx b">MemoAndCallback</code>组件的修改版本。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/179c4b3f81194b2d2c3bf40d35658880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*-f42EVY7CJBHl7TA4V-f3g.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图5带有useCallback的MemoAndCallback组件的浏览器控制台输出</figcaption></figure><p id="650a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这里，我们在<code class="fe mu mv mw mx b">MemoAndCallback</code>中添加了另一个组件<code class="fe mu mv mw mx b">Child3</code>，也带有一个功能道具<code class="fe mu mv mw mx b">func</code>。函数<code class="fe mu mv mw mx b">child3Func</code>被传递给<code class="fe mu mv mw mx b">Child3</code>，然而，它的声明被包装在一个<code class="fe mu mv mw mx b">useCallback</code>钩子中。<code class="fe mu mv mw mx b">useCallback</code>的概念与<code class="fe mu mv mw mx b">React.memo</code>完全相同，被包装的实际函数被缓存，如果<code class="fe mu mv mw mx b">useCallback</code>的第二个数组参数中指定的依赖项都没有改变，则返回前一个渲染周期中完全相同的函数。使用这种技术，我们可以确保存储在相同内存地址中的完全相同的函数将作为一个属性传递给一个组件。因此，<code class="fe mu mv mw mx b">React.memo</code>将能够正确检查组件的属性，即使它们是函数。从图5中的控制台输出中，我们可以准确地看到，如上所述，<code class="fe mu mv mw mx b">Child3</code>仅渲染一次，并且不会再次渲染，因为对于<code class="fe mu mv mw mx b">MemoAndCallback</code>组件中的每个状态更新，<code class="fe mu mv mw mx b">child3Func</code>仍然是同一个<em class="nr"/>。</p><h1 id="204b" class="lr ls iq bd lt lu nm lw lx ly nn ma mb mc no me mf mg np mi mj mk nq mm mn mo bi translated">使用备忘录</h1><p id="170f" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">除了优化组件功能，React还提供了一个工具，允许我们记忆任何产生某种结果的复杂表达式。<code class="fe mu mv mw mx b">useMemo</code> React钩子可以用来包装我们在组件内部调用的代码以进行优化，下面的代码演示了它的用法。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/471fc56a56f0e7640455d8ad3c59705f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*r2OYkht0gcZKGeKTyrPUbQ.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图UseMemoExample组件的浏览器控制台输出</figcaption></figure><p id="6359" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe mu mv mw mx b">UseMemoExample</code>组件有一个单独的状态<code class="fe mu mv mw mx b">revaluate</code>，可以通过<code class="fe mu mv mw mx b">revaluateHandler</code>更新。由一百万个随机数组成的全局<code class="fe mu mv mw mx b">data</code>对象被定义在组件之外，以模拟传递给组件的持久数据。全局<code class="fe mu mv mw mx b">data</code>为<code class="fe mu mv mw mx b">UseMemoExample</code>的每次渲染排序。这种排序操作被进一步基准化，并且结果以毫秒显示在组件中。从图6所示的输出中我们可以看到，每次<code class="fe mu mv mw mx b">UseMemoExample</code>更新时，大约在200ms内对<code class="fe mu mv mw mx b">data</code>进行排序。实际上，这种排序操作可以被更复杂的逻辑所取代，并可能导致组件呈现出次优的性能。这是我们可以使用<code class="fe mu mv mw mx b">useMemo</code>来优化代码的地方，下面是一个演示。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/300a0ed5d6935b01c5c6b590d5fa6c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*tJDg_irBS8GC4kf4LQJJwg.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图7带有useMemo的UseMemoExample组件的浏览器控制台输出</figcaption></figure><p id="a0a4" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们在<code class="fe mu mv mw mx b">UseMemoExample</code>组件中引入的唯一变化是将<code class="fe mu mv mw mx b">data</code>的排序逻辑移动到一个<code class="fe mu mv mw mx b">useMemo</code>钩子中作为回调，其中钩子的第二个参数是要检查记忆的依赖项列表。在本例中,<code class="fe mu mv mw mx b">data</code>是一个全局常量，因此不应被视为依赖关系。从图7中我们可以看到，<code class="fe mu mv mw mx b">UseMemoExample</code>第一次渲染时，<code class="fe mu mv mw mx b">data</code>在205ms内排序，并被<code class="fe mu mv mw mx b">useMemo</code>缓存。对于每一个后续的状态更新，因为没有依赖关系改变，缓存和排序的<code class="fe mu mv mw mx b">data</code>对象将被使用，因此导致<code class="fe mu mv mw mx b">UseMemoExample</code>组件的渲染速度大大加快。</p><p id="0a8e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">应该注意的是，当实现<code class="fe mu mv mw mx b">useMemo</code>来改进您的React组件时，我们应该考虑与前面提到的<code class="fe mu mv mw mx b">React.memo</code>完全相同的优缺点。如果在糟糕的用例中实现，由于额外的空间复杂性以及检查函数输入所需的时间，记忆化可能会导致更差的性能！</p><h1 id="2dbc" class="lr ls iq bd lt lu nm lw lx ly nn ma mb mc no me mf mg np mi mj mk nq mm mn mo bi translated">摘要</h1><p id="cdb0" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">在本文中，我们讨论了什么是内存化，以及如何使用React提供的相关工具来提高应用程序的性能。特别是<code class="fe mu mv mw mx b">React.memo</code>和<code class="fe mu mv mw mx b">useMemo</code>被详细覆盖和解释。还讨论了对<code class="fe mu mv mw mx b">useCallback</code>的需求，以实现记忆功能，其中功能包含在记忆功能输入中。每个概念都用代码示例进行了解释和演示，这样我们就可以清楚地看到这些工具是如何在浏览器中运行的。</p><p id="9815" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">唷！！这是大量的信息😅但是希望所有的概念都有足够的细节和例子来解释，以帮助您完成React之旅。这是我第一次尝试在博客上记录我的发展历程，我几乎可以肯定我的写作中可能有不足之处，因此我欢迎所有的批评和改进建议！谢谢你。</p></div></div>    
</body>
</html>