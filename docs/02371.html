<html>
<head>
<title>JavaScript Clean Code — Vertical Formatting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码—垂直格式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-vertical-formatting-d15097f5f30e?source=collection_archive---------5-----------------------#2020-03-09">https://levelup.gitconnected.com/javascript-clean-code-vertical-formatting-d15097f5f30e?source=collection_archive---------5-----------------------#2020-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bd4cbbd521e8a6b664715d1188cd358e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WXqFSPTOLnWjjXzl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@blackpoetry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">pix poeties</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9401" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">鸣谢:灵感来自罗伯特·c·马丁的廉洁守则</strong></p><p id="d16f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以易读的方式格式化代码是保持代码整洁的重要部分。没有正确格式化的代码需要更多的脑力来解释和理解。</p><p id="3fa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何一致地格式化JavaScript代码，以便通过查看垂直格式可以容易地阅读它们。</p><h1 id="b5ee" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么我们需要格式化代码？</h1><p id="8697" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">代码格式很重要，因为它完全是关于交流的。可读性对我们自己和其他读者都很重要。</p><p id="d9b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">杂乱无章的代码会妨碍人们理解代码。其他人不理解代码就无法工作。</p><p id="22f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，阅读代码的人也必须坚持清理代码。我们不希望他们因为容易修复的错误格式而遭受损失。</p><h1 id="719d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">垂直格式</h1><p id="7154" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">代码的行数应该少于500行。小文件比大文件更容易理解。大文件需要更长的时间来阅读，所以花在阅读代码上的时间比做实际工作的时间要多。</p><p id="49fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">源代码就像一篇报纸文章。我们研究得越深入，文章就越详细。代码也是如此。我们有一个关于变量和函数声明的介绍，然后随着我们越来越深入，我们得到了更多的代码实现细节。</p><h1 id="d783" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">空白行</h1><p id="6817" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">不同实体之间的空行很重要。它们在函数和类定义之间尤其重要。没有它们，一切都变得难以阅读，令读者沮丧。</p><p id="b0f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面的内容很难读懂:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6929" class="mq lf it mm b gy mr ms l mt mu">class Foo {metho1(){}metho2(){}}<br/>class Bar {metho1(){}metho2(){}}</span></pre><p id="c502" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，下面要简单得多:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5080" class="mq lf it mm b gy mr ms l mt mu">class Foo {<br/>  method1() {}</span><span id="d030" class="mq lf it mm b gy mv ms l mt mu">  method2() {}<br/>}</span><span id="e930" class="mq lf it mm b gy mv ms l mt mu">class Bar {<br/>  method1() {}</span><span id="06ad" class="mq lf it mm b gy mv ms l mt mu">  method2() {}<br/>}</span></pre><p id="2fa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们应该在代码中放一些空行。</p><p id="bd44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当它们都被捆绑在一起时，很难集中在一段代码上。</p><h1 id="e990" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">垂直密度</h1><p id="5e57" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正如我们在上面看到的，代码在垂直方向上不应该太密集。总是在代码组之间留出一些空间。</p><p id="056f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将没有空行的变量声明和类组合在一起，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e871" class="mq lf it mm b gy mr ms l mt mu">let x = 1;<br/>let y = 2;</span><span id="9f0c" class="mq lf it mm b gy mv ms l mt mu">class Foo {<br/>  method1() {}</span><span id="f17a" class="mq lf it mm b gy mv ms l mt mu">  method2() {}<br/>}</span><span id="0219" class="mq lf it mm b gy mv ms l mt mu">class Bar {<br/>  method1() {}</span><span id="40ff" class="mq lf it mm b gy mv ms l mt mu">  method2() {}<br/>}</span></pre><h1 id="b5d8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">垂直距离</h1><p id="5d1a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">不得不从一个函数跳到下一个函数，并一直上下滚动页面来阅读我们的代码，这令人沮丧。这让所有人都很困惑。</p><p id="636e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在成吨的文件中寻找某个事物的原始定义是令人沮丧的。</p><p id="81af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了防止这种情况，相关的概念应该保持相互接近。</p><h1 id="c46e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">变量声明</h1><p id="7859" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">变量声明应该尽可能接近它们的用法，这样就可以很快找到它们的用法，而不需要在不同的文件之间滚动或跳转。</p><p id="86f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">循环控制变量应该在循环语句中声明，这样读者会马上知道它在循环中使用。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/0221385a446357e814a2826331385d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MsjePDOgoKMSXn9S"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@leomoko?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">利奥·可比</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="f75f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实例变量</h1><p id="7687" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">实例变量应该在类的顶部声明，这样我们就知道可以马上找到它们。</p><p id="1fc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以把它们放在<code class="fe mx my mz mm b">constructor</code>中，这样我们就知道它们是供我们使用或更改的。</p><p id="860e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面的类:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c410" class="mq lf it mm b gy mr ms l mt mu">class Point {<br/>  constructor(x, y) {<br/>    this.x = x;<br/>    this.y = y;<br/>  }</span><span id="fdd3" class="mq lf it mm b gy mv ms l mt mu">  getPoint() {}</span><span id="7899" class="mq lf it mm b gy mv ms l mt mu">  setPoint() {}<br/>}</span></pre><p id="a7c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比下面的更清楚:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b3bf" class="mq lf it mm b gy mr ms l mt mu">class Point {<br/>  getPoint() {}</span><span id="a636" class="mq lf it mm b gy mv ms l mt mu">  setPoint() {}</span><span id="cb78" class="mq lf it mm b gy mv ms l mt mu">  constructor(x, y) {<br/>    this.x = x;<br/>    this.y = y;<br/>  }<br/>}</span></pre><p id="fdf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为大多数人希望类的初始化代码在顶部。<code class="fe mx my mz mm b">constructor</code>有初始化代码，所以我们应该把它放在上面。</p><h1 id="c810" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从属函数</h1><p id="6e75" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">相互依赖的函数应该靠得很近，这样我们就不必滚动文件来寻找被调用函数的原始定义。</p><p id="ae35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这减少了挫折感，因为我们把所有的东西都放在一个屏幕上。</p><p id="7e1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有如下一连串的调用，我们应该将它们放在一起:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="09e5" class="mq lf it mm b gy mr ms l mt mu">class Foo {<br/>  foo() {<br/>    this.bar();<br/>  }</span><span id="436f" class="mq lf it mm b gy mv ms l mt mu">  bar() {<br/>    this.baz();<br/>  }</span><span id="d7d0" class="mq lf it mm b gy mv ms l mt mu">  baz() {}<br/>}</span></pre><h1 id="f700" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">相关代码</h1><p id="c925" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">相关的代码应该彼此靠近，这样我们就不必在代码中滚动查找相关的概念。他们可能没有直接的依赖关系，但他们有足够的密切关系，我们需要一起找到他们。</p><p id="ae22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面的类具有彼此密切相关的方法:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e763" class="mq lf it mm b gy mr ms l mt mu">class Assert {<br/>  assertTrue() {}</span><span id="6b76" class="mq lf it mm b gy mv ms l mt mu">  assertFalse() {}</span><span id="e530" class="mq lf it mm b gy mv ms l mt mu">  assertNotUndefined() {}<br/>}</span></pre><p id="5c85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这三者都断言满足某些条件，所以它们是相关的概念，所以它们应该放在一起。</p><h1 id="fbe1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">垂直排序</h1><p id="9ca4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">被调用的函数应该在执行调用的函数下面。这创造了一个从高到低的良好流程。</p><p id="0875" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">高层次的概念很重要，所以它们应该在最上面，然后我们可以看看低层次的帮助函数。</p><p id="2618" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以上面的例子也适用于这里:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2c2c" class="mq lf it mm b gy mr ms l mt mu">class Foo {<br/>  foo() {<br/>    this.bar();<br/>  }</span><span id="aa4a" class="mq lf it mm b gy mv ms l mt mu">  bar() {<br/>    this.baz();<br/>  }</span><span id="1ee3" class="mq lf it mm b gy mv ms l mt mu">  baz() {}<br/>}</span></pre><p id="fd68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mx my mz mm b">foo</code>叫<code class="fe mx my mz mm b">bar</code>做某事，<code class="fe mx my mz mm b">bar</code>叫<code class="fe mx my mz mm b">baz</code>做另一件事。总之，<code class="fe mx my mz mm b">foo</code>是最高级别，因为它首先被调用，然后调用沿着链向下到达<code class="fe mx my mz mm b">baz</code>。</p><h1 id="8043" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="a2a8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">代码格式很重要。没有它，代码会变得一团糟，难以阅读，因此也难以维护。我们必须主动清理格式混乱的代码。</p><p id="5d50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要做到这一点，我们必须先看看代码的垂直格式。每个文件应该有数千行或更多行。此外，空行在像函数和变量声明这样的代码组之间也很重要。</p><p id="ad3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，相关的概念应该紧密地组合在一起，以减少一起搜索这些实体的时间。</p><p id="6fff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实例变量应该放在最上面，这样容易找到。其他变量声明也应该放在一起，但是它们应该靠近将要使用它们的地方，以最小化滚动。</p><p id="65a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，高级代码应该在低级助手代码之上。</p></div></div>    
</body>
</html>