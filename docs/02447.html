<html>
<head>
<title>JavaScript Clean Code — Smells and Heuristics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码——气味和启发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-smells-and-heuristics-9251efc7c589?source=collection_archive---------11-----------------------#2020-03-13">https://levelup.gitconnected.com/javascript-clean-code-smells-and-heuristics-9251efc7c589?source=collection_archive---------11-----------------------#2020-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/728de415221a58afc7eeb0a9ea464265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nCJbIdvL8CCkZDBi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@frostroomhead?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rodion Kutsaev </a>拍照</figcaption></figure><p id="29dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">糟糕的代码有很多独特的特征。在这篇文章中，我们将看看每一个和他们是什么。我们着眼于编写注释、函数和一般的代码味道和启发。</p><h1 id="20d7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">评论</h1><h2 id="42e5" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">不适当的信息</h2><p id="00ca" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">不应该出现在评论中的信息，比如作者和修改日志，都在评论中。它们应该在源代码控制系统、bug追踪器和其他记录保存系统中。</p><p id="9114" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，变更历史应该在源代码控制系统中。它包含作者、代码变更、变更日期等元数据。这些不应该出现在评论里。</p><p id="7bc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注释应该是关于代码的技术说明。</p><h2 id="2484" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">过时的注释</h2><p id="efc3" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">陈旧、不相关或错误的评论会产生误导。他们老得很快。代码应该足够干净，不需要这么多注释。</p><p id="aabc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们很快就会过时，所以应该避免使用。</p><h2 id="efb3" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">多余的注释</h2><p id="abcc" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">如果代码充分地解释了它自己，那么我们不需要注释来解释它。只说签名的JSDoc也不是很有用。</p><p id="7cfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们应该说代码无法显示的东西。</p><h2 id="ddf6" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">写得不好的评论</h2><p id="55a1" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">值得写的评论要写好。我们应该确保它们是我们能写的最好的评论。</p><h2 id="eafd" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">注释掉的代码</h2><p id="f50e" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">注释掉的代码可能会产生误导。如果它们被注释掉了，为什么它们还在那里？</p><p id="6fdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不需要这些代码，我们应该删除它们。它们也可以从源代码控制系统的变更记录中还原。</p><h1 id="20e3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">环境</h1><h2 id="874c" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">需要多个步骤的构建</h2><p id="3d56" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">构建不应该需要一个以上的步骤。我们必须手动完成的事情越多，每个人遭受的痛苦就越严重。</p><p id="e012" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该做手工操作，比如从源代码控制中签出代码，或者在每次运行构建时运行一堆命令和脚本。</p><p id="c495" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有如此多的构建管道解决方案，按钮应该是一个点击过程。</p><h2 id="9682" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">需要一个以上步骤的测试</h2><p id="cabe" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">运行测试也应该很容易。所有测试都应该用一个命令运行。我们既可以在IDE上单击一下就运行命令，也可以键入一条命令。</p><h1 id="ad84" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">功能</h1><h2 id="39f8" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">太多的争论</h2><p id="7efa" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">函数应该有尽可能少的参数。没有争论是最好的。超过3就有问题了。</p><h2 id="f8c7" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">输出参数</h2><p id="8f44" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们不应该在函数末尾直接返回参数。这毫无意义。</p><h2 id="1f62" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">标志参数</h2><p id="7e44" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">标志参数意味着一个函数不止做一件事，所以应该去掉。</p><h2 id="4fe8" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">死功能</h2><p id="23c5" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">没有被调用的函数应该被删除。死代码占空间，误导人。我们总是可以从源代码管理历史中得到它。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/aa57edc5fdfecd58a56e84ae8ae4e08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r_FTFQ72se4RmBuf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kf" href="https://unsplash.com/@curology?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Curology </a>拍摄的照片</figcaption></figure><h1 id="b637" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一般</h1><h2 id="f0fb" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">一个源文件中有多种语言</h2><p id="e6a0" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">一个文件应该只有一种语言。文件中的语言越多，就越混乱。</p><p id="4775" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逻辑和标记的清晰分离总是好的。JSX只是JavaScript的不同语法，所以它实际上是一种语言。</p><h2 id="bc2e" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">未实施的明显行为</h2><p id="8d24" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">应该实施明显的行为。如果它是如此的无用以至于不能被实现，那么我们可能会消除它。</p><p id="9b88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该像函数描述的那样实现显而易见的功能，这样名字就不会让人误解。</p><h2 id="1ee0" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">边界上的不正确行为</h2><p id="a7d8" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">开发人员在编写他们的函数时，常常相信他们的直觉，认为一切正常。我们经常忽略拐角和边界的情况。</p><p id="6138" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该通过针对这些条件编写测试来检查我们的代码，而不要假设它可以在这些条件下正常工作。</p><h2 id="8937" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">超驰安全机制</h2><p id="37c2" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">当我们写代码时，代码中的安全机制不应该被覆盖。危险的改变应该被最小化。最终可能是大量的错误和调试。</p><p id="9e27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关闭失败的测试是不好的，当我们这样做时，我们应该考虑可能的后果。</p><h2 id="127e" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">复制</h2><p id="36d9" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">代码重复是不好的。每次我们必须改变重复的代码时，我们必须在多个地方改变它们。</p><p id="ffc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过提取代码并将它们放在一个中心位置来删除它们。</p><p id="1194" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码变得更快，更少出错，因为我们只需要在一个地方改变一些东西。</p><p id="6d36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最明显的形式是一堆相同的代码。</p><p id="e4c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种形式是在代码的不同部分多次出现的条件语句。我们可以用多态代码替换它们。</p><p id="1e9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数设计模式都是众所周知的消除重复的方法。它们的结构就是为了消除它们。</p><h2 id="1378" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">代码处于错误的抽象层次</h2><p id="9371" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">当我们抽象代码时，我们应该使它们完整。分离完成了。所有更高级的概念都在基类中。</p><p id="97c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">常量、变量和实用函数不应该出现在基类中。</p><p id="bda3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">源文件、组件和模块也应该在较高的抽象层次上与较低的抽象层次分离开来。</p><p id="4295" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不要把高级代码和低级代码混淆在一起。</p><p id="38bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个<code class="fe my mz na nb b">Account</code>类:</p><pre class="mu mv mw mx gt nc nb nd ne aw nf bi"><span id="f6ef" class="mc lf it nb b gy ng nh l ni nj">class Account {<br/>  saveAccountToDb() {}<br/>  getAccount() {}<br/>  setAccount() {}<br/>}</span></pre><p id="e575" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有两个抽象层次的代码，因为我们有<code class="fe my mz na nb b">saveAccountToDb</code>，它是一个将数据保存到数据库的辅助方法。</p><p id="1bc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们想把它移到一个助手类或函数中。</p><h1 id="8179" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="25a3" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">评论应该被最小化，并且是有用的和最新的。</p><p id="a1d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数应该有尽可能少的参数，并且只做一件事。这也意味着我们不应该有标志参数。</p><p id="ea8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们写代码时，我们应该检查边界和角落情况以避免错误。此外，我们应该覆盖安全功能，如删除重要的测试。他们在那里可能是有原因的。</p><p id="8659" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，代码重复是不好的。</p></div></div>    
</body>
</html>