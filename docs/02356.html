<html>
<head>
<title>The Linked List Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-linked-list-data-structure-6559a1e15f09?source=collection_archive---------8-----------------------#2020-03-08">https://levelup.gitconnected.com/the-linked-list-data-structure-6559a1e15f09?source=collection_archive---------8-----------------------#2020-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/adf95262ee295455e18e483b829f0ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQCi2qU_2dHqGBiH8FeZuQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们可以把链表想象成一列数据火车</figcaption></figure><h2 id="c2ee" class="kf kg it bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍数据结构</h2><p id="2a84" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">在我的上一篇文章中，我介绍了计算机科学中的数据结构，特别是堆栈数据结构。这一次，我将通过介绍另一种类型回到数据结构的主题:链表数据结构。</p><p id="28f7" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">概括一下:数据结构只是一种存储信息和保留信息片段之间特定关系的方式。使用这些关系，我们可以定义一些方法来检索数据的特定部分。</p><h2 id="ec42" class="kf kg it bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">链表数据结构</h2><p id="65ad" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">在链表数据结构中，每一段数据都与下一段数据相连，这样我们就可以访问该数据的值以及链中下一段数据的值。如果该值是链中的最后一个，那么它将链接到null。为了形象化这种结构，我们可以想象一列火车，其中每节车厢都是一段数据，我们可以从火车的一端开始，行进到每节相邻的车厢，以到达下一段数据。我们不能跳过车厢，也不能从中间进入火车，但是，我们可以通过从一节车厢到下一节车厢来参观火车上的每一节车厢。当我们到达最后一节车厢时，我们无处可去，下一段数据什么也不是(或者用更计算机科学的定义来说是“null”)。我们称链表中的每一个回车为“节点”。每个节点有两个属性:一个值和指向下一个节点的指针。链表的大小是由节点的数量定义的。在下面的火车例子中，我们有一个大小为4的链表。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/2438ab7be002c00a8d726ce959f3c036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*Hfe9sTrayoojt74LMfNmFQ.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">链表数据结构</figcaption></figure><p id="f1d1" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">在简单的链表数据结构中，我们也没有办法后退，但是，也有一种叫做双向链表的东西，我们可以双向移动，即每一段数据都包含对前一段数据以及下一段数据的引用。在我们的火车类比中，双向链表将允许我们从火车中的任何一点行进到下一节或上一节车厢。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/a1d2d7f72282ccfc875717a5492e51bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TH4OtUA0YwfeW9UDq40pA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">双向链表数据结构</figcaption></figure><p id="113d" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">双向链表的一个可能的实际应用是使用前进和后退按钮在浏览器中浏览页面。就像我们的火车例子一样，我们只能线性地浏览页面，不允许跳跃，但是，如果你浏览整个列表，就有可能到达每一页。在本文中，我们将坚持使用单链表，但是我认为在现实世界中提到双向链表是很重要的。</p><p id="1840" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在我们已经定义了链表，让我们深入代码，看看如何用JavaScript创建一个链表数据结构。</p><h2 id="bb9d" class="kf kg it bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">JavaScript中的链表数据结构</h2><p id="9c60" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">在创建链表类之前，我们必须首先创建<code class="fe mh mi mj mk b">Node</code>类。这是一个简单的类，其中每个实例都有一个数据值和一个指向另一个实例的指针。默认情况下，我们将这个指针设置为null，除非我们向它传递另一个值。</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="1951" class="kf kg it mk b gy mp mq l mr ms">class Node {</span><span id="8de7" class="kf kg it mk b gy mt mq l mr ms">  constructor(data, next = null) {</span><span id="286d" class="kf kg it mk b gy mt mq l mr ms">    this.data = data;</span><span id="7e73" class="kf kg it mk b gy mt mq l mr ms">    this.next = next;</span><span id="3cc2" class="kf kg it mk b gy mt mq l mr ms">  }</span><span id="57ac" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="b081" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在创建了节点类，我们可以开始定义链表了。</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="4447" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {</span><span id="f134" class="kf kg it mk b gy mt mq l mr ms">  constructor() {</span><span id="9902" class="kf kg it mk b gy mt mq l mr ms">    this.head = null;</span><span id="c864" class="kf kg it mk b gy mt mq l mr ms">    this.size = 0;</span><span id="3ca8" class="kf kg it mk b gy mt mq l mr ms">  }</span><span id="2025" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="4174" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">这里我们将列表的头部定义为第一个节点。因此，当我们第一次构造链表时，我们没有数据，所以头被设置为空，大小被设置为0。让我们添加一个函数来获取列表的大小，这样我们就可以跟踪添加了多少项。我们定义:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="d2ed" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {<br/>...<br/>   getSize() {<br/>   <br/>   return this.size;</span><span id="7c16" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="72f1" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在，我们可以很容易地获得列表中的项目数量。然而，没有数据，我们就没有任何用处！因此，让我们从添加一个向列表中插入元素的方法开始:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="4184" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {</span><span id="ab1c" class="kf kg it mk b gy mt mq l mr ms">...<br/>    insertFirst(data) {</span><span id="b91e" class="kf kg it mk b gy mt mq l mr ms">      this.head = new Node(data, this.head);</span><span id="841b" class="kf kg it mk b gy mt mq l mr ms">      this.size++</span><span id="5905" class="kf kg it mk b gy mt mq l mr ms">  }</span><span id="d2e0" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="9fad" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">这里我们使用我们的<code class="fe mh mi mj mk b">Node</code>类来创建一个新的<code class="fe mh mi mj mk b">Node</code>实例，并将其设置为列表的头部。如果我们添加到一个空列表中，<code class="fe mh mi mj mk b">this.head</code>将会是null，所以实际上，我们创建了一个新的节点<code class="fe mh mi mj mk b">new Node(data, null)</code>，并将列表的大小增加1。让我们用JavaScript创建一个名为<code class="fe mh mi mj mk b">Train</code>的列表:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="3208" class="kf kg it mk b gy mp mq l mr ms">const train = new LinkedList();</span><span id="6890" class="kf kg it mk b gy mt mq l mr ms">train.insertFirst('first carriage');</span><span id="243d" class="kf kg it mk b gy mt mq l mr ms">console.log(train)</span><span id="df68" class="kf kg it mk b gy mt mq l mr ms">// output: LinkedList { head: Node { data: 'first carriage', next: null }, size: 1 }</span></pre><p id="5b10" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">让我们给火车增加一节车厢:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="b58d" class="kf kg it mk b gy mp mq l mr ms">train.insertFirst('second carriage');</span><span id="0ecb" class="kf kg it mk b gy mt mq l mr ms">LinkedList <br/>   { head: <br/>      Node { data: 'second carriage',</span><span id="c34e" class="kf kg it mk b gy mt mq l mr ms">next: <br/>      Node { data: 'first carriage', next: null } }, <br/>     <br/>     size: 2 }</span></pre><p id="bce2" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">很好，现在我们有了一列火车和一些车厢，但是以这种方式查看数据会很难读取实际值。不如我们定义一个函数，让我们打印出我们的数据列表，并显示那些重要的链接关系。我们可以通过访问每个节点的数据值并使用带箭头的字符串插值来实现这一点:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="0a7b" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {</span><span id="2ddc" class="kf kg it mk b gy mt mq l mr ms">...</span><span id="ed12" class="kf kg it mk b gy mt mq l mr ms">    printDataAsList() {</span><span id="8bf7" class="kf kg it mk b gy mt mq l mr ms">      let current = this.head;</span><span id="13dd" class="kf kg it mk b gy mt mq l mr ms">      let str = "";</span><span id="6dd1" class="kf kg it mk b gy mt mq l mr ms">      while (current) {</span><span id="6c9b" class="kf kg it mk b gy mt mq l mr ms">        str +=`${current.data}-&gt;`</span><span id="ed57" class="kf kg it mk b gy mt mq l mr ms">        current = current.next;</span><span id="cc37" class="kf kg it mk b gy mt mq l mr ms">      }</span><span id="d793" class="kf kg it mk b gy mt mq l mr ms">    str += 'null'</span><span id="380c" class="kf kg it mk b gy mt mq l mr ms">    console.log(str)</span><span id="6113" class="kf kg it mk b gy mt mq l mr ms">    }<br/>}</span></pre><p id="2b06" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">所以看着<code class="fe mh mi mj mk b">printDataAsList(train)</code>我们看到:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="c8ba" class="kf kg it mk b gy mp mq l mr ms">train.printDataAsList();</span><span id="adfa" class="kf kg it mk b gy mt mq l mr ms">\\ output: second carriage-&gt;first carriage-&gt;null</span></pre><p id="4c5b" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">可读性强多了！</p><p id="c1b3" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在我们可以创建新的列表，我们可以看到列表中的所有数据，并向列表中添加数据，但是如何向列表的另一端添加数据呢？我们知道我们只能从开始访问我们的列表，所以解决方案在于从第一个节点开始遍历列表。</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="56e3" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {</span><span id="9b90" class="kf kg it mk b gy mt mq l mr ms">...<br/>   <br/>    insertLast(data) {</span><span id="1ab3" class="kf kg it mk b gy mt mq l mr ms">      let node = new Node(data);</span><span id="e501" class="kf kg it mk b gy mt mq l mr ms">      let current;</span><span id="2256" class="kf kg it mk b gy mt mq l mr ms">      if (!this.head) {</span><span id="49e1" class="kf kg it mk b gy mt mq l mr ms">        this.head = node</span><span id="80f7" class="kf kg it mk b gy mt mq l mr ms">    } else {</span><span id="2221" class="kf kg it mk b gy mt mq l mr ms">        current = this.head;</span><span id="c158" class="kf kg it mk b gy mt mq l mr ms">        while (current.next) {</span><span id="ab7b" class="kf kg it mk b gy mt mq l mr ms">          current = current.next</span><span id="1037" class="kf kg it mk b gy mt mq l mr ms">        }</span><span id="3838" class="kf kg it mk b gy mt mq l mr ms">      current.next = node;<br/>     <br/>       }</span><span id="ab53" class="kf kg it mk b gy mt mq l mr ms">      this.size++<br/>          <br/>      return;<br/>    }</span><span id="416e" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="b7c1" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">首先，我们为我们的数据值创建一个新的节点，由于我们在构造函数中将默认值<code class="fe mh mi mj mk b">next</code>设置为null，我们只需要给这个节点传递一个参数，因为我们将把它添加到列表的末尾，所以它无论如何都会指向null。现在我们检查列表，看它是否包含任何数据。如果列表是空的，我们只需要在列表的开头插入新的节点，然后就可以返回了。否则，我们将当前节点设置为列表的开头，然后使用while循环沿着列表移动，直到<code class="fe mh mi mj mk b">current.next</code>为空，即我们已经到达了数据序列的末尾！然后，只需将<code class="fe mh mi mj mk b">current.next</code>更改为我们的新节点，增加列表的大小，我们就可以返回了。让我们给火车增加一个引擎:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="bd50" class="kf kg it mk b gy mp mq l mr ms">train.insertLast('Engine')</span><span id="bda2" class="kf kg it mk b gy mt mq l mr ms">train.printDataAsList();</span><span id="9da1" class="kf kg it mk b gy mt mq l mr ms">\\output: second carriage-&gt;first carriage-&gt;Engine-&gt;null</span></pre><p id="a00d" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在我们可以在两端相加并打印出数据值，在列表中的特定索引处插入数据怎么样。同样，我们需要从第一个节点开始遍历列表，让我们看看如何做到这一点:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="ba2b" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {</span><span id="91ba" class="kf kg it mk b gy mt mq l mr ms">...<br/>    <br/>   insertAt(data, index) {</span><span id="ab38" class="kf kg it mk b gy mt mq l mr ms">      if (index &gt; 0 &amp;&amp; index &gt; this.size) {</span><span id="5993" class="kf kg it mk b gy mt mq l mr ms">      return;<br/>   }</span><span id="2c96" class="kf kg it mk b gy mt mq l mr ms">   if (index === 0) {</span><span id="f9f3" class="kf kg it mk b gy mt mq l mr ms">      this.insertFirst(data)</span><span id="de35" class="kf kg it mk b gy mt mq l mr ms">      return;</span><span id="7940" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="72d0" class="kf kg it mk b gy mt mq l mr ms">   const node = new Node(data);</span><span id="6957" class="kf kg it mk b gy mt mq l mr ms">   let current, previous;</span><span id="768d" class="kf kg it mk b gy mt mq l mr ms">   current = this.head;</span><span id="29c5" class="kf kg it mk b gy mt mq l mr ms">   let count = 0;</span><span id="12c0" class="kf kg it mk b gy mt mq l mr ms">   while (count &lt; index) {</span><span id="1b55" class="kf kg it mk b gy mt mq l mr ms">     previous = current;</span><span id="d483" class="kf kg it mk b gy mt mq l mr ms">     count++;</span><span id="c456" class="kf kg it mk b gy mt mq l mr ms">     current = current.next; </span><span id="4e60" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="7fa9" class="kf kg it mk b gy mt mq l mr ms">   node.next = current;</span><span id="d479" class="kf kg it mk b gy mt mq l mr ms">   previous.next = node;</span><span id="8dc5" class="kf kg it mk b gy mt mq l mr ms">   this.size++;<br/>  <br/>   return;</span><span id="0a52" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="0905" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="3966" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">比在列表末尾添加稍微复杂一点，但是使用类似的逻辑，我们首先必须检查索引是否在列表的大小之内，如果不是，我们简单地返回。您也可以决定通过将这个值添加到列表的末尾来定义它，但是我决定以这种方式实现它。接下来，我们必须检查索引是否确实为0，在这种情况下，我们可以简单地使用前面定义的<code class="fe mh mi mj mk b"> insertFirst</code>函数。否则，我们将current设置为第一个节点，并定义一个变量<code class="fe mh mi mj mk b">count</code>来跟踪我们在列表中的位置。再次使用while循环，我们向下移动列表，存储当前节点和前一个节点，直到我们到达给定的索引。此时，我们退出循环，并将新节点的下一个指针设置为当前节点，将前一个节点的下一个指针设置为新节点，即我们在这两个节点之间插入新节点。最后，我们再一次将大小增加1，我们可以从函数返回。让我们给火车增加一节车厢:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="57fc" class="kf kg it mk b gy mp mq l mr ms">train.insertAt('1.5 carriage', 1)</span><span id="ab61" class="kf kg it mk b gy mt mq l mr ms">train.printDataAsList();</span><span id="a824" class="kf kg it mk b gy mt mq l mr ms">\\ output: <br/>second carriage-&gt;1.5 carriage-&gt;first carriage-&gt;Engine-&gt;null</span></pre><p id="4312" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在我们可以在列表中插入任何一个索引，如何访问这个值。让我们定义一个方法<code class="fe mh mi mj mk b">getAt(index)</code>来访问列表中任意给定索引处的值。</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="5a7c" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {</span><span id="1e89" class="kf kg it mk b gy mt mq l mr ms">...</span><span id="34dc" class="kf kg it mk b gy mt mq l mr ms">   getAt(index) {</span><span id="2661" class="kf kg it mk b gy mt mq l mr ms">     if (index &gt; 0 &amp;&amp; index &gt;= this.size) {</span><span id="8d1e" class="kf kg it mk b gy mt mq l mr ms">     return "Index is greater than size of list";</span><span id="819b" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="1724" class="kf kg it mk b gy mt mq l mr ms">   let current = this.head;</span><span id="a2e2" class="kf kg it mk b gy mt mq l mr ms">   let count = 0;</span><span id="7e36" class="kf kg it mk b gy mt mq l mr ms">   while (count &lt; index) {</span><span id="d581" class="kf kg it mk b gy mt mq l mr ms">     count++;</span><span id="d440" class="kf kg it mk b gy mt mq l mr ms">     current = current.next;</span><span id="af01" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="cc6e" class="kf kg it mk b gy mt mq l mr ms">   return current.data</span><span id="f475" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="e70c" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="734a" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">这里我们首先检查索引是否在我们的列表中，事实上，这一次因为我们没有向列表中添加数据，所以我们需要检查索引是否是<code class="fe mh mi mj mk b">&gt;= this.size</code>。否则，我们将当前节点设置为第一个，然后在列表中向下移动，直到找到索引，此时我们只返回该节点的数据值。回到我们的火车例子:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="24f0" class="kf kg it mk b gy mp mq l mr ms">train.printDataAsList();</span><span id="e896" class="kf kg it mk b gy mt mq l mr ms">console.log(train.getAt(2))</span><span id="eabd" class="kf kg it mk b gy mt mq l mr ms">\\output:</span><span id="b618" class="kf kg it mk b gy mt mq l mr ms">second carriage-&gt;1.5 carriage-&gt;first carriage-&gt;Engine-&gt;null</span><span id="fc72" class="kf kg it mk b gy mt mq l mr ms">first carriage</span></pre><p id="5982" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在，如何移除给定索引的节点呢？在添加数据的类似方法中，我们将方法<code class="fe mh mi mj mk b">removeAt(index)</code>定义如下:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="5f55" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {</span><span id="1307" class="kf kg it mk b gy mt mq l mr ms">...</span><span id="e680" class="kf kg it mk b gy mt mq l mr ms">   removeAt(index) {</span><span id="e10c" class="kf kg it mk b gy mt mq l mr ms">   if (index &gt; 0 &amp;&amp; index &gt;= this.size) {</span><span id="d870" class="kf kg it mk b gy mt mq l mr ms">     return;</span><span id="7f79" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="4d8e" class="kf kg it mk b gy mt mq l mr ms">   let current, previous;</span><span id="0c5e" class="kf kg it mk b gy mt mq l mr ms">   if (index === 0) {</span><span id="05fe" class="kf kg it mk b gy mt mq l mr ms">     current = this.head</span><span id="efe5" class="kf kg it mk b gy mt mq l mr ms">     this.head = current.next</span><span id="8b62" class="kf kg it mk b gy mt mq l mr ms">   } else {</span><span id="65a0" class="kf kg it mk b gy mt mq l mr ms">     current = this.head;</span><span id="0f45" class="kf kg it mk b gy mt mq l mr ms">     let count = 0;</span><span id="98c6" class="kf kg it mk b gy mt mq l mr ms">     while (count &lt; index) {</span><span id="3900" class="kf kg it mk b gy mt mq l mr ms">       previous = current;</span><span id="7a90" class="kf kg it mk b gy mt mq l mr ms">       count++;</span><span id="3d6e" class="kf kg it mk b gy mt mq l mr ms">       current = current.next;</span><span id="e2ba" class="kf kg it mk b gy mt mq l mr ms">     }</span><span id="7321" class="kf kg it mk b gy mt mq l mr ms">   previous.next = current.next;</span><span id="af5d" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="b114" class="kf kg it mk b gy mt mq l mr ms">   this.size--;</span><span id="d2d6" class="kf kg it mk b gy mt mq l mr ms">   return;</span><span id="10ae" class="kf kg it mk b gy mt mq l mr ms">   }</span><span id="2d9a" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="6938" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">像以前一样，我们检查索引是否在当前列表中。然后我们检查索引是否是第一个节点，如果是，我们将头设置在第二个节点并返回。否则，我们将当前节点设置为第一个节点，将前一个节点设置为当前节点之前的节点，并在列表中向下移动，直到到达给定的索引。在那里，我们简单地将previous的指针设置为当前节点之后的节点，即我们跳过当前节点，有效地将它从列表中删除。最后，我们将大小减1，并从方法返回。让我们通过移除索引1处奇怪的火车车厢来看看这一点:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="fc4a" class="kf kg it mk b gy mp mq l mr ms">train.removeAt(1)</span><span id="2414" class="kf kg it mk b gy mt mq l mr ms">train.printDataAsList();</span><span id="699d" class="kf kg it mk b gy mt mq l mr ms">\\output:</span><span id="a2c4" class="kf kg it mk b gy mt mq l mr ms">second carriage-&gt;first carriage-&gt;Engine-&gt;null</span></pre><p id="8607" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">让我们再定义一个函数来清空我们的列表。假设我们实际上想要清除整个列表，而不是只删除一个节点。这实际上很简单，我们需要做的就是将列表的头重置为空，并将列表的大小重置为0，如下所示:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="97f6" class="kf kg it mk b gy mp mq l mr ms">class LinkedList {</span><span id="f204" class="kf kg it mk b gy mt mq l mr ms">...</span><span id="b152" class="kf kg it mk b gy mt mq l mr ms">   clearList() {</span><span id="8a55" class="kf kg it mk b gy mt mq l mr ms">     this.head = null;</span><span id="6880" class="kf kg it mk b gy mt mq l mr ms">     this.size = 0;</span><span id="e17d" class="kf kg it mk b gy mt mq l mr ms">     return;</span><span id="72f7" class="kf kg it mk b gy mt mq l mr ms">     }</span><span id="4bca" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="4a24" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">最后，在所有这些车厢操作之后，我们的火车准备出发了，我们把它送上了它的路，并清除了我们的列表！</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="cfb5" class="kf kg it mk b gy mp mq l mr ms">train.clearList();</span><span id="848a" class="kf kg it mk b gy mt mq l mr ms">train.printDataAsList();</span><span id="5d59" class="kf kg it mk b gy mt mq l mr ms">\\output:</span><span id="8870" class="kf kg it mk b gy mt mq l mr ms">null</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/7383e57541a2e50c5cb06ffc41edc2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5QaNHiMtyuS-5tsr5vc5A.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">再见火车！</figcaption></figure><h1 id="5afb" class="mv kg it bd kh mw mx my kk mz na nb kn nc nd ne kr nf ng nh kv ni nj nk kz nl bi translated">我们如何使用链表数据结构？</h1><p id="bdc1" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">现在我们已经看到了用JavaScript创建链表的方法，我们如何用它来解决问题呢？事实上，我们可以使用链表来创建一个简单的计算器，并通过将这些数字表示为链表并逐位相加来将非常大的数字相加。在本文中，我将只创建一个将两个大数相加的函数，但是以类似的方式，我们可以使用这个结构来做减法、乘法甚至除法。</p><p id="19c3" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">从加法计算开始，我们首先需要一个函数来检查两个列表的大小是否相同，如果不相同，我们将在较短的列表中添加零作为占位符，以使加法更简单。所以首先我们定义一个函数<code class="fe mh mi mj mk b">makeSameSize(l1, l2)</code>，其中<code class="fe mh mi mj mk b">l1</code>和<code class="fe mh mi mj mk b">l2</code>是两个链表，作为我们上面定义的类的实例创建。</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="c6e6" class="kf kg it mk b gy mp mq l mr ms">function makeSameSize(l1, l2) {</span><span id="4bf8" class="kf kg it mk b gy mt mq l mr ms">  l1Size = l1.getSize();</span><span id="b551" class="kf kg it mk b gy mt mq l mr ms">  l2Size = l2.getSize();</span><span id="30c9" class="kf kg it mk b gy mt mq l mr ms">  if (l1Size !== l2Size) {</span><span id="77c1" class="kf kg it mk b gy mt mq l mr ms">    let [bigger, smaller, smallList] =</span><span id="0408" class="kf kg it mk b gy mt mq l mr ms">    l1Size &gt; l2Size ? [l1Size, l2Size, l2] : [l2Size, l1Size, l1];</span><span id="ff5f" class="kf kg it mk b gy mt mq l mr ms">    let n = bigger - smaller;</span><span id="86e3" class="kf kg it mk b gy mt mq l mr ms">    for (let i = 0; i &lt; n; i++) {</span><span id="ed66" class="kf kg it mk b gy mt mq l mr ms">      smallList.insertAt(0, smaller + i);</span><span id="bf04" class="kf kg it mk b gy mt mq l mr ms">    }</span><span id="d13f" class="kf kg it mk b gy mt mq l mr ms">  }</span><span id="8111" class="kf kg it mk b gy mt mq l mr ms">  return [l1, l2]</span><span id="c1f9" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="5855" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">首先，我们检查两个列表的大小，如果其中一个更大，我们使用三元运算符设置数组<code class="fe mh mi mj mk b">[bigger, smaller, smallList]</code>来包含适当的值。我们设置<code class="fe mh mi mj mk b">n</code>为两个列表大小的差，然后使用我们的<code class="fe mh mi mj mk b">insertAt(index)</code>方法添加占位符零，直到两个列表长度相等。</p><p id="b447" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">比如说我们要添加<code class="fe mh mi mj mk b">1234 + 567</code>。我们在链表结构中表示这些数字如下:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="21a1" class="kf kg it mk b gy mp mq l mr ms">let list1 = new LinkedList();</span><span id="0ff7" class="kf kg it mk b gy mt mq l mr ms">list1.insertFirst(4);</span><span id="ad62" class="kf kg it mk b gy mt mq l mr ms">list1.insertFirst(3);</span><span id="59dd" class="kf kg it mk b gy mt mq l mr ms">list1.insertFirst(2);</span><span id="215f" class="kf kg it mk b gy mt mq l mr ms">list1.insertFirst(1);</span><span id="b05b" class="kf kg it mk b gy mt mq l mr ms">let list2 = new LinkedList();</span><span id="c022" class="kf kg it mk b gy mt mq l mr ms">list2.insertFirst(7);</span><span id="5423" class="kf kg it mk b gy mt mq l mr ms">list2.insertFirst(6);</span><span id="aae2" class="kf kg it mk b gy mt mq l mr ms">list2.insertFirst(5);</span><span id="064f" class="kf kg it mk b gy mt mq l mr ms">list1.printDataAsList();</span><span id="d571" class="kf kg it mk b gy mt mq l mr ms">list2.printDataAsList();</span><span id="4ae5" class="kf kg it mk b gy mt mq l mr ms">\\output:</span><span id="6316" class="kf kg it mk b gy mt mq l mr ms">1-&gt;2-&gt;3-&gt;4-&gt;null</span><span id="d9a1" class="kf kg it mk b gy mt mq l mr ms">5-&gt;6-&gt;7-&gt;null</span></pre><p id="ff69" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">然而，颠倒这些列表是有意义的，这样我们首先有最小的数字，因为这将使数字相加更容易(想想纸上的长加法:我们总是从单位开始！).我们可以使用我们的<code class="fe mh mi mj mk b">getAt(index)</code>方法创建一个简单的函数来反转一个链表，如下所示:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="193f" class="kf kg it mk b gy mp mq l mr ms">function reverseList(ll) {</span><span id="89de" class="kf kg it mk b gy mt mq l mr ms">  let outPutList;</span><span id="0015" class="kf kg it mk b gy mt mq l mr ms">  if (ll.getSize() === 0 || ll.getSize() === 1) {</span><span id="2068" class="kf kg it mk b gy mt mq l mr ms">    return;</span><span id="566b" class="kf kg it mk b gy mt mq l mr ms">  } else {</span><span id="8f62" class="kf kg it mk b gy mt mq l mr ms">    outPutList = new LinkedList();</span><span id="4429" class="kf kg it mk b gy mt mq l mr ms">    for( let i = 0; i &lt; ll.getSize(); i++) {</span><span id="f7bf" class="kf kg it mk b gy mt mq l mr ms">      let current = ll.getAt(i);</span><span id="8da6" class="kf kg it mk b gy mt mq l mr ms">      outPutList.insertFirst(current)</span><span id="f2ad" class="kf kg it mk b gy mt mq l mr ms">    }</span><span id="4b37" class="kf kg it mk b gy mt mq l mr ms">  }</span><span id="e908" class="kf kg it mk b gy mt mq l mr ms">  return outPutList;</span><span id="f3c1" class="kf kg it mk b gy mt mq l mr ms">}</span></pre><p id="64f2" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在我们颠倒列表，使单位列在第一位。这使得以正确的顺序添加数字变得容易:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="8999" class="kf kg it mk b gy mp mq l mr ms">list1 = reverseList(list1);</span><span id="62db" class="kf kg it mk b gy mt mq l mr ms">list2 = reverseList(list2);</span><span id="69ad" class="kf kg it mk b gy mt mq l mr ms">list1.printDataAsList();</span><span id="7fcc" class="kf kg it mk b gy mt mq l mr ms">list2.printDataAsList();</span><span id="241d" class="kf kg it mk b gy mt mq l mr ms">\\output:</span><span id="3f72" class="kf kg it mk b gy mt mq l mr ms">4-&gt;3-&gt;2-&gt;1-&gt;null</span><span id="e2f9" class="kf kg it mk b gy mt mq l mr ms">7-&gt;6-&gt;5-&gt;null</span></pre><p id="024e" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">如果我们将这些值添加到我们的函数中，使它们具有相同的大小，我们将得到预期的输出:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="fd23" class="kf kg it mk b gy mp mq l mr ms">const [sslist1, sslist2] = makeSameSize(list1, list2)</span><span id="a276" class="kf kg it mk b gy mt mq l mr ms">sslist1.printDataAsList();</span><span id="46b0" class="kf kg it mk b gy mt mq l mr ms">sslist2.printDataAsList();</span><span id="6b67" class="kf kg it mk b gy mt mq l mr ms">\\output:</span><span id="b7aa" class="kf kg it mk b gy mt mq l mr ms">4-&gt;3-&gt;2-&gt;1-&gt;null</span><span id="eebc" class="kf kg it mk b gy mt mq l mr ms">7-&gt;6-&gt;5-&gt;0-&gt;null</span></pre><p id="9a8a" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">正如所料，我们在数字567的千位列中添加了一个0，所以现在我们的列表大小相同。</p><p id="ebb5" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">现在让我们实现其余的功能！我们需要创建几个变量来存储数字的总和，检查这个总和是否大于10，如果恰好是这样，则存储进位数字，这里有一种在JavaScript中实现这个函数的可能方法:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="9a1a" class="kf kg it mk b gy mp mq l mr ms">function addTwoLists(l1, l2) {</span><span id="50e9" class="kf kg it mk b gy mt mq l mr ms">  outPutList = new LinkedList();</span><span id="1522" class="kf kg it mk b gy mt mq l mr ms">  [l1, l2] = makeSameSize(l1, l2)</span><span id="0d62" class="kf kg it mk b gy mt mq l mr ms">  let currentL1 = l1.getAt(0);</span><span id="e41b" class="kf kg it mk b gy mt mq l mr ms">  let currentL2 = l2.getAt(0);</span><span id="fc00" class="kf kg it mk b gy mt mq l mr ms">  let carry = 0;</span><span id="90e8" class="kf kg it mk b gy mt mq l mr ms">  let remainder, quotient;</span><span id="4f00" class="kf kg it mk b gy mt mq l mr ms">  let sum = 0;</span><span id="d851" class="kf kg it mk b gy mt mq l mr ms">  let index = 0;</span><span id="5a46" class="kf kg it mk b gy mt mq l mr ms">  while (index &lt; l1Size) {</span><span id="6790" class="kf kg it mk b gy mt mq l mr ms">    index++;</span><span id="6061" class="kf kg it mk b gy mt mq l mr ms">    sum = currentL1 + currentL2 + carry;</span><span id="a97a" class="kf kg it mk b gy mt mq l mr ms">    quotient = Math.floor(sum / 10);</span><span id="d0dc" class="kf kg it mk b gy mt mq l mr ms">    if (quotient !== 0) {</span><span id="5317" class="kf kg it mk b gy mt mq l mr ms">      remainder = sum % 10</span><span id="7ad8" class="kf kg it mk b gy mt mq l mr ms">      carry = 1;</span><span id="c3a6" class="kf kg it mk b gy mt mq l mr ms">      outPutList.insertFirst(remainder)</span><span id="f116" class="kf kg it mk b gy mt mq l mr ms">    } else {</span><span id="83b8" class="kf kg it mk b gy mt mq l mr ms">      carry = 0;</span><span id="1c61" class="kf kg it mk b gy mt mq l mr ms">      outPutList.insertFirst(sum)</span><span id="e353" class="kf kg it mk b gy mt mq l mr ms">    }</span><span id="5969" class="kf kg it mk b gy mt mq l mr ms">    currentL1 = l1.getAt(index);</span><span id="54c8" class="kf kg it mk b gy mt mq l mr ms">    currentL2 = l2.getAt(index);</span><span id="47cd" class="kf kg it mk b gy mt mq l mr ms">    if (index === l1Size &amp;&amp; carry !== 0) {</span><span id="b82e" class="kf kg it mk b gy mt mq l mr ms">      outPutList.insertFirst(carry)</span><span id="efb2" class="kf kg it mk b gy mt mq l mr ms">    }</span><span id="0fbd" class="kf kg it mk b gy mt mq l mr ms">  }<br/> <br/>  return outPutList;<br/>}</span></pre><p id="07b8" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">我们首先使用索引为零的<code class="fe mh mi mj mk b">getAt(index)</code>得到每个列表的头，并将<code class="fe mh mi mj mk b">carry</code>(结转数字)设置为0。我们还为余数、常数、总和以及指数定义了一些变量。因为我们现在有两个相同大小的列表，我们只需要检查一个列表的大小，所以我们使用while循环直到索引到达列表的末尾。</p><p id="0db7" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">在这个循环中，我们增加索引，并将总和定义为2个当前数据值的总和，并加上进位数字(在我们的第一次迭代中，这当然会是0)。我们必须检查这个值是否大于10(就像你在纸上做长加法时，必须检查你是否需要携带一个10)。如果值大于10，那么一定在10到20之间，所以我们设置<code class="fe mh mi mj mk b">remainder</code>，设置<code class="fe mh mi mj mk b">carry</code>为1，否则<code class="fe mh mi mj mk b">carry</code>不变为0。我们将<code class="fe mh mi mj mk b">remainder</code>或<code class="fe mh mi mj mk b">sum</code>插入链表，这取决于我们是否有一个结转数字。最后，我们将<code class="fe mh mi mj mk b">currentL1</code>和<code class="fe mh mi mj mk b">currentL2</code>的当前值重置为列表中的下一个值，并继续下去，直到索引达到<code class="fe mh mi mj mk b">l1</code>的大小。</p><p id="8a08" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">最后，我们只需检查最后一对数字，也就是说，如果我们的最后2位数字有一个带有进位的和，那么我们必须将这个进位数字添加到我们的链表中(因此，与输入相比，我们将输出链表的大小增加了1)。然后我们只需要返回输出链表，我们就成功了！让我们看看我们的例子的输出，并使用JavaScript的内置加法函数进行一些巧妙的添加:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="34ba" class="kf kg it mk b gy mp mq l mr ms">(addTwoLists(list1, list2)).printDataAsList();</span><span id="927d" class="kf kg it mk b gy mt mq l mr ms">console.log("Answer should be:", 1234 + 567)</span><span id="24e9" class="kf kg it mk b gy mt mq l mr ms">\\output:</span><span id="7c9a" class="kf kg it mk b gy mt mq l mr ms">1-&gt;8-&gt;0-&gt;1-&gt;null</span><span id="42d9" class="kf kg it mk b gy mt mq l mr ms">Answer should be: 1801</span></pre><p id="3285" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">万岁！让我们尝试一个更复杂的加法:<code class="fe mh mi mj mk b">987654321 + 123456789</code></p><p id="a510" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">我们像以前一样创建两个链表，并颠倒数字:</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="79e7" class="kf kg it mk b gy mp mq l mr ms">1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;null</span><span id="cda7" class="kf kg it mk b gy mt mq l mr ms">9-&gt;8-&gt;7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null</span></pre><p id="cfff" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">用我们的函数添加这些</p><pre class="mc md me mf gt ml mk mm mn aw mo bi"><span id="e0ba" class="kf kg it mk b gy mp mq l mr ms">(addTwoLists(list1, list2)).printDataAsList();</span><span id="ae2e" class="kf kg it mk b gy mt mq l mr ms">console.log("Answer should be:", 987654321 + 123456789)</span><span id="75fb" class="kf kg it mk b gy mt mq l mr ms">\\output:</span><span id="70fa" class="kf kg it mk b gy mt mq l mr ms">1-&gt;1-&gt;1-&gt;1-&gt;1-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0-&gt;null</span><span id="09fb" class="kf kg it mk b gy mt mq l mr ms">Answer should be: 1111111110</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/3b59c0a776c935ed779738ef512e22ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFHtRTvr-R6EPwN7mtGxkg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">万岁！</figcaption></figure><p id="19e7" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">所以加法就这样了。我们当然可以用这个函数作为基础，创造出其他的算术运算来对大数进行乘、减甚至除。但那是以后的事了！</p><p id="43d3" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">在本文中，我们介绍了链表数据结构，并了解了如何通过创建一个类在JavaScript中实现它，并使用该结构为由整数组成的长列表创建一个简单的加法函数。</p><p id="8c7f" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">参考资料:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><div class="np nq gp gr nr ns"><a href="https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithms.htm" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">数据结构和算法-链表</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">链表是通过链接连接在一起的一系列数据结构。链表是一系列…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og jz ns"/></div></div></a></div></div></div>    
</body>
</html>