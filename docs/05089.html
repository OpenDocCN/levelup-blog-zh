<html>
<head>
<title>Building a Resilient Microservice with Quarkus and Wiremock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Quarkus和Wiremock构建弹性微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-resilient-microservice-with-quarkus-and-wiremock-de59b2a4fac7?source=collection_archive---------10-----------------------#2020-08-03">https://levelup.gitconnected.com/building-a-resilient-microservice-with-quarkus-and-wiremock-de59b2a4fac7?source=collection_archive---------10-----------------------#2020-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/739bad1a04e16b9fc397db685cd1c018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXGgLlwlPI4x_igLOlEJkg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@knaggit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马扬·格拉博斯基</a>在<a class="ae kc" href="https://unsplash.com/s/photos/mobile-phone?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b5ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">这是用Quarkus、Kotlin和Debezium从头开始构建微服务系列的第三部分。该服务用于发送短信。</p><p id="fe61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一部分中，我们构建了基本框架并添加了持久性。在<a class="ae kc" href="https://medium.com/@changeant/implementing-the-transactional-outbox-pattern-with-debezium-in-quarkus-f2680306951" rel="noopener">第二部分</a>中，我们使用CDC从持久化的SMS消息中生成事件。我们构建了一个消息处理程序来处理发送到Kafka主题的消息。</p><p id="ea47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是消息处理程序的当前状态</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="9c9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二部分的末尾，消息处理程序只是将消息状态更新为Delivered(第11行),这样我们就可以证明这个流了。为了完成这个流程，我们需要添加一个或多个SMS提供者，以便可以将消息传递给接收者。</p><p id="38cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有一个以上的提供者就好了，这样如果一个提供者不可用或者发生一些不可预见的事件，比如信用过期，我们可以有一个备份。我们需要挑选几个提供者，并编写客户端集成来与提供者API对话。然后，我们将编写一个路由器，随机选择一个提供者来发送消息。</p><p id="4af4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该流程将如下所示</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/968c27d7e9d104de89f6db432cedde9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFGQC6nVOuGFnqI-q8rLOw.png"/></div></div></figure><p id="101e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了跟随代码，你可以拉动分支</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="c03b" class="lw lx iq ls b gy ly lz l ma mb">git clone <a class="ae kc" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:iainporter/sms-service.git<br/>git checkout part_three</span></pre><p id="ec1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先要做的是挑选几个提供商，并添加客户端集成。在本例中，我们将使用<a class="ae kc" href="https://www.clicksend.com/gb/" rel="noopener ugc nofollow" target="_blank">点击发送</a>和<a class="ae kc" href="http://twilio.com" rel="noopener ugc nofollow" target="_blank">两种方式。</a></p><p id="14d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要一个面向所有提供商的公共接口</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="78fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注册ClickSend后，我们会收到一组凭据和一定数量的免费信用点数，这将允许我们进行测试。</p><p id="5de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击发送查看开发者文档这里是一个发送短信到点击发送的例子</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="c646" class="lw lx iq ls b gy ly lz l ma mb">curl --include \<br/>     --header "Authorization: Basic ZXJuYW1lOmFwaS1wYXNzd29yZA=="  \<br/>     --request POST \<br/>     --header "Content-Type: application/json" \<br/>     --data-binary "    {<br/>        \"messages\":[<br/>            {<br/>                \"source\":\"php\",<br/>                \"body\":\"Jelly liquorice marshmallow candy \",<br/>                \"to\":\"+61411111111\"<br/>            }<br/>        ]<br/>    }" \<br/>'https://rest.clicksend.com/v3/sms/send'</span></pre><p id="3bcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向ClickSend API发送消息的客户端实现</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="f80c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分解代码:</p><p id="dc6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第6–13行</strong> - &gt;设置我们在注册点击发送时获得的属性，这些属性在应用程序中。属性<br/> <strong class="kf ir">第17行</strong> - &gt;使用<a class="ae kc" href="https://github.com/rybalkinsd/kohttp" rel="noopener ugc nofollow" target="_blank"> kohttp </a>客户端进行REST通信<br/> <strong class="kf ir">第36–38行</strong> - &gt;捕捉超时异常并将消息设置为失败<br/> <strong class="kf ir">第44行</strong> - &gt;点击发送返回所有响应，即使失败也作为200 Http我们需要从响应中提取status属性，并检查它是否等于“成功”(第82–91行)</p><h2 id="1857" class="lw lx iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">科特林密封类</h2><p id="5b4f" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">在处理客户端对ClickSend API的调用时，人们倾向于使用类似java的异常处理。然而，Kotlin不支持使用检查异常，这是有充分理由的。通过使用异常，我们迫使任何使用该类的人理解可能会抛出什么异常，并适当地处理它们。</p><p id="9a07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，这是第33-61行的外观，但有例外</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ad53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用一个密封的类来消除所有这些混乱的异常处理</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="592e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以通过返回ProviderResponse并允许调用者决定如何处理它来使实现的意图更加清晰。这是Twilio的实现。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h2 id="31f0" class="lw lx iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">使用Wiremock测试客户端集成</h2><p id="4d38" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">在我们的单元和集成测试中，我们不想向真正的SMS提供者发送消息。我们需要用Wiremock把这些REST调用剔除掉。Wiremock 是一个模仿和阻止对外部服务的http调用的重要工具。它是一个HTTP模拟服务器，我们可以在其中设置期望值，然后验证结果。通过设置与来自外部API的预期响应相匹配的数据，我们可以编写测试来验证我们的代码行为是否如预期的那样工作。</p><p id="66cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个测试，用于验证点击发送集成在以下场景中的行为:</p><ul class=""><li id="3b80" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">Http 200成功，消息的状态为“成功”</li><li id="503b" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">Http 200成功，但消息的状态不是“成功”</li><li id="cbad" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">Http 401授权失败</li><li id="94a5" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">复制读取超时故障</li></ul><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h2 id="db23" class="lw lx iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">路由到短信提供商</h2><p id="2ae9" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">现在我们已经编写了客户端集成，我们需要添加一些路由逻辑。这是提供商路由器的接口。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="9a24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现细节并不重要。我们可以选择许多不同的方式来实现这一点。保持简单，路由器随机选择一个提供商。如果出现服务器故障，我们将使用不同的提供商再试一次。</p><p id="3877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意第9行，如果没有配置提供者，那么我们关闭服务器，因为如果没有地方可以发送SMS消息，那么继续是没有意义的。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h2 id="b05c" class="lw lx iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">组件测试</h2><p id="17cc" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">在第二部分中，我们向组件测试添加了额外的docker容器，以允许我们验证消息传递是否按预期工作。为了在我们的组件测试中测试SMS客户端集成，我们需要添加一个wiremock容器，我们可以用我们需要的存根填充它。借助Dockerfile的魔力，这很容易实现</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="6fc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以将其连接到sms服务中的构建执行中</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="5b85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将其添加到在BaseComponentTst.kt类中启动的容器列表中</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="edbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意我们用config/wiremock目录中的存根填充mappings目录</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/81f5d2c38882b5babe56e73588613f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*h3_XMM06EOXF9FsyRvFNeA.png"/></div></figure><p id="2cdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以验证当一个或多个提供者返回成功和不成功状态时的行为</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h2 id="7356" class="lw lx iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">运行服务</h2><p id="7c6c" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">在运行这项服务之前，你需要通过<a class="ae kc" href="https://www.clicksend.com/gb/" rel="noopener ugc nofollow" target="_blank">点击发送</a>和/或<a class="ae kc" href="http://twilio.com" rel="noopener ugc nofollow" target="_blank"> Twilio </a>注册一个账户。这两种服务都有免费试用，可以给你足够的积分来发送大量的测试信息。</p><p id="6e08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获得SMS提供程序的凭据后，添加config/application.properties文件并添加您的属性。</p><p id="23ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">application.properties.sample提供了一个示例</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="41ff" class="lw lx iq ls b gy ly lz l ma mb">## Sign up for ClickSend (www.clicksend.com) and get username and apikey<br/>sms.provider.clicksend.enabled=true<br/>sms.provider.clicksend.username=<br/>sms.provider.clicksend.apiKey=<br/>sms.provider.clicksend.endpoint=https://rest.clicksend.com/v3/sms/send<br/><br/>## Sign up for Twilio (www.twilio.com) and get the values to access the API<br/>sms.provider.twilio.enabled=true<br/>sms.provider.twilio.account.sid=<br/>sms.provider.twilio.endpoint=https://api.twilio.com/2010-04-01/Accounts/&lt;your account.sid&gt;/Messages.json<br/>sms.provider.twilio.auth.token=<br/>sms.provider.twilio.from.number=</span></pre><p id="a1d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保docker-compose.yml文件中引用了您添加的文件。在本例中，我将属性文件放在相对于docker-compose.yml文件的父目录中:../config/应用程序.属性</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="ffac" class="lw lx iq ls b gy ly lz l ma mb">volumes:<br/>  - ../config/application.properties:/deployments/config/application.properties</span></pre><p id="6d4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建服务，然后用docker-compose运行它</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="faa6" class="lw lx iq ls b gy ly lz l ma mb">mvn clean install<br/>cd sms-service<br/>docker-compose up -d</span></pre><p id="afce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向kafka connect注册连接器</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="f76d" class="lw lx iq ls b gy ly lz l ma mb">curl 'localhost:8083/connectors/' -i -X POST -H "Accept:application/json" \<br/>-H "Content-Type:application/json" \<br/>-d '{"name": "sms-connector", "config": {"connector.class": "io.debezium.connector.postgresql.PostgresConnector", "database.hostname": "postgres-db", "database.port": "5432", "database.user": "postgres", "database.password": "postgres", "database.dbname" : "sms", "database.server.name": "smsdb1", "table.whitelist": "public.outboxevent", "transforms" : "outbox","transforms.outbox.type" : "io.debezium.transforms.outbox.EventRouter", "transforms.OutboxEventRouter.event.key": "aggregate_id", "transforms.outbox.table.fields.additional.placement": "type:header:eventType"}}'</span></pre><p id="eaa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以开始发送消息了。这是一个样本卷曲</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="e166" class="lw lx iq ls b gy ly lz l ma mb"><a class="ae kc" href="http://localhost:8080/v1/sms'" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/sms'</a> -i -X POST    -H 'Content-Type: application/json'     -d '{"text":"Foo Bar!", "toNumber": "+1234567890", "fromNumber="+1234567890"}'</span></pre><p id="f1e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">期待这样的回应</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="a700" class="lw lx iq ls b gy ly lz l ma mb">HTTP/1.1 202 Accepted<br/>Content-Length: 0<br/>Location: <a class="ae kc" href="http://localhost:8080/v1/sms/e307458a-a0a8-4f13-9635-f9b27b4da0e5" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/sms/e307458a-a0a8-4f13-9635-f9b27b4da0e5</a></span></pre><p id="d8f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用位置头来获取消息细节</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="3867" class="lw lx iq ls b gy ly lz l ma mb">curl -i <a class="ae kc" href="http://localhost:8080/v1/sms/c75e551a-b11c-4703-bbe7-5c6bb38b001c" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/sms/</a>e307458a-a0a8-4f13-9635-f9b27b4da0e5</span></pre><p id="78f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果消息成功传递，结果应该如下所示</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="b619" class="lw lx iq ls b gy ly lz l ma mb">HTTP/1.1 200 OK<br/>Content-Length: 194<br/>Content-Type: application/json</span><span id="bda3" class="lw lx iq ls b gy nn lz l ma mb">{<br/>"createdAt":"2020-07-29T15:10:49.36597Z",<br/>"id":"e307458a-a0a8-4f13-9635-f9b27b4da0e5",<br/>"status":"DELIVERED",<br/>"text":"Foo Bar!",<br/>"toNumber":"+1234567890",<br/>"updatedAt":"2020-07-29T15:10:57.558555Z"<br/>}</span></pre><p id="f06e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果其中一个提供者返回一个错误，那么我们应该在日志中看到对另一个提供者的重试</p><pre class="lk ll lm ln gt lr ls lt lu aw lv bi"><span id="0a86" class="lw lx iq ls b gy ly lz l ma mb">2020-07-29 15:26:21,183 DEBUG [com.por.sms.pro.cli.ClickSendProvider] (ForkJoinPool.commonPool-worker-3) Sending SMS via ClickSend Service to +1234567890<br/>2020-07-29 15:26:21,199 DEBUG [com.por.sms.pro.cli.ClickSendProvider] (ForkJoinPool.commonPool-worker-3) serialised messages to json: {"messages":[{"body":"Foo Bar!","to":"+1234567890","schedule":0}]}<br/>2020-07-29 15:26:26,624 DEBUG [com.por.sms.pro.cli.ClickSendProvider] (ForkJoinPool.commonPool-worker-3) API response from ClickSend, statusCode: 200<br/>2020-07-29 15:26:26,627 DEBUG [com.por.sms.pro.cli.ClickSendProvider] (ForkJoinPool.commonPool-worker-3) ClickSend failed to send the message due to: INSUFFICIENT_CREDIT<br/>2020-07-29 15:26:26,629 DEBUG [com.por.sms.pro.RandomProviderRouter] (ForkJoinPool.commonPool-worker-3) retrying message with different provider Twilio<br/>2020-07-29 15:26:26,629 DEBUG [com.por.sms.pro.twi.TwilioProvider] (ForkJoinPool.commonPool-worker-3) Sending SMS via Twilio Service to +1234567890<br/>2020-07-29 15:26:27,431 DEBUG [com.por.sms.pro.twi.TwilioProvider] (ForkJoinPool.commonPool-worker-3) API response from Twilio, statusCode: 201<br/>2020-07-29 15:26:27,433 DEBUG [com.por.sms.eve.SmsMessageCreatedHandler] (ForkJoinPool.commonPool-worker-3) Message has been processed</span></pre><p id="2144" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有一个全功能的微服务在Quarkus中运行，它将接受SMS请求并将其转发给一个已配置的提供商。除了一个明显的漏洞:安全性之外，它几乎可以投入生产了！！</p><p id="57ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前这项服务对所有人开放。任何人都可以通过API发送消息。通常，像这样的服务将由其他微服务在内部使用，不会暴露在API网关之外。但是，我们应该保护端点，并确保只有经过授权的用户或客户端才能访问。下一篇文章将讨论如何使用OAuth保护端点。</p><p id="e896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的代码库可以在<a class="ae kc" href="https://github.com/iainporter/sms-service/tree/part_three" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="bfdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该系列的其他部分包括:</p><ul class=""><li id="1a1a" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-microservice-from-the-ground-up-with-quarkus-kotlin-and-debezium-83ae5c8a8bbc">第一部分:构建框架并添加持久性</a></li><li id="4ff4" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/implementing-the-transactional-outbox-pattern-with-debezium-in-quarkus-f2680306951">第二部分:使用Kafka Connect和Debezium实施CDC</a></li><li id="4d7e" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/securing-a-microservice-in-quarkus-with-openid-connect-505204d1c9a9">第四部分:使用OpenID Connect保护服务</a></li><li id="50de" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae kc" href="https://medium.com/@changeant/running-a-microservice-in-quarkus-on-graalvm-52d6b42a5840" rel="noopener">第五部分:使用GraalVM本地运行</a></li><li id="a461" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae kc" href="https://medium.com/@changeant/containerizing-your-microservice-in-quarkus-with-jib-fae0f62bd57e" rel="noopener">第六部分:用Jib封装你的微服务</a></li><li id="d5b0" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-ci-pipeline-for-a-microservice-in-quarkus-with-circleci-11e9b679423f">第七部分:使用CircleCI为微服务构建CI管道</a></li></ul></div></div>    
</body>
</html>