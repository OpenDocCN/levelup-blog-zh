# Golang 中更好的错误处理:理论和实践技巧

> 原文：<https://levelup.gitconnected.com/better-error-handling-in-golang-theory-and-practical-tips-758b90d3f6b4>

## 这就是 Go 使用返回错误而不是异常的原因

![](img/ecc1f25f83b8fdb78d764b5cbe77588c.png)

科学错误地鼠作者[@ egonelbre](https://twitter.com/egonelbre?lang=en)[https://github . com/egonelbre/gophers/blob/master/vector/science/mission . SVG](https://github.com/egonelbre/gophers/blob/master/vector/science/mistake.svg)

编程语言应该如何处理错误？例如，打开给定名称的文件并将其读入缓冲区的函数可能由于多种原因而失败:文件可能不存在，打开文件的程序可能没有打开它的权限，或者文件太大，缓冲区容纳不下。大多数语言使用异常:在一个系统中，抛出的异常通过调用堆栈传播，直到在 try-catch 块中处理它的级别。异常模型将错误视为特例，与程序的常规返回值流分开处理。

这种方法有几个缺点。首先，它可以对程序员隐藏错误处理路径，特别是在捕捉异常不是强制性的情况下，比如在 Python 中。即使在必须处理 Java 风格的检查异常的语言中，如果在不同于原始调用的级别处理错误，也不总是很明显错误是从哪里抛出的。我们都见过长代码块包装在一个 try-catch 块中。在这种情况下，catch 块实际上充当了一个`goto`语句，这通常被认为是有害的(奇怪的是，[对于 C #中的关键字来说，被认为是可接受的少数用例之一是出错后清理](https://stackoverflow.com/questions/788903/valid-use-of-goto-for-error-management-in-c)，因为该语言没有 Golang 风格的`defer`语句)。

如果您在异常的源头捕获异常，您将得到一个不太优雅的 Go 错误模式版本。这可能会解决混淆代码的问题，但是会遇到另一个问题:性能。在像 Java 这样的语言中，抛出一个异常可能比函数的常规返回慢几百倍。基于[这篇文章](https://www.baeldung.com/java-exceptions-performance)，Java 中最大的性能成本是由打印异常的堆栈跟踪引起的，这是很昂贵的，因为运行的程序必须检查编译它的源代码。仅仅进入一个`try`块[也不是自由的](https://stackoverflow.com/a/299315)，因为 CPU 内存寄存器的先前状态需要被保存，因为它们可能需要在发生异常时被恢复。

如果你把它们看作是不经常发生的例外情况，那么异常的缺点就没什么大不了的。这可能是传统的单片应用程序的情况，其中大部分代码库不必进行网络调用——操作格式良好的数据的函数不太可能遇到错误(除了出现 bug 的情况)。只要在代码中加入 I/O，代码无错代码的梦想就破灭了:**你可以忽略错误，但不能假装错误不存在！**

```
try {
    doSomething()
} catch (IOException e) {
    // ignore it
}
```

与大多数其他编程语言不同，Golang 认为错误是不可避免的。如果不是在整体架构时代，它肯定是在今天的模块化后端服务中，其中服务通常是外部 API 调用、对数据库的读写以及与其他服务的通信之间的瘦包装器。所有这些都可能失败，解析或验证从它们那里收到的数据也可能失败(通常在无模式 JSON 中)。Golang 使这些调用返回的错误显式化，与普通返回值的级别相同。这由从函数调用返回多个值的能力来支持，这在大多数语言中通常是不可能的。Golang 的错误处理系统不仅仅是一种语言怪癖，它是一种完全不同的将错误视为可选返回值的方式！

# 重复 if err！=零

对 Go 错误处理的一个常见批评是被迫重复下面的代码块:

```
res, err := doSomething()
if err != nil {
 // Handle error
}
```

对于新用户来说，这可能是无用的，也是对代码行的浪费:一个在其他语言中需要 3 行代码的函数可能会增长到 12 行:

```
// In Java
DBResult doSomething() throws IOException {
    APIResult res = getFromAPI()
    Model parsed = parse(res)
    return writeToDB(parsed)
}// In Golang
func doSomething() error {
    res, err := getFromAPI()
    if err != nil {
        // Handle API error
    }
    parsed, err := parse(res)
    if err != nil {
        // Handle parse error
    }
    res, err = writeToDB(parsed)
    if err != nil {
        // Handle database error
    }
    return res
}
```

这么多行代码！如此低效！

如果你认为以上是不雅的或浪费代码，你可能忽略了我们检查代码中错误的全部原因:我们需要能够以不同的方式处理它们！对 API 或数据库的调用可能会被重试。有时事件的顺序很重要:在调用外部 API 之前发生的错误可能没什么大不了的(因为数据从未发送过)，而 API 调用和写入本地数据库之间的错误可能需要立即引起注意，因为这可能意味着系统最终处于不一致的状态。即使我们只想将错误传播给调用者，我们也可能希望用失败原因的解释来包装它们，或者为每个错误返回一个自定义的错误类型。并非所有的错误都是相同的，向调用者返回适当的错误是 API 设计的重要部分，对于内部包和 REST APIs 都是如此。

你不必担心在你的代码中重复`if err != nil`——这就是 Go 中的代码应该看起来的样子。

# 自定义错误类型和错误包装

当从导出的方法返回错误时，请考虑指定自定义错误类型，而不要只使用错误字符串。字符串在意外代码中是可以的，但是在导出的函数中，它们成为函数的公共 API 的一部分。更改错误字符串将是一个突破性的改变——没有明确的错误类型，需要检查返回的错误类型的单元测试将不得不依赖于原始字符串值！事实上，基于字符串的错误使得在私有方法中测试不同的错误情况也很困难，所以您也应该考虑在一个包中使用它们。回到错误与异常的争论，返回错误也比抛出异常更容易测试代码，因为错误只是一个要检查的返回值。测试中不需要测试框架或捕捉异常。

简单定制错误类型的一个很好的例子可以在`[database/sql](https://pkg.go.dev/database/sql#pkg-constants)` [包](https://pkg.go.dev/database/sql#pkg-constants)中找到。它定义了一个导出的常量列表，这些常量代表了包可以返回的错误类型，最著名的是`sql.ErrNoRows`。虽然从 API 设计的角度来看，这种特定的错误类型有些问题(您可能会认为 API 应该返回空结构而不是错误)，但是任何需要检查空行的应用程序都可以导入该常量并在代码中使用它，而不必担心错误消息本身会改变和破坏代码。

对于更复杂的错误处理，您可以通过实现返回错误字符串的`Error()`方法来定义定制的错误类型。自定义错误可以包括元数据，如错误代码或原始请求参数。如果您想要表示错误类别，它们会很有用。来自 DigitalOcean 的本教程展示了如何使用自定义错误类型来表示一类可以重试的临时错误。

通常，错误通过用更高级别的解释包装低级别的错误而在程序的调用栈中传播。例如，数据库错误可能以下面的格式记录在 API 调用处理程序中:`error calling CreateUser endpoint: error querying database: pq: deadlock detected`。这很有用，因为它帮助我们跟踪错误在系统中的传播，向我们显示根本原因(数据库事务引擎中的死锁)及其对更广泛系统的影响(调用者无法创建新用户)。从 Go 1.13 开始，这种模式有特殊的语言支持，带有[错误包装](https://go.dev/blog/go1.13-errors)。通过在创建字符串错误时使用`%w`动词，可以用`Unwrap()`方法访问底层错误。除了比较错误相等性的函数`errors.Is()`和`errors.As()`之外，程序还可以获取被包装错误的原始类型或身份。这在某些情况下可能是有用的，尽管我认为在决定如何处理所述错误时最好使用顶级错误的类型。

# 恐慌

不要`panic()`！总的来说，这是很好的人生课程，但在编写 Go 代码时尤其重要。长期运行的应用程序应该优雅地处理错误，而不是惊慌失措。即使在无法恢复的情况下(例如启动时验证配置)，最好记录一个错误并优雅地退出。死机比错误信息更难诊断，并且可能会跳过被推迟的重要关闭代码。

# 记录

我还想简要地写一下日志，因为它是处理错误的一个关键部分。通常，您能做的最好的事情就是记录收到的错误，然后继续处理下一个请求。

除非您正在构建简单的命令行工具或个人项目，否则您的应用程序应该使用一个结构化的日志记录库，该库可以向日志添加时间戳，并提供对日志级别的控制。最后一部分尤其重要，因为它允许您突出显示应用程序记录的所有错误和警告。这将帮助您将它们从信息级日志中分离出来，从而节省大量时间。微服务架构还应该包括服务的名称，以及日志行中机器实例的名称。当这些被默认记录时，程序代码不必担心包含它们。您还可以在日志的结构化部分中记录其他字段，例如接收到的错误(如果您不想将它嵌入日志消息本身)或有问题的请求或响应。只要确保你的日志没有泄露任何敏感数据，比如密码、API 密匙或者用户的个人数据！

对于日志库，我过去使用过 [logrus](https://github.com/sirupsen/logrus) 和 [zerolog](https://github.com/rs/zerolog) ，但是也有其他的结构化日志库可以选择。如果你想了解更多，网上有很多关于如何使用这些的指南。如果您正在将您的应用程序部署到云，您可能需要日志库中的一个适配器来根据您的云平台的日志 API 格式化日志——如果没有它，一些功能(如日志级别)可能无法被云平台检测到(我过去就遇到过这种情况)。

如果您在应用程序中使用调试级别的日志(默认情况下通常不记录日志)，请确保您的应用程序有一个简单的方法来更改日志级别，而无需更改代码。更改日志级别还可以暂时抑制信息级别甚至警告级别的日志，以防它们突然变得过于嘈杂并开始淹没错误。您可以使用一个环境变量来实现这一点，该变量在启动时被检查以设置日志级别。

希望你学到了新的东西，可以在下次用 Go，甚至其他语言编程时应用！