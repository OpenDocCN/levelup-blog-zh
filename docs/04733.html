<html>
<head>
<title>Understanding useRef</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解useRef</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-useref-513b1bbe00dc?source=collection_archive---------2-----------------------#2020-07-12">https://levelup.gitconnected.com/understanding-useref-513b1bbe00dc?source=collection_archive---------2-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6f8b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">refs和React挂钩简介</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/05a6f1cc03c0a6603aa045a22d4a1c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xFw_LxaLYxy4PuvY"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@shivelycreative?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Nathan Shively </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d24d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useRef</code>是React 16.8中的开箱即用挂钩。在React的类(有状态)组件中使用的是替代<code class="fe ls lt lu lv b">createRef()</code>的功能组件。无论你是否熟悉refs、<code class="fe ls lt lu lv b">createRef</code>或<code class="fe ls lt lu lv b">useRef</code>，这篇文章都将引导你了解这个非常有用的钩子的基础知识。</p><p id="bdb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，React功能组件中的<code class="fe ls lt lu lv b">useRef</code>钩子有两个主要用途:访问DOM元素和在状态中存储可变信息，而不会触发组件的重新呈现。我们将看看这两者的一个例子，并讨论一些需要记住的事情。</p><h2 id="7c0f" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">一个警告</h2><p id="4d24" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">一般来说，我们应该避免在React中使用<code class="fe ls lt lu lv b">useRef</code>来做任何可以用<em class="mu">声明的事情——也就是说，我们应该让React尽可能地处理应用程序的状态和每个组件的“如何”。然而，在某些情况下，您需要<em class="mu">强制性地</em>改变DOM元素或与之交互，告诉它“如何”处理(或不处理)某些东西，从而绕过状态。一些常见的DOM元素示例包括管理特定元素的焦点、选择文本或媒体回放。我们还将探索一些我们可能需要React的其他原因。</em></p><h2 id="bd88" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">什么是裁判？</h2><p id="e2bf" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在React中，ref是一个可以在元素标记或组件标记本身中使用的属性。ref提供了“一种访问在render方法中创建的DOM节点或React元素的方法，”(<a class="ae kv" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> Refs和DOM </a>)。在普通JavaScript中，我们通过调用<code class="fe ls lt lu lv b">document.getElementById()</code>，传入给定元素的id来处理DOM元素。有了refs in React，我们不再需要这样做了。<code class="fe ls lt lu lv b">ref</code>属性将直接引用该元素，并让我们访问它的方法。</p><p id="b383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个在输入标签中放置引用的示例:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="35e9" class="lw lx iq lv b gy mz na l nb nc">&lt;input type="text" ref={textInput} /&gt;</span></pre><p id="e47a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以在组件内部使用ref(但只能在父组件的render方法中使用):</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="2c29" class="lw lx iq lv b gy mz na l nb nc">&lt;FormComponent ref={formRef} /&gt;</span></pre><p id="e15b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ref属性是<code class="fe ls lt lu lv b">useRef</code>的灵感来源，但它不是使用这个钩子的唯一原因。让我们更深入地了解一下<code class="fe ls lt lu lv b">useRef</code>。</p><h2 id="9e9a" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">什么是useRef？</h2><blockquote class="nd ne nf"><p id="f6f6" class="kw kx mu ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useRef</code>返回一个可变的ref对象，其<code class="fe ls lt lu lv b">.current</code>属性被初始化为传递的参数(<code class="fe ls lt lu lv b">initialValue</code>)。返回的对象将在组件的整个生存期内保持不变。<em class="iq"> ( </em> <a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> <em class="iq">钩子API引用— React </em> </a> <em class="iq"> ) </em></p></blockquote><p id="85ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个令人兴奋的定义——<code class="fe ls lt lu lv b">useRef</code>的基础是，它是一个可以存储可变信息而不触发重新呈现的对象。<code class="fe ls lt lu lv b">.current</code>属性是将要初始化的内容，也是存储最新信息的地方。正如我提到的，这对于处理DOM元素特别有用，但是这个钩子的用处远不止于此，因为它可以在组件的生命周期中随时改变，而不会触发重新呈现。</p><h2 id="35a8" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">入门指南</h2><p id="f8e4" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">将<code class="fe ls lt lu lv b">useRef</code>钩子导入到顶部的React组件中:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="c198" class="lw lx iq lv b gy mz na l nb nc">import React, { useRef } from 'react';</span></pre><p id="1253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦导入了钩子，就可以开始使用它了。<code class="fe ls lt lu lv b">useRef</code>挂钩的初始化方式与<code class="fe ls lt lu lv b">useState</code>挂钩相同:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="d72c" class="lw lx iq lv b gy mz na l nb nc">const textInput = useRef('');</span></pre><p id="6d1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传递给useRef的值将是初始值，它存储在<code class="fe ls lt lu lv b">.current</code>属性中。在这个例子中:<code class="fe ls lt lu lv b">textInput.current = '';</code></p><h2 id="8c79" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">使用<code class="fe ls lt lu lv b">useRef</code>访问元素</h2><p id="afef" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">运行我们的文本输入示例，让我们看看如何使用<code class="fe ls lt lu lv b">useRef</code>钩子通过将焦点切换到输入框来与DOM元素交互:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9b49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们给按钮一个<code class="fe ls lt lu lv b">onClick</code>函数，它调用我们的<code class="fe ls lt lu lv b">useRef</code>钩子<code class="fe ls lt lu lv b">textInput</code>上的<code class="fe ls lt lu lv b">focus()</code>方法。当按钮单击时，用户在页面上的焦点切换到该文本框。因为我们将ref放在input元素中，所以我们可以访问特定HTML元素的任何方法，比如<code class="fe ls lt lu lv b">focus()</code>方法。</p><h2 id="020a" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">使用useRef在状态中存储信息</h2><p id="e699" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">正如我已经说过几次的,<code class="fe ls lt lu lv b">useRef</code>钩子可以存储在组件的整个生命周期中可以改变的信息，而不会触发重新呈现。</p><p id="9ac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有很多用例，但是作为例子，让我们假设我们想要记录一个组件被重新渲染的次数。我们可以尝试这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="34ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，由于存储在状态中的任何东西在改变时都会触发重新渲染，所以每次我们增加<code class="fe ls lt lu lv b">count</code>时，我们的组件都会重新渲染，从而创建一个无限循环。所以这是一个不应该做的事情的例子！但是我们确实需要将这个数字<em class="mu">存储在状态中的某个地方</em>，这样组件就可以在它的整个生命周期中跟踪它。</p><p id="26b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次输入<code class="fe ls lt lu lv b">useRef</code>。通过简单地将<code class="fe ls lt lu lv b">count</code>改为<code class="fe ls lt lu lv b">useRef</code>挂钩而不是<code class="fe ls lt lu lv b">useState</code>挂钩，我们可以安全地存储这些变异的数据，而无需重新呈现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe ls lt lu lv b">useRef</code>不像<code class="fe ls lt lu lv b">useState</code>钩子那样自带设置器。要更改ref，我们只需重新分配useRef的<code class="fe ls lt lu lv b">.current</code>属性中存储的任何值。</p><p id="eb82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个注意事项:建议在<code class="fe ls lt lu lv b">useEffect</code>或<code class="fe ls lt lu lv b">useLayoutEffect</code>中运行任何副作用，比如改变ref，以避免bug。</p><h2 id="5a03" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">结论</h2><p id="90fc" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useRef</code>钩子是一个非常方便的选项，既可以与DOM元素交互，也可以在应用程序中存储变异信息，而不会触发重新渲染。但是，建议仅在必要时使用<code class="fe ls lt lu lv b">useRef</code>并且在<code class="fe ls lt lu lv b">useEffect</code>内，以避免错误。</p><p id="7df4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章是对<code class="fe ls lt lu lv b">useRef</code>钩子的快速介绍。React中的<code class="fe ls lt lu lv b">useRef</code>和<code class="fe ls lt lu lv b">refs</code>世界里发生了很多事情。以下是一些帮助您入门的文章:</p><ul class=""><li id="efde" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><a class="ae kv" href="https://medium.com/@rossbulat/react-using-refs-with-the-useref-hook-884ed25b5c29" rel="noopener"> React:使用Refs和useRef挂钩</a>作者Ross Bulat</li><li id="1ea1" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">反应useRef和useLayoutEffect vs useEffect 鲁本·莱贾著</li><li id="8814" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><a class="ae kv" href="https://medium.com/better-programming/how-to-properly-use-the-react-useref-hook-in-concurrent-mode-38c54543857b" rel="noopener">如何在并发模式下正确使用React useRef钩子</a>Daishi Kato</li></ul></div></div>    
</body>
</html>