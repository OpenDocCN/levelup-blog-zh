<html>
<head>
<title>High resilience with Web Sockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web套接字的高弹性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/high-resilience-with-web-sockets-315641e4f02c?source=collection_archive---------1-----------------------#2022-07-08">https://levelup.gitconnected.com/high-resilience-with-web-sockets-315641e4f02c?source=collection_archive---------1-----------------------#2022-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3876" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用实时数据确保连通性和增强UX的技巧</h2></div><p id="6d0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一个拥有巨大数据量的快速发展的世界里，<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket" rel="noopener ugc nofollow" target="_blank"> WebSockets </a>在谈论实时通信时往往会成为第一选择，因此，在使用它们时提高它们的能力是非常重要的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/edb1698191c7fbcf93e2fe657f27b45a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0lto_hCzo08tPNQ8h9Cng.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">实时图表示例</figcaption></figure><p id="ce6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这不是本文的目的，但值得注意的是，根据场景的不同，【WebSockets可能有些过头了，其他替代方案 <strong class="kk iu">如服务器端事件(</strong> <a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> SSE </strong> </a> <strong class="kk iu">)或轮询</strong> <strong class="kk iu">对于大多数常见情况来说可能是足够好的解决方案。</strong></p><p id="f9bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到这里，我们不打算深入实施细节或解释整个<a class="ae le" href="https://datatracker.ietf.org/doc/html/rfc6455" rel="noopener ugc nofollow" target="_blank">协议</a>本身，而只是强调几个概念来支持您在考虑Web套接字时应该考虑的不同点，主要是前端方面。</p><p id="8d4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，我们旨在涵盖以下主题:</p><ol class=""><li id="a422" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">会话粘性</li><li id="e4a6" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">订阅缓存</li><li id="a849" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">应用可见性</li><li id="2760" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">网络状态</li><li id="fbd1" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">插座配置</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d02f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.粘性会话</h1><p id="cc19" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">会话粘性(<em class="nn">又称为会话持续性或关联性</em>)是一个过程，其中负载平衡器将特定会话的请求路由到为该会话的第一个请求提供服务的同一物理机器，从而在客户端和特定网络服务器之间创建关联性。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi no"><img src="../Images/2c2707fc3a156f894ac80eaf2c0190c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PtJAbkuZIyv05XQU-ljjnA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">无粘性与粘性会话配置</figcaption></figure><p id="396c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这通常是通过发布cookie或跟踪他们的IP详细信息来实现的。</p><blockquote class="np"><p id="e8cc" class="nq nr it bd ns nt nu nv nw nx ny ld dk translated"><strong class="ak">粘性本身仅仅取决于你的技术和产品规格</strong></p></blockquote><h2 id="e2e9" class="nz mr it bd ms oa ob dn mw oc od dp na kr oe of nc kv og oh ne kz oi oj ng ok bi translated">您计划扩展您的系统吗？</h2><p id="d495" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">如果不是这种情况，你的系统的本质已经达到了粘性。唯一的服务器实例将侦听和处理所有连接。</p><h2 id="790d" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated">您需要提供连接回退吗？</h2><p id="016c" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">WebSocket是一个开放的TCP连接，当连接打开时，服务器和客户端可以在任何给定的时间发送和接收数据。</p><p id="acf1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当客户端请求对WebSockets ( <em class="nn">又名握手</em>)进行连接升级时，返回<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101" rel="noopener ugc nofollow" target="_blank"> HTTP 101 </a>状态码以接受连接升级的目标就是WebSocket连接中使用的目标。<strong class="kk iu">一旦升级，基于cookie的粘性将不再使用</strong>。</p><blockquote class="np"><p id="ce68" class="nq nr it bd ns nt nu nv nw nx ny ld dk translated">WebSocket连接天生具有粘性</p></blockquote><p id="a1b6" class="pw-post-body-paragraph ki kj it kk b kl oq ju kn ko or jx kq kr os kt ku kv ot kx ky kz ou lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#the_websocket_handshake" rel="noopener ugc nofollow" target="_blank">握手</a>旨在与基于HTTP的服务器端软件和任何中介兼容，以便HTTP和WebSocket客户端可以使用一个端口与服务器对话。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ov"><img src="../Images/c2f6d1ade1dd836441408eaced48e20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7Ut8Mpc-4x8I9MbRz2wtw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">Web套接字图</figcaption></figure><p id="7f4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">连接到<code class="fe ow ox oy oz b">/prices</code>名称空间的客户端握手看起来像这样:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="2b52" class="nz mr it oz b gy pe pf l pg ph"> GET /prices HTTP/1.1<br/> Host: example.com<br/><strong class="oz iu"> Upgrade: websocket</strong><br/> Connection: Upgrade<br/> Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==<br/> Origin: https://example.com</span></pre><p id="4c80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务器的响应是:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="e0fa" class="nz mr it oz b gy pe pf l pg ph"> <strong class="oz iu">HTTP/1.1 101 Switching Protocols</strong><br/> Upgrade: websocket<br/> Connection: Upgrade<br/> Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span></pre><blockquote class="pi pj pk"><p id="8e09" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated"><strong class="kk iu"> Sec-WebSocket-Key </strong>是一个随机的16字节nonce (base64编码),它在服务器中与预定义的GUID一起使用，以导出<strong class="kk iu"> Sec-WebSocket-Accept </strong>报头，<strong class="kk iu">,因此客户端确保服务器支持WS，并且不会将数据解释为HTTP请求</strong></p></blockquote><blockquote class="np"><p id="206c" class="nq nr it bd ns nt po pp pq pr ps ld dk translated">WebSocket协议是一个独立的基于TCP的协议。它与HTTP的唯一关系是它的握手被HTTP服务器解释为升级请求</p></blockquote><p id="ff71" class="pw-post-body-paragraph ki kj it kk b kl oq ju kn ko or jx kq kr os kt ku kv ot kx ky kz ou lb lc ld im bi translated">然而，默认情况下，<a class="ae le" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>和<a class="ae le" href="https://github.com/sockjs/sockjs-client" rel="noopener ugc nofollow" target="_blank"> SockJS </a>等套接字引擎会建立与<strong class="kk iu"> HTTP长轮询</strong>传输的连接，以防止由于公司代理、个人防火墙等原因建立WebSocket连接时可能出现的问题。</p><p id="d64c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">长轮询(<em class="nn">或“轮询”</em>)基本上由连续的HTTP请求组成:</p><ul class=""><li id="c61d" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld pt mb mc md bi translated"><em class="nn">长时间运行的</em> <code class="fe ow ox oy oz b">GET</code>请求:从服务器接收数据(相当于服务器<em class="nn">发出</em>)</li><li id="e2e4" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld pt mb mc md bi translated"><em class="nn">短时运行</em> <code class="fe ow ox oy oz b">POST</code>请求:向服务器发送数据(相当于客户端<em class="nn">发出</em>)</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pu"><img src="../Images/6059590b30d886c5a61d15c0f587d88b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5EHq5I2SJEtcXCocGRqkAA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">长轮询图</figcaption></figure><blockquote class="pi pj pk"><p id="9587" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">服务器选择保持客户端连接打开，直到数据可用(或超时后)。这比原来的轮询技术更有效，因为服务器不需要为每个新的传入连接分配新的资源来处理、解析、生成和传递响应</p></blockquote><p id="333e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在连接开始时<strong class="kk iu"><em class="nn">【1】</em></strong>服务器发送会话ID <code class="fe ow ox oy oz b">sid</code>以及其他信息:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="5d63" class="nz mr it oz b gy pe pf l pg ph"><em class="nn">Request</em><br/>GET https://example.com/prices/?EIO=3&amp;<strong class="oz iu">transport=polling</strong>&amp;t=NymEVAg</span><span id="4f34" class="nz mr it oz b gy pv pf l pg ph"><em class="nn">Response</em><br/>{<br/>  "<strong class="oz iu">sid</strong>": "<strong class="oz iu">aBM2xUVW5zx0WC3ZAAQE</strong>",<br/>  "upgrades": ["websocket"],<br/>  "pingInterval": 25000,<br/>  "pingTimeout": 20000<br/>}</span></pre><p id="ba22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在升级到WS之前，该会话id必须作为查询参数包含在所有后续HTTP请求中，作为协议的一部分:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="5d38" class="nz mr it oz b gy pe pf l pg ph"><strong class="oz iu">(3)</strong> POST https://example.com/prices/EIO=3&amp;transport=polling&amp;t=NymEVR0&amp;<strong class="oz iu">sid=aBM2xUVW5zx0WC3ZAAQE</strong></span><span id="0479" class="nz mr it oz b gy pv pf l pg ph"><strong class="oz iu">(2) </strong>GET<br/>http://example.com/prices/EIO=3&amp;transport=polling&amp;t=NymEVR4&amp;<strong class="oz iu">sid=aBM2xUVW5zx0WC3ZAAQE</strong></span></pre><p id="e85f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这样的服务器实现通常将会话状态存储在内存中，因此<strong class="kk iu">给定会话的每个长轮询请求需要到达同一个服务器</strong>，也就是说<strong class="kk iu">会话粘性。</strong></p><blockquote class="pi pj pk"><p id="1490" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">根据引擎，您可以禁用此回退。以Socket.io为例，您可以在启动连接时通过<a class="ae le" href="https://socket.io/docs/v3/client-initialization/#transports" rel="noopener ugc nofollow" target="_blank">传输</a>参数来避免长时间轮询:<code class="fe ow ox oy oz b"><em class="it">transport = ['websocket']</em></code></p></blockquote><h2 id="19b3" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated">您是否为每个用户提供个性化数据？</h2><p id="6c61" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">与http相比，<strong class="kk iu"> WebSocket </strong>协议<strong class="kk iu">没有元数据</strong>，因此如果连接丢失，负载平衡器将不得不在TCP层实现负载平衡。</p><blockquote class="np"><p id="4821" class="nq nr it bd ns nt nu nv nw nx ny ld dk translated">失去连接后，负载平衡器和浏览器之间将发生http升级协商</p></blockquote><p id="ac85" class="pw-post-body-paragraph ki kj it kk b kl oq ju kn ko or jx kq kr os kt ku kv ot kx ky kz ou lb lc ld im bi translated"><strong class="kk iu">负载平衡器可以</strong> <strong class="kk iu">因此使用粘性会话cookie </strong>以便将连接发送到合适的服务器实例。</p><p id="ea97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您的应用程序只需要一个没有个性化内容的通用实时源，它可以重新连接到任何实例<strong class="kk iu">、</strong>，因此粘性会话不是强制性的。</p><blockquote class="pi pj pk"><p id="7336" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">即使提供定制的更新，只要你能确保在你的所有实例中提供正确的提要，你就不需要会话粘性</p></blockquote><h1 id="3cd4" class="mq mr it bd ms mt pw mv mw mx px mz na jz py ka nc kc pz kd ne kf qa kg ng nh bi translated">2.订阅缓存</h1><p id="023a" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">根据应用程序的性质，您需要特别注意它如何处理实时更新。</p><p id="dac6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在大多数情况下，一个简单的场景可能需要在一个页面中显示一个提要。</p><p id="3f2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，对于更复杂的应用程序，您应该事先问自己几个问题:</p><ul class=""><li id="24a6" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld pt mb mc md bi translated"><em class="nn">我的应用需要多少订户？它们是固定的还是基于用户交互动态创建的？</em></li><li id="a33a" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld pt mb mc md bi translated"><em class="nn">它们是如何分布的？他们使用来自同一来源的数据吗？它们是在应用程序、页面还是组件级别分配的？</em></li><li id="7d4b" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld pt mb mc md bi translated"><em class="nn">登录时，无论导航如何，我是否需要在后台使用任何订阅源？</em></li></ul><p id="2ef0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据答案思考以下几点。</p><h2 id="c8f4" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated"><strong class="ak">跟踪给定房间的预订情况</strong></h2><p id="ff3f" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">例如，根据您的需求为订阅实体建模:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="542f" class="nz mr it oz b gy pe pf l pg ph">import { Subscription } from "rxjs"</span><span id="247f" class="nz mr it oz b gy pv pf l pg ph"><em class="nn">class</em> SourceSub {<br/> // Subscriber -&gt; Subscription<br/><em class="nn"> private </em>subscribers: <em class="nn">Map</em>&lt;<em class="nn">string</em>, Subscription&gt; = new <em class="nn">Map</em>()<br/>}</span></pre><p id="5956" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个<code class="fe ow ox oy oz b">SourceSub</code>被绑定到一个<a class="ae le" href="https://socket.io/docs/v3/rooms/" rel="noopener ugc nofollow" target="_blank">房间</a>作为数据源，你的应用程序中从同一来源获取更新的所有部分应该由同一个实例处理。</p><p id="c279" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ow ox oy oz b">subscribers</code>地图让我们可以通过存储每个UI部件的数据源订阅来实现，这些UI部件需要对给定房间进行实时更新。</p><h2 id="3b2a" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated">缓存最后一个提要</h2><p id="0928" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">给定一个房间，缓存最后收到的值:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="a14a" class="nz mr it oz b gy pe pf l pg ph"><em class="nn">class</em> SourceSub {<em class="nn"><br/> private </em>subscribers: <em class="nn">Map</em>&lt;<em class="nn">string</em>, Subscription&gt; = new <em class="nn">Map</em>()<br/><strong class="oz iu"> private lastValue? </strong>//Your feed model<br/>}</span></pre><p id="70bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将有助于在用默认值呈现新组件时增强用户体验，直到它获得新的提要更新。</p><blockquote class="pi pj pk"><p id="c3fb" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">根据您的数据馈送约束，考虑在服务器端缓存它</p></blockquote><h2 id="47b8" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated">在您的应用中缓存订阅</h2><p id="ef5a" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">在任何给定时间缓存应用程序中的所有活动订阅:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="2762" class="nz mr it oz b gy pe pf l pg ph"><em class="nn">class</em> MyApp {<br/> // Room -&gt; SourceSub<br/> private appSubCache: Map&lt;string, SourceSub&gt; = new Map()<br/>}</span></pre><blockquote class="pi pj pk"><p id="57fe" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">根据您的需求和服务器套接字配置的缓存结构</p></blockquote><p id="72e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每次装载显示实时数据的新组件时，您都需要跟踪它并创建合适的订阅。成像<em class="nn"> </em>一个<code class="fe ow ox oy oz b">header</code>组件第一次加入<code class="fe ow ox oy oz b">today</code>通道:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="eada" class="nz mr it oz b gy pe pf l pg ph">const channel = 'today'<br/>const subscriber = 'header'<br/>const source$ = my_feed_stream</span><span id="1158" class="nz mr it oz b gy pv pf l pg ph"><em class="nn">// Component subscription receiving live updates<br/></em>const headerSubscription = source$.subscribe(update)</span><span id="20d7" class="nz mr it oz b gy pv pf l pg ph"><em class="nn">// New source subscription for the first time</em><br/>const roomSubscription = new SourceSub()<br/>roomSubscription.add(subscriber, headerSubscription)</span><span id="716f" class="nz mr it oz b gy pv pf l pg ph"><em class="nn">// Store it</em><br/>this.appSubCache.add(channel, roomSubscription)</span><span id="c6cd" class="nz mr it oz b gy pv pf l pg ph">// Join room<br/>join(channel)</span></pre><p id="569a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，当<code class="fe ow ox oy oz b">my_feed_stream</code>发出动态数据时，<code class="fe ow ox oy oz b">update</code>将作为回调函数相应地更新每个新提要的组件状态，但是您可以实现任何其他机制将数据源连接到您的组件树。</p><h2 id="1924" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated"><strong class="ak">退订</strong></h2><p id="dd4b" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">每当获取实时更新的组件被卸载时，确保它从数据源中取消订阅。</p><p id="7cf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设用户现在导航到一个没有<code class="fe ow ox oy oz b">header</code>组件的新页面:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="a610" class="nz mr it oz b gy pe pf l pg ph">const channel = 'today'<br/>const subscriber = 'header'</span><span id="3bd0" class="nz mr it oz b gy pv pf l pg ph"><em class="nn">const</em> subscription = this.appSubCache.get(channel)<br/>// Unsubscribe and delete <br/>subscription.remove(subscriber)</span><span id="b21d" class="nz mr it oz b gy pv pf l pg ph">if (subscription.hasNoSubscribers()) {<br/>  // Remove SourceSub *<br/>  this.appSubCache.delete(channel)</span><span id="b654" class="nz mr it oz b gy pv pf l pg ph">  // Leave room<br/>  leave(channel)<br/>}</span></pre><p id="25c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将防止内存泄漏并改进处理，而无需从服务器更新针头。</p><blockquote class="pi pj pk"><p id="2e6b" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated"><strong class="kk iu"> * </strong>请记住，您可以为没有订户但有<code class="fe ow ox oy oz b"><em class="it">lastValue</em></code>的给定房间保留<code class="fe ow ox oy oz b">SourceSub</code>实例，这样下一个新订户将始终有一个默认值可供显示</p></blockquote><h1 id="4d9d" class="mq mr it bd ms mt pw mv mw mx px mz na jz py ka nc kc pz kd ne kf qa kg ng nh bi translated">3.应用可见性</h1><p id="7849" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">一个普通用户可能会同时打开几个页面，所以你应该考虑当你的应用不活跃时会发生什么。</p><blockquote class="np"><p id="b3d1" class="nq nr it bd ns nt nu nv nw nx ny ld dk translated">用户代理通常有特定的策略来减轻后台或隐藏选项卡的性能影响</p></blockquote><p id="92ed" class="pw-post-body-paragraph ki kj it kk b kl oq ju kn ko or jx kq kr os kt ku kv ot kx ky kz ou lb lc ld im bi translated">例如，大多数浏览器停止发送<code class="fe ow ox oy oz b">requestAnimationFrame</code>回调，像<code class="fe ow ox oy oz b">setTimeout</code>这样的计时器被节流以提高性能和电池寿命。</p><blockquote class="pi pj pk"><p id="3cec" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">像<a class="ae le" href="https://developer.chrome.com/blog/tab-discarding/#discarding-unused-tabs" rel="noopener ugc nofollow" target="_blank">标签丢弃</a>和<a class="ae le" href="https://developer.chrome.com/blog/background_tabs/#budget-based-background-timer-throttling" rel="noopener ugc nofollow" target="_blank">基于预算的后台超时</a>调节这样的功能在现代浏览器中可用，以提供对后台计时器CPU使用的额外限制</p></blockquote><p id="acaa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，<strong class="kk iu">像音频</strong>播放、<strong class="kk iu">索引DB </strong>和<strong class="kk iu">实时连接(WebSocket和WebRTC)这样的进程不受这种节流</strong>行为的约束，以避免超时关闭连接。</p><p id="4dfe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，您可以为基于web的应用程序使用<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">页面可见性</strong> </a> <strong class="kk iu"> </strong> API:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="0346" class="nz mr it oz b gy pe pf l pg ph">function getPageVisibility() {<br/>  <!-- -->let hidden, visibilityChange<br/>  if (typeof document.hidden !== "undefined") {<br/>    hidden = "hidden"<br/>    visibilityChange = "visibilitychange"<br/>  } else if (typeof document.msHidden !== "undefined") {<br/>    hidden = "msHidden"<br/>    visibilityChange = "msvisibilitychange"<br/>  } else if (typeof document.webkitHidden !== "undefined") {<br/>    hidden = "webkitHidden"<br/>    visibilityChange = "webkitvisibilitychange"<br/>  }<br/>  return { hidden, visibilityChange }<br/>}</span></pre><p id="ff40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据您的应用和性能要求，您可能需要在应用处于非活动状态时关闭所有连接，但更重要的是，<strong class="kk iu">当应用返回前台时，您应该始终确保连接处于正常活动状态</strong>，以减少任何连接停机时间:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="5538" class="nz mr it oz b gy pe pf l pg ph">document.addEventListener(visibilityChange, () =&gt; {<br/> if(!document[hidden]) {<br/>   <strong class="oz iu">// Ensure connectivity</strong> <br/> }<br/>}, false)</span></pre><blockquote class="pi pj pk"><p id="b5cd" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">当切换标签或最小化浏览器时，监听器将被触发</p></blockquote><p id="d970" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">页面可见性API得到了广泛的<a class="ae le" href="https://caniuse.com/pagevisibility" rel="noopener ugc nofollow" target="_blank">支持</a>，但是那些不支持它的浏览器可以使用替代的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onblur" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> onblur </strong> </a>和<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/focus_event" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> onfocus </strong> </a>事件来代替。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qb"><img src="../Images/837a7740906e0325281ef60bb6d60cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L05rE4XkR3Cx6u5c6Zx2zQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">页面生命周期<a class="ae le" href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api" rel="noopener ugc nofollow" target="_blank"> API </a></figcaption></figure><p id="a971" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，这些事件会通知您<strong class="kk iu">用户是否切换了窗口，但这并不一定意味着它是隐藏的</strong>。只有当用户切换选项卡或最小化包含该选项卡的浏览器窗口时，页面才会隐藏。</p><blockquote class="pi pj pk"><p id="5781" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">或者，你也可以尝试使用<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/pagehide_event" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">页面隐藏</strong> </a>和<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/pageshow_event" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">页面显示</strong> </a>事件，但是在触发事件时要考虑它们的局限性</p></blockquote><p id="44eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您提供一个移动应用程序，您将需要基于您的移动技术实现类似的API。</p><blockquote class="np"><p id="d3e3" class="nq nr it bd ns nt nu nv nw nx ny ld dk translated">在本地移动平台上，基于操作系统，后台应用程序或其连接可能会被系统终止，以节省资源</p></blockquote><p id="cc3b" class="pw-post-body-paragraph ki kj it kk b kl oq ju kn ko or jx kq kr os kt ku kv ot kx ky kz ou lb lc ld im bi translated">例如，基于Cordova或Capacitor的应用程序可以使用<a class="ae le" href="https://cordova.apache.org/docs/en/latest/cordova/events/events.html#pause" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">暂停</strong> </a>和<a class="ae le" href="https://cordova.apache.org/docs/en/latest/cordova/events/events.html#resume" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">恢复</strong> </a>事件来控制应用程序的可见性。</p><p id="74de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Android应用程序可以通过<a class="ae le" href="https://developer.android.com/guide/components/activities/activity-lifecycle#onpause" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> onPause </strong> </a>和<a class="ae le" href="https://developer.android.com/guide/components/activities/activity-lifecycle#onresume" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">on resume</strong></a>activity life cycle方法来跟踪它，在iOS上可以使用<a class="ae le" href="https://developer.apple.com/documentation/uikit/uiapplication/1622944-willenterforegroundnotification" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">前台</strong> </a>通知和<a class="ae le" href="https://developer.apple.com/documentation/uikit/uiapplication/1623003-applicationstate" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">应用状态</strong> </a>之间的组合。</p><blockquote class="pi pj pk"><p id="686c" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">一个WWDC 2020 <a class="ae le" href="https://developer.apple.com/videos/play/wwdc2020/10078/" rel="noopener ugc nofollow" target="_blank">视频</a>解释了你的应用程序可能被杀死的主要原因</p></blockquote><h1 id="83e2" class="mq mr it bd ms mt pw mv mw mx px mz na jz py ka nc kc pz kd ne kf qa kg ng nh bi translated">4.网络状态</h1><p id="a02c" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">在手机上，用户可能会因为一些原因暂时失去连接，所以你需要考虑这些情况。</p><p id="ee82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，您可以通过收听<strong class="kk iu">在线/离线</strong> <a class="ae le" href="https://developer.mozilla.org/en-US/docs/web/api/navigator/online" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">事件</strong> </a>来检测应用程序是否在线，并采取相应措施:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="74c2" class="nz mr it oz b gy pe pf l pg ph">window.addEventListener('online',  event =&gt; {<br/>  <strong class="oz iu">// Ensure connectivity<br/></strong>})</span></pre><p id="5b68" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不是特别相关，但是如果您想收集关于用户行为的统计数据，您可以使用网络监听器或页面可见性API以及<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> sendBeacon </strong> </a>方法:</p><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="4d61" class="nz mr it oz b gy pe pf l pg ph">window.addEventListener('offline',  event =&gt; {<br/>  navigator.sendBeacon('/info', data)<br/>})</span></pre><p id="372d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该方法<strong class="kk iu">在用户代理有机会时异步传输数据</strong>，<strong class="kk iu">而不阻止卸载文档</strong>。</p><h1 id="8305" class="mq mr it bd ms mt pw mv mw mx px mz na jz py ka nc kc pz kd ne kf qa kg ng nh bi translated">5.插座配置</h1><p id="71d8" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">如前所述，WebSocket是客户机和服务器之间的一个开放的TCP连接。</p><h2 id="929e" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated">关系</h2><p id="ebdf" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">默认情况下，像<code class="fe ow ox oy oz b">SocketIO</code>这样的套接字引擎使用<strong class="kk iu">多路复用</strong>，这意味着你可以在一个共享连接上拥有<strong class="kk iu">几个通信通道</strong>(又名<a class="ae le" href="https://socket.io/docs/v4/namespaces/" rel="noopener ugc nofollow" target="_blank">名称空间</a> ) <strong class="kk iu">。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qc"><img src="../Images/471842bd59acdecbf80d3dc5c6032dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rkzBYndlGMAHmJSE6uH-w.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">检查本地<a class="ae le" href="https://echo.websocket.events/.ws" rel="noopener ugc nofollow" target="_blank">插座</a>示例</figcaption></figure><p id="b3cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当连接断开时，你的应用将停止获取所有频道的新内容。</p><p id="b01b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在启动连接时设置配置标志<code class="fe ow ox oy oz b"><em class="nn">forceNew: true</em></code>将会改变这种情况，从而<strong class="kk iu">获得每个名称空间</strong>的独立套接字连接(在这种情况下，您将在devTools中看到与单个套接字连接一样多的WebSockets条目)</p><blockquote class="pi pj pk"><p id="cd2e" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">如果你好奇的话，你可以分别通过<code class="fe ow ox oy oz b">chrome://net-export</code>和<code class="fe ow ox oy oz b">https://netlog-viewer.appspot.com</code>来记录和加载低级别的网络活动</p></blockquote><h2 id="d4a2" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated">版本匹配</h2><p id="dba6" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">继续使用套接字引擎，始终确保客户端和服务器使用相同的版本。此类协议定义了双方之间交换的数据包的格式，因此需要匹配才能相互理解。</p><blockquote class="pi pj pk"><p id="12f3" class="ki kj nn kk b kl km ju kn ko kp jx kq pl ks kt ku pm kw kx ky pn la lb lc ld im bi translated">像<a class="ae le" href="https://www.piesocket.com/websocket-tester" rel="noopener ugc nofollow" target="_blank"> PieSocket </a>这样的工具可以帮助您测试与本地WS或不同socketIO版本的服务器连接</p></blockquote><h2 id="d832" class="nz mr it bd ms oa ol dn mw oc om dp na kr on of nc kv oo oh ne kz op oj ng ok bi translated">事件处理程序和重新连接</h2><p id="600e" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">这似乎是显而易见的，但是请倾听由协议触发的合适的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#events" rel="noopener ugc nofollow" target="_blank">事件</a>，并始终根据您的解决方案相应地处理重新连接。</p><p id="9913" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑诸如重新连接之间的<em class="nn">延迟</em>、<em class="nn">最大重试次数</em>、<em class="nn">连接超时</em>等方面，以避免在意外情况下服务器过载。</p><p id="71a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还要记住你的socket引擎在失去连接后是否会自动重新加入房间，所以如果需要的话<strong class="kk iu">确保你的系统支持并在连接重新建立后正确解决这种情况</strong>。</p><h1 id="3ff0" class="mq mr it bd ms mt pw mv mw mx px mz na jz py ka nc kc pz kd ne kf qa kg ng nh bi translated">结论</h1><p id="3d87" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">总结我们只是强调了处理WebSockets时需要考虑的几点。</p><p id="4c78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的来说，在确保这种技术是适合你的情况的解决方案后，试着进一步思考，并根据你的应用程序的性质提出潜在的极限情况。</p><p id="320c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，说到实时通信，如果你也想深入研究其他流技术，比如<a class="ae le" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> WebRTC </strong> </a>，可以看看我以前的文章！😁</p><div class="qd qe gp gr qf qg"><a rel="noopener  ugc nofollow" target="_blank" href="/build-your-own-video-chat-with-vue-webrtc-socketio-node-redis-eb51b78f9f55"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd iu gy z fp ql fr fs qm fu fw is bi translated">使用Vue、WebRTC、SocketIO、Node &amp; Redis构建您自己的视频聊天</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">通过水平缩放构建多房间视频聊天</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="qp l"><div class="qq l qr qs qt qp qu lp qg"/></div></div></a></div><div class="qd qe gp gr qf qg"><a rel="noopener  ugc nofollow" target="_blank" href="/multiparty-video-conference-using-vue-webrtc-socketio-node-redis-e8c5a059d332"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd iu gy z fp ql fr fs qm fu fw is bi translated">使用Vue、WebRTC、SocketIO、Node和Redis的多方视频会议</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">第二部分:对等网格体系结构</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="qp l"><div class="qv l qr qs qt qp qu lp qg"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="51bf" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">分级编码</h1><pre class="lg lh li lj gt pa oz pb pc aw pd bi"><span id="2137" class="nz mr it oz b gy pe pf l pg ph">Thanks for being a part of our community! More content in the <a class="ae le" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">Level Up Coding publication</a>.<br/>Follow: <a class="ae le" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae le" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae le" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">Newsletter</a></span></pre><p id="2492" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">升一级正在改造理工大招募➡️ </strong> <a class="ae le" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>