<html>
<head>
<title>Scala Beginner Series (2) : Object Oriented Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala初学者系列(2):面向对象的Scala</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-beginner-series-2-object-oriented-scala-4e2496ec2e9f?source=collection_archive---------6-----------------------#2020-09-03">https://levelup.gitconnected.com/scala-beginner-series-2-object-oriented-scala-4e2496ec2e9f?source=collection_archive---------6-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/703cc91a377a5aa528f8ef47d70dc08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QC70bnA7fMXDhiut.png"/></div></div></figure><blockquote class="jy jz ka"><p id="93fd" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个系列讲的都是Scala的味道。<br/>最适合所有Scala新手。</p><p id="2deb" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能也喜欢:<a class="ae la" href="https://dzone.com/articles/scala-beginner-series1-basics" rel="noopener ugc nofollow" target="_blank"> Scala初学者系列(一) :基础知识</a></p></blockquote><p id="4b4f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在<a class="ae la" href="https://dzone.com/articles/scala-beginner-series1-basics" rel="noopener ugc nofollow" target="_blank">之前的</a>部分，我们介绍了:</p><ul class=""><li id="53e5" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">值、变量、表达式和类型</li><li id="ba1d" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">函数和递归</li><li id="dbd0" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">单位类型</li></ul><p id="17f3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">本文将介绍Scala语言面向对象的本质。</p><h1 id="1334" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">班级</h1><p id="3311" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala拥有和其他语言一样的类概念。</p><p id="394a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">Scala中的类是创建对象的蓝图。它们可以包含方法、值、变量、对象、特征和超类，统称为成员。与其他语言类似，使用点运算符访问字段和方法。</p><p id="f730" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">此外，类的所有字段和方法在默认情况下都是公共的，除非我们用<code class="fe mv mw mx my b">private</code>和<code class="fe mv mw mx my b">protected</code>修饰符限制它们的可见性。我们不必明确指定<code class="fe mv mw mx my b">public </code>访问修饰符。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/707929e7a480d5b108f007a5ffe0c1bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/0*EH1762mFMhJHH403.png"/></div></figure><p id="ddb8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最小的类定义只是关键字<code class="fe mv mw mx my b">class</code>和一个标识符。关键字<code class="fe mv mw mx my b">new</code>用于创建类的一个实例。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9da0d41c4b1a7f7744051291e167958e.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/0*QpRmSqGZiPvCt1wd.png"/></div></figure><h1 id="6281" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">构造器</h1><p id="fe85" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala中的类可以接受参数——这些是构造函数的参数。当我们定义一个类时，我们也可以定义它的构造函数签名。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4f8913c217d4603a8bc916227a2ef774.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/0*9XUFVnzFIRI-VLv2.png"/></div></figure><p id="961c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">注意构造函数参数<strong class="ke ir"> </strong>不是类字段。没有<code class="fe mv mw mx my b">val</code>或<code class="fe mv mw mx my b">var</code>的参数是私有值，只在类中可见。因此，下面的代码将生成错误:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/761a7f90232b5c23a4de4d34cc93789f.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/0*qxTDiMAd2nIXS6r9.png"/></div></figure><p id="60ec" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">因此，为了将构造函数参数提升到类字段，我们可以在参数名称前加上一个<code class="fe mv mw mx my b">val</code>或<code class="fe mv mw mx my b">var</code>。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/66403065b930a15a8c5f0f0fc2e87bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*Sr2P0z5Y6S4FCdur.png"/></div></figure><h1 id="daf1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">遗产</h1><p id="dd3d" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">当一个类从另一个类继承时，意味着它扩展了另一个类。这使得一个类可以从它扩展的类中继承成员，并提供代码的可重用性。</p><p id="eddd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">为了实现Scala继承，我们使用关键字<code class="fe mv mw mx my b">extends</code>:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/939e4c06069845c77718c74d7914d93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/0*Jd4LjwqvhhwCW_0S.png"/></div></figure><p id="a3ce" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在上面两个类的例子中，<code class="fe mv mw mx my b">Person </code>类是基类或超类，<code class="fe mv mw mx my b">Employee</code>类是派生类或子类。</p><p id="bfab" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><code class="fe mv mw mx my b">extends </code>条款有两个作用:</p><ul class=""><li id="5aa7" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">它使<code class="fe mv mw mx my b">Employee </code>类继承<code class="fe mv mw mx my b">Person </code>类的所有非私有成员</li><li id="76b5" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">它使类型<code class="fe mv mw mx my b"> Employee </code>成为类型<code class="fe mv mw mx my b">Person </code>的子类型。</li></ul><p id="1b24" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">Scala也像Java一样只允许单一类继承。</p><p id="472f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">Scala拥有和我们在其他静态类型的面向对象语言中看到的相同的子类型多态性。在子类型多态性中，子类的实例可以传递给基类。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/efa31ace9284ef680506adc499bacc0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*mPXqttV9apAtXk9e.png"/></div></figure><p id="4df0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在编译时，编译器只知道我们正在调用<code class="fe mv mw mx my b">Element </code>对象的<code class="fe mv mw mx my b">demo()</code>方法。但是在运行时，最派生的方法即<code class="fe mv mw mx my b">ArrayElement</code>的<code class="fe mv mw mx my b">demo()</code>方法被调用。当然，派生类可以重写它们的超类方法。</p><h1 id="dc66" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">抽象类</h1><p id="5667" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala还有一个抽象类的概念，类似于Java的抽象类，既包含抽象方法，也包含非抽象方法，不能支持多重继承。它们也不能被实例化。</p><p id="240e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">为了实现Scala抽象类，我们对它的声明使用了关键字<code class="fe mv mw mx my b">abstract </code>:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/cba66d90209f6d55078eb9dd25c73903.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*0GUSSRVuNKWS8mEq.png"/></div></figure><p id="5d64" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">子实现父类的所有抽象方法也是强制性的。抽象类的抽象方法是那些不包含任何实现的方法。</p><h1 id="0bf1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">特征</h1><p id="7d6b" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala的特性类似于Java的接口。类和对象可以扩展特征，但是特征不能被实例化，因此没有参数。</p><p id="2231" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">特征就像部分实现的接口。它可能包含抽象和非抽象方法。有可能所有方法都是抽象的，但它至少应该有一个抽象方法。</p><p id="8024" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">扩展特征的类必须实现特征的抽象方法，但不需要实现特征的具体方法。</p><p id="0522" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">为了定义trait，我们使用了<code class="fe mv mw mx my b">trait </code>关键字:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/27d03f90d69b0e6d94b67bbfc8804c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/0*SX03t5d7dtZ2CzsB.png"/></div></figure><p id="512b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">Scala具有单类继承和多性状混合。可以用一个类或一个抽象类来扩展任意数量的Scala特征。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4ce121f00e6fbf2e35d66a0ff2cc11e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/0*Yg8CrxUKbLgL3i9Q.png"/></div></figure><h1 id="f2b7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">匿名类</h1><p id="78f4" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala也有匿名类的概念，很像Java。</p><p id="3421" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们已经看到了如何实现父类声明的方法。为父类的方法提供实现的一种不太正式的方式是使用匿名类，一种不可重用的无名类定义。</p><p id="9918" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">要定义一个一次性的匿名类，实例化父类(可能是抽象的),在类名和参数后面加上包含实现的花括号。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/41dfc0d790de708dfa0f7a96df86066c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/0*o_FyzMnnvrSkhvJl.png"/></div></figure><p id="0b02" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">结果是一个实例，它用一次性实现扩展了给定的父类，但可以像传统类定义中的实例一样使用。</p><p id="195b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">对于编译器来说，匿名类看起来像这样:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/a4f76e9430c43aff58d33d540cd77101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bD2_Jth5nu5CwUlG.png"/></div></div></figure><p id="f6e1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">对于匿名类，编译器在幕后做了大量的工作。这允许我们从代码中抽象出复杂性。</p><h1 id="9609" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">单一对象</h1><p id="61e6" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala中没有<code class="fe mv mw mx my b">static </code>的概念，取而代之的是单例对象。</p><p id="5901" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">对象是一个只有一个实例的类。它是在被引用时被延迟创建的，就像一个延迟val。在singleton对象中声明的方法和字段是全局可访问的，我们不需要一个对象来访问它们。我们可以从程序中的任何地方导入它们。此外，我们不能将参数传递给它的主构造函数。</p><p id="0ae8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">使用关键字<code class="fe mv mw mx my b">object</code>声明一个单例对象:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ca607c0ada3ab0a151cf2ca401b788ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/0*ATjWih43hNutp5SH.png"/></div></figure><p id="bf5d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">单例对象可以扩展类和特征。它还为程序执行提供了一个入口。如果没有这样的对象，代码可以编译，但不会产生输出。</p><h1 id="eba1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">伴随物体</h1><p id="2990" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">当一个单例对象的名字和一个类的名字相同时，它被称为一个伴随对象，而这个类被称为伴随类。相伴的类对象对必须在单个源文件中。这对成员中的任何一个都可以访问其同伴的私有成员。我们对不特定于companion类实例的方法和值使用companion对象。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/6ad054d543c1f2ce7a55f3c3d953784a.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/0*iQxUzwleaZ81iefs.png"/></div></figure><p id="e32d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我在这里进入了<code class="fe mv mw mx my b">:paste</code>模式，因为我在<code class="fe mv mw mx my b">REPL</code>工作。由于同伴需要在同一个源文件中，所以<code class="fe mv mw mx my b">REPL</code>中的<code class="fe mv mw mx my b">:paste</code>模式允许同伴一起定义。</p><p id="21cc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><code class="fe mv mw mx my b">static</code>Java中的成员被建模为Scala中一个伴随对象的普通成员。</p><h1 id="0488" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">该应用方法</h1><p id="e100" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala类和Scala对象都提供了一个默认方法，我们称之为<code class="fe mv mw mx my b">apply </code>方法。我们有时称之为注射器法。我们也可以在没有名字的情况下调用这个方法。让我告诉你我的意思:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/b5f74ff343b6e448ebda7b5f9d1205a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s-O7CNLrNvlf4kvJ.png"/></div></div></figure><p id="144b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">记住，<code class="fe mv mw mx my b">apply</code>只是一个特殊的函数，让我们像函数一样直接调用父对象。它与面向对象、类或构造函数毫无关系。</p><p id="2954" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们可以在伴随对象中使用apply作为工厂方法。工厂方法的思想是在没有<code class="fe mv mw mx my b">new</code>的情况下构造类实例。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/76b6deddb2a6653b21bc237b67de6721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/0*1KsOXy2cXaAIgYCY.png"/></div></figure><h1 id="618d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">案例类别</h1><p id="94bd" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala case类就像普通类一样，有一些关键的区别，我们将会谈到。当编译器看到<code class="fe mv mw mx my b">class</code>前面的<code class="fe mv mw mx my b">case</code>关键字时，它会为我们生成代码，有以下好处:</p><ul class=""><li id="515d" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">Scala case类在默认情况下是不可变的，并且可以通过模式匹配进行分解。</li><li id="6911" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">它不使用<code class="fe mv mw mx my b">new </code>关键字实例化对象。这是因为默认情况下case类有一个<code class="fe mv mw mx my b">apply</code>方法负责对象的构造。</li></ul><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/4a2c8b010be79658a6c91839748a7da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*d-apEWS5fHPcGYZf.png"/></div></figure><ul class=""><li id="5c9f" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">生成了一个<code class="fe mv mw mx my b">unapply</code>方法，让我们在<code class="fe mv mw mx my b">match</code>表达式中以更多的方式使用case类。</li><li id="0a87" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">生成一个默认的<code class="fe mv mw mx my b">toString</code>方法，有助于调试。</li><li id="98cc" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">产生了<code class="fe mv mw mx my b">equals</code>和<code class="fe mv mw mx my b">hashCode</code>方法，它们让我们可以比较对象，并在地图中轻松地将它们用作键。它用于检查所有单个成员字段的值是否相等，而不仅仅是检查对象的引用是否相等。</li></ul><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/352b5af5057f20d11d261b3b51ee5800.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*6aN9UP2DvdEY8y4j.png"/></div></figure><ul class=""><li id="afc3" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">我们可以简单地通过使用<code class="fe mv mw mx my b">copy</code>方法创建一个case类实例的浅层副本。我们也可以改变构造函数的参数。</li></ul><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/376f2d0970881ec0c79555148909cecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/0*sSfa6ImYeJKmz2-k.png"/></div></figure><ul class=""><li id="ea8b" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">默认情况下，case类中列出的所有参数都是公共的和<code class="fe mv mw mx my b">val </code>。可以在case类中使用<code class="fe mv mw mx my b">var</code>,但不鼓励这样做。</li></ul><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3ee61e04424653aad1ffa5b467bf9efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/0*UcSV8yha8Ocj4XAw.png"/></div></figure><h1 id="7cf5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">案例对象</h1><p id="b104" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">一个<code class="fe mv mw mx my b">case object</code>就像一个<code class="fe mv mw mx my b">object</code>，但是就像一个case类比一个常规类拥有更多的特性一样，一个case对象比一个常规对象拥有更多的特性。其特点包括:</p><ul class=""><li id="13a3" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">它是可序列化的</li><li id="55eb" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">它有一个默认的<code class="fe mv mw mx my b">hashCode</code>实现</li><li id="ed98" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">它具有改进的<code class="fe mv mw mx my b">toString</code>实现</li></ul><p id="aef7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">case类和case对象最大的优点是支持模式匹配。模式匹配是函数式编程语言的一个主要特性，Scala的case类和对象提供了一种在匹配表达式和其他领域实现模式匹配的简单方法。</p><blockquote class="jy jz ka"><p id="f395" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">你可能也喜欢:</em> <a class="ae la" href="https://medium.com/swlh/pattern-match-anything-in-scala-3a22f5d3535" rel="noopener"> <em class="iq">模式匹配Scala中的任何东西</em> </a></p></blockquote></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="97f0" class="ls lt iq bd lu lv ob lx ly lz oc mb mc md od mf mg mh oe mj mk ml of mn mo mp bi translated">类似文章-</h1><p id="08bd" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">你也可以查看我在<em class="kd"> Scala初学者系列</em>上的其他文章</p><ul class=""><li id="39f6" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-1-basics-d1dae1f3458d"> Scala初学者系列(1):基础知识</a></li><li id="8a82" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-3-functional-scala-eedd9090a3ac"> Scala初学者系列(三) :函数式Scala </a></li></ul></div></div>    
</body>
</html>