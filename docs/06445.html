<html>
<head>
<title>REST API Fuzzing with Microsoft RESTLer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微软RESTLer的REST API Fuzzing</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rest-api-fuzzing-with-microsoft-restler-7184053e2205?source=collection_archive---------4-----------------------#2020-11-25">https://levelup.gitconnected.com/rest-api-fuzzing-with-microsoft-restler-7184053e2205?source=collection_archive---------4-----------------------#2020-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e4db31ad5ea62c222a6745d449cc6021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R5JqsgnJDsikQ17C"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@tumbao1949?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> James Wainscoat </a>拍摄</figcaption></figure><p id="9a7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> F </span> resh来自<strong class="kf ir">微软研究院</strong>,<strong class="kf ir">RESTLer</strong><strong class="kf ir">fuzzer</strong>是一个新的REST fuzzing工具，它依靠一个<strong class="kf ir">open API</strong>/<strong class="kf ir">Swagger</strong>规范来创建并执行对所选API的测试。</p><p id="319c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模糊化允许我们通过用随机输入测试我们的应用程序来发现错误。它帮助开发者提高程序的<strong class="kf ir">健壮性</strong>、<strong class="kf ir">安全性</strong>和<strong class="kf ir">整体质量</strong>。由于它基本上是自动化的，它让开发者在运行的时候可以自由地编写代码。RESTLer给了我们所有这些好处。</p><p id="741f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个关键点表明了这个工具的好处:首先，它可以推断请求<strong class="kf ir"><em class="lk"/></strong>的依赖关系，也就是说，它可以推断一个请求的资源作为另一个请求的输入参数是必要的；其次，它有一个<strong class="kf ir"> <em class="lk">动态反馈</em> </strong> <em class="lk">，</em>意为工具可以分析以前的结果来预测无效的请求流，即。:做请求X和Y，会引起请求z的拒绝。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="c84e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将介绍该工具的设置和执行，但第一步是获得一个应用程序来运行我们的测试，您可以使用您选择的应用程序，但在本教程中，我们将使用<a class="ae kc" href="https://github.com/swagger-api/swagger-petstore" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">Swagger pet store</strong></a>，这是由Swagger团队提供的一个示例，用于演示it功能。</p><p id="89b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，如果您还没有设置Java环境，那么您需要设置Java环境。你需要一个<strong class="kf ir"> Java SDK </strong>，如果你使用的是Windows，你可以简单的使用<a class="ae kc" href="https://www.oracle.com/java/technologies/javase/jdk8-readme.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">Oracle Java SDK</strong></a>。本教程将提供在Windows上运行的命令，因为RESTLer目前提供了更好的支持。</p><p id="2691" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还需要<a class="ae kc" href="https://maven.apache.org/download.cgi" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Maven </strong> </a>来安装项目依赖项并运行服务器。记得设置好你的<strong class="kf ir"> JAVA_HOME </strong>和<strong class="kf ir"> maven </strong>环境变量，你可以用<a class="ae kc" href="https://mkyong.com/maven/how-to-install-maven-in-windows/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a><strong class="kf ir"/>条来走完这个过程。</p><p id="eddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在克隆上面提供的<strong class="kf ir"> Swagger Petstore </strong> GitHub存储库，打开您的终端，<strong class="kf ir"> <em class="lk"> cd </em> </strong>到存储库文件夹，并运行它:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="84c4" class="mb mc iq lx b gy md me l mf mg"><strong class="lx ir">mvn package jetty:run</strong></span></pre><p id="e056" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下载所有的依赖项需要一些时间，但是之后你就有了一个可以访问的工作服务器。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="9e1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将设置<strong class="kf ir"> RESTLer </strong>本身。这要看<a class="ae kc" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Python </strong> </a>了，一定要有版本<strong class="kf ir"> 3.8.2 </strong>以上，还有<a class="ae kc" href="https://dotnet.microsoft.com/download/dotnet-core?utm_source=getdotnetcorecli&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">。网芯SDK </strong> </a> <strong class="kf ir"> </strong>版本<strong class="kf ir"> 3.1 </strong>。</p><p id="cd0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">克隆<a class="ae kc" href="https://github.com/microsoft/restler-fuzzer" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">RESTLer Fuzzer</strong></a>GitHub库。我们需要编译RESTLer，因为二进制drops还不可用。在<strong class="kf ir">终端</strong>在库文件夹<strong class="kf ir">中打开的情况下，运行</strong>:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5835" class="mb mc iq lx b gy md me l mf mg"><strong class="lx ir">mkdir restler_bin</strong></span><span id="3a96" class="mb mc iq lx b gy mh me l mf mg"><strong class="lx ir">python ./build-restler.py --dest_dir</strong> &lt;full path to restler_bin&gt;</span></pre><p id="78dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">务必始终给<strong class="kf ir">完整路径</strong>，否则RESTLer可能无法正常工作。RESTLer现在编译在<strong class="kf ir"><em class="lk">RESTLer _ bin</em></strong><em class="lk"/>文件夹下。</p><p id="2051" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，是API的语法的编译，我们需要<strong class="kf ir"> Swagger规范</strong>。在Swagger Petstore webserver运行的情况下，在浏览器上转到<a class="ae kc" href="http://localhost:8080/api/v3/openapi.json" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">localhost:8080/API/v3/open API . JSON</strong></a>并下载文件。由于本地web服务器的目标端口是8080，我们需要更新JSON中的“servers”属性。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="cc0b" class="mb mc iq lx b gy md me l mf mg">{<br/>"servers": [{"url":"localhost:8080/api/v3"}]<br/>}</span></pre><p id="745b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"><em class="lk">restler _ bin/restler</em></strong><em class="lk"/>文件夹内<strong class="kf ir">运行</strong>:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="eca2" class="mb mc iq lx b gy md me l mf mg"><strong class="lx ir">./restler compile --api_spec</strong> &lt;full path to openapi.json&gt;</span></pre><p id="37f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将使用我们的<strong class="kf ir">语法</strong>创建一个<strong class="kf ir"> <em class="lk">编译</em> </strong>目录，下一步将使用<strong class="kf ir"> <em class="lk"> grammar.py </em> </strong>，<strong class="kf ir"> <em class="lk"> dict.json </em> </strong>，<strong class="kf ir"><em class="lk">engine _ settings . JSON</em></strong>文件。<strong class="kf ir"> </strong>我们现在可以<strong class="kf ir">测试</strong>如果语法有效，测试命令将在所有端点上执行快速测试，并显示测试的覆盖范围。<strong class="kf ir">运行<strong class="kf ir">中的<em class="lk"> restler_bin/restler: </em>中的</strong></strong></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="dcf3" class="mb mc iq lx b gy md me l mf mg"><strong class="lx ir">.\restler test --grammar_file</strong> &lt;full path to grammar.py&gt; <strong class="lx ir">--dictionary_fil</strong>e &lt;full path to dict.json&gt; <strong class="lx ir">--settings</strong> &lt;full path to engine_settings.json&gt; <strong class="lx ir">--no_ssl</strong></span></pre><p id="729c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果我们得到了一个<strong class="kf ir">请求覆盖</strong>，这表明了在测试运行中有效请求的<strong class="kf ir">数量，如果你想在你的应用中改进它，在<a class="ae kc" href="https://github.com/microsoft/restler-fuzzer/blob/6b906d03ac13e12936d6ec6be21e8f5e00d77b8e/docs/user-guide/ImprovingCoverage.md" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上有一个用户指南。</strong></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9888" class="mb mc iq lx b gy md me l mf mg">Request coverage (successful / total): 9 / 19</span></pre></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="3db8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说到精彩的部分，我们已经准备好模糊我们的应用程序。RESTLer上有两个设置可供您使用。正如GitHub上的团队所描述的:</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="fe65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Fuzz-lean </strong>:在编译好的RESTler语法中，每个endpoint+方法执行一次，使用一组默认的检查器，看看是否可以快速找到bug。</p><p id="bb9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">Fuzz</strong>:bug hunting——在智能广度优先搜索模式(深度搜索模式)下探索RESTler fuzzing语法，以找到更多bug。<strong class="kf ir">警告</strong>:这种类型的模糊更具攻击性，如果服务实现不佳，可能会导致测试中的服务中断(例如，模糊可能会导致资源泄漏、性能下降、后端损坏等)。).</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="43e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们是在本地运行一个样本代码，这个警告不会影响我们，但是<strong class="kf ir">请小心</strong>，如果你的目标是一个不属于你的部署应用，请不要运行RESTLer。</p><p id="394e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">模糊-倾斜</strong>和<strong class="kf ir">模糊</strong>模式的命令分别为:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2c20" class="mb mc iq lx b gy md me l mf mg"><strong class="lx ir">.\restler fuzz-lean --grammar_file</strong> &lt;full path to grammar.py&gt; <strong class="lx ir">--dictionary_file</strong> &lt;full path to dict.json&gt; <strong class="lx ir">--settings</strong> &lt;full path to engine_settings.json&gt; <strong class="lx ir">--no_ssl</strong></span><span id="d22e" class="mb mc iq lx b gy mh me l mf mg"><strong class="lx ir">.\restler fuzz --grammar_file</strong> &lt;full path to grammar.py&gt; <strong class="lx ir">--dictionary_file</strong> &lt;full path to dict.json&gt;<strong class="lx ir"> --settings</strong> &lt;full path to engine_settings.json&gt; <strong class="lx ir">--no_ssl --time_budget</strong> &lt;time in hours to run&gt;</span></pre><p id="25c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当运行结束时，RESTLer将打印<strong class="kf ir">覆盖结果</strong>，以及错误的总数。所有<strong class="kf ir">被调试的请求序列</strong>将被放置在:<strong class="kf ir"> <em class="lk"> FuzzLean </em> </strong>或<strong class="kf ir"> <em class="lk"> Fuzz </em> </strong>文件夹中。我的1小时模糊运行给出了这个结果:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="85d8" class="mb mc iq lx b gy md me l mf mg">PayloadBodyChecker_500: 33</span><span id="7ae0" class="mb mc iq lx b gy mh me l mf mg">main_driver_500: 10</span></pre><p id="71a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，上面的<strong class="kf ir"><em class="lk">PayloadBodyChecker</em></strong>是什么呢？<strong class="kf ir">雷斯特勒的检查员完全按照他们说的去做。这些<strong class="kf ir">与正常的模糊化一起运行，可以检查是否有更多的bug</strong>，每个都以不同的逻辑运行。在我们的例子中，它检测到33个bug<strong class="kf ir">直接模糊了我们请求的<strong class="kf ir"> JSON主体</strong>。其他<strong class="kf ir"> 10个bug</strong>是在正常的fuzzing运行中发现的，每次有<strong class="kf ir"> 500 </strong> <strong class="kf ir">响应</strong>就会被当作一个bug处理。</strong></strong></p><p id="55cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看我们的<strong class="kf ir"> bug buckets </strong>，在<strong class="kf ir"><em class="lk">Fuzz/restler results/experiment&lt;…&gt;/bug _ buckets</em></strong>里面是所有被bug的请求以及它们各自的响应的集合。看看<strong class="kf ir"><em class="lk">main _ driver _ 500 _ 1 . txt</em></strong>文件:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="fdbd" class="mb mc iq lx b gy md me l mf mg"><strong class="lx ir">...</strong></span><span id="3da2" class="mb mc iq lx b gy mh me l mf mg">-&gt; POST /api/v3/user HTTP/1.1\r\nAccept: application/json\r\nHost: localhost:8080\r\nContent-Type: application/json\r\n\r\n{\n    "id":0,\n    "username":"fuzzstring",\n    "firstName":"fuzzstring",\n    "lastName":"fuzzstring",\n    "email":"fuzzstring",\n    "password":"fuzzstring",\n    "phone":"fuzzstring",\n    "userStatus":0}\r\n</span><span id="a419" class="mb mc iq lx b gy mh me l mf mg">! producer_timing_delay 0</span><span id="1e71" class="mb mc iq lx b gy mh me l mf mg">! max_async_wait_time 20</span><span id="71e4" class="mb mc iq lx b gy mh me l mf mg">PREVIOUS RESPONSE: 'HTTP/1.1 500 Internal Server Error\r\nDate: Sun, 22 Nov 2020 19:36:09 GMT\r\nAccess-Control-Allow-Origin: *\r\nAccess-Control-Allow-Methods: GET, POST, DELETE, PUT\r\nAccess-Control-Allow-Headers: Content-Type, api_key, Authorization\r\nAccess-Control-Expose-Headers: Content-Disposition\r\nContent-Type: application/json\r\nContent-Length: 110\r\nServer: Jetty(9.4.9.v20180320)\r\n\r\n{"code":500,"message":"There was an error processing your request. It has been logged (ID: 9b4a940aedfc92d9)"}'</span></pre><p id="2da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，上面的请求返回了一个<strong class="kf ir">内部服务器错误</strong>，RESTLer甚至为您提供了使用<strong class="kf ir">—replay _ log&lt;path _ to _ the _ log&gt;</strong>命令重放请求的选项。调试错误非常有用。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="0fd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，在设置了<strong class="kf ir"> RESTLer </strong>本身之后，很容易出错，给我们<strong class="kf ir">自动化的错误报告</strong>，这意味着我们的REST服务质量<strong class="kf ir">更好</strong>，可靠性<strong class="kf ir">更高</strong>和安全性<strong class="kf ir"/>，并且<strong class="kf ir">参与的工作很少</strong>。</p></div></div>    
</body>
</html>