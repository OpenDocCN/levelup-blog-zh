# 学习 C++:类构造函数

> 原文：<https://levelup.gitconnected.com/learning-c-class-constructors-2aacfd6b7ff7>

![](img/a1b539c7be7e4cdb645406f441abb65b.png)

照片由[洛根·韦弗](https://unsplash.com/@lgnwvr?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

类构造函数是一个函数，它将数据放入一个类对象中，并为一个类对象执行任何其他设置，这些设置需要在类对象第一次被实例化时执行。在本文中，我将演示如何创建和使用几种不同类型的类构造函数。

我将演示如何使用我在上一篇文章中开发的类定义来创建和使用构造函数，上一篇文章是对 C++类的介绍。下面是我将要开始的类定义:

```
class Date {
private:
  int month, day, year;
  string adjustDate(int d) {
    string date;
    if (d < 10) {
      date = "0" + to_string(d);
    }
    else {
      date = to_string(d);
    }
    return date;
  }public:
  void display() {
    string date = adjustDate(month) + "/" + adjustDate(day)
                + "/" + adjustDate(year);
    cout << date;
  } void setMonth(int m) {
    month = m;
  } void setDay(int d) {
    day = d;
  } void setYear(int y) {
    year = y;
  }
};
```

# 构造函数概述

构造函数用于初始化类的成员变量，并在实例化类对象时执行任何其他需要执行的设置操作。根据类的需要，一个类可以有多个构造函数。构造函数必须与类同名。

大多数类需要两种类型的构造函数。第一种类型是默认构造函数。默认构造函数将所有类成员变量初始化为它们的默认值，因此整数变量得到 0，字符串变量得到空字符串，依此类推。

大多数类的第二种构造函数类型是完全参数化的构造函数。这个构造函数有这个名字，因为这个类的每个成员变量都有一个函数参数。

在这两个构造函数之间，根据类的需要可以有其他构造函数。例如，`Date`类可能会提供一个构造函数，它只设置月份和年份，并将日期设置为默认值。

# 默认构造函数

我将讨论的第一种构造函数是默认构造函数。默认构造函数为类的成员变量分配默认值。对于`Date`类，每个成员变量的值都是 0。下面是`Date`类的默认构造函数的一个定义:

```
Date() {
  month = 0;
  day = 0;
  year = 0;
}
```

我们可以使用在定义函数和类模板时常见的高级 C++特性来缩短这个定义。以下是更简短的定义:

```
Date() {
  month = day = year = {};
}
```

编译器将检查赋值语句左侧的变量类型，并将该类型的默认值赋给该变量。

下面是在实例化一个新的 `Date`对象时如何调用默认构造函数:

```
Date today;
```

在 C++中，如果你没有提供一个默认的构造函数，编译器会为你提供一个，但是你不想依赖它来获得准确的数据。下面是我在没有定义默认构造函数的情况下实例化一个新的 Date 对象时得到的输出:

```
75/08/67
```

很明显，这些不是整型变量的默认值，表明 C++访问了成员变量的内存位置，并返回那里的任何内容。这就是为什么你应该为你的 C++类提供一个默认的构造函数。

# 完全参数化的构造函数

第二种类型的构造函数是完全参数化的构造函数，这意味着每个成员变量都有一个函数参数。下面是`Date`类的这种构造函数的一个版本:

```
Date(int m, int d, int y) {
  month = m;
  day = d;
  year = y;
}
```

我会说这是一个准系统构造函数，因为它没有提供数据封装的好处，因为成员变量可以设置为任何有效的整数值。我们需要的是执行数据验证的私有成员函数。

我们已经用`setMonth`、`setDay`和`setYear`实现了这些功能。然而，我将更改`setDay`的定义，以演示如何在构造函数中进行数据验证。首先，这里是`setDay`的一个新定义，使用一个表查找来确定一个月中有多少天:

```
private:
…
int monthDays[12] = 
   {31, 28, 31, 30, 31, 30, 31, 31, 31, 31, 30, 31};
…public:
…
  void setDay(int m, int d) {
    int daysInMonth = monthDays[m-1];
    if (d > 0 && d <= daysInMonth) {
      day = d;
    }
    else {
      day = 1;
    }
  }
```

下面是添加了`setDay`的构造函数:

```
Date(int m, int d, int y) {
  month = m;
  setDay(m, d);
  year = y;
}
```

下面是测试构造函数的程序片段:

```
Date today(8,24,2020);
today.display();
Date tomorrow(8,32,2020);
tomorrow.display();
```

这个程序片段的输出是:

```
08/24/2020
08/01/2020
```

根据函数定义中的数据有效性规则，第二个日期将日期还原为 1。当然，这是一个任意的决定，这一天可以被设置为类设计者想要的任何时间。

# 参数化构造函数

如果参数列表与其他参数列表不同，可以重载类的构造函数。这意味着构造函数将有一些参数(至少一个),但不是像完全参数化构造函数中那样每个成员变量都有一个参数。这些类型的构造函数称为参数化构造函数。

我现在可以用两个参数和一个参数定义`Date`类构造函数。以下是它们的定义:

```
Date(int m, int y) {
  month = m;
  setDay(m, 0);
  year = y;
}Date(int y) {
  month = 0;
  setDay(0, 0);
  year = y;
}
```

当然，如果这是我投入生产的一个类，我会在那些定义中添加数据验证。

另一件要记住的事情是，您只需要提供使类有用所需的构造函数的数量。如果您想将构造函数的数量限制为一个默认构造函数和一个完全参数化的构造函数，这完全没问题。这个决定取决于班级和你的用户的需要。

# 复制构造函数

有时，您希望通过复制现有的类对象来创建新的类对象。您可以使用复制构造函数来实现这一点。这个构造函数将一个现有的类对象作为参数，并将其成员变量赋给正在构造的新对象。

下面是`Date`类的复制构造函数的定义:

```
Date(const Date &d1) {
  month = d1.month;
  setDay(month, d1.day);
  year = d1.year;
}
```

关于这个定义，有一些事情需要注意。首先，参数被定义为一个常量，这样函数就不会意外地对其进行更改。此外，参数通过引用传递，以使函数更有效。总是通过引用将类对象传递给函数是一个好主意。这节省了编译器在函数中使用完整对象之前必须复制该对象的开销。

下面是使用复制构造函数的一小段程序:

```
int main ()
{
  Date today(8,24,2020);
  today.display();
  Date tomorrow(today);
  tomorrow.display();
  return 0;
}
```

这个程序的输出是:

```
08/24/2020
08/24/2020
```

# 构造函数和类定义

构造函数是类定义的重要组成部分，应该小心设计和构建，因为这些函数定义了如何实例化新的类对象。您为一个类实现的类构造函数的数量和类型总是取决于该类和用户的需要，因为类是为用户使用而设计的。

我必须提到，我确实省略了一种类型的类构造函数，即 move 构造函数。一旦我们有了更多的设计和实现类的经验，我将在以后的文章中回来定义 move 构造函数做什么。

感谢您阅读这篇文章，请给我发电子邮件，地址是[mmmcmillan1@att.net](mailto:mmmcmillan1@att.net)，并提出意见和建议。如果你对我的在线编程课程感兴趣，请访问 https://learningcpp.teachable.com。