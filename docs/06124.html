<html>
<head>
<title>A Nearest Neighbor Solution in Go to the Traveling Salesman Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">旅行商问题的最近邻解法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-nearest-neighbor-solution-in-go-to-the-traveling-salesman-problem-d4d56125b571?source=collection_archive---------7-----------------------#2020-10-28">https://levelup.gitconnected.com/a-nearest-neighbor-solution-in-go-to-the-traveling-salesman-problem-d4d56125b571?source=collection_archive---------7-----------------------#2020-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/de997bf092fa908cf77b4ea5b4a86264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ldZa8csdjojTzQ4n5UpYQ.jpeg"/></div></div></figure><div class=""/><h1 id="3a3d" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">摘要</h1><p id="9370" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">介绍了最近邻算法的Go实现，包括路径图表和支持报告输出。一组圆形节点显示了该算法的实现相当精确。如参考文献6所述，该项目在gitlab上公开托管。</p><h1 id="5618" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="7c80" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个项目是使用最近邻(NN)算法对旅行推销员问题的近似解决方案。参考文献(4)对这个相对著名的计算机科学问题进行了非常详细的分析和讨论。这种解决方案被认为比维基百科(4)中提到的精确解决方案长大约25%。这个项目是在围棋中实现神经网络算法的一个练习，也可能是对基本神经网络算法的一些改进。</p><h1 id="a816" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">笔记</h1><p id="43db" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">关于该项目的说明:</p><ol class=""><li id="b009" class="lx ly je lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">从输出图表的随意检查中可以明显看出，该算法虽然执行起来很快，但在准确性方面不够理想。许多测试运行揭示了这一点，并激发了进一步测试的一些想法。</li><li id="4a35" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">在NN算法中，通过使用前瞻特征来考虑两个节点而不是单个节点，有可能提高精度。</li><li id="4a01" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">另一个改进可能是实现一个圆，使得通过比较节点与圆周上某点的距离来选择节点。</li><li id="947a" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">预计代码重组和图表改进。</li></ol><p id="2e36" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">起始节点不影响任何一组节点的总行进距离。原因是选择了同一组边，因为节点彼此之间相对位置的变化不会影响该节点到下一个节点的最短距离。</p><p id="6bba" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">一旦算法开始工作，首先想到的问题是如何证明它按照设计的那样工作。第一个解决方案是以27边多边形的形式计算26个节点，这些节点足够接近一个圆，以便将销售员的路线距离与由27条边组成的圆进行比较。圆的周长被计算并四舍五入到314，而推销员的路线被计算为313.18。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="cbd3" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">节点</h1><p id="adab" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">节点结构包括一个名称字符串和十进制的x，y值。小数(3)类型。我使用shopspring库(3)是为了方便、易用以及精确处理值。</p><p id="9d10" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">String() func应用于节点类型，允许方便地显示节点值。</p><p id="1fe1" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">主要功能从生成26个命名节点开始，这些节点的名称对应于NATO拼音字母；《阿尔法》、《布拉沃》、《查理》、《德尔塔》、《回声》、《狐步舞》、《高尔夫》、《酒店》、《印度》、《朱丽叶》、《基洛》、《利马》、《迈克》、《十一月》、《奥斯卡》、《爸爸》、《魁北克》、《罗密欧》、《塞拉》、《探戈》、《制服》、《维克多》、《威士忌》、《x光》(1)、《扬基》、《祖鲁》。这些节点被分配0到100之间随机生成的x和y坐标。</p><p id="9c05" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">26个节点的集合存储在一个map[string]节点中。映射键是节点名。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0d5c" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">通常这一代在我的联想W540 Thinkpad上需要大约300微秒，正如最近一次运行所报告的:</p><p id="16c9" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">在272.967秒内生成了26个带有0到100之间的随机x y数据点的命名节点</p><h1 id="ae7e" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">原始节点</h1><p id="cab4" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">原点节点origin node被标识为离x和y坐标的原点最近的节点。这由func FindOriginNode()执行，它计算每个节点到原点的距离，并保存较低值，直到检查完所有节点。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1715" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">程序从原点节点开始。如前所述，它对最终行进的距离没有影响。测试对此进行了检查，并且没有出现OriginNode的替代选择对输出产生影响的情况。</p><h1 id="ecc0" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">优势</h1><p id="958b" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Edge结构包括node1、node2字符串类型和长度类型decimal . decimal .<br/><br/>String()func应用于Edge类型，允许方便地显示值。<br/> <br/>应用于每个节点对的潜在边的集合是从节点x和y坐标生成的。回忆一下高中代数，x - y平面上两点之间的距离由公式d = sqrt((x1-x2)^2加(y1-y2)^2).)给出这始终是一个正数，因此代码应用绝对值函数来处理这种情况。这将创建一组650条边。</p><p id="4e2a" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">一些表示边的倒数和自引用节点如“Alfa”-“Alfa”的对被丢弃或不被计算。</p><p id="7c13" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">边的集合存储在map[string]Edge，Edges中。映射键是node1和node2字符串的串联，即“node1”。名称-节点2。名”。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4d2d" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">通常这个边的生成需要大约7毫秒，如相同的测试运行输出所示:<br/>在6.81242毫秒内计算了所有节点之间650条边的边长</p><h1 id="ae1e" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">路线确定</h1><p id="a8e5" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一旦节点和边的地图被填充，我们就可以根据神经网络算法来确定路线。从原始节点开始，func processEdges(node)通过扫描从原始节点开始的边来查找最近的邻居路径。这个最近的邻居是最短的路径，在应用了一些条件的情况下，给出了nextNode返回值。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b1af" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">func findShortestEdgeFromNode(节点Node)返回一条边。这些条件确保返回的边以前没有被使用过，并且边节点2还没有被访问过。本质上，该函数遍历边并检查边，以查看边node1是否与节点参数匹配，以及边是否尚未被使用，边的node2是否尚未被访问。</p><p id="7892" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">已使用的边被添加到名为UsedEdges的边的Go切片中。以类似的方式，节点被添加到另一个Go片VisitedNodes。两个小的实用函数EdgeContains和NodeContains用于检查正在讨论的边和节点是否尚未被使用。当func将边(edge . node 1 . name-edge . node 2 . name)添加到UsedEdges切片时，它还将倒易边edge . node 2 . name-edge . node 1 . name添加到UsedEdges切片。</p><p id="1a17" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">func findShortestEdgeFromNode(Node Node)返回从当前节点到未访问节点的最短未使用边。另一个Go切片RouteEdge存储使用过的边，以便组成为节点找到的最短边。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="f843" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">算法开发和TDD</h1><p id="9877" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我要指出的是，这种算法的机制和操作或过程可能看起来很简单，但在构建和测试过程中并非如此。我很幸运，尽管使用26个节点作为起点，测试运行还是给出了即时反馈。由于运行、检查输出报告和进行修正都很容易，所以性能足够好，使得对每个函数的测试变得多余。不完全是测试驱动的开发，而是合理的妥协。</p><p id="0673" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">我保证以后会做得更好！</p><h1 id="76cf" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">路线检查</h1><p id="f4bf" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一旦func ProcessNodes结束，VisitedNodes的节点切片包含26个按顺序排列的节点，因此生成路由作为报告输出的一部分就足够容易了。</p><p id="8b97" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">一个典型的路线输出看起来是这样的:阿尔法→威士忌→制服→布拉沃→查理→奥斯卡→美国佬→德尔塔→魁北克→酒店→十一月→祖鲁→帕帕→x光→基洛→探戈→高尔夫→利马→迈克→维克多→朱丽叶→回声→罗密欧→印度→塞拉→狐步舞→阿尔法</p><p id="2f04" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">在这种情况下:<br/>推销员旅行的总距离是528.65</p><h1 id="d7fd" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">制图</h1><p id="bc6e" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我使用go-charts(5)库来绘制销售人员的路径。这最终做得相当好，对这个项目来说很好。我以前用过它，发现它很容易做简单的事情，只需要多一点学习和实验就可以达到预期的效果。</p><p id="8baa" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">图表功能太长，不能作为片段包含在这里，主要是因为使用了26个节点和边，必须包含这些节点和边才能显示图表。我确信对这个库更有经验的人可能能够改进这个图。在该项目的gitlab列表中可以很容易地找到它。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mw"><img src="../Images/865655a36db4a91a6e7f52fd90f3d3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXcVLncyCgwtuBu_0crsrw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">途径</figcaption></figure><h1 id="9e7f" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="bb13" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个项目是由我读到的一篇关于TSP的最新工作的文章引发的。以前，我听说这个问题是计算机科学中最著名的问题之一。当时，我是一名工程学生，这个问题与我有关，即在其他领域中最小化电网的成本。这是最小生成树问题，当时我没有时间或兴趣去研究它。</p><p id="6eec" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">回顾在这个问题领域中所做的更多工作可能是有意义的。绕圈路线并尝试采用最近邻算法可能是一种有趣的方式来练习Go代码。</p><p id="ae4b" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">这个项目帮助我学习了更多关于Go的知识，以及如何以一种利用结构的不可变方面的方式来管理数据，比如节点和边。一旦生成了节点和边，通过将它们添加到专门的片段(如usedEdges和visitedNodes)来处理条件就容易多了，而不是试图更新结构内部的某些字段。</p><p id="6e7c" class="pw-post-body-paragraph kz la je lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">它还显示了如果项目被适当地开发，一点点的考虑可以提供什么。而不是从一个包含所有功能的main.go开始。我可以节省几个小时的时间，而不是把它分成多个包和文件。从长远来看，这可能会导致更广泛的测试和更少的挫折。一些被导出的函数也可能被隐藏。该项目肯定可以在几个方面进行改进，但这仍是未来的事。</p><h1 id="5d9d" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">参考</h1><ol class=""><li id="fd34" class="lx ly je lb b lc ld lg lh lk nb lo nc ls nd lw me mf mg mh bi translated">维基百科贡献者，“北约音标”，维基百科，自由百科，https://en.wikipedia.org/w/index.php?title = NATO _ phonetic _ alphabet &amp; oldid = 976561111(2020年10月14日访问)。北约的正式名称是“X射线”</li><li id="a435" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">旅行推销员算法，链接<a class="ae ne" href="https://cse442-17f.github.io/Traveling-Salesman-Algorithms/" rel="noopener ugc nofollow" target="_blank">https://cse442-17f.github.io/Traveling-Salesman-Algorithms/</a></li><li id="49ee" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">go中任意精度的定点十进制数。链接https://github.com/shopspring/decimal<a class="ae ne" href="https://github.com/shopspring/decimal" rel="noopener ugc nofollow" target="_blank"/></li><li id="0c5c" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">维基百科贡献者，“旅行推销员问题”，维基百科，免费百科全书，https://en.wikipedia.org/w/index.php?title = traveling _ salesman _ problem &amp; oldid = 983348561(2020年10月14日访问)。</li><li id="5ce1" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">威尔·查尔丘克，“去海图”，github.com，链接https://github.com/wcharczuk/go-chart</li><li id="da06" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">伊万·S·柯克帕特里克，“travsales”，Tessaract公司，【https://gitlab.com/ivank2139/travsales T4】</li><li id="634b" class="lx ly je lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">照片由<a class="ae ne" href="https://unsplash.com/@revolt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">反抗</a>上<a class="ae ne" href="https://unsplash.com/s/photos/travel-salesman-route-map?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">的Unsplash </a></li></ol></div></div>    
</body>
</html>