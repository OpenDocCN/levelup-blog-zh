<html>
<head>
<title>Delegating work is an underrated skill</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">委派工作是一项被低估的技能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/delegating-work-is-an-underrated-skill-3a0bf4a093c?source=collection_archive---------12-----------------------#2022-12-27">https://levelup.gitconnected.com/delegating-work-is-an-underrated-skill-3a0bf4a093c?source=collection_archive---------12-----------------------#2022-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0ad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太多的混凝土很麻烦。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2f95621569e0804d9076ad0bb7fcf7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t7QLUQjfQvBBZ8x7"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">亚历山大·曾在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="639e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是软件设计模式系列的第四篇博客。让我们继续深入研究另一个复杂的模式。这将是一个构建，我们将在下一篇博客中介绍实际的模式😎。你可能想知道为什么一个建立本身需要另一个博客。这是因为我将尝试深入解释先决条件，以便我们能够正确理解实际的模式。</p><h2 id="15b6" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">让我们来谈谈“新”这个关键词</h2><p id="53bd" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">“new”关键字是任何面向对象语言的基础，当我说面向对象时，我特指像Java和C++这样的语言。JavaScript也有“这”的概念，但它不是面向对象的。顺便说一句，你可以在评论里杀了我说JavaScript不是面向对象的。👻</p><p id="0eba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们之前的博客中，我们强调了设计原则之一，即<em class="ma">对接口编程，而不是对实现编程</em>。</p><p id="bc95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，好吧，但是“新”这个关键词有什么问题。“新建”是创建对象的唯一方法，对吗？那有什么问题？</p><p id="8e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，没有问题。但是如果你仔细想想，无论何时我们这样做，Object obj=new myObj()，我们确实在这里谈论具体。每当产品或管理发生变化时，开发人员都必须重新访问这些代码，并且可能需要重写或修改一些现有的部分，因此违反了“<strong class="jp ir"> <em class="ma">代码应该对扩展开放，但对修改关闭</em> </strong>”。</p><p id="5bde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们举一个例子来充分理解这有什么问题。我认为我们过度使用了比萨饼的例子，这是头优先模式书中的事实。另外，我正在节食，所以我们不谈论比萨饼。希望你能理解。🥺</p><p id="9060" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我正在浏览我的食品配送应用程序，发现了一个出售面包卷的商店，我喜欢在我作弊的日子里订购面包卷。姑且称之为“<strong class="jp ir">翻滚吧</strong>”。我们将试图解开他们的代码逻辑。让我们为'<strong class="jp ir"> RollingTaste </strong>'实现一个非常基础的类。</p><pre class="km kn ko kp gt mb mc md bn me mf bi"><span id="9bb5" class="mg ld iq mc b be mh mi l mj mk">public class RollingTaste {<br/><br/>    Roll orderRole(string type){<br/>        Roll roll;<br/>        <br/>        if(type.equals('chicken')){<br/>          roll = new ChickenRoll();<br/>        }<br/>        else if(type.equals('egg')){<br/>          roll = new EggRoll();<br/>        }<br/>       else if(type.equals('veg')){<br/>          roll = new VegRoll();<br/>       }<br/>       <br/>       roll.prepare();<br/>       roll.pack();<br/>       return roll;<br/>       <br/>    }<br/>}</span></pre><p id="8ad7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，这段代码似乎没有问题，这是真的，代码没有问题，但它也不是完美的。总有改进的余地。</p><p id="27b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，有一部分代码实现量很大，并且依赖于运行时的条件来创建不同类型的roll对象。现在想一想可能需要这种roll实例化的其他类似类。</p><p id="a357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的应用程序中可以有一个类，比如RollsMenu，我们需要获取它们的描述和价格。在那种情况下我们必须做什么？很明显，</p><blockquote class="ml mm mn"><p id="7b63" class="jn jo ma jp b jq jr js jt ju jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">代码重复</em> </strong></p></blockquote><p id="926b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ma">代码重复不利于开发人员的健康</em>💀</p><p id="7393" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将尝试应用从我们的第一个战略模式中学到的知识。我们谈到了封装那些经常变化的东西。如果我们能有一个只负责创建披萨对象的类(天哪！我想念披萨。抱歉打错了。我说的是面包卷。)😢根据类型？这似乎是一个很好的解决方案。让我们编写代码来理解这一点</p><pre class="km kn ko kp gt mb mc md bn me mf bi"><span id="4fde" class="mg ld iq mc b be mh mi l mj mk">public class RollingTaste {<br/>    <br/>    RollFactory factory;<br/>    public RollingTaste(RollFactory factory){<br/>        this.factory = factory;<br/>    }<br/>    <br/>    Roll orderRoll(String type){<br/>        Roll roll;<br/>        roll = factory.createRoll(type);<br/>        roll.prepare();<br/>        roll.pack();<br/><br/>        return roll;<br/>    }<br/>}</span></pre><p id="ab26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将了解什么是RollFactory，</p><pre class="km kn ko kp gt mb mc md bn me mf bi"><span id="ba68" class="mg ld iq mc b be mh mi l mj mk">public class RollFactory {<br/>    <br/>    public Roll createRoll(String type){<br/>        Roll roll=null;<br/>       if(type.equals('chicken')){<br/>          roll = new ChickenRoll();<br/>        }<br/>        else if(type.equals('egg')){<br/>          roll = new EggRoll();<br/>        }<br/>       else if(type.equals('veg')){<br/>          roll = new VegRoll();<br/>       }<br/>      return roll;<br/>    }<br/>}</span></pre><p id="9316" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们<strong class="jp ir"> <em class="ma">将创建roll对象的责任</em> </strong>委托给RollFactory类，而不是将它放在多个地方。如果我们仔细观察，我们仍然需要改变代码，如果我们想引入一个新的辊类型，但现在的变化将只在一个地方。</p><p id="876c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恭喜🤟！我们实现了简单的工厂<strong class="jp ir">，它不是一个设计模式。这更像是一个编程习语。</strong></p><blockquote class="ml mm mn"><p id="6e75" class="jn jo ma jp b jq jr js jt ju jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj kk ij bi translated">等等什么？如果这甚至不是一个设计模式，我们为什么要做这些呢？一切都很好😩</p></blockquote><p id="caab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于理解接下来会发生什么是必要的😊。再次请通过参考更好的理解和更多的例子，请不要恨我，如果你发现任何错误或incomplete🥺。我在努力做得更好，❤️</p><p id="53bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参考资料:</p><ul class=""><li id="409d" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated"><a class="ae lb" href="https://www.codeproject.com/Articles/1131770/Factory-Patterns-Simple-Factory-Pattern" rel="noopener ugc nofollow" target="_blank">https://www . code project . com/Articles/1131770/Factory-Patterns-Simple-Factory-Pattern</a></li><li id="4777" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><a class="ae lb" href="https://stackoverflow.com/questions/27007107/how-to-apply-simple-factory-pattern-java" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/27007107/how-to-apply-simple-factory-pattern-Java</a></li></ul></div></div>    
</body>
</html>