<html>
<head>
<title>GitOps in Kubernetes with GitLab CI and ArgoCD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitLab CI和ArgoCD的Kubernetes中的GitOps</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/gitops-in-kubernetes-with-gitlab-ci-and-argocd-9e20b5d3b55b?source=collection_archive---------0-----------------------#2020-08-27">https://levelup.gitconnected.com/gitops-in-kubernetes-with-gitlab-ci-and-argocd-9e20b5d3b55b?source=collection_archive---------0-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3a78" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是GitOps？</h2></div><p id="c3f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就一个简单的词，</p><blockquote class="le"><p id="8b1d" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">这就是你在Git中做DevOps的方式。</p></blockquote><p id="fbc9" class="pw-post-body-paragraph ki kj it kk b kl lo ju kn ko lp jx kq kr lq kt ku kv lr kx ky kz ls lb lc ld im bi translated">您在Git存储库中存储和管理您的部署。这样，您将利用版本控制系统来跟踪部署中的变更，并像程序员一样协调基础设施团队之间的工作。当您在Git系统中将所有东西都声明性地配置为代码时，这种Git集中式工作流允许您大规模地管理基础设施，并为加速自动化做好准备，即“Git作为真实的单一来源”。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/aaea80ce96dd9fe4a936c650ddcc85f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9q37KuHZFWC7XOZRSQpJ6Q.png"/></div></div></figure><p id="7b96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们将学习如何使用GitLab CI、ArgoCD和Helm Chart构建端到端的GitOps工作流。该系列基于以下组件:</p><ul class=""><li id="08e2" class="mf mg it kk b kl km ko kp kr mh kv mi kz mj ld mk ml mm mn bi translated"><strong class="kk iu"> GitLab </strong> CI管道</li><li id="25d2" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">Kubernetes模板使用<strong class="kk iu">掌舵</strong>图表</li><li id="6d9d" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">使用<strong class="kk iu"> ArgoCD </strong>进行连续部署</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="493f" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">先决条件</h1><p id="6412" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">在我们开始之前，您需要设置并运行Kubernetes集群。如果没有，你可以按照我之前关于如何使用<strong class="kk iu"> Kubespray </strong>设置K8s集群的文章中的说明来做。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ny"><img src="../Images/9b01e5c5607ad23e21ed9121acedb924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKc4VgVy-BHEiJpfpPfnog.png"/></div></div></figure><p id="5acd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还需要一个<strong class="kk iu">入口控制器</strong>(例如<strong class="kk iu"> Nginx </strong>)来访问ArgoCD仪表板和部署的web应用程序。另外，通过本指南，我们将使用<a class="ae nx" href="https://k8slens.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> K8S Lens </strong> </a> IDE，因为它有助于更轻松地操作集群。</p><h1 id="5538" class="na nb it bd nc nd nz nf ng nh oa nj nk jz ob ka nm kc oc kd no kf od kg nq nr bi translated">1.ArgoCD</h1><blockquote class="oe of og"><p id="0847" class="ki kj oh kk b kl km ju kn ko kp jx kq oi ks kt ku oj kw kx ky ok la lb lc ld im bi translated">用于Kubernetes的声明式GitOps连续交付工具。【argoproj.github.io/argo-cd】</p></blockquote><h2 id="7a11" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated">1.1.安装</h2><p id="90df" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">储存库:<strong class="kk iu"> </strong>舵图:<a class="ae nx" href="https://hub.helm.sh/charts/argo/argo-cd" rel="noopener ugc nofollow" target="_blank"> argo/argo-cd </a>，GitHub:<a class="ae nx" href="https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd" rel="noopener ugc nofollow" target="_blank">Argo proj/Argo-Helm/charts/Argo-CD</a></p><pre class="lu lv lw lx gt ox oy oz pa aw pb bi"><span id="6899" class="ol nb it oy b gy pc pd l pe pf">$ kubectl create namespace argocd<br/>$ helm repo add argo <a class="ae nx" href="https://argoproj.github.io/argo-helm" rel="noopener ugc nofollow" target="_blank">https://argoproj.github.io/argo-helm</a></span></pre><p id="263a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于访问服务器UI的额外舵值配置，您有以下选项:</p><ol class=""><li id="b27d" class="mf mg it kk b kl km ko kp kr mh kv mi kz mj ld pg ml mm mn bi translated"><code class="fe ph pi pj oy b">kubectl port-forward service/argocd-server -n argocd 8080:443</code>然后在<a class="ae nx" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>上打开浏览器，接受证书。</li><li id="811e" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld pg ml mm mn bi translated">在值文件<code class="fe ph pi pj oy b">service.ingress</code>中启用入口，并为<a class="ae nx" href="https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/ingress.md#option-1-ssl-passthrough" rel="noopener ugc nofollow" target="_blank"> ssl直通</a>添加注释:</li></ol><p id="0745" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我还添加了<code class="fe ph pi pj oy b">--insecure</code>标志以在TLS禁用的情况下运行，并将<code class="fe ph pi pj oy b">installCRDs</code>值设置为<code class="fe ph pi pj oy b">false</code> <a class="ae nx" href="https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd#helm-v3-compatability" rel="noopener ugc nofollow" target="_blank">以避免不存在的web挂钩</a>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="pk pl l"/></div></figure><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="pk pl l"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pm"><img src="../Images/10f60db32d0e8a74c34ae838fff3b7f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejDreDOakc2Zl8Wy4TCDNg.png"/></div></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pn"><img src="../Images/3e110ed97f6de12018030fb0b908e2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kTj40BSPL1VatQh8yoY1w.png"/></div></div></figure><p id="8c15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一次进入UI后，您可以使用<code class="fe ph pi pj oy b">username: admin</code>登录，运行<code class="fe ph pi pj oy b">kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | cut -d’/’ -f 2</code>即可获得密码</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi po"><img src="../Images/012173eb4944d0550ee92391a3e172cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sTJGYfCA8tbqYfk6NYtrBw.png"/></div></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated">如果你已经到达这一页，现在你可以走了。</figcaption></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="b572" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated">1.2.<strong class="ak"> ArgoCD CLI </strong></h2><p id="818f" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">创建CD部署有两个选项，可以通过CLI或UI。我们将使用CLI，因为它更具声明性。详细的安装说明可以通过<a class="ae nx" href="https://argoproj.github.io/argo-cd/cli_installation/" rel="noopener ugc nofollow" target="_blank">https://argoproj.github.io/argo-cd/cli_installation/</a>找到。</p><pre class="lu lv lw lx gt ox oy oz pa aw pb bi"><span id="fbaf" class="ol nb it oy b gy pc pd l pe pf"># Linux users<br/>$ VERSION=$(curl --silent "https://api.github.com/repos/argoproj/argo-cd/releases/latest" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')<br/>$ curl -sSL -o /usr/local/bin/argocd <a class="ae nx" href="https://github.com/argoproj/argo-cd/releases/download/$VERSION/argocd-linux-amd64" rel="noopener ugc nofollow" target="_blank">https://github.com/argoproj/argo-cd/releases/download/$VERSION/argocd-linux-amd64</a><br/>$ chmod +x /usr/local/bin/argocd</span></pre><p id="3001" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在尝试登录argo服务器:</p><pre class="lu lv lw lx gt ox oy oz pa aw pb bi"><span id="3be7" class="ol nb it oy b gy pc pd l pe pf">argocd login argocd.gitops.local --username admin --grpc-web</span></pre><ul class=""><li id="22a5" class="mf mg it kk b kl km ko kp kr mh kv mi kz mj ld mk ml mm mn bi translated"><code class="fe ph pi pj oy b">--insecure</code>跳过服务器证书和域验证</li><li id="ef06" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><code class="fe ph pi pj oy b">--grpc-web</code>启用gRPC-web协议。如果Argo CD服务器位于不支持HTTP2的代理之后，则非常有用。</li></ul><h2 id="1ba4" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated">1.3.ArgoCD留言簿</h2><p id="93fe" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">现在我们将从已经建立的gitops-repository部署一个应用程序，这里是<a class="ae nx" href="https://github.com/pcrete/argocd-example-apps/tree/master/guestbook" rel="noopener ugc nofollow" target="_blank"/>。这是我的分叉版本，添加一个入口示例。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="pk pl l"/></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated">使用CLI创建Argo应用程序</figcaption></figure><p id="be3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看上面的命令，我们创建了指向存储清单文件的源<code class="fe ph pi pj oy b">repo</code>和<code class="fe ph pi pj oy b">path</code>的“argo app ”,定义了在集群中部署app的位置。</p><pre class="lu lv lw lx gt ox oy oz pa aw pb bi"><span id="6732" class="ol nb it oy b gy pc pd l pe pf">$ argocd app create --help<br/>--repo, Repository URL<br/>--path, Path in repository to the app directory<br/>--dest-namespace string, K8s target namespace<br/>--dest-server string, K8s cluster URL</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pt"><img src="../Images/88f7afb38eb591b61408377a08e5a73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5HG0vhuQBakg2ef5iJ-Jw.png"/></div></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated"><a class="ae nx" href="http://argocd.gitops.local/applications/guestbook" rel="noopener ugc nofollow" target="_blank">http://argocd.gitops.local/applications/guestbook</a></figcaption></figure><p id="4104" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示ArgoCD如何工作，我们将通过向存储库添加一个<code class="fe ph pi pj oy b">ingress.yaml</code>文件来更新存储库，并更新部署<code class="fe ph pi pj oy b">3 replicas</code>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pu"><img src="../Images/c44e9ad75e024d7b21abc5fdb8b6e8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrkiuSZJUT7OOfUl02A_qA.png"/></div></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pv"><img src="../Images/f3ef2504c3e8a1cfd6c886e0653f22ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUMe1Dc2aNl78V7ZmuNHBw.png"/></div></div></figure><p id="90e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，ArgoCD将同步清单并部署对应于这些git提交更改的Kubernetes资源。因此，在将主机映射到ip地址时，我们可以通过<code class="fe ph pi pj oy b">http://guestbook.gitops.local</code> <em class="oh">访问留言簿。</em></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="fe84" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">3.具有GitLab CI的CI/CD管道</h1><p id="4c8b" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">为了演示完整的管道，我创建了<strong class="kk iu">一个</strong> <a class="ae nx" href="https://gitlab.com/gitops-argocd-demo/webapp" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Python web应用程序</strong> </a>，并将其封装为在Kubernetes集群中运行。您可以检查项目中的<a class="ae nx" href="https://gitlab.com/gitops-argocd-demo/webapp/-/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> dockerfile </strong> </a>以了解更多上下文。将应用程序构建为容器有助于CI/CD管道，其中GitLab CI可以简单地运行<code class="fe ph pi pj oy b">docker build</code>命令来集成代码并将其推送到注册表。</p><h2 id="a1ba" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated">3.1.连续累计</h2><p id="9430" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">让我们来看看管道是如何构建的。首先，我们需要在存储库的根目录下创建一个<code class="fe ph pi pj oy b"><a class="ae nx" href="https://gitlab.com/gitops-argocd-demo/webapp/-/blob/master/.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">gitlab-ci.yml</strong></a></code>文件，它定义了作业执行的<a class="ae nx" href="https://docs.gitlab.com/ee/ci/yaml/README.html#stages" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"/></a>阶段(例如，构建、测试和部署)。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="5f91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的例子可以看出，docker映像是用映像版本(这是一个带有提交sha的分支名称)构建和标记的，然后再次用<code class="fe ph pi pj oy b">latest</code>标记重新标记以重用缓存。</p><p id="513f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，您可能注意到我们正在使用<strong class="kk iu">环境变量</strong>。这些变量是动态的，以使作业可移植，并且是避免硬编码多个值的最佳实践。尤其是GitLab提供的内置或者<a class="ae nx" href="https://docs.gitlab.com/ee/ci/variables/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">预定义变量</strong> </a>。你可以在这里找到完整的列表<a class="ae nx" href="https://gitlab.com/help/ci/variables/predefined_variables.md" rel="noopener ugc nofollow" target="_blank"/>。最后，我们定义了<strong class="kk iu">组级别的</strong> <strong class="kk iu">变量</strong>，这些变量存储在项目存储库之外，可以被多个项目共享。最好存储<em class="oh">凭证</em>和<em class="oh">全局配置</em>，以便于更新。举个例子，</p><ul class=""><li id="f7a9" class="mf mg it kk b kl km ko kp kr mh kv mi kz mj ld mk ml mm mn bi translated">用于将docker映像推送到注册表的CI_REGISTRY凭据。</li><li id="d0d7" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">SSH_PRIVATE用于更新清单存储库。</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pw"><img src="../Images/8cb190f326f056dfabbd3332c47e6be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lY5_T8eceKdGQO5h6udVfA.png"/></div></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated">GitLab CI <strong class="bd nc">组</strong>级<strong class="bd nc">变量</strong></figcaption></figure><p id="2bb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于本部分的结果，Docker图像在注册表中以下列模式发布:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi px"><img src="../Images/6e68e9df9d4ae6dcc15d7add842d0796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnaef841Zuq08llk116gUA.png"/></div></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated"><a class="ae nx" href="https://hub.docker.com/repository/docker/pcrete/gitops-argocd-demo/tags" rel="noopener ugc nofollow" target="_blank">https://hub . docker . com/repository/docker/PC rete/gitops-argocd-demo/tags</a></figcaption></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="8e81" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated">3.2.连续交货</h2><blockquote class="le"><p id="52d0" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">这里是GitLab CI与ArgoCD相遇的地方。</p></blockquote><p id="c8c0" class="pw-post-body-paragraph ki kj it kk b kl lo ju kn ko lp jx kq kr lq kt ku kv lr kx ky kz ls lb lc ld im bi translated">在我们开始之前，让我们回到这张图片，删除线文本代表我们在CI部分中所做的工作。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi py"><img src="../Images/7f9c47e05a980d74a12849819d1f9614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTS-HvzA-K0mCqsB5cSvOg.png"/></div></div></figure><p id="bcfd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如ArgoCD简介从Kubernetes清单部署留言簿应用程序一样，ArgoCD也支持各种类型的<a class="ae nx" href="https://argoproj.github.io/argo-cd/user-guide/application_sources/" rel="noopener ugc nofollow" target="_blank">模板工具</a>，如Kustomize和Helm。这里我们使用Helm来定义模板或K8s资源的集合。使用可配置的值文件来表示不同类型的应用程序或部署阶段非常灵活。</p><h2 id="a80e" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated">舵图</h2><p id="eff5" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">为了进行设置，我们通过运行命令<code class="fe ph pi pj oy b">helm create webapp-chart</code>创建名为<a class="ae nx" href="https://gitlab.com/gitops-argocd-demo/webapp-chart" rel="noopener ugc nofollow" target="_blank"> webapp-chart </a>的舵图。该项目的结构如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/9994791ba456269386a3c52a21bda916.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*tBwhw4Uj8tHzvHVXM3hwfA.png"/></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated">舵图项目结构</figcaption></figure><p id="85df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不熟悉Helm，我推荐你看这篇帖子，“<a class="ae nx" href="https://opensource.com/article/20/5/helm-charts" rel="noopener ugc nofollow" target="_blank">如何在10分钟内制作一个Helm图表</a>”会给你一个很好的起点。</p><p id="396a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看<code class="fe ph pi pj oy b"><strong class="kk iu">Chart.yaml</strong></code>文件，它描述了图表信息以及应用程序版本。这个<code class="fe ph pi pj oy b"><strong class="kk iu">appVersion</strong></code>参数是当推送新版本时CI将要更新的地方。接下来，<code class="fe ph pi pj oy b"><strong class="kk iu">values.yaml</strong></code>文件被声明——变量被传递到你的模板中。例如，你可以看到<code class="fe ph pi pj oy b"><strong class="kk iu">deployment.yaml</strong></code> <strong class="kk iu"> </strong>模板是如何使用来自<code class="fe ph pi pj oy b">repository</code>和<code class="fe ph pi pj oy b">appVersion</code>的值来定义容器图像的。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi qa"><img src="../Images/5d962fcc0fe3de04788a964574fcbfdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOEExT38nRqxYSjfQefBkg.png"/></div></div></figure><p id="2bae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在已经建立了两个<a class="ae nx" href="https://gitlab.com/gitops-argocd-demo" rel="noopener ugc nofollow" target="_blank">回购</a>，它们遵循以下模式:</p><blockquote class="oe of og"><p id="0d6e" class="ki kj oh kk b kl km ju kn ko kp jx kq oi ks kt ku oj kw kx ky ok la lb lc ld im bi translated">“一个用于应用程序源代码，另一个用于清单”，<a class="ae nx" href="https://blog.argoproj.io/5-gitops-best-practices-d95cb0cbe9ff" rel="noopener ugc nofollow" target="_blank"> 5个GitOps最佳实践</a></p></blockquote><h2 id="5087" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated">更新清单阶段</h2><p id="e849" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">我们再次回到GitLab CI pipeline来添加另一个作业，在<code class="fe ph pi pj oy b">deploy</code>阶段命名为<code class="fe ph pi pj oy b"><strong class="kk iu">update_manifest</strong></code>。这将克隆并提交新的更改到舵清单库。为了更新<code class="fe ph pi pj oy b">appVersion</code>，我们应用<a class="ae nx" href="https://hub.docker.com/repository/docker/mikefarah/yq" rel="noopener ugc nofollow" target="_blank"> YQ </a>，一个轻量级的命令行YAML处理器，使用<a class="ae nx" href="https://mikefarah.gitbook.io/yq/commands/write-update#basic" rel="noopener ugc nofollow" target="_blank">路径表达式</a>系统地编辑<code class="fe ph pi pj oy b">Chart.yaml</code>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="9a41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更新清单，将<strong class="kk iu"> deploy key、</strong>全局变量中SSH_PRIVATE_KEY对应的公钥设置为<a class="ae nx" href="https://gitlab.com/gitops-argocd-demo/webapp-chart" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">web app-chart</strong></a>repo，以允许对<a class="ae nx" href="https://gitlab.com/gitops-argocd-demo/webapp/-/blob/master/.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank"> CI </a>管道的写访问。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi qb"><img src="../Images/5650f0be1b4267ac1a7280a90d6505dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jFi3njXOOIo2Ju-xavwbg.png"/></div></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated">gitops-argocd-demo &gt; web app-chart &gt;设置&gt;存储库&gt;<strong class="bd nc">部署密钥</strong></figcaption></figure><h2 id="8ed7" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated">管道</h2><p id="4df1" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">GitLab提供了一个图形，可视化了为该管道运行的作业。下面是它的两个阶段(构建和部署)。同样，在部署阶段，<code class="fe ph pi pj oy b">tag_latest_image</code>和<code class="fe ph pi pj oy b">update_manifest</code>被并行执行。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi qc"><img src="../Images/4385de430e5bde55fedc8843ed5cb68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3NUJqDEDuoVMryotR2gnQ.png"/></div></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated"><a class="ae nx" href="https://gitlab.com/gitops-argocd-demo/webapp/-/pipelines/181908945" rel="noopener ugc nofollow" target="_blank">https://git lab . com/gitops-argocd-demo/web app/-/pipelines/181908945</a></figcaption></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="0d07" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">4.ArgoCD到Kubernetes</h1><p id="46e3" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">我们将再次运行<code class="fe ph pi pj oy b">argocd app create</code>来设置ArgoCD应用程序资源，启用<a class="ae nx" href="https://argoproj.github.io/argo-cd/user-guide/auto_sync/#automated-sync-policy" rel="noopener ugc nofollow" target="_blank">自动同步策略</a>、<a class="ae nx" href="https://argoproj.github.io/argo-cd/user-guide/auto_sync/#automatic-pruning" rel="noopener ugc nofollow" target="_blank">修剪</a>、<a class="ae nx" href="https://argoproj.github.io/argo-cd/user-guide/auto_sync/#automatic-self-healing" rel="noopener ugc nofollow" target="_blank">自我修复</a>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="5056" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，ArgoCD应用基于资源的舵图。我们可以通过运行<code class="fe ph pi pj oy b">kubectl get all — namespace hello-gitops</code>来验证它</p><p id="ec20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试该应用程序，它作为一个web服务器运行，该服务器被配置为在集群中运行时使用<code class="fe ph pi pj oy b">valueFrom.fieldRef</code>从环境变量中读取<a class="ae nx" href="https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/" rel="noopener ugc nofollow" target="_blank"> pod信息</a>。例如:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="b0cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在<code class="fe ph pi pj oy b">values.yaml</code>文件中添加了一些env变量，以查看ArgoCD如何同步和执行部署的滚动更新。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi qd"><img src="../Images/574cd7fb4deb6634db6247d5962b6e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvDkloYIm_QrF9eX_2_YHQ.png"/></div></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated">部署的滚动更新</figcaption></figure><p id="7e57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你！我们已经结束了这次演示。通过将主机映射到<code class="fe ph pi pj oy b">webapp.gitops.local</code>到达此webapp页面。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi qe"><img src="../Images/ef16ca0242ea9db4dd3f7989c4a08185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9aplDM-ezpIA2jx4rtojg.png"/></div></div><figcaption class="pp pq gj gh gi pr ps bd b be z dk translated"><a class="ae nx" href="https://webapp.gitops.local/" rel="noopener ugc nofollow" target="_blank">http://web app . gitops . local</a></figcaption></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="3b99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读这篇文章，我希望你对这个GitOps工作流程有一个更清晰的了解。有了最小和简单的管道，您就可以修改它以适合您的系统。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="0229" class="ol nb it bd nc om on dn ng oo op dp nk kr oq or nm kv os ot no kz ou ov nq ow bi translated"><em class="qf">我们学到了什么</em></h2><ul class=""><li id="65c9" class="mf mg it kk b kl ns ko nt kr qg kv qh kz qi ld mk ml mm mn bi translated"><strong class="kk iu"><em class="oh">git lab</em></strong><em class="oh">CI管道</em></li><li id="37e7" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><em class="oh"> Kubernetes模板使用</em> <strong class="kk iu"> <em class="oh">掌舵</em> </strong> <em class="oh">图表</em></li><li id="6342" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><em class="oh">连续部署使用</em> <strong class="kk iu"> <em class="oh"> ArgoCD </em> </strong></li><li id="5219" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><strong class="kk iu"> <em class="oh"> GitOps </em> </strong> <em class="oh">仓库结构</em></li><li id="ca8e" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><em class="oh">清单-更新工作流，其中CI符合CD </em></li></ul></div></div>    
</body>
</html>