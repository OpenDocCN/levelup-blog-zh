<html>
<head>
<title>Upgrading Kubernetes Clusters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升级Kubernetes集群</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/upgrading-kubernetes-clusters-1ac91343a3da?source=collection_archive---------11-----------------------#2022-08-23">https://levelup.gitconnected.com/upgrading-kubernetes-clusters-1ac91343a3da?source=collection_archive---------11-----------------------#2022-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f0f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">尽职调查以避免API被弃用/删除</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9991e53bfa3eee66b45f032e84c6f19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t00I7veYyvOVtkHfdlmWZA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">升级Kubernetes集群版本</figcaption></figure><p id="dff6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上一篇文章<a class="ae lu" href="https://faun.pub/upgrade-your-kubernetes-cluster-without-upsetting-your-developers-e7d8559dee49" rel="noopener ugc nofollow" target="_blank">升级您的Kubernetes集群而不影响您的开发人员</a>中，我们推导出了针对Kubernetes目标版本部署的对象列表，这些对象针对的是过时的API和即将删除的API。我们还识别和聚合了命名空间范围和集群范围的对象。</p><p id="cfa7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，作为平台工程师，我们有责任维护最新和稳定版本的集群。这消除了技术债务的风险，并提供了所有API的最新和最好的特性。尽管有很多更流畅的技术和策略来升级任何规模的Kubernetes集群，但我们不能直接升级集群。因为存在破坏集群中运行的应用程序/服务的风险。</p><p id="3c4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，我们需要从应用程序团队那里得到许可，即他们的应用程序/服务的所有清单都根据Kubernetes的新版本进行了验证，并按预期工作，或者可能目标版本所需的对清单的必要更改已经完成，它们都为升级做好了准备。</p><p id="6c10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样做太容易了。由于从这个<a class="ae lu" href="https://github.com/gkarthiks/argo-apid-helper" rel="noopener ugc nofollow" target="_blank"> API弃用助手</a>工具中，我们知道了针对目标Kubernetes版本的弃用和/或删除的API部署的对象，我们可以要求团队自己验证清单。然后我们可以升级集群。但是有一个共同的问题:<em class="lv">人为错误</em>。当要求团队验证他们自己时，不能保证他们都将验证完美的语义目标版本。团队可能会在本地运行<em class="lv"> minikube </em>、<em class="lv"> kind </em>和<em class="lv"> k3s </em>集群，并根据他们运行本地集群的版本进行验证。贪婪的用户可能会验证最新版本的Kubernetes这可能缺少<em class="lv">向后兼容性</em>。</p><p id="1f96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着负责集群升级的团队应该控制应用程序团队正在验证的Kubernetes集群的目标语义版本。这使得我们需要创建一个新的集群，并使用目标版本来验证应用程序团队的清单。但是仅仅为了验证清单而创建一个集群将是一个非常昂贵的过程。不仅包括资源成本，还包括配置基础架构、连接以及在验证完成后拆除基础架构的成本。</p><p id="ce87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们的要求和我们想要达到的目标状态如下。</p><ul class=""><li id="0325" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">使用集中控制的目标版本调配新集群或多个新集群</li><li id="6108" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">尽可能降低成本因素</li><li id="4ad6" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">用GitOps引擎钩住新集群</li><li id="1ad7" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">要求应用程序团队在生产前针对新群集及其现有生产前环境进行alpha-beta部署</li></ul><p id="2f48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将新集群与GitOps引擎挂钩的好处是，我们得到了应用程序团队的认可，根据他们拥有的清单来验证目标Kubernetes版本APIs由于应用程序团队不需要花费时间进行验证，他们可以进行alpha-beta部署，而不必浪费时间部署到具有最新版本API的新集群。</p><h1 id="c445" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">缝合工具</h1><p id="28a2" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">平台工程或基础设施工程最吸引人的事情之一是通过自动化将不可能变为可能。为了实现上述任务并达到目标状态，即从应用程序团队处获得集群升级的“许可”,我们将把一些工具组合在一起，使其变得有价值。我们将逐一查看实现这一目标的需求、工具和步骤。</p><h2 id="5fb7" class="nh ml it bd mm ni nj dn mq nk nl dp mu lh nm nn mw ll no np my lp nq nr na ns bi translated">设置新的集群</h2><p id="34f0" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">正如我们已经讨论过的那样，创建一个新的集群需要一个专用的集群，这将是非常昂贵的。因此，为了尽量减少这种情况，我们将使用Kubernetes 中的<strong class="la iu"><em class="lv">Kubernetes</em></strong>方法。</p><p id="e729" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们将结合使用以下开源工具。</p><p id="1fcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://www.vcluster.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> <em class="lv"> vCluster </em> </strong> </a>是一个虚拟的Kubernetes集群，运行在常规的Kubernetes名称空间内。在调度工作负载时，vCluster有一个<em class="lv">同步程序</em>，它将调度提交给实际的主机集群。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/daa27632a769e38fc0886756c139914f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEnvzvBy7tvBfvEAc3WKNg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">部署在实际Kubernetes集群的命名空间中的vClusters</figcaption></figure><p id="b238" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然有很大的资源利用率，但相比之下成本大大降低。此外，我们可以为每个团队部署集群，以缩短验证时间。部署vCluster本身是一个简单的过程。它带有详细的<a class="ae lu" href="https://github.com/loft-sh/vcluster/tree/main/charts" rel="noopener ugc nofollow" target="_blank">舵图</a>用于安装。但是如果我们不把它自动化，那将会多么有趣。</p><p id="2885" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://cluster-api.sigs.k8s.io/introduction.html#kubernetes-cluster-apidiv-stylefloat-right-position-relative-display-inlineimg-srcimagesintroductionsvg-width160px-div" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> <em class="lv"> Kubernetes集群API</em></strong></a><strong class="la iu"><em class="lv"/></strong>是一个Kubernetes子项目，主要提供声明性API和工具来简化多个Kubernetes集群的供应、升级和操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/98d614be47689c4591d4267499dc70f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*trAwyqMHMVq4XJmXKXbE1w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes集群API提供程序</figcaption></figure><p id="8084" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，CAPI(集群API)允许通过修改<a class="ae lu" href="https://cluster-api.sigs.k8s.io/clusterctl/configuration.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> clusterctl </em> </a>配置来添加自定义提供程序，并且vCluster也有一个集群API提供程序，可以在<a class="ae lu" href="https://github.com/loft-sh/cluster-api-provider-vcluster" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><blockquote class="nv nw nx"><p id="20e4" class="ky kz lv la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">尽管在撰写本文时值得注意的是，vCluster CAPI提供程序只能在运行vCluster提供程序的集群中托管vCluster。</p></blockquote><p id="7420" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，按照vCluster提供者<a class="ae lu" href="https://github.com/loft-sh/cluster-api-provider-vcluster#installation-instructions" rel="noopener ugc nofollow" target="_blank">这里</a>和CAPI <a class="ae lu" href="https://cluster-api.sigs.k8s.io/user/quick-start.html#installation" rel="noopener ugc nofollow" target="_blank">这里</a>的安装文档，指定一个<em class="lv">管理集群；</em>在这种情况下，这将是我们的生产前群集。现在部署vCluster提供程序。至此，我们已经拥有了将虚拟群集部署到生产前群集所需的所有基础架构组件，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/20159dc19d6de8ef0f6f193ed8a2c97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSbn7SpwoO9LCcNgJ3VFNQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">生产前群集，也称为群集ctl配置的管理群集</figcaption></figure><p id="bd6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只需应用<em class="lv">集群模板</em> <a class="ae lu" href="https://github.com/loft-sh/cluster-api-provider-vcluster/blob/main/templates/cluster-template.yaml" rel="noopener ugc nofollow" target="_blank">清单</a>就可以在我们的生产前环境中配置一个虚拟集群。但是让我们把它模板化，包装成一个舵图。所以现在我们有了一个掌舵图，它是为<em class="lv"> Kubernetes版本</em>和<em class="lv">集群名称</em>模板化的，比如<a class="ae lu" href="https://github.com/gkarthiks/capi-vcluster-argo-chart" rel="noopener ugc nofollow" target="_blank">这个</a> <em class="lv">。现在，我们所要做的就是将这个图表库连接到ArgoCD，每当我们需要Kubernetes虚拟集群时，我们只需应用ArgoCD的应用程序/应用程序集清单。那会起作用的。</em></p><blockquote class="nv nw nx"><p id="0780" class="ky kz lv la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">注意:确保获得正确的vCluster控制平面URL那就是<vcluster name=""> .vcluster.svc.local</vcluster></p></blockquote><p id="c2ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们已经为新集群配置了一个在我们控制范围内的目标版本。通过以虚拟方式调配新集群，<em class="lv">理论上，</em>这让我们实现了“零成本”复选框，尽管再次值得重复工作负载仍在主机集群上进行调度，从而导致资源消耗。</p><h2 id="a20d" class="nh ml it bd mm ni nj dn mq nk nl dp mu lh nm nn mw ll no np my lp nq nr na ns bi translated">用GitOps引擎挂接新集群</h2><p id="8600" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">现在我们有了新的集群，我们需要它们与GitOps引擎挂钩。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8568dbbd4ca0984437276f6f8b8607e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PN5TMMXY8qXclWFvN1_oDQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ArgoCD，一个基于拉的GitOps引擎</figcaption></figure><p id="fcd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我更喜欢它是ArgoCD。它可以是任何GitOps引擎。要在ArgoCD中这样做，您必须拥有在目标集群中创建服务帐户的权限，我们拥有这种权限。运行以下命令将它们添加到ArgoCD</p><blockquote class="nv nw nx"><p id="88cb" class="ky kz lv la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated"><code class="fe od oe of og b">argocd cluster add &lt;cluster-name&gt;</code></p></blockquote><p id="1a99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经将vClusters添加为ArgoCD中部署的目标集群之一，应用程序团队也应该能够对这个新目标进行一些alpha-beta部署。</p><p id="9aff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦应用程序团队完成了对新的目标Kubernetes版本的验证(这应该不会花太多时间)，我们就必须让这个集群退役。这变得很容易，因为这些集群是通过GitOps引擎创建的，一旦argocd应用程序被删除，argocd就会删除这些虚拟集群。但是还有一个额外的步骤要做，即从ArgoCD中删除那些虚拟集群的地址作为目标之一。为此，使用用于注册目标集群的名称运行以下命令。</p><blockquote class="nv nw nx"><p id="1a9a" class="ky kz lv la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated"><code class="fe od oe of og b"><em class="it">argocd cluster rm &lt;cluster-name&gt;</em></code></p></blockquote><h2 id="fde6" class="nh ml it bd mm ni nj dn mq nk nl dp mu lh nm nn mw ll no np my lp nq nr na ns bi translated">升级集群</h2><p id="3a9f" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">既然我们已经完成了尽职调查并获得了应用程序团队的批准，我们就可以安全地升级Kubernetes集群并避免API弃用和/或移除问题。</p><p id="7cb8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">升级快乐！</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="2dce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，通过鼓掌帮助其他人找到它，并在这里和<a class="ae lu" href="https://twitter.com/gkarthics" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我以获取更多更新。</p><h1 id="137c" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">参考资料:</h1><ul class=""><li id="bbb8" class="lw lx it la b lb nc le nd lh oo ll op lp oq lt mb mc md me bi translated"><a class="ae lu" href="https://github.com/gkarthiks/argo-apid-helper/" rel="noopener ugc nofollow" target="_blank"> Kubernetes弃用助手</a></li><li id="cf14" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lu" href="https://kubernetes.io/docs/reference/using-api/deprecation-guide/" rel="noopener ugc nofollow" target="_blank"> K8s弃用指南</a></li><li id="c99b" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lu" href="https://cluster-api.sigs.k8s.io/introduction.html" rel="noopener ugc nofollow" target="_blank"> K8s集群API </a></li><li id="f684" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lu" href="https://cluster-api.sigs.k8s.io/clusterctl/configuration.html" rel="noopener ugc nofollow" target="_blank"> ClusterCTL CLI </a></li><li id="9fa5" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lu" href="https://github.com/loft-sh/cluster-api-provider-vcluster" rel="noopener ugc nofollow" target="_blank"> CAPI vCluster提供商</a></li><li id="02ea" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lu" href="https://argo-cd.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> ArgoCD文档</a></li><li id="27e9" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lu" href="https://www.vcluster.com/" rel="noopener ugc nofollow" target="_blank"> vCluster </a></li><li id="4b72" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><a class="ae lu" href="https://github.com/gkarthiks/capi-vcluster-argo-chart" rel="noopener ugc nofollow" target="_blank">https://github.com/gkarthiks/capi-vcluster-argo-chart</a></li></ul></div></div>    
</body>
</html>