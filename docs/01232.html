<html>
<head>
<title>Using a JavaScript Proxy Object to Control Object Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript代理对象控制对象操作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-proxies-to-control-javascript-object-operations-3ce1738ba811?source=collection_archive---------4-----------------------#2019-12-02">https://levelup.gitconnected.com/using-proxies-to-control-javascript-object-operations-3ce1738ba811?source=collection_archive---------4-----------------------#2019-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f23" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript对象操作可以使用特殊的代理对象来控制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7095b5db24566c5389dcf4e44e0cdd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bqgFjM_E_VhpkA68"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kendall3lane?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">肯德尔·莱恩</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="ea46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，代理是一个对象，它让我们控制当我们做一些操作时会发生什么。例如，我们可以使用它们来控制属性的查找、赋值、枚举或函数的调用方式。</p><p id="5b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代理构造函数有两个参数。第一个是目标，它是您想要对其应用控制操作的对象，第二个是处理程序，它是实际控制操作在目标对象中如何行为的对象，也称为陷阱。</p><p id="5e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理程序对象是包含代理陷阱的对象。它有很多方法让我们控制对象的基本操作。对象有许多方法来捕获由对象构造函数中的方法完成的各种操作。它们包括:</p><ul class=""><li id="054b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.getPrototypeOf()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.getPrototypeOf()</code>方法的行为</li><li id="ebe1" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.setPrototypeOf()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.setPrototypeOf()</code>方法的行为</li><li id="fcf3" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.isExtensible()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.isExtensible()</code>方法的行为</li><li id="8d34" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.preventExtensions()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.preventExtensions()</code>方法的行为</li><li id="5c11" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.getOwnPropertyDescriptor()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.getOwnPropertyDescriptor()</code>方法的行为</li><li id="f9c3" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.defineProperty()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.defineProperty()</code>方法的行为</li><li id="b009" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.has()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.has()</code>方法的行为</li><li id="615d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.get()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.get()</code>方法的行为</li><li id="27d0" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.set()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.set()</code>方法的行为</li><li id="19d3" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.deleteProperty()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.deleteProperty()</code>方法的行为</li><li id="da0e" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.ownKeys()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.ownKeys()</code>方法的行为</li><li id="f70b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.apply()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.apply()</code>方法的行为</li><li id="0b7b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">handler.construct()</code> —让我们控制目标对象的<code class="fe me mf mg mh b">Object.construct()</code>方法的行为</li></ul><p id="cda8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个基本的例子是用代理返回一个属性的默认值。例如，如果我们有以下代码:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="a312" class="mr ms it mh b gy mt mu l mv mw">const handler = {<br/>  get(obj, prop) {<br/>    return prop === 'a' &amp;&amp; obj[prop] ?<br/>      obj[prop] :<br/>      1;<br/>  }<br/>};</span><span id="4c53" class="mr ms it mh b gy mx mu l mv mw">let p = new Proxy({}, handler);<br/>console.log(p.a); // 1<br/>p.a = 2;<br/>console.log(p.a); // 2</span></pre><p id="9d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么第一个<code class="fe me mf mg mh b">console.log</code>语句将输出1，第二个将输出2。这是因为在<code class="fe me mf mg mh b">handler</code>对象中，我们有一个<code class="fe me mf mg mh b">get</code>函数来修改属性的检索方式。在函数中，如果属性名是<code class="fe me mf mg mh b">a</code>而<code class="fe me mf mg mh b">obj[prop]</code>是truthy，也就是说<code class="fe me mf mg mh b">obj['a']</code>是truthy，那么我们返回它，否则返回1。这将把<code class="fe me mf mg mh b">p.a</code>的默认值设置为1，其中<code class="fe me mf mg mh b">p</code>是由代理构造器构造的代理对象。如果我们为<code class="fe me mf mg mh b">p.a</code>设置一个新值，那么<code class="fe me mf mg mh b">get</code>函数将返回新值，因为它是真的。因此，<code class="fe me mf mg mh b">p.a</code>的第二个<code class="fe me mf mg mh b">console.log</code>语句输出2。</p><p id="aebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以为参数<code class="fe me mf mg mh b">handler</code>传入一个空对象。它将使所有对目标对象的默认操作按原样转发。例如，如果我们有:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="4bf3" class="mr ms it mh b gy mt mu l mv mw">let p = new Proxy({}, {});<br/>console.log(p.a); // undefined<br/>p.a = 2;<br/>console.log(p.a); // 2</span></pre><p id="a447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到第一个<code class="fe me mf mg mh b">console.log</code>语句是<code class="fe me mf mg mh b">undefined</code>，但是第二个是2，因为我们没有修改handler对象中的<code class="fe me mf mg mh b">get</code>函数，以便在没有设置任何内容的情况下返回任何内容。</p><p id="313e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以使用代理来验证分配给对象属性的值。例如，我们可以用它来验证一个有效的美国电话号码是否分配给了代理对象的一个属性:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="c66f" class="mr ms it mh b gy mt mu l mv mw">const handler = {<br/>  set(obj, prop, value) {<br/>    const validPhone = /^\d{3}-\d{3}-\d{4}$/.test(value);<br/>    if (prop === 'phoneNumber') {<br/>      if (!validPhone) {<br/>        throw new Error('Invalid phone number');<br/>      }<br/>    }</span><span id="3079" class="mr ms it mh b gy mx mu l mv mw">    obj[prop] = value;<br/>    return validPhone;<br/>  }<br/>};</span><span id="21af" class="mr ms it mh b gy mx mu l mv mw">let person = new Proxy({}, handler);</span><span id="7ab7" class="mr ms it mh b gy mx mu l mv mw">person.phoneNumber = '555-555-5555'; // valid<br/>console.log(person.phoneNumber);<br/>person.phoneNumber = 'abc'; // throws an error</span></pre><p id="4d28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们通过检查给定的正则表达式来检查所分配的实际上是一个有效的美国电话号码。如果<code class="fe me mf mg mh b">phoneNumber</code>属性被赋值，那么我们根据<code class="fe me mf mg mh b">set</code>函数的参数中给出的<code class="fe me mf mg mh b">value</code>检查正则表达式，如果<code class="fe me mf mg mh b">validPhone</code>是<code class="fe me mf mg mh b">false</code>，那么我们抛出一个错误。否则，我们将该值设置为对象的<code class="fe me mf mg mh b">phoneNumber</code>属性。最后，我们返回给定<code class="fe me mf mg mh b">value</code>的验证状态。第一项任务:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="6714" class="mr ms it mh b gy mt mu l mv mw">person.phoneNumber = '555-555-5555';</span></pre><p id="f16d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该可行，因为它匹配<code class="fe me mf mg mh b">set</code>函数中的正则表达式。然而，第二个赋值会抛出一个错误，因为它不匹配给定的正则表达式。</p><p id="926c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以给<code class="fe me mf mg mh b">handler</code>对象添加<code class="fe me mf mg mh b">construct</code>函数来扩展<code class="fe me mf mg mh b">target</code>对象的构造函数。例如，我们可以通过将基本对象的原型设置为超类来用超类扩展基本对象，然后用具有<code class="fe me mf mg mh b">construct</code>和<code class="fe me mf mg mh b">apply</code>函数的<code class="fe me mf mg mh b">handler</code>对象创建一个新的代理来控制构造函数的行为和基本对象的<code class="fe me mf mg mh b">apply</code>函数。例如，我们可以写:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="e971" class="mr ms it mh b gy mt mu l mv mw">function extend(sup, base) {<br/>  const descriptor = Object.getOwnPropertyDescriptor(<br/>    base.prototype, 'constructor'<br/>  );<br/>  base.prototype = Object.create(sup.prototype);<br/>  const handler = {<br/>    construct(target, args) {<br/>      const obj = Object.create(base.prototype);<br/>      this.apply(target, obj, args);<br/>      return obj;<br/>    },<br/>    apply(target, that, args) {<br/>      sup.apply(that, args);<br/>      base.apply(that, args);<br/>    }<br/>  };<br/>  const proxy = new Proxy(base, handler);<br/>  descriptor.value = proxy;<br/>  Object.defineProperty(base.prototype, 'constructor', descriptor);<br/>  return proxy;<br/>}</span><span id="b1d1" class="mr ms it mh b gy mx mu l mv mw">let Person = function(name) {<br/>  this.name = name;<br/>};</span><span id="39cd" class="mr ms it mh b gy mx mu l mv mw">let Boy = extend(Person, function(name, age, gender) {<br/>  this.name = name;<br/>  this.age = age;<br/>  this.gender = gender;<br/>});</span><span id="9d00" class="mr ms it mh b gy mx mu l mv mw">let Joe = new Boy('Joe', 13, 'M');<br/>console.log(Joe.gender);<br/>console.log(Joe.name);<br/>console.log(Joe.age);</span></pre><p id="c333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个以<code class="fe me mf mg mh b">base</code>对象为目标的代理。<code class="fe me mf mg mh b">handler</code>具有<code class="fe me mf mg mh b">constructor</code>和<code class="fe me mf mg mh b">apply</code>函数，分别修改<code class="fe me mf mg mh b">base</code>对象和<code class="fe me mf mg mh b">apply</code>函数的构造函数的行为。</p><p id="337f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">construct</code>函数通过将原型设置为作为<code class="fe me mf mg mh b">obj</code>对象的超类的<code class="fe me mf mg mh b">sup</code>对象来创建一个新的对象<code class="fe me mf mg mh b">obj</code>，在JavaScript中它与原型相同。这是一个模板对象，<code class="fe me mf mg mh b">base</code>对象继承了它的成员。然后<code class="fe me mf mg mh b">this.apply(target, obj, args);</code>使用<code class="fe me mf mg mh b">args</code>对象中传递的参数运行构造函数，然后返回<code class="fe me mf mg mh b">obj</code>对象。<code class="fe me mf mg mh b">handler</code>中的<code class="fe me mf mg mh b">apply</code>函数运行<code class="fe me mf mg mh b">sup</code>和<code class="fe me mf mg mh b">base</code>对象的构造函数来构造基础对象。</p><p id="734d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在最后，创建代理对象并用<code class="fe me mf mg mh b">descriptor.value = proxy;</code>行将其设置为构造函数的值。然后，我们通过运行<code class="fe me mf mg mh b">Object.defineProperty(base.prototype, ‘constructor’, descriptor);</code>来设置<code class="fe me mf mg mh b">base</code>对象的原型的构造函数，并返回代理对象，让我们用一个超类对象来扩展基本对象的构造函数。</p><p id="698b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe me mf mg mh b">extend</code>函数下面，我们创建了一个<code class="fe me mf mg mh b">Person</code>构造函数，让我们设置<code class="fe me mf mg mh b">Person</code>实例的<code class="fe me mf mg mh b">name</code>属性。然后我们用<code class="fe me mf mg mh b">Person</code>对象调用<code class="fe me mf mg mh b">extend</code>函数，并传递一个新的构造函数给<code class="fe me mf mg mh b">name</code>、<code class="fe me mf mg mh b">age</code>和<code class="fe me mf mg mh b">gender</code>的参数来设置这些属性。然后我们得到一个新构造的对象，它具有:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="7534" class="mr ms it mh b gy mt mu l mv mw">let Joe = new Boy('Joe', 13, 'M');</span></pre><p id="a48a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们记录属性时，我们为<code class="fe me mf mg mh b">gender</code>得到‘M ’,为<code class="fe me mf mg mh b">name</code>得到‘Joe ’,为<code class="fe me mf mg mh b">age</code>得到13。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/421d744c0270e8b8c1e61bfdf3681693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i3sNLER-jRwwEv1X"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">乔安娜·科辛斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="84da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们设置代理对象的一个属性时，我们可以同时修改该对象的另一个属性。例如，如果我们有一个由带有<code class="fe me mf mg mh b">people</code>属性的<code class="fe me mf mg mh b">target</code>对象构成的<code class="fe me mf mg mh b">room</code>代理对象，它有一个在同一个房间里的人的名字的数组，并且我们想在设置代理对象的<code class="fe me mf mg mh b">lastPerson</code>属性时将它推送到<code class="fe me mf mg mh b">people</code>数组。我们可以通过下面的代码做到这一点:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="6eea" class="mr ms it mh b gy mt mu l mv mw">let room = new Proxy({<br/>  people: ['Joe', 'Jane']<br/>}, {<br/>  get(obj, prop) {<br/>    if (prop === 'lastPerson') {<br/>      return obj.people[obj.people.length - 1];<br/>    }<br/>    return obj[prop];<br/>  },<br/>  set(obj, prop, value) {<br/>    if (prop === 'lastPerson') {<br/>      obj.people.push(value);<br/>      obj[prop] = value;<br/>      return true;<br/>    }<br/>    return true;<br/>  }<br/>});</span><span id="3318" class="mr ms it mh b gy mx mu l mv mw">console.log(room);<br/>room.lastPerson = 'John';<br/>console.log(room.people);<br/>console.log(room.lastPerson);</span><span id="2794" class="mr ms it mh b gy mx mu l mv mw">room.lastPerson = 'Mary';<br/>console.log(room.people);<br/>console.log(room.lastPerson);</span></pre><p id="d2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe me mf mg mh b">get</code>函数中，我们指定属性<code class="fe me mf mg mh b">lastPerson</code>的值将是<code class="fe me mf mg mh b">people</code>数组的最后一个元素。因此，当我们在<code class="fe me mf mg mh b">room.lastPerson</code>上运行<code class="fe me mf mg mh b">console.log</code>时，我们总是得到<code class="fe me mf mg mh b">room.people</code>数组的最后一个元素。否则，我们按原样设置对象。在<code class="fe me mf mg mh b">set</code>函数中，当<code class="fe me mf mg mh b">lastPerson</code>属性被修改时，我们也将被设置的值推入<code class="fe me mf mg mh b">room</code>代理对象的<code class="fe me mf mg mh b">people</code>数组中。因此，当我们运行<code class="fe me mf mg mh b">console.log</code>语句时，我们得到:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="a64c" class="mr ms it mh b gy mt mu l mv mw">["Joe", "Jane", "John"]<br/>John</span><span id="348e" class="mr ms it mh b gy mx mu l mv mw">["Joe", "Jane", "John", "Mary"]<br/>Mary</span></pre><p id="4a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，当我们设置<code class="fe me mf mg mh b">room</code>的<code class="fe me mf mg mh b">lastPerson</code>属性时，我们也将相同的值推入到<code class="fe me mf mg mh b">people</code>数组中。</p><p id="f1c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个更全面的例子，我们可以在<code class="fe me mf mg mh b">handler</code>对象中设置陷阱来控制代理对象的操作行为:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="e8a0" class="mr ms it mh b gy mt mu l mv mw">const handler = {<br/>  get(obj, prop) {<br/>    return obj[prop];<br/>  },<br/>  set(obj, prop, value) {<br/>    obj[prop] = value;<br/>    return true;<br/>  },<br/>  deleteProperty(obj, prop) {<br/>    delete obj[prop];<br/>    return false;<br/>  },<br/>  ownKeys(obj) {<br/>    return Reflect.ownKeys(obj);<br/>  },<br/>  has(obj, prop) {<br/>    return prop in obj;<br/>  },<br/>  defineProperty(obj, prop, descriptor) {<br/>    Object.defineProperty(obj, prop, descriptor)<br/>    return true;<br/>  },<br/>  getOwnPropertyDescriptor(obj, prop) {<br/>    return Object.getOwnPropertyDescriptor(obj, prop);<br/>  },<br/>}</span><span id="a041" class="mr ms it mh b gy mx mu l mv mw">let proxy = new Proxy({}, handler);<br/>proxy.a = 1;<br/>console.log(proxy.a);<br/>console.log(Object.getOwnPropertyDescriptor(proxy, 'a'))<br/>console.log(Object.defineProperty(proxy, 'b', {<br/>  value: 1<br/>}))<br/>console.log('a' in proxy);<br/>console.log(delete proxy.c);<br/>console.log(Object.keys(proxy));</span></pre><p id="d922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe me mf mg mh b">handler</code>对象中的<code class="fe me mf mg mh b">getOwnProperty</code>函数控制着<code class="fe me mf mg mh b">Object.getOwnPropertyDescriptor()</code>应用于<code class="fe me mf mg mh b">proxy</code>对象时的行为。<code class="fe me mf mg mh b">handler</code>对象中的<code class="fe me mf mg mh b">defineProperty</code>函数控制<code class="fe me mf mg mh b">Object.defineProperty()</code>在<code class="fe me mf mg mh b">proxy</code>对象上被调用时的行为。<code class="fe me mf mg mh b">has</code>函数控制<code class="fe me mf mg mh b">in</code>操作符的行为，<code class="fe me mf mg mh b">deleteProperty</code>函数控制<code class="fe me mf mg mh b">delete</code>操作符以<code class="fe me mf mg mh b">proxy</code>对象为操作数运行时返回的值。当我们在<code class="fe me mf mg mh b">proxy</code>上使用<code class="fe me mf mg mh b">delete</code>操作符时，我们返回了<code class="fe me mf mg mh b">false</code>而不是通常的<code class="fe me mf mg mh b">true</code>。<code class="fe me mf mg mh b">ownKeys</code>函数通过用<code class="fe me mf mg mh b">Reflect</code>对象枚举一个对象的键来修改<code class="fe me mf mg mh b">Object.keys()</code>方法的行为。</p><h2 id="a1f6" class="mr ms it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">包扎</h2><p id="a1af" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">JavaScript代理是控制对象操作行为的一种有用方式。我们可以控制对象操作符如<code class="fe me mf mg mh b">in</code>、<code class="fe me mf mg mh b">delete</code>和赋值操作符如何作用于目标对象及其属性。这对于那些操作中的验证非常有用，并且对于修改像<code class="fe me mf mg mh b">in</code>和<code class="fe me mf mg mh b">delete</code>操作符那样返回值的操作的返回值也很方便。</p><p id="de58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe me mf mg mh b">set</code>函数修改赋值操作符，在这里我们可以验证被赋值的值，同时还可以修改其他属性。我们可以修改<code class="fe me mf mg mh b">get</code>函数的行为，在某些情况下为属性返回不同的值，比如没有为属性设置值。</p></div></div>    
</body>
</html>