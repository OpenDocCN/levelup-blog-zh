<html>
<head>
<title>Understanding dependency management with Node Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解节点模块的依赖性管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-dependency-management-with-node-modules-1c47bcdee98b?source=collection_archive---------3-----------------------#2021-01-12">https://levelup.gitconnected.com/understanding-dependency-management-with-node-modules-1c47bcdee98b?source=collection_archive---------3-----------------------#2021-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b4c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">package.json中的版本控制如何工作，以及锁文件如何防止对应用程序进行重大更改</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d880999f34158e34155e9905dc4b6fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T9O8gxysDIhl6oaG"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Marcello Gennari 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bb5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript模块的兴起导致管理脚本文件的工具更加复杂。大多数现代web应用程序现在使用像<a class="ae kv" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>这样的模块捆绑器来利用JavaScript模块和更复杂的库比如<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>的优势，而不是使用像<a class="ae kv" href="https://gulpjs.com/" rel="noopener ugc nofollow" target="_blank">gupp</a>这样的简单任务运行器来传输和连接资产。</p><p id="a5fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这给JavaScript开发人员带来了一系列全新的挑战，包括依赖性管理。技术社区中有一个常见的术语叫做<em class="ls">依赖地狱</em>——指的是拥有不同或不兼容版本的共享依赖包所带来的挑战和困难。</p><p id="c0ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我见过的开发人员面对节点模块的一些常见问题通常与缺乏对版本控制和包解析如何与<a class="ae kv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">节点包管理器</a>一起工作的理解有关。这可能是意外地升级了引入了重大更改的包，不知道如何解决重复或冲突的依赖关系，不知道如何解决锁文件中的合并冲突，以及最终的错误—删除锁文件。</p><h2 id="fba0" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">什么是JavaScript模块？</h2><p id="328b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">JavaScript模块是简单的脚本文件，可以相互加载以共享功能。模块的主要好处之一是，它们允许我们将大型脚本分解成更小的、可重用的自包含代码片段。</p><p id="bdc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个模块或模块的集合可以作为<em class="ls">包</em>发布到公共或私有注册中心以供使用。JS模块的主要公共注册中心是<a class="ae kv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">节点包管理器</a> (NPM)。这使得开发人员能够在全球范围内共享代码，从而促进了JS社区的发展。</p><p id="a0cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用命令行包管理器(如<code class="fe mr ms mt mu b"><a class="ae kv" href="https://github.com/npm/cli" rel="noopener ugc nofollow" target="_blank">npm</a></code>或<code class="fe mr ms mt mu b"><a class="ae kv" href="https://classic.yarnpkg.com/en/docs/install#mac-stable" rel="noopener ugc nofollow" target="_blank">yarn</a></code>)将包安装到本地机器上的项目中，并添加到项目根目录下的<code class="fe mr ms mt mu b">node_modules</code>文件夹中。</p><h2 id="7560" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">package.json和lock文件是什么？</h2><p id="f1b9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><code class="fe mr ms mt mu b">package.json</code>和锁文件(<code class="fe mr ms mt mu b">yarn.lock</code>如果你使用<code class="fe mr ms mt mu b">yarn</code>，和<code class="fe mr ms mt mu b">package-lock.json</code>如果你使用<code class="fe mr ms mt mu b">npm</code>)是配置文件，告诉安装程序要安装哪个版本的包。</p><p id="13b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe mr ms mt mu b">package.json</code>视为<em class="ls">规范</em>——它列出了所有的包及其版本需求(例如，最低版本、最高版本等)。当您第一次安装软件包时，会创建一个锁文件。可以把这个看作是<em class="ls">契约</em>——它有一个在第一次安装时满足<code class="fe mr ms mt mu b">package.json</code> <em class="ls">中规范的软件包的精确版本列表。</em></p><p id="736e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常情况下，一个项目不仅仅存在于单个开发人员的机器上，存储库由许多开发人员克隆和安装，甚至在CI/CD管道中，因此，确保软件包受到正确的版本控制是很重要的——这是锁文件的作用。任何时候模块随后被安装，安装程序将使用锁定文件中指定的版本，<em class="ls">而不是</em>的<code class="fe mr ms mt mu b">package.json</code>。</p><p id="25d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不熟悉包管理器的模块解析是如何工作的，如果你遇到安装问题，你可能会尝试删除所有内容(包括锁文件)并重新安装，但是你应该<em class="ls">永远不要删除锁文件</em>，因为这可能会由于意外升级依赖关系而引入破坏性的改变。为了更好地理解这一点，你需要知道<a class="ae kv" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a> (semver)在<code class="fe mr ms mt mu b">package.json</code>中是如何使用的。</p><h2 id="ff8b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">永远101</h2><p id="b360" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">semver中的版本号由3组数字组成，用一个<code class="fe mr ms mt mu b">.</code>隔开，例如<code class="fe mr ms mt mu b">1.2.3</code>分别代表<code class="fe mr ms mt mu b">major.minor.patch</code>。semver文档解释了其中的每一项:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="3075" class="lt lu iq mu b gy mz na l nb nc">1. MAJOR version when you make incompatible API changes,<br/>2. MINOR version when you add functionality in a backwards compatible manner, and<br/>3. PATCH version when you make backwards compatible bug fixes.</span></pre><p id="6dbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">package.json</code>中，对于每个依赖项，您将看到一个相应的服务器号。有时这是前缀克拉<code class="fe mr ms mt mu b">^</code>或波浪号<code class="fe mr ms mt mu b">~</code>。</p><ol class=""><li id="1f9d" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><code class="fe mr ms mt mu b">^1.2.3</code> —安装最新版本的<code class="fe mr ms mt mu b">1.X.X</code>(不要超过指定的专业，只需更高的副专业和补丁号)。</li><li id="bc7d" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><code class="fe mr ms mt mu b">~1.2.3</code> —安装最新版本的<code class="fe mr ms mt mu b">1.2.X</code>(不要超过指定的主要或次要版本，只需更高的补丁号)。</li></ol><p id="c485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您需要对版本范围进行更精细的控制，您可以使用<a class="ae kv" href="https://docs.npmjs.com/cli/v6/using-npm/semver#ranges" rel="noopener ugc nofollow" target="_blank">范围操作符</a>(例如<code class="fe mr ms mt mu b">&gt;=</code>)。</p><h2 id="6857" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">删除锁定文件会如何影响版本控制</h2><p id="50a2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">假设我们的项目有一个依赖项，版本为<code class="fe mr ms mt mu b">^1.0.0</code>的<code class="fe mr ms mt mu b">example-package</code>。这是首次安装时可用的最新版本，并作为<code class="fe mr ms mt mu b">1.0.0</code>添加到锁定文件中。一个月后，一个新版本的<code class="fe mr ms mt mu b">example-package</code>出来了<code class="fe mr ms mt mu b">1.1.0</code>。让我们假设一个新的开发人员加入了您的团队，克隆了项目存储库，并安装了项目。</p><p id="5077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">package.json</code>中的版本是<code class="fe mr ms mt mu b">^1.0.0</code>(指最新的<code class="fe mr ms mt mu b">1.X.X</code>)，所以你会以为<code class="fe mr ms mt mu b">1.1.0</code>会安装在新开发者的机器上，但事实并非如此。当依赖项第一次添加到项目中时，<code class="fe mr ms mt mu b">1.1.0</code>并不存在，所以锁文件中列出的版本是<code class="fe mr ms mt mu b">1.0.0</code>。因此，尽管有符合<code class="fe mr ms mt mu b">package.json</code>中semver规范的更新版本，仍将一直安装<code class="fe mr ms mt mu b">1.0.0</code>。</p><p id="3420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您没有将锁定文件提交到您的库，或者删除锁定文件并重新安装您的节点模块，那么将安装版本<code class="fe mr ms mt mu b">example-package</code>的<code class="fe mr ms mt mu b">1.1.0</code>，因为它将被视为第一次安装。新的bug可能已经被引入到<code class="fe mr ms mt mu b">1.1.0</code>中，或者可能包的依赖关系已经改变，并且与项目中的其他依赖关系不兼容。</p><p id="50ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么删除锁文件会无意中导致依赖关系升级，从而导致应用程序崩溃。</p><h2 id="1f30" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">版本锁定</h2><p id="f128" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">您可能认为简单地从您的版本号中删除<code class="fe mr ms mt mu b">^</code>或<code class="fe mr ms mt mu b">~</code>来指定依赖项的确切版本就可以解决这个问题。不幸的是，即使您明确地将每个依赖项的确切版本放在您的<code class="fe mr ms mt mu b">package.json</code>中，如果没有锁文件，您仍然可能意外地升级依赖项的依赖项。</p><p id="25d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，包只是JavaScript模块，可以互换功能，这意味着它们可以从其他包中导入和使用模块。因此，锁文件不仅处理<code class="fe mr ms mt mu b">package.json</code>中列出的依赖项的版本控制，还处理<em class="ls">依赖树</em>中的所有包。在下面的例子中，<code class="fe mr ms mt mu b">example-package</code>在它自己的<code class="fe mr ms mt mu b">package.json</code>版本<code class="fe mr ms mt mu b">^1.0.0</code>中有一个依赖项<code class="fe mr ms mt mu b">foobar</code>，而<code class="fe mr ms mt mu b">foobar</code>在<code class="fe mr ms mt mu b">~1.0.0</code>有它自己的依赖项<code class="fe mr ms mt mu b">fizzbuzz</code>。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="b79a" class="lt lu iq mu b gy mz na l nb nc">// Hierarchal representation of dependency tree</span><span id="5753" class="lt lu iq mu b gy nr na l nb nc">root<br/>└─┬ example-package@1.0.0<br/>  └─┬ foobar@^1.0.0<br/>    └── fizzbuzz@~1.0.0</span></pre><p id="45a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使我们锁定了<code class="fe mr ms mt mu b">example-package</code>的版本，我们仍然会遇到与<code class="fe mr ms mt mu b">foobar</code>和<code class="fe mr ms mt mu b">fizzbuzz</code>相同的意外升级问题，因为可能会发布一个有bug的新版本，并且它们的版本号没有被锁定。</p><p id="a2b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有锁文件，包管理器将更新任何依赖关系及其依赖关系等等，这可能会引入破坏性的更改。</p><h2 id="948b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">处理重复或冲突的包版本</h2><p id="fb7c" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">像<a class="ae kv" href="https://www.npmjs.com/package/react" rel="noopener ugc nofollow" target="_blank"> React </a>这样的软件包要求只安装一个版本，如果有多个版本，就会抛出一个错误。如果您的项目中有两个不同的包，并且每个包都有不同版本的React作为依赖项，那么您最终可能会安装两个不同版本的React。</p><p id="bb8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用命令<code class="fe mr ms mt mu b">yarn why</code>或<code class="fe mr ms mt mu b">npm ls</code>后跟包名(如<code class="fe mr ms mt mu b">yarn why example-package</code>)来检查依赖关系树。我个人更喜欢<code class="fe mr ms mt mu b">npm ls</code>，因为它提供了依赖层次的可视化表示。</p><p id="0d4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有符合<code class="fe mr ms mt mu b">package.json</code>中指定版本的通用版本，<code class="fe mr ms mt mu b">yarn</code>将在安装时自动进行重复数据删除，并解析为通用版本。如果你正在使用<code class="fe mr ms mt mu b">npm</code>，你需要运行<code class="fe mr ms mt mu b"><a class="ae kv" href="https://docs.npmjs.com/cli/v6/commands/npm-dedupe" rel="noopener ugc nofollow" target="_blank">npm dedupe</a></code>。</p><p id="f347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果安装程序找不到通用版本，那么您需要指定应该使用哪个版本。在您的<code class="fe mr ms mt mu b">package.json</code>中添加一个resolutions字段来指定依赖项和应该使用的版本。当您安装<code class="fe mr ms mt mu b">yarn</code>时，两个软件包中的版本将被您的分辨率字段中的版本覆盖。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="4448" class="lt lu iq mu b gy mz na l nb nc">// Example of resolutions field in the package.json</span><span id="6fb2" class="lt lu iq mu b gy nr na l nb nc">{<br/>  ...<br/>  resolutions: {<br/>    react: "17.0.1"<br/>  }<br/>}</span></pre><p id="f33b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然<code class="fe mr ms mt mu b">npm</code>在<code class="fe mr ms mt mu b">yarn</code>中没有等效的解决方案，但是您可以通过使用这个包的预安装钩子<a class="ae kv" href="https://www.npmjs.com/package/npm-force-resolutions" rel="noopener ugc nofollow" target="_blank"> npm-force-resolutions </a>来指定版本。</p><p id="4f96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案非常有用，不仅可以用于对包进行重复数据删除，还可以修复子依赖版本可能导致的任何问题。例如，一个包可能有一个存在安全漏洞的依赖项，您可以使用<code class="fe mr ms mt mu b">package.json</code>中的resolutions字段来强制它更新到一个修复了该漏洞的版本。</p><h2 id="ce0e" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">锁定文件中的冲突解决方案</h2><p id="ba2e" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我看到的另一个问题是，当合并分支时，如何解决锁文件中的冲突，特别是如果你的项目中不是所有的开发人员都是JavaScript开发人员或者习惯于使用<code class="fe mr ms mt mu b">yarn</code>、<code class="fe mr ms mt mu b">npm</code>或节点模块。这可能会让他们感到沮丧，因为如果他们需要同步分支，这可能会阻塞他们的工作流。</p><p id="97a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当多个git分支修改依赖项时(例如，添加新特性所需的新依赖项)，很可能会在锁文件中引入冲突。这是完全正常的，而且<code class="fe mr ms mt mu b">yarn</code>和<code class="fe mr ms mt mu b">npm</code>实际上使解决冲突变得非常简单。</p><p id="5ab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，总是解决<code class="fe mr ms mt mu b">package.json</code>中的冲突，并且不要<em class="ls">而不是</em>手动编辑锁文件。事实上，在<code class="fe mr ms mt mu b">yarn.lock</code>中有一个警告，说明不要手动编辑它。如果您没有对分支中的依赖项进行任何更改(例如，添加了一个新的依赖项，或者显式升级了一个依赖项)，那么您应该从目标分支中进行更改。然后，只需运行<code class="fe mr ms mt mu b">yarn</code>来运行软件包安装程序，这将自动修复<code class="fe mr ms mt mu b">yarn.lock</code>中的所有冲突。如果使用<code class="fe mr ms mt mu b">npm</code>，运行<code class="fe mr ms mt mu b">npm install --package-lock-only</code>进行同样的操作。然后，存放<code class="fe mr ms mt mu b">package.json</code>并锁定文件，继续用<code class="fe mr ms mt mu b">git merge --continue</code>合并您的分支。</p><h2 id="7268" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated"><strong class="ak">更新和删除未使用的依赖关系</strong></h2><p id="74db" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">良好的内务管理是依赖性管理的关键部分。您应该定期更新您的依赖项，以便与最新的安全修补程序保持同步，但是这需要小心安全地完成，以防止破坏您的应用程序。</p><p id="3d3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我曾见过依赖关系多年未更新的项目，解决所有安全漏洞的升级过程令人难以置信地痛苦，并引入了许多突破性的更改。</p><p id="edee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用命令<code class="fe mr ms mt mu b">yarn outdated</code>或<code class="fe mr ms mt mu b">npm outdated</code>检查哪些包已经过期，但是不要一次安装所有这些包的最新版本。以下是一些关于如何安全升级依赖项的提示。</p><ol class=""><li id="2ade" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">在功能分支上，一次仅升级一个包或一组相互依赖的相关包(例如React和ReactDOM)。如果您的应用程序中断了，那么识别哪个包是违规的就容易多了，并且pull请求也可以很容易地恢复。</li><li id="536c" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">确保您的应用程序有足够的测试覆盖率。如果您针对CI/CD管道中的pull请求运行您的测试套件，您可以自动捕捉到依赖项升级的特性分支上的重大更改。</li><li id="75de" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">使用自动化的依赖管理器。像<a class="ae kv" href="https://snyk.io/" rel="noopener ugc nofollow" target="_blank"> Snyk </a>、<a class="ae kv" href="https://dependabot.com/" rel="noopener ugc nofollow" target="_blank">dependent bot</a>和<a class="ae kv" href="https://greenkeeper.io/" rel="noopener ugc nofollow" target="_blank"> Greenkeeper </a>这样的服务可以添加到您的CI/CD管道中。该机器人将自动检查一个新的分支，并提出一个拉请求，以升级过时的依赖关系或已知安全漏洞的依赖关系。</li></ol><p id="1125" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还应该删除未使用的依赖项，因为这些依赖项可以释放空间并缩短安装时间，这对于您的应用程序构建过程来说会更有效。<a class="ae kv" href="https://github.com/depcheck/depcheck" rel="noopener ugc nofollow" target="_blank"> Depcheck </a>是一个伟大的工具，它将分析你的项目，并确定你的<code class="fe mr ms mt mu b">package.json</code>中缺少或未使用的依赖项。</p><h2 id="ff5d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">结论</h2><p id="62e9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">NPM包的版本控制对于保持应用程序的稳定性非常重要。</p><p id="0b58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该有意识地、系统地升级依赖项，以保持最新的安全修复，而不是通过删除锁定文件来意外升级。我从开发人员朋友那里听说过应用程序崩溃的可怕故事，他们工作的公司在CI/CD管道中删除了锁文件，或者没有提交到存储库中。</p><p id="8e7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解语义版本化以及包管理器如何使用<code class="fe mr ms mt mu b">package.json</code>和锁文件来解析版本对于良好的依赖关系管理是至关重要的，这将有助于防止您犯这些常见的错误，这些错误会将破坏性的更改引入到您的应用程序中。</p></div></div>    
</body>
</html>