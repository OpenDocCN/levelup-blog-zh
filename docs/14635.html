<html>
<head>
<title>Avoid Callback Hell With Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin协程避免回调</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/avoid-callback-hell-with-kotlin-coroutines-7a72a2a8a701?source=collection_archive---------3-----------------------#2022-12-14">https://levelup.gitconnected.com/avoid-callback-hell-with-kotlin-coroutines-7a72a2a8a701?source=collection_archive---------3-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e120" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">只需几行代码就可以将嵌套的回调调用替换为一次性操作或订阅操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5eac4f9e90cc07ed04c67c34ff9d45da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRLN4uIL-xxjdvGcOPwOlA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个Kotlin回调地狱的例子由<a class="ae ky" href="https://openai.com/blog/chatgpt/" rel="noopener ugc nofollow" target="_blank"> ChatGPT </a></figcaption></figure><p id="1f01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回调地狱是异步任务的后果，每个遇到过它的开发人员都讨厌它。</p><p id="c9b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它很难阅读，看起来很丑，维护是一种痛苦，尤其是当开始一个新的代码库时。</p><p id="fbe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了Kotlin，现在有了一个彻底摆脱回调地狱的解决方案，这就是Kotlin协程的用武之地。</p><p id="c5bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">科特林的协程很棒。它们易于学习，轻量级，被集成到语言中，使异步代码像顺序代码一样可读。</p><p id="a81c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，它的一个最大的特点是，他们允许开发者避免回调地狱噩梦，这就是我们将要看到如何做。</p><h1 id="7940" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摆脱回调</h1><p id="6882" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了消除回调地狱，我们将使用Kotlin协程和<strong class="lb iu"> suspend </strong>函数。</p><p id="0bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将用这个<strong class="lb iu"> suspend </strong>函数替换两种类型的回调。一次触发的回调和作为订阅者-消费者模型监听更新的回调。</p><h2 id="2827" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">一次性复试</h2><p id="5dd7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，让我们从一次性回调开始。为此，我们需要一个<strong class="lb iu"> suspend </strong>函数来调用一个名为<code class="fe ne nf ng nh b">suspendCoroutine</code>的函数。如果发生错误，这个函数将返回计算出的值或传播抛出的异常。</p><p id="e04f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">suspendCoroutine</code>方法接受一个lambda，这是我们像往常一样使用回调监听器的地方，不同的是，一旦我们有了结果，我们将接受<code class="fe ne nf ng nh b">suspendCoroutine</code> lambda的<code class="fe ne nf ng nh b">continuation</code>参数，并继续执行调用<code class="fe ne nf ng nh b">resume</code>的协程，并返回值。</p><p id="c1b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe ne nf ng nh b">resume</code>还有其他选项，比如<code class="fe ne nf ng nh b">resumeWith</code>，如果你需要报道失败或成功的案例，需要一个<code class="fe ne nf ng nh b">Result</code>。如果你想返回一个异常，还有<code class="fe ne nf ng nh b">resumeWithException</code>，这是在失败的情况下调用<code class="fe ne nf ng nh b">resumeWith</code>。</p><p id="eaba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢将这些代码实现为类的扩展函数，我将这些方法从基于回调的方法转换为顺序代码，如下例所示。</p><p id="f7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我使用<code class="fe ne nf ng nh b">suspendCoroutine</code>函数从<a class="ae ky" href="https://firebase.google.com/docs/database/android/read-and-write" rel="noopener ugc nofollow" target="_blank"> Firebase实时数据库</a>中读取数据。</p><pre class="kj kk kl km gt ni nh nj bn nk nl bi"><span id="ffa0" class="nm lw it nh b be nn no l np nq">suspend fun DatabaseReference.read(): DataSnapshot = suspendCoroutine { continuation -&gt;<br/>    val valueEventListener = object : ValueEventListener {<br/>        override fun onCancelled(error: DatabaseError) {<br/>            continuation.resumeWithException(error.toException())<br/>        }<br/><br/>        override fun onDataChange(snapshot: DataSnapshot) {<br/>            continuation.resume(snapshot)<br/>        }<br/>    }<br/>    addListenerForSingleValueEvent(valueEventListener)<br/>}</span></pre><p id="bd79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要调用这段代码，唯一需要的是一个协程作用域，所以在调用函数之前，你必须记住这样做。与您可以直接调用的回调模式相比，这可以被认为是一个缺点，但是如果您忘记了协程作用域，编译器会告诉您，所以我不觉得这有什么不同。</p><p id="8d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里你可以看到如何调用上面创建的方法，现在，防止开发人员使用回调。</p><pre class="kj kk kl km gt ni nh nj bn nk nl bi"><span id="bc3a" class="nm lw it nh b be nn no l np nq">suspend fun getGroups(): List&lt;Group&gt; {<br/>    return groupRef.read().mapToGroups()<br/>}</span></pre><h2 id="2dcc" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">基于订阅的回访</h2><p id="7f6c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，对于不断发出数据的回调，例如，每次数据库中的值改变时，我们将依赖Kotlin流<strong class="lb iu">。</strong></p><p id="e66d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">科特林流<strong class="lb iu"> </strong>有一个函数<code class="fe ne nf ng nh b">callbackFlow</code>，它返回一个<code class="fe ne nf ng nh b">Flow</code>。这段代码将托管我们想要消除的侦听器，并在每次注意到更新时发出一个值。它还负责在不再需要数据流时执行代码。</p><p id="e6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe ne nf ng nh b">suspendCoroutine</code>一样，<code class="fe ne nf ng nh b">callbackFlow</code>在我们要执行监听器的地方取一个lambda，每次我们想要发出数据时，都需要调用带有发送对象的<code class="fe ne nf ng nh b">trySend</code>。</p><p id="4604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个lambda中，我们还需要调用<code class="fe ne nf ng nh b">awaitClose</code>，它也需要一个lambda，一旦不再需要<code class="fe ne nf ng nh b">Flow</code>就会执行这个lambda。这是强制性的，如果不这样做，代码就会崩溃。</p><p id="7a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗憾的是，编译器不会提醒我们这一点，所以不要忘记添加它以避免运行时错误。</p><p id="2c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码片段中，您可以看到如何使用<code class="fe ne nf ng nh b">callbackFlow</code>来监听Firebase实时数据库中的变化，同样是在扩展函数中实现的。</p><pre class="kj kk kl km gt ni nh nj bn nk nl bi"><span id="73d3" class="nm lw it nh b be nn no l np nq">suspend fun DatabaseReference.subscribe(): Flow&lt;Player&gt; = callbackFlow {<br/>    val childEventListener = object : ChildEventListener {<br/>        override fun onChildAdded(snapshot: DataSnapshot, previousChildName: String?) {<br/>            trySend(<br/>                Player(<br/>                    snapshot.key<br/>                )<br/>            )<br/>        }<br/>        override fun onChildChanged(snapshot: DataSnapshot, previousChildName: String?) {}<br/>        override fun onChildRemoved(snapshot: DataSnapshot) {}<br/>        override fun onChildMoved(snapshot: DataSnapshot, previousChildName: String?) {}<br/>        override fun onCancelled(error: DatabaseError) {}<br/>    }<br/>    addChildEventListener(childEventListener)<br/>    awaitClose {<br/>        removeEventListener(childEventListener)<br/>    }<br/>}</span></pre><p id="85eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是返回一个普通的<code class="fe ne nf ng nh b">Flow</code>，我们只需要在我们的消费者中调用<code class="fe ne nf ng nh b">collect</code>来读取发出的数据，并对它做我们想做的任何事情，如下面的例子所示，其中<code class="fe ne nf ng nh b">flow</code>变量是之前由<code class="fe ne nf ng nh b">callbackFlow</code>返回的变量。</p><pre class="kj kk kl km gt ni nh nj bn nk nl bi"><span id="2a26" class="nm lw it nh b be nn no l np nq">flow.collect { result -&gt;<br/>    _player.postValue(cachePlayers)<br/>}</span></pre><h1 id="aee6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5514" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这实际上很容易实现，最后以回调地狱结束。有了这些改变，你可以调用曾经是回调的代码，一个接一个地按顺序调用，没有无限的缩进，并且更新一些被认为是用Java而不是Kotlin来使用的旧库。</p><p id="a7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果你在Android上使用这个，现在你可以用一个用例层实现干净的架构，更容易更干净地管理错误，如果你使用的是<a class="ae ky" href="https://medium.com/codex/should-you-migrate-your-android-projects-from-mvp-to-mvvm-d8ca3ded037c" rel="noopener"> MVVM </a>，只需使用<code class="fe ne nf ng nh b">viewModelScope</code>作为你的协程作用域。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="83f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想阅读更多这样的内容，并支持我，不要忘记检查我的个人资料，或给媒体一个机会，成为会员，以获得我和其他作家的无限故事。每月只有5美元，如果你使用这个<a class="ae ky" href="https://medium.com/@molidev8/membership" rel="noopener">链接</a>，我会得到一小笔佣金。</p><div class="ny nz gp gr oa ob"><a href="https://medium.com/@molidev8/membership" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">通过我的推荐链接加入Medium—Miguel</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">阅读米格尔的每一个故事(以及媒体上成千上万的其他作家)。你的会员费直接支持米盖尔…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>