<html>
<head>
<title>Coding Problem: Nth Fibonacci Number in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码问题:Golang中的第n个斐波那契数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coding-problem-nth-fibonacci-number-in-golang-68db104e318?source=collection_archive---------9-----------------------#2021-02-03">https://levelup.gitconnected.com/coding-problem-nth-fibonacci-number-in-golang-68db104e318?source=collection_archive---------9-----------------------#2021-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f5a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你知道最优解吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd9d6e2e474947a720d50887fb589baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C26wsAeYZsO8EuqY.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自DeepDreamGenerator上的<a class="ae ky" href="https://deepdreamgenerator.com/ddream/6e89inus98p" rel="noopener ugc nofollow" target="_blank">权池</a></figcaption></figure><p id="882d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">斐波那契数列是数学中最著名的模式之一。每个术语都是由前两个术语构建而成，以两个基本案例作为模式的开始。第一个基本情况值为零，第二个值为一。从这里，我们可以使用下面的公式计算任何斐波纳契数:</p><blockquote class="me mf mg"><p id="76f3" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">斐波那契(n)=斐波那契(n-1)+斐波那契(n-2)</p></blockquote><p id="b8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">斐波那契数列是一个完美的问题，可以测试你的计算机科学基础知识和编码技能。在本文中，我们将通过三个例子来说明如何使用编程语言go尽可能高效地计算第n个斐波那契数。作为参考，这个问题也可以在Leetcode上解决:</p><div class="ml mm gp gr mn mo"><a href="https://leetcode.com/problems/fibonacci-number/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">斐波那契数- LeetCode</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">leetcode.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ks mo"/></div></div></a></div><p id="fff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>本教程假设您了解递归和堆栈数据结构。</p><p id="e690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来编码吧！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="1c7b" class="nk nl it bd nm nn no np nq nr ns nt nu jz nv ka nw kc nx kd ny kf nz kg oa ob bi translated">一个递归解— O(2^N)时间，O(N)空间</h1><p id="bf7b" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">最初的简单解决方案是将第n个斐波那契数列的公式直接翻译成代码。我们所要做的就是检查我们是否处于<code class="fe oh oi oj ok b">n==1</code>或<code class="fe oh oi oj ok b">n==2</code>的基本情况，如果不是，我们递归地返回带有参数<code class="fe oh oi oj ok b">n-1</code>和<code class="fe oh oi oj ok b">n-2</code>的<code class="fe oh oi oj ok b">fib()</code>。说真的，这个解决方案干净简洁！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对这一功能的时间和空间分析比看上去更有逻辑性。因为这是一个递归函数，我们将建立一个调用栈，如下所示。假设我们调用<code class="fe oh oi oj ok b">fib(5)</code>，这将给我们一个调用栈，总共有9个对我们函数的调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/22b815347a81454c14691709947646ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMt8sdi-zmF9OSD8XcdjSg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用Lucidchart做的</figcaption></figure><p id="8aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实际上将从左到右遍历树，一旦到达左下方的Fibonacci(2 ),我们将弹出调用堆栈中的第一个元素。因此，我们的调用堆栈看起来像这样:</p><blockquote class="me mf mg"><p id="d3e3" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">调用堆栈:<code class="fe oh oi oj ok b">fib(5)-&gt;fib(4)-&gt;fib(3)-&gt;fib(2)</code></p></blockquote><p id="f745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着堆栈变大，空间复杂度变为O(N ),因为在弹出值之前，我们必须在堆栈中存储大约N个值。说到时间复杂度，想想我们在斐波纳契树中创建了多少个节点。它看起来类似于二叉树，因为我们必须满足N=1或N=2的基本条件。</p><p id="98a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非斐波纳契树中的一个节点是一个基本情况，否则我们必须为每个节点计算2个值。随着树的增长，这很快接近2^N节点总数，因此递归斐波纳契的时间复杂度是一个糟糕的O(2^N).让我们做得更好！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="6fb1" class="nk nl it bd nm nn no np nq nr ns nt nu jz nv ka nw kc nx kd ny kf nz kg oa ob bi translated">动态规划— O(N)时间，O(N)空间</h1><p id="a351" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">关于上面的例子，你应该注意到的一件事是我们重复自己——很多次。为了优化我们的策略，有一种我们已经见过的存储值的方法，称为<em class="mh">动态编程</em>。</p><blockquote class="me mf mg"><p id="ed1e" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">尽管名字好听，动态编程只是意味着我们缓存先前计算的值，以便我们可以引用它们供以后使用。这个过程在计算斐波那契值时给了我们显著的性能提升！</p></blockquote><p id="b964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先初始化一个地图，从斐波那契数列的基本情况开始。然后，我们有一个名为<code class="fe oh oi oj ok b">computeCache()</code>的辅助函数，它接受我们想要的第n个斐波那契值以及我们的<code class="fe oh oi oj ok b">baseCases</code>图作为它的参数。</p><p id="1ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">助手方法<code class="fe oh oi oj ok b">computeCache()</code>将在第10行有一个很好的Go条件，在这里它获得<code class="fe oh oi oj ok b">cache</code>中键<code class="fe oh oi oj ok b">n</code>的值<code class="fe oh oi oj ok b">val</code>。如果确实有一个键值对，布尔运算<code class="fe oh oi oj ok b">found</code>为真，否则为假。因此，在我们得到元组<code class="fe oh oi oj ok b">val, found := cache[n]</code>后，我们在末尾添加一个<code class="fe oh oi oj ok b">;</code>，然后如果<code class="fe oh oi oj ok b">found</code>为真，if语句将通过。</p><p id="9604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我们检查散列图<code class="fe oh oi oj ok b">cache</code>，看看我们是否已经计算了当前的斐波那契数列值。</p><p id="3bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们以前没有见过这个值，我们通过将<code class="fe oh oi oj ok b">cache[n]</code>赋值为等于对<code class="fe oh oi oj ok b">computeCache()</code>的递归调用来计算它。我们遵循与第一个例子相同的递归公式，只是现在我们传递一个缓存来跟踪我们的值。嘣！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="9698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再来看看我们对这个算法的时空分析。我们仍然有递归调用，所以我们仍然有一个调用栈，从N开始，一直到N=1或N=2的基本情况。一旦我们构建了第一个链，我们将不会执行重复的工作，但是我们仍然受限于O(N)空间复杂度，因为除了在缓存中存储我们的计算值之外，还有调用栈<em class="mh">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/8c4e6c297214c4381168e7a026c73440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIGjLm3eoYCEGMoCiypVcA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用动态规划计算斐波纳契值</figcaption></figure><p id="2f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态编程极大地提高了我们的时间复杂度。我们不需要为每个Fibonacci调用计算多达两个值，而只需要计算我们以前没有见过的值。因此，我们需要计算从N到我们的基本情况的斐波纳契值，其余的计算是常数时间操作。因此，我们的新算法具有O(N)时间复杂度。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="9dc8" class="nk nl it bd nm nn no np nq nr ns nt nu jz nv ka nw kc nx kd ny kf nz kg oa ob bi translated">Fib on the Fly — O(N)时间，O(1)空间</h1><p id="08be" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">优化算法有一些共同的主题。问我们自己的两个大问题包括我们是否在重复工作。如果是这样，我们如何存储我们之前计算的值呢？如果我们已经存储了值，有没有一种方法可以实现我们算法的本质，而不必存储任何工件？</p><p id="ad50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步需要非常了解问题的本质。斐波那契数列的本质是什么？就是我们现在的价值是建立在前两个价值之上的。因此，从基础案例开始，如果我们使用之前的两个值计算当前值，然后用新的Fibonacci值替换之前的一个值，会怎么样？</p><p id="ee18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它写成代码。我们首先初始化一个数组<code class="fe oh oi oj ok b">prevFibs[]</code>(如果你愿意，你可以使用一个元组或者两个单独的变量),它从我们的基本情况值0和1开始。接下来，我们开始一个for循环，它根据前两个Fibonacci值计算下一个Fibonacci值，然后用我们刚刚计算的值替换最早的Fibonacci值。</p><p id="9211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>因为我们已经有了n=1和n=2的基本情况，我们必须初始化<code class="fe oh oi oj ok b">i=3</code>来开始我们的循环。</p><p id="c92b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们计算出最后一个斐波纳契值<code class="fe oh oi oj ok b">i=n</code>，我们需要返回最近计算的数字<code class="fe oh oi oj ok b">prevFibs[1]</code>。</p><p id="5baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">另一个注意:</strong>只有一种情况下这个逻辑不成立，那就是当n=1时，那么我们必须立即返回基本情况值为0的<code class="fe oh oi oj ok b">prevFibs[0]</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5ca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该是迄今为止最简单的时空分析。我们有的只是一个从3开始向上到N的for循环，所以我们的时间复杂度简单来说就是O(N)！除了两个元素的数组之外，我们不再存储任何数据结构。由于这是一个常数成本，我们的空间复杂度将是O(1)，我们已经成功地优化了在Go中计算斐波那契值！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="11cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，并能够学到一些新的东西。如果你有任何其他的话题想写或者只是喜欢这篇文章，我鼓励你在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>