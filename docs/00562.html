<html>
<head>
<title>Docker for Frontend Devs: Custom Docker Images for Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于前端开发的Docker:用于开发的自定义Docker映像</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-for-frontend-devs-custom-docker-images-for-development-121322ac18d8?source=collection_archive---------0-----------------------#2019-05-08">https://levelup.gitconnected.com/docker-for-frontend-devs-custom-docker-images-for-development-121322ac18d8?source=collection_archive---------0-----------------------#2019-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ca74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作者:本杰明·马丁</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2f0554a970278a139957bca71fb94b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MliryGsmPcZGf-Fm.png"/></div></div></figure><p id="9405" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们花一点时间来考虑什么对当地发展是重要的。对我来说，我希望确保我的所有开发人员都使用相同的依赖项，我不想担心他们安装了什么版本。不再有“但是它在我的机器上工作”的借口。同时，我想确保我们保留了HMR(热模块替换)的便利性，这样开发人员就不需要不断刷新应用程序来查看他们的更改。我们不想失去快速反馈。</p><p id="79a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将了解如何使用定制的<code class="fe la lb lc ld b">Dockerfile</code>为样板VueJS应用程序设置Docker，我们的图像和容器将从这些应用程序中构建，以及我们如何从中获得效率。</p><p id="a506" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您错过了本系列的第一部分，<a class="ae le" href="https://blog.rangle.io/learning-docker-command-line-interface/" rel="noopener ugc nofollow" target="_blank">查看这里以了解Docker附带的命令行界面</a>的更多信息。在本节中，我们需要使用那篇文章中的命令。如果您已经熟悉Docker CLI，请继续学习。</p><h1 id="7b4b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件:创建我们的项目</h1><p id="b71a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这当然是一篇Docker文章，所以请确保你已经安装了Docker。你可以按照<a class="ae le" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">Docker的官方安装说明在这里</a>。自从我使用Vue以来，我已经用VueCLI和<code class="fe la lb lc ld b">vue create docker-demo</code>快速创建了一个工作区。</p><blockquote class="mi mj mk"><p id="4b25" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><em class="it">我选择的配置(见下文)将与E2E测试和单元测试相关，这将成为我们CI/CD管道的一部分。</em></p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/3a8c504cef21d787a7f95d357f337f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*S6q2TBpSaNBYxck2.gif"/></div></figure><p id="ed03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦一切都安装完毕，<code class="fe la lb lc ld b">cd</code>进入我们的新项目文件夹，打开一个IDE，让我们开始工作。</p><h1 id="ab5b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用于开发的自定义Docker图像</h1><p id="5743" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果你玩过Docker但没有构建自己的映像，你可能知道我们在执行<code class="fe la lb lc ld b">docker run</code>命令时指定了一个映像。这些映像是从Docker Hub或其他远程存储库中提取的(如果在本地没有找到该映像)。但是在我们的例子中，我们想要构建一个定制的图像。</p><p id="a57c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们项目的根目录下，创建一个名为<code class="fe la lb lc ld b">Dockerfile.dev</code>的文件。这将是我们的发展形象。在该文件中，将以下代码复制到其中。</p><pre class="kp kq kr ks gt mq ld mr ms aw mt bi"><span id="31d5" class="mu lg it ld b gy mv mw l mx my"># Base Image FROM node:9.11.1 ENV NODE_ENV=development ENV PORT=8080 WORKDIR /usr/src/app COPY package*.json /usr/src/app/ RUN cd /usr/src/app &amp;&amp; CI=true npm install EXPOSE 8080 CMD ["npm", "run", "serve"]</span></pre><p id="60b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧……但是这一切有什么用呢？让我们深入研究一下。</p><h1 id="ba3b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Dockerfile命令和关键字</h1><p id="d955" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu">FROM</strong></code>指定预先存在的图像，在其上构建我们的自定义图像。因为我们正在运行一个节点应用程序，所以我们选择了他们的一个官方Docker映像。</p><blockquote class="mi mj mk"><p id="1a69" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><em class="it"> FROM node:9.11.1意味着我们的应用程序映像将从node v 9.11.1映像开始</em></p></blockquote><p id="f05b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu">ENV</strong></code>设置环境变量</p><blockquote class="mi mj mk"><p id="fd98" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu"><em class="it">ENV PORT=8080</em></strong></code> <em class="it">设置环境变量</em> <code class="fe la lb lc ld b"><em class="it">PORT</em></code> <em class="it">以备后用</em></p><p id="8860" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu"><em class="it">ENV NODE_ENV=development</em></strong></code> <em class="it">设置环境变量</em> <code class="fe la lb lc ld b"><em class="it">NODE_ENV</em></code> <em class="it">以便在我们的应用</em>中使用</p></blockquote><p id="1840" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu">WORKDIR</strong></code>设置容器内的工作目录</p><blockquote class="mi mj mk"><p id="0869" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu"><em class="it">WORKDIR /usr/src/app</em></strong></code> <em class="it">定义</em> <code class="fe la lb lc ld b"><em class="it">/usr/src/app/</em></code> <em class="it">为我们在docker镜像</em>内的工作目录</p></blockquote><p id="f97b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu">COPY</strong></code>将新文件、目录或远程文件复制到容器/映像中</p><blockquote class="mi mj mk"><p id="c8fa" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu"><em class="it">COPY package*.json /usr/src/app/</em></strong></code> <em class="it">将我们的</em> <code class="fe la lb lc ld b"><em class="it">package.json</em></code> <em class="it">和</em> <code class="fe la lb lc ld b"><em class="it">package-lock.json</em></code> <em class="it">复制到我们的工作目录</em></p></blockquote><p id="ed17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu">RUN</strong></code>在当前图像顶部的新图层中执行命令并提交。当您运行构建时，您将看到一个代表最终图像每一层的散列</p><blockquote class="mi mj mk"><p id="bafd" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu"><em class="it">RUN cd /usr/src/app/ &amp;&amp; CI=true npm install</em></strong></code> <em class="it">将工作目录更改为</em> <code class="fe la lb lc ld b"><em class="it">package.json</em></code> <em class="it">所在的位置，并将我们所有的依赖项安装到映像中的这个文件夹。这使得映像保存依赖项的冻结副本。我们的Docker映像，而不是我们的主机，对我们的依赖性负责</em></p></blockquote><p id="f7c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu">EXPOSE</strong></code>允许我们从我们的主机访问容器上的端口</p><blockquote class="mi mj mk"><p id="b724" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu"><em class="it">EXPOSE 8080</em></strong></code> <em class="it">在容器内匹配我们的应用程序运行的端口，并允许我们从我们的主机访问我们的应用程序</em></p></blockquote><p id="bcce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu">CMD</strong></code>提供创建容器时运行的默认初始化命令，就像启动脚本一样</p><blockquote class="mi mj mk"><p id="5acc" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><code class="fe la lb lc ld b"><strong class="js iu"><em class="it">CMD ["npm", "run", "serve"]</em></strong></code> <em class="it">当我们启动我们的容器时，设置这个为默认命令。这不是在构建映像时运行的，它只定义当容器启动时应该运行什么命令。</em></p></blockquote><p id="9583" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道你很想让它运行起来，但是不要着急。让我们更仔细地观察我们的<code class="fe la lb lc ld b">Dockerfile.dev</code>并理解<em class="ml">为什么</em>我们会这样做。</p><h1 id="329c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Dockerfile文件结构建议</h1><p id="71ba" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">那么，<em class="ml">我的app呢？</em></p><p id="f512" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没错。我们没有使用<code class="fe la lb lc ld b">COPY</code>命令来复制我们的整个工作空间。如果我们这样做了，我们需要为每一个代码变更运行<code class="fe la lb lc ld b">docker build</code>和<code class="fe la lb lc ld b">docker run</code>。我们不想为了发展而一遍又一遍地这样做。我们可以更有效率</p><h2 id="44ea" class="mu lg it bd lh mz na dn ll nb nc dp lp kb nd ne lt kf nf ng lx kj nh ni mb nj bi translated">缓存依赖项</h2><p id="06c1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们正在利用Docker如何分层图像。当Docker构建我们的图像时，你会看到每一层的散列。更重要的是，Docker也缓存了这些层。如果Docker可以看到该层与以前的版本相比没有任何变化(并且以前的层也是相同的)，那么Docker将使用该层的缓存版本，为您和您的开发人员节省宝贵的时间！当图层发生变化时，该图层上的任何缓存图层都将失效，并将重新构建。</p><p id="6af5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ml">因此，如果我们的</em> <code class="fe la lb lc ld b"><em class="ml">package.json</em></code> <em class="ml">或</em> <code class="fe la lb lc ld b"><em class="ml">package-lock.json</em></code> <em class="ml">没有变化，那么我们的整个图像是可缓存的，不需要重建！</em></p><h2 id="7976" class="mu lg it bd lh mz na dn ll nb nc dp lp kb nd ne lt kf nf ng lx kj nh ni mb nj bi translated">优先</h2><p id="0e1a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这也是为什么你想让其他的<code class="fe la lb lc ld b">Dockerfile</code>命令在我们文件的顶部附近不那么频繁的改变。一旦我们缓存的一层失效，例如，如果您将<code class="fe la lb lc ld b">ENV PORT=8080</code>更改为另一个端口，该缓存层及其后的每个缓存层都会失效，Docker将不得不重建这些层。</p><h1 id="d629" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">构建自定义Docker映像</h1><p id="5465" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">现在，用这个命令构建图像:<code class="fe la lb lc ld b">docker build --tag docker_demo:latest --file Dockerfile.dev .</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/b2fb7e713f4608e133609491f82ae014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XVG78qupSo0rRzu4.gif"/></div></div></figure><blockquote class="mi mj mk"><p id="701b" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><em class="it">在</em> <code class="fe la lb lc ld b"><em class="it">docker build</em></code> <em class="it">命令中使用允许我们从</em> <code class="fe la lb lc ld b"><em class="it">docker run</em></code> <em class="it">命令</em>中轻松引用该图像</p><p id="5891" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><em class="it"/><code class="fe la lb lc ld b"><em class="it">.</em></code><em class="it"/><code class="fe la lb lc ld b"><em class="it">docker build</em></code><em class="it">命令引用了我们自定义</em> <code class="fe la lb lc ld b"><em class="it">Dockerfile</em></code> <em class="it">的上下文。所以，这个命令应该从我们的项目目录</em>的根目录运行</p></blockquote><p id="f0b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以用<code class="fe la lb lc ld b">docker run docker_demo:latest</code>来运行它，但是不幸的是，我们还需要做更多的工作来让它从命令行快速而容易地工作。</p><h1 id="4cec" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">运行我们的容器:提高生活质量</h1><p id="048f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们将每天执行我们的<code class="fe la lb lc ld b">docker run</code>命令，如果不是更频繁的话。然而，如果我们简单地执行<code class="fe la lb lc ld b">docker run docker_demo:latest</code>命令，Docker每次都会创建一个<em class="ml">新的</em>容器。Docker不会停止旧容器，除非你明确地这样做。这在许多情况下非常有用，但是因为我们已经硬编码了主机端口，所以我们将在我们的主机上遇到端口冲突。</p><p id="f34d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让我们能够轻松地停止和移除我们的旧容器，我们应该给它们命名，以便我们以后能够轻松地引用它们。此外，如果我取消正在运行的进程，我希望正在运行的容器被删除。</p><pre class="kp kq kr ks gt mq ld mr ms aw mt bi"><span id="59d1" class="mu lg it ld b gy mv mw l mx my">docker run --rm -it \ --name docker_demo_container \ docker_demo:latest</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/f543c41b2144bc4c00b462a5a904dcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZsQRBhFmlUbEeNcF.gif"/></div></div></figure><h2 id="9973" class="mu lg it bd lh mz na dn ll nb nc dp lp kb nd ne lt kf nf ng lx kj nh ni mb nj bi translated">添加了什么？</h2><p id="c381" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们在运行命令的末尾添加了一个<code class="fe la lb lc ld b">--name</code>字段。这允许我们引用容器而不用查找散列。现在，我们可以很容易地通过名字来停止我们的容器。</p><p id="3aa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还在我们的<code class="fe la lb lc ld b">docker run</code>命令中添加了<code class="fe la lb lc ld b">--rm</code>和<code class="fe la lb lc ld b">-it</code>标志。<code class="fe la lb lc ld b">--rm</code>标志告诉码头工人在集装箱停止时移除集装箱。一旦容器启动，<code class="fe la lb lc ld b">-it</code>标志保持终端活动和交互。</p><h2 id="2858" class="mu lg it bd lh mz na dn ll nb nc dp lp kb nd ne lt kf nf ng lx kj nh ni mb nj bi translated">装载主机目录</h2><p id="8072" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们回到我们的<code class="fe la lb lc ld b">docker run</code>命令，让我们找到一种方法将我们的工作空间目录挂载到我们的容器中的一个文件夹。我们可以通过在<code class="fe la lb lc ld b">docker run</code>命令中向我们的容器添加一个挂载点来做到这一点。这将告诉Docker，我们想要在我们的主机的文件夹(<code class="fe la lb lc ld b">src</code>)和Docker容器文件夹(<code class="fe la lb lc ld b">dst</code>)之间创建一个活动链接。我们的新命令应该如下所示:</p><pre class="kp kq kr ks gt mq ld mr ms aw mt bi"><span id="c147" class="mu lg it ld b gy mv mw l mx my">docker run --rm -it \ --name docker_demo_container \ --mount type=bind,src=`pwd`,dst=/usr/src/app \ docker_demo:latest</span></pre><p id="fa17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是这可能会与我们主机的<code class="fe la lb lc ld b">node_modules</code>文件夹冲突，因为我们将整个<code class="fe la lb lc ld b">pwd</code>挂载到我们的应用程序在映像中的位置(以防我们的开发人员不小心在他们的主机上运行了<code class="fe la lb lc ld b">npm install</code>)。因此，让我们添加一个卷，以确保我们保存容器中的<code class="fe la lb lc ld b">node_modules</code>。</p><pre class="kp kq kr ks gt mq ld mr ms aw mt bi"><span id="22c4" class="mu lg it ld b gy mv mw l mx my">docker run --rm -it \ --name docker_demo_container \ --mount type=bind,src=`pwd`,dst=/usr/src/app \ --volume /usr/src/app/node_modules \ docker_demo:latest</span></pre><h2 id="da51" class="mu lg it bd lh mz na dn ll nb nc dp lp kb nd ne lt kf nf ng lx kj nh ni mb nj bi translated">访问容器内部的端口</h2><p id="ca00" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果您尝试了上面的命令(并且您正在运行VueJS应用程序)，您应该会看到:</p><pre class="kp kq kr ks gt mq ld mr ms aw mt bi"><span id="93df" class="mu lg it ld b gy mv mw l mx my">App running at: - Local: http://localhost:8080/ It seems you are running Vue CLI inside a container. Access the dev server via http://localhost:&lt;your container's external mapped port&gt;/</span></pre><p id="6dc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker给你一个提示，我们需要从我们的容器中公开一个端口，并在我们的主机上发布。我们通过在运行命令中添加<code class="fe la lb lc ld b">--publish</code>标志来实现这一点。(我们的<code class="fe la lb lc ld b">Dockerfile.dev</code>中已经有了<code class="fe la lb lc ld b">EXPOSE</code>命令)</p><blockquote class="mi mj mk"><p id="ed21" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><em class="it">告诉Docker端口</em> <code class="fe la lb lc ld b"><em class="it">&lt;host-port&gt;</em></code> <em class="it">上的主机流量(即通过本地主机)应该被定向到您定义的</em> <code class="fe la lb lc ld b"><em class="it">&lt;container-port&gt;</em></code> <em class="it">处的容器。</em></p></blockquote><h1 id="d8de" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe la lb lc ld b">docker run</code>在一个命令中</h1><p id="e245" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们看一下我们的最终运行命令:</p><pre class="kp kq kr ks gt mq ld mr ms aw mt bi"><span id="29e8" class="mu lg it ld b gy mv mw l mx my">docker run --rm -it \ --name docker_demo_container \ --publish 4200:8080 \ --mount type=bind,src=`pwd`,dst=/usr/src/app \ --volume /usr/src/app/node_modules \ docker_demo:latest</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/4aabdd450b4530e36faa20d12a174d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GGSw879BRETWI5RF.gif"/></div></div></figure><p id="9adc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行上面的命令将最终允许我们通过<a class="ae le" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>访问我们的应用程序。</p><h1 id="16ae" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">测试它</h1><p id="2438" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们构建一个新的副本并运行它。如果你试着改变我们文件的一个模板，你会发现一切都正常运行。</p><p id="8140" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是说到测试，单元测试呢？一旦我们的容器开始运行，我们就可以打开一个新的终端，并在容器中运行一个命令。</p><pre class="kp kq kr ks gt mq ld mr ms aw mt bi"><span id="007f" class="mu lg it ld b gy mv mw l mx my">docker exec -it docker_demo_container npm run test:unit</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/9d47464fb81bcd2d4955d8013db337fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iEMWC67rGQB43Gac.gif"/></div></div></figure><p id="ee0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的命令将创建一个与我们的容器<code class="fe la lb lc ld b">docker_demo_container</code>的交互式终端连接，并在其中执行命令<code class="fe la lb lc ld b">npm run test:unit</code>，允许我们为我们的应用程序运行单元测试。</p><h1 id="c369" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">最后</h1><p id="d461" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们现在有一种方法来构建我们的开发映像并在本地运行它们，同时保持热模块替换的便利性，以保持我们的开发工作流的效率。我们的开发人员不需要担心他们的主机上的依赖项与映像中的那些相冲突。不再有“但是它在我的机器上工作”的借口。此外，我们还有一个可以轻松运行的命令来执行我们的单元测试。</p></div></div>    
</body>
</html>