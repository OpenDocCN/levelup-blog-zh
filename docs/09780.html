<html>
<head>
<title>How to execute an object file: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何执行目标文件:第3部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-execute-an-object-file-part-3-53574658ad2a?source=collection_archive---------17-----------------------#2021-09-12">https://levelup.gitconnected.com/how-to-execute-an-object-file-part-3-53574658ad2a?source=collection_archive---------17-----------------------#2021-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee17" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理外部库</h2></div><p id="1eaa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们系列的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-execute-an-object-file-part-2-655eb8b9a811">第2部分中，我们学习了如何处理目标文件中的重定位，以便正确地连接代码中的内部依赖关系。在这篇文章中，我们将研究如果代码有外部依赖会发生什么——也就是说，它试图从外部库调用函数。和以前一样，我们将基于第2部分</a>的代码构建<a class="ae lb" href="https://github.com/cloudflare/cloudflare-blog/tree/master/2021-03-obj-file/2" rel="noopener ugc nofollow" target="_blank">。让我们给我们的玩具对象文件添加另一个函数:</a></p><p id="a459" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">对象c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="46c3" class="lm ln iq li b gy lo lp l lq lr">#include &lt;stdio.h&gt;<br/> <br/>...<br/> <br/>void say_hello(void)<br/>{<br/>    puts("Hello, world!");<br/>}</span></pre><p id="639e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上述场景中，我们的<code class="fe ls lt lu li b">say_hello</code>函数现在依赖于C标准库中的<code class="fe ls lt lu li b">puts</code> <a class="ae lb" href="https://man7.org/linux/man-pages/man3/puts.3.html" rel="noopener ugc nofollow" target="_blank">函数。为了进行试验，我们还需要修改我们的<code class="fe ls lt lu li b">loader</code>来导入新函数并执行它:</a></p><p id="6c22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="502d" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>static void execute_funcs(void)<br/>{<br/>    /* pointers to imported functions */<br/>    int (*add5)(int);<br/>    int (*add10)(int);<br/>    const char *(*get_hello)(void);<br/>    int (*get_var)(void);<br/>    void (*set_var)(int num);<br/>    void (*say_hello)(void);<br/> <br/>...<br/> <br/>    say_hello = lookup_function("say_hello");<br/>    if (!say_hello) {<br/>        fputs("Failed to find say_hello function\n", stderr);<br/>        exit(ENOENT);<br/>    }<br/> <br/>    puts("Executing say_hello...");<br/>    say_hello();<br/>}<br/>...</span></pre><p id="706d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们运行它:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="ffbb" class="lm ln iq li b gy lo lp l lq lr">$ gcc -c obj.c<br/>$ gcc -o loader loader.c<br/>$ ./loader<br/>No runtime base address for section</span></pre><p id="bc49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe ls lt lu li b">loader</code>试图处理重定位时似乎出错了，所以让我们检查重定位表:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="e59f" class="lm ln iq li b gy lo lp l lq lr">$ readelf --relocs obj.o<br/> <br/>Relocation section '.rela.text' at offset 0x3c8 contains 7 entries:<br/>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br/>000000000020  000a00000004 R_X86_64_PLT32    0000000000000000 add5 - 4<br/>00000000002d  000a00000004 R_X86_64_PLT32    0000000000000000 add5 - 4<br/>00000000003a  000500000002 R_X86_64_PC32     0000000000000000 .rodata - 4<br/>000000000046  000300000002 R_X86_64_PC32     0000000000000000 .data - 4<br/>000000000058  000300000002 R_X86_64_PC32     0000000000000000 .data - 4<br/>000000000066  000500000002 R_X86_64_PC32     0000000000000000 .rodata - 4<br/>00000000006b  001100000004 R_X86_64_PLT32    0000000000000000 puts - 4<br/>...</span></pre><p id="ca41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译器为<code class="fe ls lt lu li b">puts</code>调用生成了一个重定位。重定位类型是<code class="fe ls lt lu li b">R_X86_64_PLT32</code>，我们的<code class="fe ls lt lu li b">loader</code>已经知道如何处理这些，所以问题在别处。上面的条目显示重定位引用了符号表中的第17个条目(十六进制的<code class="fe ls lt lu li b">0x11</code>),所以让我们检查一下:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="4c3d" class="lm ln iq li b gy lo lp l lq lr">$ readelf --symbols obj.o<br/> <br/>Symbol table '.symtab' contains 18 entries:<br/>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br/>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br/>     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS obj.c<br/>     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1<br/>     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3<br/>     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4<br/>     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5<br/>     6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    3 var<br/>     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    7<br/>     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    8<br/>     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    6<br/>    10: 0000000000000000    15 FUNC    GLOBAL DEFAULT    1 add5<br/>    11: 000000000000000f    36 FUNC    GLOBAL DEFAULT    1 add10<br/>    12: 0000000000000033    13 FUNC    GLOBAL DEFAULT    1 get_hello<br/>    13: 0000000000000040    12 FUNC    GLOBAL DEFAULT    1 get_var<br/>    14: 000000000000004c    19 FUNC    GLOBAL DEFAULT    1 set_var<br/>    15: 000000000000005f    19 FUNC    GLOBAL DEFAULT    1 say_hello<br/>    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_<br/>    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</span></pre><p id="5bcf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦！<code class="fe ls lt lu li b">puts</code>函数的节索引是<code class="fe ls lt lu li b">UND</code>(本质上是代码中的<code class="fe ls lt lu li b">0</code>)，这完全说得通:与前面的符号不同，<code class="fe ls lt lu li b">puts</code>是一个外部依赖项，它没有在我们的<code class="fe ls lt lu li b">obj.o</code>文件中实现。因此，它不能是<code class="fe ls lt lu li b">obj.o</code>内任何区段的一部分。那么，我们如何解决这种迁移？我们需要以某种方式将代码指向一个<code class="fe ls lt lu li b">puts</code>实现。我们的<code class="fe ls lt lu li b">loader</code>实际上已经可以访问C库<code class="fe ls lt lu li b">puts</code>函数(因为它是用C编写的，我们已经在<code class="fe ls lt lu li b">loader</code>代码本身中使用了<code class="fe ls lt lu li b">puts</code>)，但从技术上讲，它不必是C库<code class="fe ls lt lu li b">puts</code>，只是一些<code class="fe ls lt lu li b">puts</code>实现。为了完整起见，让我们在<code class="fe ls lt lu li b">loader</code>中实现我们自己的自定义<code class="fe ls lt lu li b">puts</code>函数，它只是C库<code class="fe ls lt lu li b">puts</code>的一个装饰器:</p><p id="732e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="6027" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>/* external dependencies for obj.o */<br/>static int my_puts(const char *s)<br/>{<br/>    puts("my_puts executed");<br/>    return puts(s);<br/>}<br/>...</span></pre><p id="56de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了一个<code class="fe ls lt lu li b">puts</code>实现(以及它的运行时地址),我们应该在<code class="fe ls lt lu li b">loader</code>中编写逻辑，通过指示代码跳转到正确的函数来解决重定位问题。然而，有一个复杂的问题:在我们系列的第2部分<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-execute-an-object-file-part-2-655eb8b9a811">中，当我们处理常量和全局变量的重定位时，我们了解到我们主要处理的是32位相对重定位，并且我们引用的代码或数据与重定位本身的距离需要不超过2147483647 ( <code class="fe ls lt lu li b">0x7fffffff</code>十六进制)字节。<code class="fe ls lt lu li b">R_X86_64_PLT32</code>也是一个32位相对重定位，所以它有相同的要求，但不幸的是我们不能重用来自</a><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-execute-an-object-file-part-2-655eb8b9a811">第2部分</a>的技巧，因为我们的<code class="fe ls lt lu li b">my_puts</code>函数是<code class="fe ls lt lu li b">loader</code>本身的一部分，我们不能控制操作系统将<code class="fe ls lt lu li b">loader</code>代码放在地址空间的什么地方。</p><p id="51c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，我们不必想出任何新的解决方案，只需借用共享库中使用的方法。</p><h2 id="b3c9" class="lm ln iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">探索PLT/GOT</h2><p id="5bcd" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">现实世界中的ELF可执行文件和共享库有相同的问题:通常可执行文件依赖于共享库，而共享库依赖于其他共享库。并且完整运行时程序的所有不同部分可以被映射到进程地址空间中的随机范围。当一个共享库或一个ELF可执行文件被链接在一起时，链接器会枚举所有的外部引用，并在ELF文件中创建两个或更多的附加部分(关于ELF部分的复习，请查看我们系列的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-execute-an-object-file-part-1-2c92d962f276">第1部分)。两个强制的是</a><a class="ae lb" href="https://refspecs.linuxfoundation.org/ELF/zSeries/lzsabi0_zSeries/x2251.html" rel="noopener ugc nofollow" target="_blank">过程链接表(PLT)和全局偏移量表(GOT) </a>。</p><p id="4ff9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不会深入研究标准PLT/GOT实现的细节，因为网上有许多其他很好的资源，但简单地说，PLT/GOT只是一个外部代码的跳转表。在链接阶段，链接器解析关于本地生成的PLT/GOT表的所有外部32位相对重定位。它可以做到这一点，因为这个表将成为最终ELF文件本身的一部分，所以当文件在运行时被映射到内存中时，它将“接近”主代码。稍后，在运行时<a class="ae lb" href="https://man7.org/linux/man-pages/man8/ld.so.8.html" rel="noopener ugc nofollow" target="_blank">，动态加载器</a>用所有依赖项的运行时地址填充每个加载的ELF文件(可执行文件和共享库)的PLT/GOT表。最终，当程序代码调用某个外部库函数时，CPU通过本地PLT/GOT表“跳转”到最终代码:</p><figure class="ld le lf lg gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/f4d3664fa821d5a3e319ac16b86f82d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*R4Sh77OkLxXfR7Gt.png"/></div></figure><p id="6c1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能会问，为什么我们需要两个ELF部分来实现一个jumptable？因为真实世界的PLT/GOT比上面描述的要复杂一些。事实证明，在运行时解析所有外部引用可能会显著降低程序启动时间，所以符号解析是通过“懒惰方法”实现的:只有当代码实际尝试调用特定函数时，引用才由动态加载器<a class="ae lb" href="https://man7.org/linux/man-pages/man8/ld.so.8.html" rel="noopener ugc nofollow" target="_blank">解析。如果主应用程序代码从不调用库函数，那么这个引用就永远不会被解析。</a></p><h2 id="ac66" class="lm ln iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">实施简化的PLT/GOT</h2><p id="7ed4" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">出于学习和演示的目的，我们不会重新实现一个完整的具有惰性解析的PLT/GOT，而是一个简单的jumptable，它在加载和解析目标文件时解析外部引用。首先，我们需要知道表的大小:对于ELF可执行文件和共享库，链接器将在链接阶段计算外部引用，并创建适当大小的PLT和GOT部分。因为我们处理的是原始目标文件，所以我们必须再次遍历<code class="fe ls lt lu li b">.rela.text</code>段，并对所有的重定位进行计数，这些重定位指向符号表中具有未定义段索引的条目(或代码中的<code class="fe ls lt lu li b">0</code>)。让我们为此添加一个函数，并将外部引用的数量存储在一个全局变量中:</p><p id="9515" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="5f3c" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>/* number of external symbols in the symbol table */<br/>static int num_ext_symbols = 0;<br/>...<br/>static void count_external_symbols(void)<br/>{<br/>    const Elf64_Shdr *rela_text_hdr = lookup_section(".rela.text");<br/>    if (!rela_text_hdr) {<br/>        fputs("Failed to find .rela.text\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/> <br/>    int num_relocations = rela_text_hdr-&gt;sh_size / rela_text_hdr-&gt;sh_entsize;<br/>    const Elf64_Rela *relocations = (Elf64_Rela *)(obj.base + rela_text_hdr-&gt;sh_offset);<br/> <br/>    for (int i = 0; i &lt; num_relocations; i++) {<br/>        int symbol_idx = ELF64_R_SYM(relocations[i].r_info);<br/> <br/>        /* if there is no section associated with a symbol, it is probably<br/>         * an external reference */<br/>        if (symbols[symbol_idx].st_shndx == SHN_UNDEF)<br/>            num_ext_symbols++;<br/>    }<br/>}<br/>...</span></pre><p id="7340" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数非常类似于我们的<code class="fe ls lt lu li b">do_text_relocations</code>函数。只是它没有真正执行重定位，只是计算了外部符号引用的数量。</p><p id="d9ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要决定跳转表的实际字节大小。<code class="fe ls lt lu li b">num_ext_symbols</code>在目标文件中有外部符号引用的数目，但是每个符号要分配多少字节呢？为了解决这个问题，我们需要设计jumptable格式。如上所述，简单来说，我们的跳转表应该是一个无条件CPU跳转指令的集合——每个外部符号一个。然而，不幸的是，现代x64 CPU架构<a class="ae lb" href="https://www.felixcloutier.com/x86/jmp" rel="noopener ugc nofollow" target="_blank">不提供跳转指令</a>，其中地址指针可以是直接操作数。相反，跳转地址需要存储在内存中某个“接近”的位置，即在32位偏移量内，偏移量是实际的操作数。因此，对于每个外部符号，我们需要存储跳转地址(在64位CPU系统上为64位或8字节)和带有偏移操作数的实际跳转指令(x64架构为<a class="ae lb" href="https://www.felixcloutier.com/x86/jmp" rel="noopener ugc nofollow" target="_blank"> 6字节</a>)。我们可以用下面的C结构来表示跳转表中的条目:</p><p id="9a7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="a2b9" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>struct ext_jump {<br/>    /* address to jump to */<br/>    uint8_t *addr;<br/>    /* unconditional x64 JMP instruction */<br/>    /* should always be {0xff, 0x25, 0xf2, 0xff, 0xff, 0xff} */<br/>    /* so it would jump to an address stored at addr above */<br/>    uint8_t instr[6];<br/>};<br/> <br/>struct ext_jump *jumptable;<br/>...</span></pre><p id="26a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还添加了一个全局变量来存储jumptable的基址，这将在以后分配。注意，使用上面的方法，实际的跳转指令对于每个外部符号总是不变的。因为我们用这种结构为每个外部符号分配了一个专用的入口，所以对于32位操作数来说，<code class="fe ls lt lu li b">addr</code>成员将总是在从<code class="fe ls lt lu li b">instr</code> : <code class="fe ls lt lu li b">-14</code>字节或者十六进制的<code class="fe ls lt lu li b">0xfffffff2</code>中的跳转指令的末端的相同偏移处。所以<code class="fe ls lt lu li b">instr</code>将总是<code class="fe ls lt lu li b">{0xff, 0x25, 0xf2, 0xff, 0xff, 0xff}</code> : <code class="fe ls lt lu li b">0xff</code>，<code class="fe ls lt lu li b">0x25</code>是x64跳转指令及其修饰符的编码，<code class="fe ls lt lu li b">0xfffffff2</code>是小端格式的操作数偏移量。</p><p id="822c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经为jumptable定义了条目格式，我们可以在解析目标文件时分配和填充它。首先，我们不要忘记从<code class="fe ls lt lu li b">parse_obj</code>调用我们的新<code class="fe ls lt lu li b">count_external_symbols</code>函数来填充<code class="fe ls lt lu li b">num_ext_symbols</code>(这必须在我们分配jumptable之前完成):</p><p id="6cec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="4446" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>static void parse_obj(void)<br/>{<br/>...<br/> <br/>    count_external_symbols();<br/> <br/>    /* allocate memory for `.text`, `.data` and `.rodata` copies rounding up each section to whole pages */<br/>    text_runtime_base = mmap(NULL, page_align(text_hdr-&gt;sh_size)...<br/>...<br/>}</span></pre><p id="e94d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要为跳转表分配内存，并将指针存储在<code class="fe ls lt lu li b">jumptable</code>全局变量中以备后用。只是提醒一下，为了解决从<code class="fe ls lt lu li b">.text</code>部分到这个表的32位重定位，它必须在内存中“靠近”主代码。所以我们需要在同一个<code class="fe ls lt lu li b">mmap</code>调用中分配它，就像其余的对象部分一样。因为我们在<code class="fe ls lt lu li b">struct ext_jump</code>中定义了表格的条目格式，并且有<code class="fe ls lt lu li b">num_ext_symbols</code>，所以表格的大小将简单地为<code class="fe ls lt lu li b">sizeof(struct ext_jump) * num_ext_symbols</code>:</p><p id="52b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="1056" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>static void parse_obj(void)<br/>{<br/>...<br/> <br/>    count_external_symbols();<br/> <br/>    /* allocate memory for `.text`, `.data` and `.rodata` copies and the jumptable for external symbols, rounding up each section to whole pages */<br/>    text_runtime_base = mmap(NULL, page_align(text_hdr-&gt;sh_size) + \<br/>                                   page_align(data_hdr-&gt;sh_size) + \<br/>                                   page_align(rodata_hdr-&gt;sh_size) + \<br/>                                   page_align(sizeof(struct ext_jump) * num_ext_symbols),<br/>                                   PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);<br/>    if (text_runtime_base == MAP_FAILED) {<br/>        perror("Failed to allocate memory");<br/>        exit(errno);<br/>    }<br/> <br/>...<br/>    rodata_runtime_base = data_runtime_base + page_align(data_hdr-&gt;sh_size);<br/>    /* jumptable will come after .rodata */<br/>    jumptable = (struct ext_jump *)(rodata_runtime_base + page_align(rodata_hdr-&gt;sh_size));<br/> <br/>...<br/>}<br/>...</span></pre><p id="a5fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，因为CPU将实际执行来自jumptable的<code class="fe ls lt lu li b">instr</code>字段的跳转指令，我们需要将该内存标记为只读和可执行(在该函数前面的<code class="fe ls lt lu li b">do_text_relocations</code>完成之后):</p><p id="cb7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="962a" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>static void parse_obj(void)<br/>{<br/>...<br/> <br/>    do_text_relocations();<br/> <br/>...<br/> <br/>    /* make the jumptable readonly and executable */<br/>    if (mprotect(jumptable, page_align(sizeof(struct ext_jump) * num_ext_symbols), PROT_READ | PROT_EXEC)) {<br/>        perror("Failed to make the jumptable executable");<br/>        exit(errno);<br/>    }<br/>}<br/>...</span></pre><p id="80ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个阶段，我们已经分配了跳转表，并且可以使用了——剩下要做的就是正确地填充它。我们将通过改进<code class="fe ls lt lu li b">do_text_relocations</code>实现来处理外部符号的情况。本帖开头的<code class="fe ls lt lu li b">No runtime base address for section</code>错误，其实是由<code class="fe ls lt lu li b">do_text_relocations</code>中的这一行引起的:</p><p id="0f43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="7f2b" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>static void do_text_relocations(void)<br/>{<br/>...<br/>    for (int i = 0; i &lt; num_relocations; i++) {<br/>...<br/>        /* symbol, with respect to which the relocation is performed */<br/>        uint8_t *symbol_address = = section_runtime_base(&amp;sections[symbols[symbol_idx].st_shndx]) + symbols[symbol_idx].st_value;<br/>...<br/>}<br/>...</span></pre><p id="e0db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，我们试图通过查找符号的段运行时地址并加上符号的偏移量来确定重定位的运行时符号地址。但是我们已经在上面建立了外部符号没有相关的部分，所以它们的处理需要是一个特例。让我们更新实现来反映这一点:</p><p id="2c41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="847a" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>static void do_text_relocations(void)<br/>{<br/>...<br/>    for (int i = 0; i &lt; num_relocations; i++) {<br/>...<br/>        /* symbol, with respect to which the relocation is performed */<br/>        uint8_t *symbol_address;<br/>        <br/>        /* if this is an external symbol */<br/>        if (symbols[symbol_idx].st_shndx == SHN_UNDEF) {<br/>            static int curr_jmp_idx = 0;<br/> <br/>            /* get external symbol/function address by name */<br/>            jumptable[curr_jmp_idx].addr = lookup_ext_function(strtab +  symbols[symbol_idx].st_name);<br/> <br/>            /* x64 unconditional JMP with address stored at -14 bytes offset */<br/>            /* will use the address stored in addr above */<br/>            jumptable[curr_jmp_idx].instr[0] = 0xff;<br/>            jumptable[curr_jmp_idx].instr[1] = 0x25;<br/>            jumptable[curr_jmp_idx].instr[2] = 0xf2;<br/>            jumptable[curr_jmp_idx].instr[3] = 0xff;<br/>            jumptable[curr_jmp_idx].instr[4] = 0xff;<br/>            jumptable[curr_jmp_idx].instr[5] = 0xff;<br/> <br/>            /* resolve the relocation with respect to this unconditional JMP */<br/>            symbol_address = (uint8_t *)(&amp;jumptable[curr_jmp_idx].instr);<br/> <br/>            curr_jmp_idx++;<br/>        } else {<br/>            symbol_address = section_runtime_base(&amp;sections[symbols[symbol_idx].st_shndx]) + symbols[symbol_idx].st_value;<br/>        }<br/>...<br/>}<br/>...</span></pre><p id="3df0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个重定位符号没有一个相关的部分，我们认为它是外部的，并调用一个帮助器函数通过它的名字查找符号的运行时地址。我们将该地址存储在下一个可用的跳转表条目中，用我们的固定操作数填充x64跳转指令，并将该指令的地址存储在<code class="fe ls lt lu li b">symbol_address</code>变量中。稍后，<code class="fe ls lt lu li b">do_text_relocations</code>中的现有代码将解决<code class="fe ls lt lu li b">.text</code>相对于<code class="fe ls lt lu li b">symbol_address</code>中地址的重定位，其方式与我们系列第2部分<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-execute-an-object-file-part-2-655eb8b9a811">中的局部符号相同。</a></p><p id="2ddc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在这里唯一缺少的是新引入的<code class="fe ls lt lu li b">lookup_ext_function</code>助手的实现。真实世界的加载器可能有复杂的逻辑，如何在运行时找到并解析内存中的符号。但是出于本文的目的，我们将提供一个简单的实现，它只能解析<code class="fe ls lt lu li b">puts</code>函数:</p><p id="a34d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> loader.c </em>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="87ce" class="lm ln iq li b gy lo lp l lq lr">...<br/> <br/>static void *lookup_ext_function(const char *name)<br/>{<br/>    size_t name_len = strlen(name);<br/> <br/>    if (name_len == strlen("puts") &amp;&amp; !strcmp(name, "puts"))<br/>        return my_puts;<br/> <br/>    fprintf(stderr, "No address for function %s\n", name);<br/>    exit(ENOENT);<br/>}<br/>...</span></pre><p id="26ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，因为我们控制了<code class="fe ls lt lu li b">loader</code>逻辑，所以我们可以随心所欲地实现resolution。在上面的例子中，我们实际上“转移”了目标文件来使用我们自己的“自定义”<code class="fe ls lt lu li b">my_puts</code>函数，而不是C库函数。让我们重新编译<code class="fe ls lt lu li b">loader</code>，看看它是否能工作:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="c893" class="lm ln iq li b gy lo lp l lq lr">$ gcc -o loader loader.c<br/>$ ./loader<br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 52<br/>Executing get_hello...<br/>get_hello() = Hello, world!<br/>Executing get_var...<br/>get_var() = 5<br/>Executing set_var(42)...<br/>Executing get_var again...<br/>get_var() = 42<br/>Executing say_hello...<br/>my_puts executed<br/>Hello, world!</span></pre><p id="e36d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">万岁！我们不仅修复了我们的<code class="fe ls lt lu li b">loader</code>来处理目标文件中的外部引用——我们还学会了如何“挂钩”任何这样的外部函数调用并将代码转移到自定义实现，这在某些情况下可能是有用的，比如恶意软件研究。</p><p id="3db0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和之前的帖子一样，这篇帖子的完整源代码可以在GitHub 上找到。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="4938" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">这是我转贴自</em> <a class="ae lb" href="https://blog.cloudflare.com/how-to-execute-an-object-file-part-3/" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> Cloudflare博客</em> </a>的帖子</p></div></div>    
</body>
</html>