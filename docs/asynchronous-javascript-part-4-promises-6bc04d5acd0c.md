# 异步 Javascript 第 4 部分:承诺

> 原文：<https://levelup.gitconnected.com/asynchronous-javascript-part-4-promises-6bc04d5acd0c>

*本文是异步 Javascript 系列文章的第 4 部分。我强烈推荐你阅读第一部分*[](https://medium.com/@kabir4691/asynchronous-javascript-part-1-b87f263a353a)**，* [*第二部分*](https://medium.com/@kabir4691/asynchronous-javascript-part-2-26ac20fc5ad7) *和* [*第三部分*](/asynchronous-javascript-part-3-85390632dd1a) *，以便从这篇文章中获得最大收益。**

*![](img/bbbab6fc99628470add15052bb51d73c.png)*

*在本文中，我们将看到 ES6 中引入的一个有趣的 Javascript 特性，它可以高效地运行异步代码。在 ES6 之前，为了运行异步代码(例如网络请求)，我们使用回调函数。但是这种方法有很多缺点(包括[回调地狱](http://callbackhell.com/))，导致代码可读性、错误处理和调试方面的问题。为了克服这些问题，引入了一个名为 **Promise** 的新 Javascript 对象。*

# *承诺*

*承诺是一种特殊类型的 Javascript 对象，充当异步操作最终完成或失败的占位符。它允许您将“处理程序”附加到它，当成功值或失败原因到达后一个阶段时，处理它们。这让我们可以像调用同步函数一样调用异步函数，并将它们存储在一个代理对象中，该代理对象“承诺”在稍后阶段返回输出。让我们通过一个例子来更好地理解这一点。*

*上面给出了承诺的基本语法。一个承诺是通过一个传递给它的函数创建的，这个函数叫做**执行者**函数。executor 函数包含您希望运行的异步代码。该函数包含两个参数，`resolve`和`reject`。这些是 Javascript 提供的默认回调函数。一旦创建了承诺，就会运行执行人功能。每当这个函数的代码完成运行时，我们需要调用任一个回调函数:*

*   *resolve(value):调用该函数表示成功条件，其中' *value* '为成功完成 executor 函数返回的值*
*   *reject(error):调用这个函数表示一个失败或者错误的情况，其中' *error* '值是一个`Error`对象，表示错误的细节。*错误*'不一定必须是`Error`对象，但强烈建议使用。*

*构造函数返回的 promise 对象也有一些内部属性:*

*   *状态:最初设置为“待定”。如果调用了“解决”,则更改为“已履行”,如果调用了“拒绝”,则更改为“已拒绝”。*
*   *结果:初始设置为`undefined`。如果调用 resolve(value ),则更改为'*值*;如果调用 reject(error ),则更改为'*错误'*。*

*让我们通过一个简单的例子来看看上述特性是如何工作的。*

*上面的代码创建了一个承诺，生成一个从 1 到 10 的随机数，并检查它是否是偶数。我们使用了`setTimeout`来实现 1 秒的延迟。创建 promise 对象时，其内部属性被设置为默认值。*

```
*state: "pending"
result: undefined*
```

*让我们假设第 2 行生成的 randomNumber 是一个像 4 这样的偶数。在这种情况下，第 5 行的代码被执行，并调用`resolve`回调函数，其参数值为 4。这会将承诺对象移动到“已履行”状态。这类似于说 executor 函数的任务返回了一个“成功”的结果。promise 对象的属性现在是*

```
*state: "fulfilled"
result: 4*
```

*如果生成的 randomNumber 是一个奇数，比如 7，那么第 7 行的代码将被执行，并且使用`Error`对象作为参数调用`reject`回调函数。这会将承诺对象移动到“拒绝”状态。promise 对象的属性现在是*

```
*state: "rejected"
result: Error("Not an even number");*
```

*注意，在一个承诺中，executor 函数只能调用`resolve`或`reject`一次。第一次调用后对`resolve`或`reject`的任何后续调用都将被忽略。这是因为承诺只有一个结果，要么成功，要么失败。此外，`resolve`和`reject`都只接受一个(或零个)参数。忽略其他参数。*

*需要注意的一点是，当创建 promise 对象时，它不会立即存储异步操作的输出。输出(可能是由`resolve`函数传递的成功值，也可能是由`reject`函数传递的错误值)只能在以后获得。这个输出存储在“result”中，result 是 Promise 的内部属性，不能直接访问。为了获得结果，我们给承诺附加了特殊的处理函数，我们将在下面讨论。*

# *然后，接住，最后*

*承诺有三个重要的功能，或者可以附加到承诺上的“处理程序”,允许我们接收或“消费”它们的输出。第一个是`then`处理程序。`then`的基本语法如下。*

*`then`处理程序最多接受两个回调函数作为参数。如果在 executor 函数中调用了`resolve`，则执行第一个回调。如果在 executor 函数中调用了`reject`，就会执行第二次回调。比如下面的 promise，在 executor 函数中调用了`resolve`函数。*

*因此，只执行了第一个回调，忽略了第二个回调。*

*在调用`reject`函数的情况下，*

*第一个回调被忽略，第二个回调被执行。*

*我们也可以有单独的处理程序来使用`resolve`和`reject`的结果。这就是`catch`处理程序发挥作用的地方。它只接受一个回调函数作为参数，并在承诺被拒绝时执行。*

*第三个可用的处理器是`finally`。这类似于 final 在普通的 try-catch 场景中的工作方式。`finally`处理程序不接受任何参数，如果它附加到一个承诺，则总是被执行，不管该承诺是被解决还是被拒绝。*

*我们在本文前面已经提到了引入 promises 的原因之一是为了克服回调地狱。实现这一点的承诺的特征是链接的能力。承诺的处理者，即`then`、`catch`和`finally`，都返回一个承诺。因此，我们可以使用这些处理程序来“链接”多个承诺。让我们看一个简单的例子。*

*在上面的例子中，我们创建了一个简单的承诺，它的值为 10。接下来，我们用第 5 行的第一个`then`函数来使用这个结果。该函数将值“10”打印到控制台中，然后返回值 10 * 2 = 20。因此，这个`then`函数返回的承诺用值 20 来解析。因此，在第 9 行，当调用`then`函数时，它的结果是 20。结果 20 被打印到控制台上，然后返回 20 + 5 = 25。同样，由当前的`then`函数返回的承诺因此被解析为值 25。通过重复这个过程，我们可以将任意数量的承诺链接到一个现有的承诺。有关链接的更多信息，您可以在 MDN 上查找这个[文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)。*

*现在我们已经看了承诺，你可能想知道它们在执行顺序中的位置。承诺的处理程序(`then`、`catch`和`finally`)是否因为异步而进入回调队列？答案是否定的。*

*它们实际上被添加到一个叫做**微任务**队列的东西中。这个队列是在 ES6 中专门为处理承诺(和一些其他类型的异步函数，如`await`)而添加的。因此，每当一个承诺准备就绪时(即它的 executor 函数已经完成运行)，该承诺的所有`then`、`catch`和`finally`处理程序都被添加到微任务队列中。*

*微任务队列中的函数也被赋予比回调队列更高的优先级。这意味着每当触发事件循环时，一旦程序到达最后一行，事件循环首先检查微任务队列是否为空。如果它不为空，那么在继续检查回调队列之前，它首先将微任务队列中的所有函数添加到调用堆栈中。*

*有关承诺的更多信息，您可以在 MDN 上查找此[文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)。*

*我的异步 Javascript 系列到此结束。如有任何疑问或建议，请随时回复！*