<html>
<head>
<title>4 JavaScript libraries to learn in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年要学习的4个JavaScript库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-javascript-libraries-to-learn-in-2021-dedd6c0650ea?source=collection_archive---------2-----------------------#2021-01-09">https://levelup.gitconnected.com/4-javascript-libraries-to-learn-in-2021-dedd6c0650ea?source=collection_archive---------2-----------------------#2021-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9c2387296acfc02e15cb11d11e77d80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A_KRDIOaNEE60ReB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@wezlar11?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迪安·普</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="1885" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我所有的文章现在都是免费的<a class="ae kf" href="https://brandonburrus.com/blog" rel="noopener ugc nofollow" target="_blank">这里</a>，不需要订阅Medium！</p><p id="cc8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管喜欢还是讨厌，根据<a class="ae kf" href="https://insights.stackoverflow.com/survey/2020#technology-programming-scripting-and-markup-languages-professional-developers" rel="noopener ugc nofollow" target="_blank"> 2020堆栈溢出调查</a>，JavaScript是最受欢迎的编程语言。多年来，这门语言围绕它开发了一个庞大的库、框架和工具生态系统。当你刚刚起步时，要成为一名熟练的开发人员，你需要学习的“东西”数量之多，一开始会让你感到不知所措。</p><p id="230c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名JavaScript开发人员，你可以学习一些关键的库，它们将极大地提高你的价值。在您参与的任何给定项目中，您很可能会找到至少一个(如果不是几个)这样的库，这进一步增加了学习它们的价值。</p><p id="3108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些库是按照学习难度排序的，所以建议一个一个地学习，直到你完全掌握为止。这篇文章的目标是解释这些库做什么，以及给你一个基本的介绍。我们将从最常见的Lodash开始。</p><h1 id="3191" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">洛达什</h1><p id="e393" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript开发人员的虚拟工具带，了解Lodash提供的许多功能中的一些就可以大大提高开发人员的工作效率。</p><p id="24b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lodash本身是一个“实用程序”库，这意味着它的唯一目标就是做到这一点:为您提供一系列小的实用程序，帮助您完成日常任务，例如对数组进行分区、记忆函数或取消字符串中HTML实体的转义。</p><p id="8ca7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您不需要记住所有Lodash函数的完整列表。一种更简单的方法是浏览他们记录的函数列表，并在过程中记录有用或有趣的函数。</p><p id="4670" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着时间的推移，你会一次又一次地遇到同样的问题，很容易就能找到Lodash来帮你解决！</p><p id="5da0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">库本身最初是库下划线的一个分支，两者有很多共同之处。很有可能你工作的下一家公司会在每个项目中使用其中一个。</p><p id="112e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我发现自己一次又一次使用的一些有用/有趣的lodash函数:</p><ul class=""><li id="ee67" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">partition()</code> —根据O(n)时间内的谓词函数将一个数组分成两个独立的数组。</li><li id="0676" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">compact()</code> —从给定数组中删除任何类型的falsey值。</li><li id="eb98" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">groupBy()</code> —根据给定的分组函数将集合分组到类似叶图的对象结构中。</li><li id="e3d9" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">shuffle()</code> —将数组的索引打乱成随机顺序。</li><li id="8126" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">sortBy()</code> —根据给定的谓词输入对数组进行排序(这比内置的数组<code class="fe mq mr ms mt b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank">.sort()</a></code>方法更有用，因为它返回一个新数组，并且可以接受多个更简单的输入)。</li><li id="786f" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">curry()</code>或<code class="fe mq mr ms mt b">curryRight()</code> —执行功能，允许部分应用功能参数。</li><li id="3ffb" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">debounce()</code> —根据定义的等待时间对给定功能执行去抖。</li><li id="7e68" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">memoize()</code> —记忆给定函数，在处理数组或对象时，也可以采用记忆解析器进行更复杂的记忆。</li><li id="0d84" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">cloneDeep()</code> —深度克隆一个对象。</li><li id="b16b" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">isNil()</code> —如果给定输入为<code class="fe mq mr ms mt b">null</code>或<code class="fe mq mr ms mt b">undefined</code>，则返回true。</li><li id="ad88" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">round()</code> —将数字舍入到给定的精度。</li><li id="b139" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">chain()</code> —用一个特殊的Lodash包装器对象包装一个值，允许您将任何Lodash函数链接成一个转换(您可以通过调用<code class="fe mq mr ms mt b">.value()</code>结束该链接来获得最终的转换结果)。</li><li id="bd74" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">unescape()</code> —将HTML实体转换为这些实体所代表的实际unicode字符。</li><li id="3b04" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">get()</code> —基于给定路径安全地对对象进行深度遍历(如果您正在使用TypeScript或ES2020+，请使用<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a>而不是使用这个)。</li></ul><p id="75fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里开始使用Lodash:<a class="ae kf" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">Lodash文档</a>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="1701" class="le lf it bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">不可变的. js</h1><p id="b468" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">得益于近年来React的广泛采用，JavaScript已经出现了使用更函数式编程风格的开发的趋势。函数式编程的一部分是利用<a class="ae kf" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">不可变的</a>数据结构。然而，数组的许多内置函数是自变异的，这意味着它们就地改变数组(比如数组<code class="fe mq mr ms mt b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank">.sort()</a></code>或<code class="fe mq mr ms mt b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="noopener ugc nofollow" target="_blank">.splice()</a></code>)。</p><p id="badc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不可变. js试图通过提供强大的不可变数据结构(如列表和映射)来解决这个问题。它使得在它提供的不可变对象和原生JS对象和数组之间的转换变得很好很容易。它还为操纵这些结构提供了比原生JavaScript为对象和数组提供的更多的转换和实用API。</p><p id="9597" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自Immutable.js的核心结构的快速概述:</p><h2 id="4ba5" class="nl lf it bd lg nm nn dn lk no np dp lo kr nq nr ls kv ns nt lw kz nu nv ma nw bi translated">目录</h2><p id="de7a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">列表本质上是数组的不可变版本:有序(索引)的项目集合。</p><p id="186f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像这样创建一个空列表:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="c14f" class="nl lf it mt b gy of og l oh oi">const emptyList = List();</span></pre><p id="b23f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以从现有集合(如数组)创建一个列表:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="f7a8" class="nl lf it mt b gy of og l oh oi">const myList = List([1, 2, 3]);</span></pre><p id="fa62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有像<code class="fe mq mr ms mt b">filter()</code>和<code class="fe mq mr ms mt b">map()</code>这样的转换方法都存在于列表中，就像我们对数组的期望一样:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="de95" class="nl lf it mt b gy of og l oh oi">const onlyEvents = List([1, 2, 3, 4, 5])<br/>  .filter(n =&gt; n % 2 === 0);</span><span id="9f5a" class="nl lf it mt b gy oj og l oh oi">const doubledNums = List([1, 2, 3, 4, 5])<br/>  .map(n =&gt; n * 2);</span></pre><p id="a1fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是列表还有其他有用的API，比如<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/List/interleave" rel="noopener ugc nofollow" target="_blank">交错</a>或<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/List/isSubset" rel="noopener ugc nofollow" target="_blank">子集检查</a>，它们使得使用列表变得非常容易。</p><p id="66f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">列表的完整文档可以在<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/List" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="576b" class="nl lf it bd lg nm nn dn lk no np dp lo kr nq nr ls kv ns nt lw kz nu nv ma nw bi translated">地图和订购地图</h2><p id="a15e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">映射类似于对象，因为它是一个无序的键-值(或KV)对的集合(OrderedMap是相同的，只是键具有特定的顺序并且是可排序的)。</p><p id="98d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像创建空列表一样创建空映射:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="5cff" class="nl lf it mt b gy of og l oh oi">const emptyMap = Map();</span></pre><p id="3adc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，我们可以从现有的JS对象创建一个地图:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="1b0d" class="nl lf it mt b gy of og l oh oi">const myMap = Map({ hello: 'world' });</span></pre><p id="89fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该结构提供诸如检索、删除和合并之类的基本操作:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="c2c0" class="nl lf it mt b gy of og l oh oi">const majorCities = Map({<br/>  germany: 'Berlin',<br/>  kenya: 'Nairobi',<br/>  russia: 'Moscow',<br/>  colorado: 'Denver',<br/>  japan: 'Tokyo',<br/>});</span><span id="c17d" class="nl lf it mt b gy oj og l oh oi">majorCities.get('germany');<br/>majorCities.delete('berlin');<br/>majorCities.merge({<br/>  brazil: 'Rio de Janeiro',<br/>  finlind: 'Helsinki',<br/>  norway: 'Oslo',<br/>});</span></pre><p id="c183" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里要记住的关键是上面的结构是<em class="ok">不可变的</em>，所以当我们调用像<code class="fe mq mr ms mt b">.delete()</code>或。<code class="fe mq mr ms mt b">merge()</code>，这些方法返回一个<em class="ok">新的地图对象</em>，而不是修改原来的地图。</p><p id="3161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像列表一样，地图有各种有用的方法来执行诸如<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/Map/flip" rel="noopener ugc nofollow" target="_blank">翻转</a>、<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/Map/takeWhile" rel="noopener ugc nofollow" target="_blank">取走</a>，甚至<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/Map/reduce" rel="noopener ugc nofollow" target="_blank">减少</a>之类的事情。</p><p id="8342" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整的地图文档可以在<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/Map" rel="noopener ugc nofollow" target="_blank">这里</a>找到，订购地图<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/OrderedMap" rel="noopener ugc nofollow" target="_blank">可以在</a>这里找到。</p><h2 id="60cc" class="nl lf it bd lg nm nn dn lk no np dp lo kr nq nr ls kv ns nt lw kz nu nv ma nw bi translated">集合和有序集合</h2><p id="6411" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">集合是唯一值的集合(有序版本就是:唯一值的有序集合)。</p><p id="03a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像创建列表或地图一样创建集合:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="c3dc" class="nl lf it mt b gy of og l oh oi">const emptySet = Set();<br/>const nums = Set([1, 1, 2, 2, 3, 3]);</span></pre><p id="01ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们记录<code class="fe mq mr ms mt b">nums.size()</code>，我们会看到<code class="fe mq mr ms mt b">3</code>。这是因为集合中唯一的唯一值是<code class="fe mq mr ms mt b">1</code>、<code class="fe mq mr ms mt b">2</code>和<code class="fe mq mr ms mt b">3</code>。</p><p id="3aa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您需要处理独特的项目时，集合非常有用。您可能看到的一个技巧是从现有的<code class="fe mq mr ms mt b">List</code>创建一个<code class="fe mq mr ms mt b">OrderedSet</code>来删除任何重复项目的列表。</p><p id="274f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">成套设备的完整文件可在<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/Set" rel="noopener ugc nofollow" target="_blank">这里</a>找到，订购的成套设备的完整文件可在<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/OrderedSet" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="b08f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不仅仅是列表、映射和集合，Immutable.js还有其他数据结构，比如<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/Record" rel="noopener ugc nofollow" target="_blank">记录</a>、<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/Stack" rel="noopener ugc nofollow" target="_blank">堆栈</a>和<a class="ae kf" href="https://immutable-js.github.io/immutable-js/docs/#/Seq" rel="noopener ugc nofollow" target="_blank"> Seqs </a>等等。</p><p id="129e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里开始使用immutable . js:<a class="ae kf" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank">immutable . js文档</a>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="1471" class="le lf it bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">RxJS</h1><p id="8642" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">RxJS是关于数据流和在这些数据流上执行可组合转换的。考虑这个库的一个更简单的方法是:</p><blockquote class="ol om on"><p id="4c22" class="kg kh ok ki b kj kk kl km kn ko kp kq oo ks kt ku op kw kx ky oq la lb lc ld im bi translated">"把RxJS想象成事件的Lodash . "— <a class="ae kf" href="https://rxjs.dev/guide/overview" rel="noopener ugc nofollow" target="_blank"> RxJS文档</a></p></blockquote><p id="f24d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS使得处理复杂的时间变化(异步)变得更加容易。</p><h2 id="9c5b" class="nl lf it bd lg nm nn dn lk no np dp lo kr nq nr ls kv ns nt lw kz nu nv ma nw bi translated">看得见的</h2><p id="fdf9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">核心实体是<a class="ae kf" href="https://rxjs.dev/guide/observable" rel="noopener ugc nofollow" target="_blank">可观测的</a>。你可以把一个可观测值想象成一个值的数组，只是这些值可以用时间来分隔。这就是我们得到“流”的概念的地方，就像一段时间内的数据或值的流。</p><p id="528c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可观察性使得与这些流一起工作(并对其做出反应)变得美好而简洁。以RxJS的<code class="fe mq mr ms mt b">from()</code>函数为例，它接受一个数组作为参数，并返回该数组作为可观察值。一旦我们有了一个观察对象，我们通常会想要订阅它。</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="8fa9" class="nl lf it mt b gy of og l oh oi">const nums$ = from([1, 2, 3]);</span><span id="8487" class="nl lf it mt b gy oj og l oh oi">nums$.subscribe(value =&gt; {<br/>  console.log(value);<br/>});</span></pre><p id="5690" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">nums$</code>后的美元符号是JS开发人员在使用RxJS时喜欢使用的约定，只是用来表示变量包含对可观察对象的引用。</p><p id="3e9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在代码示例中，我们从一组数字中创建了可观察的<code class="fe mq mr ms mt b">nums$</code>。一旦我们有了那个可观察的，我们就可以订阅它来记录来自那个可观察的流的所有值。</p><p id="f87a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个更有用的例子:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="0264" class="nl lf it mt b gy of og l oh oi">const clicks$ = fromEvent(<br/>  document.querySelector('#myBtn'),<br/>  'click'<br/>);</span><span id="f98d" class="nl lf it mt b gy oj og l oh oi">let clickCount = 0;</span><span id="a68b" class="nl lf it mt b gy oj og l oh oi">clicks$.subscribe(clickEvent =&gt; {<br/>  clickCount++;<br/>});</span></pre><p id="8ff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们使用RxJS的<code class="fe mq mr ms mt b">fromEvent()</code>函数从DOM节点事件监听器创建一个可观察对象。这给了我们一个事件流，我们可以用它来增加我们的点击次数。</p><p id="fef7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们使用一种非常命令式的程序来处理点击量。RxJS真正的闪光点在于它能够将复杂的变换应用到可观察的事物上。</p><h2 id="5c37" class="nl lf it bd lg nm nn dn lk no np dp lo kr nq nr ls kv ns nt lw kz nu nv ma nw bi translated">经营者</h2><p id="84aa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">RxJS方面的运算符是将变换应用于可观察对象的特殊函数。以我们的点击计数器为例:我们将使用<code class="fe mq mr ms mt b">scan()</code>操作符将每个点击事件转换成一个递增的数字，而不是强制性地跟踪变量中的点击次数。</p><p id="b22a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们将从可观察到的点击事件转变为可观察到的(不断增加的)数量。</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="ef03" class="nl lf it mt b gy of og l oh oi">const clicks$ = fromEvent(<br/>  document.querySelector('#myBtn'),<br/>  'click'<br/>);</span><span id="9ae3" class="nl lf it mt b gy oj og l oh oi">clicks$<br/>  .pipe(<br/>    scan(accumulator =&gt; accumulator + 1, 0)<br/>  )<br/>  .subscribe(clickCount =&gt; {<br/>    console.log(clickCount);<br/>  });</span></pre><p id="4369" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mq mr ms mt b">.pipe()</code>方法将运算符应用于可观察值。<code class="fe mq mr ms mt b">scan()</code>操作符的工作方式类似于<code class="fe mq mr ms mt b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">.reduce()</a></code>的工作方式:它接受一个函数和一个初始累加器值作为参数。该函数获取累加器的当前值和可观测值作为参数，需要返回下一个新的累加器值。</p><p id="571c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，扫描函数参数不关心事件，只关心累加器(这就是为什么我们忽略第二个参数)。初始累加器值为0，每次单击按钮时，操作符都会将该事件转换为一个递增的数字。</p><h2 id="5317" class="nl lf it bd lg nm nn dn lk no np dp lo kr nq nr ls kv ns nt lw kz nu nv ma nw bi translated">捐款</h2><p id="4a34" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">observables的一个重要方面是调用<code class="fe mq mr ms mt b">.subscribe()</code>方法时返回的订阅对象。</p><p id="db9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可观测量可以是有限的，也可以是无限的。当一个可观察对象是有限的(比如我们的数组示例)，一旦可观察流完成，订阅将自动关闭。然而，对于无限的可观察对象(比如我们的点击事件可观察对象),我们需要确保在某个时候显式地取消订阅可观察对象，否则我们会在应用程序中遇到内存泄漏。</p><p id="242b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以通过简单地在返回的订阅对象上调用<code class="fe mq mr ms mt b">.unsubscribe()</code>方法来完成。</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="00a2" class="nl lf it mt b gy of og l oh oi">const clicks$ = fromEvent(<br/>  document.querySelector('#myBtn'),<br/>  'click'<br/>);</span><span id="3dc2" class="nl lf it mt b gy oj og l oh oi">const clickSubscription = clicks$.subscribe(e =&gt; {<br/>  console.log(e);<br/>});</span><span id="4f91" class="nl lf it mt b gy oj og l oh oi">clickSubscription.unsubscribe();</span></pre><p id="7ad5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是RxJS的冰山一角。该库有超过<em class="ok">一百个</em> <a class="ae kf" href="https://rxjs.dev/guide/operators" rel="noopener ugc nofollow" target="_blank">操作符</a>随时可供您使用，您也可以创建自己的操作符！</p><p id="acce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你仍然不相信RxJS是一个非常有用的库，那么André Staltz撰写的文章<a class="ae kf" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" rel="noopener ugc nofollow" target="_blank"><em class="ok"/></a><a class="ae kf" href="https://staltz.com/" rel="noopener ugc nofollow" target="_blank">对RxJS的所有原因和方法进行了更详细的介绍。</a></p><p id="9afc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里开始RxJS:<a class="ae kf" href="https://rxjs.dev/guide/overview" rel="noopener ugc nofollow" target="_blank">RxJS文档</a>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="731f" class="le lf it bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">拉姆达</h1><p id="1570" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Ramda基本上做了与Lodash相同的事情(提供了大量真正有用的实用函数)，但是有一个巨大的不同:Ramda实用程序都是用于<a class="ae kf" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>风格的。</p><p id="5dac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想从Haskell、Elixir或OCaml等语言学习JavaScript，Ramda将是你最好的朋友。</p><p id="3dfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数式编程都是关于函数的。<em class="ok">咄！</em>函数式编程的核心基础之一是使用<em class="ok">组合</em>。</p><p id="ffde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来看下面这个纯函数:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="f530" class="nl lf it mt b gy of og l oh oi">const double = n =&gt; n * 2;</span></pre><p id="6bb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在假设我们想得到一个数，并把它翻两番。我们当然可以把这个数乘以4，<em class="ok">或者</em>我们可以对这个数<em class="ok">调用两次这个<code class="fe mq mr ms mt b">double</code>函数。</em></p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="df90" class="nl lf it mt b gy of og l oh oi">double(double(42));</span></pre><p id="c819" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将这四倍的功能抽象成它自己的功能，如下所示:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="2bad" class="nl lf it mt b gy of og l oh oi">const quadruple = n =&gt; double(double(n));</span></pre><p id="a4a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是组合的意义所在:获取现有的功能，然后<em class="ok">将它们组合在一起形成更大的功能。在示例中，<code class="fe mq mr ms mt b">quadruple</code>函数由<code class="fe mq mr ms mt b">double</code>函数组成。</em></p><p id="a0ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Ramda可以通过使用<code class="fe mq mr ms mt b">compose()</code>函数使其更具可读性:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="3a03" class="nl lf it mt b gy of og l oh oi">const quadruple = compose(double, double);</span></pre><p id="78b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而由此产生的<code class="fe mq mr ms mt b">quadruple</code>功能也是一样的。</p><p id="2423" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有的Ramda函数都被设计成使用composition，就好像你在使用一种真正的纯函数式语言一样。</p><p id="310b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Ramda的每个函数都有两条规则:</p><ol class=""><li id="85ad" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld or mn mo mp bi translated">每个功能都是<a class="ae kf" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank"> <em class="ok">化</em> </a>。</li><li id="b3c1" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld or mn mo mp bi translated">每个函数都将函数操作的数据定义为最后一个参数。</li></ol><p id="6664" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，Ramda有一个<code class="fe mq mr ms mt b">filter()</code>函数，其工作原理与本机<code class="fe mq mr ms mt b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">.filter()</a></code>方法基本相同:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="0f47" class="nl lf it mt b gy of og l oh oi">const nums = [1, 2, 3];</span><span id="0a62" class="nl lf it mt b gy oj og l oh oi">const onlyEven = filter(n =&gt; n % 2 === 0, nums);</span></pre><p id="75c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">起初这看起来很奇怪，因为我们通常认为<code class="fe mq mr ms mt b">nums</code>数组应该是<code class="fe mq mr ms mt b">filter()</code>的第一个参数，而不是过滤函数。</p><p id="2623" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是请记住，来自ramda的<code class="fe mq mr ms mt b">filter()</code>是咖喱，所以我们实际上可以这样做:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="99a5" class="nl lf it mt b gy of og l oh oi">const nums = [1, 2, 3];</span><span id="6c6d" class="nl lf it mt b gy oj og l oh oi">const evenFilter = filter(n =&gt; n % 2 === 0);</span><span id="f421" class="nl lf it mt b gy oj og l oh oi">const onlyEven = eventFilter(nums);</span></pre><p id="4220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将数据自变量与组合函数结合起来，您可以定义如下函数转换函数:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="a8ff" class="nl lf it mt b gy of og l oh oi">const transform = compose(<br/>  add(2),<br/>  multiply(2),<br/>  subtract(5)<br/>);</span><span id="3133" class="nl lf it mt b gy oj og l oh oi">transform(10); // 12</span></pre><p id="0d54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子是人为的，但是将这个技术应用到更复杂的东西上，我们可以看到像Ramda这样的东西带来的真正价值。</p><p id="555a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我有以下数据结构:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="a429" class="nl lf it mt b gy of og l oh oi">const records = [<br/>  {<br/>    title: 'Section B',<br/>    entries: [5, 1, 2, 10, 7],<br/>  },<br/>  {<br/>    title: 'Section A',<br/>    entries: [4, 1, 2, 7]<br/>  },<br/>];</span></pre><p id="c230" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的目标是做以下事情:</p><ul class=""><li id="4ddf" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">按标题对数组中的每个记录对象进行升序排序</li><li id="756d" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated">按数字降序对每个记录对象中的嵌套条目进行排序</li></ul><p id="e843" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Ramda实用程序，我们可以创建自己的映射实用程序来满足这些需求，看起来可能是这样的:</p><pre class="nx ny nz oa gt ob mt oc od aw oe bi"><span id="3953" class="nl lf it mt b gy of og l oh oi">const recordMapper = compose(<br/>  map(over(lensProp("entries"), sort(descend(identity)))),<br/>  sort(ascend(prop("title")))<br/>);</span></pre><p id="d3cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们并不是在这里玩代码高尔夫，但是想象一下，在命令式风格中，同一个转换函数需要多少行代码。相反，我们基本上将所有的逻辑压缩成了三行。</p><p id="b7eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子相当严格，因为它只适用于我们给定的数据结构。通常，您会先将这个实用程序分成几个较小的函数。这就是通过组合进行函数式编程的最终目标:用更小的函数构建更大的函数！</p><p id="8f4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你真的想通过Ramda更深入地使用函数式编程风格的方法，Randy Coulman 撰写的精彩文章系列<a class="ae kf" href="https://randycoulman.com/blog/categories/thinking-in-ramda/" rel="noopener ugc nofollow" target="_blank"> <em class="ok">在Ramda </em> </a>中思考是一个很好的起点！</p><p id="a3c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里值得注意的是，Ramda是你在项目中可能看到的最不常见的库。然而，如果您仍然想使用函数式方法，Lodash有一个子模块<code class="fe mq mr ms mt b"><a class="ae kf" href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener ugc nofollow" target="_blank">lodash/fp</a></code>，它是以FP方式构建的所有Lodash函数。</p><p id="b255" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里开始使用Ramda:<a class="ae kf" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank">Ramda document ation</a>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="4831" class="le lf it bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">结论</h1><p id="71a3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">学习这些库不仅会让你成为更好的JavaScript开发人员，而且会让你成为更好的开发人员。这是因为所讨论的4个库中的3个不仅为您提供了非常有用的功能，还因为它们挑战了传统的命令式或面向对象的编程风格，大多数人在学习JS这样的编程语言时首先学习的就是这种风格。</p><p id="6125" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">成为一名优秀程序员的一个基本方面是确保为工作选择正确的工具。这正是这些库的作用:一套供您使用的工具，只是您解决任何给定问题的众多方法之一。最终，这就是我们作为开发人员要做的事情:解决问题。</p></div></div>    
</body>
</html>