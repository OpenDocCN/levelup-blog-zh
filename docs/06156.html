<html>
<head>
<title>From Go to Haskell + Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从去哈斯克尔+苗条</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-go-to-haskell-svelte-1ad5ff4a0520?source=collection_archive---------12-----------------------#2020-10-30">https://levelup.gitconnected.com/from-go-to-haskell-svelte-1ad5ff4a0520?source=collection_archive---------12-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/53210d14bac850c3642a8a801cdd0643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMgi_rZiMuoUpi-YqagB-w.png"/></div></div></figure><p id="82a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从ReactJS、Vue和Angular到Golang、ExpressJS和ASP.NET，在构建web应用程序时，前端和后端框架有无数种组合可供使用。Svelte和Haskell是前端和后端技术的两个最独特的选择。与无处不在的ReactJS及其许多竞争对手不同，Svelte不使用虚拟DOM (VDOM)。Haskell是纯函数式的，与主要是命令式的Golang、C#和Java相反。</p><p id="7fb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我考虑重写我的个人网站已经有一段时间了。虽然Go是一种很棒的服务器端语言，但它非常无聊。这对某些人来说是一个优势，但对我来说从来没有吸引力，尤其是对业余爱好项目来说。我决定既然我正在重写，我也可以从Go的标准服务器端模板转移到Svelte。</p><h1 id="9807" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么是哈斯克尔？</h1><p id="efa6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Haskell是一种纯粹的函数式语言。因此，它有:</p><ul class=""><li id="8438" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">一个有表现力的、安全的类型系统</li><li id="c009" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">大类型推理</li><li id="55b3" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">潜在的高并行性</li><li id="5047" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">简洁的语法</li><li id="50ac" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">简单的重构和测试</li></ul><p id="295d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，Haskell没有被广泛使用是有原因的。大多数程序员首先学习命令式语言，这使得Haskell相当不透明。甚至对于有经验的Haskell开发人员来说，编写难以理解的Haskell程序也是可能的。最后，Haskell对于许多现实世界的程序来说是相当不符合人机工程学的，因为它(正确地)不鼓励全局状态。我决定在我的服务器上使用Haskell主要是为了好玩，但也因为我站点上的每个端点本质上都是一个纯函数。</p><h1 id="63b3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么苗条？</h1><p id="92db" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">与其他框架相比，Svelte最大的优势是它避开了VDOM，而是简单地编译Javascript来更新DOM。这使得它比VDOM框架快得多。其他优势包括:</p><ul class=""><li id="eb64" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">苗条容易学；组件是在HTML/CSS/JS的简单超集中编写的。</li><li id="34d9" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">伟大的教程和简单的设置</li><li id="6d51" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">较小的束尺寸</li><li id="203b" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">简单而富有表现力</li></ul></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="cf4b" class="kw kx iq bd ky kz mu lb lc ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt bi translated">选择后端Haskell框架</h1><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8e7f86281683559d67ad8a2eb166add5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*QuiPcIMef_lLL1El.png"/></div></figure><p id="fe01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在决定了后端语言之后，我仍然必须选择一个web框架。在做了一些研究和尝试了一些例子之后，我决定使用Scotty。Scotty是一个简单的框架，灵感来自Ruby的Sinatra。每个端点只需要一个匹配的模式和一个要发送的文本对象。</p><h2 id="b57d" class="ne kx iq bd ky nf ng dn lc nh ni dp lg kj nj nk lk kn nl nm lo kr nn no ls np bi translated">你好，斯科特</h2><p id="9b2c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">下面是来自<a class="ae nq" href="https://github.com/scotty-web/scotty" rel="noopener ugc nofollow" target="_blank">GitHub页面</a>的hello world Scotty示例:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="87af" class="ne kx iq ns b gy nw nx l ny nz">{-# LANGUAGE OverloadedStrings #-}<br/>import Web.Scotty<br/><br/>import Data.Monoid (mconcat)<br/><br/>main = scotty 3000 $<br/>    get "/:word" $ do<br/>        beam &lt;- param "word"<br/>        html $ mconcat ["&lt;h1&gt;Scotty, ", beam, " me up!&lt;/h1&gt;"]</span></pre><p id="0d18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用<a class="ae nq" href="https://github.com/commercialhaskell/stack" rel="noopener ugc nofollow" target="_blank">栈、</a>设置我的Haskell项目，这使得事情变得非常简单。只需运行:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="c61f" class="ne kx iq ns b gy nw nx l ny nz">stack new {name}<br/>cd {name}<br/>stack setup<br/>stack build</span></pre><p id="cd62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成的文件树应该是:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="bedc" class="ne kx iq ns b gy nw nx l ny nz">.<br/>├── app<br/>├── client<br/>│   ├── node_modules<br/>│   ├── public<br/>│   ├── scripts<br/>│   └── src<br/>├── keys<br/>├── src<br/>└── test</span></pre><p id="8053" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要添加Scotty作为依赖项，只需将<code class="fe oa ob oc ns b">scotty</code>添加到<code class="fe oa ob oc ns b">package.yml</code>中的<code class="fe oa ob oc ns b">dependencies</code>列表中。</p><p id="4727" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想使用HTTPS和全局状态，你必须做一些调整，这对大多数服务器都是必要的。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="c78d" class="ne kx iq ns b gy nw nx l ny nz">main :: IO ()<br/>main = do<br/>    let tlsConfig = tlsSettings "keys/fullchain.pem" "keys/privkey.pem"<br/>        config = setPort 8443 defaultSettings<br/><br/>    sync &lt;- newTVarIO def<br/>        -- 'runActionToIO' is called once per action.<br/>    let runActionToIO m = runReaderT (runWebM m) sync<br/><br/>    waiApp &lt;- scottyAppT runActionToIO app<br/>    runTLS tlsConfig config waiApp<br/><br/>app :: ScottyT T.Text WebM  ()<br/>app = dobeam &lt;- param "word"<br/>        html $ mconcat ["&lt;h1&gt;Scotty, ", beam, " me up!&lt;/h1&gt;"]<br/>    get "/:word" $ do<br/>        beam &lt;- param "word"<br/>        html $ mconcat ["&lt;h1&gt;Scotty, ", beam, " me up!&lt;/h1&gt;"]</span></pre><h2 id="7445" class="ne kx iq bd ky nf ng dn lc nh ni dp lg kj nj nk lk kn nl nm lo kr nn no ls np bi translated">简单JSON端点</h2><p id="7c86" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用Aeson库，用Haskell制作JSON非常简单。出于我的目的，我只需要提供一个来自本地文件的记录列表。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="5720" class="ne kx iq ns b gy nw nx l ny nz">import Data.Aeson</span><span id="e6e2" class="ne kx iq ns b gy od nx l ny nz">data RecordType = Image | MP4 | Youtube<br/>data Record = Record { ty :: RecordType, title :: T.Text, url :: T.Text }<br/><br/>instance ToJSON RecordType where<br/>    toJSON Image = "image"<br/>    toJSON MP4 = "mp4"<br/>beam &lt;- param “word”<br/> html $ mconcat [“&lt;h1&gt;Scotty, “, beam, “ me up!&lt;/h1&gt;”]    toJSON Youtube = "youtube"<br/><br/>instance ToJSON Record where<br/>    toJSON (Record {ty=t, title=title, url=u}) = object [ "type" .= t, "title" .= title, "url" .= u]</span></pre><p id="367c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，<code class="fe oa ob oc ns b">Record</code>可序列化为JSON！我们可以很容易地提供一个<code class="fe oa ob oc ns b">Record</code>，或者一个列表。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="2aa1" class="ne kx iq ns b gy nw nx l ny nz">get "/:word" $ do<br/>unfortunately        json $ [Record { ty=Image, title="Hi", url="url" }]</span></pre><p id="249e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至于从本地文件中读取记录，这非常简单。对于我的玩具网站，我只是读取了一个空格分隔的文本文件(原语，我知道)。然而，Haskell有一些非常符合人体工程学的数据库支持。我发现这篇文章很有帮助。</p><p id="bc82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是从/向空格分隔的文件读写的函数。我认为它们展示了Haskell相对于其他后端语言的优势。Go中这些函数的模拟代码有将近100行长，其中有一个我没有注意到的错误。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="4f87" class="ne kx iq ns b gy nw nx l ny nz">readRecord :: T.Text -&gt; Record<br/>readRecord line = readSplit $ T.splitOn " " $ line<br/>    where readTy :: T.Text -&gt; RecordType<br/>          readTy "image" = Image <br/>          readTy "MP4" = MP4<br/>          readTy "Youtube" = Youtube<br/>          readTy _ = Image<br/>          readSplit :: [T.Text] -&gt; Record<br/>          readSplit [ty, title, url] = Record {ty=readTy $ T.strip $ ty,title=title, url=url}</span><span id="e653" class="ne kx iq ns b gy od nx l ny nz">--            all lines   start   end<br/>readRecords :: [T.Text] -&gt; Int -&gt; Int -&gt; [Record]<br/>readRecords ls start num<br/>  | start &gt;= 0 = map readRecord (take num $ drop start $ ls)<br/>  | otherwise = map readRecord (take num $ drop (-start - num) $ reverse ls)</span><span id="db41" class="ne kx iq ns b gy od nx l ny nz">addRecord :: T.Text -&gt; T.Text -&gt; T.Text -&gt; IO ()<br/>addRecord ty title url = do<br/>    let recordLS = map T.unpack [ty, title, url]<br/>    let recordStr = L.intercalate " " recordLS<br/>    file &lt;- SIO.readFile "records.txt"<br/>    writeFile "records.txt" (concat [memeStr, "\n", file])</span></pre></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="f964" class="kw kx iq bd ky kz mu lb lc ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt bi translated">苗条身材入门</h1><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2d63e2b58a30e7bff5d1f73489955472.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*sDES6Uhi1xaZH1ae"/></div></figure><p id="83fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，Svelte有一些很棒的文档。<a class="ae nq" href="https://svelte.dev/blog/the-easiest-way-to-get-started" rel="noopener ugc nofollow" target="_blank">入门指南</a>告诉我们，我们可以用几个简单的命令开始一个苗条的项目:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="9628" class="ne kx iq ns b gy nw nx l ny nz">npx degit sveltejs/template my-svelte-project<br/>cd my-svelte-project<br/>npm install<br/>npm run dev</span></pre><p id="3407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我浏览了苗条教程，写出了我的第一页。如果你已经知道HTML/JS，实际上没有学习曲线。<code class="fe oa ob oc ns b">npm run dev</code>每当你做改变时，重建并托管服务器，使得迭代速度非常快。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="6d74" class="ne kx iq ns b gy nw nx l ny nz">&lt;script&gt;<br/>    let records = [{type: 'image', title: 'title', url: 'url.com'}]<br/>&lt;/script&gt;</span><span id="7610" class="ne kx iq ns b gy od nx l ny nz">&lt;main&gt;<br/>    &lt;div class="grid"&gt;<br/>        {#each records as { type, title, url }, i} <br/>            {#if type == 'image'}<br/>                &lt;img src='{url}'&gt;<br/>            {:else if type == 'mp4}<br/>                ...<br/>            {/if}<br/>        {/each}<br/>    &lt;/div&gt;<br/>&lt;/main&gt;</span><span id="cad2" class="ne kx iq ns b gy od nx l ny nz">&lt;style&gt;<br/>...<br/>&lt;/style&gt;</span></pre><p id="933d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码片段硬编码了记录，但是实际上您需要从服务器获取它们。幸运的是，苗条使这变得很容易。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="7165" class="ne kx iq ns b gy nw nx l ny nz">&lt;script&gt;<br/>    import { onMount } from "svelte"<br/>    <br/>    let records = []</span><span id="1cbb" class="ne kx iq ns b gy od nx l ny nz">    onMount(async () =&gt; {<br/>        const res = await fetch('/records')<br/>        records = await res.json()<br/>    })<br/>&lt;/script&gt;</span></pre><p id="8c41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe oa ob oc ns b">onMount</code>是一个内置的生命周期，甚至可以在页面加载时运行。由于<code class="fe oa ob oc ns b">records</code>在脚本中被赋值给，它将自动在页面的HTML中更新。</p><p id="fd9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这本身看起来很糟糕，至少在我的网站上是这样，因为记录下面的内容会在记录载入之前短暂闪现。解决方法很简单:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="969a" class="ne kx iq ns b gy nw nx l ny nz">&lt;script&gt;<br/>    import { onMount, fade } from "svelte"<br/>    <br/>    let records = []<br/>    let loaded = false</span><span id="7e5c" class="ne kx iq ns b gy od nx l ny nz">    onMount(async () =&gt; {<br/>        const res = await fetch('/records')<br/>        records = await res.json()<br/>        loaded = true<br/>    })<br/>&lt;/script&gt;</span><span id="2162" class="ne kx iq ns b gy od nx l ny nz">&lt;main&gt;<br/>    {#if loaded}<br/>        &lt;div transition:slide class="grid"&gt;<br/>            &lt;!-- Record HTML goes here --&gt;<br/>         &lt;/div&gt;<br/>    {/if}<br/>&lt;/main&gt;</span></pre><p id="73ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，在所有记录都准备好之前，不会加载任何东西。Svelte甚至有一些很好的内置过渡，所以一切都会很好地淡入。如果你的内容需要更长的时间来获取，使用加载动画可能会更好，但这也很容易用Svelte来完成:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="895f" class="ne kx iq ns b gy nw nx l ny nz">&lt;main&gt;<br/>    {#if loaded}<br/>        &lt;!-- Record HTML --&gt;<br/>    {:else}<br/>        &lt;!-- Loading Animation --&gt;<br/>    {/if}<br/>&lt;/main&gt;</span></pre><p id="eb74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nq" href="https://svelte.dev/tutorial/animate" rel="noopener ugc nofollow" target="_blank"> Svelte内置了一些动画，</a>但是我没有试过，我不认为它是为加载类型动画设计的。</p><h2 id="3366" class="ne kx iq bd ky nf ng dn lc nh ni dp lg kj nj nk lk kn nl nm lo kr nn no ls np bi translated">Page.js</h2><p id="ea2d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Svelte的局限性之一就是只能做单页app<a class="ae nq" href="https://www.reddit.com/r/sveltejs/comments/jkzu8o/from_go_to_haskellsvelte/gamub91/" rel="noopener ugc nofollow" target="_blank">*</a>。有一个基于Svelte的框架叫做Sapper，它是为多页面网站设计的，但是据我所知，它需要一个ExpressJS服务器。为了简单起见，我决定使用一个名为page.js的客户端路由器。最初，我打算手工编写一个简单的路由器，但是由于page.js只有1200左右，并且增加了一点人体工程学的东西，所以我认为这不值得。</p><p id="37bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个苗条的应用程序中使用page.js的想法非常简单。每个页面只是一个组件，App.svelte只是一个框架，可以用于一个通用的页眉或CSS。安装page.js很简单:只需运行<code class="fe oa ob oc ns b">npm install page</code>。</p><p id="3993" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我的新<code class="fe oa ob oc ns b">App.svelte</code>的样子:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="3bdc" class="ne kx iq ns b gy nw nx l ny nz">&lt;script&gt;<br/>    import router from "page"<br/>    import Index from './Index.svelte'<br/>    import Records from './Records.svelte'</span><span id="6a6d" class="ne kx iq ns b gy od nx l ny nz">    let page = Index<br/>    <br/>    router('/', () =&gt; page = Index)<br/>    router('/records/:p', () =&gt; page = Records)<br/>    <br/>    router.start()<br/>&lt;/script&gt;</span><span id="08e8" class="ne kx iq ns b gy od nx l ny nz">&lt;main&gt;<br/>    &lt;svelte:component this={page} /&gt;<br/>&lt;/main&gt;</span><span id="af3a" class="ne kx iq ns b gy od nx l ny nz">&lt;style&gt;Conclusion<br/>&lt;/style&gt;</span></pre><p id="4e0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe oa ob oc ns b">Records.svelte</code>和以前一样，一行一行，除了没有<code class="fe oa ob oc ns b">&lt;main&gt;</code>标签，因为它们已经包含在<code class="fe oa ob oc ns b">App.svelte</code>中。它对它们起作用，但是这是一个不必要的嵌套层次。</p><h1 id="b358" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">主持斯科特的苗条网站</h1><p id="8228" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">到目前为止，我们已经通过<code class="fe oa ob oc ns b">npm run dev</code>托管了这个苗条的应用。相反，我们想通过我们的Scotty服务器托管。苗条使这变得相当简单；运行<code class="fe oa ob oc ns b">npm run dev</code>会把所有编译好的HTML/CSS/JS放到<code class="fe oa ob oc ns b">public/</code>文件夹中。接下来，我们要做的就是让哈斯克尔发球。</p><p id="33f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定做的只是添加一个文件夹作为我的整个堆栈项目的子文件夹。我将其重命名为<code class="fe oa ob oc ns b">client</code>，所以我的文件树看起来像:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="c95a" class="ne kx iq ns b gy nw nx l ny nz">.<br/>├── app<br/>├── client<br/>│   ├── node_modules<br/>│   ├── public<br/>│   ├── scripts<br/>│   └── src<br/>├── src<br/>└── test</span></pre><p id="7c15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让Haskell静态地服务于<code class="fe oa ob oc ns b">client/public</code>文件夹，我只是在我的<code class="fe oa ob oc ns b">app</code>函数的末尾添加了一行<code class="fe oa ob oc ns b">middleware $ staticPolicy (noDots &gt;-&gt; addBase “client/public”)</code>。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="69d8" class="kw kx iq bd ky kz mu lb lc ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt bi translated">结论</h1><p id="a2ee" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">最终的结果是非常整洁的；实际上，所有的JSON端点都是作为简单的纯函数提供的，Svelte可以快速轻松地呈现它们。我的服务器代码现在比在Go中时简洁多了，可以说也清晰多了，使用Svelte作为前端让我可以添加一些在服务器端渲染版本中不可行的酷效果。总的来说，我还是有点反对客户端渲染；我认为没有JavaScript也能工作的网站应该做出合理的努力。我可能会在某个时候在我的网站上添加更多的互动内容，所以我会坚持使用Svelte。</p><p id="2b82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，我可能不会再使用Haskell作为服务器语言了。虽然许多端点只是纯粹的函数，但我觉得我没有获得Haskell通常提供的许多好处。比起Golang版本，我更喜欢Haskell+svelite版本的网站；它更短，更易读，并揭示了一些我甚至不知道的Golang版本中的错误。然而，许多Haskell库的文档相当简单，至少在例子方面是这样，而且几乎任何语言都比Go更具表现力。</p></div></div>    
</body>
</html>