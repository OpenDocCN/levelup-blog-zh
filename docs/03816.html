<html>
<head>
<title>Unexpected App Crashes on Android and How to Deal with Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上意外的应用崩溃以及如何应对</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unexpected-app-crashes-on-android-and-how-to-deal-with-them-c5d07512d99f?source=collection_archive---------3-----------------------#2020-05-28">https://levelup.gitconnected.com/unexpected-app-crashes-on-android-and-how-to-deal-with-them-c5d07512d99f?source=collection_archive---------3-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/af0bf2b487fd33ca1a6c07b1dbb5674d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WT3_B3SVKgvexQOTE_ZqQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由来自<a class="ae kf" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=762486" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kf" href="https://pixabay.com/users/testbytes-1013799/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=762486" rel="noopener ugc nofollow" target="_blank"> testbytes </a></figcaption></figure><p id="29eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果说所有开发人员有什么共同点的话，不管是前端、后端，甚至是游戏开发人员，那就是我们讨厌产品bug。尤其是当这些错误导致应用程序崩溃的时候。当您最近开始生产时，在您的应用程序中监控这些不断增加的崩溃是一种不愉快的经历。</p><p id="0244" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">遇到一些崩溃是因为它运行的系统/平台，而不管应用程序的业务逻辑。在Android中，当你从后台状态恢复应用程序时，你可能会遇到崩溃。这种崩溃是意料之外的，仅通过查看崩溃日志很难理解或处理。</p><p id="52a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文就谈谈这样的问题以及解决的方法。</p><h1 id="ab16" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">问题是</h1><p id="686f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在监视生产中的崩溃日志时，我注意到一些问题日益增多。这款应用在正常测试条件下似乎运行良好，崩溃日志也不可复制。直到应用程序从后台任务中恢复。</p><p id="b48f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个android应用程序都在自己的进程中运行，这个进程已经被操作系统分配了一些内存。当用户与其他应用程序交互时，如果你的应用程序被放在后台，如果没有足够的内存可供你的应用程序使用，操作系统可以终止你的应用程序进程。这通常发生在另一个应用程序正在前台运行，需要更大的手机内存(RAM)时。</p><p id="880d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当app进程被终止时，所有的单例对象和临时数据也会丢失。现在，当您返回到您的应用程序时，系统将创建一个新的进程，您的应用程序将从堆栈顶部的活动恢复。</p><p id="d1db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为此时所有的单例对象都丢失了，所以当活动试图访问相同的对象时，应用程序会崩溃，导致NullPointerException。</p><p id="4447" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个问题，在我们进入解决方案之前，让我们复制这个场景。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="10f2" class="le lf it bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">复制撞车事故</h1><ol class=""><li id="b63e" class="mt mu it ki b kj mc kn md kr mv kv mw kz mx ld my mz na nb bi translated">继续在模拟器或通过USB电缆连接的实际设备中运行Android Studio中的任何应用程序。</li><li id="24f9" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">导航到一个随机屏幕，然后按下“主页”按钮</li><li id="b859" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">打开终端并键入以下命令来获取应用程序的进程ID (PID)</li></ol><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="185a" class="nq lf it nm b gy nr ns l nt nu">adb shell pidof com.darktheme.example</span></pre><p id="7649" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该命令的语法是‘ADB shell pidof<strong class="ki iu">* APP _ BUNDLE _ ID *’</strong></p><p id="83f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意您在终端窗口上看到的PID。(这可用于验证当我们恢复应用程序时，现有的应用程序进程是否被终止，以及是否启动了新的进程)</p><p id="499e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.键入以下终端命令终止您的应用程序进程</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d6b6" class="nq lf it nm b gy nr ns l nt nu">adb shell am kill com.darktheme.example</span></pre><p id="67db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，您的终端窗口应该如下所示:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/1adf647fdfa0d488567d88204b9c831b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYpZN8FbnrYeo_6QPGqc0g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">处理终端中输入的删除命令</figcaption></figure><p id="ae2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在从后台任务打开你的应用，检查应用是否崩溃。如果是，请不要担心，我们将在下一节讨论如何处理这个问题。如果没有，给自己一个鼓励，因为这是你应得的:)</p><p id="267f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:从后台打开app后，检查新进程的PID。如果您在步骤3中记下的PID和新的PID相等，则该进程从未被终止。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="64c0" class="le lf it bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">拟议解决方案</h1><p id="ad0c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">处理这个问题有两种方法。根据您所处的情况，您可以决定采用哪一种方法:</p><h2 id="0ad4" class="nq lf it bd lg nw nx dn lk ny nz dp lo kr oa ob ls kv oc od lw kz oe of ma og bi translated">解决方案1:</h2><p id="44c0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">一个简单方便的解决方案是，当用户从后台恢复应用程序时，检查我们现有的应用程序进程是否被终止并重新创建。如果是，您可以导航回启动屏幕，这样它就像一个新的应用程序启动场景。</p><p id="06a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以将以下代码放在BaseActivity中:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="97ed" class="mt mu it ki b kj kk kn ko kr oj kv ok kz ol ld om mz na nb bi translated">通过覆盖“onSaveInstanceState”函数将您的PID保存在包中。</li><li id="2121" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld om mz na nb bi translated">在“onCreate”方法中，比较当前PID和来自包的PID。</li><li id="2568" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld om mz na nb bi translated">如果重新创建了流程，则重定向到Splash活动。</li></ul><p id="c3f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户从后台导航回应用程序时，如果应用程序进程被终止，应用程序将从SplashActivity重新启动，就像它是一个新的应用程序启动一样。</p><p id="0d6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将防止应用程序访问任何可能在进程重建期间丢失的资源，从而防止应用程序崩溃。</p><p id="ad1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这种解决方案可以防止崩溃，但这种方法会重新启动应用程序，而不是从停止的地方恢复应用程序。如果你在一个生产应用中遇到这个问题，并且迫切地想要一个快速的解决方案，这个解决方案应该很适合你。</p><p id="9365" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果你最近刚开始从头开始开发，解决方案2将是你的理想选择，因为它将从应用程序停止的地方恢复应用程序</p><h2 id="b3d5" class="nq lf it bd lg nw nx dn lk ny nz dp lo kr oa ob ls kv oc od lw kz oe of ma og bi translated">解决方案2:</h2><p id="d1a3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">到目前为止，您一定已经注意到，您可以从“Bundle”对象中保存和访问数据。保存每个活动/片段中的所有必要信息，就像我们在前面的例子中所做的那样。</p><p id="d836" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们正在访问保存在包中的数据，所以应该防止应用程序崩溃，并且应用程序应该从停止的地方恢复。所有其他活动/片段也将被重新创建。</p><p id="916b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于片段中的RecyclerView，它看起来像这样:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="e164" class="mt mu it ki b kj kk kn ko kr oj kv ok kz ol ld om mz na nb bi translated">通过覆盖“onSaveInstanceState”函数，将所需信息保存在Bundle对象中。</li><li id="48fa" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld om mz na nb bi translated">检查束中的数据是否在“onViewCreated”函数中可用，否则，通过ViewModel从源中获取数据。</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="e5f3" class="le lf it bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">结论</h1><p id="2946" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在Android平台上，由于进程终止导致的应用崩溃是非常常见的。在较新的Android版本中，可以观察到后台应用程序被大量删除以节省手机电池。</p><p id="f804" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案1可以快速修复您现有的生产崩溃。</p><p id="e610" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果你正在从头开始开发一个应用程序，我会推荐解决方案2，因为它可以确保应用程序从之前停止的地方继续运行。因此导致更好的用户体验。</p><p id="ec81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调查这种崩溃的根本原因可能会变得很困难，所以我希望这篇文章能以任何可能的方式帮助你。让我知道你们对我们讨论的解决方案有什么想法。</p><p id="8b19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文到此为止。编码快乐！</p></div></div>    
</body>
</html>