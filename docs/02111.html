<html>
<head>
<title>The fastest way to generate a sequence in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python生成序列的最快方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-fastest-way-to-generate-a-sequence-in-python-a61da7f87852?source=collection_archive---------3-----------------------#2020-02-19">https://levelup.gitconnected.com/the-fastest-way-to-generate-a-sequence-in-python-a61da7f87852?source=collection_archive---------3-----------------------#2020-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您已经知道的Python方法之间的细微差别</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c3fb3ffcba0fe1049f98a05f3539f4e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dl2lZ9Ygl8sLSWp1YM0qdw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">科技版WOC的照片</figcaption></figure><p id="81d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整个大学期间，我会在数学、应用数学和物理课上听到讲师重复说“剥猫皮有几种方法”。尽管我觉得马克·吐温的这句话有些荒谬和暴力，但它(奇怪的是)提醒我，要实现一个目标，总有许多可能的途径。当我决定在编码中使用哪些方法时，这给了我很大的帮助。</p><p id="5d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我早期，我所知道的就是<em class="lv"> range() </em>作为一种在Python中生成单调递增(或递减)序列的方法。然后我被介绍给了<em class="lv"> xrange() </em>和<em class="lv"> numpy.arange() </em>这让我开始嗯，作为一个新手，决定使用哪些功能的策略是什么？</p><h2 id="f1d6" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">1.内置方法:range()</h2><p id="ecc5" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">内置方法<em class="lv"> range( </em> [ <em class="lv"> start </em>，】<em class="lv"> stop </em>，[ <em class="lv"> step </em> ] <em class="lv"> ) </em>是我第一次在Python中介绍生成序列。函数中的可选参数显示在方括号中。<em class="lv"> range() </em>方法生成一个不可变的对象，它是一个数字序列。通过将<em class="lv"> range() </em>对象包含在list方法中，可以很容易地将其转换为Python列表，例如，创建一个介于10 ( <em class="lv"> start </em>)和0 ( <em class="lv"> stop </em>)之间的值列表，以2为增量递减(<em class="lv"> step </em>)。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ff5e" class="lw lx it mv b gy mz na l nb nc">&gt;&gt;list(range(10,0,-2))<br/>[10, 8, 6, 4, 2]</span></pre><p id="7499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法已经被证明在for循环和list comprehensions中非常有用，因为它是内置且高效的。为了测量它的速度，我编写了这个非常简单的脚本，它给出了执行range(10)的运行时的一个大样本。运行时(rt)的大范围分布提供了一个公平的方法来衡量平均创建一个<em class="lv"> range() </em>对象的速度。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c045" class="lw lx it mv b gy mz na l nb nc">rt=[]</span><span id="3618" class="lw lx it mv b gy nd na l nb nc">for _ in range(1000000):<br/>    t1 =time.time()<br/>    seq = range(val)<br/>    rt.append(time.time()-t1)</span><span id="a411" class="lw lx it mv b gy nd na l nb nc">rt_mean = np.mean(rt)*1.e9<br/>rt_std  = np.std(rt)*1.e9</span><span id="1d7f" class="lw lx it mv b gy nd na l nb nc">print(u'range() has an average runtime of %.0f \u00B1 %.0f ns'%(rt_mean,rt_std))</span></pre><p id="35a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简短的脚本以纳秒为单位提供了平均运行时间和1σ不确定性(或标准偏差)。人们可以使用神奇的方法%timeit来获得类似的度量。运行这个脚本给我们提供了:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b32f" class="lw lx it mv b gy mz na l nb nc">range() has an average runtime of 478 ± 739 ns</span></pre><p id="1989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来够快了，但是有更快的选择吗？</p><h2 id="ace0" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">2.Python 2的内置方法:xrange()</h2><p id="6f30" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">另一个这样的内置方法你可能在切换到Python 3之前已经发现了，就是<em class="lv">xrange(</em>[<em class="lv">start</em>，] <em class="lv"> stop </em>，[ <em class="lv"> step </em> ] <em class="lv">)。它输出一个生成器对象。像<em class="lv"> range() </em>一样，它在循环中很有用，也可以转换成列表对象。使用与前面类似的测试，我们可以测量它的平均运行时间，结果如下:</em></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="89d7" class="lw lx it mv b gy mz na l nb nc">xrange() has an average runtime of 370 ± 682 ns</span></pre><p id="d136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定误差范围，<em class="lv"> range() </em>和<em class="lv"> xrange() </em>的执行速度相当相似。主要区别在于输出——一个由<em class="lv"> range() </em>给出的iterable和一个由<em class="lv"> xrange()输出的generator对象。</em>比较两个对象之间的内存使用情况，</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7b31" class="lw lx it mv b gy mz na l nb nc">&gt;&gt; print('Memory use of iterable: %d'%(sys.getsizeof(range_seq)) )<br/>Memory use of iterable: 152</span><span id="06a4" class="lw lx it mv b gy nd na l nb nc">&gt;&gt; print('Memory use of generator object: %d'%(sys.getsizeof(xrange_seq)) )<br/>Memory use of generator object: 40</span></pre><p id="f580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在效率上没有差别，但是<em class="lv"> xrange() </em>对象的字节大小要小得多。我们可以考虑的另一个序列构建器是存在于NumPy库中的序列构建器。</p><h2 id="8e54" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">3.NumPy方法:numpy.arange()</h2><p id="17ab" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">numpy的方法<em class="lv">NumPy . arange(</em><strong class="lb iu">[</strong><em class="lv">start</em><strong class="lb iu">，】</strong> <em class="lv"> stop </em> <strong class="lb iu">，[ </strong> <em class="lv"> step </em> <strong class="lb iu">，] </strong> <em class="lv"> dtype=None) </em>提供了生成序列的功能。它生成一个NumPy数组对象(或<em class="lv"> numpy.ndarray </em>)。运行类似的脚本来确定平均运行时产量，</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="586e" class="lw lx it mv b gy mz na l nb nc">numpy.arange() has an average runtime of 1111 ± 958 ns</span></pre><p id="499c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据该测试，<em class="lv"> numpy.arange() </em>的平均执行时间是<em class="lv"> range() </em>和<em class="lv"> xrange() </em>的两倍以上。</p><p id="8fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<em class="lv"> xrange() </em>被限制在Python 2中，并且<em class="lv"> numpy.arange() </em>在生成序列时比<em class="lv"> xrange() </em>和<em class="lv"> range() </em>慢两倍，答案似乎很清楚。方法<em class="lv"> range() </em>是在Python中生成单调递增或递减序列的最有效的方法。虽然这可能是真的，但是每种方法产生的对象消耗内存的方式不同。</p><h1 id="6358" class="ne lx it bd ly nf ng nh mb ni nj nk me jz nl ka mh kc nm kd mk kf nn kg mn no bi translated">警告——每种方法的输出</h1><p id="ef9f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">的确，<em class="lv"> range() </em>执行<em class="lv"> </em>比<em class="lv"> numpy.arange() </em>快，输出一个可以转换成iterable list的对象。另一方面，<em class="lv"> numpy.arange() </em>给你一个<em class="lv"> numpy.ndarray </em>。毫无疑问，<em class="lv"> range() </em>在for循环中是更好的选择。然而，当涉及到对结果序列进行操作时，NumPy数组在内存消耗和速度方面都有明显的优势。</p><p id="0b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从内存开始，我们可以发现一个Python list对象和NumPy数组消耗了多少内存。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f8ac" class="lw lx it mv b gy mz na l nb nc">&gt;&gt; print('Memory use of iterable: %d'%(sys.getsizeof(range_seq)) )<br/>Memory use of iterable: 152</span><span id="2863" class="lw lx it mv b gy nd na l nb nc">&gt;&gt; print('Memory use of numpy.ndarray: %d '%(sys.getsizeof(arange_seq)) )<br/>Memory use of numpy.ndarray: 80</span></pre><p id="a6fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy数组在编译器内存存储中占用的空间更少，使得它们的操作效率更高。比较在<em class="lv">列表</em>和<em class="lv">numpy . ndar arrays</em>上执行基本算术运算的速度，可以很容易地测试这一点，正如这篇<a class="ae ky" href="https://webcourses.ucf.edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference" rel="noopener ugc nofollow" target="_blank"> UCF网络课程文章</a>中所展示的。</p><p id="3281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，在一个人的Python之旅中发现给猫剥皮的许多方法，可以帮助理解不同数据类型和方法的速度、功能和内存使用的重要性。最重要的是，编写简短的测试来比较运行时可以帮助人们辨别哪些方法会增加代码的整洁度和效率。</p><h2 id="8b1c" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">其他参考资料:</h2><p id="ffa9" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">[1]<a class="ae ky" href="https://www.geeksforgeeks.org/range-vs-xrange-python/" rel="noopener ugc nofollow" target="_blank">‘极客为极客’的帖子。标题:“Python中的range()vs xrange()”</a></p><p id="c4dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="https://www.geeksforgeeks.org/python-range-does-not-return-an-iterator/" rel="noopener ugc nofollow" target="_blank">‘极客为极客’的帖子。标题:“Python | range()不返回迭代器”</a></p><p id="0d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3] <a class="ae ky" href="https://www.reddit.com/r/learnpython/comments/3g0hiz/difference_between_range_and_arange/" rel="noopener ugc nofollow" target="_blank"> Reddit在subreddit上的帖子:<em class="lv"> r/learnpython。</em>题目:<em class="lv"/>“range和arange的区别？”</a></p></div></div>    
</body>
</html>