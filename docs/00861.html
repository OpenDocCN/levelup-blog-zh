<html>
<head>
<title>How to Upload and Stream Multipart Content with Node JS In 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在5分钟内用Node JS上传和流式传输多部分内容</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/upload-and-stream-multipart-content-with-nodejs-in-5minutes-61836e061080?source=collection_archive---------1-----------------------#2019-08-28">https://levelup.gitconnected.com/upload-and-stream-multipart-content-with-nodejs-in-5minutes-61836e061080?source=collection_archive---------1-----------------------#2019-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c266c8a7481f180cb461b0210b57cd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFmaIJiZ7BehRryMgLDvxQ.jpeg"/></div></div></figure><p id="d152" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Node js中，开始流式传输上传的内容非常简单。在这个例子中，我们将看看如何使用request.js来实现这一点，这是一个非常漂亮的HTTP请求实用程序，应该是您的实用工具中的必备工具。如果你打算长期使用Node js的话。对于不熟悉流概念的人来说。将大文件加载到内存中的问题是，您实际上可能会耗尽内存，导致应用程序崩溃。如果这是一个可能是一场噩梦的生产应用程序，您会想尽一切办法避免它。</p><p id="dd3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">流的美妙之处在于，它们通过对大块数据进行操作来帮助您解决内存问题，从而允许您最小化内存占用。你可以想象一条小溪，就像你厨房水槽里的水龙头。一旦一个流被打开，数据就以块的形式从源头流向使用它的进程，理论上，你可以传输无限量的数据。</p><p id="cf27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始编码之前，确保你已经安装了<a class="ae kz" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js和</a>。</p><p id="9e0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦安装了节点，打开终端窗口并输入以下命令，检查它是否按预期工作</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="2c49" class="lj lk it lf b gy ll lm l ln lo">node -v</span></pre><p id="a011" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个名为<code class="fe lp lq lr lf b">myapp</code>的目录，切换到该目录并运行<code class="fe lp lq lr lf b">npm init</code>。按照屏幕上的说明给你的包一个默认的名字，版本，作者，测试脚本。按回车键预选默认选项。然后安装<code class="fe lp lq lr lf b">express</code>作为依赖项。Express js将用于说明我们的服务器，它将负责处理多部分上传的内容</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="5100" class="lj lk it lf b gy ll lm l ln lo">$ mkdir myapp &amp;&amp; cd $_</span><span id="e237" class="lj lk it lf b gy ls lm l ln lo">$ npm init</span><span id="81c9" class="lj lk it lf b gy ls lm l ln lo">$ npm install express --save</span></pre><p id="c41d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了说明流的作用，我们创建了客户端代码来执行内容的上传，我们可以将文件命名为<strong class="kd iu"> index.js </strong>。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3a02" class="lj lk it lf b gy ll lm l ln lo">touch index.js</span></pre><p id="7af4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的client.js代码利用了<a class="ae kz" href="https://www.npmjs.com/package/request" rel="noopener ugc nofollow" target="_blank">请求</a>模块——节点内置<a class="ae kz" href="https://nodejs.org/api/http.html" rel="noopener ugc nofollow" target="_blank"> http </a>模块的包装器。因此，我们需要通过运行以下命令来确保我们已经安装了它</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="8b29" class="lj lk it lf b gy ll lm l ln lo">npm install requests --save</span></pre><p id="ca1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将下面的代码附加到index.js，该代码用作负责执行formData上载的客户端代码，其中my_file属性是指向本地计算机上的文件的链接。<code class="fe lp lq lr lf b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank">FormData</a></code>对象允许您编译一组键/值对，并使用<code class="fe lp lq lr lf b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank">h</a>ttp request</code>发送。它主要用于发送表单数据，但也可以独立于表单使用，以传输键控数据。如果表单的编码类型设置为<code class="fe lp lq lr lf b">multipart/form-data</code>，传输数据的格式与表单的<code class="fe lp lq lr lf b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit" rel="noopener ugc nofollow" target="_blank">submit()</a></code>方法发送数据的格式相同。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="1b34" class="lj lk it lf b gy ll lm l ln lo">var request = require('request');<br/>var fs = require('fs');</span><span id="6940" class="lj lk it lf b gy ls lm l ln lo">var formData = {<br/>    my_field: 'file',<br/>    my_file: fs.createReadStream('C:\\temp\\recording.mp4')<br/>};<br/>request.post({<br/>    url: '<a class="ae kz" href="http://localhost:5000/api/v1/uploads'" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/v1/uploads'</a>,<br/>    formData: formData<br/>}, function optionalCallback(err, httpResponse, body) {<br/>    if (err) {<br/>        return console.error('upload failed:', err);<br/>    }<br/>    console.log('Upload successful!  Server responded with:', body);<br/>});</span></pre><p id="6fec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在服务器端，我们将使用busboy npm包来实际处理上传内容的流。附加包http-status-codes包含静态http代码，而<a class="ae kz" href="https://github.com/expressjs/morgan" rel="noopener ugc nofollow" target="_blank"> morgan </a>是一个日志工具，任何在Node.js中使用HTTP服务器的人都应该学会使用它。morgan是一个中间件，它允许我们轻松地将请求、错误等记录到控制台。</p><p id="c7d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于我们的用例，它有助于注销所有传入的HTTP请求。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="fdb9" class="lj lk it lf b gy ll lm l ln lo">npm install busboy --save<br/>npm install http-status-codes --save<br/>npm install morgan --save</span></pre><p id="d48c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">服务器背后的想法是模拟一个面向公众的服务，你需要上传多部分内容。你要记住的一点是，当使用Busboy时，它只解析application/x-www-form-urlencoded和multipart/form-data请求。创建名为server.js的新文件</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d607" class="lj lk it lf b gy ll lm l ln lo">touch server.js</span></pre><p id="fb9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面附加以下代码</p><pre class="la lb lc ld gt le lf lt bn lu lv bi"><span id="6b01" class="lw lk it lf b be lx ly l lz lo">var express = require('express'),<br/>    HttpStatus = require('http-status-codes'),<br/>    morgan = require('morgan'),<br/>    packageConfig = require('./package.json'),<br/>    path = require('path'),<br/>    fs = require('fs'),<br/>    Busboy = require('busboy');<br/>express()<br/>    .use(morgan('combined'))<br/>    .get('/api/v1', function(req, res) {<br/>        res.status(HttpStatus.OK).json({<br/>            msg: 'OK',<br/>            service: 'File Server'<br/>        })<br/>    })<br/>    .post('/api/v1/uploads', function(req, res) {<br/>        var busboy = new Busboy({<br/>            headers: req.headers<br/>        });<br/>        console.log(req.headers);<br/>        busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {<br/>            file.on('data', function(data) {<br/>                console.log('File [' + fieldname + '] got ' + data.length + ' bytes');<br/>            });<br/>            file.on('end', function() {<br/>                console.log('File [' + fieldname + '] Finished');<br/>            });<br/>            var saveTo = path.join(__dirname, 'dir', path.basename(filename));<br/>            var outStream = fs.createWriteStream(saveTo);<br/>            file.pipe(outStream);<br/>        });<br/>        busboy.on('finish', function() {<br/>            res.writeHead(HttpStatus.OK, {<br/>                'Connection': 'close'<br/>            });<br/>            res.end("That's all folks!");<br/>        });<br/>        return req.pipe(busboy);<br/>    }).listen(process.env.PORT || 5000, function() {<br/>        var address = this.address();<br/>        var service = packageConfig.name + ' version: ' + packageConfig.version + ' ';<br/>        console.log('%s Listening on %d', service, address.port);<br/>    });</span></pre><p id="87a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您需要将客户端作为单独的节点应用程序运行，而服务器在单独的节点应用程序上运行。点击查看完整源代码<a class="ae kz" href="https://github.com/timothymugayi/tiptapcode-node-examples/tree/master/multipart-streaming-upload" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>