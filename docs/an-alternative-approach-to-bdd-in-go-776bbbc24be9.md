# 围棋中 BDD 的另一种方法

> 原文：<https://levelup.gitconnected.com/an-alternative-approach-to-bdd-in-go-776bbbc24be9>

![](img/3ff47dc6f8475ce7b12d5c2dd5a440d5.png)

照片由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的[尼克·费因斯](https://unsplash.com/@jannerboy62?utm_source=medium&utm_medium=referral)拍摄

我是 TDD 的忠实粉丝。BDD 对我来说总是有点难以捉摸，我希望我能更经常地使用它。然而，我似乎总是最终难以通过 BDD 来表达相同的细微差别，而这些细微差别通过标准测试用例来表达是轻而易举的。

说实话，我已经有一段时间没碰 BDD 了。然而，这个问题最近一直在我脑海里蹦蹦跳跳:

**为什么通过 BDD 来表达简单的系统常常如此困难？**

基于代码的测试非常擅长描述我们如何完成一项任务。BDD 非常擅长描述一个任务想要达到的目标。想了想，我得出结论，根本问题是*状态*:

> DD 在像我们用代码那样访问和描述状态方面做得不好。因此，在描述算法和底层功能的行为时，抽象鸿沟变得太大了。

# 简单的例子

让我们考虑一个简单的银行账户的例子。测试如下:

下面是我们在 BDD 中表达相同行为的一种方式:

这两种方法都没有本质上的错误。然而，细节决定成败。这是一个非常简单、直接的例子，但是我已经能感觉到抽象的鸿沟让我离代码太远了。

随着测试变得越来越复杂(我真正谈论的是增加状态的数量)，用语言表达变得越来越困难。最终，语言变得比代码本身更难理解。

# 以前的方法

BDD 场景在管理状态方面做得不太好，因为描述步骤的语言和步骤实现可能想要/需要的变量之间存在脱节。我看到了解决这个问题的两种主要方法:

## 将步骤直接保存为代码，并依赖于变量的范围

一些以这种方式工作的框架有[银杏](https://onsi.github.io/ginkgo/#adding-specs-to-a-suite)和 [GoConvey](https://chromium.googlesource.com/external/github.com/smartystreets/goconvey/+/1.2/README.md#quick-start) 。我不想说这是一个糟糕的方法。我过去曾广泛使用银杏，最终这感觉就像是嵌套的测试。个人感觉并没有把行为和实现分开。不过，这是描述场景步骤的更好方式。

## 代码生成器

godog T2 框架就是一个很好的例子。它获取实际的 cucumber 特性文件并生成一堆空函数，您可以将您的实现放入其中。我个人没有使用过 godog，但是我在 Ruby 上使用 cucumber 的时候就非常熟悉这种方法。

我认为当在代码之外读取或维护特性文件时，这是一个很好的方法。这对于首先需要高度抽象的自动化和流程来说非常有效。然而，这并没有真正解决我的问题，我想在我的系统中使用 BDD 来处理底层的东西。

# 另一种方法

这两种策略当然都有优点(毫无疑问，我还没见过更多的优点)，这取决于哪种策略最适合您的工作流程。对我来说，我想要一些对我传统上用单元测试做的事情有效的东西。或者，至少探索一下这可能是什么样子。

我首先要澄清的是，这些例子还没有经过大型代码库的测试，所以我不能告诉你长期的细微差别和问题，但这些是我的初步想法。

我将首先向您展示整个框架:

是的，真的那么轻。事实上，这只是用类似小黄瓜的方式编写步骤的一点语法糖。

现在，回到我们的银行账户例子:

让我们用这个框架来表达这两个场景:

你可以在这里运行[的例子](https://play.golang.org/p/e77rqeSqQ0g)。它分为三个部分:

1.  **状态**(这是顶部的三个变量)。这些由所有步骤共享，甚至可以用作步骤本身的输入。
2.  **步骤**是作为场景可重用部分的函数或闭包。
3.  底部的**场景**成为命名的子测试。

我建议仍然使用像[verify](https://github.com/stretchr/testify)这样的测试框架来测试断言和其他特性。

我喜欢这个解决方案的原因是:

1.  它不依赖于任何运行时魔法，因此您可以从编译器那里获得更好的理解和保护。
2.  没有外部工具、文件或任何好的 ol' `go test`以外的东西。每个场景都是一个子测试，您可以在详细的输出中看到这一点——如果您对这类事情感兴趣的话。
3.  我觉得我以一种合理的方式将场景从步骤的实现中分离出来。

# 警告

1.  除了几个微不足道的例子之外，这是完全未经检验的。我不知道更复杂的设置会有多有效。如果这看起来像是你想尝试的东西，我很想知道这对你是否有效。
2.  尽管每个场景都作为单独的测试运行，但是场景不能并行运行，并且在设置结构时需要小心，以便测试不会相互影响。如果你想在场景之间保持状态，这实际上可能是一个积极的方面。
3.  步骤闭包中使用的变量需要通过引用传递(即使它们已经是指针)。这是一个很小的缺点，但是值得注意。