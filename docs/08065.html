<html>
<head>
<title>Go: Using a Closure in Place of a Struct</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go:使用闭包代替结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-using-a-closure-in-place-of-a-struct-d56ddd1e55f9?source=collection_archive---------5-----------------------#2021-03-31">https://levelup.gitconnected.com/go-using-a-closure-in-place-of-a-struct-d56ddd1e55f9?source=collection_archive---------5-----------------------#2021-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/032875e724a58c60b9967a56eb8bdf49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pPPYE7i7ZWX2PUmdF07Bcg.jpeg"/></div></figure><p id="3499" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这篇笔记并不是建议遵循一种模式，而是一种思考练习。让我们看看在惯用结构的地方使用闭包。</p><h2 id="d113" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">斐波那契数列发生器</h2><p id="e41f" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">对于这个思想练习，我们将以两种方式实现一个<a class="ae lt" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契数</a>序列生成器，一次使用<em class="lu">结构</em>，一次使用<a class="ae lt" href="https://gobyexample.com/closures" rel="noopener ugc nofollow" target="_blank">闭包 </a>。我们将在两者中使用相同的方法进行比较。</p><h2 id="8c65" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">作为一个结构</h2><p id="8cbd" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">因此，这里有一个简单且惯用的结构实现:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="eb78" class="kv kw it ma b gy me mf l mg mh">package main</span><span id="a8d9" class="kv kw it ma b gy mi mf l mg mh">import "fmt"</span><span id="a95f" class="kv kw it ma b gy mi mf l mg mh">type Fibonacci struct {<br/>  x1, x2 int<br/>}</span><span id="976b" class="kv kw it ma b gy mi mf l mg mh">func NewFibonacci() *Fibonacci {<br/>  return &amp;Fibonacci{-1,1}<br/>}</span><span id="207c" class="kv kw it ma b gy mi mf l mg mh">func (f *Fibonacci) Next() int {<br/>  f.x1, f.x2 = f.x2, f.x1 + f.x2<br/>  return f.x2<br/>}</span><span id="0658" class="kv kw it ma b gy mi mf l mg mh">func main() {<br/>  f := NewFibonacci()<br/>  for i := 0; i &lt; 10; i++ {<br/>    fmt.Println(f.Next())<br/>  }<br/>}</span></pre><p id="a149" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们声明结构(<em class="lu"> Fibonacci </em>)、工厂函数(<em class="lu"> NewFibonacci </em>)和下一个函数(<em class="lu"> Next </em>)。</p><h2 id="49d9" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">作为一个结束</h2><p id="ccc9" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">让我们实现与闭包相同的内容:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9fe1" class="kv kw it ma b gy me mf l mg mh">package main</span><span id="aeda" class="kv kw it ma b gy mi mf l mg mh">import "fmt"</span><span id="832a" class="kv kw it ma b gy mi mf l mg mh">func fibonacci() func() int {<br/>  x1, x2 := -1, 1<br/>  return func() int {<br/>    x1, x2 = x2, x1 + x2<br/>    return x2<br/>  }<br/>}</span><span id="af2e" class="kv kw it ma b gy mi mf l mg mh">func main() {<br/>  f := fibonacci()<br/>  for i := 0; i &lt; 10; i++ {<br/>    fmt.Println(f())<br/>  }<br/>}</span></pre><p id="6579" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">只有一个带闭包的函数(<em class="lu">斐波那契</em>)。</p><h2 id="825b" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">思想</h2><ul class=""><li id="329e" class="mj mk it jz b ka lo ke lp ki ml km mm kq mn ku mo mp mq mr bi translated"><em class="lu">闭包</em>更干净，更容易理解，代码更少。它隐式地封装了状态数据和工厂函数。</li><li id="bfbf" class="mj mk it jz b ka ms ke mt ki mu km mv kq mw ku mo mp mq mr bi translated">这种情况是人为设计的，因为我们只想要Fibonacci中的一个函数。当我们想读取值而不更新它或添加额外的函数时，只有一个<em class="lu">结构</em>会支持它。</li></ul><p id="76b2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">不管这里使用闭包有什么好处，这是一个关于闭包能做什么的有趣的思考练习。</p></div></div>    
</body>
</html>