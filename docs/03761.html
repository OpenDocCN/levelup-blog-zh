<html>
<head>
<title>Implement a Finite-State Machine in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang实现一个有限状态机</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-a-finite-state-machine-in-golang-f0438b6bc0a8?source=collection_archive---------4-----------------------#2020-05-26">https://levelup.gitconnected.com/implement-a-finite-state-machine-in-golang-f0438b6bc0a8?source=collection_archive---------4-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e640" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有限状态机是计算的一个基本概念。我们可以在现实生活中发现很多FSM的行为，比如自动售货机、电梯、红绿灯等等。</p><p id="0cc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于有限状态机的编程也是一个强大的工具来模拟复杂的状态转换，它可以大大简化我们的程序。</p><h1 id="04e9" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">什么是有限状态机</h1><blockquote class="lm ln lo"><p id="a197" class="jq jr lp js b jt ju jv jw jx jy jz ka lq kc kd ke lr kg kh ki ls kk kl km kn im bi translated">有限状态机(FSM)或简称为状态机，是计算的数学模型。它是一个抽象的机器，在任何给定的时间都可以处于有限数量的状态中的一个。FSM可以响应一些输入从一种状态改变到另一种状态；从一种状态到另一种状态的变化称为过渡。</p><p id="f454" class="jq jr lp js b jt ju jv jw jx jy jz ka lq kc kd ke lr kg kh ki ls kk kl km kn im bi translated">— <a class="ae lt" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="012a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有限状态机由三个关键元素组成:初始状态、所有可能状态的列表、触发状态转换的输入。</p><p id="c706" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们以turnstile作为FSM建模的一个简单例子。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/2602903c64eb0d87ff1a1dfcc4a84c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYlj2tD5OV8iUyyjZaJzLA.jpeg"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><a class="ae lt" href="https://upload.wikimedia.org/wikipedia/commons/9/9e/Turnstile_state_machine_colored.svg" rel="noopener ugc nofollow" target="_blank">维基百科的十字转门状态图</a></figcaption></figure><p id="d3bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像其他FSM一样，十字转门的状态机有三个元素:</p><ul class=""><li id="261d" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">它的初始状态是“锁定”</li><li id="808b" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">它有两种可能的状态:“锁定”和“解锁”</li><li id="3d4d" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">两个输入将触发状态改变:“推”和“投币”</li></ul><h1 id="70a7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">在Golang中构建一个基于FSM的程序</h1><p id="8916" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">接下来，我将构建一个模拟turnstile行为的命令行程序。</p><p id="095f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当程序启动时，它会提示用户键入一些命令，然后它会根据输入的命令改变其状态。</p><h2 id="0630" class="nd kp it bd kq ne nf dn ku ng nh dp ky kb ni nj lc kf nk nl lg kj nm nn lk no bi translated">版本1，以简单的形式实现FSM</h2><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3f6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们定义了两个状态(<code class="fe nr ns nt nu b">Locked &amp; Unlocked</code>)和两个有效命令(<code class="fe nr ns nt nu b">CmdCoin &amp; CmdPush</code>)。</p><p id="6bf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在函数<code class="fe nr ns nt nu b">main</code>中，我们设置初始状态为<code class="fe nr ns nt nu b">Locked</code>，打印使用信息给用户。</p><p id="b687" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们开始主循环，从<code class="fe nr ns nt nu b">stdin</code>中读取命令字符串，根据当前状态处理命令。</p><p id="3075" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能会注意到，我们必须为每个状态处理未知命令，这可以通过小的重构来改进。</p><p id="bec6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，如果我们将状态转换的逻辑提取到一个函数中，程序将更具表现力。</p><h2 id="1779" class="nd kp it bd kq ne nf dn ku ng nh dp ky kb ni nj lc kf nk nl lg kj nm nn lk no bi translated">版本2，重构使代码更加清晰</h2><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2272" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在实践中，状态机通常由一个<a class="ae lt" href="https://en.wikipedia.org/wiki/State-transition_table" rel="noopener ugc nofollow" target="_blank">状态转换表</a>来表示，对于我们的十字转门示例，该表看起来像这样:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nv"><img src="../Images/41c27a9d975a451ccb58ae57f6577703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_2x8lMfIF4XjnAjoJcfEw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Finite-state_machine#Example:_coin-operated_turnstile" rel="noopener ugc nofollow" target="_blank">维基百科的状态转换表</a></figcaption></figure><p id="a4e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用状态转移表来实现FSM。</p><h2 id="fcb8" class="nd kp it bd kq ne nf dn ku ng nh dp ky kb ni nj lc kf nk nl lg kj nm nn lk no bi translated">版本3，引入状态转换表</h2><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5e7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这种方法，所有可能的转换都列在表中。易于维护和理解。如果需要新的转换，只需添加一个表条目。</p><p id="3d8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于FSM是一个抽象机器，我们可以更进一步，用面向对象的方式实现它。</p><h2 id="ea55" class="nd kp it bd kq ne nf dn ku ng nh dp ky kb ni nj lc kf nk nl lg kj nm nn lk no bi translated">版本4，用一个类对FSM建模</h2><p id="16f4" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">引入了一个新的类<code class="fe nr ns nt nu b">Turnstile</code>，它有一个属性<code class="fe nr ns nt nu b">State</code>，一个名为<code class="fe nr ns nt nu b">ExecuteCmd</code>的方法。</p><p id="ed02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">触发状态转换的唯一方法是调用方法<code class="fe nr ns nt nu b">ExecuteCmd</code>。</p><p id="163b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该关系可以用下面的有向图表示:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nw"><img src="../Images/896125a446f86edba750130db778e048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnQTaea8YizYi5SPPsSU0g.png"/></div></div></figure><p id="585d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把所有的东西放在一起，这是完整的源代码:</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="701d" class="nd kp it bd kq ne nf dn ku ng nh dp ky kb ni nj lc kf nk nl lg kj nm nn lk no bi translated">跑起来</h2><p id="f1b8" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">让我们试一试这个程序:</p><pre class="lv lw lx ly gt nx nu ny nz aw oa bi"><span id="e6fa" class="nd kp it nu b gy ob oc l od oe">$ go run main.go<br/>current state is [Locked], please input command [coin|push]<br/><strong class="nu iu">foo</strong><br/>unknown command, try again please<br/><strong class="nu iu">push</strong><br/>not allowed, unlock first<br/><strong class="nu iu">coin</strong><br/>unlocked, ready for pass through<br/><strong class="nu iu">coin</strong><br/>well, don't waste your coin<br/><strong class="nu iu">push</strong><br/>pass through, shift back to locked<br/><strong class="nu iu">push</strong><br/>not allowed, unlock first<br/>^Csignal: interrupt<br/>$</span></pre><p id="5f7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">程序启动后，会出现一个提示字符串。</p><p id="a94a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们输入一个无效的命令“foo ”,我们会得到反馈，程序不知道这个命令。</p><p id="f8da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于初始状态是锁定的，如果我们试图“推”它，旋转门将不会打开。只有“硬币”命令才能解锁。</p><p id="f524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是“投币”命令对解锁的十字转门无效。如果我们在这种情况下“推”它，旋转门的状态将恢复到锁定状态。</p><p id="b5df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的例子展示了十字转门的所有典型转换。</p><h1 id="0882" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="af33" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在这个故事中，我们介绍了FSM的概念，并构建了一个基于FSM的程序。</p><p id="5921" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们提供了该程序的四个版本。</p><ul class=""><li id="5fc3" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">v1，以简单的形式实现FSM。</li><li id="8997" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">v2，做一些重构来减少代码重复</li><li id="b89b" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">v3，引入状态转换表</li><li id="1cf1" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">v4，用OOP重构</li></ul><p id="2c2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这次旅程之后，我希望你和我有同样的感觉:FSM是一个简单而强大的工具，我们应该把它添加到我们的编程工具箱中。不是吗？</p></div></div>    
</body>
</html>