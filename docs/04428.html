<html>
<head>
<title>Testing an all open-source, modern C++ workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试一个完全开源的现代C++工作流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-a-modern-c-workflow-by-coding-a-base85-decoder-from-scratch-c6cde64984a9?source=collection_archive---------1-----------------------#2020-06-26">https://levelup.gitconnected.com/testing-a-modern-c-workflow-by-coding-a-base85-decoder-from-scratch-c6cde64984a9?source=collection_archive---------1-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="47b7" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">从头开始编写base85解码器</h1><p id="d77b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我职业生涯的大部分时间都花在后端，比如实时和高可用性软件。在我的职业生涯中，我使用C++的次数比其他任何技术都多。我从2002年开始使用C++，从那以后就没有停止过。</p><p id="863e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">时间在继续，前几天，一个偶然的机会，我在一个网站上发现了一个不错的挑战。那个网站叫“汤姆的数据洋葱”。你可以在这里找到它:<a class="ae lr" href="https://www.tomdalling.com/toms-data-onion/" rel="noopener ugc nofollow" target="_blank">https://www.tomdalling.com/toms-data-onion/</a></p><p id="f1c7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">事情是这样的，在挑战中有一个有效载荷，以Adobe-flavor Base85编码进行编码，你必须解码才能继续解决有效载荷中嵌套的其余问题。</p><p id="900a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我告诉自己:哦，这是一个从零开始的小实验的完美。我将建立一个项目，看看与其他语言相比，特别是从我开始使用C++以来，T2的生产率如何。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="8744" class="jq jr it bd js jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn bi translated">这个项目的自我设定目标</h1><p id="458b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我的目标只是生产一个base85解码器，可以解码Tom的数据洋葱中的有效载荷，而不是迭代洋葱的嵌套层来解决每个问题。</p><ol class=""><li id="3a40" class="mf mg it kq b kr lm kv ln kz mh ld mi lh mj ll mk ml mm mn bi translated">我想遵循TDD工作流，所以我需要一个测试依赖。</li><li id="149f" class="mf mg it kq b kr mo kv mp kz mq ld mr lh ms ll mk ml mm mn bi translated">我会使用最新的C++。所以我选择了C++20。</li><li id="510a" class="mf mg it kq b kr mo kv mp kz mq ld mr lh ms ll mk ml mm mn bi translated">目标是完成能解码base85有效载荷的东西。通过测试(TDD)检查正确性，最后我想添加一个文件解码作为基线基准，以防我想用更具竞争力的实现来改进我已经拥有的东西。</li></ol><p id="2e25" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">谁知道呢，如果我感到有动力，有一天我可以把这个库变成一个解码器，让它快速工作…但这不是最初的目标。</p><h1 id="774f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">选择编码环境</h1><p id="9c2f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如我之前说过的，我写代码已经有一段时间了(我会说是很长一段时间)。我发现编码非常有趣，但我也喜欢完成工作。因此，我不得不从200，000种自定义工作流排列中选择一种合理的工作流，人们可以在C++中选择这种工作流。您可以选择普通的Makefiles，但这只能在类Unix系统中工作。或者自动工具，同样的故事。你也可以选择一个Visual Studio解决方案，但那只适用于Windows。所以我总是使用可移植的构建系统。从SCons，到Waf，Tup，CMake，介子或Build2。我应该选择什么？</p><p id="98f8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于IDE…从Visual Studio到CLion全功能IDE，再到Vim、Emacs、Sublime或Visual Studio代码等文本编辑器...</p><p id="45bf" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我选择了一些我可以很快建立起来的东西，这些东西将会有代码完成，将会是合理的可移植的，并且在那里我至少可以快速和容易地处理需要的依赖。</p><p id="7157" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">总之，我喜欢这种环境:</p><ul class=""><li id="38d2" class="mf mg it kq b kr lm kv ln kz mh ld mi lh mj ll mt ml mm mn bi translated">Doom Emacs</li><li id="9388" class="mf mg it kq b kr mo kv mp kz mq ld mr lh ms ll mt ml mm mn bi translated">介子构建系统(外部依赖的包装)</li><li id="03ba" class="mf mg it kq b kr mo kv mp kz mq ld mr lh ms ll mt ml mm mn bi translated">Lsp代码完成</li></ul><h1 id="6dc2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">环境的效率如何？</h1><p id="e1ec" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我将从开发的一部分开始，这样你就可以对工作流程有所了解。</p><p id="cb10" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">之后，我想展示一些不同领域的结论，这些领域是我在编码时重视完成的事情，与生产力相关。</p><h1 id="d091" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">编码器的发展，因为它发生了</h1><p id="0172" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">安装和设置好工具后，您需要:</p><ol class=""><li id="d630" class="mf mg it kq b kr lm kv ln kz mh ld mi lh mj ll mk ml mm mn bi translated">设置git repo</li><li id="a530" class="mf mg it kq b kr mo kv mp kz mq ld mr lh ms ll mk ml mm mn bi translated">安装并启动用于lsp代码完成的ccl</li><li id="804d" class="mf mg it kq b kr mo kv mp kz mq ld mr lh ms ll mk ml mm mn bi translated">通过Emacs中的melpa添加介子模式</li><li id="2011" class="mf mg it kq b kr mo kv mp kz mq ld mr lh ms ll mk ml mm mn bi translated">在基础设施中提供最少的介子构建文件来开始你的项目</li></ol><p id="ad28" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">设置git repo是从终端完成的，git init位于项目的目录中。</p><p id="dcc4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">ccl可以通过apt从包管理器安装，也可以从终端运行。我只是用<code class="fe mu mv mw mx b">nohup ccls &amp;</code>运行它以使它变得简单，尽管你可以做你自己的进一步的systemd集成或类似的事情。</p><p id="9e9a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以通过MELPA从Emacs安装大量的软件包。我自己安装了介子模式，我不记得是否有其他东西，因为Doom Emacs默认有很多东西，尽管你需要激活它们(取消注释+ <code class="fe mu mv mw mx b">.emacs.d/bin/doom sync</code>)。Doom Emacs支持分步更新，这样如果有东西坏了，你可以回到以前的设置，虽然我自己没有试过。</p><p id="1fa8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">由于我的目录布局，现在我需要一个最小的meson.build文件在顶部+一些其他的递归文件，因为我每个文件夹使用一个。最初的主视图如下所示。</p><p id="62aa" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我添加了一个可执行文件和一个测试。在介子中这很容易。如您所见，测试需要catch2依赖关系。这不是标准库的一部分:</p><figure class="my mz na nb gt nc"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">开始编码的基本meson.build文件</figcaption></figure><p id="22be" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你可以在Emacs中设置一个项目，在pulse的帮助下，使用F-10键，进入菜单pulse-&gt;配置项目，或者使用<code class="fe mu mv mw mx b">Control-c p C</code>。所有命令都有快捷键。射弹用途。git文件夹作为根目录，并且足够智能地检测到这是一个Meson项目，所以它第一次用配置命令提示我可以更改，但是缺省值已经足够好了。除了配置之外，还有用于运行、测试和编译的命令。</p><p id="3f64" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">通过F-9，你还可以在左边隐藏/显示一个树形导航部件。通过F-10，您可以显示全球菜单。右键单击可以显示文件的上下文菜单。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/d65bcdeccfd1493e930a641593a0bfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wd6BAkuKh4-exg2E692OA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">按下F-9键后显示树状视图。有了F-9，它又隐藏起来了。</figcaption></figure><p id="51d1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">一旦项目设置好了，我就在根文件夹中添加了(不确定是否还需要，但曾经是必要的)一个到我的<code class="fe mu mv mw mx b">compile_commands.json</code>的链接，用于代码完成:</p><figure class="my mz na nb gt nc"><div class="bz fp l di"><div class="nq ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">链接compile_commands.json以便lsp可以索引您的代码</figcaption></figure><p id="cb0b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在那之后，我重启了emacs和lsp索引，只要你已经安装并运行了ccls，因为ccls是一个守护进程。</p><p id="f829" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">有一个外部依赖，Catch2。依赖关系会发生什么？简单:如果它是在你的系统中被检测到的话。如果找不到…你就有麻烦了…或者没有。</p><p id="d695" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">使用介子缠绕依赖关系</strong></p><p id="bc19" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">介子包是一个包依赖系统(像柯南)。它有一个依赖项集合，并且它与Meson配合得非常好，因为它是在源代码级别集成的。顺便说一下，你也可以通过pkg-config使用Conan和介子。</p><p id="560d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Meson wrap的优势在于，如果包可用，它将与项目中发布的编译标志很好地集成。它还可以与Meson的子项目特性很好地集成，在Meson中，它更喜欢系统提供的库，如果没有安装依赖项，就可以回退到子项目。</p><p id="e1fa" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">反正我就是这么做的。可以在subprojects/目录下的Meson中安装子项目。您只需要创建该文件夹，并执行以下操作:</p><figure class="my mz na nb gt nc"><div class="bz fp l di"><div class="nq ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">通过介子包安装子项目</figcaption></figure><p id="9317" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果您想获得有关可用包装的更多信息:</p><figure class="my mz na nb gt nc"><div class="bz fp l di"><div class="nq ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">获得带有介子包的catch2包的可用版本</figcaption></figure><p id="833a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我用的是C++20，但用的是gcc 9。不幸的是，在这个gcc版本中还没有<code class="fe mu mv mw mx b">std::span</code>。我又用meson wrap装了微软-gsl，有一个<code class="fe mu mv mw mx b">std::span</code>兼容的版本。</p><p id="6742" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在引用了Meson中的依赖关系之后，我可以开始编写测试代码了。</p><p id="051c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我所要做的就是在<code class="fe mu mv mw mx b">src/TestDecoding.cpp</code>中添加代码并运行测试。我使用一个快捷键<code class="fe mu mv mw mx b">Control-c c P</code></p><p id="55e5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Catch2的迭代时间有点糟糕，因为编译时间很慢。您可以使用doctest作为替代。但就我而言，我拆分了编译。</p><p id="6aca" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以在我将在本文末尾链接的存储库中看到最终的解决方案。基本上，我将Catch的主函数分离到一个TestMain.cpp中，迭代时间提高了很多。我没有等待6-7秒来编译，而是等待了1秒(大约，没有测量)。</p><p id="adf9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在Emacs中，您可以通过<code class="fe mu mv mw mx b">Control-p c c </code>编译和<code class="fe mu mv mw mx b">Control-p c P</code>测试，轻松发布编译或测试命令。您还可以在Doom Emacs中使用更多面向Vim的命令(默认)。但是我使用面向Emacs的快捷方式，因为这是我从小到大的习惯:)。</p><p id="5b8d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">第一次执行快捷方式时，它会要求您输入命令。在我的例子中，我添加了一次meson test -v，这样做是为了测试，它会自动重新编译代码。现在，工作流变成了类似于变更测试、按快捷键并运行的东西。</p><p id="2a64" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我的TDD相当于转换文本块，然后在预先保存在文件中的base85有效载荷的帮助下解码一个流。</p><p id="48e8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在这一点上，工作流非常快速和高效，对于我的目的来说绰绰有余。Emacs中的代码补全工作得很好，引用的镜头很准确，我可以进行重命名重构、查找引用、搜索文本(如果我需要的话)等等。没有痛苦。与以前相比，这方面的情况已经有了很大的改善，考虑到这都是自由软件，而不是专有的付费解决方案。</p><p id="cb7e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">一旦所有的TDD迭代都完成了，测试也通过了，我将测试的内容拆分到tests/目录中，并在src/中的一个独立的库中使用它自己的库。</p><p id="88df" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我可以通过Git中的<code class="fe mu mv mw mx b">Control-x g </code>保存我的工作，它显示了伟大的<a class="ae lr" href="https://magit.vc/" rel="noopener ugc nofollow" target="_blank"> Magit </a>界面。这个界面可以让你以一种简单(但非常emacs-y)的方式保存文件或推送文件，这是我多年来每次使用emacs时一直使用的。</p><p id="90c7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">一旦我有了适当的测试+一个库，我就添加了一个基准，也就是基线。介子支持添加基准。基准测试只需要一个有效载荷，添加它是小菜一碟，基本上和测试一样。Meson会注意不要让测试并行运行，就像对待测试一样。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="1fee" class="jq jr it bd js jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn bi translated">结论</h1><h1 id="2b86" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">项目设置</h1><p id="b628" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Linux下设置emacs没什么大不了的。你只需要通过apt从你的软件包管理器安装它，然后你就可以得到<a class="ae lr" href="https://github.com/hlissner/doom-emacs" rel="noopener ugc nofollow" target="_blank"> Doom Emacs </a>并按照说明进行操作。</p><p id="6e1f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">与使用Visual Studio或CLion等环境相比，设置lsp模式并不是最容易的。你必须设置一些配置。幸运的是，Doom Emacs比一些替代产品更友好，在启动时会显示以下屏幕:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nr"><img src="../Images/0ce464485c6ec3583aba481f8828d80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VChtgYv-FaTbhr_bm3IOw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">Doom Emacs启动屏幕</figcaption></figure><p id="1ad4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您必须打开init.el的私有配置并取消注释“(cc +lsp)”。如果您想要lsp镜头模式，您必须自己在config.el中添加它。我添加了这两行，因为我也启动了emacs最大化:</p><pre class="my mz na nb gt ns mx nt nu aw nv bi"><span id="8188" class="nw jr it mx b gy nx ny l nz oa">(toggle-frame-maximized)<br/>(add-hook! ‘lsp-mode-hook ‘lsp-lens-mode)</span></pre><p id="9045" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你需要介子，所以需要通过做python3 -m pip安装介子来通过pip安装。你还需要<code class="fe mu mv mw mx b">sudo apt install ninja-build</code></p><p id="3f67" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你不应该忘记让ccl运行lsp特性。有了这个，你应该可以走了。Projectile允许你浏览文件，查找文本，使用lsp你可以跳转到声明，查找引用，高亮显示文件中光标下的变量，等等。很容易通过一些键绑定或右键上下文菜单。</p><h1 id="0a22" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">开发人员工作流程</h1><p id="1c33" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">环境一旦搭建好，工作流程又快又好。Emacs有了很大的改进:您可以拥有精确的代码完成、语义导航、重命名，甚至右键单击并根据上下文发现所有这些选项:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ob"><img src="../Images/a6ed62783b68c9a370a6298ab30d777b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCV3X_eIocY8RX2MMnARWA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">用于导航的上下文菜单、相同变量的高亮显示、通过Emacs中的投射体和参考透镜运行的测试结果</figcaption></figure><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oc"><img src="../Images/e63e600919877c4892cdb85510aea223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-2_XLE8YNuu5G6fn6yIyg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">代码完成，甚至通过compile_commands.json和lsp实现外部依赖</figcaption></figure><p id="aa19" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我唯一怀念的是某种执行测试面板，就像你在Visual Studio Code或CLion中可以找到的那种，它可以让你以一种非常直观的方式通过右键单击来轻松地、分层地执行测试。</p><h1 id="16de" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">迭代时间</h1><p id="a697" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是关于Catch2编译时间的第一个难点。一旦解决了，就很好了。C++中的编译时间有望通过模块得到改善，但有时您需要一些缓解措施。在我的例子中，为Catch使用一个单独的主文件是解决方案，而且效果很好。</p><h1 id="1b48" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">C++现代化</h1><p id="a00e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些年来，C++已经有了很大的进步。当我在2002年开始时，C++98没有lambdas、基于范围的for循环、移动语义、默认成员函数、智能指针(尽管Boost在C++11之前就有了)、复制省略、变量模板或概念。</p><p id="e843" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">但是我必须特别提到<code class="fe mu mv mw mx b">std::span</code>(实际上我在自己的代码中使用了<code class="fe mu mv mw mx b">gsl::span</code>)。这门课非常非常有用，我不知道为什么以前没有这门课。C++特性和算法(如<code class="fe mu mv mw mx b">std::copy</code>和<code class="fe mu mv mw mx b">std::remove_if</code>)的正确组合让我能够以一种方式编码解码器，与我自己所能做的相比，我确信它是合理有效的，并且非常可用(例如通过lambdas来实现谓词)。然而，我仍然怀念语言中的某种缩写lambdas。</p><p id="5f44" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">算法从琐碎性检测和其他优化到执行策略或使用范围的并行化能力(虽然在我的实现中没有使用)。这些年来，C++在可用性和效率方面有了很大的提高。</p><p id="47a8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以超越我对这段代码所做的，但我只是触及了皮毛。例如，多线程实现和使用协程可以解决这个问题。</p><p id="59e5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，模块、协程、概念和范围等即将到来，我等不及了。越来越好的一点是，将许多这些特性与智能指针、跨度和其他特性结合起来，高效地编码，几乎达到应用程序级别，似乎比以往任何时候都更加可行。</p><p id="b41b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当然，这是C++，你将不得不考虑可复制性，切片和其他一些事情。但是现在已经好多了。</p><h1 id="e770" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">新一代构建工具</h1><p id="aca2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我选择介子，因为这是我所习惯的，并尝试了CMake。Meson集成了一个包管理器，它比诸如Autotools之类的东西更容易理解，而且它可以移植到Windows，所以协作起来也更容易。</p><p id="b4f9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">总而言之，诸如CMake(尽管我在许多方面都讨厌它)和Meson之类的东西这些年来已经在这方面改进了很多。还有很多事情要做。模块在这里应该有所帮助，但是要考虑到C++在当前的实现中是一种本地编译的语言。这给包管理器之类的东西带来了困难。</p><p id="2980" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如今，使用我编写的少量Meson build系统代码，您可以通过许多不同的方式(调试、发布、净化、valgrind、基准、静态与动态msvc运行时、生成静态或共享库等等)获得基准、测试、依赖管理和编译，只需少量非常小且可读的文件，全部都是可移植的。</p><p id="3347" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以为Visual Studio、ninja和其他应用程序生成项目，并生成compile_commands.json文件，用于与代码完成框架集成。这绝对比我刚开始编码的时候超前了好几光年。</p><h1 id="c04f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">其他人进一步参与协作的难易程度如何？</h1><p id="fe01" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们有Github来建立项目和发布。我在本文中跳过了这个设置，因为它是最后一步。</p><p id="fc31" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Github的协作工作流非常有名(fork，pull-request workflow)。这与Meson等新一代工具相结合，使得协作比过去容易得多。您可以在Windows的Visual Studio中使用您的项目，就像我在Linux中使用Emacs设置一样，我展示了完全相同的源代码树。</p><p id="b935" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果您倾向于使用compile_commands.json文件作为项目文件(并在添加了几个用于构建/调试的脚本之后),您也可以使用CLion，并获得CLion为您提供的完整重构框架，运行和调试代码，并在相同的环境下在Linux、Windows和Mac之间保持可移植性(我自己在另一个项目中尝试了这一点)。测试面板也提前运行您想要的测试，这是我在Emacs中所没有的。</p><p id="d968" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">毫无疑问，事情已经有了很大的改善，尽管我想念ide的直接介子集成。截至目前，<code class="fe mu mv mw mx b">compile_commands.json</code>加一点胶水或者配置给出了非常好的效果。我认为CMake现在在IDE集成领域领先，但是我不能回头，因为当我必须添加东西来构建脚本时，我发现Meson要好得多。</p><h1 id="8629" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">代码导航和重构</h1><p id="d846" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">代码导航在lsp和后端(如cquery、ccls和clangd)方面迈出了一大步。我一直在使用ccl进行设置。以前，除了脆弱的文本替换之外，重命名是不可行的。</p><p id="7c48" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，您至少可以从Emacs内部进行语义重命名、导航到引用、查找函数的覆盖、基派生类等等。</p><p id="23c1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">CLion提供了同类最佳的重构，尽管我没有完全尝试过这个特性。</p><p id="46ae" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">总的来说，这种体验看起来很有成效，但不如Java或C#商业ide那么完美。但是与我开始编码的时候相比，事情一直在稳步改善，尤其是最近5年左右。</p><h1 id="b917" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">最后的话</h1><p id="51a3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">总的来说，这种体验是积极的。在使用Visual Studio + Resharper开发C#之后，ide仍然不能与最好的C#或Java IDEs相提并论，但比几年前更接近了。例如，在C#中，很容易使用(相当于#includes more或more or less)来删除未使用的代码，并且代码生成是高质量的。</p><p id="9217" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">但总的来说，我认为你可以用我的设置和其他一些接近最佳环境的类似设置获得一个专业的生产环境，这样你就可以考虑用C++编写代码，即使是现在的应用程序编程，如果你寻求的是高效的高运行时间。</p><p id="1a5a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果您想在开发环境设置方面实现跨平台，我建议您考虑CLion许可。它不贵，而且效果很好。我肯定会在某个时候购买它。但是对于纯Linux环境或纯Windows环境，我认为使用Visual Studio甚至Emacs对于专业需求来说已经足够了。</p><p id="6a2b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你可以在这里找到Github项目<a class="ae lr" href="https://github.com/germandiagogomez/onionbase85" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e3a8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">感谢阅读！</p></div></div>    
</body>
</html>