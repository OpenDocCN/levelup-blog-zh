<html>
<head>
<title>WebSockets Demystified, Part 2: Building a Chat Application with React and Node.js — and Without Socket.IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSockets非神秘化，第2部分:使用React和Node.js构建聊天应用程序——不使用Socket。超正析象管(Image Orthicon)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/websockets-demystified-part-2-building-a-chat-application-with-react-and-node-js-a52e0b7accf8?source=collection_archive---------1-----------------------#2021-07-30">https://levelup.gitconnected.com/websockets-demystified-part-2-building-a-chat-application-with-react-and-node-js-a52e0b7accf8?source=collection_archive---------1-----------------------#2021-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9075" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们不要屈服于其他库提供的抽象</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5961e0b76a7d828088a9dce1e8d67d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QOdtpgHFYbUowFMHlZF6w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">安妮·斯普拉特在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个简短系列的<a class="ae kv" href="https://medium.com/p/fccca2ca75eb" rel="noopener">第1部分中，我们深入了解了WebSocket在web socket连接的整个生命周期中的工作方式。现在，我们将使用React和Node.js构建一个简单的聊天室应用程序，只需添加一些附加功能，就可以充分利用WebSocket协议提供的特性。</a></p><h1 id="2c7f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先决条件</h1><p id="424b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">本教程适用于大多数人，但不是所有人——但是如果你点击了这篇文章，你就满足了所有的要求。要构建此应用程序，您需要</p><ul class=""><li id="0b48" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">良好的HTML和JS知识，</li><li id="e9fa" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">React和Node.js的一些经验，以及</li><li id="91f4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">对WebSocket连接生命周期的深刻理解(我们在第1部分中讨论过)。</li></ul><p id="6d9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，如果你有使用像Webpack这样的工具链的经验，还有额外的好处——在本教程中我们将使用Vite，但是我已经设置好了。</p><h1 id="91b1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">首先:搭建应用程序</h1><p id="17b1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了简洁起见，我将避免描述启动和运行我们的项目所需的所有无聊的设置步骤:我们将从一个样板文件开始，您可以通过运行</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="e8d4" class="ni lt iq ne b gy nj nk l nl nm">npx degit https://github.com/DamianoMagrini/websocket-chat-room-boilerplate.git websocket-chat-room</span></pre><p id="bd80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这会创建一个带有两个子目录的<code class="fe nn no np ne b">websocket-chat-room</code>文件夹:</p><ul class=""><li id="92a4" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe nn no np ne b">client</code>，我已经用Vite构建工具建立了一个React应用程序，并用React路由器连接了一些页面</li><li id="8924" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nn no np ne b">server</code>，它包含一个非常简单的Node.js应用程序，安装了<code class="fe nn no np ne b">ws</code>依赖项和一个导入它的<code class="fe nn no np ne b">main.js</code>文件。</li></ul><p id="3519" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过构建这两个样板，我们将有机会在客户端和服务器端实践WebSocket。先从后者说起吧！然而，在开始之前，您应该运行<code class="fe nn no np ne b">client</code>和<code class="fe nn no np ne b">server</code>目录中的<code class="fe nn no np ne b">npm install</code>(或<code class="fe nn no np ne b">yarn</code>)。</p><h1 id="68ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实现服务器</h1><h1 id="d406" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们将会建造什么</h1><p id="bf9a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在进入实际代码之前，让我们概述一下我们的行动过程:</p><ol class=""><li id="e853" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nr mv mw mx bi translated">首先，我们将启动一个服务器来监听HTTP/1.1连接，并能够将它们<code class="fe nn no np ne b">Upgrade</code>到web sockets——虽然这听起来可能很复杂，但由于有了<code class="fe nn no np ne b">ws</code>库，这实际上是一个单行程序。</li><li id="b2b4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">然后，每次启动一个新的WebSocket连接时，服务器应该存储一个对用户套接字的引用，并将其添加到一个打开的套接字的<code class="fe nn no np ne b">Set</code>(对应于当前连接的用户)。</li><li id="7633" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">每当服务器接收到来自一个套接字/用户的消息时，它应该将它们发送给每个套接字/用户。</li><li id="1cb9" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">最后，当一个套接字关闭时，服务器应该从<code class="fe nn no np ne b">Set</code>中删除它的引用(不这样做将导致内存泄漏)。</li></ol><h1 id="9051" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码</h1><p id="09f2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们现在可以直接进入代码了！在运行了<code class="fe nn no np ne b">server</code>目录中的<code class="fe nn no np ne b">npm install</code>(或<code class="fe nn no np ne b">yarn</code>)之后，让我们打开<code class="fe nn no np ne b">lib/main.js</code>，在这里，正如您将看到的，<code class="fe nn no np ne b">ws</code>包已经被<code class="fe nn no np ne b">require</code> d了。在这里，我们可以通过键入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="62f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这行代码将启动一个WebSocket服务器，该服务器接受端口<code class="fe nn no np ne b">8081</code>上的连接(<code class="fe nn no np ne b">8080</code>也是一个合理的选择，但这恰好是我们的客户端应用程序的默认端口)。如果我们想在服务器启动时得到通知，我们还可以包括一个回调，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="365e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我们的服务器是相对无用的:除了处理打开和关闭握手之外，它不会对它接收到的连接做任何事情。让我们通过监听新的WebSocket连接来解决这个问题——同时让我们初始化用户的<code class="fe nn no np ne b">Set</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次初始化新的WebSocket连接时，<code class="fe nn no np ne b">server.on</code>中的代码都会运行。这段代码目前做两件事:</p><ul class=""><li id="10fd" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">它将两个(当前为空)事件侦听器附加到每个新套接字，并且</li><li id="2f74" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">它创建一个<code class="fe nn no np ne b">userRef</code>对象，并将其添加到<code class="fe nn no np ne b">users</code>集合中(我们将使用它来存储关于每个用户的一些额外数据——但是现在，它只包含一个对套接字的引用)。</li></ul><p id="f5e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于<code class="fe nn no np ne b">close</code>监听器，这很简单:当用户断开连接时，我们将从集合中删除他们的<code class="fe nn no np ne b">userRef</code>。因此，我们的代码变成了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f160" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想知道为什么我使用了一个<code class="fe nn no np ne b">Set</code>而不是一个<code class="fe nn no np ne b">Array</code>，这个片段可能会让您更清楚:<code class="fe nn no np ne b">Set</code> s允许您通过值来删除(因此我们可以简单地将<code class="fe nn no np ne b">userRef</code>传递给<code class="fe nn no np ne b">delete</code>方法)，而<code class="fe nn no np ne b">Array</code> s要求您提供一个索引(使用<code class="fe nn no np ne b">Array</code>，我们将需要编写<code class="fe nn no np ne b">users.splice(users.indexOf(userRef))</code>，更冗长且性能更差)。</p><p id="1c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在这一点上，剩下要做的就是实现接收和转发消息的逻辑。让我们从编写一个基本的<code class="fe nn no np ne b">sendMessage</code>函数开始，该函数遍历每个用户并向他们发送消息。(记住WebSockets只能传输文本或二进制数据，所以JS对象需要被字符串化。你可能会问，“消息不是已经是字符串了吗？”是和否—对于我们的目的，每条消息将有三个属性:发送它的用户的姓名、消息的正文和发送它的时间。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="11d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们编写负责处理每个用户发送的消息的逻辑。但首先，让我们来分解一下我们希望发生的事情:</p><ol class=""><li id="a402" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nr mv mw mx bi translated">用户发送一条JSON消息，它有两个属性:<code class="fe nn no np ne b">sender</code>(用户名)和<code class="fe nn no np ne b">body</code>(消息体)。两者都必须是字符串，否则消息无效。</li><li id="539b" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">服务器确保它刚刚收到的消息是有效的JSON，并试图解析它。如果它不是有效的JSON，服务器<code class="fe nn no np ne b">catch</code>会接收<code class="fe nn no np ne b">JSON.parse</code>抛出的错误，并在控制台记录一个错误。</li><li id="4b3e" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">服务器还确保<code class="fe nn no np ne b">sender</code>和<code class="fe nn no np ne b">body</code>属性都是字符串。如果不是，它会在控制台记录一个错误并暂停(它不会将消息转发到聊天室)。</li><li id="e99b" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">最后，如果所有其他步骤都成功，服务器将消息发送给所有用户(使用我们上面定义的<code class="fe nn no np ne b">sendMessage</code>函数)，将其<code class="fe nn no np ne b">sentAt</code>设置为<code class="fe nn no np ne b">Date.now()</code>(发送消息的时间戳)。</li></ol><p id="99cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相应的代码将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="27b8" class="ni lt iq bd lu nu nv dn ly nw nx dp mc lf ny nz me lj oa ob mg ln oc od mi oe bi translated">额外功能:踢不活跃的用户和洪水</h2><p id="d692" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们首先创建一个简单的系统来踢不活动的用户，即那些在过去5分钟(300秒，或300，000毫秒)内没有发送消息的用户。我们将向<code class="fe nn no np ne b">userRef</code>对象添加一个<code class="fe nn no np ne b">lastActiveAt</code>属性，并在用户成功发送消息时更新它(在<code class="fe nn no np ne b">try</code>块的末尾)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4fcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管，不可否认，这不是一个很好的实践，我们将使用一个全局<code class="fe nn no np ne b">setInterval</code>来周期性地踢不活动的用户(每10秒)。怎么会？就像关闭连接一样简单！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="61b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们还指定了</p><ul class=""><li id="c1a9" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">close代码(这是任意的:为了一致，每次我们踢用户——不管什么原因——我们将使用代码<code class="fe nn no np ne b">4000</code>；一般来说，该代码的范围可以从<code class="fe nn no np ne b">4000</code>到<code class="fe nn no np ne b">4999</code>，而所有其他值都被保留)和</li><li id="3404" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">关闭连接的原因(“不活动”)，</li></ul><p id="283f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两者稍后都会派上用场。</p><p id="2fbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，是时候踢那些泛滥聊天的用户了！👢这样做的逻辑很简单:用户被允许每分钟最多发送30条消息，如果他们在过去60秒内发送的消息数量超过这个限制，就会因为淹没聊天而被踢。我们将分三步实施:</p><p id="1f81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.我们首先创建一个全局<code class="fe nn no np ne b">recentMessages</code>数组，在其中我们将存储过去60秒内发送的所有消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5e46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.每当用户成功发送一条消息时(同样，在<code class="fe nn no np ne b">try</code>块的末尾)，我们将其添加到数组中，并开始超时，60秒后，将从数组中删除该消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们在调用<code class="fe nn no np ne b">sendMessage</code>之前增加了另一项检查:用户发送的<code class="fe nn no np ne b">recentMessages</code>的数量(即那些<code class="fe nn no np ne b">sender</code>属性等于用户提供的属性)还不大于30。如果是，我们只是踢用户，再次提供</p><ul class=""><li id="71bd" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">关闭代码<code class="fe nn no np ne b">4000</code>(与之前相同，表示用户被踢)和</li><li id="a86d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">原因“泛滥聊天”。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们的后端！概括地说，我们构建了一个服务器，它</p><ul class=""><li id="67f2" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">处理WebSocket握手(将HTTP/1.1连接转换为WebSocket连接)，</li><li id="b975" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">存储当前连接的所有用户的记录，</li><li id="7927" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">监听来自每个用户的消息并将它们转发给每个人，并且</li><li id="8dfa" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">踢不活跃的用户和那些一直充斥着聊天。</li></ul><p id="8bd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们得到的最终代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="768c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以开始处理客户端了。</p><h1 id="aa4a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实现客户端</h1><p id="bba5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">像以前一样，让我们从概述我们将构建的内容开始:</p><ul class=""><li id="27e5" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">一个身份验证页面，用户可以在其中输入他们的姓名；</li><li id="8d88" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">聊天页面，允许用户发送和接收消息；</li><li id="59f5" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">一个“被踢”的页面，通知用户他们被踢出了聊天，并提供一些关于为什么会这样的附加信息(它将利用前面的关闭代码和原因)。</li></ul><p id="dba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经编写了页面的CSS并用React Router将它们连接起来，所以我们将跳过这一部分。</p><h2 id="8c5a" class="ni lt iq bd lu nu nv dn ly nw nx dp mc lf ny nz me lj oa ob mg ln oc od mi oe bi translated">授权页面</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/bfb97892f92a6506cca855800d7af7bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*G-N_yJ7_NH7Qa54K6WEYKg.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们将会建造什么</figcaption></figure><p id="9e5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们打开<code class="fe nn no np ne b">client/src/pages</code>中的<code class="fe nn no np ne b">AuthPage.jsx</code>文件。正如你所看到的，页面的一部分已经被写好了(T2钩子提供了一个T3函数，可以用来在React路由器的路由之间移动)。在<code class="fe nn no np ne b">&lt;main&gt;</code>元素内部，让我们搭建页面的静态内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="500f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会注意到我在这里和那里使用了一些奇怪的类名:它们只是为了设计应用程序的样式，使它看起来更好一些——如果你想调整样式或者只是好奇，请随意查看<code class="fe nn no np ne b">src/index.scss</code>内部！</p><p id="9db2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使用<code class="fe nn no np ne b">useState</code>创建一个<code class="fe nn no np ne b">name</code>状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="457f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，让我们通过添加几个属性将其值绑定到<code class="fe nn no np ne b">&lt;input&gt;</code>元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a209" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们创建一个<code class="fe nn no np ne b">onSubmit</code>函数，该函数(只要名称不为空)会将用户路由到聊天室页面...</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…让我们在点击按钮或用户按下<code class="fe nn no np ne b"><br/> Enter</code>键时运行此功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="cc79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括一下，这是这个页面的完整代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="f8da" class="ni lt iq bd lu nu nv dn ly nw nx dp mc lf ny nz me lj oa ob mg ln oc od mi oe bi translated">聊天页面</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5faf564be60198419bbc4cf21eeafb7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/1*v5e2delUgY-eDVnL6HggWw.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们将会建造什么</figcaption></figure><p id="b767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们应用程序的核心，在这里我们打开、交互和关闭WebSocket连接。如果你打开<code class="fe nn no np ne b">src/pages/ChatPage.jsx</code>，你可能会注意到我已经包含了一个<code class="fe nn no np ne b">sendIcon</code>元素，我们稍后会用到它。但是首先，让我们通过创建一个标题、一个聊天容器和一个用于消息输入字段的容器来搭建页面:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7a09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这可能看起来很多，但我们所做的只是创建静态元素:标题、聊天容器和允许用户键入和发送消息的元素。</p><p id="d6db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在屏幕上显示信息</strong></p><p id="0757" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在发送和接收消息之前，让我们编写一些逻辑来将它们显示在屏幕上:我们将创建一个<code class="fe nn no np ne b">messages</code>状态(一个消息数组，每个消息都有<code class="fe nn no np ne b">sender</code>、<code class="fe nn no np ne b">body</code>和<code class="fe nn no np ne b">sentAt</code>属性)，然后将每个消息映射到我们的<code class="fe nn no np ne b">chat-view-container</code>中的一个元素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果消息是由当前用户发送的(即，如果<code class="fe nn no np ne b">message.sender === name</code>)，其显示应该略有不同。特别是，</p><ol class=""><li id="d54e" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nr mv mw mx bi translated">消息容器应该有不同的背景，应该向右刷新而不是向左(<code class="fe nn no np ne b">.own-message</code>类负责这一点)</li><li id="d559" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">它应该显示“您”，而不是显示发件人的姓名。</li></ol><p id="1c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们实现这些变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2cd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">接收消息</strong></p><p id="6e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">WebSockets时代到了！让我们在安装了<code class="fe nn no np ne b">ChatPage</code>组件时建立一个WebSocket连接——我们将使用一个<code class="fe nn no np ne b">useEffect</code>钩子来启动连接，并使用一个<code class="fe nn no np ne b">useRef</code>钩子来保存对它的引用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d481" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这段代码将连接到<code class="fe nn no np ne b">localhost</code>的端口<code class="fe nn no np ne b">8081</code>(您可能还记得，我们的服务器就在这里)，但它不做任何其他事情。让我们添加两个侦听器:</p><ul class=""><li id="a27b" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">一个<code class="fe nn no np ne b">onmessage</code>监听器，在这里我们将向<code class="fe nn no np ne b">messages</code>数组追加新消息；</li><li id="da8c" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">一个<code class="fe nn no np ne b">onclose</code>监听器，我们将检测用户是否被踢(在这种情况下，关闭代码将是<code class="fe nn no np ne b">4000</code>)，如果是，将他们重定向到“被踢”的页面，包括React路由器的状态中被踢的原因。</li></ul><p id="4ab7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是它在代码中的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fbd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们没有包括<code class="fe nn no np ne b">try</code> / <code class="fe nn no np ne b">catch</code>块，因为我们可以相信服务器只会发送有效的JSON。最后，让我们添加一些清理代码，以便在用户离开页面时关闭连接:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ca49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们已经将<code class="fe nn no np ne b">messages</code>数组与用户将在屏幕上看到的内容连接起来，所以我们没有更多工作要做。</p><p id="447d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">发送信息</strong></p><p id="186b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经设置了<code class="fe nn no np ne b">message-input-container</code>，所以现在我们需要让它具有交互性。让我们创建一个<code class="fe nn no np ne b">messageBody</code>状态，并将其值绑定到<code class="fe nn no np ne b">&lt;input&gt;</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d5c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们编写一个<code class="fe nn no np ne b">send</code>函数</p><ol class=""><li id="1c3a" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nr mv mw mx bi translated">确保消息正文不为空，</li><li id="6256" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">发送消息，然后</li><li id="7456" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">清除输入内容。</li></ol><p id="67f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把它连接到<code class="fe nn no np ne b">&lt;input&gt;</code>和<code class="fe nn no np ne b">&lt;button&gt;</code>，就像我们在auth页面中做的那样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c738" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们添加一些收尾工作。</p><p id="be17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">禁用按钮，直到连接打开</strong></p><p id="ff50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户在特别慢的网络上，WebSocket连接可能需要一些额外的时间来打开——为了确保在连接打开之前没有消息被发送，我们可以禁用该按钮。这很容易做到:我们会的</p><ol class=""><li id="b1e4" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nr mv mw mx bi translated">创建默认为<code class="fe nn no np ne b">false</code>的<code class="fe nn no np ne b">isConnectionOpen</code>状态，</li><li id="f8ef" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">如果<code class="fe nn no np ne b">isConnectionOpen</code>为<code class="fe nn no np ne b">false</code>，禁用该按钮</li><li id="c0ef" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nr mv mw mx bi translated">一旦连接打开，就将状态设置为true。</li></ol><p id="2207" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码中，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="29bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">滚动到最后一条消息</strong></p><p id="5332" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是这一页的最后一步，我保证。每当接收到新消息并将其添加到<code class="fe nn no np ne b">messages</code>数组中时(这相当于说，“每当<code class="fe nn no np ne b">messages</code>数组的长度改变时”)，我们将滚动到聊天容器的底部，显示新消息。这很容易做到:我们只需要在聊天容器的最底部添加一个占位符<code class="fe nn no np ne b">&lt;div&gt;</code>，每当<code class="fe nn no np ne b">messages.length</code>发生变化时就滚动到视图中(我们将用一个<code class="fe nn no np ne b">useEffect</code>钩子来实现)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c51e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是聊天页面——唷！😅让我们回顾一下我们编写的整个代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b3a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一次努力！让我们创建“被踢”的页面。</p><h2 id="d09a" class="ni lt iq bd lu nu nv dn ly nw nx dp mc lf ny nz me lj oa ob mg ln oc od mi oe bi translated">“被踢”的一页</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a4fb5a02cbf5b16d1e2ae14ab8ca115d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*kBvRySNEwd2piiqqCp-kJg.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们将会建造什么</figcaption></figure><p id="a992" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个页面在结构上与auth页面非常相似，都有一个标题、一个副标题和一个返回主页的按钮(这里没有输入——简单多了！).您可能还记得，我们将被踢的原因作为这条路由的状态进行了传递:在第6行(<code class="fe nn no np ne b">const { state } = useLocation()</code>)我们检索了这个状态。在<code class="fe nn no np ne b">&lt;main&gt;</code>元素内部，让我们模拟一下auth页面的结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="36f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">搞定了。👌为了方便起见，下面是完整的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="6017" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">把所有的放在一起</h1><p id="3dd6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们现在可以打开两个终端窗口，一个在<code class="fe nn no np ne b">server</code>目录，一个在<code class="fe nn no np ne b">client</code>目录。在服务器目录中，我们可以运行<code class="fe nn no np ne b">npm start</code>或<code class="fe nn no np ne b">yarn start</code>来启动服务器；另一个中，<code class="fe nn no np ne b">npm run dev</code> / <code class="fe nn no np ne b">yarn dev</code>会启动开发服务器，打开app。玩弄它！打开多个窗口，输入愚蠢的用户名，等待被踢或淹没聊天——世界是你的牡蛎。一旦您觉得已经准备好构建应用程序，您可以通过运行<code class="fe nn no np ne b">client</code>目录中的<code class="fe nn no np ne b">npm run build</code> / <code class="fe nn no np ne b">yarn build</code>来完成(服务器可以按原样运行)。</p><h1 id="8806" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">总结:我们学到并应用的东西</h1><p id="e17f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了巩固我们的知识，让我们回顾一下我们在这个由两部分组成的系列中所学的概念:</p><ul class=""><li id="7ee0" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">我们研究了WebSocket协议的内部工作和生命周期。</li><li id="4799" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用Node.js和<code class="fe nn no np ne b">ws</code>，我们建立了一个WebSocket服务器，将每个用户的消息转发给所有用户，踢走不活跃的用户和那些淹没聊天的用户。</li><li id="dfc7" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用React和原生的<code class="fe nn no np ne b">WebSocket</code> API，我们为我们的应用程序编写了一个WebSocket客户端，它处理消息交换和发送。</li></ul><p id="cdf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你觉得你掌握了所有这些概念吗？如果是这样的话，我全心全意鼓励你去实践，自己打造一些东西去实践。如果有不清楚的地方，请告诉我——我很乐意与您联系并提供帮助！</p></div></div>    
</body>
</html>