<html>
<head>
<title>Update file content with golang and regexp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用golang和regexp更新文件内容</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/update-file-content-with-golang-and-regexp-2f031891f713?source=collection_archive---------17-----------------------#2022-05-23">https://levelup.gitconnected.com/update-file-content-with-golang-and-regexp-2f031891f713?source=collection_archive---------17-----------------------#2022-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7221" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我在我们的一个项目中更改了i18n解决方案，我需要更改数百个文件，我尝试手动更新文件，但这太耗时了。所以我考虑写一个程序自动更新文件。</p><p id="d352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的项目是我写的更新文件，我添加了一些演示文件来演示这个程序做什么。演示文件在<code class="fe kl km kn ko b">demodata</code>文件夹中，在这个文件夹中，我放了一些演示文件，包括<code class="fe kl km kn ko b">java</code>、<code class="fe kl km kn ko b">kotlin</code>、<code class="fe kl km kn ko b">objc</code>和<code class="fe kl km kn ko b">swift</code>文件，演示如何将文件从<code class="fe kl km kn ko b">StringProvider</code>更新到<code class="fe kl km kn ko b">StringVaues</code>。</p><div class="kp kq gp gr kr ks"><a href="https://github.com/swanwish/fileupdater" rel="noopener  ugc nofollow" target="_blank"><div class="kt ab fo"><div class="ku ab kv cl cj kw"><h2 class="bd ir gy z fp kx fr fs ky fu fw ip bi translated">GitHub - swanwish/fileupdater:一个用golang写的工具，可以用regexp和…</h2><div class="kz l"><h3 class="bd b gy z fp kx fr fs ky fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="la l"><p class="bd b dl z fp kx fr fs ky fu fw dk translated">github.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg lh ks"/></div></div></a></div><h1 id="415a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题</h1><p id="bb80" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">在这个演示中，以java文件为例，原始内容如下:</p><pre class="ml mm mn mo gt mp ko mq mr aw ms bi"><span id="adab" class="mt lj iq ko b gy mu mv l mw mx">String value1 = StringProvider.getValue("key1", "default value 1");<br/>String value2 = StringProvider.getValue("key2", "default value 2");<br/>String value3 = isAdd ? StringProvider.getValue("key3", "default value 3") : StringProvider.getValue("key4","default value 4");<br/>String value4 = StringProvider.getValue("key5",<br/>                "default value 5");</span></pre><p id="63fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码调用StringProvider的方法根据一个键获取值，我想改成另一个类，这个类的变量名为key name，比如<code class="fe kl km kn ko b">StringValues.key1</code>。源代码有多种格式，有的逗号后面没有空格，有的多行。我需要搜索它们并用新方法替换它们。</p><h1 id="35cc" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解决办法</h1><p id="0dcd" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我创建的项目，它可以注册更新规则，应用程序将使用规则搜索文本，并根据规则替换文本。</p><h2 id="b968" class="mt lj iq bd lk my mz dn lo na nb dp ls jy nc nd lw kc ne nf ma kg ng nh me ni bi translated">更新规则</h2><p id="8c33" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">更新规则可以配置文件扩展名、正则表达式模式和匹配替换符。</p><p id="3700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新规则的结构如下所示:</p><pre class="ml mm mn mo gt mp ko mq mr aw ms bi"><span id="9f3f" class="mt lj iq ko b gy mu mv l mw mx">type UpdateRule struct {<br/> Exts             []string<br/> Pattern          string<br/> GetMatchReplacer func(match []string) *string<br/>}</span></pre><p id="3365" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序将搜索规则中配置了扩展名的文件，并搜索规则中带有模式的文本，模式是regexp模式，<code class="fe kl km kn ko b">GetMatchReplacer</code>有匹配参数，从regexp中获取，并将替换字符串返回给应用程序，如果返回值为nil，则文本不会被替换，当返回值不为nil时，它将被用作目标。</p><h2 id="d8fd" class="mt lj iq bd lk my mz dn lo na nb dp ls jy nc nd lw kc ne nf ma kg ng nh me ni bi translated">列出目录中的文件</h2><p id="93da" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">List file将在search dir中搜索文件，它将检查文件的扩展名，添加返回匹配的文件，这个函数是一个递归函数，如果文件夹中的项是dir，那么将用sub dir再次调用这个函数。下面的代码是函数的实现。</p><pre class="ml mm mn mo gt mp ko mq mr aw ms bi"><span id="dc37" class="mt lj iq ko b gy mu mv l mw mx">func (updater fileUpdater) listFiles(searchDir string) []string {<br/> items, err := ioutil.ReadDir(searchDir)<br/> if err != nil {<br/>  logs.Errorf("Failed to get items from dir %s, the error is %#v", searchDir, err)<br/>  return nil<br/> }</span><span id="7f63" class="mt lj iq ko b gy nj mv l mw mx">files := make([]string, 0)<br/> for _, item := range items {<br/>  itemName := item.Name()<br/>  subDir := filepath.Join(searchDir, itemName)<br/>  if item.IsDir() {<br/>   subFiles := updater.listFiles(subDir)<br/>   if err != nil {<br/>    logs.Errorf("Failed to get sub file, the error is %#v", err)<br/>    return nil<br/>   }<br/>   files = append(files, subFiles...)<br/>  } else {<br/>   fileExt := path.Ext(itemName)<br/>   for _, ext := range updater.fileExts {<br/>    if fileExt == ext {<br/>     files = append(files, filepath.Join(searchDir, itemName))<br/>    }<br/>   }<br/>  }<br/> }<br/> return files<br/>}</span></pre><h2 id="228e" class="mt lj iq bd lk my mz dn lo na nb dp ls jy nc nd lw kc ne nf ma kg ng nh me ni bi translated">使用正则表达式过滤字符串</h2><p id="1794" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我使用regexp来过滤需要替换的字符串，我使用函数<code class="fe kl km kn ko b">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</code>来查找字符串，下面是对函数的描述。</p><blockquote class="nk nl nm"><p id="cf48" class="jn jo nn jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">// FindAllStringSubmatch是FindStringSubmatch的“All”版本；它<br/> //返回表达式所有连续匹配的一部分，如<br/> //包注释中的‘All’描述所定义。<br/> //返回值nil表示不匹配。</p></blockquote><p id="4d5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我从这个项目中学到了一些东西:</p><p id="5450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">java文件的模式示例如下:</p><pre class="ml mm mn mo gt mp ko mq mr aw ms bi"><span id="9518" class="mt lj iq ko b gy mu mv l mw mx">"StringProvider\\.getValue\\(\"(.*?)\",\\s*?\"(.*?)\"\\)"</span></pre><p id="6538" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据此规则，下面的文本将返回三个项目。</p><pre class="ml mm mn mo gt mp ko mq mr aw ms bi"><span id="b5f8" class="mt lj iq ko b gy mu mv l mw mx">String value1 = StringProvider.getValue("key1", "default value 1");</span></pre><p id="3bbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">FindAllStringSubmatch</code>的结果有三项，第一项是<code class="fe kl km kn ko b">StringProvider.getValue("key1", "default value 1")</code>，第二项是<code class="fe kl km kn ko b">key1</code>，最后一项是<code class="fe kl km kn ko b">default value 1</code>。</p><p id="3126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在模式中，我使用<code class="fe kl km kn ko b">\\s*?</code>来匹配术语之间的空白，占位符<code class="fe kl km kn ko b">(.*?)</code>我在末尾添加了一个<code class="fe kl km kn ko b">?</code>，这不会使用贪婪模式，所以如果我有两个匹配项，它将返回两个项。</p></div></div>    
</body>
</html>