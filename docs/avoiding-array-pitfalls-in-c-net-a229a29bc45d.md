# 避免 C#中的数组陷阱。网

> 原文：<https://levelup.gitconnected.com/avoiding-array-pitfalls-in-c-net-a229a29bc45d>

## 优化。网络应用

## C#中基本类型的有效使用

![](img/e62f5fae32dfdebc16dbe77f56011804.png)

一个糟糕的笑话

通过理解数组在。NET 运行时并在处理应用程序热路径中的数组时为作业选择正确的特性。

# 避免空数组分配

英寸 NET 中，数组是在创建后不能改变大小的对象。本质上，这意味着分配空数组的多个实例没有实际意义。这些实例只会污染运行时，并且在某些时候需要被 GC 收集。

如果分配和释放的数量足够大，这些分配的实例会导致应用程序效率低下。

这最终会导致额外的垃圾收集工作:

空数组的分配

当分配一个空数组时，不能在其中存储任何元素。那么，为什么要首先分配数组呢？

## **另类:阵。清空< T > ()**

**阵列。Empty < T > ()** 利用静态只读属性在应用程序的整个生命周期中只创建一个数组实例。

这种策略避免了相同类型的多个空数组实例，节省了内存和收集不需要的对象的额外 GC 工作。

下面是它的语法:

因为我们现在只处理一个实例，所以当针对任意数量的调用对`Array.Empty<T>`和`new []`进行基准测试时，我们可以实现零分配测量:

> **底线:**避免分配新的空数组。使用数组。空< T >()取而代之。

# 对大型数组使用数组池

对于在关键路径上创建数千个大型数组新实例的应用程序，使用**数组池**可能是值得考虑的。

通过在堆上创建大型数组的新实例，应用程序可能会在其 GC 过程中经历高压力或多次暂停。

ArrayPools 通过利用指定泛型类型 **< T >** 的可重用数组，提供了一种防止这些暂停的方法。ArrayPool 类为我们提供了一个 **Rent** 方法，该方法从该池中检索一个具有指定最小长度**的数组，以备调用者使用。**

ArrayPool 的主要工作是通过减少应用程序分配和释放大型数组的数量来避免 GC 压力。

下面是它的语法:

数组池的使用

*   非常重要的一点是，我们要将租来的归还给泳池，并且不再使用它。不将数组返回到池中可能会降低应用程序的性能，使用已经返回到池中的数组可能会导致运行时错误和崩溃。

> **底线:**避免分配和释放大的、长寿命的对象，而是重用它们。

# 数组方法及其 LINQ 对应物

阅读[时你可以注意到的一个关键点。NET Roslyn 编译器贡献指南](https://github.com/dotnet/roslyn/blob/main/CONTRIBUTING.md)是以下语句:

```
DO avoid allocations in compiler hot paths:
    - DO avoid LINQ
```

然而，看到 LINQ 方法漂亮地散布在一些代码库中并不罕见。

**老实说，我甚至不确定* ***更具可读性*** *的论点在某些情况下是否成立，但那是另一篇文章的讨论内容！*😉

回到数组…如果你手头有一个具体的数组实例，你可能不需要 LINQ 命名空间的方法。

您可能希望对其进行基准测试。但一般来说，在热路径上使用 LINQ 扩展方法往往会导致高负载下的代码效率低下，这主要是由于数组和接口类型之间的装箱和拆箱。

最重要的是，array 类已经提供了许多现成的特性，如复制项目、过滤、搜索、排序、计数等。所以如果你不熟悉它的界面，花点时间阅读它的[源代码](https://referencesource.microsoft.com/#mscorlib/system/array.cs)或者官方[微软文档](https://docs.microsoft.com/en-us/dotnet/api/system.array?view=net-5.0)可能会很有趣。

下面是对 LINQ 计数和任何针对**数组的方法之间的差异的度量。长度**属性:

> 底线:如果你不需要 LINQ，就避开它。

# 一维、多维或锯齿状

在 C#中，我们有三种不同类型的数组:一维(又名。向量)、多维数组和交错数组。

每一种都有自己特定的语法和方法。NET 编译器会翻译你的代码。但总的来说，区别在于:

*   CLR 是专门为处理向量数组而调优的。NET 编译器对此有专门的指令。这些总体上将比非向量数组(多维)更有效。
*   多维数组的每行总是有标准数量的列。
*   交错数组是数组的数组。本质上，这使得它成为一个可以使用的向量，而不是一个多维向量。如果需要多个维度，交错数组通常是首选方式。

下面是一个基准测试，我比较了交错阵列和多维阵列的访问速度:

> 底线:明智地选择你的类型。

# 额外收获:足够有趣的语法让每个人都开心

数组可以用许多不同的方式来声明和初始化，只是为了让我们有足够的理由与我们的队友和同事进行富有成效的(***…或者不是*** )编程语言大战。

这是标准的声明版本:

标准数组声明

## 隐式局部变量

我们可以使用 C#的隐式类型化的`var`关键字，只要类型是指定的(或推断的，见下文…):

带有隐式类型“var”关键字的数组声明

## 创建期间的初始化

可以用一行代码声明和初始化数组:

在创建时初始化数组

## 一条捷径

编译器可以在初始化期间自动推断数组元素的类型。因此，我们可以跳过声明数组类型，仍然使用关键字`var`。

具有自动类型推断的数组初始化

## 一条更短的路

事实证明，我们最终可能不需要新的关键字:

没有“new”关键字的数组初始化

## 这个会导致你的电脑爆炸🔥小块的

不幸的是，由于 the.NET 团队的决定，以下代码是无效的，并将引发编译错误:

# 关键要点

*   除非有理由，否则永远不要分配空数组。⛔
*   当热路径上需要大型阵列时，可以考虑使用 ArrayPool。🚀
*   评估使用 LINQ 方法相对于本机类型方法的成本效益。⚖️
*   并非所有阵列都是相同的。◾️ ◼️ ⬛️
*   选择你最喜欢的语法，进行几次语言大战。你只能活一次。✔️
*   要经常衡量，做出自己的结论。⏰

[](/8-hidden-visual-studio-features-26723606631b) [## 8 个隐藏的 Visual Studio 功能

### 掌握 Visual Studio 快捷方式和隐藏功能

levelup.gitconnected.com](/8-hidden-visual-studio-features-26723606631b) 

# 参考

*   [数组类，微软文档](https://docs.microsoft.com/en-us/dotnet/api/system.array?view=net-5.0)
*   [微软文档 ArrayPool 类](https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1?view=net-5.0)
*   [多维数组 C#指南，微软文档](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays)
*   [罗斯林捐款指南](https://github.com/dotnet/roslyn/blob/main/CONTRIBUTING.md)