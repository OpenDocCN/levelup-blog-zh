# 用 React 钩子和风格化组件构建您自己的无与伦比的井字游戏

> 原文：<https://levelup.gitconnected.com/build-your-own-unbeatable-tic-tac-toe-with-react-hooks-and-styled-components-6f36a6dcb8cc>

在与 React 合作了几年之后，我意识到我只使用这个框架来开发网站和移动应用程序。随着[钩子](https://reactjs.org/docs/hooks-intro.html)的加入，我认为制作一个小游戏会很有趣，可以更深入地了解 React lifecycle 是如何工作的。对于游戏选择，我决定转换一个 jQuery 版本的 Tic Tac Toe，这是我几年前构建的，以作出反应，这最终证明比我预期的更具挑战性。游戏的最终版本可以在[这里](https://clarity-89.github.io/React_tic_tac_toe/)找到，代码可以在 [Github](https://github.com/Clarity-89/React_tic_tac_toe) 上找到，如果你想直接进入游戏的话。

## 安装

为了设置游戏，我们将使用[创建-反应-应用](https://facebook.github.io/create-react-app/)。此外，我们将使用[风格的组件](https://www.styled-components.com/)，一个 CSS 框架 [papercss](https://www.getpapercss.com/) ，它将赋予游戏很酷的极简风格，以及 [React-modal](https://github.com/reactjs/react-modal) 来显示游戏结果。我们将从创建一个空项目并安装必要的依赖项开始。

```
npx create-react-app tic_tac_toe
cd tic_tac_toe
npm i styled-components papercss react-modal
```

项目设置完成后，我们可以开始修改 **App.js，使**包含主要的游戏组件和 **papercss** 样式。

这将使游戏组件在屏幕上居中。不相关的元素，比如`footer`，被省略了，这样我们就可以专注于最重要的部分。下一步是创建实际的 **TicTacToe** 组件。由于应用程序的大小相对较小，我们将把所有文件直接保存在 **src** 文件夹中。

首先让我们开始添加一些游戏的常数到一个单独的 **constants.js.**

在新创建的 **TicTacToe.js** 中，我们可以开始设置和渲染游戏的网格。

首先，我们从导入所有必要的依赖项并声明网格的默认数组开始。注意，我们使用的是 JavaScript 新的[取幂运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Exponentiation)，ES2016 中添加的，以及 ES2015/ES6 中的`[Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)`，来创建一个长度为 9 的数组，并用`null`值填充。它是在组件外部声明的，所以当组件重新呈现时，它不会被重新创建。我们不是创建一个多维数组，然后递归地渲染它，而是渲染一个一维数组，并用 CSS 限制它的宽度。

`width: ${({ dims }) => `${dims * (SQUARE_DIMS + 5)}px`};`是 styled components 将变量传递给组件的方式，也可以写成`width: ${(props) => `${props.dims * (SQUARE_DIMS + 5)}px`};`这里我们将容器的宽度限制为 3 个 100 像素的正方形(加上一些 px 以考虑边框)，并设置`flex-flow: wrap`，这将把多余的正方形推到下一行，以此类推，最终创建一个 3 x 3 的正方形网格。在运行`npm start`并进行一些移动之后，我们可以验证我们的网格功能是否正常。

![](img/7975c7334428951b659e3143f045bb71.png)

看起来不错，但是因为我们还没有设置计算机的移动，所以并不太令人兴奋。我们将通过添加`computerMove`功能来修复它。

现在游戏的互动性更强了。在人类玩家回合后，调用`computerMove`函数，基本上是对棋盘上的一个随机空方格进行移动。注意，我们还在项目中添加了一个 **utils.js** 文件，其中存储了所有的帮助器，比如用于获取某个范围内的随机数的帮助器。

当然，这款游戏还远远不够完美，还存在一些问题。我们将通过添加三种游戏状态**开始改进它**、**进行中**和**结束。**当游戏处于第一状态时，我们将显示一个**选择玩家**屏幕，第二状态将呈现棋盘并允许玩家移动，最终状态将宣布游戏结果。

现在我们可以在组件中使用它们来呈现不同的“屏幕”。

## 添加效果挂钩

以上改变允许选择一个球员。然而，由于我们不检查当前是谁的移动，人类玩家可以不按顺序进行几次移动。为了解决这个问题，我们将引入基于回合的移动，分配下一个回合的玩家到`nextMove.`

这里发生了很多事情。首先，我们将`nextMove`添加到`useEffect`的依赖数组中，这样当它改变时，效果中的代码就会运行。为了实现这一点，在我们的`humanMove`函数中，我们不调用`computerMove`，而是将计算机设置为进行下一步动作的计算机。此外，我们将在允许行动之前检查是否真的轮到人类玩家了。作为一个增强，一个轻微的超时，使计算机移动非瞬间，被添加。还必须记住在效果的清理功能中移除超时。除了`nextMove`，我们还需要跟踪在效果内部访问的组件范围内的其他变量。考虑到`computerMove`在这里是一个函数，并且将在每次渲染时重新创建，我们将使用`useCallback`钩子来记忆它，并防止它发生变化，除非它的任何依赖关系发生变化。为了更深入地了解，本文提供了对效果挂钩的主要注意事项的极好概述。

既然我们在这里跟踪`move`函数，我们也需要记忆它。

玩家现在可以行动了，游戏的流程看起来已经很自然了。然而，如果你运行游戏到最后，即填满所有可用的方块，它将陷入一个无限循环。原因是`computerMove`中的`while`循环在网格上没有更多的空方块后没有终止条件。如果到目前为止，我们解决了一个问题后，又出现了一些新问题，坚持住，我们很快就能解决所有问题了！

## 添加`Board`类

如果你仔细观察代码，你会发现我们并没有在游戏的任何时候将游戏状态设置为**而不是**。但在此之前，我们需要找到游戏的赢家。这似乎是创建一个单独的`Board`类的好机会，它将封装所有与渲染无关的电路板逻辑。

这个类本身非常简单。我们添加了一个方法来获取所有空方块的索引，一个实用方法来检查棋盘是否为空，能够复制棋盘，最后添加了`getWinner`方法，该方法将通过检查棋盘的当前状态是否有任何获胜的组合来返回游戏的结果，硬编码在该方法中。除了用一个空网格初始化棋盘之外，我们还将允许它的方法接受一个网格作为可选参数，这样我们就可以将它们应用到游戏组件的网格中。

好了，现在我们有办法知道游戏的赢家了。让我们用它来表示游戏何时结束，同时我们将添加一个方法来实际设置游戏结果的状态，这样我们就可以在之后显示它。每次移动后检查游戏是否已经到达终点是有意义的，所以我们将引入另一个`useEffect`钩子来跟踪这些变化。

现在我们可以将结果消息与一个**新游戏**按钮一起呈现，这个按钮基本上会重置网格状态，并将游戏设置为**未开始**。

## 介绍 Minimax

有了这些改变，我们现在有了一个合适的井字游戏。但是仍然缺少一点:计算机随机移动，这使得它很容易被击败。我们可以通过引入 [Minimax](https://en.wikipedia.org/wiki/Minimax) 算法来计算计算机的最佳走法，将情况推向另一个极端。如果实施得当，这将使游戏不可战胜，人类玩家能指望的最好结果是平局。关于算法的内部工作方式，我不会讲得太深入，网上已经有很多关于它的文章了。基本上，Minimax 所做的是根据最终的游戏结果，为每一步棋赋予价值。得分最高的棋被选为最佳棋。为了做到这一点，算法需要递归地计算棋盘当前状态的所有移动。考虑到在井字游戏中可能的移动次数相对较少，该算法运行速度相当快。

为了让算法工作，我们需要在我们的 board 类中添加`makeMove`方法，这将把当前玩家放到棋盘上。

我们不仅仅使用来自`TicTacToe`组件的`move`函数的原因是因为在 minimax 的循环中触发它会改变组件的状态并导致大量的重新渲染，这将很快导致堆栈溢出。

最后，我们实际上可以让计算机对手做出“聪明”的举动。

将`grid`的副本传递给`Board`构造函数很重要，这样`minimax`就不会改变`TicTacToe`组件中使用的实际网格。`[concat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)`调用一个没有参数的数组将返回该数组的一个副本。用`[grid.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)`或者使用 [JS 数组展开语法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) : `[...grid]`也可以达到同样的效果。

接下来，如果轮到计算机时棋盘是空的，这意味着计算机正在进行第一步，我们将让计算机进行随机移动，以大大加快极大极小值计算的速度。

## 添加难度等级

在这一点上，基本游戏已经准备好了，但是我们仍然可以改进它一点。虽然随机电脑版太容易了，但 minimax 版太难了，基本上不会让人类玩家获胜。我们可以把它们结合起来，增加一个“中等”水平，其中一半的移动是随机的，另一半是极小最大。当我们这样做的时候，让我们也添加已经开发的“简单”和“困难”级别。为此，我们将把`mode`引入组件状态。玩家将能够在每场游戏开始时选择所需的游戏模式，并且必须修改`computerMove`功能以适应该选择。

现在我们迎来了更新的开始屏幕，默认选择了**中等**游戏难度。

![](img/474424e4988bdf0ebe960cff6fae3f5c.png)

## 包扎

在这个可选部分，我们将为最终的 Tic Tact Toe 体验添加一些收尾工作:显示游戏结果模式，调整网格的边界样式，并为获胜的组合添加 strike through 样式。第一项任务是最容易的，所以让我们从它开始。

为了定制模态叠加的样式，我们将根据包文档使用`customStyles`对象。模型的其他元素我们将使用样式化组件进行样式化。

随着样式的出现，让我们将模态导入到主组件中，并在游戏结束时显示它。

是的，模态在那里。一个新游戏可以从这里开始，或者玩家可以关闭它再次看到最后的棋盘(在这种情况下，页面必须重新加载才能开始新游戏)。

![](img/522023e820770d0c6f2db95ae703562a.png)

看着这些按钮，你会注意到它们有不规则形状的边框，这与应用程序的整体风格非常吻合。如果我们的网格正方形和结果模型有相似形状的边界不是很好吗？通过一点试验和调整，我们可以得出一个令人满意的样式，它将被添加到一个单独的 **styles.js** 文件中。

这里我们只是将 CSS 样式声明为模板字符串，我们可以在组件中使用它。

请注意，向样式化组件添加可重用样式的语法是模板内的变量插值。经过这些改变后，网格看起来与整体风格更加一致。

![](img/0191cff614f2681b1c5afa4f257311bb.png)

作为最后的润色，我们将添加一个醒目的样式来突出获胜的方块序列。为了实现这一点，与游戏的获胜者一起，`Board`类将根据获胜的组合返回删除的样式(除非游戏是平局)。

让我们给我们的主组件添加一个`Strikethrough`元素，看看样式是否有效。

如果`board.getStrikethroughStyles()`返回样式，我们将它们应用到我们的元素中，否则它将被隐藏，宽度为`0px`。

![](img/a25a5e15de12ec07e6e3d26c51334c28.png)

完美！现在，只要比赛有赢家，我们就会看到一个漂亮的好球。

这是一个总结。按照你自己的喜好自由调整和定制游戏！