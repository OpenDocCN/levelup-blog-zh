<html>
<head>
<title>Building a Scalable Data Service in the Modern Microservices World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在现代微服务世界中构建可扩展的数据服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bulding-a-scalable-data-service-in-the-modern-microservices-world-481f9d1cabad?source=collection_archive---------6-----------------------#2021-06-22">https://levelup.gitconnected.com/bulding-a-scalable-data-service-in-the-modern-microservices-world-481f9d1cabad?source=collection_archive---------6-----------------------#2021-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f94e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种数据服务，它可以跨多个持久层执行事务，可以灵活地选择服务和数据库，即TypeScript方式。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/58f1e2e13a4642f058cf3298b163d200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMg8HqCL8JR_ewLpVlhoKQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">基于SOA的应用程序中的多方向数据流，带有一个中央数据存储库</strong></figcaption></figure><h1 id="928e" class="kw kx iq bd kv ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">序言:应用程序</h1><p id="7f29" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae mj" href="https://en.wikipedia.org/wiki/Service-oriented_architecture" rel="noopener ugc nofollow" target="_blank">面向服务的架构(SOA) </a>采用<a class="ae mj" href="https://microservices.io/patterns/microservices.html" rel="noopener ugc nofollow" target="_blank">微服务的架构设计</a>已经成为<a class="ae mj" href="https://www.ibm.com/docs/en/txseries/8.1.0?topic=overview-what-is-distributed-computing" rel="noopener ugc nofollow" target="_blank">分布式计算</a>的家喻户晓的名字。我们构建的数据密集型应用越来越多，将我们的系统分解成具有固定数量的数据集和固定数量的业务规则的小型可管理服务的重要性和必要性就变得越来越明显。</p><p id="4493" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">微服务架构不仅使整个应用程序更具解耦性和内聚性，还使团队更灵活地进行频繁部署，而不会中断或依赖他人。服务之间的通信通常使用超文本传输协议来完成。请求和响应格式(<a class="ae mj" href="https://www.w3.org/XML/" rel="noopener ugc nofollow" target="_blank"> XML </a>或<a class="ae mj" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>)被称为<a class="ae mj" href="https://spec.openapis.org/oas/v3.1.0" rel="noopener ugc nofollow" target="_blank"> API契约</a>，它将服务绑定在一起，形成应用程序的完整行为。</p><p id="65ec" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在上面给出的例子中，我们讨论的是一个服务于Web和移动用户的应用程序，它允许外部服务使用提供给最终用户的<a class="ae mj" href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" rel="noopener ugc nofollow" target="_blank"> REST API </a>端点进行集成。</p><p id="432b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">每个用例都有自己的端点暴露在单独的<a class="ae mj" href="https://www.nginx.com/resources/glossary/load-balancing/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">负载平衡器</em> </a>面前，负载平衡器利用最佳可用资源管理<em class="mp">传入的请求</em>。每个内部服务都包含一个<a class="ae mj" href="https://www.nginx.com/resources/glossary/application-server-vs-web-server/" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> Web服务器</em> </a>，它处理所有传入的请求并将它们转发给正确的服务或将其发送给内部应用程序；一个<em class="mp">应用服务器</em>，它托管微服务的所有业务逻辑；以及一个准持久层，一个基于数据的空间和/或时间局部性的数据库的<em class="mp">本地复制。</em></p><h2 id="35ff" class="mq kx iq bd kv mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">问题:我们试图解决什么</h2><p id="0854" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">每个单独的服务维护自己的复制。但是通常情况下，我们的事务可能会改变另一个服务的行为。因此，我们需要在它们之间保持某种状态。实现这种状态共享架构的简单解决方案是拥有一个两种服务都可以访问的公共数据库。这种解决方案不能很好地与服务的数量相适应，尤其是当您考虑到每个服务在数据库事务上的自由度时。对此的快速解决方案可能是为个别服务添加自定义访问权限，但这也会增加维护开销。每个服务，如果被给予不受限制的访问，可以修改他们不应该修改的数据，或者将状态转换为不一致的状态。考虑这个例子，有两个实体— <em class="mp">用户</em>和<em class="mp">宠物</em>。他们有一对多的关系。现在假设我们有一个更新<em class="mp">用户的</em>电子邮件地址的事务。这个特定的事务不需要与Pets表交互，并且可以被禁止访问它。另一方面，如果我们有一个事务，其中我们向现有的<em class="mp">用户</em>添加了一个新的<em class="mp">宠物</em>。这将需要与两个表进行交互。</p><p id="ed9c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在要考虑的另一件事是，我们不想在我们的服务中编写原始SQL/文档查询，因为它们会与数据库实现甚至数据库供应商紧密耦合。这也将是一场维护噩梦，因为现在数据库中一个最小的结构变化可能需要更新成千上万个查询。</p><p id="a57b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">因此，在大多数现实世界的应用程序中，我们使用称为<a class="ae mj" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank"><em class="mp"/></a><em class="mp"/>或<em class="mp">对象文档映射器(ODM) </em>的东西来封装查询，并抽象出所有与数据库相关的配置设置和手册。现在我们有了表示表结构的实体类，但也可以用作任何其他对象。现在，为了恢复早期的实现设计，我们必须在使用这些类的每个服务中重复地重新实现这些类，或者至少是其中的一些。这再次引入了我们之前讨论过的相同的维护开销。</p><h2 id="09ef" class="mq kx iq bd kv mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">要点</h2><ol class=""><li id="bd58" class="nc nd iq lp b lq lr lt lu lw ne ma nf me ng mi nh ni nj nk bi translated">我们有多个微服务运行在外部负载平衡器之后。</li><li id="1748" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">它们相互依赖，并通过专用的web服务器进行管理。</li><li id="9c62" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">每个单独的服务都有自己的数据库的本地副本。</li><li id="1f7a" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">但是由于服务的相互依赖性，他们有一个集中的数据存储。它可以是SQL，或者Document/HashStore，或者两者都是。</li><li id="2c02" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">如果我们试图在服务中编写原始查询，我们将与数据库供应商和数据库实现高度耦合。这将在每个服务中引入维护和安全开销。</li><li id="7447" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">因此，我们将使用一些ORM/ODM库来表示我们的数据库实体。但是这涉及到松散的内聚性，使得相同的实现在多个服务上重复。</li><li id="460a" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">我们正在寻找一种方法，可以促进我们的中央数据库的跨服务请求处理，甚至可以减少服务间的通信开销；同时不在多个地方复制逻辑。</li></ol><h1 id="8eb5" class="kw kx iq bd kv ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">构建数据服务</h1><p id="a923" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">所以现在我们要做的是建立一个专用的数据服务，它的目的是提供一个与数据交互的接口。对于关系数据，这也应该考虑相关的实体组件。我们希望这个服务本身是无状态的，因为实际的逻辑将驻留在单独的服务中。</p><h2 id="b5e1" class="mq kx iq bd kv mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">数据服务的组件</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/60ca82f9be35a3d7ea90aa8dc8c1d995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*KPcPuckfnwMZuWj-4Vbiyg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">附属于数据服务的依赖关系和服务<em class="nr">(六角形架构)</em> </strong></figcaption></figure><p id="1115" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在本服务中，我们假设可用的工具和服务如下:</p><ol class=""><li id="47ee" class="nc nd iq lp b lq mk lt ml lw ns ma nt me nu mi nh ni nj nk bi translated"><strong class="lp ir"> HTTP API控制器</strong> —这部分程序负责处理<em class="mp">网络层</em>。我们可以有一个REST API或者一个<a class="ae mj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL API </a>或者两者都有，供我们的消费者使用。我们可以在<a class="ae mj" href="http://typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> TypeScript </em> </a>中使用<a class="ae mj" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">表示</em> </a>进行休息，而对于其他的则使用<a class="ae mj" href="https://typegraphql.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> Type-GraphQL </em> </a>。</li><li id="d4fc" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated"><strong class="lp ir">持久数据层</strong> —保存应用程序状态的实际数据库。根据数据的性质，它可以是某种SQL或NoSQL T21，或者是两者的组合。当从我们的服务进行交互时，我们将在其上使用ORM/ODM。<a class="ae mj" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> TypeORM </em> </a>在这里是一个相当大的选择。</li><li id="2af0" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated"><strong class="lp ir">网络日志监视器</strong> —这一层将负责提供我们服务的日志和指标，以便在稍后的时间点，我们可以监视它的行为、性能，甚至调试单个请求。我们可以使用<a class="ae mj" href="https://github.com/winstonjs/winston" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> Winston </em> </a>进行日志记录，并使用<a class="ae mj" href="https://www.elastic.co/what-is/elk-stack" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> ELK Stack </em> </a>将数据点汇集到适当的索引和仪表板中。</li><li id="4049" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated"><strong class="lp ir">出站缓存—</strong><em class="mp">网络层</em>中的缓存层，用于减少具有读取密集型操作的服务的读取时间。<a class="ae mj" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> Redis </em> </a>在这里是个不错的选择。</li><li id="31ab" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated"><strong class="lp ir">活动日志— </strong>这将跟踪以可串行化方式完成的操作，以及元数据，包括但不限于调用该操作的服务，以及可以逆转该操作效果的请求。它本质上是数据库的时间序列，可以用于将来的审计目的。<a class="ae mj" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank"><em class="mp">elastic search</em></a>是存储和检索这类数据的一个相当不错的选择。</li></ol><p id="f20a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">所有这些依赖项都可以加载到应用程序中，并在运行时<a class="ae mj" href="https://en.wikipedia.org/wiki/Bootstrapping" rel="noopener ugc nofollow" target="_blank">引导</a>(使用<a class="ae mj" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank"> DI </a>容器，如<a class="ae mj" href="https://docs.typestack.community/typedi/v/develop/01-getting-started" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> TypeDI </em> </a>)，我们可以使用这些接口的<a class="ae mj" href="https://en.wikipedia.org/wiki/Reflective_programming" rel="noopener ugc nofollow" target="_blank">反射</a>来构建我们的服务。</p><h2 id="d903" class="mq kx iq bd kv mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">三层架构</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/06758ed434696430473239821e17292e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSl26pqMHAXA22KdYpwU8A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">数据服务的三层架构</strong></figcaption></figure><p id="fae9" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在这种模式中，我们不仅将实际的数据库实现和网络层从核心服务逻辑中分离出来，而且数据处理部分也是分层的。<em class="mp">实体</em>层简单地提供了数据库中各个表的表示接口。<em class="mp">存储库</em>层在实体的简单实现上添加了特定领域的逻辑。<em class="mp">服务</em>层提供了一组可以在每个实体及其相关实体上执行的操作/事务。</p><p id="a42a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><em class="mp">服务</em>层稍后被注入到<em class="mp">控制器</em> (REST)和<em class="mp">解析器</em> (GraphQL)组件中，以基于来自各个微服务的传入请求来执行那些操作。</p><p id="5d58" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下是<em class="mp">用户</em>实体的示例定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e490" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">注意这里，类中没有提供方法定义，只有表列及其属性的定义。这是数据层的最接近的表示，不应该有更多的内容。</p><p id="61e2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">附加行为由基于实体的<a class="ae mj" href="https://medium.com/swlh/inside-out-repository-pattern-for-data-layer-5eca4dd0e7d4" rel="noopener">库</a>类保持，如<em class="mp">用户</em>库如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="960c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">此外，服务层托管所有操作，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8ce6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">一个人能做多少手术就做多少手术。但是在处理所有请求的这一层之上，与服务层交互来执行这些请求。</p><p id="df39" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下分别是<em class="mp">用户</em>控制器和<em class="mp">用户</em>解析器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="21cf" class="mq kx iq bd kv mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">从微服务中消费数据</h2><p id="fd00" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在我们有了一个专用的数据服务，可以用来查询和变更存储在我们的中央持久数据库中的数据，我们进一步需要的是一个从我们的单个微服务访问它们的机制。</p><p id="ba8e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">数据服务的开发方式有两种，要么通过REST API，要么通过GraphQL API。现在，在它们中的任何一个中手工编写查询或操作不仅耗时且不可维护，而且在某些地方效率也很低。</p><p id="56e2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">所以我们应该做一些叫做反思的事情。在这种方法中，我们将通过数据服务导入网络层定义的接口来与外部世界进行交互，并将它们重新实现为服务的代理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="3352" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在，这个代理可以简单地如下使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="563f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">对于<em class="mp">宠物</em>实体也可以遵循类似的模式。我们只需要<a class="ae mj" href="https://blog.bitsrc.io/sharing-types-between-backend-and-frontend-with-the-bff-pattern-553872842463" rel="noopener ugc nofollow" target="_blank">公开一个接口，该接口从中央数据存储库服务</a>定义这些实体。这些接口是我们用于数据服务的API契约。</p><p id="927d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">另一个好方法是建立一个<a class="ae mj" href="https://grpc.io/docs/what-is-grpc/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>框架，使用协议缓冲区定义接口，将这些事务定义为消息，将数据存储库定义为服务，但是我将在另一篇文章中详细介绍这一点。</p><h2 id="3c1b" class="mq kx iq bd kv mr ms dn lb mt mu dp lf lw mv mw lh ma mx my lj me mz na ll nb bi translated">缺点和警告</h2><ol class=""><li id="f2b7" class="nc nd iq lp b lq lr lt lu lw ne ma nf me ng mi nh ni nj nk bi translated">身份验证超出了本服务的范围。由于预期该服务仅由内部服务使用，因此不预期该服务维护任何身份验证层，而是预期来自经过验证的资源的传入请求。</li><li id="3712" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">这在单个服务和数据库之间增加了一个额外的层，因此导致了一些额外的延迟。这可以通过使用适当的基础设施工具和缓存来最小化，但无法消除。</li><li id="9781" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">因为这个服务本身是无状态的，所以理论上它可以无限扩展。但是瓶颈现在在于数据库服务和它一次可以保持的活动连接数。为了改进这一点，可以使用复制数据库来最大化可能的连接。</li><li id="5ce3" class="nc nd iq lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated">提高数据库性能的标准优化技术将成倍地加速这种架构。</li></ol></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="d907" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">解释这种架构的样板存储库(以及一些其他特性):<a class="ae mj" href="https://github.com/w3tecch/express-typescript-boilerplate" rel="noopener ugc nofollow" target="_blank"><em class="mp">w3tecch/express-typescript-样板</em> </a>。</p><p id="35b8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在这里加入领英讨论:<a class="ae mj" href="https://www.linkedin.com/feed/update/urn:li:activity:6813481252939808768/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/feed/update/urn:李:活动:6813481252939808768/ </a></p></div></div>    
</body>
</html>