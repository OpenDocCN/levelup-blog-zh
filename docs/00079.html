<html>
<head>
<title>Protecting your React + GraphQL application with JWT authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JWT认证保护您的React + GraphQL应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/protecting-your-react-graphql-application-with-jwt-authentication-3c03db9530cb?source=collection_archive---------0-----------------------#2018-01-29">https://levelup.gitconnected.com/protecting-your-react-graphql-application-with-jwt-authentication-3c03db9530cb?source=collection_archive---------0-----------------------#2018-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dbe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续React + GraphQL教程，通过JWT增加安全性</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/301d2f844a971777d4830c23b2e54de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VWqDww9-d4dSsnLq."/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">保护您的GraphQL API</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="12c5" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">警告</h1><p id="fa3d" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">本教程中提供的实现不是生产就绪的代码，也没有足够的安全性来集成到您的应用程序中。这篇文章的目的是扩展<a class="ae ml" href="http://graphql.org/graphql-js/authentication-and-express-middleware/" rel="noopener ugc nofollow" target="_blank"> GraphQL文档</a>中给出的信息。你可以读到很多关于使用JWT的讨论(<a class="ae ml" href="https://float-middle.com/json-web-tokens-jwt-vs-sessions/" rel="noopener ugc nofollow" target="_blank">这里</a>或者<a class="ae ml" href="https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies" rel="noopener ugc nofollow" target="_blank">那里</a>)，它的<a class="ae ml" href="https://dzone.com/articles/jwtjson-web-tokens-are-better-than-session-cookies" rel="noopener ugc nofollow" target="_blank">优点</a>、<a class="ae ml" href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/" rel="noopener ugc nofollow" target="_blank">缺点</a>以及不同的<a class="ae ml" href="https://auth0.com/docs/security/store-tokens" rel="noopener ugc nofollow" target="_blank">储存</a>它们的方式。</p><p id="8401" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>如果您在生产中使用令牌认证，您必须确保您的API仅在<code class="fe mm mn mo mp b">https</code>期间可用。此外，还必须禁用CORS(为了简化示例，此处启用了它)</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="9b06" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">介绍</h1><p id="d3d1" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">在本系列文章的第一部分中，我们用后端的GraphQL API(使用node JS)和前端的React JS创建了单页面应用程序(SPA)。</p><p id="48b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二部分<a class="ae ml" rel="noopener ugc nofollow" target="_blank" href="/enhancing-your-react-graphql-app-with-redux-and-redux-thunk-90c556aff1c5">中，我们通过添加</a><a class="ae ml" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>作为状态管理库和Redux-Thunk作为<a class="ae ml" href="https://redux.js.org/docs/advanced/Middleware.html" rel="noopener ugc nofollow" target="_blank">中间件</a>来增强我们的应用程序。我们还添加了一些特性，如<a class="ae ml" href="http://StorageService.js" rel="noopener ugc nofollow" target="_blank"> StorageService </a>来存储搜索表单的数据，以及<a class="ae ml" href="https://github.com/reactjs/react-router-redux" rel="noopener ugc nofollow" target="_blank"> React-Router-Redux </a>来以“Redux”方式处理客户端路由。</p><p id="4295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将使用所有这些功能，并在后端进行一些更改，以使用基于Json Web令牌(也称为<a class="ae ml" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a> s)的身份验证来保护我们的GraphQL API</p><p id="0aeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt" rel="noopener ugc nofollow" target="_blank">库</a>中看到一个工作教程。要启动它，请运行<strong class="jp ir"> npm，在客户端和服务器文件夹中安装</strong>，然后您可以使用<strong class="jp ir"> npm start </strong>来启动服务器或客户端，或者两者都启动。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="4b96" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在后端保护您的API</h1><p id="0063" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">首先，我们需要安装一个对JWT令牌有用的npm包。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="2295" class="mu lj iq mp b gy mv mw l mx my">npm i -s jsonwebtoken</span></pre><p id="8864" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用它在后端创建和验证JSON web令牌。你可以在这里看到完整的package.json文件<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/blob/master/graphsrv/package.json" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要创造我们的逻辑与JWT合作。我们首先导入jsonwebtoken库、用户的数据源和一个附加的lodash函数。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="e217" class="mu lj iq mp b gy mv mw l mx my">import jwt from 'jsonwebtoken'<br/>import Users from './data/users'<br/>import find from 'lodash/find'</span></pre><p id="d5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下常量用作JWT的配置选项:</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="7c45" class="mu lj iq mp b gy mv mw l mx my">const expiresIn = '3h' // time to live<br/>const secret = 'samplejwtauthgraphql' // secret key<br/>const tokenPrefix = 'JWT' // Prefix for HTTP header</span></pre><p id="a84b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们准备向SPA的后端添加负责身份验证的方法。第一个函数将负责创建令牌。它将检查数据源中是否存在具有给定凭证的用户，否则返回令牌或false。<em class="mz"> jwt.sign </em>函数用于生成新的令牌。在本教程中，我们将使用用户的电子邮件和小写的姓氏作为凭证。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="57e3" class="mu lj iq mp b gy mv mw l mx my">/**<br/> * Use email as login, use password as password<br/> * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} email <br/> * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} password<br/> */<br/>export const createToken = (email, password) =&gt; {<br/>    if (!email || !password) { // no credentials = fail<br/>        return false<br/>    }<br/>    const user = find(Users,<br/>        (user) =&gt; {<br/>            return user.email === email.toLowerCase()<br/>                &amp;&amp; user.last_name.toLowerCase() === password<br/>        }<br/>    );<br/>    if (!user) { // return false if not found<br/>        return false<br/>    }<br/>    const payload = {<br/>        username: user.email,<br/>    }<br/>    const token = jwt.sign(payload, secret, {<br/>        expiresIn<br/>    })<br/>    return token<br/>}</span></pre><p id="e575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个函数将从认证头中提取令牌(通过JWT前缀)并检查它是否有效。如果有效，它将返回属于用户的令牌，否则抛出一个错误。<em class="mz"> jwt.verify </em>方法用于此。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="48ef" class="mu lj iq mp b gy mv mw l mx my">/**<br/> * <a class="ae ml" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {Object} - current user object<br/> * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} token header<br/> */<br/>export const verifyToken = (token) =&gt; {<br/>    const [prefix, payload] = token.split(' ')<br/>    let user = null<br/>    if (!payload) { //no token in the header<br/>        throw new Error('No token provided')<br/>    }<br/>    if (prefix !== tokenPrefix) { //unexpected prefix or format<br/>        throw new Error('Invalid header format')<br/>    }<br/>    jwt.verify(payload, secret, (err, data) =&gt; {<br/>        if (err) { //token is invalid<br/>            throw new Error('Invalid token!')<br/>        } else {<br/>            user = find(Users, { email: data.username })<br/>        }<br/>    })<br/>    if (!user) { //user does not exist in DB<br/>        throw new Error('User doesn not exist')<br/>    }<br/>    return user<br/>}</span></pre><p id="67f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使我们的API安全，我们需要在<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/blob/master/graphsrv/src/server.js" rel="noopener ugc nofollow" target="_blank"> server.js </a>文件中创建几个HTTP端点来处理用户登录和令牌验证。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="8bc9" class="mu lj iq mp b gy mv mw l mx my">import express from 'express'<br/>import bodyParser from 'body-parser'<br/>import schema from './schema'<br/>import graphqlHTTP from 'express-graphql'<br/>import { createToken, verifyToken } from './auth'</span><span id="72a6" class="mu lj iq mp b gy na mw l mx my">app.use('/login', jsonParser, (req, res) =&gt; {<br/>    if (req.method === 'POST') {<br/>        const token = createToken(req.body.email, req.body.password)<br/>        if (token) { //send successful token<br/>            res.status(200).json({ token })<br/>        } else {<br/>            res.status(403).json({ //no token - invalid credentials<br/>                message: 'Login failed! Invalid credentials!'<br/>            })<br/>        }<br/>    }<br/>});</span><span id="111a" class="mu lj iq mp b gy na mw l mx my">/**<br/> * Verify token and return either error or valid user profile<br/> */<br/>app.use('/verifyToken', jsonParser, (req, res) =&gt; {<br/>    if (req.method === 'POST') {<br/>        try {<br/>            const token = req.headers['authorization']<br/>            const user = verifyToken(token)<br/>            res.status(200).json({ user })<br/>        } catch (e) {<br/>            console.log(e.message)<br/>            res.status(401).json({ //unauthorized token<br/>                message: e.message<br/>            })<br/>        }<br/>    }<br/>});</span></pre><p id="9a58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，为了使我们的API受到JWT令牌认证的保护，我们需要在GraphQL API处理之前添加一些中间件来处理数据。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="b4d5" class="mu lj iq mp b gy mv mw l mx my">// auth middleware<br/>app.use('/graphql', (req, res, next) =&gt; {<br/>    const token = req.headers['authorization']<br/>    try {<br/>        req.user = verifyToken(token)<br/>        next()<br/>    } catch (e) {<br/>        res.status(401).json({ //unauthorized token<br/>            message: e.message<br/>        })<br/>    }<br/>});</span></pre><p id="2f39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个中间件检查一个令牌，如果令牌有效，就添加一个用户对象来请求这个对象，否则就返回一个401 http头。如果令牌有效，它将调用next()函数，这将导致一个现有的GraphQL处理程序。我们可以使用“context”键将这个用户对象传递给GraphQL模式。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="f419" class="mu lj iq mp b gy mv mw l mx my">app.use('/graphql', graphqlHTTP((req, res) =&gt; ({<br/>    schema,<br/>    graphiql: true,<br/>    context: {<br/>        user: req.user,<br/>    }<br/>}));</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="ebd1" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在前端添加身份验证和令牌验证逻辑</h1><p id="de61" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我们需要在前端进行一些更改，以便它能够处理身份验证和令牌。您可以在存储库的<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/tree/master/client" rel="noopener ugc nofollow" target="_blank">客户端</a>文件夹中找到源代码。</p><p id="86ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要在<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/blob/master/client/src/ApiService.js" rel="noopener ugc nofollow" target="_blank"> ApiService </a>中为新的端点调用添加一些方法。</p><p id="ba69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的方法是调用非GraphQL APIs的通用函数。它只是为Javascript获取功能添加了更多的语法糖。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="d69d" class="mu lj iq mp b gy mv mw l mx my">/**<br/>     * Generic API call (for non-graphql endpoints)<br/>     * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} url <br/>     * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {object} params <br/>     */<br/>    async apiCall(url, params = {}, method = 'POST', token = false) {<br/>        const res = await fetch(`${this.baseUrl}${url}/`, {<br/>            method,<br/>            mode: 'cors',<br/>            headers: this.buildHeaders(token),<br/>            body: JSON.stringify(params),<br/>        })<br/>        if (!res.ok) {<br/>            throw new Error(res.status)<br/>        }<br/>        return res.json()<br/>    }</span></pre><p id="cd1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要定义一个buildHeaders方法，该方法假设我们可能有一个包含令牌的身份验证头。如果我们将令牌作为参数传递，它会创建一个授权HTTP头，其中包含前缀为“JWT”的令牌。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="a76d" class="mu lj iq mp b gy mv mw l mx my">    /**<br/>     * Build  http headers object<br/>     * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string|boolean} token <br/>     */<br/>    buildHeaders(token = false) {<br/>        let headers = new Headers();<br/>        headers.append('Content-type', 'application/json');<br/>        if (token) {<br/>            headers.append('Authorization', `JWT ${token}`);<br/>        }</span><span id="3f1a" class="mu lj iq mp b gy na mw l mx my">        return headers;<br/>    }</span></pre><p id="ba5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要调用登录和验证令牌端点的方法。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="d314" class="mu lj iq mp b gy mv mw l mx my">/**<br/>     * Login user and return jwt token or throw error in<br/>     * case of fail<br/>     * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} login<br/>     * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} password<br/>     */<br/>    async login(params) {<br/>        const res = await this.apiCall('/login', params)<br/>        console.log(res)<br/>        return res.token<br/>    }</span><span id="80fb" class="mu lj iq mp b gy na mw l mx my">/**<br/>     * Verify current token and return current user or throw error<br/>     * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} token <br/>     */<br/>    async verifyToken(token) {<br/>        const res = await this.apiCall(<br/>           '/verifyToken',<br/>           {},<br/>           'POST',<br/>           token<br/>        )<br/>        return res.user<br/>    }</span></pre><p id="1731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们的GraphQL API方法应该能够在其HTTP头中使用我们的身份验证令牌。另外，请注意，我们现在将令牌作为参数传递给所有受保护的API调用。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="3776" class="mu lj iq mp b gy mv mw l mx my">/**<br/>     * Generic function to fetch data from server via graphql API<br/>     * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} query<br/>     * <a class="ae ml" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {unresolved}<br/>     */<br/>    async getGraphQlData(resource, params, fields, token = false) {<br/>        const query = `{${resource} ${this.paramsToString(params)} <br/>             ${fields}}`<br/>        const res = await fetch(this.apiUrl, {<br/>            method: 'POST',<br/>            mode: 'cors',<br/>            headers: this.buildHeaders(token),<br/>            body: JSON.stringify({ query }),<br/>        });<br/>        if (res.ok) {<br/>            const body = await res.json();<br/>            return body.data;<br/>        } else {<br/>            throw new Error(res.status);<br/>        }<br/>    }</span><span id="1c95" class="mu lj iq mp b gy na mw l mx my">/* .... */</span><span id="baa5" class="mu lj iq mp b gy na mw l mx my">   /**<br/>     * <br/>     * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {object} params<br/>     * <a class="ae ml" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {array} users list or empty list<br/>     */<br/>    async getTodos(params = {}, token) {<br/>        const data = await this.getGraphQlData(<br/>            'todos', params, this.todoFields, token<br/>        );<br/>        //return todos list<br/>        return data.todos;<br/>    }</span></pre><p id="b9f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候转到与React-Redux相关的逻辑了。我们需要定义一个<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/blob/master/client/src/reducers/authReducer.js" rel="noopener ugc nofollow" target="_blank">缩减器</a>来处理我们的状态中与认证相关的部分。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="98ba" class="mu lj iq mp b gy mv mw l mx my">// shape of bit or state related to authentication<br/>const initialState = { <br/>    isAuthenticated: false,<br/>    isFailure: false,<br/>    isLoading: true,<br/>    current_user: null,<br/>}</span></pre><p id="3c47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个reducer将处理所有成功和失败的身份验证，它还将加载用户配置文件数据。我们使用isLoading标志让UI组件知道正在加载。</p><p id="4491" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/blob/master/client/src/actions/authActions.js" rel="noopener ugc nofollow" target="_blank">动作</a>文件将处理所有这些状态转换。其中最有趣的部分实际上是中间件，它处理API调用以获取/验证令牌，并根据结果分派特定的操作。例如，下面的登录函数将使用给定的参数进行API调用，然后将令牌存储在存储中，并在成功的情况下调度一个<em class="mz"> loginSuccess() </em>操作，或者在身份验证失败的情况下显示一个错误并调度<em class="mz"> loginFailure() </em>。请注意，我们还使用react-redux-router中的<em class="mz"> push() </em>方法以“redux方式”进行重定向</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="079b" class="mu lj iq mp b gy mv mw l mx my">export const login = (params) =&gt; async dispatch =&gt; {<br/>    try {<br/>        const token = await ApiService.login(params)<br/>        StorageService.setToken(token)<br/>        dispatch(loginSuccess())<br/>        dispatch(push('/'))<br/>    } catch (e) {<br/>        console.error(e.message)<br/>        dispatch(loginFailure())<br/>    }<br/>}</span><span id="3219" class="mu lj iq mp b gy na mw l mx my">export const logout = () =&gt; dispatch =&gt; { //destroy token and logout<br/>    StorageService.removeToken()<br/>    dispatch(logoutAction())<br/>    dispatch(push('/login'))<br/>}</span></pre><p id="100f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个动作用于在页面加载时从存储中验证我们的令牌，如果令牌有效，则获取用户的配置文件，如果无效，则重定向到登录页面。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="809c" class="mu lj iq mp b gy mv mw l mx my">export const verifyToken = () =&gt; async dispatch =&gt; {<br/>    if (!StorageService.getToken()) { //if no token - logout<br/>        dispatch(logoutAction())<br/>        return<br/>    }<br/>    try {<br/>        dispatch(requestProfile())<br/>        const user =await ApiService.verifyToken(<br/>            StorageService.getToken()<br/>        )<br/>        dispatch(receiveProfile(user))<br/>        dispatch(loginSuccess())<br/>    } catch (e) {<br/>        //remove token and logout if invalid<br/>        console.error(e.message)        <br/>        StorageService.removeToken()<br/>        dispatch(logoutAction())<br/>    }</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="9ea0" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在客户端处理私有和公共路由</h1><p id="2255" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我们的应用程序中有许多不同的组件，我们需要其中一些(用户列表，待办事项列表)只对授权用户可用，但其他一些(登录表单)应该对非授权用户可用。在每个组件内部检查这一点并不是很有效，所以我们将创建特殊的<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/tree/master/client/src/containers" rel="noopener ugc nofollow" target="_blank">容器</a>来在路由级别处理它。第一个只允许访客访问，如果用户已经登录，则重定向到主页。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="fcbb" class="mu lj iq mp b gy mv mw l mx my">/**<br/> * Router for only guest stuff like Login/Register<br/> * If not guest - redirects to home<br/> */</span><span id="97a9" class="mu lj iq mp b gy na mw l mx my">class GuestRoute extends React.Component {<br/>    render() {<br/>        const {<br/>            isAuthenticated,<br/>            component: Component,<br/>            ...props<br/>        } = this.props        <br/>        return (<br/>            &lt;Route<br/>                {...props}<br/>                render={props =&gt;<br/>                    !isAuthenticated<br/>                        ? &lt;Component {...props} /&gt;<br/>                        : (<br/>                            &lt;Redirect to={{<br/>                                pathname: '/',<br/>                                state: { from: props.location }<br/>                            }} /&gt;<br/>                        )<br/>                }<br/>            /&gt;<br/>        )<br/>    }<br/>}</span><span id="6554" class="mu lj iq mp b gy na mw l mx my">const mapStateToProps = ({ auth }) =&gt; {<br/>    const isAuthenticated = auth.isAuthenticated<br/>    return {<br/>        isAuthenticated,<br/>    }<br/>}</span><span id="ed94" class="mu lj iq mp b gy na mw l mx my">export default connect(mapStateToProps)(GuestRoute)</span></pre><p id="ac03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个是<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/blob/master/client/src/containers/PrivateRoute.js" rel="noopener ugc nofollow" target="_blank"> PrivateRoute </a>，只允许授权用户访问，用户未登录时重定向到登录页面。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="1f5d" class="mu lj iq mp b gy mv mw l mx my">/**<br/> * Private route to navigate over private routes<br/> * If not logged in - goes to login<br/> * If not admin but required - throws an error!<br/> */</span><span id="07e5" class="mu lj iq mp b gy na mw l mx my">class PrivateRoute extends React.Component {</span><span id="073f" class="mu lj iq mp b gy na mw l mx my">componentDidMount() {<br/>        this.props.dispatch(verifyToken())<br/>    }</span><span id="d25c" class="mu lj iq mp b gy na mw l mx my">logoutHandler() {<br/>        this.props.dispatch(logout())<br/>    }</span><span id="5a7c" class="mu lj iq mp b gy na mw l mx my">render() {<br/>        const {<br/>            isAuthenticated,<br/>            component: Component,<br/>            current_user,<br/>            ...props<br/>        } = this.props<br/>        if (this.props.isLoading) {<br/>            return &lt;Loading /&gt;<br/>        }<br/>        if (isAuthenticated &amp;&amp; !current_user) {<br/>            return null<br/>        }<br/>        return (<br/>            &lt;Route<br/>                {...props}<br/>                render={props =&gt;<br/>                    isAuthenticated<br/>                        ?<br/>                        &lt;main&gt;<br/>                            &lt;Header<br/>                              current_user={current_user}<br/>                              logout={this.logoutHandler.bind(this)}                     <br/>                            /&gt;<br/>                            &lt;Component {...props} /&gt;<br/>                        &lt;/main&gt;<br/>                        : (<br/>                            &lt;Redirect to={{<br/>                                pathname: '/login',<br/>                                state: { from: props.location }<br/>                            }} /&gt;<br/>                        )<br/>                }<br/>            /&gt;<br/>        )<br/>    }<br/>}</span><span id="227e" class="mu lj iq mp b gy na mw l mx my">const mapStateToProps = ({ auth }) =&gt; {<br/>    const current_user = auth.current_user;<br/>    const isAuthenticated = auth.isAuthenticated;<br/>    return {<br/>        isAuthenticated,<br/>        current_user,<br/>        isLoading: auth.isLoading,<br/>    }<br/>}</span><span id="15df" class="mu lj iq mp b gy na mw l mx my">export default connect(mapStateToProps)(PrivateRoute)</span></pre><p id="0fe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在组件挂载时，我们通过调度verifyToken操作来检查身份验证状态，然后将当前用户配置文件传递给应用程序的状态，或者重定向到登录页面。isLoading标志用于转换状态。</p><p id="667d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个容器，我们还添加了更多的功能，比如一个带有欢迎消息和注销链接的公共标题，当用户登录时，它将显示在所有页面上。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="ab22" class="mu lj iq mp b gy mv mw l mx my">/**<br/> * Header with greetings and links<br/> * <a class="ae ml" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {object} props <br/> */</span><span id="6ba8" class="mu lj iq mp b gy na mw l mx my">const Header = (props) =&gt; {<br/>    return &lt;header className="header"&gt;<br/>        &lt;p className="header__greeting"&gt;<br/>            &lt;span&gt;<br/>                Welcome<br/>                &lt;a className="header__link" href=""&gt;<br/>                    {props.current_user.first_name}<br/>                &lt;/a&gt;<br/>            &lt;/span&gt;<br/>        &lt;/p&gt;<br/>        &lt;p className="header__logout"&gt;<br/>            &lt;a className="header__link" href="" onClick={(e) =&gt; { e.preventDefault(); props.logout(); }}&gt;<br/>                Logout<br/>            &lt;/a&gt;<br/>        &lt;/p&gt;<br/>    &lt;/header&gt;<br/>}</span><span id="70b2" class="mu lj iq mp b gy na mw l mx my">export default Header</span></pre><p id="e2c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，这些路由容器是高阶组件，它们封装了一个通用的react-router路由组件，所以我们可以在主<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/blob/master/client/src/App.js" rel="noopener ugc nofollow" target="_blank">应用</a>文件中的应用路由中使用它们。所有公共和游客路线都在这里。</p><pre class="km kn ko kp gt mq mp mr ms aw mt bi"><span id="2929" class="mu lj iq mp b gy mv mw l mx my">const App = () =&gt; {<br/>    return &lt;Switch&gt;<br/>        &lt;GuestRoute exact path='/login'<br/>            component={LoginContainer}                       <br/>        /&gt;<br/>        &lt;PrivateRoute exact path='/' component={UserListContainer}/&gt;<br/>        &lt;PrivateRoute path='/todos/:userId'<br/>            component={TodoListContainer}<br/>        /&gt;<br/>    &lt;/Switch&gt;<br/>};</span></pre><h1 id="0cf1" class="li lj iq bd lk ll nb ln lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf bi translated">包扎</h1><p id="d078" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">在浏览完所有源代码示例后，让我们看看我们的应用程序实际上是如何工作的。</p><p id="cac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们运行应用程序并在浏览器中打开页面时——我们没有登录，PrivateRoute中的签入会将我们重定向到登录表单。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/dca0f48f7f001d3d22fdd9247085f85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*ZYUTDjmwEnwrGdsP.png"/></div></div></figure><p id="7d48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们输入来自<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt/blob/master/graphsrv/src/data/users.js" rel="noopener ugc nofollow" target="_blank">用户</a>数据源的一些有效凭证(电子邮件和小写的姓氏)，我们将登录并重定向到用户列表页面。</p><p id="7010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们向<em class="mz"> /login </em>端点发送一个请求，如果我们的凭证有效，它返回给我们一个有效的JWT认证令牌。你可以使用Chrome开发工具在本地存储中看到它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/79276b4413214365c138299f4255fb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nrIPZW_K878hNjAS.png"/></div></div></figure><p id="030d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您刷新页面时，令牌仍然在那里，您可以看到调用了verifyToken方法来获取有关当前登录用户的信息。令牌通过端点及其背后的令牌验证逻辑进行验证，我们的服务器将当前用户的配置文件发送回给我们。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/dac774db800be81651368b80f821218c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RZ9X6BqGR94RwiZ8.png"/></div></div></figure><p id="435b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的令牌过期或被删除，或者我们将其更改为无效内容，如:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/e44ef03b0c6543e26973401fb07c9512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dh3TCZMivZeMoLps.png"/></div></div></figure><p id="ef1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将看到错误消息，GraphQL API请求将返回未授权的401 HTTP响应，因为令牌验证失败。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2c16c699140a6e8987ee6b3e56a9d7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/0*bOAhQxL3ZT0r1qOV.png"/></div></figure><p id="450f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们登录时，我们的应用程序应该像往常一样工作，直到我们执行注销，此时令牌将从localStorage中删除，我们将再次重定向到登录页面。要使用JWT注销，您只需从客户端移除您的令牌。</p><p id="1d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们如何在前端使用React + Redux在Node JS中使用GraphQL API进行JWT认证。希望有所帮助。随意克隆<a class="ae ml" href="https://github.com/KilroggD/GraphQL-redux-jwt" rel="noopener ugc nofollow" target="_blank">库</a>并运行/测试/修改它。</p><p id="ecfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这差不多就是本教程的内容。:)</p></div></div>    
</body>
</html>