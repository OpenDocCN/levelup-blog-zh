<html>
<head>
<title>Data Preprocessing — Machine Learning with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据预处理—使用Python进行机器学习</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/machine-learning-with-python-d99f13a9e395?source=collection_archive---------9-----------------------#2020-03-06">https://levelup.gitconnected.com/machine-learning-with-python-d99f13a9e395?source=collection_archive---------9-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/68c8b5181de7436a68c6cc9f3ff03fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHd4Z6fYslacjk-CXsSy-Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">【https://www.flickr.com/photos/mikemacmarketing/30212411048 T4】</figcaption></figure><p id="747e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近几个月，我一直在从事<em class="le"> R </em>和<em class="le"> Python </em>的机器学习工作，也选修了几门课程。我注意到我所有的程序都有一个共同点，那就是对数据进行预处理，以便应用机器学习模型。大多数情况下，数据预处理过程分为以下步骤:</p><ul class=""><li id="e816" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">导入数据集</li><li id="aa0b" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">完成缺失的数据</li><li id="8337" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">编码分类数据</li><li id="577a" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">分割数据集</li><li id="dec1" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">特征缩放</li></ul><h2 id="4918" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">导入数据集</h2><p id="fe2a" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">有几种方法可以导入<em class="le">数据集</em>。最简单的方法是从一个<code class="fe mr ms mt mu b">.csv</code>文件导入<em class="le">数据集</em>。为此，您必须执行以下操作:</p><p id="0c57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，您必须导入必要的库来处理数据:</p><pre class="mv mw mx my gt mz mu na bn nb nc bi"><span id="5264" class="nd lu it mu b be ne nf l ng nh">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd</span></pre><p id="c7bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦你建立了工作目录，你必须导入<code class="fe mr ms mt mu b">dataset</code> <em class="le"> : </em></p><pre class="mv mw mx my gt mz mu na bn nb nc bi"><span id="f2de" class="nd lu it mu b be ne nf l ng nh">dataset = pd.read_csv('Data.csv')</span></pre><pre class="ni mz mu nj nk aw nl bi"><span id="b14f" class="lt lu it mu b gy nm nn l no nh">The command <!-- -->pd.read_csv('filename')<!-- --> receives different optional parameters, you will have to use some of them depending on how your dataset is arranged on the <em class="le">.csv</em> file. You can set the <!-- -->sep<!-- --> parameter to indicate the separator on your file. For instance:</span><span id="ec5e" class="lt lu it mu b gy np nn l no nh">dataset = pd.read_csv('Data.csv', sep = ';')<br/># sep = ';' indicates that the separator between each data is ;</span></pre><p id="501a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们加载了数据集，我们需要通过以下操作将自变量从因变量中分离出来:</p><pre class="mv mw mx my gt mz mu nj nk aw nl bi"><span id="a9e1" class="lt lu it mu b gy nm nn l no nh">X = dataset.iloc[:, :-1].values # We take all the feature columns (we exclude the last one)<br/>Y = dataset.iloc[:, 3].values # We take the dependent variables</span></pre><h2 id="28e5" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">完成缺失的数据</h2><p id="4ae7" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">填写缺失数据是可选的。如果你的<em class="le">数据集</em>是完整的，你显然不需要做这部分。但是有时您会发现<em class="le">数据集</em>缺少一些单元格，在这种情况下，您可以做两件事:</p><ul class=""><li id="b84c" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">删除一整行(不推荐，您可能会删除关键信息)。</li><li id="acb8" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">用该列含义来完成所缺的信息。</li></ul><p id="45e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拿下面这个不完整的<em class="le">数据集</em>，</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f37e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，有一些缺失的单元格，一个在<strong class="ki iu">年龄</strong>列，另一个在<strong class="ki iu">收入</strong>列。为了用每列的<strong class="ki iu">平均值</strong>填充这些缺失的单元格，您必须遵循以下步骤:</p><ol class=""><li id="4e49" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld ns ll lm ln bi translated">从<code class="fe mr ms mt mu b">scikitlearn</code>进口<code class="fe mr ms mt mu b">Imputer</code>。这将有助于我们填补缺失的数据。</li></ol><pre class="mv mw mx my gt mz mu nj nk aw nl bi"><span id="b6ee" class="lt lu it mu b gy nm nn l no nh">from sklearn.preprocessing import Imputer </span></pre><p id="911c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.我们需要实例化导入类的一个对象。</p><pre class="mv mw mx my gt mz mu nj nk aw nl bi"><span id="6a53" class="lt lu it mu b gy nm nn l no nh"># NaN = not a number<br/># The default strategy is mean, so you can ommit it<br/>imputer = Imputer(missing_values = 'NaN', strategy = "mean", axis = 0)</span><span id="0a2b" class="lt lu it mu b gy np nn l no nh">imputer = imputer.fit(X[: , 0:2])<br/>X[:, 0:2] = imputer.transform(X[:, 0:2])</span></pre><p id="7f11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经检查了每一列上是否有空单元格。如果有，那么空单元格将被替换为列的平均值。</p><p id="dee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出如下所示，</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e2aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然数据已经完成，我们可以进入下一步。</p><h2 id="c344" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">编码分类数据</h2><p id="1979" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这一步也是可选的。根据您的<em class="le">数据集</em>，您可能从一开始就有一个已经编码了分类数据的<em class="le">数据集</em>。那样的话，你就不需要这么做了。</p><p id="99f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，我们有<strong class="ki iu">毕业生</strong>列，这个列有两个可能的值，或者是<strong class="ki iu">是</strong>或者是<strong class="ki iu">否</strong>。为了能够处理这些数据，我们必须对其进行编码，这意味着将标签改为数字。在<em class="le"> Python </em>中做到这一点非常简单，你只需要做以下事情:</p><pre class="mv mw mx my gt mz mu nj nk aw nl bi"><span id="9ad3" class="lt lu it mu b gy nm nn l no nh">from sklearn.preprocessing import LabelEncoder<br/>label_encoder_y = LabelEncoder()<br/>Y = label_encoder_Y.fit_transform(Y)</span></pre><p id="85c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出如下所示:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="c586" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">分割数据集</h2><p id="85d8" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这一部分是强制性的，也是使用机器学习模型时最重要的部分之一。</p><p id="d61a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分割<em class="le">数据集</em>意味着你要将整个数据集分成两部分，即<em class="le">训练集</em>和<em class="le">测试集</em>。当你想训练一个模型去解决或者预测一个特定的事情，你首先要训练你的模型，然后测试这个模型是否在做一个正确的预测。</p><p id="876c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常比例为80% <em class="le">训练集</em>和20% <em class="le">测试集</em>，但可能会因您的型号而异。我们将按照这个比例分割数据集。</p><p id="589c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您首先必须安装以下库:</p><pre class="mv mw mx my gt mz mu nj nk aw nl bi"><span id="dfbe" class="lt lu it mu b gy nm nn l no nh">from sklearn.cross_validation import train_test_split</span></pre><p id="93b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是将<em class="le">数据集</em>分成测试和训练集。为此，请键入以下内容:</p><pre class="mv mw mx my gt mz mu nj nk aw nl bi"><span id="1c19" class="lt lu it mu b gy nm nn l no nh">X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2)</span></pre><p id="6d8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然数据已经分割，我们可以继续进行最后一步。</p><h2 id="657a" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">特征缩放</h2><p id="bb0a" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这最后一步也不总是必要的。在数据集中，有一些值不在同一个范围内，例如，年龄和收入具有非常不同的范围。</p><p id="25d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数机器学习模型使用两点之间的<a class="ae kf" href="https://hlab.stanford.edu/brian/euclidean_distance_in.html" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>工作，但是由于尺度不同，两点之间的距离可能是巨大的，这可能会给你的模型带来问题。</p><p id="ec5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有些模型已经处理了这一点，因此您不必自己动手，但其他一些模型要求您先对要素进行缩放。为了扩展我们的数据，我们必须运行以下代码:</p><pre class="mv mw mx my gt mz mu nj nk aw nl bi"><span id="165e" class="lt lu it mu b gy nm nn l no nh">from sklearn.preprocessing import StandardScaler<br/>scale_X = StandardScaler()<br/>X_train = scale_X.fit_transform(X_train)<br/>X_test = scale_X.transform(X_test)</span></pre><p id="65ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码的分类数据呢？我们也需要扩展它吗？</p><p id="96a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有人说对分类数据进行缩放是有用的，有人说没有必要。我实验过的是，没那么重要，看你自己。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="11f3" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">结论</h2><p id="fd39" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">在多次完成所有这些数据预处理步骤之后，您会注意到，如果您的数据从一开始就准备充分，那么其中的一些步骤可以省略。</p><p id="4055" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么所有这些步骤都很重要？机器学习最关键的部分之一是拥有一个准备充分且值得信赖的<em class="le">数据集。以正确的方式准备你的信息是拥有一个好的机器学习模型的又一步。</em></p></div></div>    
</body>
</html>