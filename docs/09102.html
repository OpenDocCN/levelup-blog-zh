<html>
<head>
<title>Best Practices for Writing Brilliant Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写优秀单元测试的最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/top-best-practices-for-writing-brilliant-unit-tests-3af3e9ddce79?source=collection_archive---------1-----------------------#2021-07-06">https://levelup.gitconnected.com/top-best-practices-for-writing-brilliant-unit-tests-3af3e9ddce79?source=collection_archive---------1-----------------------#2021-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8eb8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这可以最大化你的单元测试套件的好处。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ebb4b9d09ced4477e93745be6181da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xDs2Wj6dG1wTSS_m"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的单元测试有助于软件开发人员发现在重构、修复bug或将新功能集成到现有代码库中时可能会意外出现的回归问题。</p><p id="2acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个有用的单元测试套件有许多最佳实践，我们将看看几个重要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="72e8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单元测试符合F.I.R.S.T</h1><p id="24b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">整个套件的执行时间应该是<strong class="lb iu">快</strong>几秒钟，而不是几分钟。缓慢的测试将增加开发人员重构逻辑所需的时间，因为他们经常运行整个测试套件以确保没有新的回归问题。此外，慢速测试会降低构建管道的执行时间。</p><p id="af3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试应该是相互独立的，也就是说，它们不应该共享状态。如果一个测试在共享内存中存储了一些数据，而下一个测试依赖于这些数据，那么就不可能只运行第二个测试或者并行运行测试。</p><p id="7d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果单元测试仅仅依赖于一个代码，而不依赖于诸如数据库、文件系统或其他外部因素，那么它们就是可重复的。这确保了单元测试不需要预先设置，并且在任何环境下都能产生相同的结果。</p><p id="cafa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">自验证</strong>单元测试在测试执行后产生一个布尔值，指示测试是通过还是失败。开发者通常通过使用<code class="fe mz na nb nc b">AreEqual, IsTrue, Greater</code>等方法来实现。开发人员不应该通过阅读日志或类似的东西来找出测试执行的结果。</p><p id="3a57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试套件应该随着应用程序代码的发展而发展。测试应该以<strong class="lb iu">及时</strong>的方式编写，而不仅仅是在投入生产之前。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e3f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单元测试中缺乏非确定性</h1><p id="80da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试中的不确定性意味着对于测试中的相同逻辑，单元测试有时通过，但有时失败。</p><p id="65d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了找到非确定性行为的根本原因，开发人员需要仔细检查单元测试代码和测试中的逻辑。开发人员应该看看非确定性行为最常见的来源:<code class="fe mz na nb nc b">DateTime</code>对象或缺乏线程同步。</p><h2 id="a17c" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">日期时间对象</h2><p id="cb59" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个使用<code class="fe mz na nb nc b">DateTime</code>如何产生非确定性测试结果的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果代码在一个节拍内运行得非常快，单元测试就可以通过，否则测试就会失败。</p><p id="3512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题出在测试本身的逻辑中，因为对<code class="fe mz na nb nc b">DateTime</code>对象的使用是硬编码在<code class="fe mz na nb nc b">User</code>类中的。</p><p id="70be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以修复非确定性，并且都需要重写<code class="fe mz na nb nc b">User</code>类。</p><p id="29b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个选项是将<code class="fe mz na nb nc b">DateTime</code>实例作为构造函数参数传递给<code class="fe mz na nb nc b">User</code>类。在这种情况下，单元测试确定在<code class="fe mz na nb nc b">User</code>对象和<code class="fe mz na nb nc b">AreEqual</code>方法中都传递了同一个<code class="fe mz na nb nc b">DateTime</code>实例。</p><p id="546a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个选择是实现包装<code class="fe mz na nb nc b">DateTime</code>类型的<code class="fe mz na nb nc b">IDateTimeProvider</code>接口。</p><h2 id="b03d" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">缺少线程同步</h2><p id="38e9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在下面的示例中，不确定性是由映射逻辑中缺少线程同步引起的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a2d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时输出集合的长度与输入集合的长度相同，但有时长度会有所不同，因为在向<code class="fe mz na nb nc b">output</code>集合中添加项目时缺少线程同步。</p><p id="c06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使单元测试具有确定性，您需要通过添加关键部分或使用并发集合来修复映射逻辑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d43f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不测试类实现细节</h1><p id="dc65" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在用单元测试覆盖某个类之前或期间(以防你不使用TDD ),最好确保<strong class="lb iu">类实现细节被正确封装</strong>,这样单元测试就不会测试类实现细节。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a00a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您当然可以为<code class="fe mz na nb nc b">NormalizeComment</code>方法编写一个单元测试。但是在这种情况下，您的应用程序将至少有一个测试封装不良的逻辑的坏单元测试。</p><p id="967c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">NormalizeComment</code>方法是<code class="fe mz na nb nc b">Comment</code>类的实现细节，但是它错误地暴露给了应该记得调用它的客户端。</p><p id="ea44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编写单元测试之前，可以对外界隐藏<code class="fe mz na nb nc b">Comment</code>类的实现细节，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么单元测试就会容易写得多，更简洁，更容易维护。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在无需修改单元测试就可以更改类实现细节，因为它只测试<code class="fe mz na nb nc b">Comment</code>类的公共API。</p><h2 id="aef9" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">测试私有方法</h2><p id="0808" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关于单元测试的一个误解是私有方法应该被单元测试覆盖，而不仅仅是公共方法。但这只是一种误解。</p><p id="2ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">私有方法、属性和其他私有成员是类的实现细节，不应该直接测试。唯一需要测试的是类的<strong class="lb iu">公共API </strong>。当测试公共方法时，私有方法将被单元测试间接覆盖。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0fcb00ff5fa74a53fc5e66a74dbf0191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*6pQztpR9MIdEX6PoPUxRng.png"/></div></figure><p id="2dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试公共API时，唯一要确保的是它具有完整的行和分支覆盖，这反过来又为所有私有方法提供了完整的覆盖。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b7a3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单元测试套件是构建管道的一部分</h1><p id="d593" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个项目可以有一个理想的单元测试集，它覆盖了项目的整个代码库的所有可能的边缘情况，符合F.I.R.S.T .原则，并根据编码和单元测试最佳实践编写。</p><p id="bf4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在集成到构建服务器的持续集成管道中之前，这样一个理想的单元测试套件不会有太大的好处。</p><p id="6171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Fail-fast" rel="noopener ugc nofollow" target="_blank">快速失败</a>是可以应用于软件工程各个方面的基本原则之一。设计为快速失效的系统充分利用了尽快检测和报告问题的能力。有了Fast Fail，在生产环境中发生严重问题的可能性就会低得多，因为它们会在QA、DEV甚至本地环境中被发现。</p><p id="f2d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果至少有一个单元测试是红色的，持续集成管道应该单元测试套件和失败构建。否则，就违反了快速失败原则，因为不能保证开发人员会在创建拉请求之前手动运行测试。失败的单元测试及其在应用程序逻辑中的相关bug可能会悄悄地进入生产环境。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="80d1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><ul class=""><li id="b5ce" class="ns nt it lb b lc mu lf mv li nu lm nv lq nw lu nx ny nz oa bi translated">单元测试应该是快速的、独立的、可重复的、自我验证的，并且及时编写。</li><li id="d563" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">测试中的不确定性通常是由测试逻辑中的<code class="fe mz na nb nc b">DateTime</code>使用或缺乏线程同步引起的。</li><li id="6dc7" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">应该只测试类的公共API，而不是实现细节。</li><li id="b31c" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">单元测试必须集成到构建管道中，这样如果存在bug，应用程序可以快速失败。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="adc7" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">我的其他文章</h2><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/the-simplest-explanation-of-adapter-design-pattern-cd37f02bfecd"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">适配器设计模式的最简单解释</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">C#中的真实世界示例</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://medium.com/geekculture/dont-let-your-enterprise-project-become-a-legacy-d282acfdf212" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">每个企业项目都是遗产吗？</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">如何不让项目变成遗产？</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">medium.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/develop-these-few-habits-to-become-an-outstanding-software-engineer-8117a155af77"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">养成这几个习惯，成为一名优秀的软件工程师</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">你所需要的只是纪律。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>