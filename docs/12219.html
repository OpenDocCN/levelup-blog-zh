<html>
<head>
<title>Concurrency in Golang, Goroutines, and Channels Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang、Goroutines和Channels中的并发性解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/concurrency-in-golang-goroutines-and-channels-explained-55ddb5e1881?source=collection_archive---------2-----------------------#2022-05-24">https://levelup.gitconnected.com/concurrency-in-golang-goroutines-and-channels-explained-55ddb5e1881?source=collection_archive---------2-----------------------#2022-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ccb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go中的主并发</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/169213d679390f6127329ac900d540e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlz9v7VdJDf7O-bCz14vIw.png"/></div></div></figure><p id="6465" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go是一种强大的语言，因为它有效地处理了几件事情，其中一件使它迷人和强大的事情是它如何处理并发。</p><p id="f8ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将全面解释并发的核心概念，以及Golang完成并发程序所遵循的方法。</p><h2 id="eeb3" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated"><strong class="ak">让我们从定义什么是并发开始:</strong></h2><p id="142c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果一个程序可以同时处理多个任务，那么它就被认为是并发的。并发性的概念包括程序同时运行几个操作的能力，即使这并不一定意味着这些操作同时明确运行，每个任务可以在不同的时间点开始。让我们看一张图来更好地理解并发操作是什么样子的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/98b48265b91e707941df7250d790552a.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*juuQ-GGhJ4iXAUW8NWzt6Q.png"/></div></figure><p id="87c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些操作可能不会同时开始，但它们会同时运行。这意味着一个任务不必等到另一个任务完成后才运行。</p><p id="64fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，如果你的程序同时运行多个操作，这意味着它们在相同的时间点开始，这将被认为是并行。当使用并发时，你的程序也可以实现并行，这取决于用例。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="e655" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">Golang并发模型</h2><p id="021d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Golang使用<strong class="kw iu"> goroutines来处理并发。</strong> A <strong class="kw iu"> </strong> goroutine由Go运行时管理，与线程非常相似，但有几个优点。Goroutines允许您同时运行多个操作。在多线程环境中，为了同时运行各种操作，操作系统必须创建新的线程，这涉及到大量的资源、内存和时间，因此使用线程同时运行多个操作对于操作系统来说成本更高。另一方面，goroutine是轻量级的、高效的，并且创建它不需要太多的资源，在Go中创建数百个Go routine不成问题。</p><h2 id="7c8d" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">与goroutines共享资源</h2><p id="83ec" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当运行多个go routine来完成不同的任务时，您通常会发现go routine需要访问和修改共享资源，如果多个go routine同时访问和修改相同的数据，这将导致几个问题、意想不到的结果和所谓的竞争条件。</p><p id="4e55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们在并发程序的上下文中定义什么是竞争条件。</p><p id="6b69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当同时运行的多个操作试图同时读取/写入相同的数据时，就会发生争用情况。</p><p id="9c9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了避免这种情况，golang使用了锁，这样一次只有一个goroutine可以修改特定的数据。这是一个非常重要的话题<br/>,因为实现并发性的一个关键因素是确保你的程序不会以意想不到的结果告终。</p><p id="13b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们编写第一个并发程序，看看如何使用go关键字创建一个goroutine:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2b8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们有一个main函数，它只在第6行打印一条消息，当程序运行时，它会创建一个所谓的主goroutine，这个goroutine是在运行程序时自动创建的，它是执行所有代码的地方，但是如果您想在一个单独的goroutine中运行另一个操作，我们可以在我们想要并发运行的函数之前使用<strong class="kw iu"> go </strong>关键字，这将有效地创建一个新的goroutine并运行那个函数。</p><p id="8fd0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第8行，我们告诉程序为<strong class="kw iu"> countNumbers </strong>函数创建一个新的goroutine。然后回到主要的goroutine，在第10行有另一个print语句。</p><p id="5e2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，为什么我们看不到<strong class="kw iu"> countNumbers </strong>函数中的打印语句呢？。这是因为主程序不会等待其他程序完成它们的工作，主程序会继续执行主程序，它会终止而不会等待其他程序完成。</p><p id="d93b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了让<strong class="kw iu"> countNumbers </strong>函数结束，我们可以在第9行的主go例程中休眠1秒钟。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="74ee" class="lq lr it mz b gy nd ne l nf ng">time.Sleep(1 * time.Second)</span></pre><p id="5fd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您再次运行该程序，您将看到现在的打印语句，这种解决方案在任何并发程序中都不理想，因此我们将在后面看到如何使用通道来实现这一点。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="4dc1" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated"><strong class="ak">什么是渠道？</strong></h2><p id="548c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">通道是不同goroutines之间的一种通信方式。这是将一种数据类型的值发送到另一个goroutine的安全方式。通道是通过引用传递的，这意味着当创建一个通道并将其传递给其他函数时，这些函数将具有指向同一通道的相同引用。如果你理解指针是如何工作的，这对于理解通道来说可能很简单。</p><p id="eec7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只有当通道具有相同的类型时，我们才能比较它们，正如我前面提到的，因为它们是通过引用传递的，如果两个通道都指向内存中的同一个引用，那么两个通道之间的比较将为true。我们也可以将一个通道与nil进行比较。</p><p id="7f1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通道的目的是允许go routine发送和接收信息，但通常它们也用于通知其他go routine<br/>某个进程已经完成，并且不一定通过通道发送任何信息。</p><p id="2653" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个通道也可以被关闭，这意味着它将不再接受任何发送或接收的消息，如果一个goroutine试图从一个关闭的通道发送或接收消息，程序将会崩溃，除非我们使用一个特殊的语法从通道中读取，或者我们使用一个范围循环。我们马上会看到这是如何工作的。</p><h2 id="3449" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated"><strong class="ak">频道类型</strong></h2><p id="d412" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu">无缓冲通道:</strong>这种类型的通道只允许发送一条数据，并阻塞当前的goroutine，直到另一条在通道上执行接收操作。如果在发送操作之前执行通道上的接收操作，也会发生同样的情况，执行接收操作的goroutine将被阻塞，直到另一个goroutine通过相同的通道发送消息。</p><p id="7e8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了演示使用无缓冲通道时的阻塞概念，我们来看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d887" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行前面的示例将输出以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4017003724a9dfbb3b73901a2ef93e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*LtwfPSwiQM5EB4lM9mSfBg.png"/></div></figure><p id="6829" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来了解一下输出。当程序启动时，会创建一个空的用户对象，并在第36行和第37行分别创建一个boolean类型的通道(无缓冲通道)，然后在第39行创建一个goroutine，这意味着该函数中的这段代码将在一个单独的goroutine中运行。</p><p id="2351" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">主goroutine继续执行，在第49行我们有一个print语句，然后在第二个goroutine中，由于它此时正在并发运行，它到达第40行，也执行一个print语句。</p><p id="524c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">主goroutine继续调用方法<strong class="kw iu">import posts</strong>并执行另外两个print语句，最后一个是<code class="fe ni nj nk mz b">[Main-Goroutine] — — -waiting------</code>，这是我们之前讨论过的阻塞概念发挥作用的地方，在第53行我们看到主goroutine正在从<code class="fe ni nj nk mz b">done</code>通道读取，这基本上意味着主goroutine不会继续执行，直到第二个goroutine向该通道发送消息。</p><p id="2755" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第二个goroutine中，调用<strong class="kw iu"> buildUser </strong>函数并打印<code class="fe ni nj nk mz b">[Second-GoRoutine] Finished Building User</code>，然后在下一行中，它向通道发送一条消息。此时，主goroutine将检测到这一点，并将继续执行，第二个goroutine也是如此。</p><p id="525c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">方法<strong class="kw iu"> mergeUserPosts </strong>和<strong class="kw iu"> setDefaultTags </strong>分别在main和second goroutine中被调用，我们得到它们对应的日志。</p><p id="9735" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们到达第57到60行时，用户和它的文章被打印出来，但是如果你检查用户结构中的标签数组是空的。原因是在第二个goroutine向主goroutine发送消息之后，两个goroutine继续并发执行，正如我前面提到的，主goroutine不会等到其他goroutine完成执行，也就是说，在主go routine完成之前，第二个go routine没有完成将用户标记附加到结构中的工作，这就是数组为空的原因。如果我们删除第91行，我们将能够看到标签数组现在已被填充。</p><p id="ed18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这个例子，我们了解了如何使用内置的make函数创建一个无缓冲通道。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="ab27" class="lq lr it mz b gy nd ne l nf ng">done := make(chan int)</span></pre><p id="55e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以及如何从信道发送和接收数据</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="7d60" class="lq lr it mz b gy nd ne l nf ng">done &lt;- true // send<br/>&lt;-done // receive ignorting value<br/>resp := &lt;-done // receive storing value in a variable</span></pre><p id="3619" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们还看到了如果没有其他goroutine通过通道发送/接收消息，goroutine是如何阻塞执行的。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="ffcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将一个goroutine的结果用作另一个go routine的参数，通道也被用作连接多个go routine的一种方式。</p><p id="b73a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看下一个例子，这次使用多个goroutines。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b509" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此示例的输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/778c6811fc45158440502f7a0d172f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbFu2F_nmn0IUO-LlxGp-w.png"/></div></div></figure><p id="9191" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们有两个通道<strong class="kw iu"> usersToUpdate </strong>和<strong class="kw iu"> userToNotify </strong>，注意第一个通道是如何接受用户数组的，而第二个通道只接受一个用户对象。然后有两个用户数组，一个用于现有用户，一个用于新用户。</p><p id="528c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一个goroutine中，我们发送了<strong class="kw iu">userstouupdate</strong>通道<strong class="kw iu"> </strong>和<strong class="kw iu"> newUsers </strong>的片，所以当程序运行到第40行时，一个新的goroutine被创建。</p><p id="d849" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<strong class="kw iu"> filterNewUsersByStatus </strong>函数中<strong class="kw iu"> usersToUpdate </strong>参数的语法。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="b0e2" class="lq lr it mz b gy nd ne l nf ng">usersToUpdate chan&lt;- []*User</span></pre><p id="4ced" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，通道是<strong class="kw iu">双向的</strong>，这意味着您可以通过它们发送和接收信息，但是当将通道传递给函数时，您可以改变这种行为，并告诉通道在函数的上下文中它只服务于一个目的，要么接收信息，要么发送信息。</p><p id="acaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以在这种情况下，我们告诉通道<strong class="kw iu"> usersToUpdate </strong>在这个函数的上下文中，这个通道将只接受发送信息而不接收它。</p><p id="74c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该功能<strong class="kw iu"> filterNewUsersByStatus </strong>在<strong class="kw iu">新用户</strong>的范围内，仅选择那些活动的并且启用了通知设置的用户。此后，在第54行中，通过信道发送经<strong class="kw iu">过滤的用户</strong>。</p><p id="1a80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，该通道将不再用于发送数据，因此关闭该通道非常重要。在这种情况下，我们使用<strong class="kw iu"> defer </strong>函数调用内置的<strong class="kw iu"> close </strong>函数，关闭<strong class="kw iu">userstouupdate</strong>通道。</p><p id="385b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第二个goroutine中，我们发送<strong class="kw iu">用户更新</strong>通道、<strong class="kw iu">用户通知</strong>通道和<strong class="kw iu">现有用户</strong>片。这就是使用一个通道的结果作为另一个goroutine的输入的概念发挥作用的地方。</p><p id="e4ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在该功能中，我们还为每个通道定义了它是否将用于接收信息或发送信息，<strong class="kw iu"> usersToUpdate </strong>将仅用于接收数据，<strong class="kw iu">userton notify</strong>用于发送数据。</p><p id="f878" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第59行，该函数首先更新了现有的用户，为每个用户添加了一个新的标签。然后在第63行，它创建了一个新变量，并将其赋给了<strong class="kw iu"> usersToUpdate </strong>通道的结果。该行将阻止这个goroutine的执行，直到通道发送消息。换句话说，如果<strong class="kw iu"> filterNewUsersByStatus </strong>花费大量时间来发送<strong class="kw iu"> filteredUsers </strong>，那么这个goroutine将不得不在这个队列中等待，然后才能继续。</p><p id="58d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦接收到数据，该goroutine将覆盖<strong class="kw iu">新用户</strong>并更新他们的标签，还会通过<strong class="kw iu">usertonnotify</strong>通道在线路68中发送用户。</p><p id="0d4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个函数完成工作后，<strong class="kw iu"> userToNotify </strong>也需要被关闭，所以在第58行我们有一个<strong class="kw iu">延迟</strong>来关闭通道。</p><p id="134a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后在第42行，有一个函数在主goroutine中被调用，它将通知用户，它将<strong class="kw iu">usertonnotify</strong>通道和<strong class="kw iu"> existingUsers </strong>作为参数。</p><p id="4598" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数首先初始化一个发送通知的服务，然后覆盖现有用户，并向每个用户发送电子邮件通知。</p><p id="05c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后在第78行，它覆盖了<strong class="kw iu"> userToNotify </strong>通道，对于通过该通道发送的每个用户，该函数向该用户发送一个电子邮件通知。这个语法允许我们接收通过这个通道发送的所有信息，一旦通道关闭，for循环也将中断。这将阻止我们从一个封闭的通道中阅读，正如我之前提到的，这是确保你不从一个封闭的通道中阅读的一种方法。另一种语法如下:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="090a" class="lq lr it mz b gy nd ne l nf ng">resp, ok := &lt;-userToNofity</span></pre><p id="7535" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们从一个封闭的通道中读取，那么<code class="fe ni nj nk mz b">ok</code>变量将为假，否则为真，但是它不会死机。</p><p id="a431" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您在这个示例中看到的，这些函数将并发运行，它们使用通道相互通信，发送关于已过滤用户和要通知的用户的信息。</p><p id="91b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本例中，我们学习了如何使用延迟和关闭功能关闭通道。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="3186" class="lq lr it mz b gy nd ne l nf ng">defer close(done)</span></pre><p id="06cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，当一个通道被传递给一个函数时，如何使它单向</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="9471" class="lq lr it mz b gy nd ne l nf ng">userToNotify &lt;-chan *User // read-only channel<br/>userToNotify chan&lt;- *User // send-only channel</span></pre><p id="1c39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们不知道有多少项目将通过一个渠道发送，但我们想阅读所有的项目时，这是非常有用的。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c086" class="lq lr it mz b gy nd ne l nf ng">for user := range userToNotify {}</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="7d5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">缓冲通道:</strong>这种类型的通道允许您存储容量指定的多条数据，当达到该容量时，发送到该通道的后续消息将被阻塞，直到至少一条消息被读取，以便该通道重新具有容量。</p><p id="c463" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要创建缓冲通道，我们只需向make函数传递一个附加参数:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="1248" class="lq lr it mz b gy nd ne l nf ng">ans := make(chan int, 5)</span></pre><p id="06f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该通道将接受5个整数而不阻塞goroutine，但是如果第6个整数被发送到该通道，那么它将阻塞，直到执行接收操作。如果通道为空并且执行了接收操作，也会发生同样的情况，它会一直阻塞，直到执行了发送操作。</p><p id="0c9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用于跟踪信道容量的数据结构是队列，这意味着第一个进入队列的元素将是第一个离开队列的元素。</p><p id="c793" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们使用下面的代码来研究这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d6e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的场景中，我们创建了一个容量为3的缓冲通道，这意味着它一次可以容纳3个字符串，而不会阻塞goroutine。在第10行中，创建了一个goroutine并传递了通道。该函数将向通道发送多个名称，每次发送之间的延迟为1秒，当发送完名称后，将使用defer关闭通道。</p><p id="7d1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在主goroutine中，有一个sleep函数调用来模拟主goroutine在从通道读取值之前执行另一个耗时5秒的操作。</p><p id="93af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看这段代码的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/694eabc39a87c5f9050cf1023301734c.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*dh5tis6-N55ZZfgXfghyRQ.png"/></div></figure><p id="3aca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，前3个名称被无阻塞地发送到通道，因为缓冲区的大小是3，但在此之后，第二个goroutine的执行将被阻塞，直到从通道中读取了至少一个元素，当主goroutine开始从通道中读取时，第二个goroutine将被解除阻塞，并继续发送其余的名称。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="99dc" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">关键要点</h2><ul class=""><li id="f043" class="nn no it kw b kx mj la mk ld np lh nq ll nr lp ns nt nu nv bi translated">使用goroutines加速你的围棋程序。</li><li id="cf93" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">使用make关键字创建无缓冲通道。</li><li id="6558" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">使用make关键字指定创建缓冲通道的容量。</li><li id="ead2" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">使用以下语法从通道读取数据<code class="fe ni nj nk mz b">resp := &lt;-names</code>。</li><li id="3917" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">使用以下语法向通道发送数据<code class="fe ni nj nk mz b">numbers &lt;- num</code>。</li><li id="06c9" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">使用循环范围读取发送到通道的所有数据。</li><li id="5130" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">使用defer和Close内置函数关闭通道。</li><li id="c4da" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">不同goroutines之间的阻塞概念。</li><li id="77ae" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">将双向通道更改为函数上下文中的只发送或只读通道。</li><li id="8c8c" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">使用通道在不同的goroutines之间进行通信。</li></ul><p id="2908" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在Golang中看到了很多与并发相关的概念。我希望你喜欢它，并从这篇文章中学到东西！</p><p id="5f1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读。敬请关注。</p><h2 id="0f6d" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">资源</h2><p id="2fe2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果您有兴趣了解更多关于Go的知识，下面的文章可能会有所帮助。</p><div class="ob oc gp gr od oe"><a href="https://betterprogramming.pub/implementing-interfaces-with-golang-51a3b7f527b4" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">用Golang实现接口</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">了解如何利用接口的力量</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">better编程. pub</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://betterprogramming.pub/go-api-design-with-protocol-buffers-and-grpc-991838e4852b" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">使用协议缓冲区和gRPC的Go API设计</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">基于社交媒体应用的分步指南</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">better编程. pub</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>