<html>
<head>
<title>Vue.js 3 Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js 3完整指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vue-js-3-complete-guide-8545454f2c4a?source=collection_archive---------2-----------------------#2021-09-02">https://levelup.gitconnected.com/vue-js-3-complete-guide-8545454f2c4a?source=collection_archive---------2-----------------------#2021-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c4f8289b9643ec5d3981386f02969803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kh2auCrasYHfqd662Zi27Q.png"/></div></div></figure><p id="bc02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue是一个渐进的框架。进步意味着Vue不会寻求对整个项目的独家控制。您可以轻松地将Vue与其他库或现有项目集成。</p><p id="6522" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue帮助我们构建用户界面。有两种类型的用户界面:命令行和图形。显然，Vue是用来构建图形用户界面的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kz"><img src="../Images/f81a4502b74062d0b8a8c5bbd226c174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOMthcbabB2iVVbtwAJCwA.png"/></div></div></figure><p id="3ae2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">图形用户界面的专业术语是视图。它是用户查看的内容，因此被命名为视图。它是使用HTML和CSS创建的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi le"><img src="../Images/b3230127bcfb4a03b71b32fdf76d89c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*VNvGPVAD5egUPUsHYrsJ3Q.png"/></div></figure><p id="ef61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">视图的主要工作是向用户展示数据。它还从用户那里收集数据和命令。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lf"><img src="../Images/4c26419affd04fcbccd3934594bde8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bc49wT8k9KK9padgzzLKHQ.png"/></div></div></figure><p id="e4d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">视图只是一个HTML文件。它只存储有限数量的静态数据，不能永久存储用户数据。我们需要一个数据库来为视图提供和存储数据。但问题是视图不能操作数据库。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lg"><img src="../Images/bfc8f713f54b4b3f85b70b86328f4657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Lml3jdgt8vgYfSiNmJ1Jg.png"/></div></div></figure><p id="831d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要一个中间人。中间的人被称为模型。它指的是操作数据库的后端程序。模型的主要工作是进行CRUD操作。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lh"><img src="../Images/76cd4f1b8b4add500f6a54d0613f0073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Jx225vTYwv-8EWl0eNvtA.png"/></div></div></figure><p id="7f4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CRUD代表创建、读取、更新和删除。它们是四种最常用的数据库操作。创建意味着将新数据保存到数据库中。读取意味着从数据库中检索数据。更新和删除意味着修改或删除数据库中的现有数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/d61700272e935aabb55efa28031a7b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bLzDGYmHJwEE1OFMnL3zg.png"/></div></div></figure><p id="c038" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然无法将视图与模型联系起来。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/3ecccb8606f0dece72d9f60ec8ada01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*364VQE4guIeepPsaUl_izw.png"/></div></div></figure><p id="42ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要第二个中间人，也就是控制者。控制器与双方交换数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lk"><img src="../Images/741a62c943545c770aac2f36e285d103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbG0bw7trEEb9cVftHwGWQ.png"/></div></div></figure><p id="e1cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据用户命令，控制器从模型中检索数据，并从视图中选择一个HTML模板。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ll"><img src="../Images/1ece27e51f6b514f2172d4f046a50dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aypENiqssDYgc7BwnVhimg.png"/></div></div></figure><p id="56f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检索到的数据将被注入HTML模板并呈现给用户。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lm"><img src="../Images/a7b196be6a369115407936202a0eef86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WvOMdxRKdT1rpXirnVUirQ.png"/></div></div></figure><p id="7cd0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种架构被称为MVC:模型视图控制器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ln"><img src="../Images/c7ae54315a49097c8db58f9cad5d21f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2NMGixUG1SQiIKP5_5Kkg.png"/></div></div></figure><p id="4a80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一个MVC架构的真实例子。</p><p id="bc9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是摘自CodeIgniter手册的一段示例代码。CodeIgniter是一个典型的MVC框架。控制器在左边。右边的文件是视图文件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/fee5ddac6a80180da1ea902660261923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9nKFlRgkEocnfR0lpBCHA.png"/></div></div></figure><p id="7fee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">View函数选择一个视图文件并将数据注入其中。然后，完成的视图文件将呈现给用户。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lp"><img src="../Images/b23c62913ed04ad443847a0649231a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMJZFcZ_BL_I7cyCn67g5A.png"/></div></div></figure><p id="5efe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">MVC开发出了一种新的架构。它叫做MVVM。控制器已经被视图模型所取代。ViewModel和视图通过双向数据绑定连接。那么什么是双向数据绑定呢？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ll"><img src="../Images/ed5f14408009aa9ecf147933bd0fe943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwcoDXCmAkVte3VJVfyeyg.png"/></div></div></figure><p id="8e82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">视图和视图模型是两个独立的程序。视图是使用HTML和CSS创建的。ViewModel是一个JavaScript程序，能够操作DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lq"><img src="../Images/bf5b5681955b5431b7a1dfa07ef57602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ewmOBDHkhTeIqLkMywwagw.png"/></div></div></figure><p id="5b05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ViewModel从模型端检索数据。在双向数据绑定下，检索到的数据会自动同步到视图端。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lr"><img src="../Images/fbdeb93ffec508036551162d822e7c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SM7VGxZ9av28GvEnJBvT9g.png"/></div></div></figure><p id="bee1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们在视图模型端修改数据，那么视图端的相应数据将会自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ls"><img src="../Images/9b6b15378ebce8b91999304e252b16f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sl4BODGOMBhWzqHtKuv7iQ.png"/></div></div></figure><p id="8f4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据是双向同步的，如果我们在视图端更新数据，ViewModel端的相应数据也会被更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lt"><img src="../Images/e18141a7f89ac913acd36d57092adc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOsIS8lLihSfrXVyXrkaNQ.png"/></div></div></figure><p id="fb43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么如何实现双向数据绑定呢？</p><p id="73c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设在视图模型端，我们有一个变量:城市。它的价值来自模型，我们希望通过视图向用户展示它的价值。该视图使用HTML标签显示数据。我们以P标签为例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lu"><img src="../Images/f00646e322b5af7b1762c7df6fec17be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8S1S1Y64iPbxjarFtO7bpA.png"/></div></div></figure><p id="f9a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">P标签主要使用它的内部文本来表示数据。HTML属性也存储数据。例如，我们给P标签一个标题属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/7cc8fae6dcb0c582761f0180ac482a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*tkKBjVH2zA-WcuShUX68lA.png"/></div></figure><p id="9df9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用city变量设置P标签的内部文本或标题属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lw"><img src="../Images/3724bae53278381e8b326b1bfdf8b773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zTmZ1E07fRodEYMkmIjMw.png"/></div></div></figure><p id="50d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要城市变量是反应性的。被动意味着如果我们设置了一个新的城市名称，P标签应该自动更新，没有任何延迟。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/70225acf375d022a5000eef19dd75762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvt5qgLcV5DWU1YJQnQgNw.png"/></div></div></figure><p id="77d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道如何实现这一点吗？</p><p id="9a84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免任何延迟，我们必须能够截取值分配，以便我们可以在最早的时间更新P标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/72f3a48cd55887143e294e5998cf52c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wvVZL34-ubrXRXpMHFQ6w.png"/></div></div></figure><p id="60df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">setter函数负责给变量赋值。我们定制setter并将DOM更新代码合并到其中。这样，当我们重新设置城市值时，P标签的DOM对象将会立即自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/3710d5676a08262a5fb718011230c960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i4mGJlLHukRnnak579NSmw.png"/></div></div></figure><p id="5835" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将数据从视图同步到视图模型意味着将用户数据提交到视图模型。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/aa4ca71782fe6739417339b9ed670fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*yqdF9zB4KhLZCxlZVwLJqA.png"/></div></figure><p id="5b76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">视图通过输入标签收集用户数据。每当我们在输入标签中输入一个字符，它就会发出一个输入事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/efa508d4a255ed8f48ba2a5db97bb101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCeZQn5qGpA0jsBQ1F7e9A.png"/></div></div></figure><p id="b31b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在ViewModel端，我们监听输入事件，并使用回调拦截用户提交的数据。这就是数据从视图端同步到视图模型端的方式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/2292348cea7b717de91941fee8f0daf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdxAVxGZEYXwugfACDl3CA.png"/></div></div></figure><p id="a020" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回调可以将用户提交的值赋给城市变量。这样，输入框可以实时更新P标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/ca9ceff542a312d14495eefa08727d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOuEp5m8DVOUympGnJAlQg.png"/></div></div></figure><p id="c6e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue是使用MVVM架构开发的。它扮演视图模型的角色，并且还构建视图。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/66089573eec1136bfab5aa352dcfc31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvPAkrvD42n1T-8ofNOQsA.png"/></div></div></figure><p id="aeae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ViewModel从模型中检索数据。然后，它使用定制的setter将检索到的内容同步到视图中。这个过程是自动发生的。我们不需要手动将数据注入视图模板。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mf"><img src="../Images/53925b09f6e4eced0c09d01ac6fad4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68OYnx8tP7msCr2vL0ACUg.png"/></div></div></figure><p id="edc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">视图通过输入标签从用户那里收集数据。ViewModel通过监视输入事件来捕获这些数据。然后，它将用户提交的数据传递给模型，以便将它们保存到数据库中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mf"><img src="../Images/54cc7d0d6903742ebcf28baa55514948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWOn-N-eE-x8jWrR_KWbCA.png"/></div></div></figure><p id="d5c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个视图模型与一个视图配对。ViewModel和它的视图一起构成了一个组件。视图也称为组件模板。组件是Vue项目的构建块。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/cb35ae86540fc58aa3745866c756a832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yq7WmOAQo6bFtjRBqUCKrA.png"/></div></div></figure><p id="eaec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个Vue项目必须有一个并且只能有一个根组件。在根组件中，我们可以根据需要安装任意数量的子组件。每个子组件都可以有自己的子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/b5a6b7d8de17e822d2738757f77e67e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sc_LjNWH8IgE4jiXLAQuFA.png"/></div></div></figure><p id="d9b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过切换和重新定位组件，我们可以生成不同的虚拟页面。每个组件负责最终页面的一个部分。整个程序是模块化的。未来的维护和调整变得更加容易。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/c0692127a65c4980e273692e83783a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oewe-f8Yg2D8UyZrAYhBkA.png"/></div></div></figure><p id="1aef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来看一个现实生活中的例子。这是Vue3的官方手册。这个页面是使用几个组件创建的。我们在左边有一个侧边栏，在右上角有一个导航栏。在中间，我们有一个主要区域。这些部分是独立的，可以单独维护。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/e5bde5c83e74d958338a1877f3f8d025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwdXfUDcJYPcrEV69piUag.png"/></div></div></figure><p id="8a9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在主区域中，我们有一个注释部分和一个提示部分。仔细看看这两个部分。找到相似之处了吗？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/8715f43467e9065835c3a39f08d5faa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQgr_bcP7OwrMKTCBfTzrw.png"/></div></div></figure><p id="c42e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">他们都有一个标题。标题下面，都有一段话。它们有相同的装饰和相同的背景颜色。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/08d088a00d8cef86eb6dc744073265c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BXnPqhrpdVK3BQBdeRQDQ.png"/></div></div></figure><p id="2f03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以只用同一个组件创建这两个部分。我们只需要安装两次，自定义标题和段落内容。Vue组件实际上是一个构造函数。它是预定义视图和视图模型的蓝图。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/3a42ce5d286eeac5e3ef148253f55e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_ijtSxelbRRhQEjwANtXA.png"/></div></div></figure><p id="6c74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们安装一个组件时，我们实际上是在创建该组件的一个实例。组件实例由视图实例和视图模型实例组成。同一组件的实例是独立的。这使我们能够定制组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/52b5be2b49228d0f23b40c616cdf546f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evZzjuFHHf8rsInNlYkYpQ.png"/></div></div></figure><p id="cc7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了保持每个组件实例的独立性，我们在定义组件时需要工厂模式。工厂模式本质上是一个返回对象的函数。每次运行工厂函数，都会收到一个独立的对象。它防止引用类型的值被共享。我们将在后面的课程中学习更多关于工厂模式的知识。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/99801c2c838f313c150505cfc4a64501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5R7VLKHH6Bgb0ddP76pnw.png"/></div></div></figure><p id="6bd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有Vue提供了一个视图和一个视图模型。这通常是不够的。我们可以使用插件来扩展Vue，赋予它更多的功能。VueRouter和VueX是两个必备的官方插件。没有理由不去学习它们。你还需要学习至少一个Vue UI库，这样你才能用最小的成本创建出好看的页面。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/804e1353c48062501505606919b19085.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*qcleygYs27LOI5NnW5398A.png"/></div></figure><p id="fe56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是我们的Vue路由器和VueX指南的链接:</p><div class="mp mq gp gr mr ms"><a rel="noopener  ugc nofollow" target="_blank" href="/complete-vue-router-4-guide-basics-programmatic-routing-navigation-guards-transition-effects-31b21a2f444d"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">完整的Vue路由器4指南:编程路由、防护、过渡效果和合成API</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">基础知识介绍</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jz ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a rel="noopener  ugc nofollow" target="_blank" href="/complete-vuex-4-guide-states-getters-mutations-actions-modules-plugins-and-composition-api-eff469c43b4f"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">完整的VueX 4指南:状态、Getters、突变、动作、模块、插件和组合API</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">Vue应用由一系列嵌套组件组成。我们在最外面有一个根组件。它有零或…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng jz ms"/></div></div></a></div><p id="62db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们学习了ViewModel使用定制的setter将数据同步到视图。定制的setter包含了DOM更新代码。因此，如果我们在ViewModel端修改数据，视图会自动更新。Vue2和Vue3在定制setter时采用了不同的方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/0de51753e13918813dda766a0c7ee9d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNzNCiUtqOOkCYNdjUOnag.png"/></div></div></figure><p id="a147" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将展示Vue2使用的策略。在工作面试中，你经常会被要求解释Vue2和Vue3的区别。</p><p id="f0c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个物体。它有一个属性:消息。我们首先获得H1标签的DOM对象。然后我们获取它的innerText属性，并将message属性赋给它。</p><p id="eb9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，消息属性的值显示在H1标记内。但这只是一次性绑定。如果我们重置消息值，H1标签保持不变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/21a6edfdd16371e8cf49270f2d155aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYHHxoC7bsLk6mU_-CeQwA.png"/></div></div></figure><p id="e1f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望让H1标签与消息属性保持同步。如果我们重置消息值，H1标签的内部文本应该立即自动更新。这就需要我们拦截消息属性的设置者。</p><p id="a795" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用对象点定义属性向info对象添加一个新属性。defineProperty方法允许我们设置自定义的setter和getter。我们将info对象作为第一个参数传递给defineProperty方法。第二个参数是新属性的名称。我们将其命名为reactiveMessage。第三个参数是一个对象。我们在这里设置自定义的getter和setter函数。setter函数接收分配给reactiveMessage属性的新值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/65dd37418ac5531d939a60632ec095b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4Xfx82bnWx5sE1sxp5ZwA.png"/></div></div></figure><p id="e212" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们读取reactiveMessage属性时，getter函数将被触发。它返回的值将被用作属性值。在这里，我们返回info点消息。这样，reactiveMessage将始终返回消息属性的值。info对象可以通过defineProperty方法的第一个参数来访问。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/eea9836d4602d1055b99c00af96bf035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-agC59YDd458gaM2uk4lRA.png"/></div></div></figure><p id="eb89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们为reactiveMessage属性分配一个新值时，setter函数将被触发。新值作为第一个参数传递给setter函数。我们将新值赋给信息点消息。这样，reactiveMessage属性可以重置消息属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/29f59a30ab666726754ba0fe8688adcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*1puS-a0uuMCnqXuqEu8CaA.png"/></div></figure><p id="499e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新的属性完成了。让我们检查info对象。</p><p id="dbf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到reactiveMessage属性已添加到其中。我们还可以从info对象的根级别找到它的getter和setter。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6c869630be2446bd0e79d06e53421e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*qXGC-OETydFFQKmkzHKh_g.png"/></div></figure><p id="315e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">reactiveMessage属性不是非常规属性。为了输出它的值，我们需要调用它的getter函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/40753b3e94e56317342412ebd51fe7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUdpBZQz7A0WH-jCDedO-g.png"/></div></div></figure><p id="5f6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它的getter函数返回了消息属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi gj"><img src="../Images/dc36d8cf518180b412a633d7235216f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3fC5QPuOp7aaev9IyqDHg.png"/></div></div></figure><p id="d7f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将消息值设置为apple，并再次检查info对象。</p><p id="f819" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到reactMessage的价值也变成了<em class="np">苹果</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/d9b0371af9335460094bcb084053b4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_InCZmchIOo9NJi3r5dxzw.png"/></div></div></figure><p id="6e5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将reactiveMessage的值重置为<em class="np">橙色</em>。该操作触发setter函数，该函数将<em class="np">橙色</em>分配给消息属性。</p><p id="6434" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到消息值变成了橙色。reactiveMessage属性也返回我们orange，这是消息属性的当前值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/3c215f3c315189ec1920dcf4b3807a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxZWT7KZ4SKm1aMUzNEUyw.png"/></div></div></figure><p id="6a39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">setter本质上是一个钩子函数，当我们给reactiveMessage属性赋一个新值时，它就会被触发。我们可以用它来更新H1标签的内部文本。我们选择H1标记的DOM对象，并使用分配给reactiveMessage属性的新值重置其innerText属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/7f415cb1f4102563cd18c50c27e6ee93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbFsmoETtp-AwdvaiHtSxg.png"/></div></div></figure><p id="ea65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，每当我们为reactiveMessage属性分配一个新值时，就会发生两件事。H1标签的内部文本将使用新值进行更新。那么新值将被分配给消息属性。这样，H1标签的内部文本与消息属性保持同步。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/95505f4bd216c60c94a560eac57cdc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CqFdq-AB2_j6D_cufmodg.png"/></div></div></figure><p id="249e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">整个计划:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/263741a1beda6ca4684e4e06623baae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKuEI3TMIoAnvQ_vD6tlGw.png"/></div></div></figure><p id="4517" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">reactiveMessage属性充当Message属性的代理。它帮助我们检索和重置消息属性的值。我们可以在其setter中更新DOM对象。这就是Vue2更新HTML代码的方式。它使用Object defineProperty方法拦截setter。</p><blockquote class="nt nu nv"><p id="323d" class="kb kc np kd b ke kf kg kh ki kj kk kl nw kn ko kp nx kr ks kt ny kv kw kx ky im bi translated">我知道你过去喜欢对象定义属性方法，但是我可以全心全意地支持ES6的一种新特性:代理和反射。</p></blockquote><p id="bf3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与其只为一个属性创建代理，为什么不为整个对象创建代理呢？</p><p id="f26f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们声明一个新变量，并将其命名为infoProxy。我们通过实例化代理构造函数来设置变量值。我们将info对象作为第一个参数传递给代理构造函数。信息对象被称为目标对象。它是我们正在创建的代理对象的目标。</p><p id="b360" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个参数是一个称为handler对象的对象。它定义了我们想要拦截和定制的操作。这个对象中的函数称为处理函数。这里，我们添加了一个getter和一个setter来拦截对代理对象属性的读写操作。请注意，getter和setter只在我们读取或修改代理对象的属性时才起作用。我们直接操作目标对象，他们不会有反应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/c967ffc6572626ea7a5fb619018bbe36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpSRsClqzhbmsZd4bUge6Q.png"/></div></div></figure><p id="a0d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">getter函数有三个参数。第一个是代理的目标对象。第二个是目标属性的名称。第三个名为接收器。它指向由代理构造函数创建的代理对象。通常，我们不会需要它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/b5f231d416d47a9d61f84a3e957cdc57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Px1i3g_WxWqoAod7-71p5Q.png"/></div></div></figure><p id="8bd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">setter函数接收四个参数。前两个参数仍然是目标对象和目标属性名。我们将第三个参数命名为newValue。它存储分配给目标属性的新值。最后一个仍然是指向代理对象的接收者。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/1327af859425aecff0c7b8f20672c6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QI4L8p9pDpayPrCLOskYUQ.png"/></div></div></figure><p id="24d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们输出目标对象和代理对象。乍一看，代理对象与目标对象非常相似。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/8c0b580cde0b326db30bd8eb975af84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*zgzDHhtKG96dv-8m23sv4g.png"/></div></figure><p id="0525" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果我们打开它，我们会发现代理对象是由两个对象组成的。第一个是处理程序对象。自定义处理函数存储在这里。此物品供内部使用。第二个对象是目标对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/b7b75651209ff9c174edba4ebc37957d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1utNSZNmpdw16SJUnAVrWw.png"/></div></div></figure><p id="baa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您在目标对象中看到的属性值可能不是您从代理对象中获得的实际值。得到什么取决于getter函数。</p><p id="3a53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过代理对象输出消息属性。该操作将被getter截获。我们得到的值取决于getter返回的内容。当前，getter为空。所以我们会变得不确定。setter也是空的。如果我们通过代理给消息属性分配一个新值，这个新值将不会到达目标对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/7ebc5486ddbdbeb6005a1d1202949139.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*NQJP23lJ1FrLkwGgmU7yzA.png"/></div></figure><p id="144f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">你要明白，当你读写一个代理对象的属性时，最终结果取决于getter和setter，这一点非常重要。</strong></p><p id="bd46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们完成getter函数，这样我们就可以从代理对象中读取属性。</p><p id="d7f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">getter本质上是一个钩子函数，当我们从代理对象中读取属性时就会被触发。它返回的值就是我们将获得的属性值。</p><p id="ec31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与只作用于一个属性的Object defineProperty方法不同，代理getter应用于目标对象的所有属性。</p><p id="1951" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目标对象的属性可以有各种各样的值。例如，我们添加一个数字属性，并将其值设置为10。然后我们定义一个测试方法。我们在控制台中记录了这一点。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/41140cf2319db66e918145bb2836890c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QGiVS6V0LczFJugN_jpSQ.png"/></div></div></figure><p id="3400" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有这些属性和方法都将被getter返回。所以如果你想返回一个修改过的值，你必须首先检查属性值的数据类型。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/cd00cf440e57866712a61ffc1f820daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D49G97Sk1Tx7vUF2BZHbCg.png"/></div></div></figure><p id="95cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在getter函数中，我们添加了一个IF语句。我们检查目标属性是否是字符串。如果是，我们首先返回原始属性值。然后我们用一个定制的字符串附加它。如果属性值不是字符串，我们返回原始属性值。我们不能将字符串连接到非字符串值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/d70302d4f7bbbef6e661d0a41328c111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDErWG6POloMHqqu9mHBwg.png"/></div></div></figure><p id="811a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setter函数中，我们做了同样的事情。</p><p id="7708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果目标属性值是一个字符串，我们给它分配一个修改后的值。我们用一个自定义字符串作为新值的附录。对于其他值类型，我们直接将新值赋给目标属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/6a7db6efbacb6d5badeb9ce8469d160d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mk3UtddcBzUixfsqmFgjxQ.png"/></div></div></figure><p id="37fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。我们通过代理对象输出消息属性。这个操作触发代理getter函数。消息值是一个字符串，getter函数返回一个定制的值。我们得到了原始消息值和自定义附录。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/f0eca080f7b7ecd1af4009aeeb0d5456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_fzY3NCaeImAbuXJPFzuQ.png"/></div></div></figure><p id="df60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们通过代理对象重置消息属性。我们将苹果分配给它。</p><p id="6e16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个操作触发了setter。消息值是一个字符串，新值<em class="np">苹果</em>将首先与自定义字符串连接。那么新的字符串将被分配给info对象的message属性。</p><p id="29e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到消息属性的值已经变成了由代理设置器设置的<em class="np">苹果。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/01e3d49be0228cc367d5f93a7490538a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fInut2wCRkZbI-jqsyvX7A.png"/></div></div></figure><p id="abbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们从代理对象输出消息属性，它将从自定义getter接收第二个附录。</p><p id="814e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到的消息值是代理getter 返回的代理setter设置的<em class="np"> apple。它有两个附录，第一个来自setter，第二个来自getter。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/55f849d9d0a46c13a2b518dc1a7f3038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqyri-zVfhKBFPdocIBdjg.png"/></div></div></figure><p id="1a78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们通过代理对象输出num属性。</p><p id="5e4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的值是一个数字，getter不会修改它的值。所以我们会得到它的初始值10。</p><p id="bcfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过代理对象给number属性加1，number值将变成11。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/75aa44197ef9ac9cb3a3ef8cbd90852f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aws98sk0f4RcKwrACmDo2A.png"/></div></div></figure><p id="af32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试方法输出它的这个。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/e7e98a3f3a310a19ce998e76ef1082f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uVvRp3HIuZIJ0o213MnKg.png"/></div></div></figure><p id="e084" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过info对象调用它，它就指向info对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/cc73d7f496478508a15bba3c7b048bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tF5iDDsmyS07Do3fugqcHw.png"/></div></div></figure><p id="176a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过代理对象调用它会发生什么？它将指向哪里？信息对象还是代理对象？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/a18667422165697688daeb0530077f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOTydBoZ0RUJBKblo9fgzA.png"/></div></div></figure><p id="0545" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到这个指向代理对象的点。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/a9d14c393be261d1d724c25cc99ced8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3vCSph7q2OkiXFYIrwJOw.png"/></div></div></figure><p id="ccc4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在测试方法中，我们控制台记录消息属性。</p><p id="45c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过info对象运行测试方法，我们将获得原始消息值。如果我们通过代理对象运行它，我们将获得由代理getter返回的自定义值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/f7a38d5451c90e70990453f48f5e73b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DvZiZRjvQ60tnvd41qj0ig.png"/></div></div></figure><p id="0762" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有没有发现getter函数有问题？</p><p id="06a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们只定制字符串类型的值。但是我们需要返回两次。如果我们设置更多的自定义值，那么我们需要几个return语句。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/0e413fe57620be37fe828f66b54b208f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*peNdDG1Z7FMbAef1krscKQ.png"/></div></div></figure><p id="0b43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，ES6提供了反射对象，它是代理对象的助手。它具有与代理处理程序对象相同的方法。我们在代理处理函数中安装反射方法。例如，在代理getter函数的最后，我们返回反射get方法。</p><p id="4db8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要将getter函数的参数传递给Reflect方法。最简单的解决方案是直接在Reflect get方法中传播arguments变量。这样，getter函数的参数会自动传递给Reflect get方法。实际上，Reflect get方法只需要前两个参数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi or"><img src="../Images/25a5fa442c88409d31f64f7cbc131f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9iXmqDB5ld9pWq3V8TGHw.png"/></div></div></figure><p id="a320" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Reflect get方法返回目标属性值。这就是为什么它需要访问目标对象和目标属性名。</p><p id="e13b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要返回自定义值，我们只需将修改后的值赋回目标属性。不再需要ELSE部分。在IF部分，我们删除关键字<em class="np"> return </em>，并将修改后的值赋回目标属性。我们只需要在getter函数结束时返回一次。相比之下，getter函数看起来干净多了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/806beb8396b4e0b3c3f7dac4652f1c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLYuayUm0jGJhbCU0_yAbQ.png"/></div></div></figure><p id="e68d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setter函数的末尾，我们添加了Reflect set方法。我们仍然把自变量分布在其中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ot"><img src="../Images/605b31d608b5437cffc458ec11a3bd17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3hoYriUAY55dqW-Kw8a8g.png"/></div></div></figure><p id="a208" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反射集方法的作用是将newVal参数赋给目标属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ou"><img src="../Images/8d2b6ad34a49ed2f44fd2d87ec578b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GRXBHuwwwHIy-2OHh3LGA.png"/></div></div></figure><p id="7f3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了自定义分配给目标属性的值，我们将修改后的值重新分配给newVal参数。<strong class="kd iu">将修改后的值赋回newVal参数</strong>非常重要。不再需要ELSE部分。在IF部分，我们将自定义值赋回newVal参数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ov"><img src="../Images/dddfd2acace5b3e4d5b4ca32042a8e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*goiPp3cdnk0IhFOjGd-MfQ.png"/></div></div></figure><p id="881f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，setter完成了。让我们刷新页面并测试程序。</p><p id="3f24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们先测试吸气剂。我们输出消息属性。我们得到了修改后的消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/8d99923687d37386239c5053677f8032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GilT8cpTx-2chVUqKN4HvQ.png"/></div></div></figure><p id="c7ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们输出number属性，我们将得到它的原始值。只会修改字符串类型的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/2053f4e7756b7560e27e91cb79a35412.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*I6oQ7Y9fa31F9CuYSfG2dw.png"/></div></figure><p id="698a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们试试二传手。</p><p id="780e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过代理对象将<em class="np">苹果</em>分配给消息属性。字符串类型的值将被修改。所以<em class="np">苹果</em>不会是消息属性实际接收到的。</p><p id="e801" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们输出info对象。我们可以看到消息值是由代理设置器设置的<em class="np">苹果。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/01528591f802de21d756ccc4679b463d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdHj_JxPMLtsZ64mGr94xA.png"/></div></div></figure><p id="298c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将数值加1。我们可以看到数值变成了11。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/847ec9cd0c2e1f6769d178d9b0c8830f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOfSb6PiZDCTrh3c_SgoRg.png"/></div></div></figure><p id="b3a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setter函数的末尾，我们选择H1标签的DOM对象，并使用newVal参数重置其内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/b713d5d92783fe3c0e39cc0eeb1e3399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0EROJ7knwRMXpiHkZRdgw.png"/></div></div></figure><p id="000b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果我们通过代理对象重置消息属性的值，H1标签将使用自定义值自动更新。</p><p id="ebb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是Vue3构建双向数据绑定的方式。它通过创建一个代理对象来截取并重新定义setter和getter。我们通过目标对象的代理来操作它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pb"><img src="../Images/fcff444467b644653576beed741cd923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lY7L6pkgPIrawM-6YIiz7A.png"/></div></div></figure><p id="ae7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建我们的第一个Vue 3程序之前，我们需要学习两种设计模式:单例模式和工厂模式。这两种模式都被Vue使用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/c2d16f74da8172d55770d5a6fed809db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsAku58MGE_efS0U_Ac2Gw.png"/></div></div></figure><p id="55a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从单例模式开始。</p><p id="b7de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们声明一个变量。我们将其命名为info，并为其分配一个对象。在对象内部，我们定义了一个城市属性，并将其值设置为London。我们将这个对象命名为城市对象。</p><p id="c88b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对象、数组和函数都是引用类型的值。与数字或字符串等原始值不同，我们通过引用类型值的内存地址来访问它们。info变量实际存储的是city对象的内存地址。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3504c6f8cdafefc8cf4edf80ab7abfd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*KPs1C2HSy3Qausg17n8m7Q.png"/></div></figure><p id="9f9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们声明一个新变量。我们将其命名为instanceA，并将info变量赋给它。然后我们声明另一个变量。我们将其命名为instanceB，并为其分配info变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/ff2d6abf965f278535b0ba23844e6cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*iiQsQbPdXqjnJAMO7UeVlw.png"/></div></figure><p id="c251" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，城市对象的内存地址存储在三个变量中。换句话说，我们可以通过三个变量来访问和修改城市对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/bf9f55c88c9c66677c4ea4c8bc246f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*FpqxXPXA1HwX4OQ97KWA4Q.png"/></div></figure><p id="e934" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过instanceA重置城市名。InstanceA和instanceB指向同一个对象。因此，它们将总是返回相同的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/4a4a8962e0f40e67d9086dc9b91c9291.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*395awuqRMS5X9Tam3PZW0w.png"/></div></figure><p id="ef13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到instanceB返回了新的城市名称。</p><p id="5212" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，如果我们通过instanceB重置城市名，instanceA将返回新的城市名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/c79e0ad3a99aa9b18ea18642c71bf1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*T6ZgWO_f-eWVD8VDKXXC0A.png"/></div></figure><p id="bbf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市对象同时由instanceA和instanceB控制，这是单例模式的典型场景。一个引用类型值被几方共享。它们从同一个引用类型值中读取和写入。<strong class="kd iu">单例模式保证了数据的一致性。</strong>各方将始终访问相同的值。</p><p id="897d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们试试<strong class="kd iu">工厂模式</strong>。它返回给我们与相反的<strong class="kd iu">结果作为单例模式。</strong></p><p id="d301" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了一个函数。我们称之为信息工厂。在里面，我们返回一个对象。在返回的对象中，我们设置了city属性，并将其值也设置为London。</p><p id="f729" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回的对象是在工厂函数中定义的。每次我们运行工厂函数，它都会返回一个新的对象。换句话说，每次我们运行工厂函数时，都会收到一个新的内存地址。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/ece78c9337e9221755f7f7af89c35e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*d-oLm7QGEsBcRc-PpeaXIQ.png"/></div></figure><p id="8d68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将工厂函数的调用分配给instanceA和instanceB。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/b2af279935440d618892f30d8af4a217.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*4wCUde-Z__Jv93cPJ6DsBw.png"/></div></figure><p id="6548" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们输出它们。似乎这两个变量返回给我们两个相同的对象。但是这两个物体是不一样的。他们只是看起来一模一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/cf410aa84db7a2d39b99b0ac7cb0784e.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*qLPfd2ANAxENrFlZwbV0Sg.png"/></div></figure><p id="6ef5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过instanceA重置城市名，instanceB不会受到影响。同样，如果我们通过instanceB重置城市名称，instanceA也不会受到影响。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/e3f7af533ea1a1dccdd29f712de6b1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*ESc_uvFBN0scYjW-mVacrA.png"/></div></figure><p id="a33e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">InstanceA和instanceB指向两个独立的对象。它们之间没有联系，这意味着它们不会互相干扰。</p><p id="10e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，单例模式保证了数据的一致性，因为只有一个数据副本。每个人都在同一个副本上工作。工厂模式保证了数据独立性。每个人都有自己的副本，并且只使用自己的副本。无法保证数据的一致性。</p><p id="1000" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在你以后的Vue研究中，这两种模式都是需要的。有时，我们需要保证数据的一致性，而有时，数据独立性是优先考虑的。</p><p id="ddb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将创建我们的第一个Vue 3应用程序。为了让你更容易，我们将创建一个虚拟程序。本课的主要目的是向您介绍真正的Vue3程序是什么样子的，并让您对后面的课程有一个大致的了解。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pm"><img src="../Images/f0ed1791d15f591d31746fbe3b1feba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwG88fXKk_1RXse7kDLyoA.png"/></div></div></figure><p id="a69e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要一个空的HTML文件。</p><p id="6b01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加一个脚本标签来链接Vue3的源代码。这个CDN地址是Vue 3官方手册提供的。全局API名称是Vue。第一个字母V应该大写。然后我们添加第二组脚本标签。这是我们定义Vue程序的ViewModel部分的地方。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pn"><img src="../Images/d9dd9c56c8e3e29e8c5375fd3e0c8136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNQozIA1Fz7y0vnGGWN3yg.png"/></div></div></figure><p id="6680" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要启动一个新的Vue程序的方法是createApp方法。我们通过全球API Vue访问它。createApp方法将一个对象作为其参数值。这个对象称为options对象。options对象是我们定义Vue数据属性和帮助我们处理数据的Vue方法的地方。Vue生命周期挂钩和观察器也在这里定义。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi po"><img src="../Images/17f3d534dea0050f8d8ae29ac3093e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxeppuc_JgtJszDujnLsdQ.png"/></div></div></figure><p id="594a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watcher只是一个特殊的钩子函数，当watched Vue属性的值改变时会自动触发。最后两项特别重要。它们支持预定义代码的自动执行。在接下来的课程中，你会学到更多这方面的知识。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pp"><img src="../Images/47b5584f1423cf738eb106e69c2c737c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9chmHTq1WZkpgKkWD0Ehg.png"/></div></div></figure><p id="ae41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">createApp方法返回Vue应用实例。app实例有一个mount方法。该方法将Vue应用程序实例连接到页面元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pq"><img src="../Images/2623e8431bec3ee0b4a84e17f349e3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sLuVR-zHXmbjyFJEdE1kYA.png"/></div></div></figure><p id="7eef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建一个DIV并给它一个ID。我们将其ID值设置为VueApp。在Head区域，我们添加了style标签来定义CSS代码，这些代码对嵌套在VueApp DIV中的元素进行样式化。CSS代码和VueApp DIV一起构成了视图。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pr"><img src="../Images/a04952d734c6519b6438b0bdc1c818db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tn3UFKubSjgwQDvDNw6jUw.png"/></div></div></figure><p id="facc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将DIV ID传递给mount方法。一旦Vue应用程序实例被安装到页面元素上，ViewModel就被创建了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ps"><img src="../Images/9b27c7fe7bba7403b953bc1e00bf3109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIpEAid5Hdw9_jEud-GRXQ.png"/></div></div></figure><p id="c869" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ViewModel及其视图构成了根组件。VueApp DIV被称为根组件模板。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pt"><img src="../Images/ca62a23c4e290dd53a4e20fd1d8b7619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1k1iGAxoiESx_fKwE21Yg.png"/></div></div></figure><p id="bcba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们看看根组件是如何管理它的模板的。我们在VueApp DIV中添加了一个H1标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pu"><img src="../Images/79110ce6eb4b70ada3f072b7b51e1e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AcvqlHjIbwZ1HwOOA4hGw.png"/></div></div></figure><p id="993b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">开始和结束H1标签之间的文本称为内部文本。我们可以使用文本模板控制H1标签的内部文本。</p><p id="e43a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文本模板是使用两个嵌套的花括号创建的。它被称为小胡子标签。它创建了一个可访问Vue数据属性的范围。我们将在以后的课程中了解更多。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pv"><img src="../Images/48ee7bc8b7c71f7abd0cd84d7d49ad10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUD7VKLF9lKyKvd4Qmo1kA.png"/></div></div></figure><p id="4d6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了内部文本，HTML标签还使用其属性存储信息。</p><p id="d379" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue指令是HTML属性的Vue等价物。它们安装在HTML标签中。Vue指令可以与指令值成对出现。我们使用等号将它们连接起来，就像本地HTML属性一样。在指令名和值之间，我们可以添加一个指令参数。指令参数和名称使用冒号连接。总之，一个Vue指令最多可以存储三条信息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pw"><img src="../Images/b9f2031de578893ac97f0f0b8a6f27be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b90FD3t2bZzdlvnC9Htgxw.png"/></div></div></figure><p id="cefc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue还可以控制原生HTML属性。但是事情比你想象的要复杂。我们将在后面的课程中向您展示细节。</p><p id="13b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们分离出只属于根组件的代码。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi px"><img src="../Images/386ee553fa0ea50a4ae4854f5ba1143d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3ot7DHj8diR9aoSnky2tA.png"/></div></div></figure><p id="298f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，这些代码可以分为三个部分。</p><p id="7313" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一部分是风格部分。CSS代码存储在这里。第二部分是模板部分。它存储HTML代码。最后一节是脚本部分。定义视图模型的JS代码存储在这里。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi py"><img src="../Images/c939946b3c8b8b01fcb414b4a7e149e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yctBS-XV1xXt46ZWhyupXA.png"/></div></div></figure><p id="544d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们能把这三个部分放在一个文件里，那就太好了。这样，一个Vue组件使用一个专用文件来定义。程序维护会容易得多，因为组件需要的所有东西都存储在同一个文件中。</p><p id="6a50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue的开发者也想到了这一点。Vue支持一个称为单文件组件的特性。使用一个点vue文件定义一个组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pz"><img src="../Images/f01a12ab0c108785820d99eebe5f7d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqtpO0c5WgxDrGd5VkIwsw.png"/></div></div></figure><p id="1544" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">dot vue文件由三部分组成:模板、脚本和样式。如果我们将scoped属性添加到style标签中，那么style标签中的所有CSS代码只适用于当前组件的模板。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pp"><img src="../Images/e9235a7b1f3f81e4315a386157a7b0d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7vmjlYV8F1Y6yX_kzTDYQ.png"/></div></div></figure><p id="4682" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，这样的文件不能单独工作，也不能被浏览器处理。</p><p id="2b93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要一个脚手架工具来帮助我们建立一个开发环境。我们还需要一个捆绑器将所有的点Vue文件和Vue源代码合并成一个JavaScript文件。</p><p id="0e00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">官方的安装和捆绑工具是VueCLI。我们将在以后的课程中学习。它是高度自动化的，基本上开箱即用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/d20f2cd80053d3357322fedf604f0cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5ZkGn6E1HSXnJPNLkJW-Q.png"/></div></div></figure><p id="2771" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的Vue研究的开始，我们的Vue程序将看起来像这样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/43d46747d550da34da39acb967fdcdc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAwkeJjjExQj_iFTAGIJsw.png"/></div></div></figure><p id="a477" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个带有两个脚本标签的HTML文件。第一个链接的是Vue源代码。第二个是我们定义自己的Vue代码的地方。</p><p id="54f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们学习了关于Vue的所有基础知识并理解了Vue的工作原理之后，我们将向您展示如何使用Vue CLI并使用单个文件组件开发Vue项目。</p><p id="867f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将创建我们的第一个Vue 3程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qa"><img src="../Images/dd35521a3054ee9cff20d1499d253661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kljfPws411aLieBFBq9atg.png"/></div></div></figure><p id="4fe1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您所需要的只是一个空的HTML文件。我已经通过CDN链接了Vue 3的源代码。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qb"><img src="../Images/a9fdde40810b05244b681cbabb9c3f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EREzvs38iQu_0O7ji1GviA.png"/></div></div></figure><p id="e9e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">全局API名称是Vue。第一个字母Vue需要大写。我们在控制台上输出它。我们得到了一个有很多方法和属性的对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qc"><img src="../Images/bb1d2980c5073a27b6a74f18c91afa31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ch3-rwJHYAxFF_vu7jDfgA.png"/></div></div></figure><p id="9d92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一直滚动到最后，我们会找到一个名为version的属性。它告诉我们正在使用的Vue的版本。确保您的版本是3。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/826ac7290bba31f52bfefc2adb207789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTd-aQTL-L6oFQ4mVVZqiw.png"/></div></div></figure><p id="6249" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Vue 2中，全局API Vue是一个构造函数。我们实例化它来启动一个新的Vue程序。但是在Vue 3中，你不能再实例化Vue了。Vue现在是一个对象，而不是一个构造函数。我们使用它的createApp方法来启动一个新的Vue程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qd"><img src="../Images/efe6b09b031fd6921ca1938de5dbcac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhmneP18--TnBATkF6pUzQ.png"/></div></div></figure><p id="f74b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了另一个脚本标签来定义我们自己的Vue代码。</p><p id="bd5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过Vue api调用createApp方法。我们传递一个对象给它。这个对象称为options对象。我们用它来定义Vue组件。其中的属性称为选项。</p><p id="8e14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">createApp方法向我们返回应用程序实例。我们将它保存到一个名为app的变量中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qe"><img src="../Images/7225a09c7aef79defca4ca94595efaf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTVMHFjuZxCUpSKG9KlHTw.png"/></div></div></figure><p id="a14a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们输出app变量。</p><p id="8e5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">app实例也为我们提供了一些方法和属性。挂载方法是我们下一步操作所需要的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qf"><img src="../Images/d9ad1b527cf06ac7988ec394b659a568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhVgC6wUaThL3aYcPTUh8w.png"/></div></div></figure><p id="755f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过app实例调用mount方法。mount方法将应用程序实例挂载到页面元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/d1a8ecc2f14b538f4bb4d8fae93abbd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*YofVypFw73aYcHx6rPkZnQ.png"/></div></figure><p id="3d9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在H2标签下面，我们添加了一个DIV并给它一个ID。确保DIV不完全为空。空行就可以了。然后，我们将DIV ID传递给mount方法。</p><p id="2393" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦应用程序实例被装载到页面元素，它就成为根组件。根组件的实例对象由mount方法返回。我们将它保存到一个名为VM的变量中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qh"><img src="../Images/8d8b90ae1b938e9eb244d1c00a68de75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sItexymQGc5uCBKKAVCbQ.png"/></div></div></figure><p id="6279" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面并输出VM变量。我们得到一个代理对象。在Vue 3中，所有组件实例都是代理对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/d77df3de978f41af2b0f9b73e0f20526.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*e4AM9qhIW1lvEevpi76Wpg.png"/></div></figure><p id="4a4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开它的目标对象，我们可以找到几个属性，它们的名字都以美元符号开头。每个属性都有一个getter和一个setter。美元符号前缀意味着该属性是由Vue内部创建和使用的内置属性。</p><p id="bf0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用传递给createApp方法的options对象，我们可以将自己的自定义属性添加到组件实例中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qj"><img src="../Images/7413a1d892407831763be3951862e0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ntl7Wco2H5-gtxwhsIXGQ.png"/></div></div></figure><p id="8352" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号数据属性是存储所有数据属性的地方。目前，它是一个空对象。一旦我们定义了数据属性，它也将成为一个代理对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/1eb8e229965c211a5fcc8bc105135e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*z-owo2H5cvVAt044SFUpvw.png"/></div></figure><p id="1c91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号EL属性指向组件实例管理的根DOM元素。这也是VueApp DIV不能完全为空的原因。美元符号EL property肯定有所指。目前，它指向19行的空行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qk"><img src="../Images/a7dde5b18ad4c8833fdf18766992f592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfDD0Me3Nrjsr7D0432QkA.png"/></div></div></figure><p id="a55a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将H2标签移动到VueApp DIV中。H2标签是VueApp DIV中的唯一元素，它的DOM对象将由美元符号EL属性返回。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ql"><img src="../Images/9f717e267b6e535d2c6d5be4bc5aabfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKKqOKF2tV8Vf6KJZEtkOQ.png"/></div></div></figure><p id="3bca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号EL属性的问题是它只能指向一个页面元素。Vue 3不再要求每个组件必须有一个根分区。如果我们在VueApp DIV中添加另一个P标签，美元符号EL属性就不能同时指向H2标签和P标签。它只是返回一个占位符DOM节点。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qm"><img src="../Images/3d01f80f0e33a8e34ede62b3d2b8a854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7wYb6THTibsEJJ00CdKXg.png"/></div></div></figure><p id="145c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在实际项目中，避免使用美元符号EL属性访问任何页面元素。还有其他方法可以做到。我们将在后面的课程中向您展示如何操作。</p><p id="90b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们在options对象中设置第一个选项:数据选项。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qn"><img src="../Images/2199a3614cb3b47b0cf46f5ad53535bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F23_JgIcMCOAYtM1crrDdg.png"/></div></div></figure><p id="eb05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给数据选项分配一个对象，看看会发生什么。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/bac2ec1df06e2c356589985a7142225e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*metYRfGAxTivTem8uNXM8Q.png"/></div></figure><p id="453d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到一个警告和一个错误。从Vue3开始，所有数据选项都必须使用工厂模式定义，包括根组件的数据选项。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qp"><img src="../Images/442f2c879b5467873afeab59c33ec49d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZrTrscCW703-MRe_IK9bg.png"/></div></div></figure><p id="7467" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为数据选项分配一个完整的函数，并在其中返回一个对象。数据属性在返回的对象中定义。我们定义一个消息属性，并给它分配一个字符串值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qq"><img src="../Images/e39d55ca411f8e928ce80a08ba97a7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQiI1DHGxFezyGKc1u8UcA.png"/></div></div></figure><p id="3a43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查根组件实例。我们可以看到消息属性已经被添加到根组件实例的根级别中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/28b51018c8d8cef6c528b4724aa141fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*3fHKbbjUDU5h96CbKyyJaA.png"/></div></figure><p id="f0a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您在根级别找到的消息属性只是一个别名。真实消息属性存储在美元符号数据属性中。数据属性及其别名始终保持同步。它们总是输出相同的值。</p><p id="bb70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们改变一个别名值，相应的数据属性将被更新。同样，如果我们改变一个数据属性的值，它的别名将自动重置。</p><p id="a2f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号数据的值已经成为一个代理对象。消息属性存储在其目标对象中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/a708ef9a7354649a88857e3e9d270d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*mLXJVST4nIBgSiH8zQz2Eg.png"/></div></figure><p id="1307" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经创建了一个数据属性，如何将它的值呈现给用户呢？</p><p id="3900" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">VueApp DIV由根组件控制。可以在VueApp DIV中访问根组件的数据属性。</p><p id="fa36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们先来看看一个原生HTML标签是如何向用户呈现数据的。我们将以H2标签为例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/151357ecaa4e8f3a022f4ac8aaf0c0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-Ue6E6eNCGufR9e1NmDSw.png"/></div></div></figure><p id="e54e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H2标签向用户呈现一段文本。这段文本是H2标签的内部文本。除了内部文本，H2标签还在其标题属性中存储信息。当然，您也可以使用其他属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qt"><img src="../Images/9374afa997597fcf48ef0954fe8e6d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2mr6YW7ILRvDV_kN2d8Cg.png"/></div></div></figure><p id="1b98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用Vue数据属性设置内部文本和属性值。我们将从内部文本开始。在下一课中，我们将向您展示如何设置属性值。</p><p id="7ca3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们清空H2标签，并在其中添加两个嵌套的花括号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qu"><img src="../Images/bbce0163d27ff53b13eb808d5ac02cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*ygCJI_rzZtLdLNB5rcXSWw.png"/></div></figure><p id="a2f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个嵌套的花括号被称为mustache标记。mustache标签创建了一个文本模板，我们可以在其中定义一个JS表达式。表达式值将被用作H2标签的内部文本。</p><p id="7c66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们在mustache标签中放了一个比较表达式。我们比较10和5。比较结果为true，因此true将作为其内部文本显示在H2标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qv"><img src="../Images/ab36faa3f15773b2575ac216f924b95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqnR2CvF0QJg7Kds5HAUnA.png"/></div></div></figure><p id="5702" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">mustache标签可以访问内置的JS对象。例如，我们可以在其中实例化日期构造函数。当前日期和时间将作为内部文本显示在H2标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qw"><img src="../Images/396b7dcbaeff6ad3fa3dfe5cae9d6249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ypYSp7EMPyQ9_pH_7uirg.png"/></div></div></figure><p id="dcc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">mustache标签不能访问窗口对象。您不能控制台日志或警告任何东西，因为这些方法来自窗口对象。</p><p id="4c8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们得到了两个警告和一个错误。Vue项目也被关闭了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qx"><img src="../Images/f66f7e71073850e10486d208e013ddce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OO62puZfMpCm0xYFwONw1g.png"/></div></div></figure><p id="9b8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">mustache标签可以直接访问组件实例的根级别。我们可以在这里输出美元符号数据属性。仅属性名称就足够了。不需要前缀。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qy"><img src="../Images/3c58580dc3b6382d4454f92cbd5e5050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTmJEgV3TPDlcAqAeVJ9pA.png"/></div></div></figure><p id="bc2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了访问消息属性，我们在消息中附加了美元符号数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qz"><img src="../Images/ea954b9a946c635c50042f3efbcd8cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6zxzmXOYD03DNX6qgk7Dg.png"/></div></div></figure><p id="750e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以使用消息属性的别名。别名存储在组件实例的根级别中。我们可以跳过美元符号数据前缀。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ra"><img src="../Images/36fabaaf3a1a118235d75e0a9cf370af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pmzd-K-E8EK2lbs6VveLcg.png"/></div></div></figure><p id="8abd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue数据属性都是反应性的。如果我们重置消息属性的值，H2标签将自动更新其内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rb"><img src="../Images/1f6c4c456b2985f747bd1af8750cdca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbnjDnvBNNy-Vi96TyRBJg.png"/></div></div></figure><p id="6288" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在将消息属性的值呈现给用户之前，我们可以进一步处理它。例如，我们可以用toUpperCase方法附加它。用户现在将看到一个完全大写的消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rc"><img src="../Images/f54b3fc92672a04e4815c37048537c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwGTt4rfmaiD5ewlqXq_lw.png"/></div></div></figure><p id="b683" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您的实际项目中，mustache标记应该尽可能简单，最好只包含Vue属性名。所有数据处理代码最好保存在options对象中。</p><p id="d641" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我添加toUpperCase方法的原因是为了强调mustache标记创建了一个我们可以定义JS表达式的范围。它不仅仅是一个用于设置数据属性名称的插槽。</p><p id="4a7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue数据属性还可以存储引用类型的值，并保证它们的反应性。我们创建一个名为list的属性，并为它分配一个数组。然后我们创建另一个属性，并将其命名为car。我们给它分配一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rd"><img src="../Images/b0a4f79f318ad2e9384bc207fc69a1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEurV04T5rPil5bv4EBlMw.png"/></div></div></figure><p id="18ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查根组件实例。car和list属性的别名已添加到组件实例的根级别中。打开美元符号数据属性，我们可以找到汽车并列出属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi re"><img src="../Images/518a0fbedfbb5b45acd40b31d2540663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6hTdjQO6ioiHwTtweg4fw.png"/></div></div></figure><p id="c5da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件实例是一个代理对象。您在它的目标对象中看到的值可能不是最终的输出值。list属性是目标对象中的一个数组。但是当我们输出它的时候，它会被转换成一个代理对象。这同样适用于汽车对象。它也将被转换成一个代理。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi rf"><img src="../Images/a3ca93de12d5ac2ef4518a0b98f96fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*re2wC_5iqnOqwPy0Fz19_Q.png"/></div></figure><p id="38ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue进行这种转换的原因是为了使引用类型的值具有反应性。我们将在后面的课程中学习更多关于Vue反应性的知识。</p><p id="f50e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数组代理的行为与普通数组相同。我们可以使用length属性检查元素总数。所有与数组相关的方法都使用数组代理对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi rg"><img src="../Images/26ac8d16f5624f70ced10d1416ee8ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*fHrw-2kVjvWTo4lJDjN4Eg.png"/></div></figure><p id="ad71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对象代理的工作方式与汽车对象相同。我们可以通过属性值的名称来检索属性值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi rh"><img src="../Images/a0f5dff56de35156c0333a7dbd0ed006.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*bS8qZXPRUHLVT3ZHEY_1sg.png"/></div></figure><p id="b57c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在mustache标记中，我们显示了列表数组的第一个元素和汽车对象的brand属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ri"><img src="../Images/f76b451afa3329e4a969a4e869ab7699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3d_DaVN4V3W0BJckbCcJTw.png"/></div></div></figure><p id="c1ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们重置列表数组的第一个元素。我们可以看到模板已经自动更新。如果我们重置品牌价值，模板也会更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rj"><img src="../Images/22139ba4dbd68fa8c692c1de6b750bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2eehKPsX-hjerL9mofTPA.png"/></div></div></figure><p id="012c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue 3已经引入了设置功能。setUp函数返回一个对象。返回对象中定义的属性将被添加到组件实例的根级别。</p><p id="587c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们定义一个城市属性，并将其值设置为伦敦。顺便说一下，你应该随时随地避免命名冲突。设置功能中的属性不应与数据选项中定义的属性相同。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rk"><img src="../Images/26b3ca6d9889dd38eb3525a05078e35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4JblhIiZm_hLiGxPev4Ww.png"/></div></div></figure><p id="f5a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们输出VM变量。city属性已经添加到组件实例的根级别中。但是您不会在$data对象中找到它，因为它是<strong class="kd iu">而不是</strong>一个数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qc"><img src="../Images/86d6f75f4003063597fe813a61d05a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Txh6vP3RSSru25BgFhe7g.png"/></div></div></figure><p id="c071" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">被添加到组件实例的根级别使得city属性在组件模板中可见。我们可以使用它的名称在mustache标签中显示它。</p><p id="04f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，城市名称显示在P标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rl"><img src="../Images/fc8fd7570c8e9151ac5bc9ce0274f187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eue1umOPeNhx1PFhhTBIjA.png"/></div></div></figure><p id="bd22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们给city属性分配一个新值，模板不会自动更新。城市财产还没有反应。稍后我们将了解更多关于setUp函数的内容，包括如何使city属性具有反应性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rm"><img src="../Images/2dfb7ccc7ff2a12eb38a5fa29022504e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3PMrRZXH4Nh-B027bsTmw.png"/></div></div></figure><p id="e4b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在这里向您展示设置功能的原因是为了强调两点。</p><p id="4fa2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个是数据选项不是将属性添加到组件实例的根级别的唯一方法。换句话说，并不是组件实例的根级别中的每个自定义属性都是数据属性的别名。</p><p id="210e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二点是来自组件实例根级别的定制属性并不总是反应性的，但是它们保证在组件模板中是可见的。</p><p id="b835" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">HTML标签也在其属性中存储信息。例如，H2标签有一个标题属性。那么Vue是如何控制HTML属性的呢？</p><p id="a949" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案是使用v bind指令。我们使用v bind指令作为title属性的前缀，并用冒号将它们连接起来。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/4c323dd2dd49239ae6ae55cc582f6517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwRhiEez5-Qn68FeRoDfgQ.png"/></div></div></figure><p id="70f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue指令是虚拟的HTML属性。它们被安装在HTML标签中。v bind指令是最常用的Vue指令之一。</p><p id="c9bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们用v bind指令作为title属性的前缀时，一切都变了。让我们刷新页面，看看会发生什么。</p><p id="1e28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到一个警告和一个错误。现在无法识别原始属性值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rn"><img src="../Images/d980126bf2674ba1dc4149fe69ef2c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufCMCqxViaSOLVOIqBcgPA.png"/></div></div></figure><p id="5fe9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们用v bind指令作为title属性的前缀，原来的属性值就变成了Vue指令值。它不再是字符串了。</p><p id="0908" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原来的标题值现在被认为是两个Vue属性名，不再是一个字符串。我们当前的Vue程序在这两个名称下没有属性。这就是我们得到警告和错误消息的原因。</p><p id="d90d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue指令值实际上是一个作用域。我们可以在其中定义一个JS表达式，表达式的值将被用作最终值。例如，我们在指令值中比较10和5。比较结果为真。因此标题值将被设置为true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ro"><img src="../Images/93a2d558eea267b81b6882b39abdadfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjwNuWHevWRUE14hcwqBMA.png"/></div></div></figure><p id="3c27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以在范围内实例化日期构造函数。当前日期和时间将被设置为标题属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rp"><img src="../Images/99dd13fe17f49f28bbf60d286674f2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MZig-At7lKi43SYFUXrUQ.png"/></div></div></figure><p id="3318" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">窗口对象在这里不可用，所以不要尝试控制台日志或更改任何内容。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rq"><img src="../Images/de622ad8231a3a2500e78b4a37d3a47a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ybJFtqdOqc9Cinn6A7Mrjg.png"/></div></div></figure><p id="643d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue指令值为我们提供了对组件实例根级别的直接访问，就像mustache标签所做的那样。</p><p id="0942" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue属性在指令值中可见。这里，我们将title属性赋给v bind指令。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rr"><img src="../Images/db2f925eb497885cb47663839e8dbf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubGzzBgMWKoMbwXfIfe7lA.png"/></div></div></figure><p id="b804" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。title属性的值现在已经分配给了H2标签的title属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rq"><img src="../Images/0d6344a2af90ee2aa490fa9789f197e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVRtT_b5oAxiFHb1TNt5Mg.png"/></div></div></figure><p id="5a5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">理解指令值是一个作用域，而不仅仅是Vue属性名的位置，这一点非常重要。我们可以在其中定义一个JS表达式。例如，我们用toUpperCase方法附加title属性。</p><p id="3ae4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，将使用title属性的大写值来设置H2标签的title属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rs"><img src="../Images/97b4ef5d072c761b720d743b8811d538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqkglQt6il6_8BBeJaJCqg.png"/></div></div></figure><p id="b86e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您的实际项目中，最好还是<strong class="kd iu">保持指令值尽可能简单</strong>。建议您仅使用<strong class="kd iu">的一个Vue属性</strong>设置一个指令值。数据处理代码最好放在options对象中。本建议适用于所有Vue指令。</p><p id="2ba7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于一些HTML标签，v bind指令是它们使用Vue的唯一方式。</p><p id="83cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们添加一个输入标签。输入标记没有内部文本。它依靠它的值属性来工作。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rt"><img src="../Images/c8ea3f4a94649780b05a7980ecebc657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdbzuaSLnZAxBTAdVDvneg.png"/></div></div></figure><p id="38a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v bind指令使我们的Vue程序能够控制输入标签的value属性。我们用v bind指令作为value属性的前缀。v bind指令可以简称为冒号。我们使用消息属性设置指令值。</p><p id="7b7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，消息属性的值将显示在输入框中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ru"><img src="../Images/549851e71de30cc637a5f2636d2dba36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4flAJMpQxn3pQVumeG_CQ.png"/></div></div></figure><p id="28bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们修改message属性的值，输入框中的文本会自动改变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rv"><img src="../Images/d3f15018483a3059f8d5ed785c93c609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1uMABhmwwAam8HLvXyRZA.png"/></div></div></figure><p id="52fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来澄清一些可能的误解。</p><p id="89cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">vue指令由三部分组成:指令名、指令参数和指令值。指令名和指令参数用冒号连接。</p><p id="a311" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">任何HTML属性，一旦以v bind指令为前缀，就不再是HTML属性。它成为v bind指令的一个参数。</p><p id="6a48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v bind指令有意将其参数命名为与原生HTML属性相同的名称。这样做是为了降低用户的学习障碍。</p><p id="b161" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来证明一下这个说法。我们将禁用的属性添加到输入标签中。disabled属性禁用接收它的元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rw"><img src="../Images/3c343ab9c45bbdf4ad583d493bed1569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PaLUFPRZS1h3LHTsYJjokw.png"/></div></div></figure><p id="c176" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">禁用</em>属性比较特殊。它不接受任何值。要禁用输入框，只需将<em class="np"> disabled </em>属性添加到输入标签中。要打开一个禁用的输入框，您需要删除<em class="np">禁用的</em>属性。</p><p id="a1ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将<em class="np">禁用的</em>属性赋值为false将不起作用。输入框仍处于禁用状态。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rn"><img src="../Images/1be0b42fc10c6eecf755f1b3b42a931a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmMTEpZ_d409748EGryhgA.png"/></div></div></figure><p id="67a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们用v bind指令作为<em class="np"> disabled </em>属性的前缀，看看会发生什么。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rx"><img src="../Images/24a95438b8a5e0a4b01805c175407f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJ_GAmKooqdiUN_Nu_54Bw.png"/></div></div></figure><p id="3ba9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入框再次被启用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ry"><img src="../Images/3b1dd8a707f0d78efc976effcdf9938b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jrn7Y_9xXNA3F9I6uWMmg.png"/></div></div></figure><p id="b5c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这证明了一旦以v bind指令为前缀，<em class="np">禁用的</em>属性就不再是HTML属性。它成为v bind指令的一个参数。否则，将它赋值为false不会起作用。</p><p id="444b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果指令值为false，Vue不做任何事情。呈现的输入标记不会接收禁用的属性，因此可以接受用户提交的数据。如果指令值为true，Vue会将禁用的属性添加到呈现的输入标记中。因此，输入框被禁用。</p><p id="c62c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">理解v bind指令不仅仅是为现有的HTML属性赋值，这一点非常重要。它实际上呈现了整个HTML属性。它的参数决定了将呈现哪个HTML属性。它的值将被用作呈现的属性值。如果呈现的属性不接受任何值，就像我们刚刚展示的禁用属性，那么指令值决定属性是否将被呈现。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rz"><img src="../Images/811534f9282835a35c051210756cf991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xl6ayP2w4ROLHvw7l7c4tQ.png"/></div></div></figure><p id="d43c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将讨论条件渲染。Vue为这项工作提供了四个指令:v show、v if、v else和v else if。</p><p id="3d53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后三个指令一起工作。v秀单干。它不适用于v else。请记住这一点。</p><p id="5412" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">条件呈现，就像它的名字所暗示的那样，意味着基于一个条件来呈现元素。</p><p id="b4c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有两个P标签。第一个说<em class="np">吃你的蛋糕</em>，第二个说<em class="np">吃你的蛋糕</em>。显然，我们不能鱼和熊掌兼得。所以一次只能显示一个P标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sa"><img src="../Images/9b0dc60dd81a515d9852a95e488c002a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*nWMNV3ByhDtTbFkgyCclEg.png"/></div></figure><p id="1c82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个P标记中，我们添加了v show指令。不需要任何指示性参数。我们将指令值设置为true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/2629da7911da385901f554a5b8ebce68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQ2ZU5r6fRrW1pG1No1F7A.png"/></div></div></figure><p id="a255" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sb"><img src="../Images/8387be7d4d74b22bf3b216ba5732dcd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8xR16MrFFRBiQXw442Hzw.png"/></div></div></figure><p id="ccb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个P标签都正常显示。</p><p id="df56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们回到v show指令，将其值从true切换到false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sc"><img src="../Images/cf0021e2af6f6410971e6a0fc93e7972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnvIR8XHbd2yhGfgX4Rxyg.png"/></div></div></figure><p id="efcd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这次，我们只有第二个P标签。第一个P标签没了。但是在呈现的HTML文件中，第一个P标签仍然存在。它只是隐藏了它的CSS属性<em class="np">显示</em>设置为无。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sd"><img src="../Images/9660f41949be4da092ef224c09e4a8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0QICzGlvG0mb4eZ9tAlnw.png"/></div></div></figure><p id="522a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个新的数据属性。我们将其命名为<em class="np"> have </em>，并将其值设置为false。然后，我们将<em class="np"> have </em>属性分配给v show指令。</p><p id="494f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们复制了v show指令，并将其粘贴到第二个P标记中。我们在<em class="np"> have </em>属性前面加上感叹号来反转它的值。这样，两个P中的v show指令总是接收相反的值。因此，一次只能显示其中一个。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi se"><img src="../Images/ff8b0b3e0b4760de6a79d40636e4cbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPsSrw-BFGcfvzhJBsbh4Q.png"/></div></div></figure><p id="8030" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，显示第二个P标记。我们将<em class="np">的属性设置为true。现在，第一个P标签出现了。第二个已经藏起来了。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sf"><img src="../Images/409885aff8f36dfc750b6fc2de128a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mpThZGk9ehdk_-ncQaY6g.png"/></div></div></figure><p id="97fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将两个v show指令切换到v if指令。</p><p id="c9c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好像结果和以前一样。当我们第一次加载页面时，显示的是第二个P标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sg"><img src="../Images/fdbf615462df455023262bbd47f0b02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_DuciVeztbywdUKRvdwQQ.png"/></div></div></figure><p id="c820" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们将<em class="np"> have </em>属性的值反转为true之后，第一个P标签出现，第二个消失。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sh"><img src="../Images/69c2fd96c92e1578cf29acedae3632ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXt6ZDitT6SLP9IN3L-vew.png"/></div></div></figure><p id="404c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查HTML代码。与v show指令不同，v if指令直接从HTML文件中删除隐藏元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sb"><img src="../Images/116166cd76d2f0e893aa3afd4f9a4d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwZ5MEi7LOWhKNdkOEVDWw.png"/></div></div></figure><p id="c786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你知道v show指令和v if指令的区别了。V show通过将元素的<em class="np"> display </em>属性设置为none来隐藏元素。V if指令直接从呈现的HTML文件中删除an元素。</p><p id="bdd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个v if指令可以替换为v else指令。不需要指令参数或值。结果和之前一样。一次只显示一个P标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi si"><img src="../Images/a9af449d12b9605eb8f6066c553901cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfMOARixUmzCpnzR4LZXKg.png"/></div></div></figure><p id="7d7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v else指令不能单独使用。这取决于安装在前一个元素中的v if指令。在v if指令和v else指令之间不能有额外的元素。否则，v else指令将不起作用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sj"><img src="../Images/0af737fa30a18524d76e38f2a286706a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pz5qiCZtCurxpGQHZfxfgw.png"/></div></div></figure><p id="ba90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个新的数据属性。我们把它命名为水果，把它的价值设定为苹果。</p><p id="652b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们添加一个UL标签来创建一个列表。我们添加一个Li标签，并在其中显示苹果。然后我们添加另一个李标签，并在其中显示<em class="np">其他</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sk"><img src="../Images/9b64478c270d3c638f945d9b00bb3a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dAjJ-1Yst9pm4yep8OJHA.png"/></div></div></figure><p id="0844" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个Li标签中，我们添加了v if指令，并使用比较表达式设置了它的值。我们用苹果比较果实性状。在第二个Li标记中，我们添加了v else指令。</p><p id="6e6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">fruit属性的默认值是apple，因此比较表达式返回true。结果，第一个Li标签被显示。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sl"><img src="../Images/a81da61bfad94d8a3a345c9e18403368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIEl-QR7bk1ZjtaCthBx1Q.png"/></div></div></figure><p id="5dea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加另一个Li标签并在其中显示orange。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/763b7c7da8b5c828d57748b468e42aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyYA8vOAocmGMm85fJ7QxQ.png"/></div></div></figure><p id="595d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有个问题。使用v if指令和v else指令，我们只能切换两个页面元素。现在我们有三个列表项。我们做什么呢</p><p id="ef99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将<em class="np"> v else if </em>指令添加到中间元素中。我们将水果的特性与橘子进行比较。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sm"><img src="../Images/d7625652bcc9341e6e5dfe7bfb028dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-omYJ42sloDiQZobAhTWQ.png"/></div></div></figure><p id="c430" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以根据需要添加任意多的v else if指令。只要确保它们的值都不同。您需要确保在v if、v else if和v else指令之间没有额外的元素。v else if指令必须安装在v if指令和v else指令之间。</p><p id="c7d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这节课中，我们将学习一个非常有用的开发工具:ref属性。在下面的课程中，我们将经常使用ref属性。它帮助我们更好地理解Vue是如何工作的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sc"><img src="../Images/86c05147ebcb67bf6b359b9ffd63d5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbQoFgp-6CzuO4izulFfFw.png"/></div></div></figure><p id="6dc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以将ref属性视为HTML元素ID的Vue等价物。它是一个唯一的标识符，帮助我们检索页面元素。</p><p id="27e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参考值由我们设定，并且必须是唯一的。ref值也称为参考ID。ref属性由Vue内部使用，不会出现在最终呈现的HTML代码中。</p><p id="b21a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ref属性帮助我们访问所选模板元素的DOM对象。由ref属性检索的DOM对象由美元符号refs属性存储。该属性是内置属性，所有组件实例对象都具有该属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sn"><img src="../Images/68288d6c35557474702b0ae58835fb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDOgrsiWI5iLC1gLoJvnSA.png"/></div></div></figure><p id="351c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在后面的课程中，我们将学习如何使用子组件。我们可以使用ref属性来访问子组件实例。访问子组件实例实际上是ref属性的主要应用。</p><p id="9f04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查美元符号refs属性。目前，它的值是一个空对象。这是因为我们还没有为任何元素设置任何ref属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi so"><img src="../Images/2d8eb4909630799ae0ff03e1a6a69367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCoMu3fBezPbAAgxKYbKtQ.png"/></div></div></figure><p id="9f10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到H2标签，并在其中设置ref属性。我们还给H2标签一个ID。在下面的P标签中，我们做同样的事情。我们给它一个引用和一个ID。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sp"><img src="../Images/0bc1459019245ee61d50e7badf1f5737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clIqW9IYr5V0Ef4G_4MnRA.png"/></div></div></figure><p id="df03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们刷新页面并再次检查美元符号引用对象。</p><p id="1dbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，它的值变成了代理对象。代理目标对象有两个属性:消息和标题。</p><p id="bba4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个属性名与我们在H2和P标签中设置的ref值相同。属性值是H2和P标签的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sq"><img src="../Images/fbb867d729c9301cff3e3e81b09abc74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*KxcGR23lh3xCXF1OM6N7cg.png"/></div></figure><p id="0c4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们输出标题属性。</p><p id="caa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到了H2标签的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rj"><img src="../Images/29fa90efdd4227136f06d9e5f373cd11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNwgHtrPmcc5UXCfaYUJoA.png"/></div></div></figure><p id="fbf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">message属性返回给我们P标签的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rm"><img src="../Images/1895f60140a1251d6e60808446f68254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eH3tvKSjgq6R0g9FYJL5vQ.png"/></div></div></figure><p id="d828" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Vue 3中，代理对象通常意味着反应性。美元符号引用对象也不例外。它的属性都是反应性的，这意味着它们都返回了最新的DOM对象。</p><p id="3256" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用title属性设置H2标签的内部文本。我们给title属性分配一个新值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/843eff2a50f595d33093804a7c2433c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*E6Kjy87LUekVBAytcaK2Hw.png"/></div></figure><p id="f689" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们检查标题ref返回的DOM对象。</p><p id="7769" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到H2标签的DOM对象已经被更新。它的内部文本是title属性的新值。简单地说，ref属性总是返回给我们最新的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sr"><img src="../Images/422b07e551b5ad7fca745a8f85b338a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*zc6YlaAML3ADhpi4Fkuoiw.png"/></div></figure><p id="46d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们改变标题值时，Vue只改变H2标签的内部文本。H2标签本身已被重新使用。重用页面元素有助于提高程序效率。</p><p id="3cfd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用ref属性来证明这一点。</p><p id="500d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的Vue程序的最后，我们声明了一个名为H2的变量。我们使用美元符号refs对象的title属性来设置它的值。现在，当我们第一次加载程序时，H2标签的DOM对象将被保存到H2变量中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ss"><img src="../Images/fbcb671ea290c193dd698661bbcfcb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80M78V4SL0CrXSo8XF0jCg.png"/></div></div></figure><p id="b5dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们重置title属性的值。</p><p id="8e2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们再次输出H2变量。我们可以看到它的内部文本已经更新为新的标题值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi st"><img src="../Images/1e30367dc10de71615dfba789377e6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*HlOQ5Vd8bNlYGOq7hSlL_Q.png"/></div></figure><p id="92a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这证明了在我们重置了title属性的值之后，原来的H2标签仍然在使用。使用原来的H2标签显示新的标题值。</p><p id="1708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们学习了v if指令删除一个元素。让我们证明这一点。</p><p id="fd5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加一个新的数据属性。我们将其命名为<em class="np">控件</em>，并将其值设置为true。</p><p id="3e64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们转到H2标签，并在其中设置v if指令。我们使用control属性设置指令值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi su"><img src="../Images/25217805e1aef826d54c14b76d28c10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kg3pztZ6H3R1oQ1XwxkzTg.png"/></div></div></figure><p id="5881" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="6c99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们输出美元符号refs属性。此时，title属性与H2变量指向同一个DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sv"><img src="../Images/ec82ccc47cfbd1fd74e929eb3a532fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*36VatBgnhzfUeMJ_Aww06Q.png"/></div></figure><p id="2f1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将控件属性设置为false，以移除H2标签。然后让我们检查美元符号refs属性。</p><p id="ec77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到title属性仍然存在，但是它的值已经变成null。美元sin refs对象中的属性都是反应性的。它们总是返回最新的DOM对象状态。</p><p id="cf38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H2标签已经被v if指令删除，自然地，它的ref属性返回us null。然而，H2变量仍然保存着被删除的H2标签的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sw"><img src="../Images/2d45dea3633471616e13efb83eadc507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Iy9ZcrH62Ii6SKsEbqglQ.png"/></div></div></figure><p id="6b24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将控件属性的值设置为true，以取回H2标签。</p><p id="1be5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查美元符号refs对象。</p><p id="9fe4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的title属性现在指向新的H2标签的DOM对象。</p><p id="6462" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将title属性与H2变量进行比较，我们将得到false。</p><p id="119e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前的H2标签是新创建的。原来的H2标签已被删除。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sx"><img src="../Images/34c65c3ea6c5cdff79d3179ae2c1e508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*UiVCWtnX6QG2Ca6UNq-Jjw.png"/></div></figure><p id="32c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">refs属性应该只用作开发工具。在实际项目中，应该避免依赖ref属性来操作模板元素或子组件。</p><p id="4218" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这节课中，我们将学习一个新的Vue指令:v代表。</p><p id="29a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">for指令的v是FOR循环语句的Vue等价物。我们用它来迭代数组或对象。如果我们将一个v for directive嵌套在另一个v for directive中，我们就可以遍历一个对象数组。</p><p id="7f5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文本模板可以处理数组和对象。但是很多时候，我们需要检索每个数组元素或对象属性，并单独显示它们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sy"><img src="../Images/f5324cc41525eb83c9e5814fad481045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HJJVVKR-LN4X6yJTrM7pw.png"/></div></div></figure><p id="3cc8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从迭代一组原始值开始。</p><p id="e513" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先添加一个UL标签。在它里面，我们添加了一个李标签。第一个问题是我们应该在哪里安装v for指令？在标签里还是在李标签里？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sz"><img src="../Images/ab5be33e3407c01658e6b6925479a8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfSYJPDv1Ljj1b3UCu-EQw.png"/></div></div></figure><p id="f649" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住这个结论，接收v for指令的元素将根据迭代数组的元素总数重复创建。</p><p id="1a33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望为每个数组元素创建一个Li标记，并只使用一个列表显示所有数组元素。</p><p id="01bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着我们需要多个L1标签和一个UL标签。所以在这里，指令的v应该放在Li标记中，而不是标记中。</p><p id="3330" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v for指令对其值使用特殊的语法。我们在括号中声明了两个别名。第一个表示元素值，第二个表示元素索引。我们要给这两个化名命名。在这里，我将它们命名为元素和索引。你可以选择其他名字，但要确保你的名字容易理解。</p><p id="b29f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们在括号后面的中添加关键字<em class="np">。在</em>中的关键词<em class="np">后面，我们放置了城市属性。如果只需要元素值，可以跳过括号。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ta"><img src="../Images/b5c1c37280b5845d2c243538b0f30513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1j9LH7u9A7W1AFg-U7gHqw.png"/></div></div></figure><p id="731f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v for指令遍历cities数组，并为每个数组元素创建一个Li标记。这两个别名在Li标签内部和之间都是可见的。在Li标记之间，我们添加了两个mustache标记来显示这两个别名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/1b483aea7b06be482831dbc90a0fb8e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQSu8seUSEVK4f_V7hJr4Q.png"/></div></div></figure><p id="85f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="4b7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到已经自动创建了一个列表。该列表有四个项目，每个项目对应于城市数组中的一个元素。第一个别名给出了元素值，第二个别名给出了元素索引。</p><p id="9b24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在HTML文件中，我们有一个标签和四个Li标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tb"><img src="../Images/386df97b97f8ad1706cdedc9f9df273b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4SNZRWwUrXeYjhyKH8JVA.png"/></div></div></figure><p id="5371" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最好给每个动态生成的元素一个键。该键作为唯一标识符工作，因此它的值必须是唯一的。</p><p id="2ad8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">保持键值唯一的最简单方法是使用元素索引作为它的值。关键属性是给Vue内部用的。你不会在最终呈现的HTML文件中找到它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tc"><img src="../Images/fe75adc2a676f23b0fc7fa4dbf834c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ej8en6lhByGOV9oZgyCrdw.png"/></div></div></figure><p id="b16b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么关键属性是什么呢？</p><p id="4207" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关键属性是Vue用来区分动态生成的元素。在当前程序中，key属性帮助Vue区分四个Li标签。</p><p id="f95f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果一个元素的键值改变了，Vue会创建一个新元素来替换当前的元素。如果键值保持不变，Vue将继续使用当前元素。</p><p id="8522" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，key属性决定了一个元素应该被重用还是被替换。通过手动更改键值，我们可以强制Vue重新呈现页面元素。</p><p id="7aa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们以第一个李标签为例。它的内部文本来自城市数组的第一个元素。</p><p id="dedc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置了城市数组的第一个元素。我们把它从伦敦改成达拉斯。</p><p id="5d16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以首先看到Li标签已经自动更新了它的内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rj"><img src="../Images/1573d11eff37ded410097ca0e7805194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjrZqHNnbn786JaSaKQpbQ.png"/></div></div></figure><p id="9bc8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题是Vue如何更新第一个Li标签？仅重置其内部文本还是用新的Li标签替换它？</p><p id="5b44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这取决于Li标签的键值是如何设置的。目前，键值是使用元素索引设置的。更改第一个元素的值不会影响它的索引。所以键值保持不变。因此，最初的李标记仍在使用。Vue所做的只是改变了它的内部文本。</p><p id="bbf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们证明这一点。</p><p id="3661" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将ref属性添加到Li标记中，以帮助我们访问呈现的Li标记的DOM对象。</p><p id="2836" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为Li标签是动态生成的，所以我们需要为ref属性设置一个动态值。我们通过将标签名<em class="np"> Li </em>与索引值连接起来来设置它的值。这样，每个Li标签都有不同的ref值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi td"><img src="../Images/d71c1f0cb1b6a165e06a44db2659e80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrcPFrD5wQ4E-N7Yp8diyA.png"/></div></div></figure><p id="8d1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们输出美元符号refs属性。</p><p id="8b5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在目标对象中有四个属性。属性名由标签名<em class="np">李</em>和元素索引组成。属性值是四个Li标签的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi te"><img src="../Images/52f656ef0b49d113917e0119e6b8e997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NNs_avyevKbRQ7ZCtwi-NQ.png"/></div></div></figure><p id="1e3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们声明一个新变量，并将其命名为<em class="np"> first </em>。</p><p id="ba88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用美元符号refs对象的第一个属性来设置它的值。现在，变量<em class="np"> first </em>指向第一个Li标签的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tf"><img src="../Images/75e4d49661e1dd407d9813414be49ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DURDbaVteAOV_C6v91HG7g.png"/></div></div></figure><p id="57f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="f5ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们先输出变量<em class="np"/>。我们有李牌。它的内部文本是伦敦。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tg"><img src="../Images/e89a83b688bfd3a0e5d997af58036213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*J3lHfUxIymnB7kn4TlI5og.png"/></div></figure><p id="27d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将城市数组的第一个元素更改为达拉斯。</p><p id="df8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们先检查<em class="np">再检查</em>变量。</p><p id="ad80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的内部文本值变成了Dallas。这证明最初的李标记仍在使用。Vue所做的只是更新其内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi th"><img src="../Images/cc7ca4b5a3c856aedbe69d532d7aa8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*uDo5T20dGIxkuRovcsyL7A.png"/></div></figure><p id="70cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将<em class="np">第一个</em>变量与<em class="np"> </em>美元符号引用对象的第一个属性进行比较，我们将得到true。这再一次证明了李的第一个标记从未被替换过。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ti"><img src="../Images/97771295ad3381b5c9659c15825ff25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*S2wf3TsOR2jg5h-a6PBxBw.png"/></div></figure><p id="f69a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们重置键属性的值。我们通过将元素和索引值连接在一起来设置它的值。我们不单独使用元素值的原因是可能存在重复的元素。索引保证每个值都是唯一的。</p><p id="bf9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，更改元素值也会更改键值。因此，Vue将创建一个新的Li标签来替换旧标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi se"><img src="../Images/945cbc9d69ee0546d736b2dd579d23aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5DgucntW5DO74oLMSFKjg.png"/></div></div></figure><p id="ac49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将城市数组的第一个元素设置为奥斯汀。</p><p id="8ef5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们先检查一下<em class="np">变量。我们可以看到它的内部文本仍然是伦敦。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tj"><img src="../Images/936c63ead687cb3b892bedc1a78fd6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*lyR8mQSoLyhetUrlNUjRwQ.png"/></div></figure><p id="42fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用其ref值检索第一个Li标签的DOM对象，并将其与第一个变量<em class="np">进行比较。</em></p><p id="2f73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次结果是假的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tk"><img src="../Images/3d81ce759305732db67903a99c55bed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*kOq6j1dGgm5fruIXjpoPDg.png"/></div></figure><p id="c587" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之前的对比结果是真的。这证明原来的第一个李标签已被一个新的所取代。通过改变键值，我们已经强迫Vue用一个新的标签替换第一个Li标签。</p><p id="b49d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在后面的课程中，我们将学习如何创建过渡效果。只有移除或重新创建的元素才能触发过渡效果。通过改变键值，我们强制Vue用一个新元素替换当前元素，这样就可以触发转场效果。</p><p id="111a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们尝试迭代一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tl"><img src="../Images/6493001f6b7d84e0437f2586ecdf28d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTrogmsQPNt8iYLdipCQJw.png"/></div></div></figure><p id="21b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了一个新的UL标签。</p><p id="81a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Li标记中，我们添加了v for指令来迭代car对象。</p><p id="ebcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与数组相比，对象可以使用属性名存储额外的值。所以在这里，我们声明三个别名。第一个表示属性值，第二个表示属性名，最后一个表示属性索引。对象属性不需要索引。这里的索引主要是为了帮助我们创建唯一的键值。</p><p id="5165" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Li标记中，我们显示了所有三个别名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tm"><img src="../Images/674c7b435f7c461018723908baf14033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdtTOxkc7aOfm9-0_568bw.png"/></div></div></figure><p id="91eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="2f28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有了新名单。每个列表项对应一个对象属性。我们有属性名、值和索引。迭代一个对象和迭代一个数组是一样的。我们只需要为属性名设置一个额外的别名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tn"><img src="../Images/54faed4e15b495f9af4219dfe5c3097f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*5MQPxqMs5-1Wi58agX1pYQ.png"/></div></figure><p id="7281" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们尝试一个更复杂的场景:遍历一个对象数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/da7375996d5c86ce060fac01012eb64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii9x4Vg11Un8_O8iZ6h2eg.png"/></div></div></figure><p id="fb2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先我们迭代外部数组。</p><p id="7225" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个元素都是一个对象。我们可以简单地通过它们的名字输出属性值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi to"><img src="../Images/88dae73b313bb8a46c7285781e4386f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUUnau0mdcmaurQ6frq8qg.png"/></div></div></figure><p id="d1b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有了新名单。每个列表项对应一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tp"><img src="../Images/cae3701e5a1636e395f2419d63297d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*g-YgD5E9amQn-w_5C6Pijw.png"/></div></figure><p id="ffbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们正在查询一个像MySQL这样的SQL数据库，这个解决方案是不错的，因为每个对象都有相同的形状。所有对象的属性名称都相同。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tq"><img src="../Images/68c1d7403f0a58a5554a37c4cd1e41fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEqU10QyngBC-hCpDMU4Fw.png"/></div></div></figure><p id="0c65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果我们查询一个像mongoDB这样的非SQL数据库，那么每个对象都可能是唯一的。没有一致的对象形状。预定义属性名是不可能的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tr"><img src="../Images/c39ad0cced2e53e037085f7ca2dadd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0X8HMauc-1Xw60B2H_smaw.png"/></div></div></figure><p id="3ccc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们需要迭代两次。我们首先迭代数组。对于每个数组元素，我们进行另一次迭代来输出每个对象属性。</p><p id="cd63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望为每个元素创建一个列表。这意味着我们需要多个列表，所以我们在UL标签中为指令添加了第一个v。我们用它来迭代数组。</p><p id="c6be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，每个元素都有自己的列表。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ts"><img src="../Images/5069a74a93ddb9eb288ab2c3402db44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62v9j5v1B3k29uq5DxJxag.png"/></div></div></figure><p id="adac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Li标记中，我们添加了第二个v来表示指令。我们用它来迭代每个元素。将输出每个属性名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tt"><img src="../Images/f83895e791912e330e29eed9c23d7f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atVOU2Nl5if3VY_nR-FEpw.png"/></div></div></figure><p id="5c76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="18c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有三个独立的列表。每个列表对应一个对象。这三个对象具有不同的属性。但这并不重要。内部v for指令简单地遍历对象并输出每个属性名和值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tu"><img src="../Images/50f0b16e1dcced8217eee4477d49548f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*B96P6fGTs9wDGeTOONit0Q.png"/></div></figure><p id="0a35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有三个数据属性。它们是品牌、型号和注册年份。在我们的实际项目中，这三个值分别从后端API中检索。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tv"><img src="../Images/044443c2f9684c4971beebdd0416c469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLWvaRNFcZX_xE4hu4p1jg.png"/></div></div></figure><p id="dc1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，我们需要在将检索到的数据呈现给用户之前对其进行处理。例如，我们想向用户显示车龄。车龄的计算方法是从当前年份中减去注册年份。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tw"><img src="../Images/622654115fcc6ba827a9e7a6400a5677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7bTi3QYRwyEYZVe-m8Lgw.png"/></div></div></figure><p id="afa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以在组件模板中定义数学表达式。Vue将执行表达式并返回计算结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tx"><img src="../Images/25720fd8d7a9a789be7e036c7ac7a34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OL3jcCqB2FVCBZbVo_lCVA.png"/></div></div></figure><p id="60b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将逻辑代码放在组件模板中并不是一个好主意。最好将逻辑代码集中在options对象中。模板最好保持干净和简单，最好只显示Vue属性。</p><p id="4461" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了帮助我们基于数据属性创建新的值，Vue为我们提供了计算属性。计算属性就像数据属性的扩展，使我们能够基于现有的数据属性创建新的值。</p><p id="9ed6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了创建计算属性，我们添加了computed选项。它的值是一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ty"><img src="../Images/79e16153a498a3b725ef4db853c18d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OV74sFK4tgq7BiZVYdLLSQ.png"/></div></div></figure><p id="e1fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了一个名为carAge的新属性。我们可以使用函数语法或对象语法来设置它的值。</p><p id="2546" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数时候，函数语法是最好的选择。我们依靠它来访问数据属性，所以要确保使用完整的函数。我们在函数中返回的值将被用作carAge属性的值。</p><p id="9adc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们实例化了日期构造函数，并用getFullYear方法对其进行了附加。然后我们从当前年份中减去registrationYear属性。</p><p id="c569" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">carAge属性实际上是registrationYear属性的一个getter。它返回一个基于registrationYear属性值的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rx"><img src="../Images/c9f43a7c14430fbf760b2e77cf0ee38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcoLOuvS5YhfSSfR3j9uiw.png"/></div></div></figure><p id="7e00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像数据属性一样，计算属性在组件模板中也是可见的。</p><p id="98c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到车龄已经计算出来并显示给用户。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tx"><img src="../Images/2b094d1fe54ef9329a0d2cd369d916d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNS8TUAdOKhKD-cfUKjLnQ.png"/></div></div></figure><p id="0254" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们打开根组件实例。</p><p id="4432" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">carAge属性已添加到目标对象的根级别。计算属性不是数据属性，它们不会被添加到美元符号数据对象中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/50c9a9eb27fef87cb2f0aa71c51047e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*poconggX6AoDBY3TZ_JpWw.png"/></div></figure><p id="ac48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计算的属性是反应性的。如果我们设置一个新的注册年份，carAge属性将相应地改变，组件模板将自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/71e3d119c0a0e46921f642d987f10761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nqRTMCYVB44LxnsTV9r7Q.png"/></div></div></figure><p id="ab62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">carAge属性是只读的。原因是我们用函数语法定义了它。它只有一个吸气剂。没有设置器来处理新值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/84032f8919a4a7c55bd49ea30028fe65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWUCL5l1825oiGgIsmOIUQ.png"/></div></div></figure><p id="8575" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数时候，只读的计算属性正是我们所需要的。我们不需要担心数据属性被无意中修改。</p><p id="5f3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计算属性和数据属性不应同名。让我们看看如果我们确实有一个命名冲突会发生什么。</p><p id="c3e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建一个新的计算属性，并将其命名为brand。此名称下已经有一个数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tz"><img src="../Images/e26c888323527bbdcc539af5669371ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HL_6jubXuduzNoIslyXAGA.png"/></div></div></figure><p id="875c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。我们可以看到数据品牌比计算品牌具有更高的优先级。</p><p id="3f81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">警告称计算属性品牌已经在数据中定义。这证明数据属性是在计算属性之前处理的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ua"><img src="../Images/1aa8040e154e6912eb8fc77085445323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tbi0Q26LZD3_GL7xfisRvA.png"/></div></div></figure><p id="335c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查vm点品牌并检查组件实例对象。</p><p id="a423" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">VM.brand返回给我们数据品牌的价值。但是实例对象根级别的brand属性存储计算出的brand值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ub"><img src="../Images/b366d7a3af0490057ec2c7e339f10a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d1dlspxDCjGGCIzIGE_1w.png"/></div></div></figure><p id="6b1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里看到的品牌属性来自代理目标对象。vm点品牌的价值由品牌获取者决定。品牌获取器返回数据品牌属性，而不是计算的品牌属性。这意味着可以创建计算的品牌属性，但永远无法检索。</p><p id="30c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也证明了目标对象的属性值可能不总是与从代理对象中检索到的属性值相同。我们得到的最终值取决于代理getter。</p><p id="1d85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们试试对象语法。我们创建一个新的计算属性:FullName。我们给它分配一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uc"><img src="../Images/d0db97416d3e637adde3dfd47ef97d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gA4LCC9bVJw_ND3pAjsbzQ.png"/></div></div></figure><p id="e95e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个对象允许我们设置一个getter和一个setter，从而使fullName属性可读和可写。</p><p id="ebcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">getter和setter必须使用完整的函数来定义。原因和之前一样。我们需要它指向组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/edeee065de63b9203a210d569292bee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87Y-Rb6Dx6I2t2isqbJlWA.png"/></div></div></figure><p id="dfb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在getter中，我们一起返回品牌和模型值。我们用空格将它们连接起来。</p><p id="85fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们访问fullName属性时，我们将收到一个包含品牌和型号值的字符串。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ud"><img src="../Images/d2846418b9443f8e8ffc166d1759f122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CBbshIZHtsNhbdN-Sxvgw.png"/></div></div></figure><p id="6895" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">getter返回的值和分配给setter的值不必相同，甚至不必是相同的数据类型。</p><p id="d676" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给setter分配一个数组。我们将第一个元素分配给品牌属性，将第二个元素分配给模型属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ue"><img src="../Images/bdee0ed8ca51e26d83c891719d1416cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSZBVRe0XqBzxg-c-w3Mig.png"/></div></div></figure><p id="7b28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。我们首先检查组件实例。</p><p id="1ed9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">全名属性的值包括品牌值和型号值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qa"><img src="../Images/f815e278a9093743af517de30a7233e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTxWtXdKjJAmtkCHK9F73w.png"/></div></div></figure><p id="c66d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们试试它的setter。我们给它分配一个数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qu"><img src="../Images/d6b46c8d225e9d4072ec5c3ae848b103.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*z9s_e9sIS6KbskNBofnVAw.png"/></div></figure><p id="d61c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到品牌和型号的价值已经被重置。我们可以使用一个计算属性重置两个数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uf"><img src="../Images/b9c10bd9d125e422ae029b0cec509f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTjSey0QZZ81gZ8TsXelqQ.png"/></div></div></figure><p id="b3b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计算属性依赖于此来访问数据属性，所以要确保只使用完整的函数来定义getters和setters。</p><p id="afda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这节课中，我们将学习如何定义和使用Vue方法。我们还将学习如何使用v on指令来监听事件和触发Vue方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ug"><img src="../Images/1b3852f0834337ac27a58def70f0be80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTZUvFjqzBrybnZA3_heqg.png"/></div></div></figure><p id="28c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue方法是在方法选项中定义的。</p><p id="8a14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个Vue方法都应该使用完整的函数来定义。不要使用箭头功能。原因和之前一样，我们需要Vue方法有一个可控的这个。</p><p id="083a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦定义了Vue方法，它将被添加到组件实例的根级别。就像数据属性或计算属性一样，Vue方法可以通过它来访问，并且在组件模板中也是可见的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uh"><img src="../Images/c3dff9f21e3c27aa335cb54ad6a5e74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IrddLB-CV0_Dml3QHZtvbA.png"/></div></div></figure><p id="fc3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行测试方法，看看它指向哪里。</p><p id="2c29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它指向拥有测试方法的根组件实例。因此，Vue方法可以通过它访问其他Vue属性和方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rm"><img src="../Images/1c95110202668f686cf1fcd25c743970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJQcsOQieg61kz7JaB9XQQ.png"/></div></div></figure><p id="328a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们使用Vue方法创建一个简单的计数器应用程序。我已经预定义了一个名为number的数据属性。我们把它放在H2标签里。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ui"><img src="../Images/69d7172db10b3a09150a06430751cf23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uf_iW-K4oY-H6pEvN3Rh6g.png"/></div></div></figure><p id="1229" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们创建一个名为increment的新方法。</p><p id="63cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于演示的目的，我们首先在控制台记录方法名。我们通过这个方法访问number属性，并将它的值加1。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/790d025ed37a3abacd1581a819621eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2Ds4Oq4Mg3GOYCr2ozjMg.png"/></div></div></figure><p id="b58a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="6d90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们调用increment方法两次。</p><p id="950b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数字值从0到2。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uj"><img src="../Images/63e238012dd45b4cc971507e011bf12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxGIt_QPcWx-wPCrr10dcw.png"/></div></div></figure><p id="c2a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">手动调用增量相当不方便。让我们创建一个按钮，并用它来触发increment方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uk"><img src="../Images/72b4b792514a395263a6afaaa0f72bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1_9yGT5Xa5ZUjeKNZC63w.png"/></div></div></figure><p id="180f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用本机JS，我们选择按钮并将addEventListener方法绑定到它。我们监听点击事件并触发回调。</p><p id="e2e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">addEventListener方法的Vue等价物是v on指令。它监视绑定事件并触发一个或多个Vue方法。</p><p id="84af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">应该将v on指令添加到触发受监控事件的元素中。在这里，我们将它放在按钮标签中。</p><p id="f11e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指令参数是被监视事件的名称。在这里，我们将其设置为点击。Click是一个本机HTML事件。在后面的课程中，我们还将学习自定义事件。</p><p id="065a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指令值是我们想要触发的方法的名称。这里，我们将其设置为<em class="np">增量</em>。我们只需要方法名。方法名后面的括号是不需要的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ul"><img src="../Images/fcf0713da47e8455ae4ec0cbff45efb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1XnwmX7IISyKTYjlRP5E5g.png"/></div></div></figure><p id="dc04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="85d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次我们点击按钮，我们触发<em class="np">增量</em>方法，数值增加1。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi um"><img src="../Images/90fd7573a9735164f47edb0a9fba92fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*JL0rJkyQApw6VJSFt-1b1A.png"/></div></figure><p id="6083" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">被监视的事件向被触发的方法发送一个事件对象。这个对象代表本地点击事件。它与传递给addEventListener方法的回调的值相同。</p><p id="2b53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不同的事件发送不同的事件对象。本机click事件发送本机mouseEvent。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi un"><img src="../Images/e5e5fbab87b1d8207f43dcf73bdcc96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71v4G4J1EPwdX95VKb_HMw.png"/></div></div></figure><p id="cffb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以在方法名后面放一组括号。</p><p id="00f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="a916" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单击该按钮仍会触发increment方法。但是事件对象不见了。参数值未定义。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/cd871d7b2fbd2945272adae0d66f68e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEvsb47Xq5fh6bPnB1apmQ.png"/></div></div></figure><p id="d3cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个问题可以通过将事件对象显式传递给increment方法来解决。事件对象存储在全局变量$event中。在后面的课程中，我们将经常使用这个全局变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uo"><img src="../Images/0b56ca131534136df53488211a879ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyzxwdips8cWbgAeCew7kg.png"/></div></div></figure><p id="feac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，本机mouseEvent对象已经发送回增量。</p><p id="55d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数时候，你应该跳过括号。只需将方法名赋给v on指令就足够了。</p><p id="af9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你需要设置你自己的参数值，那么括号是必要的。确保将美元符号事件设置为第一个参数。否则，您自己的参数值将覆盖事件对象。但是如果您不需要事件对象，那么您可以使用自己的值设置第一个参数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi up"><img src="../Images/ac05d563e7bb6418f63a3306284fdd68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjCZYYRgexRfOm78UShuQQ.png"/></div></div></figure><p id="469b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v on指令也适用于内联方法。</p><p id="0ef5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指令值可以访问组件实例。number属性可以直接访问，不需要任何前缀。我们可以直接在它后面加上增量运算符。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uq"><img src="../Images/28b5d713a6d3a7b66b8f3a34afb00646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Aa6qrAKr9apHbUUZrFKEg.png"/></div></div></figure><p id="4462" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指令值的v是一个JS表达式，但它是一个相当有限的表达式。它无权访问窗口对象。因此，如果您想要控制台记录某些内容，您就不能这样做。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ur"><img src="../Images/087b523e5d707c6d6d3afa301b6a755f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OnZqN07gGoIa0I7-ocgecA.png"/></div></div></figure><p id="69d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的实际项目中，我们应该保持模板简单和干净。逻辑代码最好保存在options对象中。实际项目中不推荐使用内联方法。</p><p id="f30c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v on指令可以一次触发几个方法。</p><p id="6476" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们定义了两种新方法:M1和M2。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi us"><img src="../Images/8819575c8ba555df335257924619c8b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*dCukxDTwyt7iuZySdjA0WQ.png"/></div></figure><p id="a857" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们想同时触发M1和M2。</p><p id="4897" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了一个新按钮，并在其中添加了v on指令。在指令值中，我们列出了这两种方法的名称，并用逗号分隔它们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ut"><img src="../Images/00112eefa1d7311d29c75c6f0f7e0fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_4DDQuduCwhfRvuQb1f0A.png"/></div></div></figure><p id="871d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="27b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它不起作用。这两种方法都没有被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uu"><img src="../Images/8c251dcf3acd043dc2b33151dc92a2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wY5v3uAZb2NURb6c-9sVg.png"/></div></div></figure><p id="36b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当触发多个方法时，括号是必需的。</p><p id="00ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到M1和M2现在一起被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uv"><img src="../Images/f42a0449da99a7232df5c3832ef3e840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNa_T6sk08fciW60zOTtsA.png"/></div></div></figure><p id="b5d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像我们之前说过的，空括号覆盖了事件对象。所以我们需要在两个方法中显式声明事件对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uw"><img src="../Images/f314c9fe4d199aacb74f4710fb6aeb64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkhONKnsGexJTI4Dc5ptfQ.png"/></div></div></figure><p id="0a88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">手册上说我们应该用逗号来分隔方法，但是如果你用分号，你的程序仍然会工作得很好。</p><p id="7bec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你甚至可以混合逗号和分号。</p><p id="d590" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你的程序会运行良好，但最好坚持使用手册的建议:逗号。</p><p id="98db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以混合使用内联方法和Vue方法。用昏迷把他们分开。根据我的测试，分号也可以。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ux"><img src="../Images/abd27f89f4f0784f7276bffb96d51458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibK3a2o7up4-AedrScwbZg.png"/></div></div></figure><p id="0121" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将一起讨论闭包和v on指令。</p><p id="d38f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们创建两个按钮。我们将第一个按钮命名为Vue按钮，将第二个按钮命名为name按钮。为了选择第二个按钮，我们给它一个ID。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uy"><img src="../Images/4558f6f01db6ea6c66a4173c94622035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfQyHFfn0hjfa0PYDYem8A.png"/></div></div></figure><p id="01ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原生按钮需要原生JS代码。我们添加了一对新脚本标记来定义本机JS代码。</p><p id="5807" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从原生按钮开始。我们通过它的ID选择它，并将其绑定到addEventListener方法。我们监听点击事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uz"><img src="../Images/b08839f1c8b8eb9ff7a04aaf49155bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gaPzd5gDFM3QuMvKNL951Q.png"/></div></div></figure><p id="1613" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们创建一个函数并命名为outer。</p><p id="0551" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在外部函数的根级别，我们控制台日志<em class="np">本地外部函数</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi va"><img src="../Images/0ac404656d2a37b7fa43eebbedeea5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyRsfEdLBWCghfNkEGSvgA.png"/></div></div></figure><p id="60f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们返回一个子函数。返回的函数是使用完整函数定义的。在返回的函数中，我们控制台日志<em class="np">原生内部函数</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vb"><img src="../Images/fe89634c33664686c9737d12902f9992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0m7Ma91sL7-_ACW4mnYqg.png"/></div></div></figure><p id="01b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将外部函数传递给addEventListener方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/0c7981ec71ee2c04bcf56fa06d66b288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMm6hR30m8yJrsZlfDnQqg.png"/></div></div></figure><p id="7dc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们每点击一次原生按钮，就会触发外层功能。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vc"><img src="../Images/aba2e1e2e660e72a6eaaffd5dc319f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aeU5iAXTV_Sylyv7NJ3_PQ.png"/></div></div></figure><p id="7d8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了触发内部函数，我们需要在outer后面添加一组括号。这样，返回的子函数将绑定到click事件。</p><p id="3432" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也意味着当我们刷新页面时，在我们点击任何按钮之前，外部函数将被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vd"><img src="../Images/dad23d037decad7845f38e89fec0d00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRULnzWFdhmQRoCSlltX-Q.png"/></div></div></figure><p id="efb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="677c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回的子函数现在被绑定到click事件。每次点击native按钮，都会触发内部的子函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ve"><img src="../Images/9ad207f7ec35f358e0cb866d8ad72069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doEV1_pSxIWLlN7KKsXPFw.png"/></div></div></figure><p id="958b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在外部函数中，我们声明了一个变量:Number。我们将其值设置为零。然后在内部函数中，我们控制台log number++。我们在这里创建了一个基于闭包的计数器程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vf"><img src="../Images/b2d2b9d96108cd41e92d6ac70a7bf2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnBLytxd10Aum5KhFOB_jw.png"/></div></div></figure><p id="03c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次我们点击nativeButton，内部函数都会给number属性加1。每执行一次内部函数，同一个数字变量就加1。这就是计数器程序工作的原因。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vd"><img src="../Images/085e0da782178e377f62164cb2d98d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jh9GBk2XyXBZODFFdKk4Rw.png"/></div></div></figure><p id="6318" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们使用Vue创建一个类似的程序。</p><p id="9267" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了方法选项，并在其中定义了一个名为outer的方法。我们控制台日志<em class="np"> Vue外部函数</em>在里面。然后我们返回一个内部函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vg"><img src="../Images/fb6ad7c037d6942c7e82cdc6e7704f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yMIBxjMk3tdFnoPvKUOdw.png"/></div></div></figure><p id="aa58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们继续之前，你发现程序设计有什么问题吗？</p><p id="3e8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回的内部函数被定义为完整函数。这样做合适吗？</p><p id="197f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这取决于内部函数是否需要访问组件实例。</p><p id="9c00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果返回的内部函数是一个完整的函数，那么它将指向窗口对象。Vue只重定向这个外部函数。返回的内部函数只是一个原生函数。我们需要使用bind方法手动将其THIS重定向到组件实例。</p><p id="e8e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更好的选择是使用箭头函数定义返回的内部函数。arrow函数从outer函数继承THIS。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vh"><img src="../Images/07766b38df8e11f84ee500fc6fa1b810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmHQEIUpLzJywCLSCgiyQw.png"/></div></div></figure><p id="6cd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在返回的内部函数中，我们控制台日志<em class="np"> Vue内部函数</em>。</p><p id="2328" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在VueButton标签中，我们添加了v on指令并触发了外部方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vf"><img src="../Images/886a1954676318f0712bc9b7c12ea045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knEwuJpctl1INDkjJKbmHw.png"/></div></div></figure><p id="9f4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单击VueButton只会触发外层方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vi"><img src="../Images/0d3454b8f3d1403bf7a2762a0484fecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2RYwAGkZhazuQAXieqHeQ.png"/></div></div></figure><p id="d9bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了触发返回的内部方法，我们需要添加一对额外的括号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vj"><img src="../Images/0a1b27d063d8425ab063494b4d770ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cl4jje5HGYmQfW5nOSDYDA.png"/></div></div></figure><p id="1ef5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们每点击一次Vue按钮，Vue外层方法和Vue内层方法就会一起触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vk"><img src="../Images/d47ee6c73e58c5645d5c50a7992e9410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HA6FiSz1T9ksqgns58gcdg.png"/></div></div></figure><p id="4ec3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着我们不会有一个结束。内部函数的每次执行都有自己的外部作用域。让我们证明这一点。</p><p id="fa73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Vue外部方法中，我们声明了一个名为number的变量。我们将其值设置为100。</p><p id="7e46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在返回的内部函数中，我们将控制台日志的<em class="np">号减去</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vl"><img src="../Images/446044a0f0764404e1ed0028f44bbd0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69B3qag3AKNTZ2wDxU6xWQ.png"/></div></div></figure><p id="7b27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="a6d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到Vue计数器应用程序不起作用。内部函数的每次执行都有它自己的外部作用域，因此每次我们点击VueButton，我们总是得到100。内部函数的当前执行不能处理其前任的结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ve"><img src="../Images/d4a6443e95602115de5b5868e0f26b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lx0q0HDlsHnkYKsThdT8yg.png"/></div></div></figure><p id="186d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将学习如何使用Vue收集用户提交的数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vm"><img src="../Images/31ca09a0ceebbf660317a44ee1cb9b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-erA8XvsDpIEupvNAwz_Fg.png"/></div></div></figure><p id="54ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们创建一个输入框。我们添加输入标签并给它一个ID。输入标签的value属性决定了输入框中显示的初始内容。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vn"><img src="../Images/a7871b780520e4193e09c95868afc842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-zMV4ykOeOtY_eg31iwiA.png"/></div></div></figure><p id="940d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在输入框中输入的任何内容都将存储在value属性中，覆盖其默认值。</p><p id="7e29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue使用v bind指令控制HTML属性。我们用v bind指令作为value属性的前缀，并将指令值设置为message属性。</p><p id="1647" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，消息属性的值已经作为初始值发送到输入框中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ua"><img src="../Images/121ea32f9c42a82957bc74452a55d03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMqCtY4XfOdUFIoxyyKQvQ.png"/></div></div></figure><p id="3b1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据现在可以从消息属性传输到输入框。我们下一步的工作是扭转方向。我们希望使用输入标签修改消息值。</p><p id="56a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们来看看原生输入框是如何工作的。</p><p id="6209" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到了输入框的DOM对象。然后我们将它绑定到addEventListener方法。我们监听输入事件。输入事件对象将被传递给addEventListener方法的回调。</p><p id="ffcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在输入框中输入的每个字符都会触发输入事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vo"><img src="../Images/63ee1f3d6c5086b0336d0c7a6037c37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Up4LuZcnbsA-gl43ZrBPA.png"/></div></div></figure><p id="29b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们打开最后一个输入事件对象。</p><p id="dd41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">向下滚动，您将找到一个目标属性。目标属性指向输入标记的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rm"><img src="../Images/54dd842740638b169bf6bc0657171024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdOV8BZCY5QticOHN-JsAQ.png"/></div></div></figure><p id="6a3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开它，滚动到最后。这是一个很长的物体。</p><p id="97ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在最底部，我们会发现一个名为value的属性。它对应于输入标记的value属性，使我们能够访问用户提交的数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vp"><img src="../Images/1d890e34617976ef5d88df12501e322d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_ZD7ys6nYVTa93g9gE3QQ.png"/></div></div></figure><p id="8d16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结论是实时获取用户提交的数据，我们监听输入事件并监视<strong class="kd iu"> event.target.value </strong>。</p><p id="0232" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在输入标签中，我们使用v on指令来监控输入事件。我们使用inline方法重置消息属性。</p><p id="886f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您的实际项目中，避免使用内联方法来保持模板的整洁和简单。我们在这里仅用于演示目的。</p><p id="b64d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以通过$event变量访问输入事件对象。我们用网点目标值作为附录。</p><p id="945c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，用户提交的数据已经被分配给了message属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vq"><img src="../Images/859a9b68ae00e17ebef3ab429066b975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szckvNI85wuYw4vh32I3MQ.png"/></div></div></figure><p id="7970" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="f9e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到输入框现在可以控制消息属性。我们可以实时控制消息属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vr"><img src="../Images/b7fd7ca59c383ca988c3b9d10c8075c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDsmHI4aW74bhgLB2eQK9Q.png"/></div></div></figure><p id="03e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在输入标签中设置两个指令相当不方便。Vue为我们提供了一个语法糖:v模型指令。</p><p id="f0d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v模型指令不需要参数。我们给它分配消息属性。这就是我们需要做的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vs"><img src="../Images/a9c39f1223524c1570e851cf9ac88495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VM7dwnvImLV21r9nqRzAg.png"/></div></div></figure><p id="93cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相比之下，输入标签看起来更干净，也更容易阅读。我们可以很容易地看出这个输入标签与消息属性相关联。</p><p id="bfb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法糖只是一段较长代码的较短别名。我们在这里使用的输入标记是一个文本类型的输入标记，它的v model指令将自动扩展成下面列出的v bind指令和v on指令。v bind指令控制value属性，v on指令监控输入事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vt"><img src="../Images/66c1fba5c9a34fb93d650edcd206dd60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyPaY-9sv4rjkFTqyyuv1g.png"/></div></div></figure><p id="86dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，输入框收集的所有内容都被视为一个字符串，包括数字。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rm"><img src="../Images/6999f71d1f8db22a2784d49a39a1872f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUZ1IRXr7vwqjLug297gaA.png"/></div></div></figure><p id="e0d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我们需要在v模型指令后面加上数字修饰符。修改器通过点连接到v模型指令。数字修饰符只影响数值，其他值类型仍被视为字符串。</p><p id="a68b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，数值将被保存为数字，而不是字符串。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qx"><img src="../Images/082ddba2b2961cf3012cf82d39b01f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OR0HNCfsC4T_yqiEjYG-vw.png"/></div></div></figure><p id="8dc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当我们在输入框中输入一个字符，输入事件就会被触发，bind方法就会被执行。</p><p id="c3cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对每个事件都做出反应通常是不必要的，尤其是对于较长的文本。为了提高程序效率，我们可以在v模型指令后面加上lazy修饰符。</p><p id="a0bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经输入了几个字符，但是消息属性保持不变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vu"><img src="../Images/df63721c34bc4bbe9dade29fd65764ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZhISnm2C5LvcAVxpkoQA1g.png"/></div></div></figure><p id="c1df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要提交文本，我们要么按ENTER按钮，要么将焦点从输入框中移开。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vv"><img src="../Images/2df23e85e13ddf672450906270cf7773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZQo2QuKgyAFH_GDZYpeNA.png"/></div></div></figure><p id="7376" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，v model指令不再响应我们在输入框中输入的每个字符，而是等到输入结束后才做出一个响应。</p><p id="45ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，用户可能会不小心在单词前后键入一些不需要的空格。这些不需要的空白仍然被保存，浪费内存空间并导致格式化问题。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vw"><img src="../Images/4724df312a5e8832a0a81276fb160270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZkAv5zteOD49pCjKkhztQ.png"/></div></div></figure><p id="fbdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用trim修饰符来删除这些不需要的空白。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vx"><img src="../Images/0a167632162a09913b059220b2a218ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UilIvK97AOSycveGCtJ0Rw.png"/></div></div></figure><p id="d608" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">trim修饰符不会删除单词之间的空格。无论你在两个单词之间放多少空格，它们都将被保留。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vy"><img src="../Images/b5fa2b484cb632b9bf09f8ce36fafc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Svt5u-Bkncwf_-qJ7pkFA.png"/></div></div></figure><p id="6258" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个输入标签。它连接到消息属性。</p><p id="9a35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很多时候，我们需要限制用户可以输入的字符数。假设我们将最大字符总数限制为10。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi vz"><img src="../Images/fa8c9acd9022381497f8ff42d74e3f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*g1AIPnhmOnLPfOD0cYRtoQ.png"/></div></figure><p id="9569" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先创建一个新的数据属性:Max。我们将其值设置为10。我们用它来控制最大字符串长度。将来，如果我们需要重置最大字符串长度，我们只需要修改max属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ts"><img src="../Images/2905d5765c125b5e24408d59951b13b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdXvPIpFIpZXWeab9mM_zw.png"/></div></div></figure><p id="7900" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在输入标签下面，我们添加了一个span标签。我们用它来实时显示用户还剩多少字符。</p><p id="f066" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了计算剩余的字符，我们从max属性中减去<em class="np">消息点长度</em>。</p><p id="5426" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以得到我们还剩下多少字符的实时反馈。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wa"><img src="../Images/d640754032c2eeed23fcb73e197d089a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-I7IqGUgBktOQt-IHVMysg.png"/></div></div></figure><p id="3992" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要删除多余的字符。我们回到输入标签，添加v on指令。我们监控输入事件。不要监控变更事件。稍后我们会告诉你为什么。</p><p id="fc97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们触发检查方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wb"><img src="../Images/3a93aa92badd89464671dcb89b9762f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8k5r6eyOxNzJUxq2UtqS5A.png"/></div></div></figure><p id="d63a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们添加methods选项来定义检查方法。</p><p id="d8b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先检查消息长度是否超过最大值。如果是，我们重置消息值。我们将message属性连接到substring方法。我们使用max属性将第一个参数值设置为零，将第二个参数值设置为零。这样，只有前十个字符将被赋回消息属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wc"><img src="../Images/0c43bfb66440d8abac8671ea68658fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yK4WmddRdWTID0BkzhFMA.png"/></div></div></figure><p id="1c6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="d7bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入框现在最多只接受10个字符。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wd"><img src="../Images/c039dbf6c8689a4020933127b21999bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WAxdA47sMisGu_uBXN_Jw.png"/></div></div></figure><p id="6704" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将<em class="np">输入</em>事件切换到<em class="np">改变</em>事件。</p><p id="9025" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">change事件监视输入框中的文本更改。只有在我们提交了不同的文本后，它才会被触发。这意味着我们可以输入任意多的字符。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi we"><img src="../Images/b4904452b4062fc81229ac62f6ef3c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZRL37B1O6oFZiE8LLzeVQ.png"/></div></div></figure><p id="773a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有在我们提交文本后，文本才会被截断。相比之下，输入事件提供了更好的用户体验，因为用户不会看到他们输入的一部分突然消失。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wf"><img src="../Images/77ad82c95d9d4909966422f4c12545c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5--mz12GjrDE56KtvGEtA.png"/></div></div></figure><p id="822e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将向您展示如何使用其他类型的输入标签。我们将从无线电类型开始。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi wg"><img src="../Images/0de00549d893194dfc7d465c69661a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*kukDR0d4bb_23pkYTAShiw.png"/></div></figure><p id="8259" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单选类型的输入标签生成一个可点击的圆圈。一旦选中，就无法取消选中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi wh"><img src="../Images/858e59f358bdc748f9f92cba5ec124d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*Qs2MTUG1PKmyZuvvtEFThg.png"/></div></figure><p id="4037" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">圆圈本身需要代表一个值。默认值为上的<em class="np">，表示圆已被检查。</em></p><p id="6ece" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用value属性，我们可以设置一个自定义值。在这里，我们将其设置为apple。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wi"><img src="../Images/b87ac0755898e343b4b5298ed30e1101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6Yv1Vb_f0uXn9GPDE7nQQ.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi wj"><img src="../Images/941a1c12b5f1b1d66e86660a35fdd024.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*m_cOTFZg42J2Ud6kKDeQzQ.png"/></div></figure><p id="87bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们有一个代表苹果的单选按钮。</p><p id="300a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们制作输入标签的另外两个副本。我们将第二个设置为橙色，第三个设置为桃色。</p><p id="cb7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们有三个单选按钮代表三个值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vo"><img src="../Images/f5d066db6b1e38b00cc38cbbda0a4cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGHyr0L80ajONlzgw0jmKQ.png"/></div></div></figure><p id="8413" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单选按钮用于单项选择。我们列出了几个选项，只允许用户选择一个。</p><p id="aee2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，这三个单选按钮是独立的。为了将它们组合在一起，我们需要name属性。名字值由我们决定。具有相同名称属性值的单选按钮将被组合在一起，一次只能选中一个按钮。</p><p id="cd55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，这三个单选按钮属于同一组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wk"><img src="../Images/2037931215a00809fd56b790f9ec8319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ax461Lw0FWFnAIzwH3DEsw.png"/></div></div></figure><p id="551b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="01a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们一次只能检查一个单选按钮。选中新按钮会取消选中当前按钮。一次只能提交一个值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wl"><img src="../Images/e5abc2c3c8d9116a90b7a02ecbd91a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Re9kGqwB0VTAlzTUGdhqJw.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi te"><img src="../Images/7571a7aabb5c9c754b13e8e2d4507553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cn5cPKbIq1fBGzDK6oDTdA.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vv"><img src="../Images/788762ab751d86881058de94db06fbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sn3U4ImspapTkxKUP2JHXw.png"/></div></div></figure><p id="17de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望将提交的值保存到<em class="np"> picked </em>属性中。</p><p id="1bc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加v on指令并监控输入事件的变化。结果是一样的。</p><p id="7de8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<strong class="kd iu"> $event.target.value </strong>重置<em class="np">选择的</em>属性。机理和以前一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wm"><img src="../Images/2355a8fd1e35902813a132075bc0106b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utC2kYz7VxrbP1_P4I0rKw.png"/></div></div></figure><p id="b06f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将v on指令复制到剩下的两个输入标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wn"><img src="../Images/4d3662d869aed4f3c27f4702176ffa56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwmkuHkMwfHwOdZDs1Z-uA.png"/></div></div></figure><p id="ff86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，所有三个单选按钮都向<em class="np"> picked </em>属性发送值。让我们测试这个程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wo"><img src="../Images/b5e4677abe4fc85f5fc22a3e1499f58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7FvZv2nYQwk1y1eM2Ie7w.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/5d68c2617eef148ed27d4c4184ea2582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jE1HA0Wel330Chq5Escdhg.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wp"><img src="../Images/83ef8929ae43b8bdefc098190ca675b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cddqQ5sBw8WeAuIHQBMY5w.png"/></div></div></figure><p id="b9ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过单击三个单选按钮中的一个来重置<em class="np"> picked </em>属性。</p><p id="635f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的工作只完成了一半。我们希望<em class="np"> picked </em>属性也能控制三个单选按钮。当我们手动修改picked属性时，我们希望相应的按钮被自动选中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vy"><img src="../Images/5278ae8423dabf2ae2a31c254ae3f3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQjGBkZ3uFB1Q5RXFTzcKw.png"/></div></div></figure><p id="7b22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">选中</em>属性决定单选按钮是否被选中。我们用v bind指令作为它的前缀。</p><p id="4c18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将选择的<em class="np">属性与当前输入标签的值进行比较。如果两个值匹配，比较表达式返回true，v bind指令将安装checked属性。单选按钮将被选中。</em></p><p id="e20e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">否则，v bind指令将删除选中的属性，单选按钮将被取消选中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vh"><img src="../Images/a717dd07d5ef31efa62c2f328188fdb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtvchmqZKt7XPJikLw0Q_A.png"/></div></div></figure><p id="d1d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将v bind指令复制到另外两个输入标签中。记得更新比较值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wq"><img src="../Images/3f4e6f00567fc61cefb471cd1c42f50d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0C4ciLhZftGnGOw3FDdEMA.png"/></div></div></figure><p id="e7a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="3c3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">picked属性的初始值是apple。当我们第一次加载页面时，第一个单选按钮被选中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wr"><img src="../Images/9884b0c0d8ef8a5259250e65dd760ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZoRm6qrrJOkIDcitotbSw.png"/></div></div></figure><p id="f564" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">点击其他单选按钮重置<em class="np">选择的</em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vy"><img src="../Images/9f74ce59dab3e03877f792760093d720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOxJALVzHp_dLvvyHE50Eg.png"/></div></div></figure><p id="d3d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们手动为<em class="np"> picked </em>属性分配一个新值，相应的单选按钮将被自动选中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/e1bbc5a6cb9ec332c6552b936b995433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wq7zU16eB639PBwt9xwrOQ.png"/></div></div></figure><p id="4cdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有输入标签的检查属性都由我们控制，不再需要名称属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ws"><img src="../Images/a177995312cf15f8d75d1e518d37f652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Hz-dh3nEp9tcjwxSWUtXg.png"/></div></div></figure><p id="c4c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v on指令和v bind指令可以替换为v model指令。我们只需要将选中的属性分配给它。</p><p id="4c00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将v模型指令复制到第二个输入标签中。我们保留最后一个输入标签不变，以提醒我们v model指令在单选类型的输入标签中真正代表了什么。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ta"><img src="../Images/5421f69d99ab3e564a737281f0673181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F52cHJgYaB0h2csdy84HJA.png"/></div></div></figure><p id="4e67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v model指令是一个语法糖，它实际代表什么取决于它的安装位置。当安装在radio类型的输入标记中时，v model指令仍然扩展为v on指令和v bind指令。但是v bind指令并不控制value属性，它控制的是<em class="np"> checked </em>属性。</p><p id="bb12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将尝试另外两种类型的输入标签:复选框和选择列表。我们将从复选框开始。</p><p id="d2ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">复选框用于多项选择。这就是我将list属性设置为数组的原因。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qc"><img src="../Images/7e5f189579236c7250cce555380ed912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJc0miAH5TTxrcak1zaL3Q.png"/></div></div></figure><p id="0e57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加一个输入标签，并将其类型设置为checkbox。</p><p id="94a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将得到一个可点击的正方形。就像单选按钮一样，我们需要value属性来指定复选框代表什么。这里我们将value属性设置为apple。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vl"><img src="../Images/d4d216fbfcea91076ae2a7714ab9aa07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJj2eDpnqU-E4IazFLUbBg.png"/></div></div></figure><p id="3b7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们再制作两个输入标记的副本，并将它们的值属性更改为orange和peach。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wt"><img src="../Images/b1bddd4e5a52019ef40d889fa8e6425e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKiS4mNIfGXudiMT8gr7xA.png"/></div></div></figure><p id="60db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们有三个复选框，分别代表苹果、橘子和桃子。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/911fd8ca8076a0afa8cbd635c53be6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3cmNeTdgpJZG2E694tW33A.png"/></div></div></figure><p id="a936" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个输入标记中，我们添加了v model指令，并将其值设置为list属性。您需要确保v model指令连接到一个数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wu"><img src="../Images/6b42d8f17baed33b9bc6d748a1582ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjUEh6Rwwt_7xdx0-SQ2Aw.png"/></div></div></figure><p id="d382" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将v model指令复制到接下来的两个输入标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wv"><img src="../Images/8546c67c6cae9b674ef063f5809a55ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsh3vPbMXDxCUc78OJwZ8Q.png"/></div></div></figure><p id="b3cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="bd4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">列表数组已经有apple和orange。所以前两个复选框是自动选中的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ww"><img src="../Images/e1eab4bff5d1c854fb49305a99d6d1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ksF-Ad1BFi5YpG9eqHWrA.png"/></div></div></figure><p id="8243" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单击第三个复选框将peach添加到列表数组中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qj"><img src="../Images/3138e92e7715371600b769354a05efaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LEhTmDZ_8Sj6TOiJDHbUg.png"/></div></div></figure><p id="e137" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">取消选中最后一个复选框将从列表数组中删除peach。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sy"><img src="../Images/2830fc763fac4c78190328ef93d47a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12DhkSYvFVKXTDZRalIL5w.png"/></div></div></figure><p id="185c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以用同样的方法去掉橘子和苹果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vy"><img src="../Images/6c0bf35402da7c74a0524048afa340f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGB0NfPeBDzME8EzCn8WWg.png"/></div></div></figure><p id="7e70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们手动修改列表数组，这三个复选框将相应地被选中和取消选中。</p><p id="9fdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们清空列表数组。所有复选框都会自动取消选中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wx"><img src="../Images/01ca16a4625e37b745e54e9c8533a189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwWL5pJo1MpNpl4JNySBbA.png"/></div></div></figure><p id="c7c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们从最后一个输入标签中删除v model指令。我们将使用v bind指令和v on指令重新创建v model指令。</p><p id="5b9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">复选框仍然由选中的属性控制。我们v绑定了<em class="np">选中的</em>属性。我们使用<em class="np">包含</em>方法设置指令值。</p><p id="53c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们检查当前复选框的值是否存在于列表数组中。如果是，includes方法返回true。将添加选中的属性。否则，includes方法返回false，选中的属性将被移除。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wy"><img src="../Images/ec364ffb236aca4737a9194b5a88b776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkdU4IeG1sxTUo5nTway_g.png"/></div></div></figure><p id="0269" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们取消选中一个复选框时，相应的元素应该从列表数组中删除。</p><p id="cfe2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们再次检查它，被移除的元素应该被推回到列表数组中。</p><p id="c5f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么如何做到这一点呢？</p><p id="f7b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在checked属性下面，我们添加了v on指令来监视输入事件。您还可以监控变更事件。</p><p id="192b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当输入事件被触发时，我们检查复选框的值是否存在于列表数组中。</p><p id="a81b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果是，我们使用拼接方法将其从列表数组中删除。</p><p id="5615" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">slice方法的第一个参数是开始元素的索引。</p><p id="7aaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将输入标记的值传递给indexOf方法来获取它的索引。</p><p id="83b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个参数控制将删除多少元素。我们把它设置为1。</p><p id="a129" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果复选框的值在列表数组中不存在，我们将它推入列表数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wz"><img src="../Images/3f8d6e93385ad18ecc5545eccedc9f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92SULtvNQAgEeGWnXqVESA.png"/></div></div></figure><p id="c0b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在您知道了当v model指令安装在复选框类型的输入标签中时，它代表了什么。</p><p id="19b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试选择列表。</p><p id="8471" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加选择标签。</p><p id="7955" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在它里面，我们添加了option标签。value属性决定了当前选项标记所代表的内容。像往常一样，我们添加三个选项标记来表示三个值:apple、orange和peach。</p><p id="58ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们给选择标签一个ID。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rd"><img src="../Images/584f66d5ff10accbe9e7ba9861be80a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywEyRX7wvkw04HCyY16BDw.png"/></div></div></figure><p id="6a9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们检索select标记的DOM对象，并将其存储在一个名为<em class="np"> select </em>的变量中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vn"><img src="../Images/43df2919630cc79b4f8a5573c8330f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qaqo-Ypi08kwbaw8ymE9yw.png"/></div></div></figure><p id="4cda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="8d99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一份选择名单。它有三个选项。目前，选择了第一个选项。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xa"><img src="../Images/9216dcd5a1ac7a18e193ca8209a157af.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*FXS27qkLR-a2VALhOhKKMA.png"/></div></figure><p id="2e7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们输出选择标签的值属性，这是当前选择的选项的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xb"><img src="../Images/84f48b8bb631c58ceed58a70022ac6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*bMGpMsLFUpEGXZYLkx5ARg.png"/></div></figure><p id="841b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将橙色分配给值属性。橙色是第二个选项的值。</p><p id="785a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，赋值完成后，选择了第二个选项。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/5a28539402bf0f4803ec7204ab25981e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyCQW104Pkq0mH9mqzFgtw.png"/></div></div></figure><p id="00d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将value属性设置为peach，将向用户显示第三个选项。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xc"><img src="../Images/4afd0789281f4c00ab94d0629e89c83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sbs0WUAETlcsTDuRfSBJ3g.png"/></div></div></figure><p id="0105" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，有了select标签，我们不需要处理<em class="np">选中的</em>属性。其值与选择标签的值相匹配的选项标签将被选择。</p><p id="6adb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在select标签中，我们绑定了value属性，并使用<em class="np"> picked </em>属性设置了指令值。</p><p id="d1fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以控制select标记的值，这意味着我们可以控制选择哪个选项标记。</p><p id="8193" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">被选中的<em class="np">属性的当前值是橙色的，所以当我们重新加载页面时，第三个选项标签将被选中。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vu"><img src="../Images/b4366a0c36b448b127198b954f5a9db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMxCWYPa4kJ2InkjHM55iw.png"/></div></div></figure><p id="fcc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过改变<em class="np"> picked </em>属性的值，我们可以选择不同的选项标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xd"><img src="../Images/92e7f1a520614de67fa9ddc9ba3019f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*wqLaJeayQ64C8NDJsE9fIg.png"/></div></figure><p id="157a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们反转数据流。我们想使用选择列表重置<em class="np"> picked </em>属性的值。</p><p id="25a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到select标签并添加v on指令。我们监控输入或变更事件。</p><p id="80eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用可以从美元符号事件变量访问的select标记的value属性来重置<em class="np"> picked </em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xe"><img src="../Images/61e593aeec1013b6e6a77d05e4770730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDlsZmAmDrEcYJX_AhiPfA.png"/></div></div></figure><p id="575c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以使用选择列表重置<em class="np"> picked </em>属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xf"><img src="../Images/63b941b486acec1a2b632682c77aff42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*_K-KynUJqCaHIoYoIw06iA.png"/></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xg"><img src="../Images/de907dc663fe522b293053e1a9249cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*qwjZQAW01rzCeryFD2WreA.png"/></div></figure><p id="0ac0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v model指令也适用于select标记。我们只需要将<em class="np">选择的</em>属性分配给它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vs"><img src="../Images/c60de8e591849132cefa747bc1665218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_I_Xl5wxhAaJg8yKOIpWQ.png"/></div></div></figure><p id="08e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当安装在select标记中时，v model指令的行为与它在文本类型输入标记中的行为相同。</p><p id="9fa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">select标签也支持多重选择，要启用它，我们需要在select标签中添加<em class="np">多重</em>属性。不需要属性值。</p><p id="2073" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要将v model指令的值重置为一个数组来存储多个选择的选项。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xh"><img src="../Images/42c53ae00984cbd8ecb24c7e365cc468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AEAQEs__qGjHoCIL4EYuw.png"/></div></div></figure><p id="34c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这节课开始，我们将学习如何使用Vue控制CSS样式。我们将从添加和删除类开始。我们将在下一课处理内联CSS。</p><p id="eb4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经预定义了四个类:两个背景类和两个文本类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xi"><img src="../Images/c26f06fcc7c8e5bf07966037e6e335fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgCMLKU3F4rs7C346Utxdw.png"/></div></div></figure><p id="074f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在项目样板中，我创建了一个span标记。span标记有一个外部DIV。我们将在这个DIV中添加和删除类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xj"><img src="../Images/495be9abfb863eb2b92cc419bf375c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*M80O4KrtdA2NItICWDFoRA.png"/></div></figure><p id="9d9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过class属性将类添加到页面元素中。让我们将bgOne和textOne分配给外部DIV。</p><p id="341f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，外部DIV已经接收了bgOne类和textOne类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xk"><img src="../Images/0da57288999df0f443150779f1094d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*DtdjVTxhTba3IIF8XHFxgg.png"/></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qf"><img src="../Images/accfda05a1276d702a2af73da701d1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKiw2QJ6KDpE-2ZM619JLA.png"/></div></div></figure><p id="a3b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们用v bind指令作为class属性的前缀。</p><p id="857a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原来的class属性值现在已经变成了一个JS表达式。我们不能在其中直接列出类名。我们需要使用对象语法或数组语法来设置JS表达式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sp"><img src="../Images/729dab78f6db5b45ec1dea4c89b5d905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vnjOgcvOjw7fjJfmX5UHw.png"/></div></div></figure><p id="a346" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从对象语法开始。</p><p id="7b13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用CSS类名作为属性名。属性值是一个布尔值。True表示将应用CSS类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xl"><img src="../Images/e2b8dea23b6a09589cc64fe7722f2d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kQBF-X97e4Fj2Qe8mE1Rg.png"/></div></div></figure><p id="bacf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="2948" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到外部DIV接收了两个新类:bgTwo和textTwo。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qd"><img src="../Images/e2f73f901e50a1d4c00f7a05c7b06291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3GLgA_DcUx902oXz4WaocA.png"/></div></div></figure><p id="2d58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以用根组件中的数据属性代替静态布尔值作为属性值。这样，根组件可以控制类。</p><p id="eac2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们把BG赋给bgOne。然后我们把反转的BG赋值给bgTwo。将只应用一个背景类。</p><p id="4a3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这两个文本属性，我们以相同的方式设置它们的值。我们使用文本属性来控制它们。将只应用一个文本类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xm"><img src="../Images/6c87afea7e04501f1bef94e8976cf55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSOpG6wD2bH255HO1r-mBQ.png"/></div></div></figure><p id="7a5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到数据选项来定义BG属性和Text属性。我们将这两个属性都设置为true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xn"><img src="../Images/cb28ac8d502deb21a952bdacbfd750ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pERGuBDwvxRGQx36B36h6Q.png"/></div></div></figure><p id="a7ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="6549" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到已经应用了bgOne和textOne类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vk"><img src="../Images/2299259a94fb646e0714f34acf8d749d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qx62NbCgQXeFop2j5i5IeA.png"/></div></div></figure><p id="607d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过反转bg和text属性的值，我们可以更改应用于外部DIV的类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rz"><img src="../Images/1114857d02e8f0f08cd47ba7e4fb07db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VbMbPcwNBZBPm6TRkK3eNw.png"/></div></div></figure><p id="86b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个按钮来帮助我们改变背景颜色。我们用它来反转BG属性的值。</p><p id="9d25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建另一个按钮来改变文本颜色。机理和以前一样。当我们单击按钮时，我们反转text属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xo"><img src="../Images/6e6cf8974196bae48cd34de900f90138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4lDZ3FU-QJbGSi1kQYVXw.png"/></div></div></figure><p id="079e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，通过点击这两个按钮，我们可以改变背景颜色和文本样式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xp"><img src="../Images/0a298b9066b5367076c12fcb5727122c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJEcr5ZGza2qxLrEi6pNcg.png"/></div></div></figure><p id="d2dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们为class属性分配一个新的Vue数据属性。我们称之为主题。</p><p id="4b5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转到根组件来定义主题属性。</p><p id="89d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用一个对象来设置它的值。在对象中，我们设置了两个属性:bgOne和textOne。两个属性值都为真。现在，仅主题属性就可以设置两个类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xq"><img src="../Images/0d59870f585e91d78a2f2a5372cbf577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3Sk4XQK44x4PcjKwnoqSQ.png"/></div></div></figure><p id="5d9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以将主题属性定义为一个数组。将添加数组中列出的类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xr"><img src="../Images/677a7b40ac65b312b98d50364d35caea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3MMHSxinFnUEq4518z1gg.png"/></div></div></figure><p id="0724" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们为四个类定义了四个数据属性。这四个属性是四个类的别名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xs"><img src="../Images/f3c48f3ad00aac1974679aa675db78fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*758kIueci1rAqSUHC11KnQ.png"/></div></div></figure><p id="f6cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为class属性分配一个数组，并使用类别名设置元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xt"><img src="../Images/6c1f89517a0beac11e9833b49dad559a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wt1m2s5ra3xP2q_8BuRegg.png"/></div></div></figure><p id="139b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到bgTwo类和textTwo类都已成功应用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xu"><img src="../Images/0381363eb330d5bfede725e803df41d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*WrIJ1HnAVpGtlMjxvOBgrA.png"/></div></figure><p id="99f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以使用更严格的对象语法和数组语法。我们使用一个对象来设置元素。语法和以前一样。属性名是类名，属性值决定是否添加该类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xv"><img src="../Images/ab1761cb776fb71368149e2afbc79af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hfm-PpL1Y6pMApizm11CpQ.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xw"><img src="../Images/e72088e098234fd9e50a8d1221c4bf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*eNL-vJgzy2-YgY_cWFhLSw.png"/></div></figure><p id="8559" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们用v bind指令给class属性加上前缀，class值就变成了一个JS表达式。类名只能在JS表达式中用作属性名。</p><p id="9817" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将向您展示如何控制内联CSS属性。</p><p id="819b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用v bind指令作为style属性的前缀，并给它分配一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xx"><img src="../Images/8c1684d7cbcfe21d65d90be6d0b9a1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrWkksp28AhY4gZgFPpKkw.png"/></div></div></figure><p id="9ad0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本机CSS属性用作属性名。属性值可以是组件实例中的静态值或数据属性。</p><p id="8e04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">小心使用原生CSS属性名。对于JS属性名，破折号是非法字符。我们不能直接使用它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xy"><img src="../Images/946d1705e5ceb1f82bbb08ed2701af1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXKJZUzvzUo6PdhPGMjzsA.png"/></div></div></figure><p id="a917" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们得到了一个警告和一个错误。这个问题是由仪表板引起的。合法的属性名不能有它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rd"><img src="../Images/b9a640572f682c95185e6ca3c7110e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQ8fPNL0W8T_6yCxHGLv6Q.png"/></div></div></figure><p id="e964" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要去掉破折号，把它后面的字母大写。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rt"><img src="../Images/8c7394b18dce0f915cb16398104ea7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tNpm98xnDY2KKD0Zvd8eLw.png"/></div></div></figure><p id="22a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再试一次这个程序。</p><p id="88a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，问题解决了。外部DIV的背景色设置为红色。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rt"><img src="../Images/8c7394b18dce0f915cb16398104ea7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tNpm98xnDY2KKD0Zvd8eLw.png"/></div></div></figure><p id="a8f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们用Vue数据属性替换静态值。我们把它命名为bgColor。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xz"><img src="../Images/45d463c548246059f84622c5c09b9476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eD2g_28oAaAJY9I5hptG3Q.png"/></div></div></figure><p id="74ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们转到数据选项，在bgColor的名称下定义一个属性。我们使用颜色代码设置它的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pz"><img src="../Images/dd0e7116851a8b10fc22ddebc6c78720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAWloh-0ug2CvHr0JvCMWg.png"/></div></div></figure><p id="56fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到新的背景色已经设置好了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ya"><img src="../Images/5940846fcf90475a42b83d9f32ee896f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbBfqMfci6IHLONU5Wc2gA.png"/></div></div></figure><p id="1d60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过更改bgColor属性的值，我们可以控制外部DIV的颜色。bgColor的值将被分配给本机CSS backgroundColor属性。</p><p id="5588" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，我们可能需要一起控制几个CSS属性。</p><p id="d0ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在数据选项中，我们创建了一个新的属性:styleObject。它的值是一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yb"><img src="../Images/e66eaa72dc0a76f0ea1d4d5452d428b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0PiF2kn6ygcEDL6TEKrEA.png"/></div></div></figure><p id="0f67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在其中设置了三个CSS属性:背景颜色、文本颜色和字体大小。破折号应该去掉，后面的字母应该大写。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vh"><img src="../Images/f07c01e7b9a84cd50ae9e7d4fdbd8e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhpxgRkDeqcqjRT_W_YAJw.png"/></div></div></figure><p id="1f10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们使用v bind指令将styleObject属性分配给style属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ws"><img src="../Images/a1e759709a2939f807c76cf64c495793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gg5c-1kCblY0k9eSpp4YzA.png"/></div></div></figure><p id="e130" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="0aa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到所有三个CSS属性都应用到了外部DIV。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/d94c3f067e3018eb652dc4c4fc83494b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeXiGCMJ-pv_iUD2CR9baQ.png"/></div></div></figure><p id="d0f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">styleObject属性存储分配给style属性的值。通过更改其属性值，我们可以重置外部DIV的样式。</p><p id="90e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对尺寸值要非常小心。它的值是字符串，而不是数字。你必须保留附录PX。不要仅使用数字来设置大小值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi yc"><img src="../Images/2442650c1201798ba523f6b8786be90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*ctLdW9Ziur1ugRwvCT1bdg.png"/></div></figure><p id="49c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，我们可能需要修改尺寸值。在这种情况下，我们必须将size属性定义为一个数字。</p><p id="3fe1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们绑定了另一个样式属性，并给它分配了一个对象。我们将fontSize属性的值与PX连接起来。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pr"><img src="../Images/215f5736db6c5e8826bc92e03402f240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGtC6YGRvgibVJWA8i25BA.png"/></div></div></figure><p id="38ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="d892" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们的字体大小设置不工作，即使我们有PX的附录。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/cea0747cd0fc5303bdfb14529a40f569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZPgGMIOTqeJ4GDnqxArVA.png"/></div></div></figure><p id="b757" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原因是我们设置了两个样式属性。一个HTML标记只能有一个样式属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yd"><img src="../Images/264fa225d5f38b13f4940ec864edd69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utEiNEUphKO_Z5UAqjdb9w.png"/></div></div></figure><p id="58b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您需要设置几个CSS属性，并且它们的值分散在几个数据属性中，您可以组合数组语法和对象语法。我们给样式属性分配一个数组。每个元素都是一个对象。</p><p id="4fb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将styleObject属性设置为第一个元素。</p><p id="b1ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于第二个元素，我们使用一个对象文字来设置它。我们使用本机fontSize属性作为键。记住去掉破折号，将字母s大写，然后我们使用Vue数据属性fontSize设置该值。记得加PX附录。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ye"><img src="../Images/18ee9ea79688b7a936ad4fc8c1ba2651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvYkA2_4gO90F-uxySg7xg.png"/></div></div></figure><p id="c9b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="05d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到所有三个CSS属性都被添加到了外部DIV中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vm"><img src="../Images/e0069262a6a79cf43ee1a77f6282ba1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1AJoPtgzz1uc7D7cbgDLQ.png"/></div></div></figure><p id="afa4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将讨论Vue生命周期挂钩。钩子是在预先定义的时间自动执行的函数。这是将我们的定制代码集成到已建立的程序中的一种非常有效的方式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi yf"><img src="../Images/eda40c88f7eefe2cf3a67d3a9de5ebdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*4GArB88r3mvI92GZMi2QXA.png"/></div></figure><p id="20c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue挂钩是在组件级别定义的。每个组件都有自己的挂钩。这个in hook函数指向拥有它的组件实例，这样我们就可以轻松地访问组件数据属性和方法。</p><p id="90ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前四个钩子标记了一个全功能组件实例创建过程中的四个关键点。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi yg"><img src="../Images/2b268ccfc55e896c58632c51859be792.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*PgO-exl2K33878dDuOz7Rg.png"/></div></figure><p id="fc3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此图显示了根组件的生命周期。对于子组件来说，情况基本上是一样的。</p><p id="a5a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个创建钩子在应用程序实例准备好之前和之后执行。一旦完全创建了应用程序实例，它就可以接受和存储外部数据。</p><p id="99cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个安装挂钩在组件安装之前和之后执行。只有安装的组件对用户可见。</p><p id="6e69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建的钩子是与后端API交换数据的最佳位置。此时，data选项中定义的属性都已经创建好了，可以接收数据了。</p><p id="f63f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们修改组件模板中显示的组件属性时，两个更新钩子将被触发。这里注意，两个更新钩子不是watchers。他们只监视组件模板中使用的组件属性。</p><p id="bba2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件属性包括数据属性、计算属性和属性。我们将在后面的课程中学习什么是道具。</p><p id="a4ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当从模板中删除一个组件时，将触发两个卸载挂钩。移除的组件可以是根组件或普通的子组件。</p><p id="728c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Vue 2中，这两个卸载钩子被称为beforeDestroy和Destroy。</p><p id="2631" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的实际项目中，我们通常只移除子组件。根组件总是被挂载，否则整个程序就消失了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yh"><img src="../Images/db70bcbd1097f1453731377594d3ef3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_GhHFzkBmV5sFd9_t8KIA.png"/></div></div></figure><p id="665b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试这八个挂钩。</p><p id="85ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个非常简单的Vue程序。根组件有两个数据属性:标题和钩子。它们都显示在组件模板中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xm"><img src="../Images/9d0eb28c80e7bd25d6ca9c7e28b38d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABgwKOxYxhERPfevOsAQzA.png"/></div></div></figure><p id="2b91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们添加beforeCreate钩子。我们输出钩子名称并检查它的THIS。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yi"><img src="../Images/c4f575c61a7dde83c8b711bf9d170cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IOLe4AAreFRh0F01T1BIA.png"/></div></div></figure><p id="db5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">beforeCreate挂钩在应用程序实例准备就绪之前被触发。控制台日志语句以某种方式向我们返回完全创建和挂载的组件实例对象。</p><p id="1c79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个误导性的巧合。这是由我们访问引用类型值的方式造成的。</p><p id="ea5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对象(包括代理对象)是引用类型的值。我们通过它们的内存地址来访问它们。相同的内存地址在不同的时间会返回不同的结果。</p><p id="db24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这在生命周期挂钩中存储组件实例对象的内存地址。</p><p id="cf18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们打开代理对象时，组件实例已经被创建和挂载了。这就是我们得到完整创建的组件实例对象的原因。</p><p id="221f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在beforeCreate钩子的执行过程中，组件实例对象远远没有准备好。如果我们试图通过这个输出一个特定的数据属性，我们会得到未定义的。例如，我们在beforeCreate钩子中输出这个点标题。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yi"><img src="../Images/aa10e7c3d9a37a9b6c7426aa18488856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbipuKhfGypRuPglXm8xaA.png"/></div></div></figure><p id="897b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在完全创建的组件实例对象中，美元符号数据属性指向存储数据属性的代理对象。</p><p id="7583" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果在beforeCreate钩子中输出美元符号数据对象，我们将得到一个空对象。这个对象还是一个普通的对象。还没有变成代理。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yj"><img src="../Images/0efd32507cc2bdc66f6666c3ffcd1687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiJoDNBepeegmDLga1-JNA.png"/></div></div></figure><p id="02bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加创建的钩子。</p><p id="0589" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先输出钩子名称。</p><p id="d972" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们输出这个，我们将遇到同样的问题:我们将得到一个完全创建和挂载的组件实例对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yk"><img src="../Images/26da8e196c8a1ee03283c88795e8c513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7tEJ86pTKyQBijeXbwxcw.png"/></div></div></figure><p id="1787" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建的钩子的执行过程中，APP实例已经创建，但是还没有挂载。组件离完全就绪只有一步之遥。</p><p id="8e6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们输出美元符号数据对象。</p><p id="db04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到了一个存储数据属性的代理对象。这些属性可以存储外部数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vr"><img src="../Images/ee85dbbe2e255d84f917d8fda0cf4380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7BVb5FI2P8oK2Ydsdli9w.png"/></div></div></figure><p id="e44b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该组件尚未安装。如果我们检查美元符号EL属性，我们将得到null。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yl"><img src="../Images/eb4955d93879e18b626d8d0e4baa97b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzRFbTNJxZ5I2DAvgq4GHQ.png"/></div></div></figure><p id="5937" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加beforeMount钩子。</p><p id="c42b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们已经知道直接输出这个的问题。在这里，我们只检查美元符号EL属性。</p><p id="520e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="1263" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到美元符号el返回我们null。该组件尚未安装，尚未呈现任何页面元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ym"><img src="../Images/f31b6c4c9637bd40b9bef7819e918839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vm-7R3WC-pjGF418w05Kpw.png"/></div></div></figure><p id="39a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们尝试安装挂钩。</p><p id="ffab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然检查美元符号EL属性。</p><p id="cd9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，美元符号EL属性返回程序根DIV的DOM对象。</p><p id="75e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件已经安装好了，它的模板已经呈现到实际的DOM元素中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yn"><img src="../Images/263869333ac8b6a12c94e25f9e996b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-TcjTXhS2j1H0uKnCg4Dw.png"/></div></div></figure><p id="bcd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签有一个ref属性，我们可以通过它的ref值访问它的DOM对象。</p><p id="1d74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在挂载的钩子中输出$refs属性。</p><p id="6eba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到一个代理对象。h1标签的DOM对象存储在其中。从现在开始，我们可以访问由组件呈现的页面元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yo"><img src="../Images/87765f3c01c4f8c887cfc1e461a26491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ca5U2eP9XupvuvanDbvdNg.png"/></div></div></figure><p id="1f45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们移动到一个新文件。我们将在这里尝试两个卸载挂钩。</p><p id="56d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从beforeUnmount钩子开始。</p><p id="879f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先输出钩子名称。然后我们检查三个关键属性:$data、$el和$refs。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yp"><img src="../Images/a9178723a98077077d80a88c5060d69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0me6jzUw9I6dHMcRgl6Og.png"/></div></div></figure><p id="5da7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们调用app.unmount()方法来卸载根组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uv"><img src="../Images/162d90233bbe5351a98ad1ee9766b91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5Whqp5TD0P1nhxawRTWRQ.png"/></div></div></figure><p id="11b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当beforeUnmount挂钩被触发时，组件仍然是挂载的，并且完全正常工作。</p><p id="684d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号数据属性仍然完好无损。所有数据属性都可用。</p><p id="0bfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号EL属性返回项目根DIV的DOM对象。在beforeUnmount钩子的执行过程中，这个DOM对象仍然显示。</p><p id="9bea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号引用属性返回给我们一个代理对象。</p><p id="e9bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性名是H1，属性值是H1标签的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yq"><img src="../Images/9b704c1ad76dd22cdf80f7c0b48b48d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcSEtOgbbSQNYMEu_L1h4g.png"/></div></div></figure><p id="4380" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们打开代理对象。</p><p id="86fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1房产的价值不知何故变成了零。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yr"><img src="../Images/ca71c0f6571a465700633c03b54c59fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kckF8G04__V_mAHwybXh4g.png"/></div></div></figure><p id="09b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这与我们在beforeCreate挂钩中遇到的巧合是一样的。</p><p id="66c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们打开代理对象时，组件已经被卸载了。它渲染的所有页面元素都不见了。自然，H1属性无法找到被移除的H1标签的DOM对象。这就是它返回NULL的原因。</p><p id="55fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在执行beforeUnmount挂钩的过程中，呈现的元素仍然显示。让我们证明这一点。</p><p id="8ca3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从美元符号引用对象中输出H1属性。</p><p id="8990" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了使我们的实验更有说服力，我为H1标签设置了一个ID，我们可以使用本机文档dot getElementById方法来获取H1标签的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ys"><img src="../Images/64a89573279a14cc56f58bcd92188a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yY1ZfeCQARStiZY6OpcGzA.png"/></div></div></figure><p id="2d12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再试一次这个程序。</p><p id="9514" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到H1标签的DOM对象已经被成功地获取了。我们可以通过它的ref属性或ID来访问H1标签。这证明了在beforeUnmount钩子执行期间，所有呈现的元素仍然在显示。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yt"><img src="../Images/35a14053076fe2b1b2787e78c247facc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdKqp1RRpkzSHApomKon2g.png"/></div></div></figure><p id="046d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们试试卸载的钩子。我们复制了一个beforeUnmount挂钩，并将其重命名为unmounted。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yu"><img src="../Images/9ebcde79ac77f15b2f4d5fc6bc7aa7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7NruxZaGgRSFMdQZuiYSQ.png"/></div></div></figure><p id="de5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="86de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们调用unmount方法来删除组件。</p><p id="e975" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号数据属性仍然完好无损。数据属性仍然可用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ua"><img src="../Images/5eb0f770add3198bf2e40354a3110b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rI6PX2kC1XsdnXFieIcAkw.png"/></div></div></figure><p id="39ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号EL属性返回根DIV的DOM对象。此DOM对象仍然存在，但已从浏览器窗口中删除。它不再展出了。您可以将此视为内存泄漏。我们不再需要这个DOM对象，但是它仍然存在于内存中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vu"><img src="../Images/fc3440dfe9fbe745660d526d04b49395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQqOH5YjPWDzwrr8J2lv1A.png"/></div></div></figure><p id="20e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号refs对象仍具有H1属性，但其值为null。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yv"><img src="../Images/f63d8529deff0a8d66190316289d096d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AE5tyEcxNH6dMEnEr0T5jQ.png"/></div></div></figure><p id="e9b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在beforeUnmount钩子中，H1属性的值是h1标签h1 。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yw"><img src="../Images/3b2b8d586c546ea6a8bc0f0c5494d576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5xXEiGqN6gTx35S-QcdWA.png"/></div></div></figure><p id="bc54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在卸载钩子的执行过程中，由卸载组件呈现的所有页面元素都从浏览器窗口中移除。ref属性和元素ID都返回null。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yx"><img src="../Images/24c9e41d69aaba6252a2db37dab5aa70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCQQflQ3qKirH1kmesrGCQ.png"/></div></div></figure><p id="8b04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能想知道为什么美元符号EL属性的值没有变成NULL。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yv"><img src="../Images/ef9b7c04ffc58d7b644b4376b8a0a226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iI08zEIiA1IuK4td_4E95w.png"/></div></div></figure><p id="243f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">调用app.unmount()方法不会删除根组件的实例对象。</p><p id="8bb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们输出VM变量，我们仍然可以获得根组件的实例对象。这件物品大部分完好无损。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi re"><img src="../Images/db65d1020049f883c13376ae6290fc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxgRtpRyFQzdRIPuGsrFFQ.png"/></div></div></figure><p id="c2f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的$el属性仍然存储根DIV的DOM对象。这就是为什么卸载钩子的$el属性仍然可以输出根DIV的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rj"><img src="../Images/361cd52f892cbac9496f977554bdd3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYA1t_taSIIt9oPjJhnFAQ.png"/></div></div></figure><p id="4898" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开美元符号refs属性，你会发现一个不同的结果。</p><p id="75f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有DOM对象。H1属性的值为空。</p><p id="ed48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ref属性是Vue用来访问浏览器窗口中显示的元素的属性。H1标签已被删除，因此H1属性的值已变为NULL。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qc"><img src="../Images/70af59427a95493b6a268a1af31cc64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWNxhHSrrGqMNhUc35o6PA.png"/></div></div></figure><p id="aa96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结论是，在执行未计数钩子的过程中，组件呈现的所有DOM元素都已从浏览器窗口中移除。应用程序实例仍然完好无损。数据属性仍然可用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yy"><img src="../Images/b121948a7c599ec12c1694e94b1da9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afSmjCXOgQPM4_inBNBcAg.png"/></div></div></figure><p id="2c0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将尝试四个渲染相关的钩子。我们将从两个更新挂钩开始。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xc"><img src="../Images/9b72b47bb2dd31ef70df0e0df4cc2814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rWi69-nwfD-PduhSgb23w.png"/></div></div></figure><p id="0e28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加beforeUpdate挂钩，并在控制台日志中记录其名称。</p><p id="12be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们以同样的方式创建更新的钩子</p><p id="7fa2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根组件有两个数据属性，它们都显示在组件模板中。修改其中任何一个都会触发两个更新挂钩。通过DOM对象进行的更改不会触发两个更新挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yz"><img src="../Images/56b0553a985bd2d881825c4c3fbf78f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kTFS-2_29OlOnJCfMftTQ.png"/></div></div></figure><p id="b1c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加一个新的数据属性:City。我们做<strong class="kd iu">而不是</strong>在模板中显示它。</p><p id="ccac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们给city属性分配一个新值，看看会发生什么。</p><p id="51e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">值分配已成功。这两个更新挂钩不会被触发，因为组件模板中没有使用city属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wf"><img src="../Images/b4f9ab8e6211ab3ecdb50db0469b74a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2_DZbdAtwZLiYEEnjJvIQ.png"/></div></div></figure><p id="b5c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在H2标签中，我们绑定了标题属性，并使用城市属性设置其值。</p><p id="bdaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，更改city属性的值可以触发两个更新挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi za"><img src="../Images/698e74cebee78b8572a3c1973ad9bd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjiXaZeP-FJhyJrMaewuRg.png"/></div></div></figure><p id="9935" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不要让钩名误导你。更新意味着更新视图，而不是更新数据属性。</p><p id="f7d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">beforeUpdate挂钩在赋值结束后触发。在赋值之前不可能触发beforeUpdate钩子，因为Vue无法预测你的操作。如果您需要监视数据属性的值变化，请使用观察器。稍后我们将了解更多关于观察者的信息。</p><p id="1021" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们用两个钩子输出H1标签的DOM对象。我们使用H1标签的ref属性来选择它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi zb"><img src="../Images/be8c37a580af2ae3c8203ac97ce0bbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*ols-q-kfF8elVPMSBUYYpQ.png"/></div></figure><p id="9a7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置消息值来触发两个更新挂钩。</p><p id="3796" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个更新挂钩的结果是相同的。它们都具有更新的消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zc"><img src="../Images/3d2f4e4509bdbc2d3845047cb78ab10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTnKL3uQp5lg-a0Yi3_e8A.png"/></div></div></figure><p id="4cc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这不是真实的情况，原因和以前一样。我们来证明一下。</p><p id="4305" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们输出两个DOM对象的innerText属性。</p><p id="30a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="f9cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，两个钩子的输出是不同的。beforeUpdate钩子返回旧的内部文本。更新后的钩子返回给我们新的文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zd"><img src="../Images/216e63921579a1d2beec724f7c08696c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuSltNp7SNf5ohT5-zI9Uw.png"/></div></div></figure><p id="35b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在更新后的钩子中，我们添加了alert方法。我们在其中输出标题属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qc"><img src="../Images/ca4b072b1b4fda7aaf63c904dbf0cc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3ddjew4n9A6mlXcweNu1A.png"/></div></div></figure><p id="2b8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们重置title属性的值来触发两个更新挂钩。</p><p id="64ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">警报窗口将暂停程序执行，直到我们单击OK按钮。这使我们有机会检查beforeUpdate挂钩中的控制台日志语句是如何执行的。</p><p id="a77f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仔细查看控制台表上的输出。</p><p id="eda9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果很有意思。</p><p id="15b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">beforeUpdate挂钩有四个控制台日志语句。控制台上有四个输出。第三个输出为空。</p><p id="105d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三个输出来自第24行。我们在第24行输出H1标签的DOM对象。</p><p id="d9e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">预警窗口设置在更新后的钩子中。这意味着在更新钩子被触发之前，来自beforeUpdate钩子的控制台日志语句不会输出H1标记的DOM对象。这就是DOM对象和它的innerText属性不匹配的原因。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/e08816a7ad04d23f5c34e1bdcb13aad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIuqwoT88Q0mwOFOaW8i_A.png"/></div></div></figure><p id="f988" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们单击OK按钮恢复程序执行。</p><p id="ce6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，单击OK按钮后，第24行留下的空白被H1标签的DOM对象填充。</p><p id="8007" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只要记住beforeUpdate钩子是在Vue开始重新渲染模板之前触发的。它无权访问<strong class="kd iu">更新的</strong> DOM对象。</p><p id="bdde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开Vue API，你会发现一个叫nextTick的方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tk"><img src="../Images/51355becafe3bf4477eea0a63348c22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*xJf8u1lMg0Ho1NObizfZmg.png"/></div></figure><p id="d6dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开根组件实例，您会发现一个类似命名的方法:$nextTick。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ze"><img src="../Images/3248b1f82d85c838c7657ff20048dd9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*DJQhbaRrGryXpZUCg5ybzQ.png"/></div></figure><p id="480f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个方法在下一个DOM更新周期后执行，它们可以返回给我们更新后的DOM属性值。</p><p id="cf66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将它放在beforeUpdate方法中，并向它传递一个回调。在回调中，我们输出H1标签的innerText属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pz"><img src="../Images/9590cb1569aeabda64436220b7092625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDR5vBB6SyXR2ImwFgm16Q.png"/></div></div></figure><p id="aace" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置title属性来触发两个更新挂钩。</p><p id="dda5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">nextTick方法的回调在最后执行，在更新的钩子后面。因此，它返回给我们更新的内部文本值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zf"><img src="../Images/b5ea90e124245370d6eef09ab128e261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWGLEYB46IUfUaOZ-VQaIg.png"/></div></div></figure><p id="8867" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们打开警报方法。</p><p id="5791" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，如果我们不点击OK按钮，传递给nextTick方法的回调就不会执行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi px"><img src="../Images/95ca4d14f1cae6902dae4de8b089cd00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*31vmsuJK5_rhELJnTi34qQ.png"/></div></div></figure><p id="59d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们之前创建的程序。</p><p id="d442" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一个输入标签。它的v模型指令连接到消息属性。在输入框中键入的字符将被保存到消息属性中。</p><p id="67f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入框也监视输入事件。每次我们输入一个字符，check方法就会被触发。</p><p id="4740" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">check方法首先检查消息属性的长度。如果长度超过要求，它将被subString方法截断。截断的值将被赋回消息属性。这就是我们如何控制用户可以提交的最大字符数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zg"><img src="../Images/cb9ddf9a1b1047550d558c53bd9491a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5x2A0TRzPRH5-M5eSFIs9g.png"/></div></div></figure><p id="522f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">check方法仅由输入事件触发。如果我们通过组件实例重置消息属性，检查方法将不会响应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zh"><img src="../Images/8b19c15a2611a3dccc1340850533a4ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrmnU5lP9WzNfkjjZ4PbTQ.png"/></div></div></figure><p id="20b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了能够从各个角度观察消息属性，我们需要观察器。Vue为我们提供了三种设置观察器的方法。</p><p id="fdd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开组件实例，您会发现一个名为$watch的方法。这是我们在组件实例中使用的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zi"><img src="../Images/c691d83502aaf91d856094c746d56a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgXfHHgE4DCvXL_J4Gc1Zg.png"/></div></div></figure><p id="7158" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开Vue API并滚动到底部，您会发现一个名为watch的方法。该方法不依赖于工作组件实例。我们主要在设置功能中使用。我们将在以后的课程中学习。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/d449b0db8ad0776479a9aa9f125ad410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhSVlrvPLId48olgMSB1uw.png"/></div></div></figure><p id="cbf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三个选项是观察选项。我们在选项对象中设置它，就像数据选项或方法选项一样。其行为与美元符号监视方法相同。</p><p id="aefe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从手表选项开始，因为它使用起来更方便。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zj"><img src="../Images/8cd1889f07079a27a3702223e031d6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6W9y-Z2mmsj0jj-IsJbs-w.png"/></div></div></figure><p id="761a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望观察消息属性。我们创建了一个同名的函数。</p><p id="4871" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数名必须与被监视的属性完全相同。除了数据属性，您还可以观察计算属性和属性。我们后面会学到什么是道具。</p><p id="987a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watcher函数接收两个参数。第一个是表源的新价值。第二个是前一个值。</p><p id="b01a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们控制台记录这两个参数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zk"><img src="../Images/ba52e075ea3b0e9c371ef0d96388dbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNfzl6Ihrablmpxjh4YUnA.png"/></div></div></figure><p id="a779" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="ccd0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，每当我们输入一个新的字符，消息监视器功能触发。它输出最新的消息值和先前的消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zl"><img src="../Images/3d5c57eae3014b112af6ab7451d9348a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UM8hzvwNuIjZyhXR6m_qIw.png"/></div></div></figure><p id="ff8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察者的反应就像v on指令一样及时。这使得v on指令过时了。我们可以将它从输入标签中移除。</p><p id="2cca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也不需要check方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zm"><img src="../Images/74c26d0227ea540f70be5d4809b3db56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-x4Uc9E-zcyzE17k9p5CFA.png"/></div></div></figure><p id="83d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在消息观察器函数中检查和处理消息值。</p><p id="e8a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题是如何从watcher函数内部访问message属性？如果你是Vue的设计师，你会怎么做？</p><p id="a435" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在消息观察器中输出它，看看它指向哪里。</p><p id="4f74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到一个代理对象。</p><p id="dd84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该对象是根组件的实例对象。这在观察器函数中指向拥有观察器函数的组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zn"><img src="../Images/858e9c63481c7224f51137de76790aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2SKpos1n0lve7cvOfMwwQ.png"/></div></div></figure><p id="3759" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加一个IF语句。</p><p id="520a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将新值的长度与max属性进行比较。max属性是通过这个访问的。我们截断新值，并将截断的值分配给消息属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zo"><img src="../Images/18b34b38291db751b389b359974d8ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPRI4zkPzI8-QrVHM-1zQA.png"/></div></div></figure><p id="9fd1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="eb56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当我们输入一个新字符，消息监视器就会被触发。</p><p id="b7e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">达到限制后，多余的字符将被删除。因此，输入框最多接受十个字符。第11个字符会一直被删除。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zi"><img src="../Images/92e7fa4ac7f4f0f1c46811e07666f954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCMyfQ-FSwknBoJARoRVQg.png"/></div></div></figure><p id="8a9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们直接给消息属性赋值，多余的字符也会被删除。</p><p id="7fa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">任何改变消息值的操作都会触发消息监视器。换句话说，消息属性从各个角度受到保护。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xz"><img src="../Images/241b7e773eb4f761ca302b18339afa4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rbyTx-Y5DbUDvNzt_ytzA.png"/></div></div></figure><p id="7cf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以为同一个目标设置多种监视功能。我们将在后面的课程中向您展示细节。</p><p id="1212" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来看看watchers的现实应用。</p><p id="b867" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个模拟天气应用程序。我们将在后面的课程中创建一个可用的天气应用程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zp"><img src="../Images/a23a399ea576dc1be015cf23bf8f7da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0m1VAZMuGvGZXVB6p17F3A.png"/></div></div></figure><p id="915e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有两个数据属性:city和weatherInfo。</p><p id="6d9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还有一个名为query的方法。它有一个论点:城市。它使用传递给它的城市名查询后端API。然后，它将检索到的天气信息分配给weather info属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zq"><img src="../Images/097efde604417c18f3e8d327cb2399bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6unfPzoQuLobbY5O_NxRw.png"/></div></div></figure><p id="66cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望用户从预定义的城市列表中进行选择。每当他们选择一个新的城市，该城市的天气信息应自动检索。</p><p id="b8cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了帮助用户选择城市，我们添加了一个输入标签，并将其类型设置为radio。</p><p id="5a9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加value属性并将其设置为London。然后，我们添加v model指令，并将其值设置为city属性。</p><p id="920b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="6d56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一个单选按钮，它代表伦敦。单击它会将城市属性设置为伦敦。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zr"><img src="../Images/bb346b11ba2e1069232b15bf04489ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bdeNt6xVuF7QzWfc6hPww.png"/></div></div></figure><p id="453c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们再复制两个单选按钮。我们将城市名称分别改为达勒姆和悉尼。</p><p id="9d68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们有三个单选按钮。他们都与城市财产有关。通过单击这三个按钮，我们可以更改city属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zs"><img src="../Images/3f995b7014a2111d519c5087fd5dc00c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*As2SpvGJtoIi2yHIqgstqA.png"/></div></div></figure><p id="6be9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更改城市属性只是第一步，我们还需要触发查询方法，使用新的城市名称进行新的查询。</p><p id="990c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道如何用查询方法连接这三个单选按钮吗？</p><p id="b5cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加v on指令并监控输入事件。我们触发查询方法，并将当前单选按钮代表的城市名传递给它。</p><p id="6bb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们将v on指令复制到另外两个输入标签中。</p><p id="30ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">传递给查询方法的城市名称需要手动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zt"><img src="../Images/dad5f0dae9b38b59abe6d2f6a70a8c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcnrWw3ZL4sF1pX5L-WamQ.png"/></div></div></figure><p id="6eda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个程序可以很好地工作，但是它的设计并不优雅。每个输入标签需要两个Vue指令:v model和v on。</p><p id="5c9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个输入标签都要求我们用不同的城市名设置一个查询方法。这使得以后的程序维护相当不方便。例如，如果需要用另一种方法替换查询方法，就需要修改所有的输入标签。</p><p id="8aaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你知道如何改进这个项目吗？</p><p id="42e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有当city属性的值改变时，我们才会触发查询方法。为什么我们不为城市财产设立一个监视者？我们可以从watcher函数内部触发查询方法，并将新的城市名称传递给它。</p><p id="b31a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入标签不再需要v on指令来触发查询方法。他们唯一的工作就是修改城市财产的价值。</p><p id="04c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了监视选项，并为city属性设置了一个监视器。</p><p id="551e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于演示目的，我们在控制台日志中记录了以前的和新的城市名称。</p><p id="d75c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过这个调用查询方法，并将新的城市名传递给它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ul"><img src="../Images/ed9c641854db421a082f5c7c97a862fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVOxJgKZK2KiDJn1NDcysg.png"/></div></div></figure><p id="c088" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个程序和以前一样工作。每当我们切换到一个新的城市时，查询方法就会被触发，并使用新的城市名称进行新的查询。</p><p id="2f18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相比之下，代码质量要高得多。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zu"><img src="../Images/142c879d8396c3e0b9bb78ed7a7e676a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFw1ClT_NRlOcPVZ-2whNA.png"/></div></div></figure><p id="7255" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有输入标签只有一个Vue指令:v模型指令。所有输入标签的指令值都是相同的。</p><p id="d3d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要添加新的输入标记或修改现有的输入标记，我们只需要更改value属性，其他都是一样的。</p><p id="cba4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最重要的是，这些输入标签和查询方法之间没有硬连接。</p><p id="b78e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入标记与查询方法完全分离，它们只负责修改城市属性的值。</p><p id="bb3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市财产由城市守望者无线监控。每当它的值发生变化时，城市观察器就会注意到并触发带有新城市名称的查询方法。</p><p id="f0db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们需要用另一种方法替换查询方法，我们只需要在city watcher中进行一次修改。在前面的程序中，我们必须更新所有输入标签中的v on指令。</p><p id="dece" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们给city属性一个初始值。我们把它设定在伦敦。</p><p id="faa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="ddd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市名称已设置为伦敦，但天气描述保持不变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zv"><img src="../Images/faff0a039e86cfaf82c8f434e8512b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlayBNSer6huwy1eUl01Ug.png"/></div></div></figure><p id="6365" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们刷新页面时，我们希望查询方法被自动触发，并使用默认的城市名进行查询。知道怎么做吗？</p><p id="97b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最简单的解决方案是在创建的钩子中手动调用查询方法。</p><p id="2b48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，我们可以简单地要求城市观察者在程序初始加载时做出响应。</p><p id="233d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用对象语法设置城市观察器。</p><p id="d1bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在对象内部，我们添加了处理函数。在它后面，我们添加了<em class="np"> immediate </em>属性，并将其值设置为true。其默认值为false。</p><p id="2ada" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> Immediate </em>表示当我们第一次加载页面时，观察器立即响应。</p><p id="8d58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">处理函数的语法和以前一样。它有两个参数:当前值和前一个值。当被监视的属性的值改变时，它将被触发。</p><p id="0056" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">处理函数应该使用完整的函数来定义，这样Vue就可以将其THIS重定向到组件实例。</p><p id="5292" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过这个方法访问查询方法，并将新的城市名传递给它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wn"><img src="../Images/04fb2a75f8ee2266a39f622095503c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQOnLK28AP6rp2ppWkfejg.png"/></div></div></figure><p id="dcca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="324b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，刷新页面后，城市观察器被触发。</p><p id="15bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以前的值是未定义的，新值是伦敦，这是我们为city属性设置的默认值。查询方法已被触发，并使用伦敦进行了查询。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zw"><img src="../Images/cf260395fae0e4b113e896eb2dd38e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNSmNcDIMLj7sNynKC7hhw.png"/></div></div></figure><p id="d80e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的实际项目中，我们经常将<em class="np"> immediate </em>属性设置为true，以使程序能够自动查询后端API来检索初始数据。这样，我们就不必在创建的钩子中手动调用查询方法。</p><p id="1adf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果需要设置几个观察器函数，将对象放在一个数组中。</p><p id="c2e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数时候，我们只观察像数字或字符串这样的原始值。但是您还应该知道如何观察引用类型的值，比如数组或对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/07c95a61172ade3c4ef84659b1dc9b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4YUaPktaLWUIPFIb8z_tA.png"/></div></div></figure><p id="607c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从数组开始。</p><p id="e923" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们观察整个数组。我们用数组来命名观察器。我们使用对象语法设置观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zi"><img src="../Images/7f7c0567fadd4574c3fbc2975598dd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMvSRVJXIg2hiyoArhMwzg.png"/></div></div></figure><p id="5ed4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了支持反应性，Vue将引用类型的值转换成代理对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zx"><img src="../Images/6e30044a83b0bc769a2657b3d2d47547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IyjaWtnkHTDvZjJEY2cPUw.png"/></div></div></figure><p id="6a3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着列表监视器实际监视的是数组代理对象的内存地址。</p><p id="2fc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">操作数组元素不会改变数组代理对象的内存地址。因此，列表观察者不会响应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zy"><img src="../Images/aaedb2a2fed0085144d5283faef7b87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*noK2IL2DBtQUj5CrPQJlRA.png"/></div></div></figure><p id="3edc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了触发列表监视器，我们需要给列表属性分配一个新的数组体。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/5e60bd7bc07a2d17fe4c9940140b797c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwXwiY0ufod73AIcz9H6KA.png"/></div></div></figure><p id="6688" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有两个数组是相同的，这意味着它们不会共享相同的内存地址。如果我们给列表属性分配一个相同的数组，列表监视器仍然会响应，因为内存地址已经改变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/af84d31bf33095eb3185aab94184b4bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYbTrbgIAlVOLv3o1GPvHA.png"/></div></div></figure><p id="b10e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，这不是我们想要的结果。</p><p id="4630" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了监视元素的变化，我们需要将<em class="np"> deep </em>属性设置为true。其默认值为false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qt"><img src="../Images/352991c50398cbedff7b2448cdfc8c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMHnH-fUp2Nclnc1aaLtdA.png"/></div></div></figure><p id="f13b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，修改数组元素可以触发列表监视器。</p><p id="d76d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为只有一个数组，所以处理函数的两个参数都指向更新后的数组。我们会得到同样的结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zz"><img src="../Images/691659e80f80b3969e0834c23d47acb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDVrK90GmIkXKF0umJewOg.png"/></div></div></figure><p id="3504" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的实际项目中，我们可能需要监控给定数组的元素总数。我们可以为数组长度创建一个观察器。</p><p id="2c57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用引号将列表点长度括起来，并将其用作观察器名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xo"><img src="../Images/da711ceb86d9fac2fcec296653a196ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYlb72Vcj3oOxaZ0depJjw.png"/></div></div></figure><p id="412e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="bab0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们去掉一个元素。</p><p id="806d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">长度监视器已被触发。它显示了以前的元素总数和当前的元素总数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zy"><img src="../Images/5b97a179c233d66ccab4fadfaf9cef3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIbcU2FeS70mIyNBQPwx6w.png"/></div></div></figure><p id="fd07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们尝试观察一个选定的元素。我们选第一个。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aba"><img src="../Images/20779e957b7b2e8c4fa3cedcf4b49be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4b3Unomegqc9DWmjECIEBw.png"/></div></div></figure><p id="371c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置第一个元素值。</p><p id="7fbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个元素的观察者没有反应。触发的观察器是数组观察器，而不是第一个元素的观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aba"><img src="../Images/20779e957b7b2e8c4fa3cedcf4b49be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4b3Unomegqc9DWmjECIEBw.png"/></div></div></figure><p id="9b01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加deep属性并将其设置为true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/662ce6db05586a2d2e2d81b7d9d73559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_7VFQOFQ3PNeLgqfSId0A.png"/></div></div></figure><p id="6c25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再试一次这个程序。</p><p id="a1d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个元素的观察者仍然没有反应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ud"><img src="../Images/f129729e9200705bf9e3df91ea468e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWMRqV9m9mQOlyX6ONBjnA.png"/></div></div></figure><p id="4374" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结论是在观察选项中，避免观察特定的数组元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abb"><img src="../Images/bffdb1af3292883299ad47df4918ac43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWzxJxk4SG2uiS82EJ34SQ.png"/></div></div></figure><p id="24f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，可以观察对象属性。例如，我们观察汽车对象的品牌属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tq"><img src="../Images/03a53ca31888987720e600020d6ec314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqJXB4NucF2T8SHGGj4_zQ.png"/></div></div></figure><p id="648f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重新设定了品牌价值。</p><p id="ed5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到品牌观察器已被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abc"><img src="../Images/58a38f13d5d3160cc4a04b01fc32fc95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjzsKM25xP4d8bpR_a_NEA.png"/></div></div></figure><p id="cc44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将讨论观察器函数的刷新时间。我们有三个选项:前置、后置和同步。Pre是默认值，也是推荐值。</p><p id="5fe7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">flush属性决定是在页面重新呈现之前还是之后执行观察器。如果将其设置为sync，则在页面重新呈现的同时执行观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abd"><img src="../Images/f914c06051845f2fe156dc331516be74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gesy-wjr8hR8VNF_e_Wyhg.png"/></div></div></figure><p id="e6a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个消息属性。它显示在H2标签中。H2标签有一个ref属性，帮助我们检索它的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abe"><img src="../Images/c5b6c7466e5d748907c322ac749fbfad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQXlMnxOO2xvDUPYJ1D4DA.png"/></div></div></figure><p id="a119" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在设置watch选项之前，我们首先添加四个生命周期挂钩。它们是在更新之前创建、装载和更新的。我们将比较消息观察器和这四个钩子的执行时间。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aba"><img src="../Images/fcbeb22d31e8eb022220cb36d2df2df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzEZ8CGwZvP9zMmifLaKWA.png"/></div></div></figure><p id="0cf4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加watch选项来为消息属性设置一个观察器。</p><p id="817f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用对象语法。在处理函数中，我们输出前一个值和当前值。我们将immediate属性设置为true。</p><p id="732d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认刷新值是pre。观察器在页面重新呈现之前触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ov"><img src="../Images/15888b878b7f5a2ab36fa9037c232a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50SsuYsWAXThV9soVJcpCg.png"/></div></div></figure><p id="f2be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="bd15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到消息监视器甚至在创建钩子之前就被触发了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rk"><img src="../Images/263709dc82e4f1b6ba56976ecf177e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koNUOyV01hYQLvqSBmX8Nw.png"/></div></div></figure><p id="3e97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们重置消息值。</p><p id="d10d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息观察器在beforeUpdate挂钩之前触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/d5322bd8d42859304eccf1720b5fe10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VxmbBDfOw6jPtxZKcMtLdQ.png"/></div></div></figure><p id="9548" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们回到处理函数，输出H2标签的内部文本。因为消息观察器在页面重新呈现之前触发，所以我们应该获得前一个消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abf"><img src="../Images/b50bc2729ae707495b78e38348519b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9BZhh7_0tJtmqxhFw7fVQ.png"/></div></div></figure><p id="0ec7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到一个警告和一个错误消息。</p><p id="22f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们已经将immediate属性设置为true，所以当我们刷新页面时，消息观察器会在组件挂载之前触发。因此，H2标签还没有被创建。因此我们无法访问它的innerText属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/5b8f47708699c7272bed9bd13066c250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPP6NqXz223ra6cg2OWHaA.png"/></div></div></figure><p id="0a8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在输出innerText属性之前，我们需要检查H2标签是否存在。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abg"><img src="../Images/1598e364204714cc546e94cf017f9d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2aJvhcKSxukV9RkzmrwDw.png"/></div></div></figure><p id="4f79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再试一次这个程序。</p><p id="6116" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到H2标签的内部文本是旧的消息值。这证明了消息观察器在页面重新呈现之前触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abh"><img src="../Images/2e2b4c15aa5e87dc95f7e1aa2106b5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WT5cMd7JxnqG_u3opJG4Q.png"/></div></div></figure><p id="68fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将前置转换为后置。</p><p id="3a42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再运行一次文件。</p><p id="114d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建钩子之前，观察器仍然被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abi"><img src="../Images/f23b7c5a4f790f4ac92a91ac6d3b3776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VRkk-QmOoDwPBfKW9Bd-g.png"/></div></div></figure><p id="095f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置了消息属性。</p><p id="fd60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到这次执行顺序改变了。</p><p id="e2e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息观察器在beforeCreate挂钩之后但仍在created挂钩之前被触发。</p><p id="6677" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H2标签的内部文本现在是更新的消息值。这证明消息观察器是在页面重新呈现后触发的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abj"><img src="../Images/200c0108ede3269d5ff458bd0850d53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCFSvyQKoV9w6sOsDLvxYA.png"/></div></div></figure><p id="f227" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试sync。不建议同步，因为它会消耗过多的资源。</p><p id="f03b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">初始监视仍然发生在创建钩子之前。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abk"><img src="../Images/276f4fd3007d8d9adfab2fd223e99ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oM-1smEpKeNjAbKzk3hYzg.png"/></div></div></figure><p id="9122" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置消息值。</p><p id="02de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到消息观察器在beforeCreate挂钩之前被触发。H2标记的内部文本仍然是旧的消息值。当页面重新呈现自身时，消息观察器触发，因此消息观察器不能访问更新的内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abl"><img src="../Images/41e236fe48c77bae9d51e8b599adb472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQz_EsmEzvzWRqOyVZqzyw.png"/></div></div></figure><p id="e642" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在现实项目中，最好的同花选项是pre，因为它允许观察者尽快做出反应。</p><p id="4dcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以将观察器视为一种特殊类型的挂钩。它监控目标值，并在目标值改变时触发。</p><p id="74aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以为同一个目标设置多个观察函数。我们把它们放在一个数组中，它们将按照数组中定义的顺序执行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi abm"><img src="../Images/dfc5c91f0a8ab801f158f7d6c9bb76e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*p9bz9FTrmlFKE8KADx4JSg.png"/></div></figure><p id="bab9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果使用函数语法，应该使用完整的函数来使Vue将其THIS重定向到组件实例。</p><p id="eaf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法和以前一样。watcher函数接收两个参数。第一个是新值，第二个是以前的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/3b8d8522006ffd054ee8cee36609582d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yudMmeGcAl3511wPvPEUDQ.png"/></div></div></figure><p id="4b59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们复制了一个监视函数。我们在新的观察器中控制台日志<em class="np">第二个消息观察器</em>。现在，我们已经将两个观察器函数绑定到消息属性。这两个函数将按照它们在消息数组中定义的顺序执行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/21870775430e5b36ee1c6e9682590dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Uu_iFeQez5WKgkmOM6zMQ.png"/></div></div></figure><p id="b408" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="772c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置消息值。</p><p id="245c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个观察器功能都被触发。它们的触发顺序与在消息数组中定义的顺序相同。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rl"><img src="../Images/a21ed380b2b3f4b16fbc86cf3b428abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFZB7yCrcPv50UK3t6zRpg.png"/></div></div></figure><p id="b627" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们试试对象语法。</p><p id="c1c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将两个对象添加到消息数组中。</p><p id="983d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法还是和以前一样。我们首先定义处理函数。在处理函数后面，我们设置了三个配置属性。我们将<em class="np">立即</em>设置为真，将<em class="np">刷新</em>为预。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tt"><img src="../Images/de413b90e7821b22fa9e4dc901f9d63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-kIAXDPEPuN95MicBOj5Q.png"/></div></div></figure><p id="f264" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将处理函数和两个配置属性复制到第二个对象中。</p><p id="d6ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们将<em class="np">立即</em>设置为假，并将<em class="np">刷新</em>到post。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abn"><img src="../Images/b1359d670ed3aac346e6dd63d598bb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHoWR3l4GJVUsC8wwjhcGQ.png"/></div></div></figure><p id="592b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经将两个观察器函数绑定到消息属性。这两种观察器功能具有不同的设置，因此具有不同的性能。</p><p id="3646" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="c79d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们第一次加载页面时，只有第一个处理函数被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abo"><img src="../Images/597021c7c1f05eac80070a0b10d8c743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wl1mzjgjaYo2ggvh5Asyhg.png"/></div></div></figure><p id="ee1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置消息值。</p><p id="e1eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，两个处理函数都被触发。</p><p id="e195" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个是在beforeUpdate挂钩之前触发的。第二个在两个更新挂钩之间触发。这是因为两个处理函数有不同的刷新设置。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abp"><img src="../Images/b200186bcca6b97ae2887fa4b7ec33c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcjgxP6f2awPrsovJVLjtA.png"/></div></div></figure><p id="941d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们切换两个处理函数的刷新设置。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abq"><img src="../Images/4b3a0c35a39a3222b80088bba262d0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JvUKyfEuLwTbfFB7uDI6SA.png"/></div></div></figure><p id="2462" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再运行一次文件。</p><p id="61c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置消息值。</p><p id="8906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，第二个处理程序首先被触发，因为它的刷新时间比第一个早。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tw"><img src="../Images/303c31369a0dcb373fcf0ef82e7327e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KXCKnhUryUCCCTm78J-Ftg.png"/></div></div></figure><p id="9be4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过watch选项监视数据变化很方便，我们只需要列出目标名称和属性名称。然后我们给它分配一个函数或者一个对象。</p><p id="32ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一个折衷，watch选项并没有为我们提供对观察器和观察源的足够控制。</p><p id="2fda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们无法控制观察器的开始和结束。</p><p id="5ca9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用目标名称作为属性名称意味着我们不能设置复杂的表达式来监视计算值。</p><p id="1448" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是Vue在每个组件实例对象中提供$watch方法的原因。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xw"><img src="../Images/b5731cba959d224ae3bcbc51d6195187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*RqEdL_w9Bs8jfgqAUEKQpg.png"/></div></figure><p id="0c28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">$watch方法的行为与watch选项相同，但给了我们更多的控制权。</p><p id="5fb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue API还提供了一个观察方法。这两种方法很相似。我们将在后面的课程中学习Vue手表方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vi"><img src="../Images/972c9027d64affd1e24ad82f66071986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XchMfHJtwpROgTOgObkDrw.png"/></div></div></figure><p id="69c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们删除了监视选项，并添加了创建的钩子。</p><p id="69c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建的钩子中，我们通过这个调用$watch方法。现在，当应用程序实例被创建时，一个观察器将自动启动。</p><p id="ec57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您将$watch方法放在一个普通的Vue方法中，那么观察器只会在我们调用该方法之后启动。因此，我们可以控制观察器的启动。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abr"><img src="../Images/d4a7165ff5e18dff79c690b5852bff3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3FSymf23skTFU3pJcqvSFw.png"/></div></div></figure><p id="0596" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">$watch方法有三个参数。第一个指定了观察源。手表来源是我们监控的值。</p><p id="8954" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们使用城市属性的名称来设置它。城市需要用引号括起来。我们使用属性名作为观察源。我们不将属性传递给$watch方法。</p><p id="450a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，城市财产的价值受到关注。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi abs"><img src="../Images/fe811c90fb92ff7be18e790afa797ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*XUmcAtGKqbTA7WTgiDLb6Q.png"/></div></figure><p id="fb59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个参数是处理函数。它接收观察源的新值和以前的值。顺便说一下，这里的函数应该使用arrow函数来定义，这样它就可以从创建的钩子中继承THIS。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abt"><img src="../Images/b00246ff6b6b78b9c471ec5dcbac92d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgS34Q55r6ClbcligijPfA.png"/></div></div></figure><p id="7a7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一个参数是一个配置对象。我们在这里设置了三个属性:immediate、deep和flush。</p><p id="66f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将immediate属性设置为true，并跳过其他两个属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abu"><img src="../Images/b5a54be27fc824349255fa4adedf3a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YblxKaGuen3RJpLAwZUu4g.png"/></div></div></figure><p id="5693" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="5625" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们已经将<em class="np"> immediate </em>属性设置为true，所以城市观察器在我们第一次加载页面时触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abv"><img src="../Images/a0dce69293440ce05e2f701227e5a494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXOyVj8Fyp4h4PUj0074jw.png"/></div></div></figure><p id="0b07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置了城市值。</p><p id="e62d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市守望者又被触发了。处理函数已经输出了以前和当前的城市名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yo"><img src="../Images/ae11e6f052d759a3de7040a2c13bd95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LepUjng3KUJDnJuxSNTbAA.png"/></div></div></figure><p id="61de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用多种美元符号监视方法来监视同一个目标。</p><p id="66ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们复制了美元符号手表功能。</p><p id="93d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然监视着城市财产。</p><p id="6e76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在handler函数中，我们输出了<em class="np">第二城市观察者</em>。</p><p id="a396" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们将<em class="np">的直接</em>属性改为false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pz"><img src="../Images/3b001b37ac053e9e300e219006d0046a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GUbZesZMZ5sjKbHZY22Vg.png"/></div></div></figure><p id="f657" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="f8b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有第一个$watch方法被触发。第二个没有响应，因为它的<em class="np">立即</em>属性被设置为false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abw"><img src="../Images/da4ea9724a5db2d51593c1140e4ee371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfL0rwLJGh2OI9Iyr3p1Zg.png"/></div></div></figure><p id="e97d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给城市财产赋予一个新的价值。</p><p id="6261" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，两个$watch方法都被触发了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abv"><img src="../Images/9292d713918a40341c407981e197e302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zFkTW-IAYo-6dvkmuXz2w.png"/></div></div></figure><p id="e865" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个新的数据属性。我们将其命名为<em class="np"> stop </em>，并将其值设置为null。</p><p id="711c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将第一个美元符号监视方法分配给<em class="np"> stop </em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tv"><img src="../Images/6998266fa920405e231dba66d614472c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNLzQiTp-BAmAHIF1j3sWg.png"/></div></div></figure><p id="8d94" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查一下<em class="np">停止</em>属性。</p><p id="ec88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它的值是一个停止函数。每个美元符号监视方法都返回一个专用的停止函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qy"><img src="../Images/d49062fa22fbfbfa70a1d4556056c839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EJk0dmme72_s-LWhyNNEQ.png"/></div></div></figure><p id="32b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们不运行停止功能，第一个观察器将继续工作。</p><p id="5254" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们调用了stop函数，第一个观察者就会停止。</p><p id="91e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们已经重置了城市名称，但是第一个观察者没有反应。已经被制止了。第二个守望者仍然照常工作。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/0efcf517c1804ca5d4c391de5f1a51de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZ7cpe4UB8J7iegzuUWkjA.png"/></div></div></figure><p id="f195" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个$watch方法在我们第一次加载页面时不会响应，但这并不意味着它会被搁置。当程序加载时，Vue仍然注册它。</p><p id="28d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们声明一个新的数据属性:stopTwo。</p><p id="60de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将第二个$watch方法分配给stopTwo属性。</p><p id="a077" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时此刻，第二个$watch方法还没有被触发。</p><p id="b15a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们检查stopTwo属性。</p><p id="248b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它的值是一个停止函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vu"><img src="../Images/67c75f171de16989cc2733fe57bb6ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GH9YNLvkD7Ps-ro50zl93A.png"/></div></div></figure><p id="27f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们援引它。</p><p id="2976" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们重置城市值。</p><p id="6255" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到只有第一个美元符号方法被触发。第二个美元符号观看方法已停止。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abx"><img src="../Images/e61b860f1edfbe3953def2b68b81402d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSnBnT2Uw5pAwwkLdx5Maw.png"/></div></div></figure><p id="1677" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们向您展示了如何使用美元符号观察方法来观察原始值。在这一课中，我们将学习如何观察引用类型值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aby"><img src="../Images/c43d217ea3efbf5acf3f0cfc8fb5c6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rAJncfn4_HqY1tZ1XPETqA.png"/></div></div></figure><p id="b0b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从数组开始。</p><p id="34bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然在创建的钩子内部设置$watch方法。</p><p id="3d98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用属性名<em class="np">列表</em>作为第一个参数值。不要忘记引用。</p><p id="ddb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在处理函数中，我们输出前一个值和当前值。</p><p id="d223" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在config对象中，我们将immediate属性设置为true，将deep属性设置为false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abz"><img src="../Images/b9f3de687f9aa4fc1b403cd22ad0efe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wf7ebLmbPxkhnufbDPAeIQ.png"/></div></div></figure><p id="6388" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="f53b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了支持反应性，Vue将列表数组转换成了一个代理对象。但是这个代理对象的行为仍然像一个数组。它适用于所有与数组相关的方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aca"><img src="../Images/d314fab6d0a88d6e591dff54210a49ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORs38tQN5o7MXUx4YNm1Mg.png"/></div></div></figure><p id="0c4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从列表数组中移除一个元素。</p><p id="967d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">列表监视器没有响应。</p><p id="4cd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重置第一个元素值。</p><p id="9080" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察者仍然没有反应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi acb"><img src="../Images/d0ce48205bc7673ef12fb6d57757c5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*LU0jfgBFZEYG3N9hUB33lw.png"/></div></figure><p id="33d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">列表监视器只监视列表数组的代理对象的内存地址。操作数组元素不会改变内存地址，因此不会触发列表监视器。</p><p id="e903" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们给list属性分配一个新的数组体。分配新的数组体会改变内存地址，从而触发观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acc"><img src="../Images/a5dfbe6639bde3327a5b7f8b15f26118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQ3H_yeoolxQfroGJfjXFA.png"/></div></div></figure><p id="9976" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个数组都有自己的内存地址。因此，如果我们给list属性分配一个相同的数组体，list watcher仍然会响应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sc"><img src="../Images/a82dbc0e6a01232a60ad28661e576dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpWqm1nwOACzjCvdfX801Q.png"/></div></div></figure><p id="5c83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们观察汽车物体，我们会得到同样的结果。</p><p id="307d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重置对象属性不会触发汽车监视器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acd"><img src="../Images/d0405fddee9294148a942ee7c33d41ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOcrU33_hn1zgQF7hsN7zQ.png"/></div></div></figure><p id="5bfb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要给汽车属性分配一个新对象来触发汽车监视器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rq"><img src="../Images/58ba9a27ef2ff62b468d4717e95d3b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHURh5eztavThi2cRGxmkg.png"/></div></div></figure><p id="4059" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当deep属性设置为false时，观察器只监视被观察值的内存地址。</p><p id="b6be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">手册上说我们只能将顶级数据、属性或计算属性名作为字符串传递。对于更复杂的表达式或嵌套属性，我们应该使用getter函数。</p><p id="8ff8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着如果您使用字符串设置$watch方法的第一个参数，那么该字符串只能是顶级数据、属性和计算属性的名称。</p><p id="e204" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是根据我自己的实验，你可以直接看一个数组的元素总和。只需将list.length放在引号中。$watch方法将观察目标数组的元素总数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rs"><img src="../Images/890d7c94310420079169e47e3220aa84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBO1ptV6jsSZtUBa-yNfRA.png"/></div></div></figure><p id="d58c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们能监视元素总数，我们能监视特定的元素吗？让我们找出答案。我们观察第一个数组元素。</p><p id="1341" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察器已被触发，但不需要测试程序。我们变得模糊不清。处理函数无法访问第一个数组元素。列表零不能作为字符串直接传递给美元符号监视方法。它不能被识别。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ace"><img src="../Images/4e54be2b7c3b8c0e26f5ec8769f6f93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQBNVU7z22Onj9Urq7H2iw.png"/></div></div></figure><p id="bbac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们看看是否可以观察一个对象属性。我们以品牌资产为例。</p><p id="e6d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它起作用了。</p><p id="960b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">改变品牌价值会触发观察者。</p><p id="f20c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意这里，品牌价值是一个字符串，是一个原始值。如果它的值是一个嵌套对象，那么监视器仍然只监视嵌套对象的内存地址。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acf"><img src="../Images/f8e95be9e33f68f394271d9ad45f7ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azE4J8Hb5KxI6zvqhAcSxg.png"/></div></div></figure><p id="5b70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将deep属性设置为true。这使观察者能够观察数组元素和对象属性。嵌套的数组和对象也会被监视。</p><p id="b47b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看列表数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rt"><img src="../Images/b5de78050133b30b4bcb1597b74d0468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-YzzPeakn89-6upFHpbRg.png"/></div></div></figure><p id="fe51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们去掉一个元素。</p><p id="45d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察器被触发了。</p><p id="30be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重置元素值也会触发观察器。</p><p id="f6ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分配一个新的数组体也会触发观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acg"><img src="../Images/fe6baff26bc9077f67bc1f58d187f4e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbNwiqU4Pt27cwFH4D-M4Q.png"/></div></div></figure><p id="ae74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来看汽车对象。</p><p id="fe9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，重置属性值可以触发对象观察器。</p><p id="951c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给汽车属性分配一个新对象也会触发观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ach"><img src="../Images/ae800a635d6d708fb321cffd55ab846d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kp690O-KqcAAaHxsdkk6vw.png"/></div></div></figure><p id="2ba1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号手表方法的第一个参数可以设置为函数。此函数需要是一个箭头函数，以便它可以从美元符号监视方法中继承This。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rd"><img src="../Images/64716e2fdcb984eba5046665e39684f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BHEIxrqtm07beN2oehBvA.png"/></div></div></figure><p id="c068" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们继续之前，我们将深属性设置回false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aci"><img src="../Images/53a07be7146c5584413b1e7dbadfa583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3nXWuB7ShYP4SnJ4R35AA.png"/></div></div></figure><p id="666b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">传递给美元符号watch方法的函数实际上是一个getter。它返回一个表达式。表情值会被关注。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acj"><img src="../Images/1edef6c86104ec6b23ff2090f7876ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_C1FWlE_jg--9uA7CqLiGw.png"/></div></div></figure><p id="f1d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">getter提供了一个函数作用域，允许我们设置一个复杂的表达式。</p><p id="ca48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们有时选择美元符号手表方法而不是更方便的手表选项的另一个原因。“监视的”选项使用监视源作为属性名。这给我们能看的东西设置了很多限制。getter函数将我们从这些限制中解放出来。</p><p id="488e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们可以只用一个观察者来观察多个目标。</p><p id="7144" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到数据选项来添加新的数据属性。我们将其命名为<em class="np"> nation </em>，并将其值设置为UK。我们想一起看城市资产和国家资产。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ack"><img src="../Images/bf0b2cd0ddf58f543530c38b2661c040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKPbcMHFQt-VXSIsyWMmlw.png"/></div></div></figure><p id="5afd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在getter函数中，我们返回一个数组，并将城市属性和国家属性放入其中。</p><p id="6306" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意这里，我们将这两个属性传递给getter函数。你需要在他们的名字前加上这个。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acl"><img src="../Images/d095cf89d981fa16fd8e528dd1321f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tl8GFw5l5NRYylpYTtaxg.png"/></div></div></figure><p id="ee70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们有了一个监视城市财产和国家财产的监视者。更改任一属性值都会触发观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acm"><img src="../Images/d60a808dbc80d89896c67edd5b04fed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naN72Ju02kyRRSvZtqZSZQ.png"/></div></div></figure><p id="2448" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以观看数学结果。</p><p id="855e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了另外两个数据属性。我们将它们命名为A和B，并将它们的值分别设置为10和5。</p><p id="d564" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们返回A加b。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acn"><img src="../Images/6c427a1ca4a6cb999253970a9ef266c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UITpry-wun4twEhv9CkmCg.png"/></div></div></figure><p id="c240" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="5b31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到观察者观察A和b的和。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aco"><img src="../Images/fe8c3aec500b098f6923136d0007edc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TzsrWQVJzaQQFYLpMYoKA.png"/></div></div></figure><p id="df8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们把A设为100。</p><p id="08cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察器被触发了。</p><p id="7cc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新的总数是105。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi acp"><img src="../Images/e3ee3ceaa47404b42280995af72b08ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*5MbM0jiU0u6mmqsY8176EA.png"/></div></figure><p id="3161" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们定义一个函数来一起改变A和B的值。</p><p id="01b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们把A设为105，B设为0。</p><p id="9c60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总和不变。因此，即使A和B的值都被重置，观察器也不会响应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sx"><img src="../Images/4b11a2e784f874463c8ad920b494a796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*xpKwfi4vJbJsNcB8Hqorog.png"/></div></figure><p id="4dc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的实际项目中，我们可以使用这个特性来监控总成本、平均评分等数据。</p><p id="fe5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用spread操作符，我们可以将数组的代理对象转换回数组。该表达式不能用作属性名，因此不能在watch选项中使用。但是我们可以在getter函数中返回它。</p><p id="c189" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然保持深属性为假。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qh"><img src="../Images/16ee96c905f8963ba7fb7bf7c03597d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiC3jrUVKEENaNnY8NyNGw.png"/></div></div></figure><p id="5291" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个文件。</p><p id="1750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到观察器现在观察列表数组，而不是它的代理对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acq"><img src="../Images/8235cf8f843af1e5fb3688ae4cce2d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0m1VywaXihQaYE9B_jjqaw.png"/></div></div></figure><p id="dd7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从数组中移除最后一个元素。</p><p id="918c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察器被触发。</p><p id="f91b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置第一个元素值。</p><p id="22e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察器再次被触发。</p><p id="0161" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分配新的数组体也会触发观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ss"><img src="../Images/8c5971fcea7fc0214d5806dd6ca2b496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1xXi7LYLnOYkPUObYuotQ.png"/></div></div></figure><p id="a43a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们看看是否可以观察一个选定的元素。我们返回第一个元素。</p><p id="4ab3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，与上节课中的实验不同，第一个元素值已被成功检索。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/4d23bd5aba20852a1b0a95686d69f3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TsdhbOv0FbkbngOxk7eIg.png"/></div></div></figure><p id="9e5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给第一个数组元素赋值。</p><p id="4cd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到监视器被触发了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acr"><img src="../Images/e72ee7476df29298a74fef9fc9239e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIgBBACTSFiBYs6OwBShog.png"/></div></div></figure><p id="7f8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，我们只使用了一个组件:根组件。在本课中，我们将向您展示如何创建和使用子组件。</p><p id="6d8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开APP实例对象，你会发现一个名为<em class="np">的方法组件</em>。这个方法是我们用来声明全局组件的。全局组件在根组件和其他子组件中可见。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xz"><img src="../Images/d67c4cfcfde16bc7e55d957f01a35b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvf0bZ4V8rThiXBc8BNvpw.png"/></div></div></figure><p id="6ede" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件方法有两个参数。第一个将用于命名子组件标签。</p><p id="5a77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个是选项对象。该对象与传递给createApp方法的对象相同。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acs"><img src="../Images/ef261e14975d64d4540f90b11839c682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crrmq2C-O8o3cByzCbi4Vg.png"/></div></div></figure><p id="044c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用name选项为子组件设置一个名称。名称选项是可选的，但我们建议您保留它。在后面的课程中，我们将向您展示它能为我们做什么。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi act"><img src="../Images/1daf63d46edbf7c5446fc4fcde222447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hrD_zg4OSyC_kX44mEcuQ.png"/></div></div></figure><p id="da99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加数据选项。它的值是一个返回对象的函数。数据属性在返回的对象中定义。</p><p id="9835" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在函数中返回一个对象被称为工厂模式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi acu"><img src="../Images/979425beabe0e10796a3512ad20c6e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*4o4VBnmqtdmWFOfYxrujBw.png"/></div></figure><p id="7cdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道为什么我们要在函数中返回对象吗？为什么我们不直接把对象赋给数据选项呢？为什么要费这么大的劲？稍后我们会告诉你为什么。</p><p id="995b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其他选项如计算、方法、观察器与根组件中的完全相同。</p><p id="3986" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根组件通过mount方法连接到它的模板。我们如何将一个子组件连接到它的模板？</p><p id="f7e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用模板选项。我们将HTML模板作为一个字符串分配给它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ri"><img src="../Images/c2892d5d80686bfe4d39f5a87a969a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKBw_xhROj0Hd_fQhzuDOg.png"/></div></div></figure><p id="5a6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，一个非常简单的全局组件完成了。它可以安装在任何组件中，并且可以重复安装。每次安装都会创建子组件的新实例。</p><p id="7a33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们安装子组件。子组件标签被视为HTML标签。为了遵循HTML规则，我们需要将大写字母转换成小写字母，并在前面加一个破折号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acv"><img src="../Images/31adaa743b1dad02d0033eb41ea0055f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIsESgxBCJzSTPiJZv0rBg.png"/></div></div></figure><p id="5308" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="8f35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件已成功安装。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abh"><img src="../Images/d834be1d50b261d92dd26b7e0b417504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HHT6nGH-6s8qp5nXbd20uw.png"/></div></div></figure><p id="d9f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将模板设置为字符串非常不方便，尤其是对于复杂的模板。更好的解决方案是单独定义子组件模板。我们为模板选项分配一个元素ID。</p><p id="1f55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们添加一组模板标签。模板标记的ID必须与分配给模板选项的ID相同。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acw"><img src="../Images/c2fbabd38e01f3d8089beddda26133f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWHSrF6tOX_VdVZXZebebg.png"/></div></div></figure><p id="ad9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从Vue 3开始，子组件模板不再需要根DIV。位于根DIV之外的元素称为片段。但是最好还是为子组件模板设置一个根DIV。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abw"><img src="../Images/e23737986d16dd0d02ee22b1aee90d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MMb8Y50kUlVIlHsA0mPgQ.png"/></div></div></figure><p id="649a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了访问子组件实例，我们在子组件标签中设置了<em class="np"> ref </em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acs"><img src="../Images/f5f88d6eaee6ec61da8db74857379fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpfqICasaZoaoYL4sOU9Fw.png"/></div></div></figure><p id="3c2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以通过它的ref值访问子组件实例。</p><p id="cd46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同一个子组件可以重复安装。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acx"><img src="../Images/00cf7bc2a3f567d2d90cfa68940c5408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNtwmSjqm2aIN9rQu3Golw.png"/></div></div></figure><p id="7bf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次安装都会创建一个新的组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acx"><img src="../Images/00cf7bc2a3f567d2d90cfa68940c5408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNtwmSjqm2aIN9rQu3Golw.png"/></div></div></figure><p id="7186" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有实例都是独立的。如果我们修改一个实例的数据属性，其他实例不会受到影响。</p><p id="2727" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用工厂设置数据选项可以使同一组件的实例相互独立。</p><p id="2f27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当我们创建一个子组件实例时，分配给数据选项的函数将被执行并返回一个新的对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abp"><img src="../Images/fae4a91f8ec7f9c213f3d0de18bed654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZxunoTM_GSScRMFMmaaDQ.png"/></div></div></figure><p id="3da8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，每个组件实例都有自己的数据对象。这保证了同一个组件的实例是独立的，不会互相干扰。</p><p id="4052" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试本地组件。</p><p id="ee65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件中，我们添加了组件选项。它的值是一个对象。</p><p id="7430" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性名将用作组件标记名。属性值是options对象。语法和以前一样。数据选项必须是返回对象的函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acy"><img src="../Images/ebce209c2816bf4fad1deef1c803b6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wydUzG3fuuIu678Wli-s_g.png"/></div></div></figure><p id="70db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个本地组件是在根组件中定义的，所以它只在根组件中可见。它在子组件中不起作用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abl"><img src="../Images/7855a6bce211563bb886cced8e20df91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTFiX877jObPThKIl0MCKA.png"/></div></div></figure><p id="b560" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将比较子组件钩子函数和父组件钩子函数的执行时间。</p><p id="7a16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件中，我安装了六个生命周期挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acz"><img src="../Images/5d484eb010d751747a81c9e9b9254ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bHrR655X7YjIG6QjrO6Xw.png"/></div></div></figure><p id="bc6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将这六个钩子复制到子组件中。</p><p id="91f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住手动修改beforeCreate挂钩，因为它不能访问数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yu"><img src="../Images/2e21126192a49e138770eabc365885c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAvZFU9bXdBqRzOkk-k9lw.png"/></div></div></figure><p id="4fb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="db8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件被视为根组件模板的一部分。</p><p id="5db7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件的创建和挂载挂钩在根组件的beforeMount和mounted挂钩之间执行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ada"><img src="../Images/461570de3c92a32cb49671a80c2f3f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*rFI9cHHnEgtWTqCfElP-oA.png"/></div></figure><p id="af14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们调用unmount方法来删除根组件。</p><p id="7cff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件的beforeUnmount挂钩和Unmount挂钩在根组件的beforeUnmount和Unmount挂钩之间执行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/9e2af8cb1436c77b7985b9a6db58db13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*yOsYZZdxe2aVjvg_FUpv5w.png"/></div></figure><p id="2ed6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们尝试更新和渲染挂钩。</p><p id="2747" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在根组件中启用它们，并将它们复制到子组件中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adb"><img src="../Images/bfd9cf8f4ff82af9398898df6f9da9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2ojB7Xx9B_JEKxY1VaAHg.png"/></div></div></figure><p id="5988" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="4b5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到子组件是在根组件的renderTracked钩子被触发后创建的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xu"><img src="../Images/c3a0fad19c9de1c85d2fdfe53583f8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*L3CVTiMC3B4zNLT1LBm6_g.png"/></div></figure><p id="1126" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们更新根组件的title属性。</p><p id="7230" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件不受影响。子组件中没有触发任何更新或呈现挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi adc"><img src="../Images/7100603cc36e069c9a506d84561aa6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*0CfT7Pxsfd3VoTSMQm__wA.png"/></div></figure><p id="a42d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，如果我们更新子组件的title属性，根组件不会受到影响。不会触发来自父组件的更新或渲染挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi add"><img src="../Images/5ea71d4373c336c640eecd7f8693a77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*hwP5xKLJzhsNes4TQE3ihQ.png"/></div></figure><p id="d00f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到子组件的已创建钩子，并在其中抛出一个错误。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ade"><img src="../Images/d27d89cb2e93c52605bac239bdb7954c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckBqAc1u_1njw9yd2CBJCw.png"/></div></div></figure><p id="e614" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到整个程序都停止了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/3be7ad9fa37366766437bbce625ec5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*MPnrsdeAgAFWZM2rnA3EFw.png"/></div></figure><p id="980a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根组件可以拦截来自其子组件的错误。</p><p id="06b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件中，我们添加了errorCaptured钩子。errorCaptured挂钩有三个参数:错误消息、触发错误的组件实例和包含错误捕获位置信息的字符串。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adf"><img src="../Images/67d3f1a89f892f2751877242c6e142c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZgyKuvUngGS6iL9eO5ziQ.png"/></div></div></figure><p id="a327" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再试一次这个程序。</p><p id="c2e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到来自子组件的错误已经被安装在根组件中的错误挂钩捕获。</p><p id="a93a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们收到了错误消息。</p><p id="53eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">错误消息下的代理对象是子组件实例。</p><p id="eac6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">错误在创建的钩子处被捕获。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adg"><img src="../Images/f6df23854acc0e2e68c0aa2d65df5e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzZiToENi2T1AEmW6vLehQ.png"/></div></div></figure><p id="a217" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在errorCaptured钩子中，我们可以返回false来阻止错误进一步传播。这样Vue会想尽办法挽救程序。</p><p id="c20b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到根组件已经成功装载。我们有一些警告，但是没有致命的错误关闭整个程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adh"><img src="../Images/f0fc4f4067b174043688a36607848781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5x0UfE7O9HZ6pNiaTzvwg.png"/></div></div></figure><p id="ce14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根组件的创建、挂载和呈现都是成功的。</p><p id="16ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件也已创建并成功挂载。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/bc98ca0e22abacb4501690dc29049367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*QI5JIbNTztUySqvRnn5YRg.png"/></div></figure><p id="0f11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根组件的属性仍然可以更新。</p><p id="8f05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以更新子组件的属性。尽管在子组件创建的钩子中抛出了错误，但是根组件和子组件仍然可以正常工作。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adi"><img src="../Images/2c7c52cf69f0ff9735953dba511755f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wX6jThslCGhBQNrTeoT3FA.png"/></div></div></figure><p id="5355" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您的实际项目中，您可以使用errorCaptured钩子来最小化损害。</p><p id="c343" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件标签起着特殊的作用。它是父组件标记和子组件标记之间的交集。因此，它可以访问父组件和子组件。这使得它成为在父组件和子组件之间交换数据的最佳位置。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adj"><img src="../Images/27815dcbed310afc038979f87ad8571e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYnbv7yix8NEl9NQkSc_XQ.png"/></div></div></figure><p id="0bc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将数据从父组件发送到子组件，我们使用props。Prop是property的缩写。在下面的课程中，我们将区分这两个词。Props仅指用于将数据从父组件发送到子组件的属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi adk"><img src="../Images/5a708d177e782d8c52cf97cd934a2259.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*heHdDeITOtz8Pq0U9Zth0w.png"/></div></figure><p id="0692" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">道具属于子组件，但可以从父组件获取它们的值。这就是父组件将数据发送到子组件的方式。</p><p id="de0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们使用一个道具之前，我们必须先声明它。</p><p id="5a66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件的选项对象中，我们添加了props选项。它的值可以是数组或对象。我们将从数组语法开始。每个元素都是一个专有名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi adl"><img src="../Images/adb3c8e1c8f847ddbbcc6cea08e3e386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*UOZr-FSUM2MM57MdhdGpKQ.png"/></div></figure><p id="4f09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，子组件有了一个名为mail的新道具。mail prop在子组件标记中是可见的，它作为一个属性工作。</p><p id="4883" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查子组件实例。</p><p id="7048" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以在子组件实例的根级别找到一个名为prop的属性。其当前值为<em class="np">未定义</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi adm"><img src="../Images/11d957a0c71b95bbb0cb56a9dd1e82d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*5aRIs_zs-BlS-9rkHbaEjA.png"/></div></figure><p id="7ba6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">向下滚动，您会发现一个名为美元符号道具的属性。这是Vue组件存储其道具的地方。它的值是一个代理对象。代理对象使道具成为被动的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi adn"><img src="../Images/b36704d27b3f2e5090ee2b6cc955db36.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*f-6rApX06DYOUPIkxoYqmA.png"/></div></figure><p id="021e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件实例根级别的属性在组件模板中可见。我们可以直接用道具的名字来展示道具。不需要前缀。在组件方法、钩子和计算属性中，我们可以通过这个来访问props。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ado"><img src="../Images/33ad2a91d857fa768be27d49153ce3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*W2JzMvIqMUOH8M7EWmwnZw.png"/></div></figure><p id="ed77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件标签中也可以看到属性。如果我们将子compose标签视为HTML标签，那么props只是HTML标签的属性。</p><p id="f444" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用v bind指令作为邮件属性的前缀。v bind指令允许我们访问父组件实例。我们将消息属性分配给邮件属性。</p><p id="cf77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，message属性的值已经分配给了mail prop，现在显示在子组件中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adp"><img src="../Images/ff0fff5aa9372475476203beee91f63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koNK5E90GyEvVyVFX-uYRA.png"/></div></div></figure><p id="8601" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性是被动的，邮件属性从消息属性中获取它的值，如果我们重置了消息属性的值，邮件属性将自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adq"><img src="../Images/bd5764ce8f7901d8c5bd65e40c20f172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9scWv7Ry1gDeg23RkwdkGA.png"/></div></div></figure><p id="4733" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，道具被设计成只读的。不要试图通过组件实例修改道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi acu"><img src="../Images/55ddf26033b9a6afa8ce8a9e92b1ca66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*WVJW9Uz5sBvd4_p2HVYBCg.png"/></div></figure><p id="617a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您需要处理一个属性值，请创建一个数据属性并将属性分配给它。避免直接修改属性值。</p><p id="7a11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">道具可以看，就像普通的数据属性一样。watcher函数的名称与被监视的道具相同。它将在被监视的道具接收到新值后被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qq"><img src="../Images/5bada258e2ec0bb6db9279f8e7e724cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCMf1L8hVEfITI-JHfc2cQ.png"/></div></div></figure><p id="f421" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可观看性非常重要。我们经常使用props查询后端API。通过为道具设置一个监视器，我们的程序可以在道具值改变后自动重新查询后端API。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xf"><img src="../Images/2e3620b56dabf09b6ba4fbbdb825bfed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*HginyVa6bbePBXfDdWlsvA.png"/></div></div></figure><p id="c70d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">beforeCreate钩子在组件实例准备好之前被触发。因此，它不能访问任何数据属性，因为它们还没有被创建。</p><p id="962a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">道具是不同的，它们在很早的时候就准备好了，甚至在子组件实例本身之前。我们可以在beforeCreate钩子中访问props。记住这个结论非常重要:道具在拥有它们的组件实例之前就准备好了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adr"><img src="../Images/ebb012701bceeed80a19eac053ed77e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esupGOIppcPiOSoii2h_Cw.png"/></div></div></figure><p id="9391" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过v bind指令分配的值可以保持其原始值类型。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ads"><img src="../Images/cfe3ecdc05c1acb5eec6a825d3fa59c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8KH2ZhsbiE6VAVmZsEBmA.png"/></div></div></figure><p id="513f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，我们可以给道具分配一个静态值。如果值是一个字符串，那么我们应该删除v bind指令。否则，Vue可能会将静态字符串值误认为是父组件的属性名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adt"><img src="../Images/f5c67d32f1f9abe4ef4f50786678f8ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKxAqta40s0b2f1PTaZCnw.png"/></div></div></figure><p id="0bb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是对于其他值类型，移除v bind指令会导致一个问题:无论它们的值类型是什么，都被视为字符串类型的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adu"><img src="../Images/230bcd044d589c424160444efde74ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwsAuEavdlTAXVng4bXZdA.png"/></div></div></figure><p id="39b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了保留数据类型信息，我们需要带回v bind指令。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adv"><img src="../Images/205d92b2e5bbc6084d457057031671c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrUnbfZ8823hq4l7OdhGVA.png"/></div></div></figure><p id="bc13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">静态值可以不带引号地赋值。但是报价还是推荐的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi za"><img src="../Images/9b7e765df4c0b8e958581131ec8b69b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NgqEbywrBI0-w3Bqk6_4Q.png"/></div></div></figure><p id="aaf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的引号标记的是JS表达式的边界，而不是字符串。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adw"><img src="../Images/288af558a4b6696f6f27bb8f3f12a666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVThlGKNySHkSGCylOOMbA.png"/></div></div></figure><p id="a15a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据手册，只有设置道具名称才意味着道具值为真。但是这个功能可能并不总是有效。该属性值更可能被视为空字符串。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adx"><img src="../Images/719090b196d2fbd551a87fc21d0d943c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jiujIbePNwLl4EHSjUJaQ.png"/></div></div></figure><p id="af5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在上一课中使用的属性值是一个字符串，它是一个原始值。</p><p id="11de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">具有原始值的道具是只读的。它们只从子组件标签中获取值。您不能通过组件实例重置它们的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wa"><img src="../Images/9fca28c99f669ea9ca8df14271ba6a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INYkLd0xCXcS2mMEe6yC2A.png"/></div></div></figure><p id="e060" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个很好的安全特性。它确保数据只向一个方向流动。子组件不会无意中修改父组件的属性。</p><p id="1330" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是有一个漏洞。如果我们给一个属性赋一个引用类型的值，这个属性又变得可写了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi px"><img src="../Images/887af0b974463f69e4479b05e9062321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRvM2fPYV4Wtb6EGZxDcIA.png"/></div></div></figure><p id="393c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对象是引用类型的值。邮件道具实际收到的是消息对象的内存地址。</p><p id="5948" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，子组件的邮件属性和父组件的消息属性指向同一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/dd40157ab46b8d65ee369841b0526fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDsISkuWlVEJrPGQTxRcQQ.png"/></div></div></figure><p id="217f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过邮件属性修改消息对象，父组件也将被更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ady"><img src="../Images/a0a54a52506951e3a1897892e3b4f13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1HgI4nFpPLDRgPvHZ77lg.png"/></div></div></figure><p id="4957" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">乍一看，这似乎是一件好事。Props设计用于将数据从父组件发送到子组件。但是现在它也可以反向发送数据。感觉就像买一送一。</p><p id="71fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仔细观察就会发现问题所在:我们无法阻止数据被反向发送。如果我们修改子组件中的属性值，父组件将不可避免地受到影响。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adu"><img src="../Images/7ce64d53f5928a9c4f02e8c85cf5f6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORvixbRQhrUajMumus2vmg.png"/></div></div></figure><p id="9d29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们多次安装了同一个子组件，那么所有这些实例共享同一个内存地址，因此修改同一个对象。这意味着没有实例是真正独立的。</p><p id="18ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您的实际项目中，当您将一个引用类型的值传递给一个prop时，要格外小心。</p><p id="7acc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果可能，避免直接使用引用类型值。</p><p id="1d4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数组语法只声明属性名。使用object语法，我们可以为props设置默认值和其他要求。</p><p id="9566" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性名将被用作专有名称。属性值是一个对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adz"><img src="../Images/d2f03bcd1c19c0ff8959861d1281ce75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AawL2u2raGfufZFOtpo5Tg.png"/></div></div></figure><p id="4429" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<em class="np">默认</em>选项，我们可以设置一个默认的属性值。</p><p id="c95c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原始值可以直接分配给默认属性。对象和数组必须使用工厂模式。我们将默认选项设置为一个函数，并返回其中的对象或数组。</p><p id="cb5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">部件可以重复使用。我们不允许不同的组件实例共享同一个对象或数组。工厂模式确保每个实例都有默认属性值的新副本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ts"><img src="../Images/f4d13dbcdfb7f578d5c574b6a8f474a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsLG6i-_00Q-1X8n5vOwhg.png"/></div></div></figure><p id="2665" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用类型选项，我们可以限制属性的可接受值类型。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aea"><img src="../Images/06049c035cf84ae1d8c33400864b990b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXNGSQzq5yG7VBT-QIpCRw.png"/></div></div></figure><p id="8d47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="e931" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从子组件标签中删除邮件属性。</p><p id="ef7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在已经使用了默认的prop值。它的工作原理和普通的属性值一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeb"><img src="../Images/b812b454fe526355ae4383062eeb0ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZcdqPfB1Di5ah82tfOtsw.png"/></div></div></figure><p id="ef6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们要求邮件属性的值是一个字符串。让我们给它分配一个数字，看看会发生什么。</p><p id="c974" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到了警告，仅此而已。非法属性值已被接受并显示给用户。</p><p id="a5b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您需要设置几个可接受的值类型，请将它们放在一个数组中。</p><p id="750a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，我们可以设置八种数据类型。除了字符串和数字，我们还可以设置布尔、数组、对象、日期、函数和符号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zj"><img src="../Images/a4acf7ee0b49a614f3c18e0d7ab2fb12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roF5qplPINPtzKYvXc0Mng.png"/></div></div></figure><p id="7b71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对象语法还允许我们设置一个验证器函数。validator函数接收当前的属性值，并在我们加载页面或更改属性值时被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ve"><img src="../Images/c70c34cf2129a367fc45f6cb28494552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7H-xIAbNPQtqFVg81MF1w.png"/></div></div></figure><p id="8e38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经提供了合法的属性值，但是验证器仍然失败。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rj"><img src="../Images/b7cc69f09893801a5d6b382ad46e2ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fa485OHBDic-8VlR4SPsZg.png"/></div></div></figure><p id="667f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了使验证器成功，我们需要在其中显式返回true。失败的验证器只会生成一个警告。程序仍然正常加载。</p><p id="0631" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">验证器在beforeCreate挂钩之前被触发。这意味着验证器函数在组件实例创建之前被触发。因此，验证器函数中的THIS不能指向当前组件实例。</p><p id="f7c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它指向窗口对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ss"><img src="../Images/9db34784dce004d2da3667adb1669005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5O_t6eenAgSfhPH44p9XuQ.png"/></div></div></figure><p id="d982" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们显式返回true，警告就消失了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aec"><img src="../Images/503d05d87e05473fd135f98041de5684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZFDqAtJq3yvUEZUHWm7XQ.png"/></div></div></figure><p id="a579" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有一个父组件和一个子组件。</p><p id="2865" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件有一个名为message的数据属性。父组件也有一个同名的数据属性。</p><p id="b1dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望将子消息的值发送给父消息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aed"><img src="../Images/a31f9434b7dfe5d21a0fec8e853a180f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FsPRj2E-WcgvdVkygNqog.png"/></div></div></figure><p id="545a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据交换仍然发生在子组件标签中。我们首先将子消息向上发送到子组件标记，然后将它拉下到父组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tb"><img src="../Images/154a1b03e9a67b7e196ec26d9da8827e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPSCJpR4yXnvop7Ix6j7sA.png"/></div></div></figure><p id="d049" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从子组件向其父组件发送数据需要自定义事件。</p><p id="1915" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，更准确的说法应该是将数据从子组件发送到子组件标签需要定制事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acr"><img src="../Images/b40727069dca01a05ac4851d7a335a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaCd9QbECo3A2EZguGAl_w.png"/></div></div></figure><p id="3c28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自定义事件在子组件中声明。我们使用$emit方法发出它。</p><p id="7431" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">$emit方法有两个参数。第一个是发出的自定义事件的名称。第二个是绑定到发出的事件的一段数据。任何侦听自定义事件的人都会收到绑定的数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aee"><img src="../Images/a12e1a88d1830ef843cd93d67e74c786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNjkd8ZKZlki0adCck8UXQ.png"/></div></div></figure><p id="33c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">$emit方法来自组件实例的根级别。它可以直接访问整个组件实例。我们可以通过这个访问数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yt"><img src="../Images/2587862f18535a86630ab172fab2f2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjrMD8x1WpFGznZJ7KvnGA.png"/></div></div></figure><p id="c0ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自定义事件被发送到子组件标记。</p><p id="6142" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像本地事件一样，我们使用v on指令来监控定制事件。由v on指令触发的方法属于父组件。</p><p id="562d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">被触发的方法接收<em class="np">美元符号事件</em>对象。美元符号事件存储绑定到发出的自定义事件的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aef"><img src="../Images/66f3ee1d2379d974a905841f0c46f4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDoEhT4Nx4U3AwqVyEJcrg.png"/></div></div></figure><p id="0890" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">被触发的方法属于父组件，因此它可以访问父组件的实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abj"><img src="../Images/bd67daba2ad59bf7c1ad7d634dfad185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1De2wc_AzHo5FjMtdl5iA.png"/></div></div></figure><p id="6d00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将<em class="np">美元符号事件</em>分配给父组件的数据属性。这就是子消息属性的值发送到父消息属性的方式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yt"><img src="../Images/ea3469384ff9d738be31b384f6f4e5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6DMmTfTX72-sZDwkP33fA.png"/></div></div></figure><p id="2eef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自定义事件完成了一半的工作:将数据从子组件发送到子组件标记。v on指令和inline方法完成剩下的工作:将绑定到自定义事件的数据分配给父组件的数据属性。</p><p id="9a76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们在一个真实的项目中尝试自定义事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sb"><img src="../Images/b855f8a0551d7c78528660f1ad125221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGgN66nKN6kO_USoDi01Mg.png"/></div></div></figure><p id="3a6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从Vue 3开始，所有自定义事件都必须首先声明。声明是使用emits选项完成的。它的值是一个数组。每个元素都是一个事件名称。</p><p id="2be9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们宣布了一个名为<em class="np">接力</em>的自定义事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeg"><img src="../Images/9ce8a9ca010ea2a33fa9d433ffadc0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSO9_s6jNnlsy5Kj1Ho_GA.png"/></div></div></figure><p id="b1ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到子模板并添加一个按钮。当我们点击按钮时，我们触发了一个名为send的方法。</p><p id="2711" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">send方法是一个shell，我们用它来触发emit方法。</p><p id="21c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在send方法中，我们通过这个来访问emit方法。</p><p id="aa68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将其第一个参数设置为<em class="np"> relay </em>，将其第二个参数设置为<em class="np"> this dot message </em>。</p><p id="9b2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，子消息属性已经绑定到中继事件。当我们单击send按钮时，中继事件将被发送到子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeh"><img src="../Images/7f27d10fc0597ebe82c3d764fdb96389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZmhlo2NcK8clC3RTa5fXw.png"/></div></div></figure><p id="31fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到子组件标签，使用v on指令来监控中继事件。</p><p id="c354" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们触发一个内联方法。这个内联方法属于父组件，因此可以访问根消息属性。我们将<em class="np">美元符号事件</em>分配给消息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aei"><img src="../Images/dd8cff70093dd50af03c48f8b21d116d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRwBjk8x6MYelD_0sj6J2g.png"/></div></div></figure><p id="0706" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="b11f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们点击按钮。</p><p id="84da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到根消息已经被子消息所取代。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aej"><img src="../Images/1716071399af1d6bc85710215f813a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8JC-KkyX_A8eaQxztAouA.png"/></div></div></figure><p id="00a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们用一个输入框替换这个按钮。</p><p id="35e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加v model指令，并将输入框绑定到子消息属性。然后我们监视本地输入事件并触发send方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aek"><img src="../Images/79ed4a41e4b057ef1234bbc8cbd1126d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTaCdAkaTUcrSoawvZuJGQ.png"/></div></div></figure><p id="30b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入框修改子消息属性。每当我们在输入框中键入一个新字符时，send方法就会被触发，并发出relay事件，并将最新的子消息值绑定到它。</p><p id="e088" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="de14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入框同时修改两个消息属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ael"><img src="../Images/ca1be1c074c7ce99d4a19aebb6638c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*26npq9l4CgZlfOSoP1NPkA.png"/></div></div></figure><p id="65c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们有一个父组件和一个子组件。它们的模板中都有一个输入框。我们希望这两个输入框保持同步。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rc"><img src="../Images/0ed10bcc983e6059371f028c06a87718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_OATG0Qi7FIwnminKPe-Q.png"/></div></div></figure><p id="b881" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这要求我们在父组件和它的子组件之间建立一个双向数据路径。这种路径需要一个属性和一个自定义事件。</p><p id="d9e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们向下发送数据:从父输入框到子输入框。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aem"><img src="../Images/9f4dbf00749c75284b8a44d6adf89dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOMT6qogtYGFlcfiM53lTw.png"/></div></div></figure><p id="1fac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">父输入标记依赖于v模型指令，并连接到消息属性。我们需要将消息属性发送到子组件中。这就要求我们在子组件端声明一个prop。我们称之为道具邮件。</p><p id="8f66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子输入标记中，我们将邮件属性分配给value属性。子输入框中显示的内容现在由邮件属性决定。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aen"><img src="../Images/75a7d67dcd892933bb903fed88bb53be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYCh_7RUAdrYSgzcEHeJfA.png"/></div></div></figure><p id="4807" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在子组件标记中，我们将消息属性分配给邮件属性。</p><p id="29f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，父输入框中的内容将被发送到子输入框中。道具是反应性的，在父输入框中输入的任何东西都会立即出现在子输入框中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeo"><img src="../Images/35b1ffd573d9e40b09e0ad7db89c2ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkRBVsRq4eGBTSxzRm5QtQ.png"/></div></div></figure><p id="ba4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们向上发送数据，从子输入框到父输入框。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aep"><img src="../Images/ea7b91e46d044ec1b6c336fb89890d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a90I5nGokKB1_88fPua3Ng.png"/></div></div></figure><p id="8b96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从子组件发送数据需要一个自定义事件。我们称之为接力赛。</p><p id="9998" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子输入标签中，我们监控本地输入事件并触发一个发送方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeq"><img src="../Images/859e9804716be189eb483491d7cf7f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxCjNkai3y4i6pbeUHPMEg.png"/></div></div></figure><p id="ee64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">send方法自动从v on指令接收美元符号事件对象。用户提交的数据存储在事件对象中。</p><p id="b8a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在send方法内部，我们调用emit方法来发出中继事件，并将用户提交的数据绑定到该事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aer"><img src="../Images/a200dbeba789277e7dd4264a94725a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MBsCvZXXvRGhLvvzR36Hg.png"/></div></div></figure><p id="286f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件标记中，我们监视中继事件并触发一个内联方法，在该方法中，我们将<em class="np">美元符号事件</em>分配给消息。这就是子框标签向父输入框发送数据的方式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aes"><img src="../Images/57ac3740d69a11577e2da41a83d8c227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSIOm_eHN-z-lXttDa9T_A.png"/></div></div></figure><p id="181f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子输入标签中，我们监控本地输入事件。每个输入都会触发发送方法，发送方法会发出中继方法。因此，子输入框中的任何新输入都会立即显示在父输入框中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adu"><img src="../Images/ea6db4825c3584f5def8ecc5b809f48d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbeYmSSqL7ydMCFKeJDiyg.png"/></div></div></figure><p id="eea2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们将刚刚学到的内容应用到一个真实的项目中。</p><p id="efc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一个根组件和一个子组件。为了清楚起见，我将从头开始构建两个输入框。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi un"><img src="../Images/73419d89772258c462609ad6d4eb1383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QbpunZUkLKXXslB6hHe2yg.png"/></div></div></figure><p id="7f76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根模板中，我们添加了一个输入标签，并将其v model指令设置为message。</p><p id="c661" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们转到根组件的options对象来定义消息属性。</p><p id="dbbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，根组件有了一个输入框。输入框连接到消息属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rb"><img src="../Images/ba7f857760915c83e9099148e11f2671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMfmlgBQnpeJfMOu3XjSWA.png"/></div></div></figure><p id="f3a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到子组件的options对象来声明一个新的道具。我们称之为邮件。</p><p id="a4c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件标签中，我们将消息分配给邮件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aet"><img src="../Images/d87a74e0db61c3586b65ec4f51c37dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqN9TVeNfbBeFslsGs1QkQ.png"/></div></div></figure><p id="a882" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转到子模板，定义一个新的输入标签。我们使用邮件属性设置它的值属性。</p><p id="ad81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，父输入框能够向子输入框发送数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vo"><img src="../Images/eeae3f9afab3f2e6945a656b3ee8c8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85MzYp2ZEvEBw_6GyDxUqw.png"/></div></div></figure><p id="c5d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的下一项工作是反向发送数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeu"><img src="../Images/3ad430aa4b9aaafd1d17904c3b3900c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GW-e32Bss5Qf55pE_5IrdA.png"/></div></div></figure><p id="e41b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到子输入标签，添加v on指令。我们监视输入事件并触发send方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abu"><img src="../Images/d1077ea158da76006be3d96b252c3485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujN0Jljnd-sWX5JcwYJjXQ.png"/></div></div></figure><p id="f104" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们转到子组件的options对象来定义send方法。</p><p id="addf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">send方法从v on指令接收美元符号事件对象。</p><p id="090b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从send方法内部调用emit方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi rf"><img src="../Images/41bc922211a2fc27391f34dd3cdb900d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*lYvDZhLswgpCquKFTPnMAA.png"/></div></figure><p id="cf0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从Vue 3开始，所有自定义事件都需要先声明。</p><p id="a01d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们称之为自定义事件中继。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aev"><img src="../Images/bd583fcd585ccca0af621c464c9d9c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*jFTszlEDNsiCesd37E9KhQ.png"/></div></figure><p id="7af7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将relay传递给emit方法，并使用$event dot target dot value设置第二个参数值。</p><p id="d4bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，输入到子输入框中的所有内容都将被绑定到中继事件，并被发送到子组件标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aew"><img src="../Images/69da62912bcaf6275afb9e4ba5d66cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA9kdX-ixXO7jT-RjfHQrQ.png"/></div></div></figure><p id="b1d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件标记中，我们监视中继事件并触发一个内联方法。</p><p id="2973" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将$event分配给消息属性。对于自定义事件，美元符号事件直接指向绑定数据。不需要点目标点值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aex"><img src="../Images/ea9123b369131193798d5869f7a124e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNQ4AX8kn-RKOwKXJuhj0w.png"/></div></div></figure><p id="3b72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，程序完成了。这两个输入标签相互绑定，并实时保持同步。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yl"><img src="../Images/1f6012f28d65d651e0c05335d122ae2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glFLbn1AXiPmoTgMBYMPyQ.png"/></div></div></figure><p id="c46b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在之前的课程中，我们学习了v模型指令的真正含义。它实际上是一种语法糖。当安装在输入标签中时，Vue将其转换成另外两个Vue指令:v bind和v on。</p><p id="645a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v bind指令设置输入标记的value属性的值。v on指令监视本机输入事件。</p><p id="89b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v model指令的值是message。它也用作v bind指令的值。</p><p id="26e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">message属性的值在由v on指令触发的inline方法中重置。新值来自被监控的事件。</p><p id="ca31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种安排是固定的，意味着v bind和v on指令以及line方法的参数都是固定的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mf"><img src="../Images/529c77f177c823fc66dd18967499a776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYk_3Cg6NSgyRPEe4bGYiA.png"/></div></div></figure><p id="2772" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们在组件标签中安装v model指令，我们将得到类似的结果。</p><p id="6c75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v model指令仍将被转换为v bind和v on指令。</p><p id="0002" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v bind指令的参数现在是<em class="np">模型破折号值</em>。</p><p id="66f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由v on指令监控的事件被命名为<em class="np">更新结肠模型破折号值</em>。</p><p id="07ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v model指令的值仍然用作v bind指令的值。</p><p id="dd53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v on指令的inline方法做的工作和以前一样。只是这一次，绑定数据直接来自美元符号事件，因为我们正在处理一个自定义事件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aey"><img src="../Images/3fe1d2cdd77876124d914284616076e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOm_KGcYBqEH5xt4pXnekg.png"/></div></div></figure><p id="51b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们在上一课中使用的子组件。它有v bind指令和v on指令。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aez"><img src="../Images/9f15f59339e404f19a00244c0a31c5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-C4I3Bja0Lh9jqOsEc2DZA.png"/></div></div></figure><p id="ca30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v bind指令的值由v on指令使用绑定到自定义事件的数据重置。</p><p id="896f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">道具和自定义事件都是由我们命名的。如果我们将属性重命名为modelValue，并将自定义事件重命名为update colon modelValue，我们将能够在子组件标记中使用v model指令。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/08ec42f79fd29e8579af3953db018e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1qKDavU4ngmUfLgIfWrjw.png"/></div></div></figure><p id="f0ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一件事你需要记住。当我们声明prop时，我们需要的prop名称是modelValue。破折号V应该转换成大写字母V。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abf"><img src="../Images/8de77606e93cb452904b862d0cb1b4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3cmePxJchQKwmqWemdSdRg.png"/></div></div></figure><p id="abde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性名被用作HTML属性名。HTML属性名只接受小写字母。因此，当我们在子组件标签中使用prop时，我们需要进行转换。我们转换大写字母V并在它前面加一个破折号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afa"><img src="../Images/bb29a5d8a59317d133ec0ad14f2a4739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_GyhzZwBj5TZCLk6g5a5A.png"/></div></div></figure><p id="bd9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，为了能够在组件标签中使用v model指令，属性名应该是modelValue。字母V应该大写。</p><p id="6906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们回到上一课创建的程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afb"><img src="../Images/0fb75e74bad199e9683ee6c187dc33fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDZOvipvLNa3umqu0HtRgA.png"/></div></div></figure><p id="966b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们清除当前的子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/ae6ae9108c78a0fad878037dcf39498f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UO1o_AiYhD6GRT4eTzkhA.png"/></div></div></figure><p id="eeb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们安装v model指令，并为它分配消息属性。现在，我们在子组件标签中的工作已经完成。相比之下，子组件标签现在简洁多了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vv"><img src="../Images/2529b3b34c96095993789a099e1c7c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3PR2mqxMlqQvOlnuZ0iMg.png"/></div></div></figure><p id="f367" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v model指令只是一个语法糖，为了让它工作，我们需要确保prop和自定义事件有正确的名称。</p><p id="2768" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将该道具重命名为modelValue。记住字母v要大写。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afc"><img src="../Images/4486dabaa52087dc86aa5a38a8dd6c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPuFJDNYGJVBYzkr8Zw2VA.png"/></div></div></figure><p id="edfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子输入标记中，我们将邮件属性重命名为modelValue。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afd"><img src="../Images/0975908cb3bd470e493a91cb001f8c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WbeuT2dyd7CofV-RWakjg.png"/></div></div></figure><p id="882c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们转到emits选项，并将自定义事件重命名为<em class="np"> update colon modelValue </em>。不要忘记在emit方法中更新事件名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pv"><img src="../Images/3a1d8e058e44499537aca27a38ce07e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8_lCOl5Xc9wEU6dkkQFOw.png"/></div></div></figure><p id="354c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="e682" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个程序和以前一样工作。这两个输入标签总是同步的，并且可以互相控制。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afe"><img src="../Images/23cac6c94b9154dcf9055e7061859bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzjQEMUr2eUkuPF9pTdOPQ.png"/></div></div></figure><p id="2886" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v模型指令可以使用我们自己专有名称。我们使用v model指令的参数来声明新的prop名称。当转换v模型指令时，Vue将使用新的prop名称。</p><p id="51a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在子组件中声明新的道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aff"><img src="../Images/cb82541a3b49b2e1d842fbe479e6d715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSutDOv9UBAZM-jF-dDJsw.png"/></div></div></figure><p id="a67c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子输入标记中，我们将新的属性分配给value属性。</p><p id="77bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自定义事件名称还包括属性名称。所以我们也需要更新自定义事件名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lg"><img src="../Images/5f422c82873e5317ede13db24da6e6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lupuWFDNv_BOFekYrT6jNw.png"/></div></div></figure><p id="284c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以同时使用v模型指令和我们自己的专有名称。</p><p id="8ec6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有一个根组件和一个子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qk"><img src="../Images/e9b7532c3c2d7efb7dc5b5168248b49d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JywDqVFiRef3lYC-Ap9Rg.png"/></div></div></figure><p id="7ccc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根组件的根DIV可以设置嵌套在其中的所有内容的样式，包括子组件中的元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afg"><img src="../Images/595fb9d8a3b10d1b44a1540302d5bf71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5lgwTQlkN4fpirZqhELBQ.png"/></div></div></figure><p id="172c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件可以为自己的元素设置不同的样式，覆盖从根组件继承的样式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afh"><img src="../Images/793e976fe7c5fd57a22523bcc1296e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eanCL1JKvGkvisMYR9uz_Q.png"/></div></div></figure><p id="c2a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们能把这个特性应用到子组件标签上，那就太好了。</p><p id="6d70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将子组件标记视为一个HTML标记。嵌套在子组件标记中的元素应该能够从子组件继承CSS样式。如果我们在这里放一个iTag，那么这个iTag应该能够继承子类的CSS属性。</p><p id="fac0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">开始和结束子组件标记之间的空间属于根组件的模板，因此我们可以访问根组件的属性。让我们将消息属性放在iTag中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/35ac26a81eae4dd3b0180ef29d21ab3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*JRbpAp_DWotAoWo9tAQgBg.png"/></div></figure><p id="1c21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这个程序可以工作，我们将能够使用子组件中的CSS样式显示父组件中的数据。与使用道具不同，我们从来不需要向子组件发送任何东西。</p><p id="f746" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="f02b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到iTag被忽略了。整个节目中没有它的痕迹。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afi"><img src="../Images/08b1b4dab0e57fa8afe1b22044572f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjD1790brroedO8esSxrfA.png"/></div></div></figure><p id="442a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，嵌套在子组件标记中的元素将被忽略。但是有一种方法可以解决这个问题。</p><p id="d4c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根模板可以访问根组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afj"><img src="../Images/cc8fc63ece63baf4d2cace533503b213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NuR-G8lPxsLxqqIr8EdFQ.png"/></div></div></figure><p id="7b64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件标签安装在根模板中，从而在最终呈现的HTML文件中创建一个独立的区域。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afk"><img src="../Images/20e1f0e57077b2d8dd376f18655f2a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnUdGWpf04eKUhABeKZfyg.png"/></div></div></figure><p id="2ee8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">插槽是一个内置组件。我们把它放在子组件模板中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aep"><img src="../Images/6be4c4ac7006a9d47c8868210c332fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4xJ_9uzqcM2m-O6l4bAmg.png"/></div></div></figure><p id="806a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">slot组件创建一个特殊区域，显示嵌套在子组件标记中的元素。</p><p id="4a82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从Vue的角度来看，嵌套在子组件标签中的元素仍然属于父组件模板，因此可以访问父组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afl"><img src="../Images/3c9d23cab0aa32f2808081a9c96dc326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XjaX4BOTFUpK_fIZSpXLg.png"/></div></div></figure><p id="cb63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是从原生HTML代码的角度来看，通过slot组件显示的元素嵌套在子模板中，因此，它们将从子组件继承CSS样式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afm"><img src="../Images/e68f82ce9ed1c5381036da40be9b0069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFsTqkIV4piee24fcmapmA.png"/></div></div></figure><p id="db17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，插槽使我们能够使用子组件显示父组件的数据，而不需要向子组件发送任何东西。</p><p id="a681" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">UI库经常使用插槽，尤其是它们的按钮组件。</p><p id="e571" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，bootStrap Vue使用bButton组件呈现按钮。</p><p id="e8aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按钮样式和交互行为是在bButton组件中预定义的。但是按钮名称不能提前决定。</p><p id="30b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在最后一分钟设置按钮名称，当安装bButton组件时。</p><p id="1d6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按钮名称嵌套在bButton标记中。bButton组件在其模板中有一个槽。这就是按钮名称的显示方式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afn"><img src="../Images/74c35930d13cf999263e44eed7fbedcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOl6tjM--6XCFbbKCmjXvQ.png"/></div></div></figure><p id="8789" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于其他设置，如选择按钮样式，我们使用道具。</p><p id="bc78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按钮名称也可以使用道具来设置。使用slot更好，因为它保持了与本机按钮标记相同的语法。用户没有学习成本。</p><p id="b52b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们回到我们的Vue计划。</p><p id="09b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到子模板，在H3标签下安装插槽组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afo"><img src="../Images/a1ec9476cecb6ddefd907450c28496e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9H07YB8ko81lnG0-zGomSA.png"/></div></div></figure><p id="d637" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="3409" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到message属性显示在子组件中。它从子组件继承了CSS样式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afp"><img src="../Images/356bc4a3cf97a07785e8bbe644b16c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rtMVm08DAzXNt_9H93zRQ.png"/></div></div></figure><p id="e2ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息属性本身仍然属于根组件。我们可以通过根组件实例重置它的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afq"><img src="../Images/a5dc1d36e58dae9401bb23d3995d8ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKglpqwqsMHKTKa5VgFmXw.png"/></div></div></figure><p id="b8a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以添加几个插槽组件。</p><p id="23da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个slot组件都独立工作，并显示嵌套在子组件标记中的元素的副本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afr"><img src="../Images/691c390e3510899c99d9d0ccaaa34a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRJmkB37qhwZt58nNRLoKg.png"/></div></div></figure><p id="d107" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，您可以在子组件标记之间设置多个元素。它们都将被发送到插槽组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeo"><img src="../Images/456323408161281acd6dba7a5c830cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXv5cqMyrJYMRWEvfLWg9A.png"/></div></div></figure><p id="533a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，我们希望将选定的元素发送到选定的插槽。这要求我们能够区分插槽。解决方案就是<em class="np">名</em>道具。我们将它添加到插槽标签中。</p><p id="c16f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们命名第一个吃角子老虎城市。没有名称prop的插槽将被视为默认插槽。它作为一个安全网，接收没有分配插槽的元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ts"><img src="../Images/a5a2d09b8215868f366009655d87220c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SOVDw9D1vOCS_YOuANBVw.png"/></div></div></figure><p id="076a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将B标签分配给city插槽。</p><p id="1ce8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue 3中的语法发生了变化，变得更加完整。为了将B标签发送到city插槽中，我们首先添加一个模板标签，并将B标签放入其中。</p><p id="4cf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">模板标签有一个v slot指令。我们使用指令参数指定插槽名称。注意这里，我们使用的是指令参数，而不是指令值。指令值有不同的使命。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aex"><img src="../Images/a4608424797af0219535625daecb30d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1yoCTH01BNJ-HPxvV0BHg.png"/></div></div></figure><p id="0386" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，包装在城市模板标记中的元素将全部被发送到城市槽。</p><p id="37c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其余元素将被发送到默认插槽。</p><p id="60ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="ac92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市属性已被分配给城市插槽。消息属性没有指定的槽。它已被发送到默认插槽。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qk"><img src="../Images/5b77473e3658a9fad6873e388899ff3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aU9Da_s6KwLCXqVXCMLYFw.png"/></div></div></figure><p id="13f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们在city模板标签下添加一个span标签。</p><p id="785b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此span标签也将被发送到默认插槽，显示在iTag后面。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afs"><img src="../Images/c16915cf544877876930b27f45949d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uytQLrBs13JiCV1ZhfYGrQ.png"/></div></div></figure><p id="5b8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用模板标签将元素分配给缺省槽。只需将v slot的参数设置为<em class="np">默认</em>即可。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aft"><img src="../Images/556ad3fd4511c5ad431690f2a6d6d975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzEQYrEBz3njRtKn5lNPlA.png"/></div></div></figure><p id="9e75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦将模板标签分配给默认槽，就不能有任何松散的元素。松散元素是那些放置在任何模板标签之外的元素。它们不会被渲染，并且会导致警告。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/97f73a77839acc49d4d90a4ea88fb329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnXw7b4usZ-ilSNztKDWTw.png"/></div></div></figure><p id="3fc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要禁用iTag或者将它移动到一个模板标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uo"><img src="../Images/cd59118c933837d20fbb71b06080cd57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AL-CaQIrfVXEa4g_9ukDg.png"/></div></div></figure><p id="5f62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">槽元件不能与参照一起使用。如果我们给它一个ref，并试图访问它，我们会得到undefined。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afu"><img src="../Images/b0d08a12538916b85c3e321c6f1e36e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ytvALp5ekxGHL9a2pWpeiQ.png"/></div></div></figure><p id="7717" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件实例有一个专用的属性来管理插槽。它的名字是$slots。它的值是一个代理对象。</p><p id="d690" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个插槽在代理对象中都有一个代表性的方法。方法名与插槽名相同。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qv"><img src="../Images/346874f9bde3265ff0a2cd5c263c696a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioAY-708dURXSFQ7AnqqBQ.png"/></div></div></figure><p id="c45b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">v slot指令使用其参数指定目标插槽。那么我们能用它的价值做什么呢？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qh"><img src="../Images/1e943f3edc810499efad3950c3ebf529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXZ20DFVIM-NJD2f3uIxFQ.png"/></div></div></figure><p id="6ed7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件有一个名为nation的数据属性。让我们说，要显示它背后的城市财产。这意味着我们需要将数据从子组件发送到属于父组件的城市模板中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afv"><img src="../Images/7cab6128e509093306c18faff55b15a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HwgPz0pJbY7hWlAQF9qHw.png"/></div></div></figure><p id="b891" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市模板通过v slot指令的参数连接到城市插槽。</p><p id="8f51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">city slot组件属于子组件，因此可以访问nation属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afw"><img src="../Images/6debf19ce72f8083f727b70ba18111a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdXqWBFu62Sq_GDXNEsBaQ.png"/></div></div></figure><p id="be38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在slot标签中，我们声明了一个名为nationProp的道具。我们把国家财产分配给它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afx"><img src="../Images/588364133ead971238a4212a833e550f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aIdikYNHFFbgM1W3ZtP2mg.png"/></div></div></figure><p id="788a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市槽的道具将作为指令值发送给v槽指令。一个slot组件可以有几个props，所以v slot指令将接收一个对象，在其中存储所有的props。我们可以给物体命名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afy"><img src="../Images/59218e394418c12ee69f6a790682dff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPFea91BapPeecX8jsB65A.png"/></div></div></figure><p id="ea2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们将数据从子组件发送到插槽模板的方式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afz"><img src="../Images/0aef92cdcd9e81b771b2821031ce0a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqatyWnoMtPGl5CdbG3mog.png"/></div></div></figure><p id="d1b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">道具是反应性的。如果我们更改nation属性的值，子模板将相应地更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sh"><img src="../Images/69cad31e5ddf212b8454256daf75c2f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iijA3gLWfpU0GKSTptEkIA.png"/></div></div></figure><p id="175d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当设置v slot指令的值时，我们可以使用析构赋值。这样，我们可以直接在模板中使用道具名称。不再需要前缀。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ael"><img src="../Images/2711d136cb4b4003a0ab83bc3f0befbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqM_o2q7dGcGncSaW4ul7A.png"/></div></div></figure><p id="22b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">插槽是独立的。他们不会互相干扰，这意味着他们不会分享道具。</p><p id="d633" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让默认的slot模板访问nation属性，我们需要在默认的slot标签中设置一个prop，并为它分配nation属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aga"><img src="../Images/de3e97fcf2e1ac4d48f4a8d45cca6f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyStCOqVSrOlozWzo_KtdA.png"/></div></div></figure><p id="a2e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在后面的课程中，我们将学习如何手动呈现作用域槽。到那时，您将对作用域插槽的工作方式有更深的理解。现在，只要记住语法。</p><p id="2fc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个根组件。它有一个子组件。</p><p id="9f0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根组件通过mount方法安装。我们选择一个DIV并将根组件安装到它上面。</p><p id="703a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在当前程序中，根组件被挂载到VueApp DIV。这意味着整个Vue程序只控制VueApp分区。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agb"><img src="../Images/536650bc7ce66cf0893aaf68fb142321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-pLiHXoHnYQv3uOeAo5Dmg.png"/></div></div></figure><p id="b72f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于VueApp DIV之外的元素，Vue程序无法控制它们，因为它们不在Vue程序的管辖范围内。</p><p id="f127" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时候，我们的Vue计划需要打破这个限制，在VueApp DIV之外设立一个‘海外分支’。</p><p id="dc22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们需要创建一个通知横幅或模态。横幅需要和浏览器窗口一样宽。最佳解决方案是将横幅的外部DIV设置为body标记的直接子元素。这样，横幅的外部DIV可以继承body标记的宽度。我们不需要手动设置它的大小。</p><p id="0c8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题是通知DIV被放在Vue程序的根DIV之外。Vue无法控制它。</p><p id="09ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个问题可以用传送组件来解决。</p><p id="71d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Teleport是一个内置组件，它使Vue组件能够将其自己的页面元素从其模板外部DIV发送到指定的页面元素中。</p><p id="90a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指定的页面元素被称为传送目标，应该位于组件的模板外部DIV之外，最好是在Vue程序的根DIV之外。</p><p id="3510" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在当前示例中，teleport组件安装在根组件中，因此它的目标应该只来自VueApp DIV之外。</p><p id="b1dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件不能访问其父模板。它可以使用传送组件将自己的页面元素发送到父模板中。但不建议这样做。最好只使用teleport来访问整个Vue程序的根DIV之外的元素。</p><p id="7bc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们选择通知DIV作为传送目标。我们使用元素ID将<em class="np">设置为</em>属性的值。您也可以使用类名或标记名。所有嵌套在teleport标签中的元素都将被发送到notification DIV中，放在它的原始元素后面。</p><p id="5080" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建一个P标签。这个P标签仍然属于根组件的模板。因此，它可以访问根组件实例。我们在P标记中显示根消息属性。</p><p id="d037" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aej"><img src="../Images/3c664c7b9d06c7aeeb64f014fc185ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_atPWwkSvfoTNTBWsGGgyg.png"/></div></div></figure><p id="3785" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到通知DIV现在有两个P标签。消息P标签放在原始P标签的后面。</p><p id="a553" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息属性仍然是反应性的，我们可以通过根组件实例修改它的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agc"><img src="../Images/bf2779a11f1925f920ea0b5b83123228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrSb6GxPMD_mI7ufPKYflA.png"/></div></div></figure><p id="fb83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的实际项目中，我们通常将通知DIV留空，并将其用作锚点。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aej"><img src="../Images/a3be169014e1bb4e45dfe11d57fb9ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoDDaAe3tgBeFs_3lUN2ww.png"/></div></div></figure><p id="8e7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件中，我们声明了一个名为<em class="np">显示</em>的新数据属性。我们将其值设置为false。</p><p id="0764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在P标签中，我们添加V IF指令，并给它分配<em class="np">显示</em>属性。</p><p id="c8d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在transport标签下面，我们添加了一个按钮来反转display属性的值。</p><p id="5557" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们能够挂载和卸载位于Vue程序的根DIV之外的横幅。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agd"><img src="../Images/d09c1cb817c7282332e3d15d305a03bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8XWqLVWCYv5T_bfi-wZ0g.png"/></div></div></figure><p id="b249" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你也可以“传送”子组件。</p><p id="ae67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您的通知横幅或模式具有相对复杂的设计，您可以使用组件来创建它。</p><p id="3c4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">传送目标只能从位于安装传送组件的组件的根DIV之外的页面元素中选择。最好的选择是只选择整个Vue程序的根DIV之外的元素。</p><p id="99f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，传送组件由根组件使用，如果我们将它移动到VueApp DIV中，我们的程序可能无法工作。</p><p id="0459" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们得到了警告。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi age"><img src="../Images/3696a96ab5a29bf8fc79dca66c2aa79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-89pxZFyRF-rwIYUqtrEQ.png"/></div></div></figure><p id="afc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">传送目标必须在使用传送组件的Vue组件挂载之前存在。否则，传送组件将试图找到一个尚未创建的元素。</p><p id="9c9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue根DIV之外的元素总是在any Vue组件之前呈现。所以我们不会有这样的问题。</p><p id="4911" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue 3使得根DIV对于子组件模板是可选的。放置在根DIV之外的元素称为片段。在实际项目中，最好避免组件设计中的碎片。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agf"><img src="../Images/7cc6f422a3da56a47c338588e283f122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rko7XDX-MDod33Q-o-9jdw.png"/></div></div></figure><p id="35b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开一个组件实例，你会发现一个名为$attributes的属性。</p><p id="9c6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的值是一个代理对象。这个对象是组件存储通过组件标签从父组件继承的非属性的地方。非属性也是反应性的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agg"><img src="../Images/63b5598e8e3ec0d3d246b99a6fa7ea59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GWEHzGLcN-W2YuCpG9K4Q.png"/></div></div></figure><p id="0d2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么什么是非道具属性呢？</p><p id="f068" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们把子组件标签看成一个普通的HTML标签，我们在里面设置的道具只是HTML属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xz"><img src="../Images/bd9296b7844bf063cc0b42dc36269b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7s_3KD-fHKEdMMKM6iZYw.png"/></div></div></figure><p id="7ba0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了道具，我们还可以设置原生HTML属性。例如，我们将class属性从子组件的根DIV移动到子组件标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/23fbdea03ca43a727753f52f2b30db7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3g-NswCBzz10tK3hSq8yJg.png"/></div></div></figure><p id="ad0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">class属性将由子组件的根DIV继承。</p><p id="4bee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到程序看起来和以前一样。</p><p id="deca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件的根DIV已收到class属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeb"><img src="../Images/3a08068bd179c8a0d2e284f1662c4755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wd9-rkprRhvbCEtOikNdfA.png"/></div></div></figure><p id="ff22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们检查子组件的实例对象。</p><p id="f7ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们打开美元符号属性属性。它的值是一个代理对象。</p><p id="2077" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开它，我们可以找到类属性。它的值是类名<em class="np"> childOne </em>。所有非属性及其值都存储在这里。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agh"><img src="../Images/5b39da82b12440dbfd8e894bfde6701e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Wx6fHrKoEzg1MUFOOCWqA.png"/></div></div></figure><p id="c82e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">美元符号属性对象的属性是只读的。不要通过组件实例重置它们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aby"><img src="../Images/69b9cb949365dac7d170c9b9b94c3af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ar7yUEtpY9hw6dBMfnE8ZQ.png"/></div></div></figure><p id="af97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件标签中，我们可以使用v bind指令为class属性设置一个动态值。</p><p id="497b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用className属性设置指令值。</p><p id="8b40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们定义className属性，并将其值设置为childOne。</p><p id="57e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afz"><img src="../Images/228d9432d608b89c56b15647ef8a190a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a2z2oYoXexRkG8WBOmBQTg.png"/></div></div></figure><p id="5234" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">程序看起来和以前一样。已成功应用childOne类。</p><p id="64df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将className属性的值重置为classTwo。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agi"><img src="../Images/3f466d425a08f44cfe7da78d6c988433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZE7LN520NathlOQPpkSpg.png"/></div></div></figure><p id="4bda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到子组件接受了新的样式。</p><p id="a09b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">childTwo类已应用于它。</p><p id="34a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们尝试另一个原生HTML属性:title。</p><p id="b140" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为它设置了一个动态值。</p><p id="9f16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件中，我们添加了一个名为<em class="np"> title </em>的新数据属性。</p><p id="cf24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，title属性将被子组件的根DIV继承。它的值来自title属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agj"><img src="../Images/c2e54d3d051b1d79d655cd55a92f7b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzK5eZk_zu__TUvvQ0DvWg.png"/></div></div></figure><p id="3846" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有子根DIV可以从子组件标记继承非属性。嵌套在其中的元素不会。这就是Vue 2要求每个子组件模板必须有一个根DIV的原因。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agk"><img src="../Images/d492a9d730a17cef0c96772ada46fe8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHz7VHCC96z8VlbjFdse1Q.png"/></div></div></figure><p id="a59a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子根DIV中，让我们设置一个tittle属性。让我们看看将使用哪个标题值。</p><p id="125d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到从子组件标签继承的标题值具有更高的优先级。它覆盖子组件的根DIV中的那个。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agk"><img src="../Images/ac43bffacfa360f769cc3e803e501b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBd8poVDGtM26GC8a101kQ.png"/></div></div></figure><p id="ec0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们恢复P标签。现在子模板不再有根DIV。它如何决定哪个元素获得哪个非属性？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agl"><img src="../Images/94a75028ca5f353a66a0399375e49f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfcF2rBlkxnf0MDs_JEdlQ.png"/></div></div></figure><p id="99b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序，看看会发生什么。</p><p id="5c07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到所有非属性都丢失了。子模板中没有元素继承任何非属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agm"><img src="../Images/a226061a8eac8a47c647dfdedf68efdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwyR_3o_ekilZhTb9RyYDQ.png"/></div></div></figure><p id="00b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也得到了警告。它说非prop属性不能被自动继承，因为有fragment元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agn"><img src="../Images/7fe9867f4c7f91e1718aaaaa40885bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9GYqJ70odJ14DU6Qm7jxw.png"/></div></div></figure><p id="34d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果子模板有片段元素，我们需要手动分配非属性。</p><p id="b274" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们转到子组件实例来关闭自动继承。</p><p id="2f75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加inheritAttribute选项，并将其值设置为false。子组件标签中设置的所有非属性都将被忽略。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ago"><img src="../Images/010cf7c46b7e717c20d7a9ba00b1c89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDQ8NhqBZWAraFm-rP-7Fw.png"/></div></div></figure><p id="bbc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="72c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到警告消失了。子组件中的任何元素都没有继承任何非属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agp"><img src="../Images/d168a42e54e62a05b6cb4d4bcc258cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fW9qG2NjiA_gc_1fQVz7zQ.png"/></div></div></figure><p id="f966" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像我们之前展示的那样，所有非属性都存储在美元符号属性对象中。我们只需要从$attributes对象中选择属性，并将它们分配给我们选择的元素。</p><p id="e9c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们给外部DIV一个class属性。我们绑定了class属性，并将其值设置为美元符号属性。</p><p id="126c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，childOne类已经应用于外部DIV。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agq"><img src="../Images/a9905990ddd3f7a0ce14757e74fdcfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7xmWzX7ATJJlD_f1i7I5w.png"/></div></div></figure><p id="bce2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在P标签中，我们绑定了title属性，并将其值设置为美元符号属性dot title。</p><p id="1937" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，title属性已经添加到P标记中。P标记也是唯一获得title属性的元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agr"><img src="../Images/a6a269478dae26cefeae8a0e3ca6dba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pj0FnMvn_loewDYJSIcAg.png"/></div></div></figure><p id="a24e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不同元素可以继承相同的非属性。我们可以给H3标签赋予标题属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ags"><img src="../Images/23283beb704985ebed8261de8c5c4e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmVPW8D_DJxyCM4mDy0nIA.png"/></div></div></figure><p id="cf73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将学习如何动态安装和移除组件。</p><p id="a1c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们选择主DIV作为挂载点。</p><p id="a39e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还准备了一系列组件。我们一次只安装一个组件，由用户决定安装哪个组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agt"><img src="../Images/12e774e346ae703c4513503507d48c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oaQ3GUc32QwUORQAdnrO9Q.png"/></div></div></figure><p id="b0a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有两种解决方案:Vue路由器和动态组件。</p><p id="7655" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于更简单的项目，动态组件是更好的解决方案。</p><p id="56cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了创建挂载点，我们需要组件标签。它有一个决定安装哪个组件的属性。通过改变IS prop的值，我们可以向用户呈现不同的组件。IS prop的值是子组件标记的名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qx"><img src="../Images/e1acbc22fc8074aa3b6fa0cb5571d78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--9QsfunHL3gi5gyfTgbBQ.png"/></div></div></figure><p id="6dab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试动态组件。</p><p id="fc92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有三个组件:一个根组件和两个子组件。这两个子组件被命名为C1和C2。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yk"><img src="../Images/b533a15b028fddef6761dcae9dd63288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyjcH7EFDBA_sh_oGfe5Kw.png"/></div></div></figure><p id="8d37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们一次只需要呈现一个子组件，我们希望用户能够从两个子组件中进行选择。</p><p id="2e26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先删除两个子组件标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agu"><img src="../Images/1804f11a629717ef6af0870ea13e91b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UA-PXTaD7Koz0kScWz7wfQ.png"/></div></div></figure><p id="60b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们添加组件标签。它的位置决定了C1和C2的安装位置。</p><p id="ac29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用IS prop，我们选择想要安装的组件。IS prop的值是组件方法的第一个参数值。在这里，我们将其设置为C1。</p><p id="dc5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到子组件C1已经安装。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abj"><img src="../Images/d4d7db8ce2cfeed00c077dd4af68ac0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Sbfak5_dJopk26j2vbzaA.png"/></div></div></figure><p id="9479" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过改变IS prop的值，我们可以切换组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agv"><img src="../Images/dc5feace5d6a3d27c64578917f00d942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdZlK4C0-r1Qcg7h8ILRdw.png"/></div></div></figure><p id="0aad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件标签的工作方式与普通的子组件标签相同。您可以在其中设置道具、非道具属性和自定义事件。它们的行为与普通子组件标签中的行为相同。</p><p id="bc35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以设置ref属性来访问挂载的子组件的实例对象。</p><p id="6608" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，C2已安装完毕。ref属性返回给我们C2的实例对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yo"><img src="../Images/5da8fd22d39ea0da5639ca5c56b68519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1qZWJU7Yffet-4QsnaLlA.png"/></div></div></figure><p id="db8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过给IS prop分配一个动态值，我们可以控制子组件的安装和移除。</p><p id="45da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们v bind IS prop并将其值设置为cName。</p><p id="c568" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们转到数据选项来定义cName属性。我们将其价值设定为C1。</p><p id="8de6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">C1现在是默认的子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yk"><img src="../Images/20ae650918238ae65a56beda74e40c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSVsptVuuPVAP6C7gH3paA.png"/></div></div></figure><p id="89d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加一个按钮，并将其命名为C1。我们监控点击事件，并将cName属性的值设置为C1。</p><p id="d1c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们复制C1按钮，将C1改为C2。</p><p id="f4fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，通过点击这两个按钮，我们可以切换C1和C2。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ww"><img src="../Images/ba2b3fbfda004cffa0266d0ab5f0e2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oP_yZl8mobcW7W0cGYQ5gw.png"/></div></div></figure><p id="8e9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们来看看动态组件的生命周期。</p><p id="2721" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件C1中，我们添加了三个钩子:已创建的、已挂载的和未计数的。</p><p id="c89f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们把这三个钩子复制到组件C2。</p><p id="5fe6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="a3a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">C1已经建立和安装。还不需要C2，所以不会创建它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agw"><img src="../Images/c3991b335f4deaa76d6a06056cdd2548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjKaJn19nFS2N9gJzON5JA.png"/></div></div></figure><p id="bb88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们点击C2按钮后，C2将首先被创建。然后C1将被卸下，为C2腾出空间。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xp"><img src="../Images/1cb7c4f3ceb4bdfb762fba0b652b6ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64N--hhJnkXQZzl4frCj4A.png"/></div></div></figure><p id="49f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次我们切换组件时，当前组件都会被卸载。将从头开始创建新的组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agx"><img src="../Images/75c9c9df35e283f2405f6098cbb1611c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmfmeKVCqcZykAeYZxSSkg.png"/></div></div></figure><p id="ce29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，我们需要刷新页面，这意味着我们需要Vue来重新创建和重新挂载当前组件。这可以使用key属性来完成。</p><p id="e4d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件标签中，我们添加了key属性。当键属性的值改变时，当前组件将被重新装载。</p><p id="7045" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用refresh属性设置title属性的值。</p><p id="d638" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们转到数据选项来定义刷新属性。我们将它的值设为1。您可以使用其他值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abh"><img src="../Images/f020d993ab5bd0f67bba3ec33e9c4138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAKLV_rMcy2bzZhatSRwQA.png"/></div></div></figure><p id="b0c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将刷新属性的值更改为2。</p><p id="d110" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到C1又被创造了。然后卸载当前的C1实例，创建并装载新的C1实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uv"><img src="../Images/f794ba740c6678ed6aca361598d6b77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjmMAs1m0FdAGIl-zjdJWw.png"/></div></div></figure><p id="aa9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，组件C1正在展出。我们可以通过ref属性访问它的实例对象。</p><p id="151b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给title属性分配一个新值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agy"><img src="../Images/d0202230cfbdaef18c89b98f47064462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZrlLzfUIo7gowQ2Cg1DLw.png"/></div></div></figure><p id="3ac7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们单击C2按钮切换到组件C2。</p><p id="5039" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们单击C1按钮切换回组件C1。</p><p id="c615" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到C1的称号又回到了它原来的价值。我们在切换到C2之前设置的新标题值不见了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wx"><img src="../Images/262b8d3f3c2b93f2ddb48b3da2a7fd22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4raqAVf2E2LTD2pmVIcLA.png"/></div></div></figure><p id="388b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们单击C2按钮时，C1的当前实例对象被卸载。与根组件实例不同，C1组件实例的内存地址不存储在任何变量或对象属性中。JS垃圾收集系统将销毁C1的实例对象。</p><p id="bdc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们单击C1按钮时，将会创建并挂载一个新的C1实例对象。这就是title属性保持原始值的原因。</p><p id="e8f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用keepAlive组件，我们可以保留和重用组件实例。我们只需要将组件标记包装在keepAlive标记中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agz"><img src="../Images/8438f5684a6e2c65994062c93b594e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvI1eNBLSVrVZPv0x6yinQ.png"/></div></div></figure><p id="b4ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="858b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们点击C2按钮。</p><p id="2d51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到一个警告和一个错误。C2也没能上马。</p><p id="58c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该问题是由使用固定值的key属性引起的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aha"><img src="../Images/a542db0dd10526e202989f0b1f4524e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uo9CxOrSWv8wAzokFBx_Jw.png"/></div></div></figure><p id="ca85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在添加keepAlive组件之前，在创建新的组件实例之前，将销毁未安装的组件实例。因此，新的组件实例可以重用以前的键。</p><p id="364c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经添加了keepAlive组件，卸载的组件实例仍然存在于内存中。自然，新的组件实例不能使用以前的键值。</p><p id="d523" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们得到警告和错误消息的原因。新组件也未能安装。</p><p id="1ccf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我们只需要确保每次切换到新组件时键值都会改变。最简单的解决方案是将组件名合并到键属性的值中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ca"><img src="../Images/7eb09d70523bb5eebce1e431aa75b12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXQHzo79b41b1RmCNWbAOA.png"/></div></div></figure><p id="2350" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="1337" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题已经解决了。我们可以通过点击这两个按钮来切换组件。</p><p id="bcee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件C1和C2将只创建和挂载一次。</p><p id="f6e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">卸载的挂钩从未被触发。这意味着没有组件实例被销毁。C1和C2都活在人们的记忆中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahb"><img src="../Images/5474f904948841a3c3544cb8f65808c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqBBUhBYpKiG4WZeU2Fe-A.png"/></div></div></figure><p id="4081" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们证明这一点。</p><p id="4c72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，C1正在展出。我们将其title属性的值重置为apple。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/b9836294fd43db942f3532061183fa74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuMejseCy1YnU__6qH5a-Q.png"/></div></div></figure><p id="2cc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转到C2。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/26c9e1ceaacdd572877a132488c9d4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsowclUZXutXEJyXYLPbRA.png"/></div></div></figure><p id="0f23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转回C1。</p><p id="dd52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到标题值仍然是苹果。这证明了C1的原始实例对象从未被破坏，并且在我们切换回C1时被重用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agg"><img src="../Images/02875fab2f0375cd89a9f12781521dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCJys-3hBei7O1-8XXhsvg.png"/></div></div></figure><p id="55ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在keep-alive组件中，我们可以使用激活的和停用的钩子来替换beforeUnmount和Unmount钩子。</p><p id="636b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们在C1和C2之间切换时，这两个活跃的钩子将被触发，但它们不会在服务器端渲染时被触发。</p><p id="1e8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到每次切换组件时，旧组件的停用钩子和新组件的激活钩子都会被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aca"><img src="../Images/a1d4c3b68bb02807e72b4a9aad4bd41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVLvY0emuWg5YL6TfZC94Q.png"/></div></div></figure><p id="e78d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们移动到一个新文件。</p><p id="9193" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经创建了四个子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acf"><img src="../Images/9af96abfd96d5c3fdb79d5bc42c06729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLicnOWlYdSqKTu_phdqGg.png"/></div></div></figure><p id="4a0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将组件标记包装在keepAlive标记中。现在，所有卸载的组件实例都将保存在内存中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahc"><img src="../Images/3431d59b48c0587e0bcc47eeeadb1ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iouzCN2fDm4XhTrkscteFw.png"/></div></div></figure><p id="5b92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们有很多组件，保存它们会是一个很大的负担。使用max属性，我们可以限制保存的动态组件实例的数量。</p><p id="61dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将最大值设置为2。现在，内存中最多会保存两个动态组件实例。包括当前安装的组件实例。这意味着将只保存最后一个卸载的组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xy"><img src="../Images/84bd3715ec6279098a4d125b70c85566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYgeiVWYzI2giCdOBv2oHw.png"/></div></div></figure><p id="0830" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们刷新页面。目前，只有C1已经建立。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahd"><img src="../Images/05658a3276fd1c98d85e0402a4772938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-z6h8BjMHy5YBYhgXCFfQ.png"/></div></div></figure><p id="0142" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到C2。</p><p id="6a8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经创建了两个组件实例:C1和C2。它们都保存在内存中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahe"><img src="../Images/e6197bab97bbc07a3b1fcea2edace42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tpquMYOO3KGNIux8zbXzg.png"/></div></div></figure><p id="8889" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们切换到C3，我们将创建另一个组件实例。结果，C1将被挤出队列，因为max属性要求最多只能保存两个组件实例。</p><p id="f3e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到C1已经卸载。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/b3a21ef0235dee597e1630e1dd6cc6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HvOcNvdstvRs71Ap7tFnQ.png"/></div></div></figure><p id="6612" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们转向C4，C2将被挤出队列。只有C3和C4会留在记忆中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahf"><img src="../Images/96f0762446a9ccae26035d0cbbedee64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kowoc4eceRQiSN0Vw7JLJQ.png"/></div></div></figure><p id="b5bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们切换回C1，C3将被挤出。记忆中只有C1和C4还活着。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahg"><img src="../Images/a67ac69307e0e51bb32350d8a6e381f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiHIsi_swBhVEA8ggHIfIQ.png"/></div></div></figure><p id="cb89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在任何时候，只有当前组件和它的前一个组件会被保存在内存中。</p><p id="507d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，max属性遵循FIFO规则:先进先出。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tt"><img src="../Images/e15634b67ff171fa1f84f33ca0eec0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hi4dKn3RG-uYpqbaZS6BdA.png"/></div></div></figure><p id="3b11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用include属性，我们可以指定想要保存的组件。</p><p id="2746" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们拯救了C1和C3。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahh"><img src="../Images/e5e19eb71b9c1d0a620cfea3c3e290cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylH_82FAwwgsEUVC4pKFWA.png"/></div></div></figure><p id="9adb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">似乎include属性不起作用。C1和C3已经被卸载。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zy"><img src="../Images/48bf57475ed9f25459a5786475dbc5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MickD2y8cezZdH6-JIMxA.png"/></div></div></figure><p id="f9c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">include属性基于组件实例的名称选项来区分组件实例，而不是基于组件方法中设置的组件标记名称。</p><p id="3768" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要为每个子组件设置名称选项。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zk"><img src="../Images/211b7f7dd1f9d30d219a731dcd85c40e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzIEK1QFgFxyywDhv1tJaA.png"/></div></div></figure><p id="f103" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，include属性可以工作了。它将拯救C1和C3。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agy"><img src="../Images/b7569ee25dcca87ba096046764252821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRdnnsEfYv5nQLjpKXFCoA.png"/></div></div></figure><p id="9a5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用exclude属性，我们可以指定不想保存的组件。exclude属性仍然只适用于name选项。</p><p id="5750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将向您展示如何一起使用指令和子组件的v。</p><p id="fb5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件中，我们有一个名为list的数据属性。它的值是一个数组。每个元素都是一个城市名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tb"><img src="../Images/b6d676ed774362b4c36745d03b642a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ougsa2nj2o_-YJUg1sog9g.png"/></div></div></figure><p id="a2a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用V FOR指令迭代数组。</p><p id="53f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们添加一个UL标签。</p><p id="0f0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在它里面，我们添加了李标签。LI标签是我们添加v for指令来遍历列表数组的地方。</p><p id="d258" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个Li标签都需要一个唯一的键值。通常，我们使用元素索引来设置键值。这是保证每个元素都有唯一键值的最简单的方法。</p><p id="8304" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经遍历了列表数组。每个元素都已输出。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahi"><img src="../Images/286e3bb9475861a665949ae78955ab94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36EOKBuO5_SkpT2P3qF3ag.png"/></div></div></figure><p id="1af8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们使用子组件显示每个元素。</p><p id="c796" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个子组件显示一个数组元素。所以v for指令应该安装在子组件标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vq"><img src="../Images/412a45cdcd988a23fad97fcf2743f097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AbPGQ6lhMCFLce7l3EM0jw.png"/></div></div></figure><p id="0e76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将元素值发送到子组件中，我们需要声明一个属性。我们把它命名为城市。</p><p id="7e37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件标记中，我们将数组元素分配给城市属性。</p><p id="c026" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经遍历了数组，并为每个数组元素安装了一个子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sg"><img src="../Images/79cc3cd74772ad1486eceed7524e1d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIaMGr8AuSXtq2DBHdRBNA.png"/></div></div></figure><p id="fa0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件中，我已经添加了卸载挂钩。当我们从列表数组中移除元素时，它将被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahi"><img src="../Images/fa3817d02e0d420e1b956aab5b55ea2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xjc1ssF9uTM82w8aJ-NtEQ.png"/></div></div></figure><p id="82cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从列表数组中移除最后一个元素。</p><p id="c188" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到卸载挂钩已经被触发了一次。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahj"><img src="../Images/843a7c130c62160ee7e01087c4d59c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNh4pfs06bs7qZf9gLNZQg.png"/></div></div></figure><p id="f23f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们改变一个元素的值，卸载钩子将不会被触发。Vue将在原始组件中显示新元素值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahk"><img src="../Images/a7cd43392e8416e6752c81a190fb2102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uH1R2nrVUKAN18OPXdoIJg.png"/></div></div></figure><p id="fe1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们一起使用元素索引和元素值来设置键属性的值。</p><p id="d5c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们改变元素值时，键值也会改变。因此，Vue将重新创建并重新安装显示修改元素的组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahl"><img src="../Images/6cee1591440105d6f0ec2562b84479a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lq8e0f8BmPx0iwZCtzTq-g.png"/></div></div></figure><p id="0c4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这节课开始，我们将向你展示如何在Vue程序中创建过渡和动画。</p><p id="b648" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仍然由原生CSS属性生成的过渡和动画。Vue只是帮助我们应用和删除那些属性。Vue也支持基于CSS或基于JS的第三方CSS库。</p><p id="d92d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将快速回顾三个CSS属性:过渡、变换和动画。我们将在以后的课程中用到它们。</p><p id="40ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我这里有一个DIV。它由一个名为<em class="np"> initialStyle </em>的类进行样式化。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afz"><img src="../Images/3ff213cb21d38b3b21ff91893c3625ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBbSBG0kuTKULe3t5_U2YA.png"/></div></div></figure><p id="017f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建另一个类，并将其命名为<em class="np"> newStyle </em>。</p><p id="0213" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新类设置了较小的宽度和高度以及不同的背景颜色。</p><p id="6771" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望新的类覆盖旧的类，所以一定要在前一个类的后面定义新的类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vg"><img src="../Images/59618ca7d6dcc64cc565f6ca5b51a270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-gvEHTXtA6EowYs2RMb6w.png"/></div></div></figure><p id="f97d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将新类应用于DIV。</p><p id="050b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用对象语法设置class属性。我们使用<em class="np">显示</em>属性来控制新类的应用。</p><p id="1696" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转到数据选项来定义<em class="np">显示</em>属性。我们将其值设置为false。</p><p id="f923" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在DIV的顶部，我们添加了一个按钮来反转<em class="np">显示</em>属性的值。</p><p id="a231" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，通过单击按钮，我们可以在DIV中添加和删除新类。因此，DIV将在新旧样式之间切换。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agi"><img src="../Images/8e441c0a7684b6e89998d56a6ea8690a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Bbv-cm4_NJbLowZYS4HFQ.png"/></div></div></figure><p id="2fb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，这两种风格之间没有过渡。DIV会立即从一种样式切换到另一种样式。</p><p id="0081" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在initialStyle类中，我们添加了<em class="np">转换</em>属性。它的值有三个部分。第一部分列出了我们想要转换的CSS属性。这里，我们把<em class="np"> all </em>放入所有CSS属性。</p><p id="06de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二部分设置过渡时间。我们把它设置为2秒。最后一个控制过渡过程。默认值为<em class="np">缓动</em>。过渡开始缓慢，然后快速进行，然后缓慢结束。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xs"><img src="../Images/ec3cb610a617808ab20069e83948e061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHq79Kz3didedZroyYUX-A.png"/></div></div></figure><p id="aecd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在单击按钮，DIV逐渐在两种样式之间转换。从一种风格到另一种风格只需要两秒钟。</p><p id="3941" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有个问题:过渡物业的位置有什么要求吗？如果我们把它移到newStyle类中会发生什么？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/b2137b38548d7f9e8ef155be38601f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oR4by1UjduIjhZlMPUvQZA.png"/></div></div></figure><p id="9227" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">DIV可以从初始样式转换到新样式。</p><p id="a845" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但它不会转变回来。它直接迎合了旧风格。</p><p id="7d08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原因是这两个类是如何设置的。</p><p id="3c5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> newStyle </em>类覆盖了<em class="np"> initialStyle </em>类。通过单击按钮，我们可以添加和删除newStyle类。然而，<em class="np"> initialStyle </em>类总是被绑定到DIV。</p><p id="f812" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们删除newStyle类时，其中定义的transition属性也消失了。DIV不再有任何过渡属性。因此，它将恢复到默认样式。当我们将newStyle类添加到DIV时，我们将只有过渡效果。</p><p id="bc49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们在<em class="np"> initialStyle </em>类中定义了<em class="np"> transition </em>属性，那么DIV将总是具有transition属性，因此可以在两种样式之间转换。</p><p id="8236" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设置转换属性的关键是确保<strong class="kd iu">总是</strong>应用于被转换的元素。</p><p id="acaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">变换</em>属性将2D或3D变换应用于元素。它允许我们移动、旋转、缩放等。，元素。</p><p id="3622" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一起使用<em class="np">变换</em>和<em class="np">过渡</em>属性，我们可以创建简单的双关键帧动画。</p><p id="cd9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认元素样式和位置设置开始关键帧。transform属性设置结束关键帧。使用transition属性，DIV从开始的关键帧过渡到结束的关键帧，从而生成动画。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agw"><img src="../Images/60bb920dca4abaccf0838b179baabe07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rb45_MBAMquO1Qslgv4mCA.png"/></div></div></figure><p id="4d0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">transform属性仅适用于块和内嵌块元素。它不适用于行内元素，因为行内元素没有自己的大小。</p><p id="b03f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，<em class="np">转换</em>属性应该永久绑定到被转换的元素。不要将它放入将被删除的类中。</p><p id="43b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">转换</em>属性仅适用于块和内嵌块元素。</p><p id="5550" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">过渡是一个元素从一种风格逐渐变为另一种风格的过程。这是一个双关键帧动画。</p><p id="74e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> initialStyle </em>类设置第一个关键帧。<em class="np"> newStyle </em>类设置第二个关键帧。</p><p id="37d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">transition属性使元素能够从一个关键帧过渡到另一个关键帧。它还控制过渡的持续时间。</p><p id="311e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">过渡属性的限制是我们只能从一个关键帧改变到另一个关键帧。如果我们想要设置更多的关键帧呢？</p><p id="7742" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们需要<em class="np">动画</em>属性。</p><p id="9aa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们禁用newStyle类。</p><p id="e869" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也不需要过渡属性。</p><p id="942c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了一个新的类。我们将其命名为<em class="np">动画</em>，并在其中设置了<em class="np">动画</em>属性。</p><p id="262d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动画属性要求我们至少设置两个值:动画名称和持续时间。动画名称实际上是一个类名。</p><p id="d9ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们定义动画类。</p><p id="cad8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用@keyframes作为类名的前缀。</p><p id="cec4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们设置了三个关键帧。0%表示动画的开始。50%表示动画的中间部分。100%表示动画结束。</p><p id="c276" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设置的关键帧越多，动画就越复杂和平滑。</p><p id="e018" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个关键帧中，我们没有对DIV进行任何更改。</p><p id="0e59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第二个关键帧中，我们将DIV分别向右和向下移动200个像素。然后我们把它旋转360度，放大50%。我们还将背景颜色改为红色。</p><p id="1596" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在结束的关键帧中，我们将DIV分别向右和向下移动200个像素。我们将DIV旋转另一整圈。我们将其大小和背景颜色设置为原始值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahm"><img src="../Images/c51d7cb1f8c6093b96b5c449e3d422b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3knbh4xd1kqTvUfL3iVyg.png"/></div></div></figure><p id="f6ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用animate类替换newStyle类。我们可以使用显示按钮来控制动画。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aei"><img src="../Images/68b0adffe7c2c55ed927e0ff55d96f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAnOgYWZJ-Lg24JxxsaNlw.png"/></div></div></figure><p id="677f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="5800" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经创建了一个三个关键帧的动画。DIV首先扩展，然后收缩回来。它的颜色从绿色变成红色，然后又变回绿色。动画一结束，DIV就会恢复到原来的样式。如果需要，您可以添加更多关键帧，以使动画DIV过渡回其原始样式。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aho ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/27005caefe1e5e5a4023a5a21ee75f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*l6s0r7vW-erGmf8rcUoing.png"/></div></figure><figure class="ahn ju aho ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/18b4ddfb92f57db8de71f6cbcc82eadd.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*tFTo3MGM54Dmi2HPfcY_7A.png"/></div></figure><figure class="ahn ju aht ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/448e5f6d0d35953caf731fd4e73866a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*4VLy-jX20nQ59NqLCTK3jQ.png"/></div></figure></div><p id="4043" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将向您展示如何使用Vue创建休假和进入过渡。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahu"><img src="../Images/f3a2eb714824aa59b295afbfafbac22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08j3NW1uBvCuLZZLM8DiOw.png"/></div></div></figure><p id="3404" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue为我们提供了两个内置组件来创建过渡。他们是过渡和过渡集团。我们将从过渡开始。TransitionGroup用于从动态生成的列表中转换项目。我们以后再处理。</p><p id="9d69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了定义自定义过渡效果，Vue提供了六个过渡类。在离开或进入转换期间，这六个类将在预定义的时间自动添加和删除。</p><p id="780d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">六个过渡类必须由我们来定义。因此，我们也为现有的转换类提供了9个挂钩点。这些挂钩点允许我们使用第三方动画库中的类。</p><p id="a967" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有十一个转换事件允许我们绑定十一个类型的钩子函数。这些事件允许我们使用基于JS的动画库。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahv"><img src="../Images/52b50871d5a86285a78aadd35f512402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QhTfPJlEzpQ7mJ6am_2t5Q.png"/></div></div></figure><p id="13ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们仔细看看过渡过程。</p><p id="4411" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们有一个页面元素。目前它在默认样式设置下正常显示。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ahw"><img src="../Images/4e9301af7068a30fc8bfdd8558584ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*u0NSl2H29atCCJX-JXCOKg.png"/></div></figure><p id="fcaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们将它转换出来。离开过渡包括将元素大小缩小到零，并使元素完全透明。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ahx"><img src="../Images/dfde0b4ffe90e606167724d32fa4ec53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CiDmynGZYbOx3P_kzacYQ.png"/></div></figure><p id="85dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们把元素转换回来。进入转换是离开转换的镜像。元素大小从零增长到默认大小。它的不透明度从0到100。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abn"><img src="../Images/da5f4e8abdafcdb42c77cbd4009b05c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tc1nvMC_WlyGYVwQVrxRwg.png"/></div></div></figure><p id="e051" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">enter转换结束后，该元素将返回到默认样式下的正常显示中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahy"><img src="../Images/0af3e03379b6a7a401432bd5e1370993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*se5aEHxg6ApXwQhO7YAYPw.png"/></div></div></figure><p id="ccaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在整个过程中，默认样式一直应用于元素。进入和离开过渡由覆盖默认元素样式的过渡类创建。Vue保证在被转换元素的默认样式后面定义六个转换类，这样它们可以覆盖默认样式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xl"><img src="../Images/70c03840139c9eb3a57e31fa487a59e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qw11D_FdsinnGgo-1QU1iw.png"/></div></div></figure><p id="ebc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，我们可以绘制四个关键帧:离开和进入过渡的开始和结束。Vue为四个关键帧中的每一个都提供了一个专用类。它们是leaveFrom、leaveTo、enterFrom和enterTo。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahz"><img src="../Images/20d23781e8520fb34d38db7b300ebc4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQ2SMIYPy-Y4E5RZPXbp5w.png"/></div></div></figure><p id="b81c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自类的两个<em class="np">定义开始关键帧，两个<em class="np">到</em>类定义结束关键帧。转换后的元素从</em>类的<em class="np">设置的样式变为<em class="np">到</em>类设置的样式。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi su"><img src="../Images/fce16d074f389e8e098714f158ed3a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5w8CbB1jld7eYNjqjrPbg.png"/></div></div></figure><p id="c124" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了管理过渡过程，Vue为我们提供了两个特殊的类:leaveActive和enterActive。这两个类是我们定义转换属性的地方。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sn"><img src="../Images/c1dc52dddd975813461957c8e966d07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJqwGMYa1lKdITfmTbuwdA.png"/></div></div></figure><p id="3b31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个活动类在整个转换过程中应用于转换后的元素，并将在转换结束后被移除。由于两个活动类中定义的转换属性，转换的元素可以逐渐从一种风格转换到另一种风格。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi su"><img src="../Images/886457e07347bd606b1dd6b82f932097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BWcSJF_RZlyai4HYY4zoA.png"/></div></div></figure><p id="86fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望元素平滑地过渡出来和过渡进去。<em class="np">在离开转场开始和进入转场结束时，转场元素看起来应该和正常显示时一样。</em>因此，leaveFrom类和enterTo类不应该对元素样式进行任何更改。这就是为什么我们通常不定义这两个类。Vue将在离开过渡开始和进入过渡结束时应用两个空的<strong class="kd iu">类。这样，转换后的元素可以进入它们的默认样式，也可以离开它们的默认样式。风格不会有什么突变。</strong></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acn"><img src="../Images/8f57254da8bd6c6380e7f4f96b21d733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXzY1rOL013FYdRgetJLyg.png"/></div></div></figure><p id="9bfb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在离开转换结束和进入转换开始时，转换的元素不可见。它的大小和不透明度都为零。因此，<em class="np">离开到</em>班和<em class="np">从</em>班进入是相同的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aia"><img src="../Images/73376ff65bbcd5b36f12bbe4cc56b463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RVycCrhnLKdwmrw4VnNImw.png"/></div></div></figure><p id="c4f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，我们希望离开转换和进入转换相互镜像。所以这两个活动类通常也是相同的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi su"><img src="../Images/eb58cc07356395c4193101fc63aa45da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyKILPo752rOlGHXlEV2RQ.png"/></div></div></figure><p id="9fc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，我们有六个转换类，但是通常我们只需要定义其中的四个。两个<em class="np">活动的</em>类通常是相同的，并且<em class="np">离开</em>和<em class="np">进入</em>类大部分时间是相同的。</p><p id="20a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以定义任意多的过渡效果。为了区分它们，转换类需要一个自定义前缀。自定义前缀通过<em class="np">名称</em>属性在转换组件中声明。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uw"><img src="../Images/78c9eef030e347b1611ee88b287cac76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0_vloVl-pPYBaBzENEzkQ.png"/></div></div></figure><p id="378d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试这六个过渡类。我还不会创建任何过渡效果，我将首先向您展示六个过渡类的添加和删除。</p><p id="dffc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个H1标签。我将<em class="np"> display </em>属性赋给了它的V IF指令。通过反转<em class="np">显示</em>属性的值，我们可以挂载和卸载H1标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aib"><img src="../Images/5a1778a1087d679816d054b1e812b563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CRLYXJyklKvaFJCmKZ6_w.png"/></div></div></figure><p id="03ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们将H1标签移动到转换组件中。</p><p id="3ac6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在过渡组件中，我们添加了<em class="np">名称</em>道具，并将其值设置为<em class="np">演示</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afc"><img src="../Images/70d9681cb2986378f0673666ec5e394d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGA2AZBDcAtlxEldidBIDw.png"/></div></div></figure><p id="61ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们定义六个过渡类。都需要加上前缀<em class="np"> demo </em>。</p><p id="d706" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在enterFrom类中，我们为H1标签设置了蓝色背景。</p><p id="1693" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在enterActive类中，我们添加了transition属性。我们选择所有CSS属性，并将持续时间设置为5秒。</p><p id="4d5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在enterTo类中，我们将背景色设置为绿色。</p><p id="353f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在leaveFrom类中，我们将背景色设置为黑色。</p><p id="3e0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">leaveActive类与enterActive类相同。</p><p id="4522" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在leaveTo类中，我们将背景颜色设置为黄色。</p><p id="5408" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过监视H1标签的颜色变化，我们可以知道何时添加和删除了一个转换类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adf"><img src="../Images/5a8fac969e3e1f5064d4a079c19dba0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZBcWX-b3-VlXMjElBmkNA.png"/></div></div></figure><p id="2b2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="a06c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我刷新页面。目前，H1标签在其默认样式下正常显示。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tu"><img src="../Images/a1e63066d883cbcba1b4658e591b9aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*bPBwQBaeNuAgWu_Sw2sSVQ.png"/></div></figure><p id="5013" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们单击按钮将H1标签移出。</p><p id="f89a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，当我点击按钮时，H1标签的背景色变成了黑色，这证明了<em class="np"> leaveFrom </em>类已经应用到了H1标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aic"><img src="../Images/7f369e36ee567f15ad58a04cf1acce41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*_ibcv1j_2wqg0VCMUGn8Vg.png"/></div></figure><p id="d23b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后逐渐变成黄色。这个过程需要5秒钟</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aid ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/5c74e1589a5d661b111870daf3fc3c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*MRaRY-RJNnVJdEYH3yHYEA.png"/></div></figure><figure class="ahn ju aie ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/f2e123f5bb103afb96af68305b7282fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*q1CpENnz5VhX_5-gtr6Cqg.png"/></div></figure></div><p id="4546" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当背景变成黄色时，H1标签就消失了。这证明了leaveTo类防御是leave过渡的结束关键帧。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aif ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/fad3f8cc0b70b01939c529550db9041c.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*q1CpENnz5VhX_5-gtr6Cqg.png"/></div></figure><figure class="ahn ju aig ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/47d9a4bd249594d45dc731d1663ac43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*gicQUWuvLE1TYspNw6b7xw.png"/></div></figure></div><p id="14ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> leaveActive </em>类使H1标签逐渐从<em class="np"> beforeLeave </em>类设置的样式变为<em class="np"> leaveTo </em>类设置的样式。在离开转换结束后，H1标签被卸载。</p><p id="573c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们尝试进入过渡。我再次单击按钮，将H1标签转换回来。</p><p id="61b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我点击按钮时，H1标签以蓝色背景出现。这证明了<em class="np"> beforeEnter </em>类已经应用于H1标签。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aih ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/0ba04f37400573c290acc9f0f5aca1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*gZIoNPyBLwyidbh6MVUBag.png"/></div></figure><figure class="ahn ju aii ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/c4d588b2266644d3ba99f0e6e0c14bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*hd6uw5RQrX5S1dSRog6PAQ.png"/></div></figure></div><p id="246e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后H1标签开始变绿。这个过程也需要五秒钟。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aij ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/8003134ff69618c9aa8d87752b4449dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*enfrgQPWfAs8MJqXG5x6Zg.png"/></div></figure><figure class="ahn ju aik ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/37d20f2736e5b72f929154c799e63da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*wPRxDE3wvki_1Bvpiri_Ew.png"/></div></figure></div><p id="3727" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当H1标签变成绿色时，它会恢复到默认样式。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju ail ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/13e38937fa1768934bc8dacf46e35f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*wPRxDE3wvki_1Bvpiri_Ew.png"/></div></figure><figure class="ahn ju aim ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/d19a607f6d611e5db20749eb7a1af93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*QXQSNvKRR8d6YdLhywuXNg.png"/></div></figure></div><p id="3dac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们打开源HTML代码，再次运行该文件。请注意将要添加到H1标签中的类。</p><p id="6a1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我单击display按钮时，H1的背景色变成黑色，并接收两个类:leaveActive和leaveTo。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ain"><img src="../Images/a22b57d669cb07cc56ad01fe2bcf8cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*0TGRn3FqlcYRudrgDUqZng.png"/></div></figure><p id="a055" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">休假过渡结束的那一刻，H1标签和两个休假类都消失了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aio"><img src="../Images/850c78b1f4596ca6fb300e707f22a979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*rv4LJFNt4-jbgKwJ8njcPg.png"/></div></figure><p id="3c5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们再次点击按钮。</p><p id="7952" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签立即以蓝色背景显示出来。它有两个类:enterActive和enterTo。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi zb"><img src="../Images/166b737968f14d511e0abd535a90666c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*fpKFl1IpRGyXTjIvlxmhhw.png"/></div></figure><p id="cd95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当回车键转换结束时，两个回车键类消失了，H1标签恢复到原来的样式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aip"><img src="../Images/e3ceb6a4138513a6d80944f458f22a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*h09Sx_rShYBOSoOZSnmGBA.png"/></div></figure><p id="80ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue所做的只是添加和删除预定义的时序转换类。我们负责将正确的CSS属性放在正确的转换类中。</p><p id="a4a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当过渡开始时，将应用来自类的<em class="np">。在转换过程中，<em class="np">活动的</em>和<em class="np">到</em>类被应用于被转换的元素。过渡一结束，<em class="np">激活的</em>和<em class="np">到</em>类将被立即移除。</em></p><p id="815f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，Vue将根据transition属性设置的持续时间来确定过渡持续时间。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vy"><img src="../Images/7e21be1582a340b2db62064f8b9630c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAAoJQ7rSZSOe2xtBlqFDA.png"/></div></div></figure><p id="97ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用持续时间属性，我们可以手动控制过渡持续时间。持续时间属性以毫秒为单位测量时间。在这里，我们将其设置为8000。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ug"><img src="../Images/ff5fead1ad94a8e44e6f7174a0916de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ExZ7UHkt1wmF0VLJm_3kg.png"/></div></div></figure><p id="a242" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CSS转场只持续5秒。这意味着<em class="np">活动的</em>类和<em class="np">到</em>类将被额外绑定到被转换的元素三秒钟。</p><p id="adb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="c6e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我点击按钮开始离开过渡。</p><p id="bfaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签的背景颜色已经是黄色，但是H1标签仍然显示。active和to类仍然绑定到H1标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sa"><img src="../Images/9699c9008571a0d4fbb6d70a50b71417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*j5arecktJUEYraWk0QZTRA.png"/></div></figure><p id="883c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">三秒钟后，H1的标签不见了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aiq"><img src="../Images/29f0f3636a78a9b8db4a8cb88cc3764f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*yJ4tIbN6r0Iyd4jfLaGTUw.png"/></div></figure><p id="6666" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再次点击按钮，我们将得到相同的结果。</p><p id="47d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签的背景颜色在五秒钟内从蓝色变成绿色。背景颜色将保持绿色三秒钟。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aiq"><img src="../Images/ce333130d91791ad4380ed4388a70de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*dnEn8lOyvipnTY_AvC9tBw.png"/></div></div></figure><p id="1c99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">三秒钟后，<em class="np">激活的</em>和<em class="np">到</em>类被移除。H1标签恢复到默认样式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi air"><img src="../Images/474dfa076c7409992bfc687766100c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*6x__UYAQV_c6dVwfGiAmoA.png"/></div></figure><p id="d922" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以为进入和离开转换设置不同的持续时间。</p><p id="2311" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用v bind指令绑定duration属性，并给它分配一个对象。</p><p id="5af6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该对象有两个属性:进入和离开。我们将输入设置为8000，将输出设置为80。duration属性的优先级高于CSS transition属性。这意味着进入过渡有足够的时间完成，但离开牵引没有足够的时间完成。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qh"><img src="../Images/2cbda940c6c8dfd8c46a4892bde55b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXP22Q37bSWf_POkedSGbw.png"/></div></div></figure><p id="fd21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们向您展示了Vue何时添加和删除过渡类。在本课中，我们将创建一个完整的过渡计划。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ais"><img src="../Images/580e519cedd584adb5e198e2e318875a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJguIIWZ7gtaZX1AD4qDtg.png"/></div></div></figure><p id="5b48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在enterFrom类中，我们将不透明度设置为零，并将缩放设置为零。</p><p id="1228" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们保持enterActive类不变。</p><p id="e8ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">enterTo和leaveFrom类应该为空。目前，我们出于演示目的保留它们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ait"><img src="../Images/6c3458ea79d542e143e8bc0467c3e69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eBpsvPAHsruqdJXGtRXwg.png"/></div></div></figure><p id="a792" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">leaveActive类与enterActive类相同。</p><p id="6569" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">leaveTo类与enterFrom类相同。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agn"><img src="../Images/ff53d23807fe8d8575000ee1b748e890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGPU8sGq_TAJqxzysUW3-Q.png"/></div></div></figure><p id="02f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们检查程序。</p><p id="c8ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我点击按钮时，H1标签的背景变成黑色。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ze"><img src="../Images/ad4afa00f8047d2e394ad43b0ad7ecf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*yWl5SBTSw9ifpcUl_kORqQ.png"/></div></figure><p id="666f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后它会缩小，变得更加透明，直到完全看不见。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aiu ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/e8dd8f34683ebb6138f0aabbe4b9c1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*YUEGgu2OEzhWyXgFLPM2nw.png"/></div></figure><figure class="ahn ju aiv ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/70d2f7375f47890a3cf611d8558c5360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*02_Ck-WfWYHPvkbqdgB4zg.png"/></div></figure></div><p id="790e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我再次点击按钮。</p><p id="ff98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签以其默认的背景颜色显示。随着它的扩大，它的背景逐渐变成绿色。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aiw ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/7d335fb76734624b8366a4de09dd9a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*fRHnjbKFGd9M_XP4qxS-4A.png"/></div></figure><figure class="ahn ju aix ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/e968ddf04edf6b48b36ae7a141b105b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*I4oivsGu3kVDYYnWG6tIhQ.png"/></div></figure></div><p id="e08b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当回车转换结束时，H1标签会马上回到默认的背景色。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aiy ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/fd0cba7fe109ac52cfcda3596ed15e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*I4oivsGu3kVDYYnWG6tIhQ.png"/></div></figure><figure class="ahn ju aiz ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/b28969995519221feceecdafdcab54d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*1sic7ttWuyNeNxhGLyRaTg.png"/></div></figure></div><p id="a96f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数时候，我们不希望风格有任何突然的变化。所以我们通常不定义类的入口和出口。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aby"><img src="../Images/dd40e5dd13504b90acff0460d6f9fc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_Pd5GZLIY3CmIT4MdD00g.png"/></div></div></figure><p id="bd9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签现在从默认样式中淡出。当它重新进入时，它直接转换到默认样式。</p><p id="39c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个H2标签，并将其添加到转换组件中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi si"><img src="../Images/8f7979d782cb8e9931aa97018196382d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w92Zu6xpTKg2vewT0vOt8A.png"/></div></div></figure><p id="a121" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们在转换标签中有两个元素。两者都可以过渡吗？</p><p id="ef57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们得到了警告。转换标记之间只能有一个元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aja"><img src="../Images/77f50a0daafca7456b43d061fa889fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkUksil30zUK9LV1Q-ry5Q.png"/></div></div></figure><p id="74a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在H2标签中，我们添加了V ELSE指令。</p><p id="8d0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，问题已经解决了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afj"><img src="../Images/4fa009e15d7e98648e0904a03854e383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfPrQefRNAIXo9_tWemVfQ.png"/></div></div></figure><p id="d6c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单击按钮。</p><p id="1fa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签逐渐消失。与此同时，H2标签淡入。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi adc"><img src="../Images/193a3887c9f2918cc2ea907545a6e66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*8zn4LRwAdlx2F2Usw4QnGg.png"/></div></figure><p id="8f50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再次点按该按钮，H2标签淡出，H1标签淡入。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/2892bbbd7fb7172f694c5a9af836897a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*5fUc9Iq8p2hLJMjL5EttPQ.png"/></div></figure><p id="5913" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，我们不希望两个转换同时发生。更合理的安排是先淡出当前元素，然后淡入新元素。</p><p id="acd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在过渡组件中，我们添加了<em class="np">模式</em>道具，并将其值设置为中的<em class="np">输出破折号。现在，当前元素将过渡出来，然后新元素过渡进来。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajb"><img src="../Images/ee9e4e8fa8053de3accbd3e753dae6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krtl3xD3ZgIBO8MDi8XFtA.png"/></div></div></figure><p id="ee59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您也可以在破折号中使用<em class="np">，其工作顺序与此相反。</em></p><p id="b49c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们刷新页面时，当前元素直接显示出来。没有进入转换。默认情况下，在初始渲染期间不会触发进入过渡。</p><p id="5690" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了打开初始渲染的过渡，我们将<em class="np">出现</em>道具添加到过渡组件中。我们可以在这里使用较短的语法:我们直接将appear放在转换组件中。我们可以跳过在它前面加上v bind指令并将true赋值给它。</p><p id="549d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们刷新页面时，当前元素将会过渡到页面中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeq"><img src="../Images/4ce46c8e154a9714ef95124e77d919fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFajy2vy9vD0q4DmTocTlw.png"/></div></div></figure><p id="5ea0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以使用CSS animation属性创建过渡效果。这一次，我们只需要两个活动类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajc"><img src="../Images/a30d89f55a21cf7271d216a0d2e79e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yT-0gwFxf-VePlqYg4REaA.png"/></div></div></figure><p id="00cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在enterActive类中，我们添加了animation属性，并为其设置了动画名称和持续时间。</p><p id="2e2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在leaveActive类中，我们设置了相同的动画，但是反转了动画方向。</p><p id="4f1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们使用关键帧来定义动画。这里，我们只创建一个简单的弹出动画。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajd"><img src="../Images/369da35eb4474c9782017e747026ceb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzWN_gplCBB8xzN7Oc_yHQ.png"/></div></div></figure><p id="40ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="c1f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到当前元素将弹出，新的元素将弹出。</p><p id="76ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在转换过程中，<em class="np">活动的</em>和<em class="np">到</em>类都将被应用到被转换的元素，即使<em class="np">到</em>类没有被定义。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju aje ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/e03d2a903de71f67b9e8c1b055fd23ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*tdTut7kXr24whdQrahWcmQ.png"/></div></figure><figure class="ahn ju ajf ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/f72ccc5e335145c03af7226e7ae1c23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*VfIISbymabtxjQ595HqzWg.png"/></div></figure></div><p id="4c98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这证明了Vue通过在预定义的时间添加和删除转换类来创建转换。我们需要确保在正确的转换类中定义了正确的CSS属性。</p><p id="4d51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将向您展示如何向动态生成的列表添加过渡效果。</p><p id="b087" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个数组。每个元素都是一个城市名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajg"><img src="../Images/3292259b240e65e85f5a63c9d5567918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcwnl6BhNDr4pOqDJVQssA.png"/></div></div></figure><p id="6766" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还有一个名为newCity的空数据属性。我们用它向列表数组中添加新的城市名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajh"><img src="../Images/d7230d3e7d6d3f3ecd3238c41d010d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-TcNbWe2fb_rJvxH550Ww.png"/></div></div></figure><p id="fd7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们呈现一个列表。</p><p id="7d44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Li标签中，我们添加了v for指令来遍历列表数组。</p><p id="a342" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为每个列表项创建一个删除按钮。使用拼接方法，我们可以使用元素的索引来删除元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zc"><img src="../Images/f3bbb159a3f913c4e068efeb313c8a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4C17DB6jBKGMVIgsmROtig.png"/></div></div></figure><p id="ab12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们列出了列表数组中的每个城市。每个城市都有一个专用的删除按钮。</p><p id="7378" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们在删除列表项时想要一个过渡效果。</p><p id="c806" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先用transitionGroup标记替换UL标记。列表是动态生成的，所以我们需要transitionGroup组件，而不是transition组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vt"><img src="../Images/37704509f70fa197960a4104a6243328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxu7gBxPBMj-z51kI302Yg.png"/></div></div></figure><p id="f69f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能想知道为什么我没有保留UL的标签。使用<em class="np">标签</em>属性，我们可以将transitionGroup组件转换成一组UL标签。</p><p id="58d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到UL标签已经创建。所有LI标签都嵌套在其中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aji"><img src="../Images/46edb1ffbb1ef7ca2c08a0add89e17a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D52phpFr1eBg1qU0Kbr9Mg.png"/></div></div></figure><p id="2037" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">tag属性可以将transitionGroup组件呈现为任何标记。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yw"><img src="../Images/b25c2750afb366d1947300378ed445e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mqm2DqEdQQalMdoongbgw.png"/></div></div></figure><p id="3843" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加<em class="np"> name </em>属性来声明转换类的前缀。我们还是把前缀命名为<em class="np"> fade </em>。</p><p id="f941" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们从类定义<em class="np">回车。我们将<em class="np">不透明度</em>属性设置为零。我们添加了<em class="np">转换</em>属性来将项目向右移动40个像素。</em></p><p id="7824" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们从类中复制了<em class="np">enter，并将其重命名为<em class="np"> leaveTo </em>。</em></p><p id="ad5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们定义了<em class="np"> enterActive </em>类。这是我们定义<em class="np">转换</em>属性的地方。我们选择所有CSS属性，并将持续时间设置为2秒。</p><p id="0d53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以同样的方式定义了<em class="np"> leaveActive </em>类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajj"><img src="../Images/f873f35c847068f28f8a03163e23f81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyNjNFtsy8A-RF2zfJkdBg.png"/></div></div></figure><p id="bd28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查程序。</p><p id="e533" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们每删除一个项目，被删除的项目就会淡出，向右移动。</p><p id="2441" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是有一个问题。在被删除的项目完全淡出之前，它仍然保持其原始位置，这意味着在它后面定义的项目将继续停留在它们的原始位置。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajk"><img src="../Images/75f15ac5d4dfcdf3f0fabb8ebef782dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uv4GtAGakRQO57N3azNPA.png"/></div></div></figure><p id="98aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">删除的项目消失后，在它后面定义的项目会吸附到它们的新位置，而不是平滑过渡。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uj"><img src="../Images/a259995de3ed2c57e8cf30dccdf43260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uywlscvDfT6VBtLjH_wG-Q.png"/></div></div></figure><p id="7f5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道怎么解决这个问题吗？</p><p id="cd1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="np"> leaveActive </em>类中，我们添加了<em class="np"> position </em>属性并将其值设置为<em class="np"> absolute </em>。绝对定位的元素将从文档流中提取出来。因此，它们不会阻塞在它们后面定义的元素。</p><p id="b131" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们单击delete按钮时，被删除的项目停止阻塞它后面定义的元素。但是这些元素仍然会快速进入新的位置。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajl"><img src="../Images/d2504fd2c8e173fc6dfc9b86196f0709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIJxtQyYS90oaO-V5ig-5A.png"/></div></div></figure><p id="8e65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我们需要添加一个新的类:move。它仍然需要由<em class="np"> name </em>属性声明的前缀。</p><p id="e156" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="np"> move </em>类中，我们添加了转换属性并监控转换属性。move类将自动应用于移动到新位置的元素。</p><p id="f009" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们删除了一个项目后，后面定义的项目会逐渐被提起。</p><p id="40f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> move </em>类只会被添加到在已删除项目后面定义的元素中。在删除项目之前定义的项目不会接收<em class="np">移动</em>类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajm"><img src="../Images/851e47dda9f7066873b47b96f3ac6df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlvRsXmXwconui26ofa6Fg.png"/></div></div></figure><p id="7c77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加一个输入标签。我们把它和新城物业联系起来。</p><p id="c93d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们创建四个按钮。</p><p id="a79f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个按钮将新城市添加到列表数组的开头。</p><p id="bd7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个按钮将新城市添加到列表数组的中间。</p><p id="c8d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三个按钮将新城市添加到列表数组的末尾。</p><p id="0de5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一个按钮按字母顺序排列城市名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uv"><img src="../Images/d8a91fc331f150aa9f88b40e3c940531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHmg3c3Avb4DZDNlG9UUbQ.png"/></div></div></figure><p id="ac63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在列表的开头添加了一个新的城市。</p><p id="53d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">列表中的每一项都收到了move类。它们将逐渐下移，为新的第一个项目腾出空间。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ym"><img src="../Images/5c32e3951405d88acb5c7b1b920c048d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUCd1mgDcCvRo-yhK2XIuA.png"/></div></div></figure><p id="7353" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们在列表中间添加一个新城市。</p><p id="3855" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，只有列表后半部分的项目被归入了<em class="np">移动</em>类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qj"><img src="../Images/cf5eb39aaf65728f44b5f94bf598f926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDj9-_h1PoosWVAwV8wCcg.png"/></div></div></figure><p id="d8ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们在列表末尾添加一个新城市，只有新项目本身会有过渡效果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qd"><img src="../Images/fe37268adeab326f81622f04580827bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDPG0pdBPEvK0CWdKLb6ew.png"/></div></div></figure><p id="d16f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们单击最后一个按钮，按字母顺序对城市名称进行排序。</p><p id="a7d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有物品这次都复活了移动类。他们将向上或向下移动到他们的新位置。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju ajn ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/268eee4699ac10cf0000938891f0dd4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*e56ueYQVvx6KpMNbPjqgCg.png"/></div></figure><figure class="ahn ju ajo ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/0c2a770881ae007cad90f036d3dcc684.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*4i507tCTMyM1mL76zpZIiQ.png"/></div></figure><figure class="ahn ju ajp ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/81c983fc4ec11beec9c2f130ff2617ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*obZ8NFBsLgioAroinS27Ww.png"/></div></figure></div><p id="5c30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue支持第三方动画库。我们将以animate.css为例。在开始之前，让我们先快速回顾一下如何使用animate.css。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sq"><img src="../Images/5abeec94707c4809eb8a562037d0c52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*qnZZX9v-er1kMQfH6RLHAA.png"/></div></figure><p id="6607" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Animate.css是一个免费的动画库。它为我们提供了许多预定义的动画效果。我们可以使用这些动画来创建过渡的效果。</p><p id="8ac5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动画点css是纯粹基于CSS的。要安装它，我们只需要导入它的源CSS文件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wi"><img src="../Images/131ed7c032a429722d231fd69538c5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkz4CNUlTB4IiXHJyzqwXA.png"/></div></div></figure><p id="589c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将动画效果应用于页面元素，我们为它分配了两个类。第一个是<em class="np">动画</em>。它以animate为前缀。注意这里，我们需要两个下划线。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rk"><img src="../Images/50641522b8eb54388d028e8098d3c68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAmJmMxTiR-zT8B7RY6eXg.png"/></div></div></figure><p id="7fdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个类决定应用哪个动画效果。</p><p id="1e9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们选择一个我们想要的动画并复制它的类名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajq"><img src="../Images/95a1b6d721c0c04a1dd4c5e53c098847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtP114y9p1WZggdwa6YLbw.png"/></div></div></figure><p id="ba05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们在一个Vue程序上尝试animate.css。</p><p id="7565" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们将链接标签粘贴到Vue文件中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zk"><img src="../Images/cc5edff52857f31487bd2c0127e1d441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43Xoi21v7NTFp908YL8avQ.png"/></div></div></figure><p id="1854" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文想搞活的主儿。</p><p id="db09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为它设置了两个类。第一个是<em class="np">动画</em>。</p><p id="6dc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个类决定哪个动画效果将应用于H1标签。</p><p id="7a00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们选择摆动动画。我们复制它的类名，并将该名称粘贴到H1标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/a806a3f37112b3808c3a9cf0b186dd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dex886olGjjzgh3tPbLGQg.png"/></div></div></figure><p id="4792" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们刷新页面时，H1标签会抖动。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xd"><img src="../Images/eb3c636201a28a2ec5f336d414f123c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*XZWtjqgENWhxUfHMqJ2PxQ.png"/></div></figure><p id="5b3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以控制动画的持续时间。</p><p id="1608" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们选择分配给H1标签的两个动画类。我们添加了<em class="np">动画持续时间</em>属性，并设置了一个新的持续时间。</p><p id="3809" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Animate需要以两个下划线为前缀。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajr"><img src="../Images/1b8cdcdf283d916fabcf8548dc68a2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y74-roe0l5QYbNMCI4oo8w.png"/></div></div></figure><p id="b0c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将使用animate.css中的类创建进入和离开过渡。</p><p id="846b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有六个转换类都可以转换成类挂钩点。我们只需要去掉它们的前缀，在它们后面加上<em class="np">类</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afi"><img src="../Images/afda682254d573e0c7582c178b2907aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2swp6Yk9DPBWWzkDWqPsbQ.png"/></div></div></figure><p id="5fd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其他三个挂钩点用于过渡元素的初始呈现。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ajs"><img src="../Images/3ce58e2fee8ab50b3c9b7e5beca44a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*1C_RB1JBOz84ZATLQ4bvYQ.png"/></div></figure><p id="9369" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有这些类挂钩点实际上都是转换组件的道具。它们的值是类名。分配给它们的类将在预定义的时间添加和删除。</p><p id="e8c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这九个道具允许我们使用来自第三方库(如animate.css)的现有类来创建过渡</p><p id="1bbf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动画库使用关键帧创建动画。所以很多时候，我们只需要设置两个<em class="np">主动</em>道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajt"><img src="../Images/14ad0556b4f12db46e1f83f83d29663c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrAHOL77IYlPXMa7V6dCjg.png"/></div></div></figure><p id="3c72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，Vue有一个bug。<em class="np">外观类</em>道具不工作。根据我自己的测试，正确的名字应该是<em class="np"> appearFromClass </em>。这节课结束时，我会向你证明这一点。可能等你看到这个视频的时候，Vue已经修复了这个bug。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abu"><img src="../Images/bc229c93f9dd3e61efd9eb07749d2c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7a-ntedKUTsdc6VnWlhuw.png"/></div></div></figure><p id="0629" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试这些过渡道具。我们将从进入和离开道具开始。</p><p id="e293" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们以前用过的程序。两个活动的<em class="np">类控制动画的持续时间。</em></p><p id="34da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> pop </em>类定义动画的关键帧。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afp"><img src="../Images/dca9fadb0b0c6859898ddf1d50075231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSsBO1nS06Q6Q_dQlrpi9A.png"/></div></div></figure><p id="6899" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用animate.css提供的类创建<em class="np">进入</em>和<em class="np">离开</em>过渡。所以这三个类都不需要。</p><p id="99a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也不需要<em class="np">名称</em>道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aju"><img src="../Images/4f852f81087cecea4ba9dede87281056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88clVfWIQ3M2-IEnggrozg.png"/></div></div></figure><p id="728a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从animate.css的手册中复制链接标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajv"><img src="../Images/4ab65c637c38e44676210570176e5a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EXAElLHuOLsehELAWC8Wkg.png"/></div></div></figure><p id="d893" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经在程序上安装了animate.css。</p><p id="5ceb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在过渡组件中，我们添加了两个<em class="np">活动类</em>道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ta"><img src="../Images/ef49dcc50289aeef619d3e10f3fc9f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIzNdNWK4lmSEbEoWByPpg.png"/></div></div></figure><p id="21d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它们的值是类名。他们都需要<em class="np">动画</em>类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ue"><img src="../Images/2c4fbbd9ed11a4d25dd75249a038b1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKKfFPqWFa52oys8PjPw_g.png"/></div></div></figure><p id="3ccd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们为enter过渡选择一个动画类，并将其类名分配给<em class="np"> enterActiveClass </em>属性。</p><p id="89b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="np"> leaveActiveClass </em>道具中，我们设置了相反的动画类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rr"><img src="../Images/a4bf58ab06184cf8bf44e083e834def3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hICkMKl7NrvOvfv9_6MUYQ.png"/></div></div></figure><p id="85ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，两个<em class="np">活动类</em>道具将在离开和进入过渡期间应用分配给它们的动画类。当过渡结束时，应用的动画类将被移除。</p><p id="626a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们为<em class="np">进入</em>和<em class="np">离开</em>动画设置更长的持续时间。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajw"><img src="../Images/8aaef38bd590e0ba09e47ac0c6c1a98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OPWWL4cIY0AtxDeCWhEmQ.png"/></div></div></figure><p id="18f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="6260" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意将要添加到H1标签中的类。</p><p id="f101" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当H1标签被过渡出来时，它有三个类:来自animate dot css的两个动画类和<em class="np"> leaveTo </em>类。</p><p id="56e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个动画类是由<em class="np"> leaveActiveClass </em>道具添加的。<em class="np"> leaveTo </em>类是六个过渡类之一。它尚未定义，但已被添加。我们没有在转换组件中设置<em class="np">名称</em>属性，所以前缀是V，这是默认值。</p><p id="9fcd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也揭示了一个事实，即Vue只添加和删除预定义时间的转换类。我们负责正确设置过渡类。</p><p id="9173" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当H2标签过渡进来时，它仍然有三个类。前两个来自animate dot css，最后一个是我们没有定义的<em class="np"> enterTo </em>类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajx"><img src="../Images/2899b336a10ae27eaaad9e3759928894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEjGY17a7OhNXuW-D3zzPQ.png"/></div></div></figure><p id="d94b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加<em class="np">持续时间</em>道具，并将其值设置为5000。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajy"><img src="../Images/4f5a4e7a55ef0fd46e6a8744fffc49e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*31g7HCxG0AN2Ozm3bdboJg.png"/></div></div></figure><p id="757b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，Vue将把5秒分配给进入过渡，另外5秒分配给离开过渡。进入和离开动画各只需三秒钟。因此，过渡元素和分配给它的动画类将在过渡动画结束后多停留两秒钟。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abw"><img src="../Images/d3dc1fd19169214eaf079a00dbdf3d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUIFOTxp-nT2ol5QIfjs8w.png"/></div></div></figure><p id="55ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试三个<em class="np">出场类</em>道具。它们允许我们在第一次加载或刷新页面时为转换后的元素设置专用动画。</p><p id="ef32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们去看Vue手册。我们打开API列表并找到转换组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajz"><img src="../Images/084fcedd56d1527a33e6b58031bd8b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7IFwkMHgMXUEY1bBFxj0Q.png"/></div></div></figure><p id="14e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">外观类</em>道具有问题。它不起作用。正确的名字应该是<em class="np"> appearFromClass </em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uj"><img src="../Images/1d76c2ecb1ac7bef1158f35b5a4f7d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E153U5Nsk4yWxWaEILpL6Q.png"/></div></div></figure><p id="56e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在过渡组件中，我已经添加了<em class="np">出现</em>道具来启用初始渲染的过渡。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aka"><img src="../Images/0fd45fac0d8cd67dfe20b441efeab907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGqfmIzvfquMte8Tfd73LA.png"/></div></div></figure><p id="d9f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="9f6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签已经使用由<em class="np"> enterActiveClass </em>道具设置的动画重新进入浏览器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afq"><img src="../Images/3f1d64b59cb7ef543431ce28c53d98d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hj2hKy69-zcUqotpSrMUwQ.png"/></div></div></figure><p id="76e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加<em class="np">appearractiveclass</em>道具，并为初始渲染设置一个专用动画。</p><p id="4f6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们再次刷新页面。</p><p id="b8b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，H1标签有了新的动画效果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rb"><img src="../Images/e388269a63994dfddf176eb5d22d31a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRbtmhN6ta4GcXYcl_W8QA.png"/></div></div></figure><p id="c363" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签中增加了三个类别。前两个来自动画点css。最后一个还是<em class="np"> enterTo </em>类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/cd4c220612fc0b0885d18c830e130ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*2j_j1o76V2Cz2oNl_SpIgQ.png"/></div></figure><p id="099e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们一起尝试所有三个<em class="np">道具。</em></p><p id="3f63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我首先从中定义了一个名为<em class="np">appear的新类。我将H1标签放大25%,并给它一个蓝色背景。</em></p><p id="6c68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我给定义了一个名为<em class="np">的类。我将H1标签缩小了25%,并给它一个绿色背景。</em></p><p id="1ab2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我定义了<em class="np">appearance active</em>类来设置<em class="np"> transition </em>属性。</p><p id="e187" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我将三个<em class="np">出现</em>职业分配给三个<em class="np">出现职业</em>道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akb"><img src="../Images/030a33316921036620c1483a340e1f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-o83jnOQAcVhz5-nvQlpng.png"/></div></div></figure><p id="ca95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="5dd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我刷新页面。</p><p id="45a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签首先放大并变成蓝色。这证明了<em class="np"> appearFromClass </em>道具正在工作。它将来自类的<em class="np">appear应用于H1标签。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi akc"><img src="../Images/6b603889a3c97555636635dd6086609e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*x_FQwMYnr8jjyGtJI5YJtg.png"/></div></figure><p id="3ba2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，H1标签逐渐缩小，变成绿色。</p><p id="9994" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个过程中，它接收了<em class="np">appear activate</em>和<em class="np"> appearTo </em>类。这证明了<em class="np">外观类</em>和<em class="np">外观类</em>道具正在工作。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/290fa7c6a2fe4c92a9ece9f8a4a067a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*hCR56NgzwBhkAujTs6xw6g.png"/></div></figure><p id="6c34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">转换结束后，<em class="np"> appearActive </em>和<em class="np"> appearTo </em>类都被移除，H1标签恢复到默认样式。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sq"><img src="../Images/114ca49f097b3f763d60ca9cceadcd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*3sCUO3N8IOxaWZNgzbzm8g.png"/></div></figure><p id="962d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我将<em class="np">外观职业</em>道具切换到<em class="np">外观职业</em>道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akd"><img src="../Images/cecbb1ca925ae6e34158b795e9418182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CG1-JLAFhEbasgU0WVX8XA.png"/></div></div></figure><p id="1a68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="6161" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到H1标签从默认风格转变过来。来自类的<em class="np">外观尚未添加到其中。</em></p><p id="44db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">外观类</em>道具无法识别。它被当作一个未知的道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi gj"><img src="../Images/c25c9a02a42db85cbeb34551371f7f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3ScD7B5N3rPz3fMiU-0wA.png"/></div></div></figure><p id="3ebe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">transition组件为我们提供了11个事件，允许我们绑定11种类型的钩子函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abh"><img src="../Images/e50813ccfdbaa2d28d40b8042f5e9259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4uGLIZZlluvTxUdtxY-P7g.png"/></div></div></figure><p id="d708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这十一个事件可以分为四组:之前、期间、之后和取消。</p><p id="fd10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了组之前的<em class="np">组，每个组都有三个事件:进入、离开、出现。在出现</em>事件之前没有<em class="np">。<em class="np"> leaveCancelled </em>事件仅适用于v show指令。V IF指令删除了转换后的元素，当然，我们不能取消它。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ake"><img src="../Images/5e4dac3b4941afc6543b93513cea7230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OF_t3Da3Ma58u_z-wDQshQ.png"/></div></div></figure><p id="82a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们创建的第一个过渡程序。进入和离开转换由转换类创建。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abx"><img src="../Images/b6d0da46805beaef91feb6b3bab52ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQpUj9848HwSsagfp2WOkA.png"/></div></div></figure><p id="5e67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试上面的四个项目。</p><p id="dd05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们先去掉<em class="np">出现的</em>和<em class="np">模式下的</em>道具。也不需要H2标签。</p><p id="7b20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标记的显示由display属性控制。我们将display的值重置为false。</p><p id="e7fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将过渡持续时间缩短到2秒。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akf"><img src="../Images/9766f9584807c20ce9687d012ef5556c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQQhd8YQSryH71TaNorXgw.png"/></div></div></figure><p id="105e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们监视四个输入事件。我们将每个输入事件绑定到同名的方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vh"><img src="../Images/abd19e081860cab42f7ea5fd035332e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vv4tNpkCyVIP335tdLfmcw.png"/></div></div></figure><p id="64af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转到组件选项对象来定义这四个方法。</p><p id="cfb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个事件方法将接收转换元素的DOM对象作为其第一个参数值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sc"><img src="../Images/665d2f00b9a8a57cb536d8dbd6750c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtQDugxkA3Ha3wXJXbHV-Q.png"/></div></div></figure><p id="d43d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="8e01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我单击按钮来过渡H1标签。</p><p id="7bc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总共触发了三个钩子函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akg"><img src="../Images/d27a15a2a9e9c443d54eea5ca9619e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meycne9U7s2rTcPpkkoyRQ.png"/></div></div></figure><p id="d952" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当过渡结束时，afterEnter功能将被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yw"><img src="../Images/cd36206a9e383345eefe6cc3c0689273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0_dGJ-pYPp7WgWr_f1rSw.png"/></div></div></figure><p id="8f8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从<em class="np"> beforeEnter </em>钩子和从<em class="np"> enter </em>钩子得到的El参数是相同的。H1标签有enterActive和enterTo类。</p><p id="bf6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当afterEnter挂钩被触发时，转换已经结束，所以H1标签是空的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acw"><img src="../Images/0b0e5a7324a0c19fd5d04a11fb0ee858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEBLyDs2Hjwfoh_7FGfkpg.png"/></div></div></figure><p id="67fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们刷新页面并尝试使用<em class="np">回车取消</em>挂钩。当我们取消进入转换时，离开转换将立即接管。<em class="np"> enterCancel </em>钩子捕获离开过渡的第一个关键帧。</p><p id="4748" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到<em class="np"> enterCancelled </em>钩子的EL参数有<em class="np"> leaveFrom </em>和<em class="np"> leaveActive </em>类。注意这里，我们有从类的<em class="np">leave，而不是从<em class="np">leave到</em>类。<em class="np"> enterCancelled </em>钩子捕获了离开过渡的第一个关键帧。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ags"><img src="../Images/1db2927cb6f03bfc4085f08a5a46796c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2x3wl0P7cPGsHlynQKq1A.png"/></div></div></figure><p id="4e95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">回车</em>钩子有第二个参数:<em class="np">完成</em>功能。一旦你声明了<em class="np"> done </em>函数，你必须显式调用它。否则，过渡将永远不会结束。</p><p id="0dca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回车键转换的动画已经结束，但是<em class="np"> afterEnter </em>钩子还没有被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agc"><img src="../Images/82dbc934f0acc30598baca5157645889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phCQwMoD7E4UMEIvjSo7nA.png"/></div></div></figure><p id="4afd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们调用<em class="np"> done </em>函数并再次运行该文件。</p><p id="ecb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，我们遇到了一个新问题。过渡立即结束。没有时间让动画结束。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acx"><img src="../Images/a2bdce4c9adc6794328a555822f81e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tisC8HAfTEd-2E1pST1uZg.png"/></div></div></figure><p id="1753" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们调用<em class="np"> done </em>函数时，我们必须确保过渡动画已经完成。</p><p id="f29d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了setTimeout函数，并设置了三秒钟的延迟。</p><p id="9912" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，有足够的时间来完成过渡动画。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akh"><img src="../Images/bcaf50bd6eae25578219a4b376139b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siJTcMt_M1PiVcreoO8eUw.png"/></div></div></figure><p id="85ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">过渡钩子允许我们使用基于JS的动画库。我们不再需要Vue为我们添加和删除过渡类。在这种情况下，我们可以添加CSS属性并将其值设置为false。</p><p id="04d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">转换挂钩仍然会在预定义的时间触发。但是不会再添加过渡类了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ux"><img src="../Images/5f61ae2fe231346f69c92b3be7adc176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQxN-m50hN3UaEmX-GpcAA.png"/></div></div></figure><p id="4878" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这节课中，我们将简单介绍如何使用GSAP:绿袜子动画平台。它的官方网站是greensock.com。</p><p id="6897" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在它的主页上找到它的CDN地址。只要链接这个JS文件，你的程序就可以访问GSAP提供的所有东西。不需要任何配置。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aki"><img src="../Images/c2d777dfedf37e0e43d96a18fd9bf44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COZX7P_YMqtOqVbXaIMROQ.png"/></div></div></figure><p id="6200" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GSAP有两个库:补间和时间轴。这里，我们只使用补间库。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi akj"><img src="../Images/05f46ff7f4af62c66aa0b717792fa638.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*lcQyIcU79p7AaqdxdduQZg.png"/></div></figure><p id="8af7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们主要使用的是<em class="np">到</em>的方法。它有一个相当独特的语法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akk"><img src="../Images/9e5d2c9c31d73370721e2c0f2213f5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ynTTS0iAVCwFYAzN-gf5g.png"/></div></div></figure><p id="bb11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先选择目标DOM对象。我们可以使用类、ID或标记名。</p><p id="53d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GSAP方法的第二个参数是一个对象。该对象可以直接访问所选DOM对象的属性。我们从DOM对象中选择属性，并为它们设置新的值。</p><p id="6505" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们使用duration属性来设置动画持续时间。<em class="np"> GSAP到</em>方法的第二个参数设置结束关键帧。默认元素样式是开始关键帧。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akl"><img src="../Images/91c388e5773811b409acf35c94f94098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OwlV0q9kFSIyNVN7A4CFYg.png"/></div></div></figure><p id="05b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> GSAP到</em>的方法为我们提供了几个定制动画的特性。</p><p id="1053" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">duration属性控制动画的持续时间。其值以秒为单位，默认持续时间为半秒。</p><p id="25cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">缓动</em>属性允许我们控制动画过程中的变化率。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xt"><img src="../Images/ed1de1d38adb92d9239f95032138cbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJT487ayqlxZnFs3nGDDXQ.png"/></div></div></figure><p id="7876" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> onComplete </em>属性允许我们在动画完成时设置一个钩子函数。我们可以用它来触发enter和leave钩子中的<em class="np"> done </em>函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akm"><img src="../Images/c235ba01a150e588899a8118d18b04b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPKarRXMG6VbTudYqPnnvg.png"/></div></div></figure><p id="e032" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果动画设计涉及几个关键帧，请使用<em class="np">关键帧</em>属性，并为其分配一个数组。每个元素定义一个关键帧。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abf"><img src="../Images/11fe3c3c5e852492e0365a9097fc6863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymVhSvZwkhT7rTD4JhXHmg.png"/></div></div></figure><p id="8a4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们回到我们的Vue计划。</p><p id="ec91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加一个新的脚本标签来安装GSAP。现在我们可以通过全局API GSAP访问GSAP方法和属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akn"><img src="../Images/84a43dfa0db455621d3a8be121bf6409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJxrzKOI0UYAanC0w0YDeA.png"/></div></div></figure><p id="567a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将需要<em class="np">到</em>的方法和<em class="np">设置</em>的方法。</p><p id="3c4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在转换组件中，我们首先添加CSS属性并为其赋值false。这可以防止Vue添加任何过渡类。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi akc"><img src="../Images/6333db131145c13881235d4db4809e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*WDD0uvsoJXm2Hmt_wyeFhg.png"/></div></figure><p id="65cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们监控<em class="np"> leave </em>事件，并触发一个同名的钩子函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ue"><img src="../Images/d1a6cffe538b9b5d7889c1177fa3efc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6bbVhzrkDAbhwaIGXCdZA.png"/></div></div></figure><p id="c952" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们定义<em class="np">离开</em>函数。</p><p id="8a20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> leave </em>函数有两个参数:EL和done。</p><p id="3f13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在leave方法中安装了<em class="np"> GSAP到</em>的方法。</p><p id="c776" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们把埃尔传给GSAP的<em class="np">传给</em>的方法作为它的第一个论证。</p><p id="d018" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个参数是一个对象。这个对象可以直接访问EL对象。</p><p id="7d0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们设置不透明度和比例为零。</p><p id="cfdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们将持续时间设置为1。</p><p id="47d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将<em class="np"> Done </em>函数分配给<em class="np"> onComplete </em>属性。动画结束后，会自动调用<em class="np"> Done </em>功能。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ako"><img src="../Images/a71f15cd313dc4be867612bd15afdf7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYvLbO7E0CUsqVOnNxaJ_g.png"/></div></div></figure><p id="40bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="f80f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意即将添加到H1标签中的内容。</p><p id="d9a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我点击按钮后，H1标签开始收缩和褪色。</p><p id="5d74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签收到了样式属性。GSAP仍然通过控制CSS属性来生成动画。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akp"><img src="../Images/9da9561b6b8db1c3af7361181cdd6678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6SLBg2REYhuX4LNXip8rA.png"/></div></div></figure><p id="0a0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们创建一个进入过渡。这一次，我们需要两个钩子:进入之前的<em class="np">和进入</em>之前的<em class="np">。</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sy"><img src="../Images/763fa4403905d8fc3e466995cdbb9e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvf9MzqDN7--zVBvS7pPNQ.png"/></div></div></figure><p id="dd16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="np"> beforeEnter </em>钩子中，我们调用GSAP <em class="np"> Set </em>方法来设置<em class="np"> enter </em>过渡的初始关键帧。我们将不透明度和范围属性都设置为零。</p><p id="fd01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="np">中输入</em>钩子，我们将GSAP <em class="np">添加到</em>方法中。</p><p id="58f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们设置不透明度和缩放回一。然后我们将持续时间设置为1。我们将<em class="np"> Done </em>函数分配给onComplete属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abq"><img src="../Images/765ba6951160ee4bd8c207c37b808c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pp45aDx4SSTs278P8FNeYQ.png"/></div></div></figure><p id="9fed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，输入转换完成了。</p><p id="2bd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="a469" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">离开和进入的传统都被设定好了。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju akq ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/adb29ab24b73a33e53ae4580dba8aea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Zy2eH2BAlmmig-y5KvbB2A.png"/></div></figure><figure class="ahn ju akr ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/6895a02329f3200fe5ba8d624b2f21e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*i4x8P3yhKeMl03zxeYP15Q.png"/></div></figure></div><p id="1de4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加<em class="np">出现</em>钩子。</p><p id="d57f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住还要添加<em class="np">出现</em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi gj"><img src="../Images/1ddb14ec90fd9addacb94e4e07ccd584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVh0uFJwAHZ7QkwBP9u2Sw.png"/></div></div></figure><p id="d0d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们想为初始渲染创建一个弹出效果。这就需要我们设置两个关键帧。</p><p id="9154" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="np"> GSAP到</em>方法的第二个参数中，我们添加了<em class="np">关键帧</em>属性，并为其分配了一个数组。</p><p id="41a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个元素中，我们放大了H1标签。然后在第二个元素中，我们将H1标签设置回默认大小。然后我们添加<em class="np"> onComplete </em>属性来调用<em class="np"> Done </em>函数来结束转换。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aks"><img src="../Images/2efd31bf46c4d656e18771e27946716f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ulx3-Af6HX7HVAqFKufmxA.png"/></div></div></figure><p id="6fbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="d628" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们刷新页面时，H1标签将会弹出。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wl"><img src="../Images/b52f4bb59f8ff92be603181d46be7eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7pBS70-xYkdcba7TqRR9Q.png"/></div></div></figure><p id="2337" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个输入标签。它连接到数字属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uu"><img src="../Images/bf1c2f1800027e6a6d22dbc22ea87d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmNwgSJG8n7-m_j3eo1nrg.png"/></div></div></figure><p id="f661" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将<em class="np">类型</em>属性添加到输入标签中，并将其值设置为<em class="np">号</em>。</p><p id="539e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，输入标签中有两个按钮。单击向上按钮，数值增加1。单击向下按钮，数值减一。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ym"><img src="../Images/52ee9d5d5294653761bf7b5da919ed6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZNdz8e1tbk7-b3EbxyesQ.png"/></div></div></figure><p id="b475" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加<em class="np">步骤</em>属性，并将其值设置为5。现在，当我们单击两个按钮中的一个时，number属性的值将增加或减少5。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ym"><img src="../Images/3ccce53166b2e3be42c13be5abc9f297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RokSF2O8r_9HQ4GRKKhrFg.png"/></div></div></figure><p id="d204" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数值会立即改变。我们希望将价值变化制成动画。我们在上一课中使用的<em class="np"> GSAP到</em>方法可以帮助我们做到这一点。</p><p id="0156" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们安装GSAP。</p><p id="b8f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们使用<em class="np"> GSAP到</em>的方法制作了一个页面元素的动画。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akt"><img src="../Images/7274b30687f1e8a11546b7d4166ebb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQTKMQGUiQSypJbiBVRpMg.png"/></div></div></figure><p id="47c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将动画元素的DOM对象作为第一个参数值传递给该方法。仔细想想，DOM对象还是JS对象，就像Vue组件的数据对象一样。有什么灵感吗？</p><p id="ad28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件选项对象中，我们添加了监视选项。</p><p id="88e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们监控数字属性。</p><p id="2d2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在数字监视器中安装了GSAP方法。</p><p id="dc35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将这个点美元符号数据作为它的第一个参数值传递给GSAP方法。</p><p id="6794" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第二个参数中，我们将持续时间设置为5秒，并将<em class="np">缓解</em>设置为<em class="np">无</em>。在这个对象中，我们可以直接访问所有数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aku"><img src="../Images/26d1f50bd40d2a4609d957d3329ce487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnbIm92rJJRxXRRjciG4tA.png"/></div></div></figure><p id="343c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当数字属性更新时，将触发数字监视器。它将接收最新的数值。</p><p id="86a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建一个新的数据属性，并将其命名为<em class="np"> tweenedNumber </em>。我们将其值设置为零，这与number属性的初始值相同。</p><p id="5cc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="np"> GSAP到</em>方法的第二个参数中，我们将number属性的新值赋给了<em class="np"> tweenedNumber </em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xs"><img src="../Images/f49dbb156a35a10e20b238e045dbf999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsLh5McO1W1VGiWAbbB3pw.png"/></div></div></figure><p id="1830" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是关键操作。我们通过<em class="np"> GSAP到</em>方法重置<em class="np"> tweenedNumber </em>属性的值。GSAP将为<em class="np"> tweenedNumber </em>属性的值变化创建动画效果。</p><p id="6e0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在组件模板中显示<em class="np"> tweenedNumber </em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akv"><img src="../Images/40289d0857910878bb6b0fb82aa5dba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vTULLyOtsChd_mjFTGcCyQ.png"/></div></div></figure><p id="b0b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="e449" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到<em class="np"> tweenedNumber </em>属性的值变化现在是动态的。它逐渐上升。整个过程需要五秒钟，这是我们在<em class="np"> GSAP到</em>方法中设置的持续时间。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akw"><img src="../Images/c4706eed51206f7cd7ce56b78709f8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUdqT_bGvH5Kaf2Cbugm5Q.png"/></div></div></figure><p id="ec0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不需要小数点后的四位数。我们添加computed选项并为<em class="np"> tweenedNumber </em>属性创建一个getter。</p><p id="7610" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将getter <em class="np">命名为formatedNumber </em>。</p><p id="dcfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用数学点截断方法处理<em class="np"> tweenedNumber </em>属性的值。声明点后面的所有数字都将被删除。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akx"><img src="../Images/1e5585d2c25f1472acb1c2de3887d983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8tKt2dzzjgJZVf5fzfzIg.png"/></div></div></figure><p id="84cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="4df7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了formatedNumber getter，我们基本上已经创建了一个数字时钟。数值每秒增加一。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qm"><img src="../Images/2857afa78a920e142e8b08105e34b572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pj8H6rD2WZkSbkgGu6DZMQ.png"/></div></div></figure><p id="5f52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们向您展示了如何使用GSAP制作属性值变化的动画。</p><p id="0e1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入标记只连接到数字属性。number属性本身永远不会向用户显示。过渡效果应用于作为number属性代理的其他属性。</p><p id="208d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们设置了一个监视器来监视number属性。我们将最新的数值赋给<em class="np"> tweenedNumber。tweenedNumber </em>是我们在组件模板中显示的内容。</p><p id="484f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用GSAP方法完成赋值。这是实现状态转换的关键操作。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agy"><img src="../Images/80d12ea1333ffa30c1de85aaf1f4412d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQSIc_6LSVSLPyUbnYv3gA.png"/></div></div></figure><p id="abdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们需要转换其他属性，我们需要为每个属性创建一个观察器和一个代理属性。这是相当不方便的。更好的解决方案是创建一个专用组件来转换属性状态。这样，我们可以重用观察器和代理属性。</p><p id="00ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们声明一个新的组件。我们把它命名为<em class="np">动画数字</em>。</p><p id="227a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件模板中，我们显示了<em class="np"> tweenedNumber </em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aky"><img src="../Images/6b07e70ddc146a908655bc8b9c49a791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0VIAPvyWEaQVbPd8gAd6g.png"/></div></div></figure><p id="231e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加数据选项来定义tweenedNumber属性。我们将它的初始值设置为零。</p><p id="ef18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们声明一个道具。我们将道具类型设置为number。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akz"><img src="../Images/2a6109e31b7d004c390a3856d53dc440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjjpb97a_lLZXeY0aV5g0A.png"/></div></div></figure><p id="f8ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了方法选项。</p><p id="d125" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们定义了一个名为<em class="np">补间</em>的方法。我们将其参数命名为<em class="np"> newNumber </em>。</p><p id="6c61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将补间方法中的<em class="np"> GSAP调用到</em>方法。我们通过了。$data给<em class="np"> GSAP给</em>方法作为它的第一个参数值。在第二个对象中，我们将持续时间设置为两秒，并将<em class="np">补间</em>方法的参数赋给<em class="np">补间编号</em>属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abc"><img src="../Images/7aeea512de54ac5ccec54fdbbb93b503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-15gwxlaYuTifwfU3wI8w.png"/></div></div></figure><p id="b08a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加监视选项，为<em class="np">号</em>道具设置一个监视者。</p><p id="9f83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在数字监视器中，我们触发刚刚定义的<em class="np"> tween </em>方法，并将数字属性的新值传递给它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ala"><img src="../Images/a4d55b0997558862c482a531d6052cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PG29pXd6wYl_dp8AgPMMA.png"/></div></div></figure><p id="e993" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加挂载的钩子。我们调用<em class="np"> tween </em>方法，并将当前数字道具的新值传递给它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alb"><img src="../Images/778d00622fa00bd03f906c4c4aa18955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxOQ3uMM-1soitz628i69g.png"/></div></div></figure><p id="be04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，<em class="np">动画数字</em>组件完成了。让我们安装它。</p><p id="12e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过<em class="np">数字</em>属性将根组件的<em class="np">数字</em>属性发送到animatedNumber组件中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alc"><img src="../Images/e83d78eaed70ac2e35ae642f7801888b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hb66ly0d6SIitM-iN2H9nw.png"/></div></div></figure><p id="88a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="7f59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们得到了我们想要的过渡效果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ald"><img src="../Images/902bfeee3dac5521484039682612b81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RL1lEW1RlVFMIoER1N29Q.png"/></div></div></figure><p id="f29c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这节课中，我们将学习混音。这是开发Vue项目中重用代码的最简单的方法。</p><p id="57c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们有两个组件:一个根组件和一个子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lp"><img src="../Images/f1bb1ee5f55e8978bc14d13ef3d435aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFFtcJoRDmHliSsXeLtGWQ.png"/></div></div></figure><p id="b86a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个组件的选项对象可以共享相同的选项。共享选项可以在独立对象中定义，并通过混合添加回选项对象。</p><p id="9a85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们声明一个变量。我们称之为我的混合。我们给它分配一个对象。该对象存储共享选项。这里的语法与普通组件选项对象中的语法相同。对象中的THIS指向接收混合对象的组件实例。</p><p id="f394" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先添加数据选项。我们定义一个名为city的数据属性。</p><p id="f57d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们添加计算选项。我们定义了一个名为capTitle的计算属性。我们把它定义为吸气剂。</p><p id="2011" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在getter函数中返回this.title。这指向使用mix-in对象的组件实例。为了确保getter能够正常工作，接收这个mix-in对象的组件必须有一个名为title的数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ale"><img src="../Images/8e35b930f0c1958bbbe47b474766990a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSnbcb5SVuBpUqdpHyRgiw.png"/></div></div></figure><p id="4017" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将混合对象添加到组件实例中。</p><p id="46ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件中，我们添加了mix-ins选项，并为其分配了一个数组。然后我们将mix-in对象传递到数组中。该数组允许我们传递几个混合对象。</p><p id="f6b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，city和capTitle属性将被添加到根组件实例中。CapTitle是一个计算属性。它的值基于根组件的title属性。城市是一种数据属性。它将被添加到美元符号数据对象中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afm"><img src="../Images/a28bee0cdfccdfd8993623be150ee553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eT_X8bjW8yEJfhFimgwcig.png"/></div></div></figure><p id="a01c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件模板中，我们可以将首都和城市显示为普通数据和计算属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alf"><img src="../Images/7fe5a327faf8704dc73b102a67a0931a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TIXGiuhTqK9rIRTElFm9g.png"/></div></div></figure><p id="5cdf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它们都是反应性的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ur"><img src="../Images/49f3fece2cbd40f5d105757ba281ca0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJFJNcI5UGZgvMmZztqRxQ.png"/></div></div></figure><p id="6880" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果混合对象有重复的数据属性怎么办？例如，在mix-in对象中，我们设置了一个标题属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vn"><img src="../Images/01b0a4f6e763ebc7fc241d749d4c27bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzo674Zf3zXaz7R5_Qet5g.png"/></div></div></figure><p id="e446" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接收mixin-in对象的根组件已经有一个名为title的数据属性。那么哪个将被添加到组件实例中呢？</p><p id="bb7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件自身的数据属性具有更高的优先级。它们不会被混合对象的重复属性覆盖。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alg"><img src="../Images/dd5daf4cd3313d1d857d65605b4567a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z24va-JEISLD-2feAyvnRA.png"/></div></div></figure><p id="0c8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以在混音对象中设置挂钩。我们将创建的钩子和控制台日志<em class="np">混合创建</em>在其中。</p><p id="db9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在根组件中，我们还添加了创建的钩子。我们在控制台日志的<em class="np">根组件中创建了</em>。</p><p id="cdb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="e1ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到两个创建的钩子都被触发了。首先触发来自混音对象的那个。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afm"><img src="../Images/3500475d78d5da6add8e87a7c7f11bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1vfcKAXvr-OxQCV9hrypA.png"/></div></div></figure><p id="1d16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">mix-in选项仅将mix-in对象添加到当前组件实例中。其他组件实例不会受到影响。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajt"><img src="../Images/1bf883fae517ea8fdab9e1fcb1807f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg78CriuiRvKs6Tk6FOAJg.png"/></div></div></figure><p id="7cf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们希望所有组件接收相同的mix-in对象，我们可以使用mix-in方法。这个方法来自app对象。它将混合对象发送到所有组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alh"><img src="../Images/8b89a643e1c4f1295b19e748a60bdc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adArh7Yhfxijvolu77x_pg.png"/></div></div></figure><p id="dc40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">mix-in方法仍然返回app对象。我们可以将挂载方法链接到它后面。</p><p id="af8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将学习Vue自定义指令。</p><p id="200a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue指令基本上是Vue提供的虚拟HTML属性。它们被插入到HTML标签中，从而允许我们直接控制页面元素。</p><p id="affc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，V-IF指令安装在H1标签中。我们可以用它来移除和安装H1标签。V IF指令可以在其他地方重用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vv"><img src="../Images/40293fffeb8e0cc01f328befa2c4a87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGzl8wW_Jx5yoLKTdDguXQ.png"/></div></div></figure><p id="2f72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过创建我们自己的Vue指令，我们可以定义定制的DOM操作。我们的自定义DOM操作可以很容易地在其他地方重用。我们甚至可以同时控制几个元素。</p><p id="9e86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有两种类型的Vue指令:本地和全局。</p><p id="3a14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<em class="np">指令</em>选项定义本地指令。</p><p id="c175" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们选择一个指令名，然后给它分配一个对象或者一个函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ali"><img src="../Images/eb0adc3e767e3ee797bd44e5533e330f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ltgsTS8TejpVk5zNCSriw.png"/></div></div></figure><p id="1e93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">全局指令是使用来自应用程序实例的指令方法定义的。所有组件都可以平等地访问它们。</p><p id="e104" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个参数是指令名。第二个参数要么是对象，要么是回调。我们将首先尝试对象语法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vg"><img src="../Images/c6fd440ed9f860a43b61f5cf4298c18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*538GBwGLUiOH3Em-b2LLwQ.png"/></div></div></figure><p id="cd27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个对象给了我们定义7种钩子函数的空间。它们是在装载和装载之前、更新和更新之前、卸载和未计数之前创建的。指令挂钩与Vue生命周期挂钩相同，只是不包括beforeCreate挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alj"><img src="../Images/9ccbeecbb615c66d1afe3902a76db3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNmQBIEDtRNchr2HspsTEg.png"/></div></div></figure><p id="1606" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">创建</em>这里指的是自定义指令的创建。<em class="np"> Mount </em>表示被挂载到绑定页面元素的自定义指令。<em class="np"> Update </em>表示被修改的绑定元素。</p><p id="9202" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个指令钩子函数接收三个参数:el、binding和Vnode。El代表元素，它指向绑定元素的DOM对象。它使我们能够执行DOM操作。</p><p id="7558" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">绑定是一个对象。它存储传递给指令的外部信息。VNode指向绑定元素的VNode对象。</p><p id="5a2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">VNode对象是HTML DOM对象的Vue等价物。这是内部使用的。我们不需要访问或修改它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alk"><img src="../Images/4f5d1af8aa0b01b9b2847863f2160fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ux4blW4uvLW-YXDkYiFBZw.png"/></div></div></figure><p id="cc0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们在H1标签中安装自定义指令。所有的Vue指令名称都应该以字母v为前缀，我们的自定义指令也不例外。</p><p id="cf75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指令被视为HTML属性。大写字母需要转换成小写字母，并以破折号为前缀。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi all"><img src="../Images/0bb44934427d5c8f7e9ae395975a9f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZqTzcVDz9k_nb9r2NwqtQ.png"/></div></div></figure><p id="afe4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们的自定义指令已经安装到H1标签上。让我们刷新页面。</p><p id="4099" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到三个钩子函数都被触发了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alm"><img src="../Images/f175189847f8178bebfa0595c4490bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjqeksdV_StAzGU2vE0PJA.png"/></div></div></figure><p id="984f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们看看传递给指令钩子函数的参数。我们使用创建的钩子作为例子。</p><p id="82f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们控制台记录所有三个参数。我们还检查它指向哪里。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sq"><img src="../Images/0c8231bbe0a91a4fdb03e0a62328bc18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*ms3VIwqL6xQeQecGenCC2A.png"/></div></figure><p id="96dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个参数给出了绑定元素的DOM对象。我们可以通过它执行各种DOM操作。</p><p id="4750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">绑定对象使我们能够访问传递给指令的外部信息。DIR属性列出了指令拥有的所有钩子函数。instance属性指向使用该指令的组件实例。其余的属性存储传递给自定义指令的信息，包括参数名称、旧的和当前的指令值以及修饰符。我们稍后会处理它们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vv"><img src="../Images/17a032e2b856f1f300cc5bd77e0a2673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzaqCkW6Zi5k7-h56mEa-w.png"/></div></div></figure><p id="d65c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三个参数给出了H1标签的VNode对象。</p><p id="0926" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个in指令钩子函数指向窗口对象。由于指令挂钩不依赖于此，我们可以使用arrow函数来定义它们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aln"><img src="../Images/eefcc2d0ca5de5c8cd82be234d688233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pffJd4VZf322PstHifpQeg.png"/></div></div></figure><p id="bad8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们添加两个卸载挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ahx"><img src="../Images/3e2ed7e65ccdc9e829a2de4ac09fb3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnUDu7QIqoY1ysrgggzBMw.png"/></div></figure><p id="ad43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当绑定的元素被卸载时，它们将被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abj"><img src="../Images/f505ead0427cff9a20d8825e86b44db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbmDVWAUJXblD042prNt6A.png"/></div></div></figure><p id="981c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在只剩下两个更新挂钩了。我们将在本地指令中尝试它们。</p><p id="641c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">指令</em>选项允许我们定义任意多的本地指令。</p><p id="5ef4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将本地指令命名为<em class="np"> trackUpdate </em>。我们仍然使用对象语法。</p><p id="3014" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个更新钩子函数是特殊的。它们都有第四个参数，即更新前vNode。前三个论点和前面一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ty"><img src="../Images/9a9e0177e780761d376798c29f833fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Baz1tc_0jUePM5BpAg-p7g.png"/></div></div></figure><p id="3795" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用本地指令替换全局指令。别忘了V字头。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajw"><img src="../Images/268ba393935677e8c5b3502825211b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuzJyiGujcdpNGw3umt_Vg.png"/></div></div></figure><p id="6f66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="ff53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置title属性来触发两个更新挂钩。</p><p id="0f61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到前两个论点和之前一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agc"><img src="../Images/b3ca555fcad5daad91ed6de76949c40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpHGGlv5rakUiKyRQSBnSg.png"/></div></div></figure><p id="47a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试第三和第四个论点。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi alo"><img src="../Images/0401154cd4e989f2f5f446bc13b10000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*G-uXfXwhVu-EZU4SgxJYCw.png"/></div></figure><p id="6bb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置标题值来触发两个更新挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alp"><img src="../Images/b513fd8dcaaa408885d09982c50af694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_zo29JfOxJvE4KqVGTY4A.png"/></div></div></figure><p id="97b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三个参数返回更新后的vNode。它的children属性存储新的标题值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi alq"><img src="../Images/d3b36f339993add8b873e594f0939afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*MKghxj5vEF3q84fvSyj4_Q.png"/></div></figure><p id="c09e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第四个返回前一个vNode。它的children属性存储以前的title值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi alr"><img src="../Images/cf773b14b3a834c72c1b0675952761df.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*uqkJaWoPNDwIdQbp7KVefg.png"/></div></figure><p id="490c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建一个新的本地指令。这一次，我们使用函数语法。指令挂钩不依赖于此。所以可以用全功能或者箭头功能。这次没关系了。</p><p id="2ef4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指令函数将作为两个钩子使用:挂载和更新。我们将指令安装在H1标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi als"><img src="../Images/57e831d737c54eaa1c03b6b71b4889d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DroOms_CUuMLsBoWxXy7Cg.png"/></div></div></figure><p id="80b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。指令功能已被触发为挂接。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alt"><img src="../Images/71d88cb7a5d9236389f73cbc29c47449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQi_l0xp7ODz6DcX3VCldw.png"/></div></div></figure><p id="e573" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过修改H1标签再次触发它。</p><p id="c46d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，它被触发为更新的钩子。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vc"><img src="../Images/0d463137eeed6535d27afdbf19170832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eODn_8v-Q56hSbEuSE4skQ.png"/></div></div></figure><p id="7c9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">挂载和更新的钩子实际上是最常用的方向钩子，可以满足我们的大部分需求。</p><p id="a94a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们仔细看看第二个参数:绑定对象。顾名思义，binding对象存储绑定到自定义指令的信息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agi"><img src="../Images/32f9f67b1a126ffbbedfe53d5e09d8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXkubp8uZg_udkHUzQ8llg.png"/></div></div></figure><p id="d810" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数语法只包括挂载的和更新的钩子。所以dir属性只有挂载和更新的钩子。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sw"><img src="../Images/45e4f842ded03550184d6a0d759ecb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WkpfHvWsa9L6LrLd8recw.png"/></div></div></figure><p id="dbde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">instance属性指向安装自定义指令的组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agd"><img src="../Images/f5e4c825d0374861b8055766c7fb2031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylTs_E9YMjrldC-0qYIHvQ.png"/></div></div></figure><p id="e387" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue指令可以有一个参数。参数名存储在ARG属性中。当前参数值本身存储在<em class="np">值</em>属性中。oldValue属性存储前一个参数值。</p><p id="6c15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指令名和参数名用冒号连接。我们可以使用一组方括号来设置动态参数名。</p><p id="bbb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件数据选项中，我们将参数名定义为<em class="np"> info </em>。现在，通过更改<em class="np"> arg </em>数据属性，我们可以更改自定义指令的参数名称。这给了我们一个额外的位置来存储信息。</p><p id="dbb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在指令参数后面，我们可以使用点符号链接修饰符。</p><p id="f4ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们使用description属性作为指示值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alu"><img src="../Images/8b9597da14d8c54bec04926a2d90f54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBUVidQDweZKs7hCIab3xw.png"/></div></div></figure><p id="c851" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重新加载页面。</p><p id="ec1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到传递给自定义指令的所有外部信息都可以在binding对象中找到。我们可以找到指令参数名以及当前和以前的指令值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akh"><img src="../Images/b7eabb78d7fbead8f2be2c71b5eb7977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oxqlajYmp6-E9mL2z75AQ.png"/></div></div></figure><p id="34de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们重置自定义指令的值，更新后的钩子也将被触发。</p><p id="d57e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在绑定对象中，我们可以找到新旧指令值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alv"><img src="../Images/80b1f5adab8477ad93a5d1a50dd1b8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtZpH9t-iHekF4K44bsOrA.png"/></div></div></figure><p id="8110" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，如果我们重置参数名，更新后的钩子也将被触发。ARG属性存储新的参数名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yr"><img src="../Images/ed0d2c3327feb890fd4a1d01fef478dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NrhKWaYQmn2v8fEOc1nIw.png"/></div></div></figure><p id="d1f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果需要向自定义指令传递几段数据，请使用对象设置其值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alw"><img src="../Images/ced067c92e79af5e32adfc0d4cc682ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQNfQjphRwI6KcaGBOLLvA.png"/></div></div></figure><p id="f74a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们移动到一个新文件。该文件有一个子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alx"><img src="../Images/1d6abcf7eb695c96501ef9abc77223ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9RsBQxVwDpTRXQ6Q9FlZYA.png"/></div></div></figure><p id="b091" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">local指令是在根组件中定义的，因此它只适用于根组件模板中的元素。从技术上讲，子组件标签是安装在根组件模板中的标签。那么我们可以在子组件标签中安装本地指令吗？让我们找出答案。</p><p id="c58e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将本地指令移到子组件标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aly"><img src="../Images/a80a87c6c28a80283512c7bb70c6498f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*C3vkMTOjprwEcpmR0SkcVg.png"/></div></figure><p id="8404" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它起作用了。安装的挂钩已被触发。</p><p id="e837" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个参数EL返回子组件模板的DOM对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alz"><img src="../Images/c47712462376d536b72a3ecd937b4130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6WdQ8JBoXx7VXjvQAe7F3g.png"/></div></div></figure><p id="3d72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">绑定对象的实例属性仍然指向根组件实例。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acy"><img src="../Images/d42c91e8e0f0a9d11f2395c178bcfa1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1chB02nonRRpYshkdNraGw.png"/></div></div></figure><p id="8b78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件的模板只有一个元素。让我们在不设置根DIV的情况下向它添加第二个元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7bc0198af92343365d9253faa4aec9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*hbuQr7-bC61Eh7IHRQLGEA.png"/></div></figure><p id="7553" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重新加载页面。</p><p id="f211" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们收到了警告。该警告是由子组件的模板没有根节点引起的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ama"><img src="../Images/9660fb90c9a86f337376f0b2dcedb3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2JzLtyiqGf94jJqXfE4ug.png"/></div></div></figure><p id="0d6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自定义指令不同于其他非属性，我们不能控制哪个元素继承它。</p><p id="b374" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使我们关闭子组件的属性继承，我们仍然会得到相同的警告。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amb"><img src="../Images/ce39ae9f7089879dbc2cf63ad782548f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbILQ_VRkCk8SNwBJtjE2A.png"/></div></div></figure><p id="e0ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案是为子组件的模板设置一个根DIV。</p><p id="b2eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，第一个参数EL返回给我们整个子组件的模板。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amc"><img src="../Images/abadd06ff88a3e3d590dbbe6926ecdf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGaGLZZO14ZmwNETfTd__Q.png"/></div></div></figure><p id="8201" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上两节课中，我们已经学习了自定义指令的基本语法。在本课中，我们将向您展示自定义指令的实际应用。我们将创建一个自定义指令来帮助我们控制所选页面元素的CSS样式。</p><p id="87cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们创建一个输入标签。我们将它的类型设置为range。然后我们设置一个最小值和最大值。使用v model指令，我们将输入标签连接到size属性。</p><p id="862c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们转到数据选项来定义size属性。我们将其值设置为30。</p><p id="d3e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以通过向左和向右滚动按钮，在15和100之间重新设置大小值。</p><p id="9217" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">滚动到右端，<em class="np">尺寸</em>值将增加到100。滚动到左端，大小值将减少到15。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yn"><img src="../Images/0cc23ecef20efd4c576e2c952d7ad91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZBBSM1u9qM9yt8p0AYRHA.png"/></div></div></figure><p id="8724" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们想使用滚动按钮来控制任何选定页面元素的文本大小。这要求我们定义一个自定义指令。</p><p id="e88e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们称app点指令为定义全局指令。我们把它命名为<em class="np">调整</em>。</p><p id="9d7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用函数设置第二个参数，因为我们只需要更新的钩子。我们记录第一个参数。然后我们控制台记录绑定对象的value属性。value属性存储当前指令值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wl"><img src="../Images/b1df0a95e1ff6387386fcf7d141263df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRkTBgxkJJbKI0hOz6wpsA.png"/></div></div></figure><p id="ea92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在P标签中安装了<em class="np">调整</em>指令。我们使用size属性作为指示值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zj"><img src="../Images/c772bbab4efa2afd4eb699040caa1b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrvcgZnv4-Q_Yd1jLaR9jw.png"/></div></div></figure><p id="1f44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="71ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们得到了P标签的DOM对象和size属性的值。</p><p id="c25d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们滚动按钮，我们将更改size属性的值，这将触发自定义指令的更新挂钩。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akt"><img src="../Images/e43e88baf399219c3fbeffd9b1e02bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPa_d5boWiborGH_ifd_oQ.png"/></div></div></figure><p id="33d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有什么灵感吗？</p><p id="c9fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在自定义指令中，我们通过第一个参数EL访问CSS fontSize属性。</p><p id="acb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们使用指令值重置fontSize属性。记得在参数值后面加上PX。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rj"><img src="../Images/007de021e400aa1c5e775540f2e8b00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O58arOkTNwFpw575EM2tLg.png"/></div></div></figure><p id="387c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="0ae2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过滚动按钮来控制P标签的字体大小。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yo"><img src="../Images/874a329626014631287e0d44bbeb03de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfXUjlgtetAtLfmMaV2N8g.png"/></div></div></figure><p id="acdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自定义指令允许我们重用DOM操作代码。我们可以将<em class="np"> adjust </em>指令添加到根模板的其他元素中。这里，我们将<em class="np">调整</em>指令复制到P标签中。</p><p id="7e0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以一起控制H1和P标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yn"><img src="../Images/8e14384604f479fe0aa34fff4fe2e6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTr5RLjobtJuSkOeMWhnjg.png"/></div></div></figure><p id="176b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">adjust指令是一个全局指令。它在子组件的模板中也是可见的。</p><p id="6592" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们可以将它添加到H2标签中。</p><p id="2064" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是有一个问题，adjust指令的值是使用属于根组件的size属性设置的。它在子模板中不可见。</p><p id="e9b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到我们得到了警告。它说无法从子组件实例中找到size属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amd"><img src="../Images/47f9eec2d9f855b641b648fcd61e1665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QNSHpbdvaWCDeceQVfnyg.png"/></div></div></figure><p id="a11b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们用来重置size属性的输入标记也来自根组件。<em class="np">调整</em>指令不是完全独立的。它是全局可见的，但是只有根组件可以提供它所需要的一切。</p><p id="32b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了控制子组件的字体大小，我们可以在子组件标签中安装adjust指令。size属性在这里是可见的。但是这也要求子组件有一个根DIV或者只有一个元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ame"><img src="../Images/0c530814fa5e30b044a2e9a901d5774a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Emf6iHsAXDnpf6FrkPF4uQ.png"/></div></div></figure><p id="4b18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，现在我们可以同时控制三个段落的字体大小。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amf"><img src="../Images/a8f4933b3650944cfa72722daf5c37fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFB-55eMoPY_DOb3k1pDJA.png"/></div></div></figure><p id="3cfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们向<em class="np"> adjust </em>指令添加另一个特性。</p><p id="f5f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，我们有三个HTML标签:h1、h2和p。它们都是块元素，这意味着我们可以控制文本对齐。我们希望使用adjust指令来控制文本对齐。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi amg"><img src="../Images/27e87e4d3b2a02884d14f1085c335e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*Cq5UQxLa_80BmzGHYqgV-g.png"/></div></figure><p id="f699" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了另一个输入标签。我们将它的类型设置为无线电。</p><p id="fa04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将其值设置为left。我们将输入标签连接到<em class="np"> align </em>数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amh"><img src="../Images/e64d3e3db2e9e3dc717c5a617d19f442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6gl_8NKBYBKiOtSPpO08w.png"/></div></div></figure><p id="9dd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们制作了输入标签的另外两个副本。我们将它们的值设置为居中和向右。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ale"><img src="../Images/bcc3472538f94e1d1c68b5b4010c433c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DE65NMxUNpCr5bSuPDr_KA.png"/></div></div></figure><p id="56bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件的数据选项中，我们添加了<em class="np"> align </em>属性，并分别将其值设置为left。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ami"><img src="../Images/5f543b946c267b1020541b04380aea8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ehqw734zK-R8ys28N4bbg.png"/></div></div></figure><p id="436f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以通过单击三个单选按钮之一来重置align属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi amj"><img src="../Images/db2795ce2461b20e9296664e59659b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*hYNNpI-LCr_vQrcEQvaiJQ.png"/></div></figure><p id="4576" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了使用这三个按钮控制文本对齐，我们需要将<em class="np"> align </em>属性的值传递给adjust指令。</p><p id="48e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">adjust指令已经有一个值。它的当前值存储字体大小。它的当前值存储字体大小。要将对齐方向添加到指令值中，我们需要使用对象来设置指令值。这样，我们可以在指令值中存储两条信息。</p><p id="d14a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像我们之前说过的，Vue指令可以在两个位置存储外部值:指令值和指令参数。</p><p id="91c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用指令参数存储align属性的值。这样，我们可以保持当前的指令值不变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amk"><img src="../Images/4284aad91a79b15ac7f256c891cc8cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*457H-JlE47iY5D-sMF5U1Q.png"/></div></div></figure><p id="d41f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在directive函数中，我们可以通过binding.ARG访问<em class="np"> align </em>属性的值。我们使用它来控制接收adjust指令的元素的文本对齐。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alp"><img src="../Images/0034737dec339e624d06f1611796e324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qXSPzfoILc3r_G-btZIJw.png"/></div></div></figure><p id="e2f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以使用三个单选按钮来控制文本对齐。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aby"><img src="../Images/216d888b120afa59452599fce97c602f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHfFOnrKwSsYm5vDSUjRng.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qf"><img src="../Images/85efbdb8ba7e6da33def26a6658ffe92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flelEfEqt2hS7YOzZ44euQ.png"/></div></div></figure><p id="f8e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您的实际项目中，如果您需要一起控制几个页面元素，那么自定义指令通常是最好的解决方案。</p><p id="026c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这节课开始，我们将学习渲染函数。它使我们能够以编程方式生成页面元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aml"><img src="../Images/01c0ffca81146f70f33f9b4721204001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvnEG1nM4vU7My2PKsRQcw.png"/></div></div></figure><p id="2ad5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开Vue API向下滚动，你会发现一个名为H的方法，H方法就是我们用来生成页面元素的。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju amm ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/216d874051a4cdf8e91a859fdc5b6b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*Hr4VNdL3BvdTdTtb3GNPvA.png"/></div></figure><figure class="ahn ju amn ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/2fd323259aa0ea66e226c1a27e2ca10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*s_vDYKw784-sZOM8OdbBGQ.png"/></div></figure></div><p id="af08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们以chid组件为例。我们删除它的模板选项。我们将使用H方法重新创建同一个模板。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amo"><img src="../Images/90795c3b655505da710bff179b5203a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojSko7f87SGveiHiPXluMQ.png"/></div></div></figure><p id="df15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H方法不能单独工作。它需要一个由渲染选项创建的外部环境。</p><p id="65f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用工厂模式设置渲染选项。我们必须给渲染选项分配一个完整的功能。不要在这里使用箭头功能。我们需要它指向组件实例。</p><p id="37b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在render函数中，我们返回H方法。在Vue 2中，H方法作为回调传递给了render函数。在Vue 3中，我们通过Vue api访问它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ain"><img src="../Images/ea3a486741ee856ddb0864544deefc50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*QPgSUQn8UTqfTwf47Zk9ZQ.png"/></div></figure><p id="3c40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H方法通常需要我们为它设置三个参数。第一个是我们想要创建的HTML标签的名称。</p><p id="bca4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个参数是options对象。这里定义了新创建的DIV标签的属性。属性名用作属性名。我们希望DIV拥有<em class="np">子</em> CSS类，所以我们将属性名设置为<em class="np">类</em>，属性值设置为<em class="np">子</em>。</p><p id="fd9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三个参数通常是一个数组。我们在这里定义子元素。每个子元素都是一个H方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amp"><img src="../Images/7891e06642065a9dc9ee1ff23cc49f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rx9WlGzfUI-9rBCqo_jFRw.png"/></div></div></figure><p id="4fd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是原始子组件模板没有根DIV。子DIV和H4标签是兄弟。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/05c7906ac97a247f0129a202df446a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8bJ3k6J7VDFolW11FUn_w.png"/></div></div></figure><p id="71f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们不直接返回H方法。我们返回一个数组，并在其中设置两个H方法。第一个用于子DIV，第二个用于H4标记。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ale"><img src="../Images/ea2dcd437e45d1c6ad27d3ede3212dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-XNIZEtmM9Q3UjkeA0DfQ.png"/></div></div></figure><p id="459b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H2标签没有属性。我们使用一个空对象来设置第二个参数。H2标签的文本内容来自title属性。我们使用<em class="np">这个点标题</em>设置第三个参数值。为了指向组件实例，我们需要使用完整的函数来定义呈现函数。我们不能使用箭头功能。</p><p id="5dcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于H3标签，我们用同样的方法设置它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amq"><img src="../Images/f11881a2d46cad97443106c5e84a24d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZbK9-txPlsn31c6lE5rBg.png"/></div></div></figure><p id="56b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们设置H 4标签。</p><p id="bc8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H4标签有内嵌的CSS代码。在options对象中，我们使用<em class="np"> style </em>作为属性名，并为其分配一个对象。我们在对象中定义CSS属性。以破折号为前缀的字母应该大写。</p><p id="3421" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H4标签的文本内容被包装在一个<em class="np"> i </em>标签中。我们使用另一个H方法设置第三个参数，该方法呈现一个<em class="np"> i </em>标签。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amr"><img src="../Images/3454cba3ca6c053ca2b7c53437b9f0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfmOd_xxxduhfWDyL9OT3w.png"/></div></div></figure><p id="2994" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经使用render函数重新创建了子模板。让我们刷新页面。</p><p id="f38e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到结果和以前一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yl"><img src="../Images/c849d554e7336cf492cd77ffd0dc3698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i72ooulNGjzTLfu_lGhn2A.png"/></div></div></figure><p id="740e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们快速总结一下。</p><p id="2a61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H方法的语法非常简单。设置需要三个步骤。首先声明您想要创建的标签。然后设置一个选项对象来设置该标签的属性。最后，使用第三个参数来设置新创建的标记的内容。</p><p id="dad1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们呈现根组件的模板。这里的事情有点挑战性。子组件安装在根组件中。如何渲染子组件标签？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ams"><img src="../Images/4e7e4798a7fdd1599f151a66af75d680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igTeQMHJsZCBNsGKiBHtLg.png"/></div></div></figure><p id="06e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开Vue API并向下滚动，您会发现四个名称以resolve开头的方法。resolveComponent方法是我们需要的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yr"><img src="../Images/4c4d049c1a837b22e016b73e888be2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKFyxgAF7W3vHguS5qIPbQ.png"/></div></div></figure><p id="8898" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到根组件的options对象。我们添加了渲染选项。根组件的模板有一个根DIV。所以我们直接返回H方法。我们在H方法中呈现父DIV。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wi"><img src="../Images/d381fb5170876fe8b01de4bc6ceb4bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctAo5Y0PZ3TCzBQm0Bt5uA.png"/></div></div></figure><p id="55c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">父DIV有四个子元素。我们需要一个有四个元素的数组。</p><p id="bf6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前三个元素非常简单。他们只是H标签。我们甚至不需要设置任何属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amt"><img src="../Images/d25a10c55a392ec8b9eaafbf1378af30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYiv13oyXjiqHAlgYijAOA.png"/></div></div></figure><p id="afe7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一个元素是子组件标签，我们仍然使用H方法来呈现它。我们使用resolveComponent方法设置它的第一个参数。我们将子组件的名称传递给resolveComponent方法。现在，将呈现子组件标记。</p><p id="37d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件有一个道具。道具还是属性。我们将它们设置在H方法的第二个参数中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qk"><img src="../Images/0f9d8f9c2b4c8f6c8c8a36d19cf5c63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqApwOsSiXtIoH5xfiBrMQ.png"/></div></div></figure><p id="f172" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，render函数已经重新创建了整个父DIV。我们删除原始的父DIV并重新加载页面。我们可以看到结果和以前一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ams"><img src="../Images/96bbab7b7d78a0e623237695b596d25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xp04reBETSfEh0OVE_7KAA.png"/></div></div></figure><p id="eab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们在呈现的组件标记中设置一个非属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wz"><img src="../Images/f4e4b00845860cfb36e8c7517cd6a8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4Bj9G-kJbmC8Leczge0Sw.png"/></div></div></figure><p id="d896" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">子组件没有根DIV。因此，不能自动继承非属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vu"><img src="../Images/40c2a9b33a12297e6cb90f6543092089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6AXFBZ_DVKPLlj6GFfmvQ.png"/></div></div></figure><p id="2e15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到子组件的options对象，并关闭属性继承。</p><p id="fff0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们手动分配非prop属性。我们希望H2标签继承它。所有非道具属性都存储在<em class="np">这个。$attributes </em>。</p><p id="f386" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，来自子组件的H2标签已经从呈现的子组件标签继承了标题属性。请记住，所有与属性相关的设置都是在H方法的第二个参数中完成的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yx"><img src="../Images/16d458a06ff51f01d7167a3b4e7f4c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UfLdKjwYD5EvhBmjxjsYQ.png"/></div></div></figure><p id="7de4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将向您展示如何渲染插槽。在开始本课之前，请复习一下命名和限定作用域的插槽。</p><p id="5649" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根模板有四个子元素。他们都是兄弟姐妹。让我们将H2和H3标签移到子组件标签中。</p><div class="la lb lc ld gt ab cb"><figure class="ahn ju amu ahp ahq ahr ahs paragraph-image"><img src="../Images/e8563ac702494beda322ad10ba9b9102.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*x7N7U64r2hvC3uoSUIPyEg.png"/></figure><figure class="ahn ju amv ahp ahq ahr ahs paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/33d30289e26a5cebb7f48e79bc2afb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*NkH2s_X35kAbfmfLR65f5A.png"/></div></figure></div><p id="05df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件的模板中，我们添加了一个槽来显示它的子元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uf"><img src="../Images/cf442bf41f9b686d276c411e83d12a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXiVGPw0gmX34Gii3_ZgZg.png"/></div></div></figure><p id="7047" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么我们如何渲染插槽呢？</p><p id="444d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们找到了呈现子组件标签的H方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amw"><img src="../Images/0aa8ae8f2c93b954738f394f35beab38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFbaDk8f34vIT0Ds9dTTGg.png"/></div></div></figure><p id="e7e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们向它传递一个数组作为它的第三个参数值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pm"><img src="../Images/ac3f72f60d880c6a811139f5bc10bff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeZUseRIDnCfMX656qXAHQ.png"/></div></div></figure><p id="983e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将上面列出的两个H方法移到数组中。现在，H2和H3标签嵌套在子组件标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uc"><img src="../Images/b6017ec36e581c6eb7e0af10d81464eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khexuOCsxibdhkB9Nt1ycQ.png"/></div></div></figure><p id="df44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到子组件的render函数。我们希望将插槽放在H2和H3标签之间。</p><p id="f702" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在H2和H3标签之间，我们添加了一个新的H方法来呈现一个空的DIV。这个DIV将用于容纳插槽。为了更好地跟踪它，我们给它一个标题。我们使用<em class="np"> this设置DIV内容。$slots </em>。</p><p id="edd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们渲染插槽的方式。与其他标签不同，我们不呈现slot标签本身，我们创建一个外部DIV并使用分配给slot的内容设置外部DIV的内部内容。</p><p id="a287" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="0e39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到该插槽已成功创建。根组件中的H2和H3标签现在显示在子组件中。它们嵌套在slots DIV中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amx"><img src="../Images/a16a992cef43f10338e9552a20169407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCgpUPsXxcIqf8avDedW5A.png"/></div></div></figure><p id="e457" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在使用的插槽没有名称，它被视为默认插槽。<em class="np">这背后。$slots </em>，我们可以附加默认的方法来标记它的身份。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abq"><img src="../Images/04568665b2d0077c334cd1ccea4846fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFvdKGHrAcTN7c2L02GYSw.png"/></div></div></figure><p id="c827" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在控制台桌上，有一个警告。它表示默认插槽遇到了非函数值。为了获得更好的性能，我们应该使用函数槽。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amy"><img src="../Images/49b2577bfb8a4ef0e40d2400006c3000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7lx_eLn5iHkqGBB3UOTLQ.png"/></div></div></figure><p id="8f97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们找到了呈现子组件的H方法。我们用一个对象替换数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amz"><img src="../Images/67155e5e91e00c8ac88aa8776476bab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZM_Nuf9gCkULTfeo-sitA.png"/></div></div></figure><p id="bc01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在对象中，我们添加了<em class="np">默认的</em>方法。在默认方法中，我们返回原始数组。</p><p id="d1d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">默认</em>方法对应默认槽。它帮助Vue将内容映射到正确的位置。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abn"><img src="../Images/6bd11a3b4a94daa99911502d15309ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gYptX4RBdzuLPUc8ykGI3g.png"/></div></div></figure><p id="a5c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，警告消失了。呈现的HTML代码和以前一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ana"><img src="../Images/5ad108201a2df0511a6ef822c9635c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kngz2efbcz4QrtX5T8ophQ.png"/></div></div></figure><p id="f8e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以默认方法呈现的元素将被发送到默认槽。我们用H方法替换返回的数组。我们呈现一个H2标签，并使用根组件的title属性设置其内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ws"><img src="../Images/5400aeafd2c089e842b81f1e78400e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrPIG41qhWkEWhIt45gbLw.png"/></div></div></figure><p id="fe95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在默认方法下面，我们添加了一个author方法。</p><p id="a30f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作者方法对应于作者槽。我们呈现一个H2标签，并使用author属性设置其文本内容。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi als"><img src="../Images/85f6bf453650f80eab7f7f377c954a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXCEy8SNYx-zh_u2pt7aKQ.png"/></div></div></figure><p id="0029" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们添加一个book方法。我们呈现一个H3标签，并使用book属性设置其文本内容。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anb"><img src="../Images/c771902c50c158c4dba0852396e155be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bS6s60_J3-6W7GykLAj1NQ.png"/></div></div></figure><p id="a700" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们给作者位置分配了一个H2标签，给图书位置分配了一个H3标签。</p><p id="5069" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到子组件来创建作者和书籍插槽。</p><p id="77d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们制作了默认插槽的两个副本。</p><p id="0938" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将第一个副本的方法名改为author，将第二个副本的方法名改为book。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ty"><img src="../Images/c95ee68faa51cc17c0a848b840638bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FUAFNQfhGCOP7Teyx9YSw.png"/></div></div></figure><p id="b589" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查程序。</p><p id="00ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到两个命名的插槽已经成功渲染。他们收到了分配给他们的元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afb"><img src="../Images/3eca84486ee2e3b6f47b75dc0f087940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4czID6M2jVLhIRXedyVWg.png"/></div></div></figure><p id="c764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们试试作用域插槽。作用域插槽允许我们向后发送数据，这意味着我们可以将数据从子组件发送到属于父组件的插槽区域。</p><p id="8174" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件的数据选项中，我们有一个名为realName的属性。我们想把它发送到author槽，并显示在author属性后面。</p><p id="b526" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们呈现author插槽时，我们将一个对象传递给author方法。在对象内部，我们添加了realName属性。我们使用<em class="np">这个点realName </em>来设置它的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vt"><img src="../Images/019060d82099aeb602669b80998ffb96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2XKxxfYihT-vXfP3nkIMgQ.png"/></div></div></figure><p id="a084" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到根组件并找到author方法。我们传递给$ <em class="np"> slots.author方法</em>的对象将被传递给author方法。因此，我们可以在H方法中访问realName属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anc"><img src="../Images/23e275b2d00eb7543d93cd6fdd17e151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2tA7EFwH7dHmBCGYEeVhA.png"/></div></div></figure><p id="271b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="6b6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在作者名字后面，我们得到了真实姓名。我们现在在同一行显示一个根组件数据属性和一个子组件数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amy"><img src="../Images/143dd2fa8095ff888b62549cce529876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wb8QHxOd4f1MOIFZeKj1yw.png"/></div></div></figure><p id="9c44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将向您展示如何呈现Vue的内置指令。</p><p id="c61a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在数据选项中，我们定义了一个列表属性。它的值是一个数组。</p><p id="1fb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用V FOR指令，我们可以遍历数组并输出每个元素。</p><p id="de73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果数组为空，V IF和V ELSE指令将用P标记替换该列表。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi and"><img src="../Images/9d415abee1cf34a57432c8cbb50e15cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgNv3jBt5q9h0L7mwMvqUw.png"/></div></div></figure><p id="b410" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用render函数重新创建这三个指令。</p><p id="5b14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将渲染功能添加到选项对象中。</p><p id="fe1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先添加一个IF语句来检查数组长度。如果它不为空，我们将呈现一个列表。否则，我们渲染一个P标签。</p><p id="abe5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将错误类分配给P标签，并将其文本内容设置为<em class="np"> no item found </em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ane"><img src="../Images/25105b8b0fac85189356cdb6226859ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HS-nim6XnXwmUTC743ZNfg.png"/></div></div></figure><p id="2ca4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了呈现列表，我们首先呈现UL标签。</p><p id="cede" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用map方法设置它的子元素。它遍历数组并对每个元素执行相同的操作。</p><p id="2e6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在map方法的回调中，我们返回H方法并呈现一个LI标记。</p><p id="1d8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个LI标签都应该有key属性。我们使用元素索引设置键属性的值。</p><p id="f49b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用元素值设置LI标签的内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pn"><img src="../Images/3b4197cdab75a20f6226393adb3d6867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6EEgpcQS1GxJsKdu5T8yQ.png"/></div></div></figure><p id="a369" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="5a70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到一切都在按预期运行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/6cd8d2d6467e4cf051951790f557e70c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddUQgzYpGMQNzF2UHA1AIw.png"/></div></div></figure><p id="3ef2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用V model指令，我们可以在输入框和数据属性之间创建双向连接。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anf"><img src="../Images/459966f65483ee43a058dcfb6796d8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jOT5saoNVD22_ErhXPISA.png"/></div></div></figure><p id="581a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将向您展示如何呈现v模型指令。</p><p id="27c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根DIV中有两个元素:一个输入标签和一个P标签。</p><p id="c62b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在render函数中，我们返回一个数组，并在其中设置两个H方法。</p><p id="4547" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第二个H方法中，我们呈现P标签。我们使用message属性设置它的内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ang"><img src="../Images/ca6874784dd38285517080005db7ca72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcYz15ATABbLZhb7bt2vYQ.png"/></div></div></figure><p id="35f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入标签依赖于它的属性来工作。</p><p id="9a27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先使用消息属性设置它的值属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi act"><img src="../Images/c3da2af9aa78c87c422f4e44ba99bcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4LrLul9FE6wMbZJQyCFTqQ.png"/></div></div></figure><p id="50bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们需要监控输入事件。我们使用onInput方法。</p><p id="2ad3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">onInput方法将接收<em class="np">$事件</em>对象。</p><p id="25c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<em class="np"> $event.target.value </em>重置消息属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vg"><img src="../Images/912b159255b35bab01123827282fc50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0533opAdKI77MwRnqejCQ.png"/></div></div></figure><p id="0c66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经手动呈现了输入标签。</p><p id="67ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的工作原理和以前一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anh"><img src="../Images/e82dc5d3cdf30b70c2346c78a996e4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIx-rJQ969wS0U8thksSPQ.png"/></div></div></figure><p id="d8cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将向您展示如何呈现安装在组件标记内的v模型指令。</p><p id="6c83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有两个输入标签，一个在根组件中定义，另一个在子组件中定义。这两个输入标签总是同步的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agf"><img src="../Images/5dfcaaa746443e1ecdf80614d0ea63c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUArVVfr53gj3iatFgPbuw.png"/></div></div></figure><p id="d35b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">V model指令实际上是一种语法糖。它将被扩展成一个<em class="np"> v bind </em>指令和一个<em class="np"> v on </em>指令。道具名为<em class="np">模型值</em>，事件名为<em class="np">更新:模型值</em>。</p><p id="442e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件中，如果我们将属性<em class="np">模型值</em>和事件<em class="np">更新:模型值</em>，我们将能够在子组件标签中使用<em class="np"> v模型</em>指令。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alh"><img src="../Images/42626c31fe27a3250355415fe9eba1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCBjAQm24qOKn5GSdGoQdg.png"/></div></div></figure><p id="a16e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先呈现根组件的模板。我们有三个要素。我们用三个H方法返回一个数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ani"><img src="../Images/55b61a8ec97991fb9266ee5244981a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyI3qHDpYNN8GtWZdcEJjw.png"/></div></div></figure><p id="b74e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个H方法中，我们呈现一个输入标签。在options对象中，我们使用<em class="np"> this.message </em>设置value属性。然后我们添加<em class="np"> onInput </em>方法。我们将<em class="np"> $events.target.value </em>分配给<em class="np">这个点消息</em>。现在，根组件的输入标记已经完成。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anj"><img src="../Images/30033ce05e6b9667c5bd939ec62b0404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiVVyUrLi9-46JHu5HRudQ.png"/></div></div></figure><p id="6908" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第二个H方法中，我们呈现一个HR标签。</p><p id="aa3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第三个H方法中，我们调用resolveComponent方法来呈现子组件标记。道具被视为属性。所以我们在选项对象中设置它们。我们使用<em class="np">模型值</em>作为属性名，并将<em class="np"> this.message </em>分配给它。</p><p id="29eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们监视自定义事件。</p><p id="9981" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于默认的输入事件，我们使用onInput方法来监视它。对于自定义事件，我们使用相同的策略。</p><p id="48fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事件名称为<em class="np">更新:模型值</em>。我们在的前面加上<em class="np">，并用引号将全名括起来。更新的第一个字母应该大写。</em></p><p id="4013" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自定义事件由emit方法发出。emit方法还将向自定义事件发送一个值。该值将作为第一个参数值传递给onUpdate方法。我们将它的第一个参数命名为<em class="np"> $event </em>。</p><p id="91e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在回调中，我们将<em class="np"> $event </em>分配给<em class="np"> this.message </em>。与我们对本地事件所做的不同，我们不需要在<em class="np"> $event </em>后面附加<em class="np"> target.value. </em></p><p id="2645" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">$ <em class="np">事件</em>本身就是传递给自定义事件的值。</p><p id="4916" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，根组件完成了。我们已经重新渲染了它的模板。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anj"><img src="../Images/4ab33e72d4de250c285c56d9d6c7c940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWbPUzFBucNt9sLiHmig3w.png"/></div></div></figure><p id="91a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="a909" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到两个输入标签仍然是同步的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agi"><img src="../Images/2b239a938264ed10447570b485936a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlWsqaHvfn1zzKY9UPvBUQ.png"/></div></div></figure><p id="ca0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们呈现子组件的模板。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ank"><img src="../Images/ee515cceb7e4197bedded8c432ed72ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqaggFgO3riFl9p0CZTCAA.png"/></div></div></figure><p id="b2d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们只需要呈现一个输入标签。</p><p id="c29a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在options对象中，我们首先将prop值分配给input标记的value属性。</p><p id="9296" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们添加onInput方法来监控本地输入事件。</p><p id="0997" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们称之为发射方法。自定义事件名称必须是<em class="np">更新:模型值</em>。</p><p id="4990" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<em class="np"> $event.target.value </em>设置第二个参数值。我们通过输入标签提交的文本存储在这里。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anl"><img src="../Images/7e43d0bfa4d3fcb92036ed38777aff97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1zEDFriDVBl3KMVHsO6mA.png"/></div></div></figure><p id="fa86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，子组件完成了。</p><p id="a5f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="d576" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它和以前一样工作。这两个输入标签是同步的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anm"><img src="../Images/54e4bec653112f285231ca35c72d6144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnTH_uib8saVqgG1fi9ETw.png"/></div></div></figure><p id="23df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你不明白这个程序是如何工作的，那就复习一下我们上一课的内容，我们解释了v model指令是如何在组件标签中工作的。</p><p id="5780" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将向您展示如何渲染动态组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lh"><img src="../Images/58905a42ec1c75df9f2b7b0a63083804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_18ZvgLoavNzzLPnJ3Gsw.png"/></div></div></figure><p id="8511" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开Vue api并向下滚动，您会发现一个名为resolveDynamicComponent的方法。这种方法正是我们所需要的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi akc"><img src="../Images/2186d3afb13ebb906a22e1883daeea66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*EXogdfMHWvvWwmfrV9qr2g.png"/></div></figure><p id="e290" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到根组件的渲染函数。</p><p id="1a3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，它呈现三个子元素。第二个和第三个H方法呈现两个子组件。我们删除最后一个H方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ann"><img src="../Images/9fdc0760c520730d8a71a3856c2e9c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEjqQr84ZBRJ-TgIWxoOvQ.png"/></div></div></figure><p id="ee76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将剩余的resolveComponent方法更改为resolveDynamicComponent方法。</p><p id="90de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过更改传递给resolveDynamicComponent方法的名称，我们可以呈现不同的子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ano"><img src="../Images/87d7d0b5d1e914bee87bcc712232cf9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fMyPmO9ZDgFTWVVYrF6aCA.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anp"><img src="../Images/442642b117f4a85f55e5afbc133507c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3inX9zTr9jbi36POC2AS8g.png"/></div></div></figure><p id="a6cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在数据选项中，我们定义了一个新的属性:componentName。我们将其值设置为childOne，这是第一个子组件的名称。</p><p id="8947" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们将新的数据属性传递给resolveDynamicComponent方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adg"><img src="../Images/ecdc014cbbe714869ec3dea36d63220c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aEEl-c9EYyXAbCvJdt5QQ.png"/></div></div></figure><p id="489d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们渲染两个按钮。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anq"><img src="../Images/4c97da461b58f182d929cff199d90644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhLC0mVYKiwaOr09Vcurog.png"/></div></div></figure><p id="f49c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在options对象中，我们添加了onClick方法来监视本机Click事件。我们使用两个按钮重置componentName属性的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anr"><img src="../Images/ab6394075c34c19ebe82842fc8dcf523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnxyETZL4ZTCDR4R0LXdnQ.png"/></div></div></figure><p id="984a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以通过单击这两个按钮来切换组件。</p><p id="dc44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将学习如何向呈现的元素添加自定义指令。我们不提供指令。我们仍然需要使用directive方法来定义它们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abk"><img src="../Images/f17ce854ccf68d3db36f8838f8b8301a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdpP1OfYEI9hyaHhDdPE3g.png"/></div></div></figure><p id="152c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们想要将测试指令添加到呈现的H1标签中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ys"><img src="../Images/191e736622893d36e928fd7483ed3fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YYt2t590ewn-ewUGQBVUNQ.png"/></div></div></figure><p id="60cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开Vue API，向下滚动找到这些解决方法。</p><p id="6d5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要的是解决问题的方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi re"><img src="../Images/48a74adfec98d07633cbc3771da578d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJCaY9tOPPTVfMGk2sQZFQ.png"/></div></div></figure><p id="ee81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅有这种方法是不够的，我们还需要withDirectives方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aea"><img src="../Images/2cb76e8d75e93d8da0d12df908f15376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9RNCBoVTYyyHt9lYRXIqg.png"/></div></div></figure><p id="521f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先将H方法作为第一个参数值传递给withDirectives方法。</p><p id="efd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用数组设置第二个参数值。</p><p id="c5b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在数组内部，我们添加了一个子数组。一个子数组在自定义指令上设置，通常有三个元素。第一个是resolveDirective方法。我们将指令名传递给它。第二个是我们希望测试指令拥有的参数值。第三个是参数名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ans"><img src="../Images/39d4ebd9b11e4236313740d617bd360c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AzcNtrObTGrBnhxcoB6tA.png"/></div></div></figure><p id="84a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过添加更多的子数组，可以呈现更多的指令。</p><p id="67f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="64a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到测试指令已经被添加到H1标签中。它还接收了参数值。</p><p id="e708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参数值来自info属性，如果我们修改info属性，我们将触发测试指令的更新钩子。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ant"><img src="../Images/5322e949c4daf0db81fcea234b35280e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rw9SIweZ5uktD667oYCa0Q.png"/></div></div></figure><p id="8327" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开应用程序实例，我们将找到一个配置属性。它有一个名为globalProperties的属性。目前，它的值是一个空对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anu"><img src="../Images/bedefac4c508df3780c92aa21046f50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJJ6xQ5LyuiYmPkFHCJwTw.png"/></div></div></figure><p id="b9b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有组件都可以访问添加到该对象中的属性。它们将被添加到所有组件实例的根级别中。</p><p id="4ffd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加一个info属性，并使用一个字符串设置它的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anv"><img src="../Images/e17fdf569476135db8c62ca02492192a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3hN8f9-tkkFRMhfgQo8qg.png"/></div></div></figure><p id="d8db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="d170" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先检查根组件实例。</p><p id="c252" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它已经接收了info属性。注意，info属性不是一个数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agd"><img src="../Images/3afc2524dea819eec139b91942a7dcf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2Jd90lWZR9US3eQQR4rFA.png"/></div></div></figure><p id="7146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们检查子组件实例。</p><p id="5dd0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的情况是一样的。子组件实例已收到info属性，但info属性不是数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anw"><img src="../Images/bd429a038cdb5bcc3221ce8b0cfc3393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UouR1CWpVrgO4a9BQLviIA.png"/></div></div></figure><p id="0538" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们在两个组件的模板中显示info属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aln"><img src="../Images/1b8606b2c3173ce1188f09ac0d5414fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_gvVoFsa9YXritVJCo8tQ.png"/></div></div></figure><p id="f9ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过vm.info访问info属性。</p><p id="7849" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们给它赋值。</p><p id="5b74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">值分配已成功，但模板未更改。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/a525b0beb8c0c99aeb9e12aeb50f58a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQY_UkVp2ak_cQ_BKIKzEQ.png"/></div></div></figure><p id="8137" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试子组件。</p><p id="9f60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事情和以前一样。我们可以重置info属性的值，但模板不会更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ud"><img src="../Images/0d032f55a64c6ca82cf627480a70f6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0vg13OcHvR2QhgZMqKYXw.png"/></div></div></figure><p id="4344" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">模板不会自动更新的原因是因为<em class="np"> info </em>属性的值只是一个普通的字符串。它不是被动的。我们在数据选项中设置的属性被Vue自动激活。</p><p id="30e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">info属性不是数据属性。它不会自动反应。我们需要手动激活它。那么如何做到这一点呢？</p><p id="87e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开Vue API。</p><p id="b600" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">向下滚动，你会发现一个名为<em class="np"> ref </em>的方法。意思是参考。我们用它来使像字符串或数字这样的原始值具有反应性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aby"><img src="../Images/8359d79194a4319971fe13c47cc5a012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIE0P_oW2VkYVOCYG-3IcQ.png"/></div></div></figure><p id="21c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面列出的<em class="np">无功</em>方法用于使参考型值无功。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xg"><img src="../Images/1f7d8c397c0d57d0e793161bf6b05cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*8TG_y6DIrmX5fu1i0hPsjQ.png"/></div></figure><p id="cb90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">先试试<em class="np"> ref </em>方法。</p><p id="427c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们向它传递一个字符串。</p><p id="de57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它返回给我们一个引用对象。value属性存储我们传递给ref方法的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qj"><img src="../Images/611fb08c5b055b5d706cb103986fb02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIv7XR6qACjnnj2iwK5RTw.png"/></div></div></figure><p id="bf11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">reactive方法仅适用于引用类型的值，如objects或array。不要向它传递原始值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rz"><img src="../Images/ebf4c755e94969dd764690985fd483c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiwIzWIJ7Zhvl5VXdZTWOA.png"/></div></div></figure><p id="0d0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">reactive方法通过为引用类型的值创建一个代理对象来使引用类型的值具有反应性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agn"><img src="../Images/8b38d060131e3b0b934ad6ba94b823c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLjwYBbKtaprf61otp-tDQ.png"/></div></div></figure><p id="a5ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以将引用类型的值传递给ref方法。</p><p id="2aec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将获得与字符串相同的引用对象。但是这样做没有意义，因为对象的反应仍然是通过创建代理对象来实现的。value属性存储一个代理对象，而不是传递给ref方法的原始对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rd"><img src="../Images/4751b544e1091740cc7eb367be38c285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8rkTz95OoEiKuiBQuG5tg.png"/></div></div></figure><p id="574e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，要使基元类型的值具有反应性，请使用ref方法。对于引用类型的值，请使用反应式方法。</p><p id="efdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<em class="np"> ref </em>方法重置info值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acl"><img src="../Images/680837221b8c228e20643e4a0459f1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xRfSxPTA7ZCkkldxO0oUNQ.png"/></div></div></figure><p id="fcc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，info属性的值是一个对象。在组件模板中，我们不能再直接显示info属性。我们需要给它加上<em class="np">点值</em>。</p><p id="54be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再运行一次程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anx"><img src="../Images/5e3c264ffee198b25901d21ddd4bdcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwD7FALOvh-gVIpqCrpong.png"/></div></div></figure><p id="e30a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先通过根组件实例重置info值。</p><p id="6e49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个组件模板都已更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/36943e79c2478dc3961caf136363ed15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFotpt0ZQGgX4xhncpTCXw.png"/></div></div></figure><p id="be5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过子组件来尝试一下。</p><p id="4ff8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果是一样的。两个组件模板都已自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agg"><img src="../Images/be314bbf00196fd44f5649ed26b89dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvyPc8kw4egVvmgpYpQS4A.png"/></div></div></figure><p id="aa61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当你使用ref方法时，记住它返回一个对象。我们在组件模板中使用它的value属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajk"><img src="../Images/b3114f27b3b3a15b6f5286872d119af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wueNc6GlO8b_VBXHFgazhg.png"/></div></div></figure><p id="61cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们尝试一个引用类型值。</p><p id="e5c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建一个对象，并将其传递给reactive方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajh"><img src="../Images/c9a668ea3ccad0577006397b3c5846ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8Lk3hHuXUW3gMAZXjg_hQ.png"/></div></div></figure><p id="b1be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">reactive方法返回一个代理对象。代理对象的处理程序使原始对象具有反应性。这意味着由于代理对象，品牌和模型属性只是反应性的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi any"><img src="../Images/3ef0ca600b619e74b234d35b2f5a0ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*-6dARjAJQ-9D7y75EK3MBg.png"/></div></figure><p id="0132" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们不能使用析构赋值来检索品牌或模型属性。为了保持反应性，必须通过代理对象访问品牌和型号值。一旦我们从代理对象中取出它们的值，它们将失去反应性，因为它们的值只是普通的字符串。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akg"><img src="../Images/4adfea91ebe5a441337ea93149663f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ly6sYAKf80QuiRR6Wr1L9g.png"/></div></div></figure><p id="e285" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们学习了如何手动创建反应。对于原始值，我们将它们传递给V <em class="np"> ue.ref() </em>方法。对于引用类型的值，我们将它们传递给V <em class="np"> ue.reactive() </em>方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anz"><img src="../Images/67d883ec3d4dfbbb48ef6972ec03acc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXnJRP0UsN9VUTEdzlU_eg.png"/></div></div></figure><p id="e22b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Vue API中，我们可以找到一个计算方法。它帮助我们创建计算属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agn"><img src="../Images/6e3cbedebb2019422383aae4129f1b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StupzarTdOGq9PeAF1B9_w.png"/></div></div></figure><p id="5d2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建一个新变量，并将其命名为capMessage。我们将它构建在消息变量之上。我们返回大写的消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ca"><img src="../Images/c1179bfb048b31e3d20c74b39f8834c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_i00zRi477-yF7gUMEMbmQ.png"/></div></div></figure><p id="edc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用computed方法设置capMessage值。我们传递一个对象给它。在对象内部，我们设置了一个getter和setter函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ut"><img src="../Images/b192f3796d3076879af288bfa0c2034b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSPy_ci59AylUVlK6TJFgg.png"/></div></div></figure><p id="3fac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在getter函数中，我们返回<em class="np"> message.value </em>并用<em class="np"> toUpperCase </em>方法附加它。在setter函数中，我们将新值赋给message.value。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zq"><img src="../Images/78f1e5085ef071f928ec6b1fe8ac3c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXepVOEQxrBgBuKjAeRhvg.png"/></div></div></figure><p id="40fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="f664" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息值是一个引用对象。原始消息值存储在value属性中。</p><p id="afbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">capMessage值也是一个引用对象。getter返回的值也存储在value属性中。</p><p id="5bcd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">capMessage值是大写的消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ael"><img src="../Images/d3caa7677b868dccedc6d94f1d9141cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-e3mGREj2v2nRQZlhUhScw.png"/></div></div></figure><p id="351b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CapMessage和Message同步。改变其中一个会影响另一个。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahd"><img src="../Images/ca8f9b19b88bba0e6e601e1aeffddd13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SfaOdWrPhnwFkiDYBVgcQ.png"/></div></div></figure><p id="a863" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将消息值转换成一个字符串。</p><p id="9d34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在capMessage getter和setter中，我们直接操作消息变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vt"><img src="../Images/9e585b2df44e34e57000a5eb557b71a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfQv5Dm9T5eZ7vxU7TO64A.png"/></div></div></figure><p id="03f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再试一次这个程序。</p><p id="cb0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CapMessage仍然可以访问消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abc"><img src="../Images/07ab5fdb669a5926e0c8df8f4e034bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03KirQqWNPVHbpER21qReQ.png"/></div></div></figure><p id="9986" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们重置消息值，capMessage不会受到影响。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/12ebe6eb55f41fde9eabf554d0eb2215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLvBvqNld0_zNC8JJm-5iA.png"/></div></div></figure><p id="ce87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">capMessage的设置者仍然可以影响消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aoa"><img src="../Images/501a00e03dcc2d57fdf616b879fdee4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*5X-HJguqDDxhYfo064XQ2g.png"/></div></figure><p id="c434" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，计算属性应该建立在反应属性之上。</p><p id="6a06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建另一个变量:carAge。在这里，我们只需要吸气剂。我们可以直接将回调传递给computed方法。这个回调函数将被用作getter函数。</p><p id="0ecd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过从当前年份中减去year属性来计算车龄。我们可以通过创建一个日期对象，然后调用getFullYear方法来获取当前年份。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aob"><img src="../Images/306dcd84df5d44e5027fbbf1519076a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_9fIfy23RUIt4fGfDca0Q.png"/></div></div></figure><p id="d789" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行文件。</p><p id="ffa4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到卡拉格是一个。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/cbde49c4d31cafe491e8b54d432ef41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYT_s0LTcNq3pfIFmYbDvQ.png"/></div></div></figure><p id="ee41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">汽车对象是反应性的，如果我们改变它的year属性的值，那么carAge值也会相应地改变。</p><p id="bab7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以汽车时代现在已经成为22。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ala"><img src="../Images/a6bfa26c069199df092af91e856331b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVfC9YaPYOGzh0VGQ6QXKw.png"/></div></div></figure><p id="3224" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将了解Vue提供的其他反应方法。</p><p id="0b9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue为我们提供了三种测试方法:isProxy、isReactive和isReadOnly。他们的名字已经告诉你他们做什么。</p><p id="fe18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了节省时间，我创建了一个结合了三种测试方法的测试函数。它告诉我们测试的值是代理值、反应值还是只读值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zl"><img src="../Images/547a30fca1375f243bcc33b9095a209d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqVZJpzEar3mKcuW8bhbOQ.png"/></div></div></figure><p id="fba8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我这里有一个对象字面量。它只有一个属性:标题。</p><p id="afd9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先让它反应。我们将它传递给reactive方法，并将返回的结果存储在名为reactive的变量中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ya"><img src="../Images/06ad60779da22cc044041f374aba4a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ng40IONPy-hRNMaPK44hYQ.png"/></div></div></figure><p id="1d0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们调用readOnly方法，并将原始对象文字传递给它。readOnly方法返回传递给它的对象的只读副本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ahx"><img src="../Images/5a07217a5cb6bfc8b5f6bc86d34d2d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUVxgCyPHDC6RJ-1WaPoTg.png"/></div></figure><p id="a66d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们向readOnly方法传递一个reactive对象，那么返回的对象将同时是readOnly和reactive。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aba"><img src="../Images/fc8b397a19fda8dab3bfe13841241b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Fjr0A1hmYHG4x2yivp1dA.png"/></div></div></figure><p id="eb2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反应变量是一个代理对象。处理者让它变得被动。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi rf"><img src="../Images/6a66345efffa63cc81a04691a272e1c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*B_WZTRX3ugmRQ5DgVgx4_Q.png"/></div></figure><p id="61cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">readOnly变量也是一个代理对象。它的处理程序截获所有写操作，因此使它成为只读的。我们可以输出它的属性。但是我们不能给它的任何属性赋值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoc"><img src="../Images/e5f37aea536ed3281f6783ee3ea5a50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQhR4HEvihXTnT7YzDrbMQ.png"/></div></div></figure><p id="fcb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ReadOnlyReactive仍然是一个代理对象。但是它有一个额外的代理层。外层使其只读，内层使其反应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vw"><img src="../Images/2c31e6427e5f1d2021caa632b9ce3ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JVQaFk3ys_Qi7ebkG-8JA.png"/></div></div></figure><p id="0ffe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将这三个变量传递给测试函数。</p><p id="a980" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">isProxy方法在所有三次执行中都返回true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aod"><img src="../Images/c931464fb9e3ec473013c0d2090077ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*4TOs2n6u4sg-fy2C7mZjNQ.png"/></div></figure><p id="4d0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">isReactive方法仅对Reactive方法创建的值返回true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aoe"><img src="../Images/ef7711e1dcefdac06cb6a1dec34bf6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*dXolTnyT9W4GQKCeQw1UWg.png"/></div></figure><p id="ef0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，isReadOnly方法仅对ReadOnly方法创建的值返回true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/b6684f90b7a4ba072ec29f10e6372143.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*tOCoSuvb-yPo7-0kkT0Qlw.png"/></div></figure><p id="4563" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用toRaw方法，我们可以将所有类型的代理值转换回对象文字。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aof"><img src="../Images/350f77777de0b139e2c15c01ea02c569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpPgA7LSN5BYDljUcmczxg.png"/></div></div></figure><p id="10ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果需要保护一个对象文本，可以将它传递给markRaw方法。</p><p id="02f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，reactive和readOnly方法将无法为它创建代理。</p><p id="c482" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">markRaw方法返回原始的对象文本，并在其中添加了一个额外的属性。额外的属性被命名为_ <em class="np"> V_skip </em>。其值为真。此属性供内部使用。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aof"><img src="../Images/90e913c1a6d90a286353c004b678043f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84fDwU6V0j3Ctx5dM47Gdg.png"/></div></div></figure><p id="ffe1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将<em class="np"> markRaw </em>对象传递给测试函数将在所有三个帐户上返回false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aog"><img src="../Images/c2d0b659827362419e6a3ea28303e217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgLaFo05mn4p_GE6NgPRaA.png"/></div></div></figure><p id="c8c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们禁用markRaw方法。在原始对象文本中，我们添加了一个嵌套对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tc"><img src="../Images/a502866645328f0027d308b219056b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lt4xZsWuWoQvfaEddkCTCg.png"/></div></div></figure><p id="9223" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反应式方法可以处理嵌套对象。</p><p id="6c11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到嵌套对象仍然是一个代理对象，仍然是反应性的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoa"><img src="../Images/fb47d996fc444cb14e877ad3ab168db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*H154VTfckcAjB4ITGCP3zA.png"/></div></div></figure><p id="4036" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">readOnly方法也可以处理嵌套对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aoh"><img src="../Images/5fc372670569b0ff72f98fb7f588c74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*iWHY2uRs50uemdu2twFbzg.png"/></div></figure><p id="958a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">禁止向嵌套对象分配新的属性值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aoh"><img src="../Images/5fc372670569b0ff72f98fb7f588c74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*iWHY2uRs50uemdu2twFbzg.png"/></div></figure><p id="83ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结论是reactive和readOnly方法都可以处理嵌套对象。这也是开发shallowReactive和shallowReadOnly方法的原因。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xz"><img src="../Images/f84159920a402098ff849f4c7857951a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Nwm0gGb_jl8ot4_XMrOCQ.png"/></div></div></figure><p id="af95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两种方法只对根级别的属性有效。嵌套对象不会受到影响。</p><p id="34fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">浅层反应对象本身就是反应性的。但是嵌套在其中的对象不是。</p><p id="984d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，浅只读对象本身也是只读的。嵌套在其中的对象不是。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoi"><img src="../Images/75a59d624399e19373e2638cf670996d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqdLfbhWssJfWaIxe--4Kg.png"/></div></div></figure><p id="736f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过一个浅只读对象来重置嵌套对象的属性值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c195cbdf6ea381f83bae88d71c32d9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*wsU1HJIQtdj8VO64b-psEw.png"/></div></figure><p id="bf4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将了解Vue提供的其他ref方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aip"><img src="../Images/e3448ca8d2ff1724494dcdc65d2fed74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*5wNr3A21zfEJFcf3FI1WNg.png"/></div></figure><p id="3997" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们创建一个字符串。</p><p id="4d2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们使用Vue.ref()方法使其具有反应性。</p><p id="0c82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ref方法返回给我们一个引用对象。value属性存储原始字符串值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abx"><img src="../Images/5348c08d2e6ed57a897cfc650397c3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQOUIliSfGOMVV2YCDc-9g.png"/></div></div></figure><p id="a7c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<em class="np"> isRef </em>方法，我们可以检查一个对象是否是引用对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qf"><img src="../Images/e6ac3280b6d194dbb9aa399cd7db152a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdJuJtl4PMQtXIrbRDdhig.png"/></div></div></figure><p id="8803" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参考对象不是反应对象。将其传递给isReactive方法将返回false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoj"><img src="../Images/ecbaab8f1e41211b6513acbe5b2f79be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXs8F-2IWybjAkS9jeTTww.png"/></div></div></figure><p id="fb96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了去除参考物体的反应性，我们使用unRef方法。它将引用对象变回其原始值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agd"><img src="../Images/8d16639e5b007a66c25bbd4f25bc0174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4XZDTBCrWTKVWgig8fZJQ.png"/></div></div></figure><p id="e3e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个反应对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vp"><img src="../Images/121700cd3c896fd89afedf557c12e261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQ01OFvcKq077-qEPTTJ4A.png"/></div></div></figure><p id="0ee5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，我们需要将一个属性从一个反应对象转换成一个参考对象。这样，属性本身就是反应性的。它不必依赖代理对象来保持其反应性。</p><p id="e569" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">toRef方法一次进行一次转换。我们向它传递两个参数。第一个参数是反应对象。第二个是目标属性的名称。</p><p id="f5d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们会得到一个参照物。原始属性值仍存储在value属性中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agi"><img src="../Images/e17e2e82ed8baf30d687612a9c2efa8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsqGc1zx5zj1U46pIyYH0g.png"/></div></div></figure><p id="f89c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个引用对象与ref方法返回的对象略有不同。但是将传递给isRef方法仍然会返回true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/cfa3bdaaf36009b08b9aa211111ed924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4w-_bshTgs_VucNCDVoxA.png"/></div></div></figure><p id="6f23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用toRefs方法，我们可以将每个对象属性转换成一个引用对象。这里要注意，必须将一个reactive对象传递给toRefs方法。你不能像普通对象一样传递它。</p><p id="fbc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回值是一个普通对象，但是每个属性值都是一个引用对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeb"><img src="../Images/de0c2ea6e61b4b4d817a44cc639c1747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uv24iwiHUq5YY2Y2EVDaWA.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agh"><img src="../Images/a8402979a4ef7406d97e12e7b3621e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7duOS89VpoSXV6d7k0xURQ.png"/></div></div></figure><p id="ace5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能想知道这样做有什么意义。传递给toRefs方法的对象已经是反应性的了，为什么还要让它再次反应呢？</p><p id="9667" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">reactive方法返回一个代理对象。反应由代理对象的处理程序启用。属性值只是普通的值。他们不是被动的。</p><p id="71b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们在代理对象上使用析构赋值，我们将只检索它的属性值。这些值不是反应性的。</p><p id="32cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">toRefs将每个属性值转换成一个引用对象，并以普通的对象文本形式返回它们。</p><p id="64e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回对象的每个属性都是独立的，这意味着它们的反应性是由它们自己实现的。它们不依赖代理对象的反应。</p><p id="ce4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这使我们能够使用析构赋值来检索我们需要的属性。检索到的属性仍然是反应性的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agd"><img src="../Images/f0184d874c15ccf6227ce1dfd421c98c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mf5Z-ivptW79YTRGU6UqZQ.png"/></div></div></figure><p id="9f4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">toRefs方法只接受一个反应值。然而，shallowRef方法没有这样的要求。</p><p id="ec73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们传递一个普通的对象给它。</p><p id="f7be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">shallowRef方法返回一个引用对象。value属性存储原始对象。未创建代理对象。这是shallowRef和Ref方法之间最重要的区别。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aee"><img src="../Images/a953fcbe1a38a53ee8334d007b5fefa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OLhmtvR-JiCvvg-V5E03Q.png"/></div></div></figure><p id="3b5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将一个对象传递给ref方法，value属性将是一个代理对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acx"><img src="../Images/d6ec4b016e470b388620747546109d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7s0ezwi5tJq1-W_8k1nd2A.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agj"><img src="../Images/1686948335bf2626e61e7f9b591eaae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvlU9jpFrVgZQ4KmeRRkmA.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aio"><img src="../Images/648294c4665c02a1589a9e69adf01d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*Zv_s2ItAy9pwPsE4sHRGAg.png"/></div></figure><p id="437f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试Vue组件中的shallowRef方法。</p><p id="dbed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将被动方法转换为浅层方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aok"><img src="../Images/aa5c8e06ddd4bea472cc116c8ae9c364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlIczRjzw3h6ct7hibkF7Q.png"/></div></div></figure><p id="2abb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">汽车属性的值将成为一个引用对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acx"><img src="../Images/f75d4614dae616290ad5ce4eb7b3a4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNWCkp8wvi8ttXsfXnSOTQ.png"/></div></div></figure><p id="86df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件模板中，我们需要给它附加<em class="np">点值</em>。</p><p id="545c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="ff6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到品牌和车型价值都得到了成功的展示。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ww"><img src="../Images/01ccc967132d8fbc425eeddd9278abec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaTHBWQKnRQy5HvAjmqVNA.png"/></div></div></figure><p id="e0f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> Car.value </em>只是一个普通的物体。更改其品牌或型号值不会导致组件模板更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/ccade6b12cf4439e3493a2ae83e77bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQYqxDGD7f11EbLroHEuAA.png"/></div></div></figure><p id="23a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了启用反应性，我们需要为value属性分配一个全新的对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alt"><img src="../Images/ef8b6f2f3700fe964aaed0205096bbbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7WIOInEnBZK9ETfI3q3kQ.png"/></div></div></figure><p id="4266" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你需要监控对象交换，这意味着你不只是修改属性，而是切换整个对象，那么<em class="np"> shallowRef </em>方法是你最好的选择。</p><p id="1795" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是大多数时候，我们只需要监控一个对象的属性，在这种情况下，<em class="np">反应式</em>方法总是最好的选择。</p><p id="ecd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计算值不是独立的。它们建立在其他反应值的基础上。一个计算值基本上是另一个反应值的附属值。它所做的只是将一个getter和setter应用于该反应值。</p><p id="19dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">customRef方法允许将自定义的getter和setter设置为独立的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aji"><img src="../Images/45aa3ec75865375c5456f02a4a7de408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nq5EDPDJd5oYqNzofYUSkg.png"/></div></div></figure><p id="0202" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，我们需要创建一个构造函数来存放customRef方法。</p><p id="181e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们将构造函数命名为carAge，并使用它根据汽车的制造年份来计算汽车的年龄。我们将生产年份传递给carAge函数，并期望它为我们计算车龄。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vm"><img src="../Images/abe7c47853ba56ae4d1b9c6c645a7885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEOSU5EX3RO5uK9lZ5xEWg.png"/></div></div></figure><p id="edaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在carAge函数中，我们首先创建当前年份。我们创建一个新的date对象并调用getFullYear方法。然后我们返回customRef方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aol"><img src="../Images/e580913dbdffa916e8c946d20a4ac872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nJNrCKcx3M18YRSGRHh6w.png"/></div></div></figure><p id="50ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">customRef方法接收回调。回调接收两个函数:跟踪和触发。跟踪先于触发。不要弄错顺序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qn"><img src="../Images/4df8680ebef91785613fd7123990e23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIvH4fzu44QdRs0trMLJPA.png"/></div></div></figure><p id="78a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在回调中，我们返回一个对象，并在其中设置一个getter和setter。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qt"><img src="../Images/68a5cf404a13c8904610820c70e7edc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s53cHWZKFi_0r9Eo5JbA1Q.png"/></div></div></figure><p id="0dfb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在getter中，在我们返回任何东西之前，记得先调用track函数。track函数确保我们返回最新的状态。</p><p id="e4f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们返回车龄，它是通过从当前年份中减去制造年份来计算的。</p><p id="3aa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，吸气剂完成了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/da260cfc7340c9c3fa807170ad68c3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QELauN1qrz28hAbUA2i0w.png"/></div></div></figure><p id="b212" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setter中，我们将新值赋给year参数。</p><p id="174f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们调用触发函数。</p><p id="781e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，自定义ref方法已经设置好了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ann"><img src="../Images/6044d8717b91aa869c0c3c4cb6022121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zhgclc6UhKPMdr3q3MSKJQ.png"/></div></div></figure><p id="651b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在getter的开头调用track函数，在setter的结尾调用trigger方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zh"><img src="../Images/3263a8b28f5009101f65fa01d6b500b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSE5g0Uk4euFo5CHwvh3Ng.png"/></div></div></figure><p id="b84d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个名为myCar的变量，并使用carAge函数设置它的值。我将2010传递给carAge函数。</p><p id="32b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到了一个自定义参考对象。它与ref方法返回的值略有不同。但它仍然是一个参照物。</p><p id="1c55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">value属性存储11。一辆2010年造的车，现在11岁了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yn"><img src="../Images/ce76ea4f62f5d97f32fbf7300cdb6269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3okmb9TAC62k7K6G1QvpbA.png"/></div></div></figure><p id="0cc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将1991分配给我的汽车点值。</p><p id="0271" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">value属性的值现在是30。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akp"><img src="../Images/4311d601234f58c0f11e1ed9ae6cc6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GobE8JRtEIdzX4ad6NRsDA.png"/></div></div></figure><p id="7e14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">myCar.value返回30。</p><p id="0e17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将myCar传递给isRef方法会返回true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aom"><img src="../Images/ac77297b5c3ca134b42f8623006b1ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*kYULwGUMJHjUYNXJxOenVg.png"/></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aon"><img src="../Images/38b9698cc7d4c8a2b9125604b961f775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEMglHNiXHSeQ0PoT7_aZw.png"/></div></div></figure><p id="9ca1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们学习了如何创建自定义引用对象。自定义引用对象最常见的应用是创建去抖程序。</p><p id="d253" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将向您展示什么是去抖程序，以及如何只用JavaScript创建一个去抖程序。如果你已经熟悉去抖程序，你可以跳过这一课。</p><p id="d711" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单地说，去抖程序是我们用来避免用户滥用的。如果用户在短时间内发出大量请求，就没有必要回答所有这些请求。我们在给定的时间内只回答一个请求。其他请求将被忽略。</p><p id="fc11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一个H1标签和一个按钮标签。</p><p id="7aa4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一个H1标签和一个按钮标签。</p><p id="616d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">clickNumber变量帮助我们记录点击按钮的次数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qz"><img src="../Images/78b003e874a2635b8b5582222517739d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPF7bzq4Dz8TKH5Lyks_Fw.png"/></div></div></figure><p id="08f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们使用H1和按钮标签创建一个计数器应用程序。</p><p id="7505" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们声明一个新变量，并将其命名为counter。我们将其值设置为零。我们使用计数器变量设置H1标签的内部文本。然后，我们向按钮标签添加另一个eventListener。</p><p id="04e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当点击按钮时，我们将计数器值加1，并使用新的计数器值重置H1标签的内部文本。</p><p id="8a5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，柜台app完成了。我们每点击一次按钮，计数器的值就增加一。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vo"><img src="../Images/5bfec9945c2b937d9c8477bedfa016cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTBDLPBccSu4FFywhoa77A.png"/></div></div></figure><p id="25f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的现实项目中，我们必须非常小心用户操作。高频操作应该受到限制。让我们在计数器程序中添加一个去抖动功能。我们从addEventListener方法中移除回调。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi td"><img src="../Images/c77bc7ff37629777a5687994df62f8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tluDnt3Af5Nm-w_Wh-sGeQ.png"/></div></div></figure><p id="8bf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们定义了一个新函数，并将其命名为去抖。我们向它传递两个参数:数量和延迟。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/a36611752f1ae86736664bb5a70a5c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCkbztQ7JL5Yx3O7GTAbzQ.png"/></div></div></figure><p id="c736" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在去抖函数中，我们首先声明一个局部变量。我们将其命名为stop，并将其值设置为null。然后我们返回一个子函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoo"><img src="../Images/1be0fdcd3e1e0265170407afdb0b6c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hfn120HnY3IGAWzfvVmzfQ.png"/></div></div></figure><p id="d75b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子函数内部，我们调用clearTimeOut函数并向其传递stop变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/5a58ee5c336b4e2a747f8f8317bf5060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*MDUlRCpXv3Ze8N1qm1Gyqg.png"/></div></figure><p id="036d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们使用setTimeOut函数重置停止值。clearTimeOut函数必须放在setTimeOut函数之前。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sa"><img src="../Images/1f1ceee9a0d9fd88f258522eabea7fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*J0Bs885wbMWKU-I_RtVRlw.png"/></div></figure><p id="e57c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数的作用是:设置一个定时器并返回一个定时器ID。clearTimeOut函数根据定时器的ID取消定时器。如果我们传递null给它，它不会有任何反应。</p><p id="8099" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们向setTimeOut函数传递一个回调。我们使用传递给去抖函数的第二个参数来设置延迟时间。在回调中，我们将计数器值加1，并使用新的计数器变量重置H1标签的innerText。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wl"><img src="../Images/6df15ce8b8959b2ba6e211b897037608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_bjppWv5QjsWdly2D_aaA.png"/></div></div></figure><p id="d70a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，去抖功能完成了。我们可以看到这是一个典型的闭包程序。去抖功能是外部功能。stop变量是在返回的子函数的父作用域中定义的。</p><p id="0351" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将去抖功能传递给addEventListener方法，并在那里调用它。</p><p id="3240" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用计数器变量作为第一个参数值。我们将第二个参数值设置为1000。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afc"><img src="../Images/42a8ad90f275c869490c48bdb96c884d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLvrc9Nj9q93t4NTE3yLpg.png"/></div></div></figure><p id="ea36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由去抖函数返回的子函数被绑定到click事件。当我们点击按钮时，它就会被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tc"><img src="../Images/b7b29759757ccae187ac0ef31d0981ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*to5Ij3Omq5_APo2H105QSg.png"/></div></div></figure><p id="9249" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">stop变量是在去抖函数的作用域中定义的，它将被返回的子函数的执行所共享。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/80cd33eb4c679ff29e1181170a376c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Euq749CVKaW8NXSk-JJ5Bw.png"/></div></div></figure><p id="8324" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无论我们执行多少次返回的子函数，都只会有一个stop变量。每次子函数触发时，它会取消之前的计时器，并使用自己的计时器ID重置<em class="np"> stop </em>变量的值。</p><p id="c5cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们一直点击按钮，子函数的当前执行总是取消其前任设置的定时器。只有最后一个setTimeOut函数才能完成它的执行</p><p id="06fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="435f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们点击一次按钮，然后等待。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vw"><img src="../Images/34605d1563e2452486b53a05271cc2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Z5F_YMFB7KYJI2fWzmHGg.png"/></div></div></figure><p id="8360" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">H1标签在我们点击按钮一秒钟后更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sy"><img src="../Images/f2c64783560a590201616dae17ff9cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E94jNlQif-YecsiXVXhF2w.png"/></div></div></figure><p id="6efa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们一直点击按钮，H1标签不会更新。在我们停止点击按钮一秒钟后，更新才会开始。最重要的是，数值只涨一。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wl"><img src="../Images/2e1d1b2364c5f33d83e02eb43c8f621d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXAsgnYRhJR-sBUzv2wxFw.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wl"><img src="../Images/2e1d1b2364c5f33d83e02eb43c8f621d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXAsgnYRhJR-sBUzv2wxFw.png"/></div></div></figure><p id="cd94" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">去抖程序本质上是一个关闭程序。关键是要确保只有一个停止变量，并且返回的子函数的所有执行都使用同一个停止变量。</p><p id="889c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在去抖功能中，我们控制log outer。然后在返回的子函数中，我们控制台日志内部。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aop"><img src="../Images/5b9f7e7112ce0774bdf24ec2485c56ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqkcMjSeFielKoTDr770gA.png"/></div></div></figure><p id="01e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="9bd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在桌案上找到了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoq"><img src="../Images/8d0ca603f1a1090ff504dbd6fbd004bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASnYUgP6EPxlMZj_amSQVg.png"/></div></div></figure><p id="46c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们点击按钮。</p><p id="27e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次我们点击按钮，我们将得到控制台表内。</p><p id="6836" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这证明了当我们第一次加载程序时，去抖功能只执行一次。每次我们点击按钮，返回的子函数都会被执行。单击该按钮不会再次触发去抖功能。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aor"><img src="../Images/432ba35eb2a25db77cb88a87fadd46ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rh08YYSig4KwtBDHQDQZ0g.png"/></div></div></figure><p id="5fcf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们学习了如何只用JavaScript创建一个去抖程序。在本课中，我们将在Vue组件中创建一个去抖程序。</p><p id="657a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经使用Vue重新创建了计数器应用程序。数字是一种数据属性。它显示在组件模板中。它的初始值为零。</p><p id="8919" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在button标记中，我添加了v on指令来监控click事件。当点击按钮时，将触发两个方法。</p><p id="46c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">addOne方法将数值加1。record方法记录我们点击按钮的次数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aos"><img src="../Images/b02767910d46905d09f96dc781874d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsVdBX5pi19aMFmzMCMQew.png"/></div></div></figure><p id="0771" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们直接将上节课创建的去抖函数移植到addOne方法中。让我们看看它是否能工作。</p><p id="f675" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在addOne方法中，我们声明了一个局部变量。我们将其命名为<em class="np"> stop </em>，并将其值设置为null。</p><p id="37f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们返回一个箭头函数。不要在这里返回完整的函数。这在一个完整的函数中指向窗口对象，而不是Vue实例对象。</p><p id="b3b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在返回的arrow函数中，我们调用clearTimeOut函数，并将stop变量传递给它。</p><p id="485b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将setTimeOut函数赋给stop变量。</p><p id="07df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将延迟设置为1000毫秒。</p><p id="bbd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setTimeOut函数的回调中，我们将number变量的值加1。</p><p id="57b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在v on指令中，我们给addOne方法添加了一对额外的括号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akx"><img src="../Images/def32d5c1440f22a8b89495c5931952c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ogXudvQILKDsr4lH5wv9Q.png"/></div></div></figure><p id="40ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="e188" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到这个程序根本不起作用。每单击一次，数值就增加一。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi acr"><img src="../Images/9edd5322b23dae06c497c5789459acb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3huILvYzzjhVuOVQhsuPg.png"/></div></div></figure><p id="e358" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们找出原因。我们添加了三个控制台日志语句来跟踪addOne方法的执行过程。</p><p id="f692" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在addOne方法的根级别，我们控制台日志<em class="np">外部</em>。</p><p id="5512" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在返回箭头功能中，我们控制台日志<em class="np">内部</em>。</p><p id="7159" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在传递给setTimeOut函数的回调中，我们将控制台日志<em class="np">的编号</em>加1。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aot"><img src="../Images/f88b0da3eb26fc1c7974aa0766295930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqnIQfSM_wvRiRvQCJ8BKw.png"/></div></div></figure><p id="6eb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再运行一次程序。</p><p id="5f6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，每次我们点击按钮，我们将触发一个新的addOne方法，因此创建一个新的停止变量。这就是去抖程序不起作用的原因。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahj"><img src="../Images/230756807c7afa0ebcba231c49a719cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2TOQaRdxjdzBgqaE0YLeQ.png"/></div></div></figure><p id="f9d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我们必须将计时器ID存储在一个唯一的位置。addOne方法的子函数必须能够访问那个地方。</p><p id="ab42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道这是哪里吗？</p><p id="6292" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根组件实例是惟一的，并且总是可以被addOne方法访问。</p><p id="cef0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在数据选项中定义了一个stop属性，并将其值设置为null。然后，我们将setTimeOut函数分配给stop属性。我们将stop属性传递给clearTimeOut函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aou"><img src="../Images/5d7bd65f28273e08af06c5503edfa53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-0rIZwjG3Ta7ot2Yr1SIw.png"/></div></div></figure><p id="d72f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有必要保留子功能。也不再需要stop变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ahz"><img src="../Images/ff0f77f8cbd5ed5a8a554d21ace30468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JP2ly4mEgcPWR8P7pcf3lA.png"/></div></div></figure><p id="b7f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在按钮标签中，我们从addOne方法中删除了第二对括号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aov"><img src="../Images/91aa3b1930aa0735bb1963953d32f24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuI68WkLDvD3Eg9OsHVEgg.png"/></div></div></figure><p id="44b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="49dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，去抖程序按预期工作。根组件实例扮演外部函数的角色。addOne方法的所有执行都共享stop属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akg"><img src="../Images/dae31eb71a49ae8a162b849b2b5ce570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjKg1-zlL1dyqnBu2SU1rg.png"/></div></div></figure><p id="b20f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们在Vue中创建了一个去抖程序。关键是<em class="np">停止</em>属性。根组件扮演外部函数的角色。setTimeOut和clearTimeOut函数都访问同一个<em class="np"> stop </em>属性。这就是去抖程序能够工作的原因。</p><p id="8d55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将通过使用customRef方法创建属性来重新创建去抖程序。</p><p id="0b0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们清空addOne方法。然后，我们从数据选项中删除停止和编号属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aow"><img src="../Images/ba49a0de5efa7c241b14ed1eabec4ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g28ZFm-Hb5UmgQ5LPQxjvg.png"/></div></div></figure><p id="3b57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用customRef方法重新创建number属性。number属性将是一个引用对象。我们需要操作它的值属性。在组件模板中，我们用点值附录编号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ca"><img src="../Images/a84110cf452aa583b390dbbfa5cb3dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_UNwtFmib7Q8gyHtg_kSRQ.png"/></div></div></figure><p id="51ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在addOne方法中，我们有两个选项来设置number属性的值。</p><p id="ea69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以在数字点值上加1，然后将总和赋回数字点值。</p><p id="f6c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，我们可以只给数字点值分配1。我们在setter中计算总和。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi akz"><img src="../Images/8be4788789701a5697bcf55d7bb9d9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJAqtQ8web2uWeMdQ8BwTw.png"/></div></div></figure><p id="7673" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们为number属性定义一个构造函数。我们将该函数命名为customNumber。我们向它传递两个参数:数量和延迟。</p><p id="6835" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在customNumber函数中，我们首先声明一个局部变量。我们将其命名为stop，并将其值设置为null。然后我们返回customRef方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aox"><img src="../Images/6600337ad111b279e1bcf72829579186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*TV_x0kcRLcgm5BYXAyD9Sg.png"/></div></figure><p id="6d33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将一个函数传递给customRef方法。这个函数接收两个函数:跟踪和触发。</p><p id="84a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在其中返回一个对象。在返回的对象中，我们定义了一个getter和一个setter。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sc"><img src="../Images/f92752ca9ffcf7c937e8b9a47a7869c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyR0PZuwN5w0DaEgxkRq4g.png"/></div></div></figure><p id="fcdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在getter中，我们首先运行track方法，然后返回number参数。getter不会对数字值进行任何更改。它只是返回传递给customNum函数的第一个参数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agn"><img src="../Images/8cd6f19fb338b205da26d8a0003ac468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LT8HyJtFNnUQQpesY-Yufw.png"/></div></div></figure><p id="2da4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setter函数中，我们首先调用clearTimeOut函数。我们把stop变量传递给它。</p><p id="6f84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用setTimeOut函数重置停止值。</p><p id="246c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">setter函数的参数值取决于addOne方法。</p><p id="23c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果addOne方法已经计算了总和并将总和分配给number.value，那么setter将接收总和。我们只需要将总和分配给<em class="np">号</em>。</p><p id="253e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果addOne方法只给number.value赋值一个，那么setter就会收到一个。我们需要计算总和，并将其分配给<em class="np">号</em>。</p><p id="23e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们调用触发函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoy"><img src="../Images/42f7d7aba099f7e71b172d74e0cf8aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rtlEW2LLCQpmf1KG7tuFw.png"/></div></div></figure><p id="824b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，customNumber函数完成了。</p><p id="1025" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过<em class="np">app dot config dot global properties</em>将number属性添加到组件实例中。</p><p id="457e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用customNumber函数创建数字值。我们将其初始值设置为零，延迟设置为1000毫秒。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoz"><img src="../Images/d551aaa5eedf8eca564b5dee62cc24fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zymefTTNL7UpUaCxu6RdDg.png"/></div></div></figure><p id="8dc8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="6a4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它像预期的那样工作。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aer"><img src="../Images/bcc23314018fa215140b08e7abc512ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WolelZ-9qO7A8fFuGFMPlA.png"/></div></div></figure><p id="6e4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们用第二种方式设置addOne方法。我们只给数字点值分配1。</p><p id="9900" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setter函数中，我们需要计算总和并将总和赋给<em class="np">号</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amr"><img src="../Images/0f0f42318e6db2478a4c30572b52378f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oe9uUFmDQp9528lUhuRv8g.png"/></div></div></figure><p id="e810" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="2899" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到结果和以前一样。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi un"><img src="../Images/c476e51d70bf56dda1fb19f145263fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUuF_BJBP2a2O_B6TPqCVw.png"/></div></div></figure><p id="ae61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们给number.value赋值一个，那么就会给setter函数发送一个。setter函数需要计算太阳并重置数值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apa"><img src="../Images/e68a80c3dd234d6ec516a084ef9be05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZjIipfLnI_8wUEcxUU4dg.png"/></div></div></figure><p id="fbcf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们删除stop变量和clearTimeOut函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apb"><img src="../Images/48df11ea5e7e933c83886de4ed2469d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DuzQ0eUigsmY428O5nwYA.png"/></div></div></figure><p id="f1e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再次运行程序，看看会发生什么。</p><p id="43cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为clearTimeOut函数已被删除。所以没有计时器会被取消。每次点击都会有效，只有一秒钟的延迟。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aos"><img src="../Images/f00963afc0f6f5a05be01816838b78fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*an2t1v-uzuLLsaUpNp4UgA.png"/></div></div></figure><p id="0f44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们重置addOne方法。我们在里面计算总数。</p><p id="5d72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setter函数中，我们只需要将新值赋给<em class="np">号</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apc"><img src="../Images/b061d1acfe1ddb53407f569195302154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kRIpTUb-_rEu14Ya98vfw.png"/></div></div></figure><p id="8643" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这会造成什么样的不同？</p><p id="ab02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我只按了一次按钮。</p><p id="c0cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数值保持不变一秒钟，然后变成一。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agq"><img src="../Images/13d806b7137a9df70ce3f5017bb3c775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-NEPhaPaA4gsqs8wARb5g.png"/></div></div></figure><p id="339c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我不停地按按钮。</p><p id="aa8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数值每秒增加一。我不需要停止单击来改变数值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi apd"><img src="../Images/3fa3630896133507bec2f3df6410e047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*gK2MrHYuwN0LSkLzYu5cBQ.png"/></div></figure><p id="bb43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我点击按钮53次，数值从0到10。最重要的是，我不需要停下来换号码。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ape"><img src="../Images/a9a7ce2a3a3ef21ecacc7a178328a067.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*a-pMaBjk6pdDKcakZZYwLQ.png"/></div></figure><p id="9bda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上，我把去抖程序转换成了节流程序。知道这是怎么发生的吗？</p><p id="15ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来追溯一下setter的执行过程。我们控制台记录它的参数值。</p><p id="4142" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我一直在按按钮。注意setter函数的参数值。</p><p id="f395" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">addOne方法执行两个操作:检索数字值并重置它。新数值基于旧数值。</p><p id="2617" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">number getter会立即返回数值。但是数字设置器以一秒钟的延迟更新数字值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vc"><img src="../Images/39b19e86eb9d66dee2d0d8c9b5a32cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSPcubkXeSz3DJnf_FiXIA.png"/></div></div></figure><p id="b63b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们以第一秒为例。</p><p id="ebb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一秒，无论我们触发addOne方法多少次，由number getter返回的number值将总是零，但是setter直到第一秒结束才工作。因此，将使用零加一来计算新数字。这就是为什么在前五次点击中，setter总是接收一个新值。作为一个额外的副作用，无论我们多么频繁地触发addOne方法，每秒钟，数字值最多只能增加1。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zv"><img src="../Images/7937b1e096a719264fcdb6fd079de5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWRKN29zwrdtsX_MJ2M9-w.png"/></div></div></figure><p id="8363" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用props和自定义事件，我们只能在一个组件和它的子组件之间交换数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apf"><img src="../Images/4bb90bfda12b60b8ddb9efc9347a8612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbnXfu6hvWx0wWem06D31A.png"/></div></div></figure><p id="c75d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们需要将数据发送得更远一点，从一个组件发送到它的孙组件，该怎么办？例如，message是根组件的数据属性。我们希望在孙组件中显示它。</p><p id="04f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用provide和inject，而不是要求子组件传递消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yj"><img src="../Images/35c01c71f3d43995aa51efe7c1b7e463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fb1EiSeTLa2z4dXpXdwnAQ.png"/></div></div></figure><p id="06e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">父组件是提供方。它将数据发送出去。它的子组件或孙组件是注入端。他们接收数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apg"><img src="../Images/1eb4e1ac0908696d9b3f1e1dad53a20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCO7Y_-Q0BZYSkK4dN3y9Q.png"/></div></div></figure><p id="cd1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无论嵌套有多深，所有子组件都可以平等地访问父组件提供的数据。</p><p id="f0e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">提供</em>和<em class="np">注入</em>的挑战是保持反应性。稍后我们将向您展示详细信息。</p><p id="88d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件中，我们添加了一个提供选项。我们使用一个对象来设置它的值。</p><p id="dbd1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此对象中定义的属性将提供给子组件。</p><p id="4b98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们定义了一个名为info的属性，并使用一个字符串来设置它的值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abo"><img src="../Images/61038fbae1a795831afd8cd1309c08d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xWqltK0p3xTy9pfQG_PDA.png"/></div></div></figure><p id="0dbf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在孙组件中，我们添加了注入选项。它的值是一个数组。我们将info列为数组元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aph"><img src="../Images/ee7fc0c678e5a7444fc7959dfc7e9451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IV9_ru5NDAitpeGByJti9w.png"/></div></div></figure><p id="08ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查孙组件的实例对象。</p><p id="c04c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它的实例对象已经接收了info属性。注意，info属性不是一个数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajl"><img src="../Images/f1a61a132b36143397d68f915fc83cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_u6-qS7hBWH_8N4Bhl-fw.png"/></div></div></figure><p id="52ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在孙组件的模板中显示info属性。</p><p id="4e0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，根组件提供的info属性已经被注入到孙组件中，并显示在它的模板中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agt"><img src="../Images/39561b08d1e2e7e343ab56e84bfcf71b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fH728umIjOjDuUQx90UYYg.png"/></div></div></figure><p id="a82d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过孙组件重置info值。模板未更新。这意味着默认情况下，innjected属性是不可反应的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi api"><img src="../Images/e293e1f8c7020092faa8883844bce0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p71AvuqxK8NV9Apyymgn3Q.png"/></div></div></figure><p id="b56e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">info值是一个字符串，为了使它具有反应性，我们需要将字符串传递给Vue.ref()方法。</p><p id="bd4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">info值现在是一个引用对象。在组件模板中，我们需要在附录<em class="np">信息</em>中添加点值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tz"><img src="../Images/b89103c604d6e4473eb162a7912b8c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PoACjMDw06aF7EWr0lUXlQ.png"/></div></div></figure><p id="5e9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重新载入程序。</p><p id="11dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过孙组件输出info属性。我们可以看到它的值是一个参照物。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi api"><img src="../Images/4ee17f4cb2beeca91c76bbed750180c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pN3y-r76qCeEUcLC30zwLQ.png"/></div></div></figure><p id="348c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们赋予它新的价值。</p><p id="e42b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到孙组件的模板已经自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abp"><img src="../Images/c622fd4884d33d0a2911326eb4545849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cslJXBWhOiDMMzOod0eMA.png"/></div></div></figure><p id="cd30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们也将info属性注入到子组件中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ye"><img src="../Images/6db98bd30af649566f91a2bebaac4aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ts_xSHGkwRr2h4ShOjUqGg.png"/></div></div></figure><p id="bcb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过子组件修改info值，孙组件也将被更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qm"><img src="../Images/6b9038a5e451a95d589b5e3a0f187c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5kRNPmPRkBl7-YgHwofgg.png"/></div></div></figure><p id="c504" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，如果我们通过孙组件重置info值，子组件也将被更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajl"><img src="../Images/0564ec96afbb0b0bd7ddce03ea167675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52dw_lWcKvG9gcEHWWdEzA.png"/></div></div></figure><p id="8484" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要使提供的属性具有反应性，我们需要使用Vue.ref()或Vue.reactive()方法。但是如果我们想提供一个数据属性呢？例如，我们希望提供消息属性。如何访问它？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abh"><img src="../Images/ff6d210c318980b87bda80df73f300d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qq5dnD2lXxcaJQn0SU0k5g.png"/></div></div></figure><p id="6265" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了从数据选项中访问属性，我们需要使用函数语法重置<em class="np">提供</em>选项的值。</p><p id="0151" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在provide函数中返回一个对象。在返回的对象中，我们设置了info属性。我们可以通过这个访问数据属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vl"><img src="../Images/7d59631ffcbde8c22ad562660d62e8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALxQbTjHYAp5IrRW2uoENw.png"/></div></div></figure><p id="3182" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="df6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们输出子组件实例。它已收到info属性。info值与message值相同。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aji"><img src="../Images/fb858f561e144bf7337b26a514323d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N39k7hb53PjkZhve07eOJg.png"/></div></div></figure><p id="c596" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，info值是使用message值设置的。仅此而已。他们之间没有进一步的联系。如果我们重置消息值，信息值不会受到影响。同样，如果我们重置info值，消息值也不会受到影响。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ant"><img src="../Images/e61947ead8c36470537630e81abd9000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4qaJyIC-uS3cQ_DJ0OBuQ.png"/></div></div></figure><p id="53c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们需要将消息和信息链接在一起。</p><p id="584d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们使用Vue.computed()方法设置info值。</p><p id="cafb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将getter函数传递给computed方法。</p><p id="1be2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在getter函数中，我们返回this.message</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xv"><img src="../Images/211b6dff03e5db7ceb4a502dd1e569a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CmSKJ_tYaBxuxnHlNzjjPA.png"/></div></div></figure><p id="419a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给消息分配一个新值。</p><p id="6669" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到info值也被更新了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abl"><img src="../Images/2f1234fee6ba28eed9a3fa1f1a6511d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0HQApNiHPYmLLrI2W9S8g.png"/></div></div></figure><p id="c202" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">info属性只有一个getter函数。这使它成为只读的。我们不能赋予它任何东西。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agv"><img src="../Images/794b3f68c40a928768a366ea6657619c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZLtUCzA9EOly-6CvxYCAw.png"/></div></div></figure><p id="b6c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们重置info值。这一次，我们添加了bot的getter和setter函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ot"><img src="../Images/d53102d696ac2e16c63108076af913e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTQG8SzwgnwTx-vF2kHbGw.png"/></div></div></figure><p id="c344" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，info属性和message属性将始终保持同步。</p><p id="b99e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更改消息值也会更改信息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uy"><img src="../Images/c083d4c2dce270e9e1dde885a7c49201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iND0vOUwmtG7lHqXMVZGvQ.png"/></div></div></figure><p id="c60c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更改信息值也会更改消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yw"><img src="../Images/8a0bb2105128f04090b382d014ec27d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBXELu00pWoohvR7lqWQ5w.png"/></div></div></figure><p id="bfee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有三个变量:城市、列表和汽车。都是反应性的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zz"><img src="../Images/9e95caecaf5276666eef5f05478755c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fejskJgHqybrG0VF-xE4Pw.png"/></div></div></figure><p id="79a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市值是一个引用对象。它由Vue ref方法创建。Vue ref方法使诸如字符串和数字之类的原始值具有反应性。</p><p id="7c8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了访问原始值，我们使用ref对象的value属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ya"><img src="../Images/8fda0a93c41746cc71aa0993fbdadb0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Wf9P-iiNK-UcaRlmXfsag.png"/></div></div></figure><p id="70a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">list的值是一个代理对象。汽车的价值也是如此。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ya"><img src="../Images/b88d905a11a01c315a0d7a4cff2be6d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSoZhd8CTu3j4_LK4Zyiqg.png"/></div></div></figure><p id="f866" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个代理对象也称为反应对象。它们是通过Vue反应方法创建的。Vue reactive方法使引用类型的值(如数组和对象)具有反应性。</p><p id="f5c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经常需要观察反应值。在组件实例中，我们可以使用watch选项或$watch方法来观察反应值。</p><p id="4f38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue API还为我们提供了两个选项。它们是观察方法和观察效果方法。这两种方法用于处理不同的情况。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ani"><img src="../Images/8598efdd11de960043a59dfab0099c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Caebh4jsXW2TEdMOMFU51g.png"/></div></div></figure><p id="da48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从观看方法开始。</p><p id="d1d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue手表方法和我们之前学的$手表方法很像。</p><p id="ae88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你知道如何使用$watch方法，那么你可以相当快地学会Vue watch方法。但是这两种方法还是有一些区别的。</p><p id="ff4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从Vue api调用watch方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi apj"><img src="../Images/0664ab1b0f7aae51206291b714604025.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*jje2r7OINHIilS7CKHak9w.png"/></div></figure><p id="d6ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法与美元符号监视方法相同。我们仍然提出三个论点。第一个指定了观察源。这里，我们使用城市变量来设置它。我们将城市变量传递给watch方法。不要用引号将变量名括起来。</p><p id="1d07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个参数是处理函数。它接收两个参数:新值和以前的值。最后一个是配置对象。有三个配置属性:立即、深度和刷新。我们将immediate设置为true，将deep设置为false。这里不需要flush属性。</p><p id="e82d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue watch方法返回一个停止函数。我们使用一个名为stop的变量来接收它。</p><p id="7958" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们建立了一个Vue观看方法。它监视城市变量。让我们试一试。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi yc"><img src="../Images/b43b653e7dfef212aa909a3ccb6d0cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*XFHD_fSPLB8YIz1L1z2xyA.png"/></div></figure><p id="0df5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们刷新页面。</p><p id="df3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到了未定义和伦敦。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/5daca9adf3862bb4db95264383442d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNvaouRPRbOuIl7gYIxXlA.png"/></div></div></figure><p id="d8e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意这里，city的值是一个ref对象。城市名称存储在value属性中。</p><p id="f2c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然ref对象被设置为观察源，但是Vue watch方法实际上监视的是ref对象的value属性。它自动打开ref对象并将value属性传递给它的处理函数。这就是为什么我们得到了伦敦而不是ref对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wa"><img src="../Images/edbf97216b7b5ab26f246e2d96831928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yi3mamQlK8s3-0OBfByUnQ.png"/></div></div></figure><p id="5ba1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要触发Vue watch方法，应该为ref对象的value属性分配一个新的城市名称。不要重置城市变量本身。</p><p id="849d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将达拉斯分配给城市点值。</p><p id="a517" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到watch方法已经被触发。它输出伦敦达拉斯。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi apk"><img src="../Images/4a885d3b8b0978a3ca2c2fabeecf43f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*3p_qbZ1eND1J7AK9YV0v5A.png"/></div></figure><p id="7317" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看如果给city变量分配一个新的ref对象会发生什么。</p><p id="cb43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给city变量分配了一个新的Vue ref方法。我们设定了一个新的城市名称。</p><p id="f629" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，city变量存储了一个新的ref对象，这意味着它不再被第18行定义的Vue watch方法监视。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adr"><img src="../Images/e5c99dda3ceb18fbf488f6affc93d385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XYMO8joHPQinKR8J4UC4w.png"/></div></div></figure><p id="d710" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们重置新的ref对象的value属性，那么第18行定义的Vue watch方法将不会被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/b7de0e770f83e58e623cd33becae0b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HrOe6USoITjbnwhQBcmRDQ.png"/></div></div></figure><p id="b5c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在继续之前，我们先来对比一下Vue手表方法和之前学过的$手表方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aji"><img src="../Images/b39f109c99cbd857b2e6e6d850e66498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Edi-4Y4Z20uSw5gVtCnptw.png"/></div></div></figure><p id="d2c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">乍一看，这两种看表方法是一样的。它们都观察一个城市名称，当城市名称改变时，它们都被触发。</p><p id="d610" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue watch方法是独立使用的，不与任何组件实例关联。</p><p id="f7ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">传递给Vue watch方法的city变量只是一个原生JS变量，而不是Vue数据属性。</p><p id="0a5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">city变量实际保存的是第10行的vue ref方法创建的ref对象的内存地址。</p><p id="647c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个ref对象是Vue watch方法实际接收和监视的对象。城市变量只是一个信使。它所做的只是提供对第10行创建的ref对象的访问。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apl"><img src="../Images/697759bb9595549242137f4c31db9b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6Xce_iO6WHBj70W9iZdRw.png"/></div></div></figure><p id="ef49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">$watch方法不同。它的第一个参数值用引号括起来。它只是一个属性名。我们没有通过这个引用城市属性。$watch方法实际上观察的是城市属性本身。为了触发$watch方法，我们为city属性分配一个新值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ps"><img src="../Images/2bec97ffc6c6187a3f0b1690ad12ae3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e84Bwl71n9ZqlCSGqiUVrA.png"/></div></div></figure><p id="84f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们调用停止函数。</p><p id="e53f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue watch方法现已停止。重置城市点值将不再触发它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apm"><img src="../Images/093843826487a4951488aef4c1831b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0JnguTNIMXVMbqghZF6tw.png"/></div></div></figure><p id="11b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们更改观察源。我们观察列表变量。</p><p id="f979" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然将<em class="np">深度</em>属性设置为false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/35d23500fa257479551a2c8957cacd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5VssfmDk9trYCOETghmog.png"/></div></div></figure><p id="ac1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">list的值是一个代理对象，但它的行为与普通数组相同。</p><p id="b2a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们移除最后一个数组元素。观察器被触发了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/cd52984cdb0d9c09fceede08d4596082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhI5KbmDW9wjEUCyeYkQOg.png"/></div></div></figure><p id="0bf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重置第一个元素值。</p><p id="050f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察器又被触发了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apn"><img src="../Images/356459c7c45c2e38219520f597022d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q23LUf00DUSCa1W5PyA6ig.png"/></div></div></figure><p id="618b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们使用美元符号监视方法，操作数组元素不会触发数组监视器，除非deep属性设置为true。</p><p id="4f0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将另一个数组赋给列表变量，watch方法将不会响应，也不会再监视列表变量。Vue watch方法和list变量之间的连接不再存在。watch方法只监视第12行创建的反应对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/31f8079bb496d05c3c312e3b0d0c1770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Uzr9rqY8Zvep9jr2vRa_Q.png"/></div></div></figure><p id="ef1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们看看是否可以观看元素总量。</p><p id="24a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们收到了警告。</p><p id="7bc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">vue watch方法已被触发，但处理函数的两个参数都没有定义。这意味着监视源不可访问。</p><p id="90ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">警告称，监视源只能是getter函数、ref对象、reactive对象或这些类型的数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adu"><img src="../Images/73ea8581cb7d47e100a35cfee86a1d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5qXY5rC8p_ggT9zI5oNEw.png"/></div></div></figure><p id="164b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个警告很有用。它清楚地告诉我们什么可以作为vue watch方法的第一个参数值。</p><p id="c207" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来看汽车变量。</p><p id="1c86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到重置品牌价值已经触发了观察器，即使deep属性设置为false。</p><p id="03e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于同样的原因，如果我们给car变量分配一个新的对象，vue watch方法将不会响应，并将停止监视car变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/5b114eca863bd2a71663731d89709429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvaHDeshLtNaMi9KL5n5uA.png"/></div></div></figure><p id="7ba9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们试图观察汽车对象的属性，我们将得到与观察数组长度相同的结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adx"><img src="../Images/22d59b80aded2dd2751ddbe59214a789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ih0bezQWgr45eFJZFaJ-cw.png"/></div></div></figure><p id="14a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue观察方法仅观察参考对象和反应对象。要观察其他值，如元素总数或选定的对象属性，需要在getter中设置它们。</p><p id="af16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用函数设置watch方法的第一个参数。我们首先返回列表变量。我们仍然将deep属性设置为false。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tg"><img src="../Images/c9d3c07a6dd83993a8b9867fe6548d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*7wcCZ9ALHgl8dTLp5BtHaQ.png"/></div></figure><p id="bc24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们移除最后一个数组元素。</p><p id="ba93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，Vue手表法没有回应。深层属性正在起作用。</p><p id="982d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们给列表变量分配一个新数组，Vue watch将不再监视列表变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afe"><img src="../Images/457e7620a95fba1c8db50a6d2a4570e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPAGcauAN34zAMXxB3hQ5A.png"/></div></div></figure><p id="9d2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将deep属性设置为true。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi apo"><img src="../Images/70f58d8f3e1c15f1d4d0ef609ec9658d.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*hojyh5xdEmLOGLw_NSO3RA.png"/></div></figure><p id="11e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="2c30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次修改数组元素可以触发Vue watch方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/c6a1ae11b6ad1eac56559e0c1755745f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiU4Sj2-hkl9Evc9s5BWOg.png"/></div></div></figure><p id="dd1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于汽车对象，您将得到相同的结果。我将跳过这里的演示。</p><p id="df2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将深度属性切换回false。</p><p id="3e53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在getter函数中，我们使用spread操作符将代理对象转换回数组。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi sx"><img src="../Images/8869450da732707b6135828094ef3166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*-u8bbcb8s12wDwpWxDHDPg.png"/></div></figure><p id="a9bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，Vue watch方法监视列表数组。</p><p id="3ba7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">移除和重置数组元素会触发观察器。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi app"><img src="../Images/a46840d573ca57ccdb7567c3d5af8d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7t_VNcAbhj5fy9W8OzC0Q.png"/></div></div></figure><p id="a293" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以观察一个特定的数组元素、元素总数和一个选定的对象属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zc"><img src="../Images/b41a51bbf216d44cec8f0ac41cc2c910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFKhDlAXELRrpMbj0gPOpQ.png"/></div></div></figure><p id="f2d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个问题要问你。如果我们在getter中返回城市变量会发生什么？不推荐。但你还是应该知道我们做的时候会发生什么。自己做实验。</p><p id="8bd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将尝试watchEffect方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi apq"><img src="../Images/e63d71984c9d5041768c7e7c6839b879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*GuWZYqm2WT3nsaWSYthK3Q.png"/></div></figure><p id="7fc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们看看watchEffect方法的基本语法。</p><p id="c8e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watchEffect方法有两个参数。第一个是回调函数。第二个是配置对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi apk"><img src="../Images/f3cfc3b3e668f2fbfebd780ad99194e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*Ab4_4h1KoMHVcCvsIC3aOw.png"/></div></figure><p id="9ce8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前面的watch方法有三个配置属性。让我们在这里也设置同样的三个属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi apr"><img src="../Images/9aec56cc17f3edb3a902444c615f695f.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*GDu37tF_tAWX-lAvvi09eQ.png"/></div></figure><p id="a380" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们刷新页面。</p><p id="9ae0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们收到了两个警告。这两个警告就是我想给你看的。</p><p id="14df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watchEffect方法的config对象只接受flush属性。immediate和deep属性在这里不适用。flush属性的默认值仍然是pre。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afl"><img src="../Images/70e6dffbe2fb0fe0c11ad3f86dc04303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38qai6y7PLCdsLTuyjuWKA.png"/></div></div></figure><p id="403c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像watch方法一样，watchEffect方法也返回一个stop函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aps"><img src="../Images/6adc9d283025ed43c33a49ebf2478db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEZGatXEwqitacr78jUaMA.png"/></div></div></figure><p id="a386" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们已经有了watch方法，为什么还需要另一个方法呢？</p><p id="a858" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，watchEffect方法不是用来比较watch源的以前值和当前值的。我们已经有了这项工作的观察方法。事实上，watchEffect方法甚至不能访问观察源的前一个值。</p><p id="a45a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> watchEffect </em>这个名字包含了两个字:手表和副作用。</p><p id="b8a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察意味着观察反应变量或属性的值变化。</p><p id="2222" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">副作用只是钩子函数的另一个名字。watch方法的handler函数也可以看作是副作用。</p><p id="2039" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watchEffect方法允许我们设置两个而不是一个副作用函数。然而，这两个功能不会总是同时触发。</p><p id="cd0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回调接收一个名为onInvalidate的函数。回调本身就是第二个副作用函数。onInvalidate函数也接受回调。这个回调是第一个副作用函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ali"><img src="../Images/118f92da2b93f0f6383faa8782c91380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1K-ZiMcwgXdIp_I2wno_w.png"/></div></div></figure><p id="74d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重新加载文件。</p><p id="9d26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到只有第二个副作用功能被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apt"><img src="../Images/8aeff39a24420fa066ceb1c83276a2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVMTzaSxH6_iCJMIU3BQPg.png"/></div></div></figure><p id="6dd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也证明了watchEffect方法在我们第一次加载页面时触发。这就是它不需要立即属性的原因。它总是立即做出反应。</p><p id="cd53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们调用停止函数。</p><p id="69e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这次只触发了第一个副作用功能。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apu"><img src="../Images/31389c0ab3a18e565f52326758784e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WG8zPxmdvK44EfyrJVQokg.png"/></div></div></figure><p id="585a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结论是当我们第一次加载程序时，只有第二个副作用函数触发。当我们停止watchEffect方法时，只有第一个副作用函数触发。</p><p id="ea6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，watchEffect方法没有观察任何东西。</p><p id="d98a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于watch方法，我们使用它的第一个参数来指定观察源。watchEffect方法没有用于指定观察源的专用参数。我们只需要确保观察源出现在第二个副作用函数的范围内。这里注意，还得是第二个副作用函数。</p><p id="457f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们希望观察城市变量。我们声明一个变量，并将其命名为target。然后我们将城市分配给目标。出于演示目的，我们控制台记录目标变量。</p><p id="4b8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="8fe8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有第二个副作用功能被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wd"><img src="../Images/ca01e077279451ca3b21d550c5b15873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZcLbCfDmeZWmB2yiBkTbA.png"/></div></div></figure><p id="f015" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置城市点值。</p><p id="ca20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">什么都没发生。watchEffect方法监视ref对象，而不是城市名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apv"><img src="../Images/63fa49bcfa73ad33fa5dfc6fbe5c4a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TLvp2Aaj7PZn9w0duaQDQ.png"/></div></div></figure><p id="edda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市网点值需要在第二个副作用函数中显示出来。</p><p id="56df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将城市名重置为达拉斯。</p><p id="ed7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watchEffect方法已被触发。这一次，两个副作用功能都被执行了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apw"><img src="../Images/b07eb0a0f78d2e63db8bc1da3a3c7120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwVv2COqIu7T4EJgjmafSQ.png"/></div></div></figure><p id="5001" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看看这两个副作用函数的执行顺序。</p><p id="428f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">onInvalidate方法是在最后定义的，但它是第一个被执行的方法。这就是为什么它是第一个副作用函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apx"><img src="../Images/8062cc921439b7db909cbb4ccfe5e53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6molgarzWMCITGVF9YoeQ.png"/></div></div></figure><p id="6d01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">观察源必须出现在第二个副作用函数的范围内。让我们把它移到第一个副作用函数中，看看会发生什么。</p><p id="50f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重设了城市名。什么都没发生。watchEffect方法没有响应。两个副作用功能都没有被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afk"><img src="../Images/781c2bc53fabd68c0b6dd7feb3ce2990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FsaVotlekoC4W9duBYNo8Q.png"/></div></div></figure><p id="a6a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以请记住，手表源必须出现在第二个副作用函数中。对于ref对象，您需要指定它的value属性。</p><p id="cca0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来看列表数组。列表数组已被转换为反应对象。我们不需要在它后面附加value属性。</p><p id="1bdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们移除最后一个数组元素。</p><p id="8429" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watchEffect方法没有响应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afm"><img src="../Images/abd8e5f608b0754b0939d9df78f303ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLsr5xeQ0NArj5vO78RkZw.png"/></div></div></figure><p id="8283" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原因和之前一样。watchEffect方法不监视列表数组。它监视列表数组的反应对象的内存地址。</p><p id="5743" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">修改list数组的数组元素不会改变内存地址，因此不会触发watchEffect方法。</p><p id="d2a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要使用spread操作符将反应对象转换回数组。</p><p id="721a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，watchEffect方法监视数组体，修改数组元素会触发watchEffect方法。两个副作用功能都被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alg"><img src="../Images/c775d2463be848d1f2df699c80b295a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TufLmpux6mW6Wbe_zXLUqA.png"/></div></div></figure><p id="b3a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来看元素总和。</p><p id="a8a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们调用pop方法来删除最后一个元素。</p><p id="7780" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watchEffect方法已被触发。两种副作用功能都已执行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apy"><img src="../Images/3149c1724b642866dae7f4ddd55f3b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xo_JZ23mXfrUC0vPoDNbcQ.png"/></div></div></figure><p id="0e5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们看看是否可以观察一个特定的数组元素。我们还是选第一个。</p><p id="f802" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置第一个元素值。</p><p id="b8cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watchEffect方法已被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apy"><img src="../Images/53198c5f5b801ed635e801eaa66e5ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39K5ZQzVkXJmHq45fiioNA.png"/></div></div></figure><p id="7311" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们监视汽车对象。</p><p id="10d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们重置了品牌属性。watchEffect方法没有响应。原因还是因为watchEffect方法只监控car对象的内存地址。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apz"><img src="../Images/45ac13f1f811b13bc2122493c85f25ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pe5wlM_NOfaZgkNJBfZI1g.png"/></div></div></figure><p id="d7e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要指定目标属性。这里，我们选择品牌属性。属性值应该是原始值。</p><p id="eefa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，重置brand属性会触发watchEffect方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aes"><img src="../Images/44b82e5a2aec2d826f80caa7c6fa5588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALOehSgMroVsrQaz0DJFhQ.png"/></div></div></figure><p id="768f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们称之为停止函数。</p><p id="a1cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个副作用函数被触发。第二个不会回应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi afm"><img src="../Images/2d54b00c6a6b14583cb320c5178fd7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSpmgylTRWuviHGXxvalSA.png"/></div></div></figure><p id="bf27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">flush属性的工作方式与美元符号监视方法相同。默认值为pre。另外两个值是post和sync。</p><p id="dbfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">flush属性控制是否在页面重新呈现之前、之后或同时触发watchEffect方法。我将跳过这里的演示。</p><p id="83e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，只需要记住watchEffect方法的语法以及它的两个副作用函数的行为。在接下来的课程中，我们将向您展示它的实际应用。</p><p id="404b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将向您展示如何使用axios发出可取消的请求。我们将在后面的课程中将其与watchEffect结合使用。但首先，我们需要确保您知道如何创建可取消的axios请求。</p><p id="9846" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用openWeather API作为数据源。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqa"><img src="../Images/7ec329a4dfc29ea615c4f1126cea5322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFc_0j3TqPqZL4xm_jIOEA.png"/></div></div></figure><p id="0806" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">转到openWeatherMap并创建一个新帐户。</p><p id="8a5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后转到“我的API密钥”页面。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/3fe1afe63181b2f41b24164c7557ed58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6vzKDf6jQz2gDwxBKinIQ.png"/></div></div></figure><p id="3660" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将获得一个默认的验证密钥。您也可以创建自己的密钥。新密钥通常需要几分钟才能生效。因此，在使用新密钥进行任何查询之前，您需要等待一段时间。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqb"><img src="../Images/d3c4a007e9c24c822616ae9175784e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YweK8ptJ7uIo7lquiSisTQ.png"/></div></div></figure><p id="05eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们复制验证密钥并将其粘贴到我们的程序中。</p><p id="3719" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到API页面。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqc"><img src="../Images/9f4e7a63eabd18e45c41dee707e8b1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EXrtpyf6wxknj09nDISUg.png"/></div></div></figure><p id="91ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有很多选择。这里，我们选择第一个:当前天气数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aki"><img src="../Images/51528efbdda7aeb670f542287a9210b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfX2UcwjMelqq5nUxyctGQ.png"/></div></div></figure><p id="d64a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">API地址非常简单。我们只需提供一个城市名和验证密钥。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqd"><img src="../Images/04f90814e7d29a13f18e65b0cf4edf46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJklwLDjhMR_uvGT5-8svA.png"/></div></div></figure><p id="5718" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个函数，并将其命名为query。我们给它传递一个城市名。</p><p id="18e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此函数需要异步。</p><p id="907a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将API地址移到查询函数中。</p><p id="7182" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从API地址中去掉了花括号。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqe"><img src="../Images/9d134c94fefa736e5f89a7500245ceb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSB_ShAa8TGuzRN8K2KIdw.png"/></div></div></figure><p id="160b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们需要给地址加上前缀<em class="np"> https冒号双斜杠</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anz"><img src="../Images/1ea1b68133a94715d1567b120fb82ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WoP_uBh-DZNfMspKP7V0rg.png"/></div></div></figure><p id="e38d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，API地址完成了。它从函数参数中获取城市名，从全局范围中获取验证密钥。</p><p id="0769" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加TRY CATCH语句。</p><p id="7832" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在TRY部分，我们“等待”axios get方法返回查询结果。我们需要这个查询是可取消的。除了API地址，我们还需要设置一个配置对象。我们稍后将处理配置对象。我们控制台记录查询结果。</p><p id="f35e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在THEN部分，我们输出错误消息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tz"><img src="../Images/963eec8074160dc81703a19e4c513da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JX7Fz3DpwszBFuWmMor2w.png"/></div></div></figure><p id="d9ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行函数。我们把伦敦交给它。</p><p id="3a80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">openWeather API返回给我们一个对象。在数据属性中，我们可以找到伦敦的天气信息。</p><p id="515b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">天气属性值是一个数组。第一个元素讲述被查询城市的天气描述。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqf"><img src="../Images/73f520f1241dbc7438bd82f7b9ca2d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_v8P-sNfp0p6_euFyoIjg.png"/></div></div></figure><p id="e023" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面的课程中，我们将只显示description属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqg"><img src="../Images/ce756aa52077b73bafd55a8c6fc1c982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jr9da_XhClpg4lLHo0eP1Q.png"/></div></div></figure><p id="f4ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们使axios get方法可取消。</p><p id="e58d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在config对象中，我们设置了cancelToken属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqh"><img src="../Images/ef2dae3ed601eb5a713ec8081c198e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIiXNQ7sRwA7pIi-k3Otcg.png"/></div></div></figure><p id="def8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在查询函数之外，我们创建一个新变量:source。我们使用source方法设置它的值。源方法来自cancelToken属性。</p><p id="3ded" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经得到了源对象。我们在get方法中注册它，这样源对象和get方法就连接起来了。</p><p id="2f66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用源点标记设置cancelToken属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqi"><img src="../Images/12a7af64b953dcd03c4471cfa8ef5350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82z09IEZ7fSUK9ujOEn2Zg.png"/></div></div></figure><p id="c540" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以从源对象中使用cancel方法取消get方法。我们可以向cancel方法传递一个通知tex。当我们取消get方法时，此通知将用作错误消息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wk"><img src="../Images/2b030f39e7220c656461fc28dd38d443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lu5V9Aba9gvbGAqqbTxFLw.png"/></div></div></figure><p id="399d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="8f5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到查询已被取消。错误消息是我们在cancel方法中设置的通知。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqj"><img src="../Images/1a38327116a3fd72ea2b851e9507f52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLLFwqTk-rwKC_Auyk6xGQ.png"/></div></div></figure><p id="173a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加另一个查询方法。</p><p id="9710" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们进行了两次查询，但只取消了一次。让我们运行程序。</p><p id="707b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到两个查询都被取消了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqk"><img src="../Images/a0cc4eda7b4b04f3fa52b7e5208dc053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gu9emjhgRUZfYotQ2mv9-w.png"/></div></div></figure><p id="5b90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将cancel方法移到两个查询方法之间。</p><p id="6eac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果和之前一样。这两个查询都已被取消，尽管第二个查询发生在cancel方法之后。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqf"><img src="../Images/4c9fabe7c18cf9d4406093b44d27331a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0sjVlouKPqB3fdR2vlbkQ.png"/></div></div></figure><p id="4119" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">源对象是独立的。它取消注册到它的每个查询。如果我们想单独取消查询，那么我们必须给每个查询一个专用的源对象。知道怎么做吗？</p><p id="216d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案是工厂模式。</p><p id="5ec2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们定义了一个queryFactory函数。</p><p id="1154" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将源变量和查询函数都粘贴到其中。</p><p id="e8f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们在一个对象文本中返回它们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wk"><img src="../Images/339d264769296698c1b8a74e39e22f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqZyarGc4RGFKZkuBtTUGg.png"/></div></div></figure><p id="62e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询方法现在被“密封”在queryFactory函数中。要访问它，我们必须首先运行query函数。我们将得到一个对象，它不仅包含查询方法，还包含一个新的源对象。</p><p id="a403" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次运行queryFactory函数，都会得到一个新的源对象和一个新的查询方法。</p><p id="99f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们运行queryFactory函数两次，并将返回的对象存储在变量A和b中。</p><p id="678b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们有两个源对象和两个查询方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/e78f29d5f9292bce13f368da50d2ba69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNF7zeZWf6j3-HERhAq0Gw.png"/></div></div></figure><p id="dfd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用实例A和b进行两个查询。</p><p id="3ed1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两次查询都成功了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqf"><img src="../Images/b70d26841776b772cea6b8b67c1fbd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGLqx8FQRrM9zeangACuPg.png"/></div></div></figure><p id="c138" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们从实例a调用cancel方法。</p><p id="766e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="ab08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到第一个查询被取消了，但是第二个查询成功了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aql"><img src="../Images/a2e9c2fdfc381cc30536b3fa8aaed702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ok043h2bPIFKmWP6bwqAcA.png"/></div></div></figure><p id="6a8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们从实例B调用cancel方法，我们将得到相反的结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aql"><img src="../Images/f79f53352afd9edf002f72f845b7d147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwUjdj89Z4nb1CF13AgNeA.png"/></div></div></figure><p id="4674" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们使用工厂模式创建了一个可取消的查询函数。工厂函数保证每个查询方法都有自己的源对象。这允许我们单独取消查询。</p><p id="64d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这节课中，我们将把它移植到一个Vue程序中。</p><p id="60fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件数据选项中，我们创建一个密钥属性，并将验证密钥存储在其中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqm"><img src="../Images/482ac631752099b289b7928304a5cc9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgLT1wsdnmYttkgVNEzjZw.png"/></div></div></figure><p id="3076" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们创建两个空属性:city和description。</p><p id="2559" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在组件模板中显示这两个属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi alu"><img src="../Images/59d29b61919d8c75af4dd1132e5cd95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AE514DQBhWW3v6ur0B66sg.png"/></div></div></figure><p id="d391" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们定义一个组件方法。我们将其命名为query。我们给它传递一个城市名。查询方法需要是异步的。</p><p id="1c9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将API地址复制到查询方法中。</p><p id="9778" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要用这个作为验证密钥的前缀。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi agz"><img src="../Images/93548e0c9729ebab1bea9dacf8d1dedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MljcICFfwDUBwWiSP4zrrA.png"/></div></div></figure><p id="fd22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加TRY CATCH语句。</p><p id="24f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在TRY部分，我们“等待”axios get方法。然后，我们将检索到的数据存储到一个名为result的变量中。</p><p id="3cea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将参数值赋给city属性，将检索到的天气描述赋给description属性。为了跟踪程序如何工作，我们还记录了城市和描述属性的控制台日志。在CATCH部分，我们在控制台记录错误消息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqn"><img src="../Images/5235c36cea782bd6a5f80b7770f3195d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jd0AGFnpuMVbEtgPJ_ytXQ.png"/></div></div></figure><p id="d4b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查一下查询方法。我们通过根组件实例运行它。我们把伦敦交给它。</p><p id="b430" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它起作用了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi and"><img src="../Images/26c8920671393b6b5c59953a8b847020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyfbYzJYQCtgNcTGa8_PJA.png"/></div></div></figure><p id="b4c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们安装创建的钩子，并从那里触发查询方法。</p><p id="a15c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，程序将自动使用London进行查询。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aps"><img src="../Images/6c001a22d2528a74d588c5650e138ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-78w4zrm_1PVpA8hA7KvXQ.png"/></div></div></figure><p id="bf7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要更改为不同的城市，我们再次运行查询方法，并向其传递一个新的城市名称。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqo"><img src="../Images/04e0858c741dd25d87670cff8e8b7c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jA3PQF7v33bXg02OYLrPA.png"/></div></div></figure><p id="a9f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们使查询方法可取消。</p><p id="60eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了一个新的数据属性:source。</p><p id="f0d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在查询方法中设置源值。我们将源对象分配给它。</p><p id="d5b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们在axios get方法中注册源对象。</p><p id="273a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查程序。</p><p id="0e72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到源对象已经被创建并存储在source属性中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajb"><img src="../Images/4b86a9514338f4395e0d1d3b3aa91afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nunmtjqrCLpmSuWqpOaFqg.png"/></div></div></figure><p id="eed2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个新的组件方法:cancel。</p><p id="4e3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用它来取消axios查询。我们通过source属性调用cancel方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xt"><img src="../Images/21f94bbb62409214d412cc9bbc13ecb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_VHYof2z07TFaTvhh32Lg.png"/></div></div></figure><p id="a464" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询已经完成。让我们运行cancel方法。</p><p id="e425" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们变得模糊了。结论是取消一个已完成的查询会返回未定义的结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adq"><img src="../Images/9995eb3921fc1eedbecbd3415873010e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLhmtYEW0uiIRcWOs-D0fA.png"/></div></div></figure><p id="233b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个测试方法。我们在其中调用查询和取消方法。</p><p id="7e82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到查询已被成功取消。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apw"><img src="../Images/179500bd97a207ebae65e47e7cd82726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1A4vhEzAHrRw0LHR4Wl6_g.png"/></div></div></figure><p id="4a21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们在测试方法中进行两个查询。</p><p id="c2e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到两个查询都成功了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ais"><img src="../Images/bb2a0ccfd94f080665164e4bee4af498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CilhDN9aje__7iul7P6sgQ.png"/></div></div></figure><p id="0dbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们在两个查询方法之间设置一个cancel方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aqp"><img src="../Images/d94bf7ff5a7e38f2c1ce7755c1df2937.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*fAuYbhB7AaI6dkIgdMcjYA.png"/></div></figure><p id="dcc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你认为我们会得到什么样的结果？是取消两个查询还是只取消第一个查询？</p><p id="e410" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们找出答案。</p><p id="adf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到第一个查询被取消了，但是第二个查询成功了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ais"><img src="../Images/ad43e82c59d14e0694dd5c1099a5b479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JE2VD78XMvGWzd9v7p_lsA.png"/></div></div></figure><p id="9659" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次运行查询方法时，我们都会创建一个新的源对象，并将其分配给source属性。然后，我们使用source属性注册源对象。</p><p id="ba1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着每次运行查询方法时，我们都用一个新的源对象更新源属性的值。这就是为什么cancel方法只取消在它之前执行的查询方法。组件实例扮演工厂功能的角色。</p><p id="f9d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要取消第二个查询，我们需要调用它背后的cancel方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqq"><img src="../Images/71d7ec6216dbbb3eb4e911f46e8feb33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7gaF0cXZg42b7vEWr68n7A.png"/></div></div></figure><p id="3fea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一课中，我们创建了一个可取消的查询方法。cancel方法取消之前执行的查询方法，但不会影响后面的查询方法。</p><p id="2017" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关键是在每次运行查询方法时，使用一个新的源对象来重置源属性的值。存储在source属性中的源对象总是指向在它之前执行的查询方法。</p><p id="e2ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们移除测试方法。</p><p id="d2f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件模板中，我们添加了一个按钮标签。</p><p id="16fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了v on指令来监控点击事件。我们触发change方法，并将<em class="np"> London </em>传递给它。我们也给这个按钮一个ref，这样我们就可以从Vue方法中访问它。</p><p id="f7e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们再复制三份按钮标签。我们设置了三个不同的城市和参考值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqr"><img src="../Images/e6b01f4572c7d63833f4f6c0a7bdfd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7bcnFJNQYwjed3x0IP_NQ.png"/></div></div></figure><p id="4268" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转到方法选项来定义<em class="np">变更</em>方法。</p><p id="2ac8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">改变的方法很简单。我们用它来改变城市财产的价值。</p><p id="5d42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了跟踪程序的执行过程，我们控制台记录了当前和新的城市名称。当前城市名称是城市属性的当前值。新的城市名称是传递给<em class="np"> change </em>方法的参数值。</p><p id="e6a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将参数值赋给city属性。更改城市名称是操作的开始。接收天气信息需要一段时间。所以我们将描述属性的值重置为<em class="np">加载信息</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aba"><img src="../Images/007b0e4467d6ef897075c07d0ecbc56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a96Ic5U9Wousysqje2FBVw.png"/></div></div></figure><p id="0dd1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，城市方法完成了。它所做的只是更改city和description属性的值。它不包含任何axios代码。</p><p id="f905" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查程序。</p><p id="244a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有四个按钮。点击按钮更改城市名称，并将描述属性a的值设置为<em class="np">加载信息</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqs"><img src="../Images/eb89666f609b6dbaa198e96bde035ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfUt9MHbW4Y_Sy0HCDYq6Q.png"/></div></div></figure><p id="120f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们已经在<em class="np"> change </em>方法中更新了城市属性。在查询方法中不需要再做一遍。我们删除第35行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqt"><img src="../Images/540950519095cd8de16bbb2f901d5c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZwPWtltO8gtSFApEdJrog.png"/></div></div></figure><p id="cdb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到创建的钩子来安装watchEffect方法。传递给watchEffect方法的回调是第二个副作用函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xl"><img src="../Images/c1dccf2e55028c789cdc6fa5f45201c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGnObjIrlq57BT3WmcNAvw.png"/></div></div></figure><p id="4d31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个副作用函数将在我们第一次加载程序时被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqu"><img src="../Images/3c9b7cdae3cacacc95038a8604824df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUJpQlVY5plyvKbZbM_Xng.png"/></div></div></figure><p id="e816" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们调用查询方法，并将这个点城市传递给它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqv"><img src="../Images/c41bef171af64ca1f179f647e8d5abd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiK4L3kMggvDT3Znpoicpw.png"/></div></div></figure><p id="e4f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，城市属性已经出现在第二个副作用函数的范围内。这使它有资格被watchEffect方法监控。</p><p id="d1bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询方法将在两种情况下被触发:当我们第一次加载程序时和当我们改变城市值时。</p><p id="8a99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询方法检索新城市的天气描述，并将其分配给description属性。</p><p id="f7ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="5929" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们刷新页面。</p><p id="ffeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询方法已被触发。我们还没有设置初始城市值，所以我们得到了一个错误消息。但这确实证明了查询方法会在我们第一次加载程序时被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqw"><img src="../Images/a99b2c37d1d8da87a3e0139de02abe60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWavR01pbkApeKNpNpNu2Q.png"/></div></div></figure><p id="1f47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建钩子的开始，我们给city属性一个初始值。我们把它设定在伦敦。</p><p id="57f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再试一次这个程序。</p><p id="2734" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到伦敦的天气信息已经被检索并显示在组件模板中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqx"><img src="../Images/95b0ecfc8396dcb77ef480a279a94ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URaNIOPHWJFORI2d0JQGlw.png"/></div></div></figure><p id="d619" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们换到一个不同的城市。</p><p id="3f16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市名称会立即改变。</p><p id="0ad1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">天气描述首先变成<em class="np">装载信息</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqy"><img src="../Images/bec0a9a53e7ca332f9ce5f827af8a1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IT71YVhtD2fP1qd0-xrk1g.png"/></div></div></figure><p id="db3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，它成为检索的天气信息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqz"><img src="../Images/e2c780cc5208ea11ea67617e90bf3e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAeFZ6_oUmQwzavfZFM8Ww.png"/></div></div></figure><p id="c4f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检索新城市的天气信息需要一段时间。如果我们在检索到当前城市的天气信息之前切换到一个新的城市，那么就不再需要完成当前的查询。我们只需要上一个城市的天气信息。那么如何取消一个中断的查询操作呢？</p><p id="9d64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">source属性为可取消的axios查询奠定了基础。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ara"><img src="../Images/bab25481c2b42146c0f08934e86ba6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_g7LZrz8CFiVRKCGPN7Bw.png"/></div></div></figure><p id="4096" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它存储当前查询操作的源对象。它的<em class="np"> cancel </em>方法使我们能够取消当前正在进行的查询操作。挑战在于何时调用cancel方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi arb"><img src="../Images/36703e7cf2f6519ea213694090c06f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*kXPhL0e4ersMwrCeLjX7xA.png"/></div></figure><p id="81ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们回到观看效果方法。我们安装onInvalidate函数来设置第一个副作用函数。</p><p id="fd5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个副作用函数在城市值改变时触发。最重要的是，它在我们在watchEffect方法中设置的所有东西之前触发，包括query方法。</p><p id="7957" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在第一个副作用函数中运行cancel方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aok"><img src="../Images/bd5337fc802e7f5fadb466560ba7e02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-g5iRIXrEuehHPOXHjnnZQ.png"/></div></div></figure><p id="7ea1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当城市值改变时，第一个副作用函数将首先触发，在查询方法之前。</p><p id="8839" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果前面的查询已经完成，cancel方法只返回false。其他都不会受到影响。查询方法仍将正常执行。</p><p id="3cdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果正在进行的查询尚未完成。它将被cancel方法取消。查询方法仍将按计划进行新的查询。</p><p id="0b9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们取消正在进行的查询时，city值已经发生了变化。因此，在通知文本中，我们无法访问正在进行的查询所使用的城市名称。在通知文本中，我们告诉用户当前城市之前的查询已被取消。<em class="np">这个圆点城市</em>指向新的城市名称。</p><p id="d7f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试这个程序。</p><p id="967f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们慢慢切换城市。在正在进行的查询结束之前，我们不会单击城市按钮。</p><p id="0768" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该程序运行良好。每当我们切换到一个新的城市，它的天气信息可以成功检索。第二个副作用函数不影响程序的执行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rw"><img src="../Images/c80d1b2e30b8dcecfa08360e5c5b1310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5U65QnK59iD2_KNAnlwjw.png"/></div></div></figure><p id="0836" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到methods选项来定义一个新方法。我们把它命名为<em class="np">种族</em>。</p><p id="da5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们设置了一个setTimeout函数。我们选择第一个按钮，使用它的ref并调用click方法来触发它。</p><p id="ab4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们以同样的方式触发其他三个按钮。</p><p id="fdfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">点击两个相邻按钮之间的时间间隔只有0.1秒，这不足以完成查询。所以只有最后一个查询会成功。前三个查询都将被取消。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arc"><img src="../Images/d087f65e4c5b4d249261cc3dec6123c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIFg2vB0Cy2TKFGoOA65Sw.png"/></div></div></figure><p id="82f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="d9c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们称之为竞赛方法。</p><p id="c183" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">初始城市值是伦敦，巧合的是，比赛方法切换到的第一个城市也是伦敦。从伦敦换到伦敦不会触发watchEffect方法。因此，不会进行任何查询。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ard"><img src="../Images/6a5f7e972f89500d926e6bed4ede076a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*HpjNOGcsa8jXOfHIs0c1wQ.png"/></div></figure><p id="f19a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总共进行了三次查询。最后只有最后一个成功了。之前对达勒姆和桑德兰的询问都被取消了。桑德兰是最后一个城市，它的天气信息终于恢复了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi are"><img src="../Images/7091094a6b587dd690461b8e4682dd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wig5ybr_eKfPc34GyWGo0w.png"/></div></div></figure><p id="9a37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们调整四个按钮的点击顺序。我们最后点击伦敦按钮。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abu"><img src="../Images/4a0f401f3a4e70300dbf9f067d83b9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDfPFuLoHTNKQuYpS1vbQg.png"/></div></div></figure><p id="fe77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再试一次这个程序。</p><p id="5b2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">已经进行了四次查询，前三次都被取消了。最后，我们得到了伦敦的天气信息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arf"><img src="../Images/a65edae39e0639fd744e77c92e47ccd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zB4h6jJQtVozTPh3hxOc6g.png"/></div></div></figure><p id="de4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们后面的课程中，我们将继续学习这个程序。让我们对它做一个简短的回顾。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anw"><img src="../Images/e1259c7edb74250cd2937e7ac5d34230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnyDFOeGbeVxQLkGSuqJ8Q.png"/></div></div></figure><p id="dd0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> change </em>方法由我们点击城市按钮触发。它重置城市值并将描述值更改为<em class="np">装载信息</em>。它不直接触发查询方法。</p><p id="40dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询方法在watchEffect方法中触发。每当城市属性的值发生变化时，它就会被触发。新的城市名称将被传递给查询方法。</p><p id="842e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询方法使用新的城市名称查询后端API，并将检索到的天气信息分配给description属性。</p><p id="6ec2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">query方法做的第一件事是创建一个新的source对象，并将其分配给source属性。</p><p id="2950" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有一个源属性。查询方法的所有执行都用新的源对象重置相同的源属性。换句话说，每次我们运行查询方法时，source属性将被重置为一个新值。这里的根组件作为一个闭包，为查询方法的所有执行提供一个惟一的共享源属性。</p><p id="3bbf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也意味着一旦新的查询方法被触发，它将重置源属性，这意味着源属性将失去与前一个查询的连接，因此无法取消它。</p><p id="fd6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是在城市名称的改变和查询方法的执行之间有一个时间差。watchEffect方法的设计允许我们利用这个时间间隙。</p><p id="be8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">watchEffect方法有两个副作用函数。</p><p id="d211" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个副作用函数总是在第二个副作用函数中定义的任何东西之前执行。这个设计至关重要。</p><p id="de1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在第一个副作用函数中取消查询，在第二个副作用函数中运行查询方法。</p><p id="7613" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着当第一个副作用函数触发时，城市名称已经更改，但查询方法尚未触发。源对象仍然指向正在进行的查询。这使我们能够取消正在进行的查询。</p><p id="a82a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们耐心地更改城市名，意味着我们只在当前查询结束后更改城市名，那么第一个副作用函数会取消已完成的查询。在上一课中，我们已经了解到取消一个已完成的查询只是返回undefined。程序将继续执行。什么都不会受影响。</p><p id="1170" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们在当前查询结束前更改城市名称，第一个副作用函数将触发并取消当前查询。然后第二个副作用函数将触发并执行带有新城市名的查询方法。</p><p id="0c81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不得不说watchEffect方法的设计堪称杰作。它使我们能够利用更改城市名和使用新的城市名进行新的查询之间的时间差。在这段时间间隔内，源对象仍然指向正在进行的查询。第一个副作用函数执行cancel方法并取消正在进行的查询。然后第二个副作用函数用新的城市名触发并运行查询方法。</p><p id="8087" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue 3引入了设置功能。它使我们能够将组件的可重复部分提取到可重用的代码片段中。这些可重用代码以函数的形式存储。这个函数可以被任何组件使用。它的功能范围帮助我们存储和保护数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeq"><img src="../Images/98b086e81b1351e1511735caef3648cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b63F0r1LJoDO4SRzy1yLuw.png"/></div></div></figure><p id="3f64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设置功能通过设置选项添加到组件中。该选项是一个挂钩点，在解析所有属性之后、创建组件实例之前执行。在创建组件实例之前，记住设置函数触发器是非常重要的。</p><p id="0541" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">setUp函数接收两个参数:props和context。这两个参数存储传递给组件的外部信息。稍后我们将向您展示详细信息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arg"><img src="../Images/60820aa95a32dcb4347435c89c952545.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*EhP684SI5MVbIPKVtJNdCA.png"/></div></div></figure><p id="db2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在一个真实的程序中试试setUp函数。</p><p id="c3df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们这里有一个非常简单的Vue程序。它只有一个组件:根组件。</p><p id="6be1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们安装安装选项并为其分配一个功能。</p><p id="84d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们控制台记录<em class="np">设置</em>并运行程序。</p><p id="abbe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到设置函数在beforeCreate钩子之前触发。这意味着设置功能在创建组件实例之前触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arh"><img src="../Images/1709117c895a41b76c8dd0caf0ea9fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRfsTV-bVTJJYSMFX_WmrQ.png"/></div></div></figure><p id="fb80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，setUp函数中的THIS不能指向组件实例，因为组件实例尚未创建。</p><p id="62a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它实际上指向了窗口对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apy"><img src="../Images/96796bd4addb30f2171e0b99f8860b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cM8c4SrWcqC_zou_xfcGqQ.png"/></div></div></figure><p id="46dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当你设计你的设置函数时，你应该避免使用它。不要试图访问属于组件实例的属性或方法。</p><p id="45f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设置功能只是分配给设置选项的普通功能。它有自己的功能范围。我们可以在里面定义变量和函数。这些属性和功能仅在设置功能中可见，因此受到保护。</p><p id="26d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们声明一个变量:city。我们把它的价值定在伦敦。</p><p id="ff81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们返回一个对象并把城市放入其中。返回对象的属性和方法将被添加到组件实例中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ari"><img src="../Images/36aad513cdc5a505ddd64d8e3a80054e.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*rWS6mzDH1Uu7dSOV6EsV3Q.png"/></div></figure><p id="fde2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查程序。</p><p id="7c51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以找到城市财产，它的价值是伦敦。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi apt"><img src="../Images/9d68eda6b91ef8da231f166bb14b6dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5vey-_qUOxOgfRSx2riBQ.png"/></div></div></figure><p id="e9da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里注意，城市属性不是数据属性。它只是添加到组件实例根级别的一个属性。但是这足以使它在组件模板中可见。我们可以通过双嵌套的花括号来显示它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arj"><img src="../Images/1d7eccc9351743c2206e12be53fb0ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CnSbU7y1TwEk9Y16S2Ouw.png"/></div></div></figure><p id="5ee7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市财产不是被动的。当我们改变它的值时，模板不会更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqo"><img src="../Images/ac69ee018b02921f881089ba94ca5404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgpr4wyRIPLGGErRIOkvew.png"/></div></div></figure><p id="bc09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市值是一个字符串。我们可以使用Vue ref方法使其反应。</p><p id="b0bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，城市价值是无功的。ref方法返回给我们一个引用对象。但是Vue为我们解开了那个物体。我们只是返回城市，并在模板中显示城市。不需要用<em class="np">点值</em>附录城市。</p><p id="4024" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到伦敦仍在展出。让我们检查组件实例。城市值是<em class="np">伦敦</em>，不是参照物。Vue为我们提取了value属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqo"><img src="../Images/44ea36fade87a64f4deb02cad84c2f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PsLSMk1K5Jc1zvWyITLdA.png"/></div></div></figure><p id="4bd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给vm点城市分配一个新值。</p><p id="10dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到模板已经自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajt"><img src="../Images/67cd20874fdda981ad575aea6744a446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELBn2NbD3bKbM44Jq0wqLg.png"/></div></div></figure><p id="c72c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建了一个基于城市的计算属性。我们将其命名为CapCity。</p><p id="8a3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<em class="np"> Vue dot computed </em>方法设置它的值。我们向它传递一个对象，并设置一个getter和setter。在getter中，我们返回<em class="np"> city.value.toUpperCase() </em>。这里我们需要value属性。city属性的值是一个引用对象。这里就不拆开了。接下来，我们添加setter。我们将新值分配给城市点值。不要忘记value属性。</p><p id="0c1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们把capCity加到返回的对象上。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ark"><img src="../Images/00d6b223a6ea8b6596aa2948651ffd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tj3w4ciqDA1S0ApaljRG2Q.png"/></div></div></figure><p id="e605" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件实例中，我们可以找到一个新的属性:capCity。它的值是大写的城市名。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi we"><img src="../Images/525ed63c96af8744e3d0a8033374b4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzoRofbKWoEgQU3PjTYnig.png"/></div></div></figure><p id="f5dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它在组件模板中也是可见的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wa"><img src="../Images/3c2215fbde009c40956899c74b6bc623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmLAkBPaVQSbwUx4hn5iNg.png"/></div></div></figure><p id="1caf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们改变城市值，capCity也会随之改变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi aod"><img src="../Images/e3e3ee7ae452cc58430f587de8a52a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*EmbWkkKenBHsL76J-ejc9A.png"/></div></figure><p id="29f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，如果我们给capCity分配一个新值，城市值也会改变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi arl"><img src="../Images/e44468fb6b741d08fe2d79205ccf2b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*n41IiN6csglPCMaXSD-OJw.png"/></div></figure><p id="e4e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了一个子组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqs"><img src="../Images/570fea961d0533f491883858aebf32a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrAkpb5ivaJFu7QSNTFS9Q.png"/></div></div></figure><p id="c40f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从设置函数返回的属性将被添加到组件实例中。如果我们想将属性发送给子组件甚至孙组件，我们可以<em class="np">提供</em>它们。</p><p id="428d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从Vue调用provide方法。我们提出两个论点。第一个是属性名，第二个是属性值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wr"><img src="../Images/990eb44210422e40fdcdddfec9f237dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4agJ_HO6L4w8EqwiZ2dE1Q.png"/></div></div></figure><p id="5887" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个提供方法只能提供一个属性。如果要提供多个属性，需要设置多个提供方法。</p><p id="608d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提供的属性不会自动添加到当前组件实例中。我们仍然需要归还他们。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi yq"><img src="../Images/9ee83a266c7ff028464293f63923a0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Mygl69-cChQgrtYluadxg.png"/></div></div></figure><p id="2f5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，城市和国家已经被添加到根组件实例中，并提供给所有子组件。</p><p id="c68b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件中，我们添加了<em class="np"> inject </em>选项来注入两个提供的属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vg"><img src="../Images/89db85754ab9e7d1c757647b6a22e9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lib55ov08YxsO1mattV3ZQ.png"/></div></div></figure><p id="9279" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行程序。</p><p id="d671" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们检查子组件实例。我们可以看到它有城市和国家的属性。两个属性值都是引用对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/38ec274975969d932d91ea57c3eef9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*em9T1Zq5YTOoKjfxZoQ9hw.png"/></div></figure><p id="39db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不能在子组件模板中直接显示这两个属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqu"><img src="../Images/0221d7e7eb21d67d881fb22d727c1ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDaz_XVpchQvlAi6S4LBrA.png"/></div></div></figure><p id="5c4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要给它们加上<em class="np">点值</em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi we"><img src="../Images/015932a1a52c6beb198b9d466a02cb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O2OAjHnTox-rCyeYr6IVUA.png"/></div></div></figure><p id="7658" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们可以在setUp函数中提供属性，那么我们也可以在其中注入属性。</p><p id="686d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在子组件中添加了一个设置函数。</p><p id="dd02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们声明一个变量，并用它来接收vue点注入方法的返回值。一个注入方法只能注入一个属性。</p><p id="925d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们返回一个对象，将城市和国家添加到子组件实例中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zi"><img src="../Images/649641deba4d7461bd846092f6c618a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUQKhAt-dF0hMmfFssFI8w.png"/></div></div></figure><p id="5c11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查子组件实例。</p><p id="dd93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到这一次,《城市与国家》被展开了。在城市模板中，我们不再需要值附录。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arm"><img src="../Images/65755c53c9fdd4b39754175dc1c6da2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7AF6keRc32mDe7hUn1qhQ.png"/></div></div></figure><p id="1ef4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">城市和国家都是反应性的。如果我们从根组件端改变它们，子组件模板将自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aja"><img src="../Images/cae9ecc67d7f983fccfa62764514ecc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlsuqBk6JkGFtQN6vybyNw.png"/></div></div></figure><p id="15c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将讨论在设置函数中定义函数。</p><p id="7163" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了一个函数，并将其命名为test。</p><p id="3afb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们控制台日志函数名和这个。</p><p id="198f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们返回它，将它添加到组件实例中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arn"><img src="../Images/fa4c1908fa08d832528ea827af7f9f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MU1jGI84kXBhR6TYsK7psQ.png"/></div></div></figure><p id="f229" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试函数将被添加到根组件实例中，因此成为它的一个方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi za"><img src="../Images/c8987667f89be1da8cd61392929e06c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*El3wAcgQNWIWorZmM55XLQ.png"/></div></div></figure><p id="5a4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这在函数中是由函数的位置决定的。如果我们通过根组件实例运行该函数，它将指向根组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aro"><img src="../Images/5ea75e6b1fd0360f82ffd8a303c0b1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgtjTaSw-hhBh5AySrstgg.png"/></div></div></figure><p id="5834" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们可以访问根组件的数据属性。我们可以看到测试函数已经成功地输出了标题属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arp"><img src="../Images/b5b19fc86d4156623063b7b71b525ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMGSEf1lNn87305ugr9ccA.png"/></div></div></figure><p id="a9b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在组件模板中添加一个按钮。我们用它来触发测试功能。这次，<em class="np">这个点标题</em>返回未定义。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arq"><img src="../Images/e769b1162493b1f1b53645823e1c98c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORXVkm9Ax3wSsea4du2XQg.png"/></div></div></figure><p id="1525" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这实际上指向了窗口对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arr"><img src="../Images/a207b59dc881960a222e5818b3879dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DinLOiav-Dl9BQWJcreE2Q.png"/></div></div></figure><p id="0a4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过根组件实例运行测试方法，它可以指向根组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ars"><img src="../Images/1eb4f7664de42587fbafcd141a4ba97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSBxvjahjlfdYqQPD7H2zQ.png"/></div></div></figure><p id="1c3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设置功能不是预定义组件属性和方法的地方。我们已经有适合这项工作的MixIn了。</p><p id="eade" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setUp函数中定义的函数可以利用setUp函数的作用域。</p><p id="d497" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在设置函数中声明了一个消息变量。我们不退货。这使得消息变量仅在设置函数内部可见。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi zm"><img src="../Images/b0fd2bc8548c003ab3b5de6edc4219be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SA-T68RpRWwi1zN3qy1bBQ.png"/></div></div></figure><p id="ae72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，测试函数可以访问消息变量。如果我们返回测试函数，那么我们可以通过根组件实例发送消息属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi art"><img src="../Images/a8c0e49b4c29bbb4781e1a90485fea15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTRqqdTzyuoZ6CaU38VaaQ.png"/></div></div></figure><p id="7545" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，无论我们如何触发测试函数，我们总能获得消息值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adh"><img src="../Images/9b6e15cd0bf53367a93439b076b5ceb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSBWDTaVqL3EzcYW_ggCMQ.png"/></div></div></figure><p id="09b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你们中的一些人可能已经意识到我们刚刚创建了一个结束程序。设置函数扮演外部函数的角色，测试函数是返回的子函数。测试功能可以访问设置功能中定义的变量。测试函数本身将被加载到组件实例中。因此，组件实例可以访问setUp函数范围内定义的变量。</p><p id="9407" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">非常重要的一点是，你要明白设置函数不是用来预定义普通的Vue组件方法的。这是mixins的工作。</p><p id="df95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这节课中，我们将讨论setUp函数的两个参数。</p><p id="39aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Props是将数据从父组件发送到其子组件的最常用方法。我们首先在子组件中声明一个道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/0f73c16110a60fcd4025d669f88280d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*RH78MTITqxB9cinMml_dtw.png"/></div></figure><p id="cfd1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在根组件的data选项中，我们创建了一个新的属性:message。我们可以通过邮件属性将消息值发送到子组件中。我们找到子组件标签。我们添加了<em class="np"> v bind </em>指令来将消息属性分配给邮件属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aoy"><img src="../Images/4dd4225ab446b8e245fef046bed665a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Q2wNZreo-zDf9WlZfmNFQ.png"/></div></div></figure><p id="1baf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，邮件道具有了它的价值。让我们在子组件模板中显示它。</p><p id="5c2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们打开子组件实例，我们可以找到名为$props的属性。</p><p id="d118" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性值是双重嵌套的代理对象。它致力于管理道具。我们可以在里面找到邮件道具。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aru"><img src="../Images/3dbfd8818b5ca9d11f260a2ede136839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvGjuWIoCdkkVzY_JEBKuw.png"/></div></div></figure><p id="c5f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个对象将作为它的第一个参数被传递给设置函数，从而使设置函数能够访问组件的属性。</p><p id="5606" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们转到子组件并添加设置功能。我们控制台记录了它的两个参数。</p><p id="999a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个参数让我们可以访问传递给子组件的所有属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arv"><img src="../Images/a11d0c5607f508a08153a5f381811cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i82bbg5odklAMJqr5T4UkQ.png"/></div></div></figure><p id="8d19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第二个参数中，我们可以找到emit方法。它使setUp函数能够发出一个自定义事件并向其传递一个属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi anp"><img src="../Images/05cfdd75c0aee82e12acf052925971fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8MH_Zw7KPygFAt9qgdb3Q.png"/></div></div></figure><p id="53b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试emit方法。</p><p id="0cb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，我们要发送的属性不应该在组件实例中定义。它应该在设置函数中定义。</p><p id="c27d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们声明一个变量:city。我们把它的价值定在伦敦。</p><p id="50a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们通过<em class="np">上下文</em>调用emit方法。我们把这个事件称为接力赛。我们将城市变量作为第二个参数传递给emit方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi arw"><img src="../Images/6cd5f640d3b3eccca0f4d9c71eee8700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*70VtIyoDFnoALdwMMQHqhA.png"/></div></figure><p id="ce33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转到根组件的数据选项。</p><p id="720a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们设置了一个新的属性:位置。我们把它的初始值设为<em class="np">未知。</em>然后我们在根组件的模板中显示位置属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi adg"><img src="../Images/6c4439ce081ed72865564670119d99b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KJYaB4i1MPly1V9g5hFuw.png"/></div></div></figure><p id="2911" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件标签中，我们添加了<em class="np"> v on </em>指令来监控中继事件，并将<em class="np"> $event </em>分配给位置属性。</p><p id="5097" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到伦敦已被发送到根组件。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arx"><img src="../Images/1a68cb4afd70268b87bd64957ba282a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5MyI1Hcg1um0ZZPYMLRWw.png"/></div></div></figure><p id="1d77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一课中，我们将看看上下文对象的另外两个属性:属性和槽。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aqu"><img src="../Images/76f706147b05a5eb53bd4a5dcc2672c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81BbCEU7Mf-hDu8uSG6d1Q.png"/></div></div></figure><p id="c7c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">expose方法供内部使用。我们不需要它。</p><p id="f362" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从属性开始。属性是我们添加到子组件标签中的非属性。</p><p id="e1d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件标记中，我们添加了title属性，并使用info属性设置其值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ary"><img src="../Images/00acef4ea7fce5b97ac7106261830272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8tfH5qQLTl-gx3vX3O-3A.png"/></div></div></figure><p id="5314" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们转到根组件的数据选项来定义info属性。我们将其值设置为hello。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi or"><img src="../Images/3979503cf845edeac958e91d7d9f23ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77Mtw4r6LgmWRGahrrcsCA.png"/></div></div></figure><p id="c426" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">title属性将被添加到子组件模板的根DIV中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arh"><img src="../Images/b216b22a73a2cd2e201fb3dc455884cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*953c5SOi38xdwPRT_4pIHQ.png"/></div></div></figure><p id="9f5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上下文对象中，我们还可以找到关于标题属性的信息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi arz"><img src="../Images/e141d0f45c58f33432c9a4af0005a7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDr3okAgstH7pZW66h-P8w.png"/></div></div></figure><p id="8a71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，尽管attributes属性是一个代理对象，但它不是反应性的。未来对标题属性所做的更改将不会反映出来。我们给info属性分配一个新值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ug"><img src="../Images/5a11cd118b04d31198f10850cdf7ba29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7uqc6CxtBsrQ_on9Hd7EQ.png"/></div></div></figure><p id="172d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">标题值已自动更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wo"><img src="../Images/53c04866ff06a0bf1eb0ed31ca6838bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1dt4M_-OHpqDiQmvOA--Q.png"/></div></div></figure><p id="9d8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性对象的标题属性保持不变。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi sw"><img src="../Images/a7dc5507e1726ed194914d6462200b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CihPfLNxAUpDhW66cv2n-Q.png"/></div></div></figure><p id="b213" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有道具对象是被动的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ani"><img src="../Images/b617e860e43c8aec3eb3a3a4ca456db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNpZlEADGoJLGAZ42AkppA.png"/></div></div></figure><p id="3972" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果需要观察非道具属性，不要在设置功能中将观察者设置为<em class="np">上下文，属性</em>永远不会改变。将观察器安装在子组件的一个生命周期挂钩中。</p><p id="ca11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来试试吃角子老虎机。插槽属性也不是反应性的。</p><p id="b231" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件模板中，我们添加了两个命名的插槽。我们把它们分别命名为<em class="np">城市</em>和<em class="np">国家</em></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vv"><img src="../Images/2b009074a568a389afb50618658d8f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gm1hlRiJADrsEx9XNyWZWQ.png"/></div></div></figure><p id="fb1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，在开始和结束子组件标记之间，我们将内容分配给两个命名的槽。</p><p id="6ce1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于城市位置，我们设置了两个页面元素。</p><p id="c094" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在国家插槽中，我们只放了一个页面元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asa"><img src="../Images/181b859d783ef55c6cd8a3d530cf0726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-zqSzZwsDZ18rPljgeJ2Q.png"/></div></div></figure><p id="835a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到两个插槽工作正常。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asb"><img src="../Images/1cc89a634c40b23880969ce3ab2bf4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYtrLqGe0QdtcJgBOg7abQ.png"/></div></div></figure><p id="e2e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查上下文对象的slots属性。</p><p id="12c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有两个命名的槽，所以我们有两个以这两个槽命名的方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ya"><img src="../Images/c281b7f89e9ddfdbaecd54da3e787d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaEHoBPVbPR72pxn4G5Xyg.png"/></div></div></figure><p id="6aff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们调用两个slot方法，我们将得到由两个slot显示的内容的虚拟节点。同样，上下文点槽没有反应。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asb"><img src="../Images/de14254dcee513d8de0cbdfe85993ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1v6zpQb5hmp_AQyvclWww.png"/></div></div></figure><p id="8e07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本课中，我们将使用闭包和工厂模式创建一个计数器应用程序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi vw"><img src="../Images/88dff85add8c0cb60c48d4d34de32d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8zJ115NmZXoGO1c8dcO9w.png"/></div></div></figure><p id="2fdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们创建一个工厂函数，它也作为外部函数。我们称之为反工厂。在工厂函数内部，我们声明了一个变量:number。我们将其值设置为零。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi asc"><img src="../Images/563dd9091482caae6f4027a4f9b52ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*w3aQIy8U19p1saM2P1h6Xg.png"/></div></figure><p id="7d48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们定义一个子函数:increment。increment函数将number的值加1，然后返回该值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi asd"><img src="../Images/cd46061d0df1af7dc602fce62c5ee0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*VlV00Jpjbv5OsfQGjwavPg.png"/></div></figure><p id="733d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们返回一个对象。</p><p id="a525" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在返回的对象中，我们设置了一个数字属性，并使用数字变量设置其值。属性名和变量名相同。我们可以使用简写语法。</p><p id="2ae3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用相同的简写语法将increment函数添加到返回的对象中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ase"><img src="../Images/95bfddb09814215b9848e675cee87e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*kt0w0azphnLGCtmy9TPL3g.png"/></div></figure><p id="53e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">工厂功能现在完成了。</p><p id="03dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用它创建一个对象。number属性的初始值为零。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi asf"><img src="../Images/a45caf22955f4bde65716844ad6fd4e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*VY5RbDiMHlRlnKNweRgXEQ.png"/></div></figure><p id="fd39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行几次increment方法。</p><p id="9b90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，我们执行了两次increment方法。第二次执行返回2。但是number属性的值仍然为零。知道为什么吗？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asg"><img src="../Images/308e326fdd2deda24cd30fe0e51868bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPVeEih8lI2CYSmwCXEINQ.png"/></div></div></figure><p id="54ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数字属性是<strong class="kd iu">而不是</strong>数字变量。number属性的值是使用number变量的初始值设置的。除此之外，他们之间没有任何联系。对number变量的更改不会影响number属性。</p><p id="2beb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们使用一个对象来设置number变量的值，事情会完全不同。我们添加value属性，并给它赋零。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ash"><img src="../Images/51975dd0c2aa554afa3dcdc57a8cef53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*D0H2UwIMagVqlyZFKHLXpw.png"/></div></figure><p id="f25c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对象是一个参考值。通过将number变量赋给number属性，我们实际上是将该对象的内存地址赋给了number属性。</p><p id="e7a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，number属性和number变量指向同一个对象。通过number变量对value属性所做的更改将由number属性反映出来。</p><p id="e49e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在增量函数中，我们用点值附录数字。</p><p id="4b72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">increment函数不再需要返回数字变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi tg"><img src="../Images/1f700c9eb95c9d305f28251a821dd154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*8gr03tlpZzw0O_MNc9Rm-Q.png"/></div></figure><p id="6563" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查程序。</p><p id="3c56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们运行增量法。然后我们输出计数器对象。我们可以看到number属性已经更新。它的值现在是1。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/daffcac9c00423c3907498474634da90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*v4AFhhA2Fyy75T2T7Y-Nlg.png"/></div></figure><p id="0206" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们再次运行增量。</p><p id="1a4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数值现在是2。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi tu"><img src="../Images/f9ca3765c614e2a6a1a729dc2a740365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*mMnQA1qIZ57x7pFjSGUasg.png"/></div></div></figure><p id="6a4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将计数器对象连接到页面元素。</p><p id="d18d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们选择B标签，并使用number属性设置其内部文本。我们需要给附录编号加上<em class="np">点值</em>。</p><p id="350b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们选择按钮标签并监听点击事件。</p><p id="53b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们称之为增量法。</p><p id="1239" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们重置B标签的内部文本。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wm"><img src="../Images/f2a3b936f59cbf35e2b96d0b8ae1a05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C34Db8n8Xuefvidtwifg4A.png"/></div></div></figure><p id="8656" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试这个程序。</p><p id="f95e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，每点击一次按钮，旁边的数字就会增加一。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qp"><img src="../Images/52988ac5c9c2570c8a86f4fb82f84a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIPoWO3Wdq2tC8qMmB6prw.png"/></div></div></figure><p id="c768" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关键是使用对象设置number变量的值。该对象使数字变量和数字属性保持同步。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi abo"><img src="../Images/4e85446a891b825efde76607d6bcf587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5It0KtL9BASLgFY4Q73dng.png"/></div></div></figure><p id="066d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到了另一个计数器应用程序。这个应用程序是使用Vue创建的。</p><p id="443b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数字属性是一个数据属性，这意味着它是反应性的。增量为number属性的值加1。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qk"><img src="../Images/e99516484491694f1267baa353d6646f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*of55mQbV9HOJC3S-Mg-2pQ.png"/></div></div></figure><p id="c1d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在设置功能中重新创建这个计数器应用程序。</p><p id="6cae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不再需要数字属性。也不需要increment方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asi"><img src="../Images/b3be33c9b5a077c9cc4bbe9755f45acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOC7u_u_7-QyPYcweSvImQ.png"/></div></div></figure><p id="6412" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们增加了设置功能。</p><p id="6eb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们声明一个名为number的变量。我们需要数字是反应性的。所以我们使用Vue点引用方法来设置它的值。我们将零传递给ref方法。这一步至关重要。它使number变量的值成为一个参考值的对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/e64c59bf791a379c4898edd57035f390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4lk02QADEGusAfry-ceYg.png"/></div></div></figure><p id="e6f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们创建一个子函数:increment。</p><p id="fd61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给数字点值加1。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi asj"><img src="../Images/5cc5096cf3768ed7ee13c4a10c1a179f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*wVAGx8Y6cmU23GhNEIQcIw.png"/></div></figure><p id="4e10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们返回一个对象，把数字和增量放在里面。</p><p id="fd2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">number属性存储引用对象的内存地址，因此可以反映其属性的最新状态。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ask"><img src="../Images/88a3c3749527d4e057199f6afae06049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*tMdCztxVXEEv0olGozia3w.png"/></div></figure><p id="1900" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，柜台App完成了。</p><p id="227f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来测试一下。</p><p id="5030" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到它和以前一样工作。</p><p id="ea88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数字变量的值是一个引用对象。number属性和number变量指向同一引用对象。因此，通过number变量对引用对象所做的更改也可以通过number属性反映出来。</p><p id="dc9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Vue为我们解开了参照物。我们可以直接在模板中显示数字属性。我们不需要在附录中添加点值。但是在增量法中，我们仍然需要点值附录。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ra"><img src="../Images/3c37bafdd29367d6b794bf150400528e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PT3v-kCmw74NMWDRyIt98A.png"/></div></div></figure><p id="bd9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建另一个变量:step。我们将其值设置为5。</p><p id="1fe1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在增量函数中，我们把步长加到数字点值上。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi xg"><img src="../Images/9590e6a776285e4562915d8fc5e78f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*iA7OYYtrp2QmnfqhBbcGkw.png"/></div></figure><p id="6dd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，每次我们单击按钮，number属性的值都会增加5。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asl"><img src="../Images/951efd82676500bea6dfd62f234089f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fy90zTMxGc2qhUH9FzqLzw.png"/></div></div></figure><p id="7790" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们没有返回步长变量。所以它不会被添加到组件实例中。换句话说，它在设置功能中受到保护。在我们的实际项目中，我们可以使用这个特性来保护敏感信息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aeu"><img src="../Images/3eae3f8be8001854c6cbc1209203d07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kC-QPeJ8_BXy2WrxW2uAuA.png"/></div></div></figure><p id="014d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们之前创建的天气应用程序。</p><p id="7c01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总共有四个按钮，代表四个城市。单击这些按钮会触发<em class="np"> change </em>方法，该方法会更新city属性的值并将天气描述设置为加载通知。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lh"><img src="../Images/93115253c485ba8fc85a3565a5735066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zScPy2jC3H8KJ1fZdGO16Q.png"/></div></div></figure><p id="78e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">query方法查询openWeather API并将检索到的天气描述分配给description属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aro"><img src="../Images/9dc53e9bac3703eef75737d4f6c03d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__obXqwVM__RFi0Nyt73Dg.png"/></div></div></figure><p id="1565" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建的钩子中，我们使用watchEffect方法安装了一个观察器。它监视城市属性并触发查询方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ars"><img src="../Images/eba3d6009f202a2cb2438d3cf6297e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DU-xUK6pujpxxfjjjyVfEg.png"/></div></div></figure><p id="d8e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果新的查询在当前查询完成之前开始，当前正在进行的查询将被取消。这有助于提高程序效率，因为我们最终只需要一个查询结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aop"><img src="../Images/8043d11b942e010b6d246a4a91954ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3S3p_u9ba8LgX6spV6b-w.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asm"><img src="../Images/791152785fd3cf1d1ec5e6874109de3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDe_1h-A1ZI0baXskLSJZA.png"/></div></div></figure><p id="e535" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">source属性是我们可以取消查询的原因。</p><p id="1c2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次运行query方法时，我们都会创建一个新的cancelToken对象，并将其分配给source属性。</p><p id="671a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">axios get方法注册cancelToken。</p><p id="b19f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="np"> onInvalidate </em>方法中，我们可以使用来自source属性的cancel方法取消查询。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ane"><img src="../Images/904a3b8fd0c072a654d1ebb816124d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eV7zAbM8flNPJrwDME5uQ.png"/></div></div></figure><p id="ed5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在数据选项中，我们有关键属性。它存储了我们用来查询openWeather API的验证密钥。</p><p id="5be6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，验证密钥是一条非常敏感的信息。如果其他组件需要查询openWeather API，它们也需要这个键。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asn"><img src="../Images/1a9ddff5c771ee8cfc3bb5e2672aee27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkx6fL3OWOdmz8qXUpwzRQ.png"/></div></div></figure><p id="769c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">存储验证密钥的最佳位置是设置功能。只要我们不返回验证密钥，它就只在setUp函数的范围内可见。这也意味着我们需要将整个查询程序移到setUp函数中。</p><p id="2e5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将设置功能添加到组件实例中。我们定义了一个变量:key。我们使用验证密钥设置它的值。我们不再需要密钥属性。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi aso"><img src="../Images/c83429f46433774c0c3ca018e8ce5d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeRuAsJaKmXsA8Iwb9y1vw.png"/></div></div></figure><p id="9b3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个程序的挑战是使查询可取消。这就要求每个查询方法都必须有自己的cancelToken，这样才能被准确识别。</p><p id="34cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道如何将每个查询方法与一个专用的cancelToken配对吗？</p><p id="b1a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案是工厂模式。我们定义一个工厂函数:queryFactory。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi rj"><img src="../Images/e491a7d1105775e5090142f272cf2623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_SvPwSNfRoCiogqnzKN8Q.png"/></div></div></figure><p id="6ee5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在工厂函数内部，我们首先声明一个变量:source。我们用它来存储cancelToken。然后我们定义查询函数。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qd"><img src="../Images/e88268075846ca2107be726be8b2c2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8R1cOUPB4O1KRafqqJzCA.png"/></div></div></figure><p id="a9ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们给它传递一个城市名。</p><p id="1fec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了追溯查询过程，我们控制台日志<em class="np">查询</em>和<em class="np">城市名称</em>。该语句标志着查询的开始。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ajk"><img src="../Images/89ff25faa85072f2d1c1f643ba288e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-ReoCiVAd_sBZVkytwe5g.png"/></div></div></figure><p id="8a98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们准备API地址。</p><p id="7fb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">验证是在父范围中定义的。没有必要以此为前缀。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asp"><img src="../Images/0e882a46f88ca308f3a0fa1efb5aca0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFm26BBqDkt3lEW0G7_w4Q.png"/></div></div></figure><p id="ddfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们添加一个TRY CATCH语句。</p><p id="d03f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在TRY部分，我们“等待”axios get方法返回查询结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi xx"><img src="../Images/d1081224eae167e3840c9611a85f9cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hhOvhaQ-2NL76v7DL8GNQ.png"/></div></div></figure><p id="80e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在get方法的config对象中，我们使用工厂函数中定义的source变量注册cancelToken。</p><p id="37bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，每个查询方法都有自己的cancelToken。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asq"><img src="../Images/47397a0813baf99846cc1d1d26cd39e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUX2vRq3T-6Qaz-F9KVZxA.png"/></div></div></figure><p id="5e5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">等待</em>需要与<em class="np">异步</em>配合工作。记得在查询函数前加上前缀<em class="np"> async </em>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asr"><img src="../Images/02cb7d52a2730a74fa80cf0b80b13952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YleSXtPPBcGZotW_iviKRA.png"/></div></div></figure><p id="2022" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将查询结果存储在一个名为result的变量中。我们在控制台日志中记录了城市名称和天气描述。然后我们返回天气描述。</p><p id="68f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在CATCH部分，我们在控制台记录错误消息。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ass"><img src="../Images/d199ddd1762bfc6220bcb0a82be520ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxo5U8SPU8Q_EDP3Mo4w8Q.png"/></div></div></figure><p id="73e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在查询函数之外，我们返回一个对象。我们将源变量和查询函数放入其中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ast"><img src="../Images/c0ad64f51e7eb50bf81ad3c282454c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfDH0eR2rT9LZswvBkeJTQ.png"/></div></div></figure><p id="8126" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们每次运行工厂函数，都会得到一个查询方法和一个专用的source属性。</p><p id="7151" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在setUp函数结束时，我们返回一个对象并将queryFactory函数放入其中。queryFactory函数将被添加到组件实例中。</p><p id="b4b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不返回关键变量。因此受到保护。但是返回的queryFactory函数仍然可以访问key变量。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi amw"><img src="../Images/0b74d6e6d3e607f0d5fe545019a1d327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2H77w36V3h3GY0oKnRbsDw.png"/></div></div></figure><p id="b334" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们转到创建的钩子。</p><p id="dd77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们移除查询方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi uq"><img src="../Images/576ccee1b6553a4dd2062a010d2b00d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7foJkG1zBuOcF7aVt6jKw.png"/></div></div></figure><p id="008a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用queryFactory函数创建一个实例。</p><p id="44dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将cancelToken对象分配给source属性。现在，<em class="np"> invalidate </em>方法可以访问<em class="np"> cancelToken </em>并取消查询。</p><p id="f8ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们调用查询方法，并将检索到的天气描述分配给description属性。</p><p id="8646" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将这个点城市传递给查询方法。现在，这个点城市已经出现在watchEffect方法的第二个副作用函数中。因此，watchEffect方法将开始监视城市属性的值。当我们重置城市属性的值时，它将被触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asu"><img src="../Images/7f56b17a16b38f0fd18b6836df3e6913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*el7m4lBUybH26eVa8rm9VA.png"/></div></div></figure><p id="8d71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询方法是异步的。</p><p id="3804" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们需要等待。我们还需要用async作为回调的前缀。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi wt"><img src="../Images/ca00845fd7d071d581af042d35d50d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hz7k2VglBYugYVbM4P3I7Q.png"/></div></div></figure><p id="2cd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不再需要原来的查询方法。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi all"><img src="../Images/373e9e0d8e4a52b7c626664b1c63a07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OetYszi9tYvxMYqMIrxvbg.png"/></div></div></figure><p id="fcab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查程序。</p><p id="3c59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们刷新页面。</p><p id="21c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">伦敦的天气信息已经被自动检索。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ars"><img src="../Images/9efb3a22364ea2ad14a3f6b7aac41772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-uuuAofMQCSMn2jSQl4nQ.png"/></div></div></figure><p id="ffc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试试其他城市。</p><p id="d554" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该计划正在按预期运行。城市更改由watchEffect方法检测，查询方法由新的城市名称触发。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asv"><img src="../Images/4d7f2748943aa5442f364bf49e266335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-caX_3ae9M7DY6XYomha4g.png"/></div></div></figure><p id="48ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查源属性。</p><p id="14c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的值是一个cancelToken对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ars"><img src="../Images/42bf05dd30b1f45f69827f367e1b5593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_30DlpbuPLHSDjEZLEgrug.png"/></div></div></figure><p id="102a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们运行race方法。</p><p id="33c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，只检索到了伦敦的天气信息。</p><p id="8d9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">起始城市价值是桑德兰。巧合的是，桑德兰是第一个采用比赛方式的城市。</p><p id="024a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从Sunderland改为Sunderland不会触发查询方法。</p><p id="bc20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以只进行了三次查询，其中只有两次最终被取消。只有最后一个查询成功。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asw"><img src="../Images/7a8032a047495244d2422cca787b0d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rEWVzw0Qn1dZssH5-BQVg.png"/></div></div></figure><p id="be30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们切换到伦敦，再次运行比赛方法。</p><p id="8745" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，进行了四次查询，其中三次被取消。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asx"><img src="../Images/8f700545ffa9dc170817aead02849e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrtRxxHSPZOIn_2M8AS_CA.png"/></div></div></figure><p id="03fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最终的城市值是伦敦，我们已经检索了伦敦的天气信息。</p><p id="6ef9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">queryFactory函数将被添加到组件实例中。但是与其他普通的组件方法不同，queryFactory函数是在setUP函数内部定义的，因此可以访问验证密钥。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi asy"><img src="../Images/8d9c95d168d47b91387c764462ffed52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hnn6zBZuGA7viEGYVwaBIw.png"/></div></div></figure><p id="2a1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们执行工厂函数时，我们将创建一个源属性和一个查询方法。</p><p id="9f61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">source属性存储cancelToken对象。</p><p id="ad98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建的钩子中，在我们执行了queryFactory函数之后，我们将cancelToken对象分配给source属性。现在，组件实例已经收到了cancelToken。</p><p id="77f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果onInvalidate方法被触发，它将使用source属性中存储的cancelToken取消查询。</p></div></div>    
</body>
</html>