<html>
<head>
<title>Constructing flexible patterns with Sass</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Sass构建灵活的模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/constructing-flexible-patterns-with-sass-cf9cb0b1b32f?source=collection_archive---------2-----------------------#2019-11-16">https://levelup.gitconnected.com/constructing-flexible-patterns-with-sass-cf9cb0b1b32f?source=collection_archive---------2-----------------------#2019-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3ef9234caea4cfca8bdbdeb2e44df617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64C0W7mJLLeiIw1yMipn6Q.jpeg"/></div></div></figure><p id="997d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个团队中工作可能很棒，尽管我经常发现自己和那些对造型不感兴趣的人一起工作。这不是一件坏事——这只是意味着作为一名开发人员，我必须有一种更柔和的方法来应对潜在的挫折，并且更加明确地告诉<em class="kw">什么是</em>、<em class="kw">如何</em>以及<em class="kw">为什么</em>。你知道那是什么感觉——当有人打开一份公关时，你的心落地了，然后— <em class="kw">喘息— </em>他们修改了你的风格。不是一般的风格，而是非常有意图的风格。你深思熟虑地组合在一起的款式，同时提前10步考虑它在整个图案方案中的位置。我们如何抑制这种情况，我们能抑制它吗？我们怎样才能创造一个灵活的模式呢？</p><p id="81c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是房间里的一只普通大象:</p><p id="d3ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">“我们的模式库是否足够灵活来服务它的消费者？”</em></p><p id="3ae0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在开发一个企业库，答案通常是<em class="kw">“不”</em>。即使有了品牌指南，设计师也总是会推出稍有变化的新设计，改变模式本身然后发布会给消费者带来意想不到的结果。</p><p id="cd42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我没有灵丹妙药，但我确实有一个解决方案，它提供了一点灵活性，可以帮助您避免“再造轮子”的危机，让您避免开发速度的意外中断。</p><p id="6819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，我在胡言乱语。让我们开始吧。</p><p id="b57a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我向你介绍…</p><h1 id="9838" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">基于构造函数的混合</h1><p id="f0fc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我知道，这个名字不够壮观，但是谁知道呢——也许我们可以改变它！</p><p id="0810" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单地说，基于构造函数的mixin镜像Javascript构造函数，因为您可以将映射传递到mixin中，使用mixin作为整个模式的构造函数，并且它将新值与默认值合并(非破坏性的)。所以…基本上，它只是一个普通的mixin，有一个行话的名字，<em class="kw">，但是它有一个内部模式——行话。</em></p><p id="bafb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Sass中，模式如下:</p><ul class=""><li id="6f20" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">创建一个接受<code class="fe mj mk ml mm b">map</code>的<code class="fe mj mk ml mm b">mixin </code>。</li><li id="478b" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">将空映射的默认值添加到mixin参数中。</li><li id="c052" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">使用非破坏性地图合并方法将新特性与默认地图合并。</li><li id="d0e5" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">将地图属性分配给Sass规则。</li></ul><p id="6564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个使用这种方法的例子:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="762f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">变量<code class="fe mj mk ml mm b">$card-config</code>和<code class="fe mj mk ml mm b">$button-config </code>包含它们对应的mixins为修改而暴露的所有属性的映射。如果您决定不修改一个属性，这不是问题，因为使用了非破坏性的合并方法。它会回到默认值。</p><p id="916d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过注释掉映射来查看默认值，或者只是防止它们被传递到mixins中。</p><p id="35de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看幕后发生了什么:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="ms mt mu mv gt my mm mz na aw nb bi"><span id="6527" class="nc ky iq mm b gy nd ne l nf ng"><a class="ae nh" href="http://twitter.com/mixin" rel="noopener ugc nofollow" target="_blank">@mixin</a> card-constructor($map: ()) {<br/><br/>  $config: map-extend(<br/>    (<br/>      background: #81866e,<br/>      text: white,<br/>      padding: 18px 12px,<br/>      avatar: (<br/>        size: 100px, <br/>        background: #F7882F, <br/>        radius: 50%,<br/>        accent-1: #DCC7AA,<br/>        accent-2: #F7C331<br/>      )<br/>    ),<br/>    $map<br/>  );</span><span id="d027" class="nc ky iq mm b gy ni ne l nf ng">  ...</span><span id="9e86" class="nc ky iq mm b gy ni ne l nf ng">}</span></pre><p id="cf5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">mixin被创建，如前所述，一个空贴图被分配给<code class="fe mj mk ml mm b">$map</code>作为它的默认值。一个<code class="fe mj mk ml mm b">map-extend</code> Sass函数被用于将默认值与<code class="fe mj mk ml mm b">$map</code>合并。</p><h1 id="31a6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">地图-扩展</h1><p id="7ba6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe mj mk ml mm b">map-extend </code>无损合并两张地图。你可以在上面codepen的SCSS标签中看到代码，或者<a class="ae nh" href="https://github.com/sebnitu/BaseWeb/blob/master/src/scss/core/_functions.scss#L17" rel="noopener ugc nofollow" target="_blank">在这里查看源代码</a>(归功于<a class="nj nk ep" href="https://medium.com/u/40e4a78f8dbb?source=post_page-----cf9cb0b1b32f--------------------------------" rel="noopener" target="_blank"> Sebastian Nitu </a>)，因为它是一个没有内置到Sass中的第三方函数。</p><p id="394f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">map-extend</code>的函数签名如下所示:</p><pre class="ms mt mu mv gt my mm mz na aw nb bi"><span id="953f" class="nc ky iq mm b gy nd ne l nf ng">@param $map (AKA $merge-into in the example)<br/>@type first <br/>@param $maps (AKA $merge-from in the example)<br/>@type list of maps<br/>@param $deep (AKA $is-deep-merge in the example)<br/>@desc Whether or not to enable recursive mode.<br/>@type boolean<br/>@default false<br/>@return merged map</span><span id="db66" class="nc ky iq mm b gy ni ne l nf ng">map-extend($merge-into, $merge-from, $is-deep-merge)</span></pre><p id="b6cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到mixin也包含了卡片图案的样式。让我们检查几个规则。</p><pre class="ms mt mu mv gt my mm mz na aw nb bi"><span id="f7be" class="nc ky iq mm b gy nd ne l nf ng">.card {<br/>    background: map-get($config, background);<br/>    border-radius: 4px;<br/>    color: map-get($config, text);<br/>    padding: map-get($config, padding);<br/>    min-height: 400px;<br/>    width: 300px;<br/>    &amp;__avatar {<br/>      background: map-fetch($config, avatar, background);<br/>      border-radius: map-fetch($config, avatar, radius);<br/>      box-shadow: 12px 12px 0px 0px map-fetch($config, avatar, accent-1), -12px -12px 0px 0px map-fetch($config, avatar, accent-2);<br/>      margin: 0 auto 36px auto;<br/>      padding: 24px;<br/>      width: map-fetch($config, avatar, size);<br/>    }</span><span id="5faa" class="nc ky iq mm b gy ni ne l nf ng">    ...</span><span id="90a2" class="nc ky iq mm b gy ni ne l nf ng">}</span></pre><h1 id="2f3e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">地图获取+地图提取</h1><p id="7264" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe mj mk ml mm b">map-get</code>从<code class="fe mj mk ml mm b">$config</code>图中检索一个<em class="kw">浅</em>值，并将其分配给相应的规则。<code class="fe mj mk ml mm b">map-get </code>内置于语言中，因此不需要任何第三方依赖。下面是函数签名的样子:</p><pre class="ms mt mu mv gt my mm mz na aw nb bi"><span id="0f2c" class="nc ky iq mm b gy nd ne l nf ng">map-get($map, $map-key)</span></pre><p id="242b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也会注意到<code class="fe mj mk ml mm b">map-fetch</code>。<code class="fe mj mk ml mm b">map-fetch</code>是一个<em class="kw">深</em>T10】，意思是它可以返回嵌套的值。这是一种更简单的方法:</p><pre class="ms mt mu mv gt my mm mz na aw nb bi"><span id="0295" class="nc ky iq mm b gy nd ne l nf ng">$avatar-map: map-get($config, avatar)</span><span id="9bfd" class="nc ky iq mm b gy ni ne l nf ng">.some-class {<br/>    background: map-get($avatar-map, background)<br/>}</span></pre><p id="eb4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为它没有内置到Sass中，所以你需要<a class="ae nh" href="https://css-tricks.com/snippets/sass/deep-getset-maps/" rel="noopener ugc nofollow" target="_blank">将代码</a>添加到你的代码库中。它的函数签名如下所示:</p><pre class="ms mt mu mv gt my mm mz na aw nb bi"><span id="702d" class="nc ky iq mm b gy nd ne l nf ng">map-fetch($map, $keys...)</span></pre><p id="ae27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">省略号意味着它接受无数的关键参数，因此无论嵌套多深，您都可以获取值。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="07c1" class="kx ky iq bd kz la ns lc ld le nt lg lh li nu lk ll lm nv lo lp lq nw ls lt lu bi translated">与React、Vue或Angular一起使用</h1><p id="dd9a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最简单的解决方案是将您的Sass mixins发布到一个私有的<code class="fe mj mk ml mm b">npm</code>注册表，就像您发布任何模式库一样。然后将它作为一个依赖项安装到您的项目中，并将mixins直接从<code class="fe mj mk ml mm b">node_modules</code>导入到您的组件的Sass文件中。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="b7ab" class="kx ky iq bd kz la ns lc ld le nt lg lh li nu lk ll lm nv lo lp lq nw ls lt lu bi translated">结论</h1><p id="d27b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在我们已经结束了，我希望你离开这里的时候至少能带走一样东西，不管是Sass maps，一种使用mixins的时髦新方法，还是一个问题的解决方案。感谢阅读！</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/99d4a71a8b91550927bd7a945fcd6269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*BoLibzN4JbNm6OPj4AA60Q.jpeg"/></div></figure></div></div>    
</body>
</html>