<html>
<head>
<title>Optimal Floating Point Adjustments to an Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对数组的最佳浮点调整</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimal-floating-point-adjustments-to-an-array-ee6ea90cfa55?source=collection_archive---------15-----------------------#2021-02-03">https://levelup.gitconnected.com/optimal-floating-point-adjustments-to-an-array-ee6ea90cfa55?source=collection_archive---------15-----------------------#2021-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="9c5e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">一些最有趣的编程面试问题都是基于数组的。这些面试问题的输入是简单的整数数组或浮点数。作为候选人，您的任务是对这些数字执行一些操作(可能找到最频繁出现的一个，或者数组中最大的和；或者，找到对数组的最佳浮点调整，就像今天的问题所要求的那样)。</em></p><p id="fca0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">大多数基于数组的问题很容易陈述和理解。对于这些问题，想出并编写最简单、效率最低的解决方案也是极其容易和快速的。(确保您能够在几分钟内编写出最简单的解决方案！).与此同时，通常需要一个聪明的技巧或对数据结构的巧妙使用来提出最佳、最有效的解决方案。在这两种情况下，解决方案通常需要不到50行代码。</p><p id="fb29" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">今天，我们有一篇很长的帖子来讨论Airbnb提出的一个基于阵列的问题。我们提出三种难度越来越大、效率越来越高的解决方案。随意浏览</em> <a class="ae kw" href="https://medium.com/swlh/smallest-missing-positive-integer-in-an-array-b6f197e78a16" rel="noopener"> <em class="kv">老帖子</em> </a> <em class="kv">了解更多基于数组的问题。</em></p><h1 id="b763" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">问题:</h1><p id="3019" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">给你一个浮点数数组<code class="fe ma mb mc md b">X</code>，<code class="fe ma mb mc md b">x1</code>，<code class="fe ma mb mc md b">x2</code>，… <code class="fe ma mb mc md b">xn</code>。这些可以向上或向下舍入，以创建一个相应的整数数组<code class="fe ma mb mc md b">Y</code><code class="fe ma mb mc md b">y1</code>、<code class="fe ma mb mc md b">y2</code>、… <code class="fe ma mb mc md b">yn</code></p><p id="67a3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">编写一个算法，找到具有以下属性的适当的<code class="fe ma mb mc md b">Y</code>数组:</p><ul class=""><li id="01e3" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">两个数组的舍入总和应该相等。</li><li id="2dd5" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">元素之间的绝对成对差异被最小化。换句话说，<code class="fe ma mb mc md b">|x1- y1| + |x2- y2| + ... + |xn- yn|</code>应该越小越好。</li></ul><p id="25d2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">比如，假设你的输入是<code class="fe ma mb mc md b">[1.3, 2.3, 4.4]</code>。在这种情况下，你不可能比<code class="fe ma mb mc md b">[1, 2, 5]</code>做得更好，它有一个<code class="fe ma mb mc md b">|1.3 - 1| + |2.3 - 2| + |4.4 - 5| = 1</code>的绝对差值。</p><h1 id="0d0d" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解决方案1:递归</h1><p id="50d1" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">数组中的每个索引<code class="fe ma mb mc md b">i</code>有两种可能的舍入模式:(1)使用<code class="fe ma mb mc md b">ceil</code>向上舍入，和(2)使用<code class="fe ma mb mc md b">floor</code>向下舍入。我们简单的递归解决方案只需执行以下步骤:</p><ol class=""><li id="d2f2" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku ms mk ml mm bi translated">它尝试索引的这两种模式<code class="fe ma mb mc md b">i</code></li><li id="a46d" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku ms mk ml mm bi translated">对于每种模式，它递归地为数组的后缀<code class="fe ma mb mc md b">[i+1, ..., n]</code>和剩余的目标差找到最优解</li><li id="8dcf" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku ms mk ml mm bi translated">在一种情况下，它将解与差<code class="fe ma mb mc md b">numbers[i] - floor(numbers[i])</code>相结合，在另一种情况下与<code class="fe ma mb mc md b">ceil(numbers[i]) - numbers[i]</code>相结合，以找到从索引<code class="fe ma mb mc md b">i</code>开始的数组后缀的最优解。</li></ol><p id="ac5e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是最简单解决方案的递归c++代码。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="07b9" class="na ky it bd kz nb nc dn ld nd ne dp lh ki nf ng ll km nh ni lp kq nj nk lt nl bi translated">复杂性</h2><p id="dea1" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">原始数组中每个可能的索引<code class="fe ma mb mc md b">i</code>有2个可能的值(<code class="fe ma mb mc md b">floor</code>和<code class="fe ma mb mc md b">ceil</code>)，我们正在尝试每个索引的每个可能的值。由于数组中有<code class="fe ma mb mc md b">n</code>个索引，尝试的值的总数。因为我们对每个值的组合都执行恒定量的工作，所以总的时间复杂度也是O(2ⁿ).</p><p id="61b1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">还有另一种计算时间复杂度的方法。对<code class="fe ma mb mc md b">adjust_recursive</code>的每一次调用都会使<em class="kv">对</em>进行两次具有较小值的递归调用。它还花费O(n)时间复制数组。结果，大小为n的输入的时间复杂度T(n)由<code class="fe ma mb mc md b">T(n) = 2T(n-1) + O(n)</code>给出。这个递归公式的解是T(n) = O(2ⁿ).</p><p id="f8dc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们显然可以做得比这更好！</p><h1 id="5f79" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解决方案2:记忆化</h1><p id="d4e7" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">我们的第一个突破来自于观察到我们在重复执行！特别是，我们用<em class="kv">同一套参数多次重复调用<code class="fe ma mb mc md b">adjust_recursive</code>！。</em>当问题的不同实例共享它们的子问题时，可以通过<em class="kv">动态规划来有效地计算解决方案。我们简单地缓存或记忆子问题的解，并在执行计算之前首先查找缓存的解。</em></p><p id="e464" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于我们的问题，我们的<em class="kv">记忆表</em>的关键由两部分组成</p><ul class=""><li id="e3a0" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated"><em class="kv"> offset: </em>记忆表中的条目只计算原数组后缀<code class="fe ma mb mc md b">numbers[offset...]</code>的有效解</li><li id="8bf6" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated"><em class="kv"> target: </em>该表还对后缀施加了约束—调整后(向上或向下舍入)后缀的总和<code class="fe ma mb mc md b">numbers[offset...]</code>应该完全等于target！</li></ul><p id="eb49" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此记忆表的元素<code class="fe ma mb mc md b">table[(offset, target)]</code>返回原始数组后缀<code class="fe ma mb mc md b">numbers[offset...]</code>的最优解，这样调整后的数组加起来就是<code class="fe ma mb mc md b">target</code>！</p><p id="9661" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面介绍使用记忆表对递归算法的修改。该解决方案还增加了一个额外的函数，使用记忆表重新计算调整后的数组:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="21cc" class="na ky it bd kz nb nc dn ld nd ne dp lh ki nf ng ll km nh ni lp kq nj nk lt nl bi translated">复杂性</h2><p id="5672" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">一个简单的记忆技巧对基本递归算法进行了重大改进！然而，分析这个算法的复杂性有点困难。这里有一种计算复杂度的方法</p><ul class=""><li id="f7c5" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">记忆键的<code class="fe ma mb mc md b">target</code>部分的下限是<code class="fe ma mb mc md b">floor(numbers[0]) + floor(numbers[1]) + ... + floor(numbers[n])</code>，上限是<code class="fe ma mb mc md b">ceil(numbers[0]) + ceil(number[1]) + ... + ceil(numbers[n])</code>。还有<code class="fe ma mb mc md b">target</code>可以拿的<code class="fe ma mb mc md b">O(N)</code>值！</li><li id="7d93" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">记忆键的<code class="fe ma mb mc md b">offset</code>部分也采用<code class="fe ma mb mc md b">O(N)</code>值。因此，存储表中插入的键的总数。</li><li id="de28" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">对于表中插入的每一个值，我们都要执行一定量的工作，因此，该算法的总复杂度也是O(N)。</li></ul><p id="c917" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们能做得更好吗？事实证明我们可以！</p><h1 id="d075" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解决方案3:贪婪</h1><p id="e093" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">这个问题的有效解决方案取决于关键的洞察力:</p><p id="ca0e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设我们根据<em class="kv">原始数和它的底的差对原始<code class="fe ma mb mc md b">numbers</code>数组进行排序。</em>即索引<code class="fe ma mb mc md b">i</code>，使得<code class="fe ma mb mc md b">numbers[i] - floor(numbers[i])</code>最小，最先出现，等等。我们把排序后的数组叫做<code class="fe ma mb mc md b">floors</code>。然后，在最佳解决方案中，</p><blockquote class="nm nn no"><p id="f239" class="jx jy kv jz b ka kb kc kd ke kf kg kh np kj kk kl nq kn ko kp nr kr ks kt ku im bi translated"><em class="it">存在一个索引，</em> <code class="fe ma mb mc md b"><em class="it">best_idx</em></code> <em class="it">，这样整个前缀</em> <code class="fe ma mb mc md b"><em class="it">floors[0...best_idx]</em></code> <em class="it">向下舍入</em><strong class="jz iu"><em class="it"/></strong><em class="it">(使用floor)，整个后缀</em> <code class="fe ma mb mc md b"><em class="it">floors[best_idx+1...]</em></code> <em class="it">向上舍入</em><strong class="jz iu"><em class="it"/></strong><em class="it">(使用ceil)。</em></p></blockquote><p id="9df0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">情况如下图所示:</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/0851bb0452f1a74fbf41a8a9ae3466bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*fPzzcpH69-kuQY-P"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">调整阵列的单个元素</figcaption></figure><p id="1588" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里，条形的高度表示原始数字的(排序的)小数部分。最终解中，所有蓝色数字<em class="kv">向下取整(floor) </em>，所有红色数字<em class="kv">向上取整(ceil)。</em></p><p id="d32b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种<em class="kv">局部优化</em>产生全局解的方法是<strong class="jz iu"> <em class="kv">贪婪算法的标志。</em> </strong>下面是这个问题的贪婪算法的一个实现</p><ol class=""><li id="4c2a" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku ms mk ml mm bi translated">首先根据<code class="fe ma mb mc md b">(numbers - floors(numbers))</code>差对数组进行排序。</li><li id="f93f" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku ms mk ml mm bi translated">从末尾开始遍历排序后的数组，找到最优的<code class="fe ma mb mc md b">best_idx</code>索引。</li></ol><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="e46d" class="na ky it bd kz nb nc dn ld nd ne dp lh ki nf ng ll km nh ni lp kq nj nk lt nl bi translated">复杂性</h2><p id="aca3" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">我们终于找到了解决这个问题的最有效的算法！这种解决方案的大部分复杂性集中在<code class="fe ma mb mc md b">std::sort</code>调用中，其最坏情况的复杂性为O(N logN)。所有后续代码都只是使用O(N)时间在数组上迭代一次。因此，这个解决方案的总复杂度是O(N logN)。</p><h1 id="c418" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试</h1><p id="f7c1" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">让我们用<a class="ae kw" href="https://github.com/cpp-testing/GUnit" rel="noopener ugc nofollow" target="_blank"> GUnit测试</a>测试几个案例</p><ul class=""><li id="918f" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">空列表</li><li id="0b01" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">单一元素列表(向上或向下舍入)</li><li id="dc72" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">示例中的复杂列表</li></ul><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="f146" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">原载于2021年2月3日</em><a class="ae kw" href="https://cppcodingzen.com/?p=2450" rel="noopener ugc nofollow" target="_blank"><em class="kv"/></a><em class="kv">。</em></p></div></div>    
</body>
</html>