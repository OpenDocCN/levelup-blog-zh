<html>
<head>
<title>How to execute an object file: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何执行目标文件:第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-execute-an-object-file-part-2-655eb8b9a811?source=collection_archive---------29-----------------------#2021-04-04">https://levelup.gitconnected.com/how-to-execute-an-object-file-part-2-655eb8b9a811?source=collection_archive---------29-----------------------#2021-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1239" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理重新定位</h2></div><p id="543e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-execute-an-object-file-part-1-2c92d962f276">之前的文章</a>中，我们学习了如何解析一个目标文件并从中导入和执行一些函数。然而，我们的玩具对象文件中的函数是简单和自包含的:它们完全基于输入计算输出，没有任何外部代码或数据依赖。在本帖中，我们将基于第1部分中的<a class="ae lb" href="https://github.com/cloudflare/cloudflare-blog/tree/master/2021-03-obj-file/1" rel="noopener ugc nofollow" target="_blank">代码，探索处理带有一些依赖关系的代码所需的额外步骤。</a></p><p id="f493" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可能会注意到，我们实际上可以使用我们的<code class="fe lc ld le lf b">add5</code>函数重写我们的<code class="fe lc ld le lf b">add10</code>函数:</p><p id="7e74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg">对象c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="70cd" class="lp lq iq lf b gy lr ls l lt lu">int add5(int num)<br/>{<br/>    return num + 5;<br/>}<br/> <br/>int add10(int num)<br/>{<br/>    num = add5(num);<br/>    return add5(num);<br/>}</span></pre><p id="bb51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们重新编译目标文件，并尝试用我们的<code class="fe lc ld le lf b">loader</code>程序将它作为一个库:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="9fd0" class="lp lq iq lf b gy lr ls l lt lu">$ gcc -c obj.c<br/>$ ./loader<br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 42</span></pre><p id="95c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哇哦。这里有些不对劲。<code class="fe lc ld le lf b">add5</code>仍然产生正确的结果，但是<code class="fe lc ld le lf b">add10</code>没有。根据您的环境和代码组成，您甚至可能会看到<code class="fe lc ld le lf b">loader</code>程序崩溃，而不是输出不正确的结果。为了理解发生了什么，让我们研究一下编译器生成的机器码。我们可以通过要求<a class="ae lb" href="https://man7.org/linux/man-pages/man1/objdump.1.html" rel="noopener ugc nofollow" target="_blank"> objdump工具</a>从我们的<code class="fe lc ld le lf b">obj.o</code>上拆卸<code class="fe lc ld le lf b">.text</code>部分来做到这一点:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="cc84" class="lp lq iq lf b gy lr ls l lt lu">$ objdump --disassemble --section=.text obj.o<br/> <br/>obj.o:     file format elf64-x86-64<br/> <br/> <br/>Disassembly of section .text:<br/> <br/>0000000000000000 &lt;add5&gt;:<br/>   0:	55                   	push   %rbp<br/>   1:	48 89 e5             	mov    %rsp,%rbp<br/>   4:	89 7d fc             	mov    %edi,-0x4(%rbp)<br/>   7:	8b 45 fc             	mov    -0x4(%rbp),%eax<br/>   a:	83 c0 05             	add    $0x5,%eax<br/>   d:	5d                   	pop    %rbp<br/>   e:	c3                   	retq<br/> <br/>000000000000000f &lt;add10&gt;:<br/>   f:	55                   	push   %rbp<br/>  10:	48 89 e5             	mov    %rsp,%rbp<br/>  13:	48 83 ec 08          	sub    $0x8,%rsp<br/>  17:	89 7d fc             	mov    %edi,-0x4(%rbp)<br/>  1a:	8b 45 fc             	mov    -0x4(%rbp),%eax<br/>  1d:	89 c7                	mov    %eax,%edi<br/>  1f:	e8 00 00 00 00       	callq  24 &lt;add10+0x15&gt;<br/>  24:	89 45 fc             	mov    %eax,-0x4(%rbp)<br/>  27:	8b 45 fc             	mov    -0x4(%rbp),%eax<br/>  2a:	89 c7                	mov    %eax,%edi<br/>  2c:	e8 00 00 00 00       	callq  31 &lt;add10+0x22&gt;<br/>  31:	c9                   	leaveq<br/>  32:	c3                   	retq</span></pre><p id="9c29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你不必理解上面的全部输出。这里只有两条相关的线:<code class="fe lc ld le lf b">1f: e8 00 00 00 00</code>和<code class="fe lc ld le lf b">2c: e8 00 00 00 00</code>。这些对应于我们在源代码中的两个<code class="fe lc ld le lf b">add5</code>函数调用，并且<a class="ae lb" href="https://man7.org/linux/man-pages/man1/objdump.1.html" rel="noopener ugc nofollow" target="_blank"> objdump </a>甚至方便地将指令解码为<code class="fe lc ld le lf b">callq</code>。通过在线查看<code class="fe lc ld le lf b">callq</code>指令的描述(就像<a class="ae lb" href="https://www.felixcloutier.com/x86/call" rel="noopener ugc nofollow" target="_blank">这个</a>)，我们可以进一步看到我们正在处理一个“近的、相对的调用”，因为有了<code class="fe lc ld le lf b">0xe8</code>前缀:</p><blockquote class="lv lw lx"><p id="cf10" class="kf kg lg kh b ki kj jr kk kl km ju kn ly kp kq kr lz kt ku kv ma kx ky kz la ij bi translated">调用near，relative，相对于下一条指令的位移。</p></blockquote><p id="45ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据<a class="ae lb" href="https://www.felixcloutier.com/x86/call" rel="noopener ugc nofollow" target="_blank">描述</a>，这个<code class="fe lc ld le lf b">callq</code>指令的变体由5个字节组成:前缀<code class="fe lc ld le lf b">0xe8</code>和一个4字节(32位)参数。这就是“相对”的来源:参数应该包含我们想要调用的函数和当前位置之间的“距离”——因为x86的工作方式是从下一条指令而不是我们当前的<code class="fe lc ld le lf b">callq</code>指令开始计算这个距离。<a class="ae lb" href="https://man7.org/linux/man-pages/man1/objdump.1.html" rel="noopener ugc nofollow" target="_blank"> objdump </a>在上面的输出中方便地输出了每条机器指令的偏移量，所以我们可以很容易地计算出需要的参数。例如，对于第一条<code class="fe lc ld le lf b">callq</code>指令(<code class="fe lc ld le lf b">1f: e8 00 00 00 00</code>)，下一条指令位于偏移量<code class="fe lc ld le lf b">0x24</code>。我们知道我们应该调用<code class="fe lc ld le lf b">add5</code>函数，它从偏移量<code class="fe lc ld le lf b">0x0</code>(我们的<code class="fe lc ld le lf b">.text</code>部分的开始)开始。所以相对偏移量是<code class="fe lc ld le lf b">0x0 - 0x24 = -0x24</code>。注意，我们有一个负参数，因为<code class="fe lc ld le lf b">add5</code>函数位于调用指令之前，所以我们将指示CPU从当前位置“向后跳”。最后，我们必须记住，负数——至少在x86系统上——是由它们的<a class="ae lb" href="https://en.wikipedia.org/wiki/Two's_complement" rel="noopener ugc nofollow" target="_blank">二进制补码</a>表示的，因此<code class="fe lc ld le lf b">-0x24</code>的4字节(32位)表示就是<code class="fe lc ld le lf b">0xffffffdc</code>。同样，我们可以计算第二个<code class="fe lc ld le lf b">add5</code>调用的<code class="fe lc ld le lf b">callq</code>参数:<code class="fe lc ld le lf b">0x0 - 0x31 = -0x31</code>，二进制补码- <code class="fe lc ld le lf b">0xffffffcf</code>:</p><figure class="lh li lj lk gt mc gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/a7f37b1ff676c6eb0f4c25dc477c2f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*u0Pi0yHfEEKdLzF8glVmjg.png"/></div></figure><p id="6003" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎编译器没有为我们生成正确的<code class="fe lc ld le lf b">callq</code>参数。我们已经计算出预期的参数是<code class="fe lc ld le lf b">0xffffffdc</code>和<code class="fe lc ld le lf b">0xffffffcf</code>，但是编译器在这两个地方都留下了<code class="fe lc ld le lf b">0x00000000</code>。让我们先检查一下我们的预期是否正确，在尝试执行它之前，通过修补我们加载的<code class="fe lc ld le lf b">.text</code>副本:</p><p id="158e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg"> loader.c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="1ae0" class="lp lq iq lf b gy lr ls l lt lu">...<br/> <br/>static void parse_obj(void)<br/>{<br/>...<br/>    /* copy the contents of `.text` section from the ELF file */<br/>    memcpy(text_runtime_base, obj.base + text_hdr-&gt;sh_offset, text_hdr-&gt;sh_size);<br/> <br/>    /* the first add5 callq argument is located at offset 0x20 and should be 0xffffffdc:<br/>     * 0x1f is the instruction offset + 1 byte instruction prefix<br/>     */<br/>    *((uint32_t *)(text_runtime_base + 0x1f + 1)) = 0xffffffdc;<br/> <br/>    /* the second add5 callq argument is located at offset 0x2d and should be 0xffffffcf */<br/>    *((uint32_t *)(text_runtime_base + 0x2c + 1)) = 0xffffffcf;<br/> <br/>    /* make the `.text` copy readonly and executable */<br/>    if (mprotect(text_runtime_base, page_align(text_hdr-&gt;sh_size), PROT_READ | PROT_EXEC)) {<br/>...</span></pre><p id="ae9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来测试一下:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="e60a" class="lp lq iq lf b gy lr ls l lt lu">$ gcc -o loader loader.c <br/>$ ./loader <br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 52</span></pre><p id="5b2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，我们的猴子补丁起了作用:<code class="fe lc ld le lf b">add10</code>现在执行得很好，并产生了正确的输出。这意味着我们计算的预期的<code class="fe lc ld le lf b">callq</code>参数是正确的。那么为什么编译器会发出错误的<code class="fe lc ld le lf b">callq</code>参数呢？</p><h2 id="f820" class="lp lq iq bd mf mg mh dn mi mj mk dp ml ko mm mn mo ks mp mq mr kw ms mt mu mv bi translated">迁移</h2><p id="148a" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">我们的toy对象文件的问题是，两个函数都用外部链接声明——这是c中所有函数和全局变量的默认设置。尽管两个函数都在同一个文件中声明，但编译器不确定<code class="fe lc ld le lf b">add5</code>代码将在目标二进制文件中的何处结束。所以编译器避免做任何假设，也不计算<code class="fe lc ld le lf b">callq</code>指令的相对偏移量。让我们通过移除我们的猴子补丁并将<code class="fe lc ld le lf b">add5</code>函数声明为<code class="fe lc ld le lf b">static</code>来验证这一点:</p><p id="93b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg"> loader.c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="5e98" class="lp lq iq lf b gy lr ls l lt lu">...<br/> <br/>    /* the first add5 callq argument is located at offset 0x20 and should be 0xffffffdc:<br/>     * 0x1f is the instruction offset + 1 byte instruction prefix<br/>     */<br/>    /* *((uint32_t *)(text_runtime_base + 0x1f + 1)) = 0xffffffdc; */<br/> <br/>    /* the second add5 callq argument is located at offset 0x2d and should be 0xffffffcf */<br/>    /* *((uint32_t *)(text_runtime_base + 0x2c + 1)) = 0xffffffcf; */<br/> <br/>...</span></pre><p id="1177" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">T21:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="5b80" class="lp lq iq lf b gy lr ls l lt lu">/* int add5(int num) */<br/>static int add5(int num)<br/>...</span></pre><p id="4ff6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重新编译和分解<code class="fe lc ld le lf b">obj.o</code>给了我们以下内容:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="0c6e" class="lp lq iq lf b gy lr ls l lt lu">$ gcc -c obj.c<br/>$ objdump --disassemble --section=.text obj.o<br/> <br/>obj.o:     file format elf64-x86-64<br/> <br/> <br/>Disassembly of section .text:<br/> <br/>0000000000000000 &lt;add5&gt;:<br/>   0:	55                   	push   %rbp<br/>   1:	48 89 e5             	mov    %rsp,%rbp<br/>   4:	89 7d fc             	mov    %edi,-0x4(%rbp)<br/>   7:	8b 45 fc             	mov    -0x4(%rbp),%eax<br/>   a:	83 c0 05             	add    $0x5,%eax<br/>   d:	5d                   	pop    %rbp<br/>   e:	c3                   	retq<br/> <br/>000000000000000f &lt;add10&gt;:<br/>   f:	55                   	push   %rbp<br/>  10:	48 89 e5             	mov    %rsp,%rbp<br/>  13:	48 83 ec 08          	sub    $0x8,%rsp<br/>  17:	89 7d fc             	mov    %edi,-0x4(%rbp)<br/>  1a:	8b 45 fc             	mov    -0x4(%rbp),%eax<br/>  1d:	89 c7                	mov    %eax,%edi<br/>  1f:	e8 dc ff ff ff       	callq  0 &lt;add5&gt;<br/>  24:	89 45 fc             	mov    %eax,-0x4(%rbp)<br/>  27:	8b 45 fc             	mov    -0x4(%rbp),%eax<br/>  2a:	89 c7                	mov    %eax,%edi<br/>  2c:	e8 cf ff ff ff       	callq  0 &lt;add5&gt;<br/>  31:	c9                   	leaveq<br/>  32:	c3                   	retq</span></pre><p id="1703" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们重新声明了具有内部链接的<code class="fe lc ld le lf b">add5</code>函数，编译器现在更有信心并且正确地计算了<code class="fe lc ld le lf b">callq</code>参数(注意x86系统是<a class="ae lb" href="https://en.wikipedia.org/wiki/Endianness" rel="noopener ugc nofollow" target="_blank">小端</a>，所以像<code class="fe lc ld le lf b">0xffffffdc</code>这样的多字节数将首先用最低有效字节表示)。我们可以通过重新编译并运行我们的<code class="fe lc ld le lf b">loader</code>测试工具来仔细检查这一点:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="5c91" class="lp lq iq lf b gy lr ls l lt lu">$ gcc -o loader loader.c<br/>$ ./loader<br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 52</span></pre><p id="d3f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使<code class="fe lc ld le lf b">add5</code>函数被声明为<code class="fe lc ld le lf b">static</code>，我们仍然可以从<code class="fe lc ld le lf b">loader</code>工具中调用它，基本上忽略了它现在是一个“内部”函数的事实。正因为如此，<code class="fe lc ld le lf b">static</code>关键字不应该被用作一种安全特性来对潜在的恶意用户隐藏API。</p><p id="aaa9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是让我们后退一步，将<code class="fe lc ld le lf b">obj.c</code>中的<code class="fe lc ld le lf b">add5</code>功能恢复为具有外部链接的功能:</p><p id="41fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标，对象:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="1302" class="lp lq iq lf b gy lr ls l lt lu">int add5(int num)<br/>...</span><span id="0be8" class="lp lq iq lf b gy nb ls l lt lu">$ gcc -c obj.c<br/>$ ./loader<br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 42</span></pre><p id="d684" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，编译器没有为我们计算正确的<code class="fe lc ld le lf b">callq</code>参数，因为它没有足够的信息。但是后面的阶段(即链接器)会有这些信息，所以编译器会留下一些关于如何修复这些参数的线索。这些线索——或对后期阶段的指示——被称为<strong class="kh ir">再定位</strong>。我们可以和我们的朋友readelf实用程序一起检查它们。让我们再次检查<code class="fe lc ld le lf b">obj.o</code>部分表:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="063b" class="lp lq iq lf b gy lr ls l lt lu">$ readelf --sections obj.o<br/>There are 12 section headers, starting at offset 0x2b0:<br/> <br/>Section Headers:<br/>  [Nr] Name              Type             Address           Offset<br/>       Size              EntSize          Flags  Link  Info  Align<br/>  [ 0]                   NULL             0000000000000000  00000000<br/>       0000000000000000  0000000000000000           0     0     0<br/>  [ 1] .text             PROGBITS         0000000000000000  00000040<br/>       0000000000000033  0000000000000000  AX       0     0     1<br/>  [ 2] .rela.text        RELA             0000000000000000  000001f0<br/>       0000000000000030  0000000000000018   I       9     1     8<br/>  [ 3] .data             PROGBITS         0000000000000000  00000073<br/>       0000000000000000  0000000000000000  WA       0     0     1<br/>  [ 4] .bss              NOBITS           0000000000000000  00000073<br/>       0000000000000000  0000000000000000  WA       0     0     1<br/>  [ 5] .comment          PROGBITS         0000000000000000  00000073<br/>       000000000000001d  0000000000000001  MS       0     0     1<br/>  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  00000090<br/>       0000000000000000  0000000000000000           0     0     1<br/>  [ 7] .eh_frame         PROGBITS         0000000000000000  00000090<br/>       0000000000000058  0000000000000000   A       0     0     8<br/>  [ 8] .rela.eh_frame    RELA             0000000000000000  00000220<br/>       0000000000000030  0000000000000018   I       9     7     8<br/>  [ 9] .symtab           SYMTAB           0000000000000000  000000e8<br/>       00000000000000f0  0000000000000018          10     8     8<br/>  [10] .strtab           STRTAB           0000000000000000  000001d8<br/>       0000000000000012  0000000000000000           0     0     1<br/>  [11] .shstrtab         STRTAB           0000000000000000  00000250<br/>       0000000000000059  0000000000000000           0     0     1<br/>Key to Flags:<br/>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br/>  L (link order), O (extra OS processing required), G (group), T (TLS),<br/>  C (compressed), x (unknown), o (OS specific), E (exclude),<br/>  l (large), p (processor specific)</span></pre><p id="8da3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到编译器创建了一个名为<code class="fe lc ld le lf b">.rela.text</code>的新部分。按照惯例，对名为<code class="fe lc ld le lf b">.foo</code>的部分进行重定位的部分将被称为<code class="fe lc ld le lf b">.rela.foo</code>，因此我们可以看到编译器为<code class="fe lc ld le lf b">.text</code>部分创建了一个重定位的部分。我们可以进一步检查重新定位:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="c71d" class="lp lq iq lf b gy lr ls l lt lu">$ readelf --relocs obj.o<br/> <br/>Relocation section '.rela.text' at offset 0x1f0 contains 2 entries:<br/>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br/>000000000020  000800000004 R_X86_64_PLT32    0000000000000000 add5 - 4<br/>00000000002d  000800000004 R_X86_64_PLT32    0000000000000000 add5 - 4<br/> <br/>Relocation section '.rela.eh_frame' at offset 0x220 contains 2 entries:<br/>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br/>000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0<br/>000000000040  000200000002 R_X86_64_PC32     0000000000000000 .text + f</span></pre><p id="015c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们忽略<code class="fe lc ld le lf b">.rela.eh_frame</code>部分的重定位，因为它们超出了本文的范围。相反，让我们试着理解来自<code class="fe lc ld le lf b">.rela.text</code>的重定位:</p><ul class=""><li id="d47f" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated"><code class="fe lc ld le lf b">Offset</code>栏告诉我们目标截面(在本例中为<code class="fe lc ld le lf b">.text</code>)中需要固定/调整的确切位置。请注意，这些偏移量与上面我们自己计算的猴子补丁完全相同。</li><li id="7fdf" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><code class="fe lc ld le lf b">Info</code>是一个组合值:高32位(上面的输出中只显示了16位)表示符号表中符号的索引，相对于该索引执行重定位。在我们的例子中，它是<code class="fe lc ld le lf b">8</code>，如果我们运行<code class="fe lc ld le lf b">readelf --symbols obj.o</code>，我们将看到它指向一个对应于<code class="fe lc ld le lf b">add5</code>函数的条目。低32位(本例中为<code class="fe lc ld le lf b">4</code>)是一种重定位类型(见下文<code class="fe lc ld le lf b">Type</code>)。</li><li id="10fb" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><code class="fe lc ld le lf b">Type</code>描述搬迁类型。这是一个伪列:<code class="fe lc ld le lf b">readelf</code>实际上是从<code class="fe lc ld le lf b">Info</code>字段的低32位生成的。不同的位置调整类型有不同的公式，我们需要应用这些公式来执行位置调整。</li><li id="a46a" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><code class="fe lc ld le lf b">Sym. Value</code>根据重定位类型的不同，可能有不同的含义，但大多数情况下，它是我们执行重定位所依据的符号偏移量。偏移量是从该符号部分的开头开始计算的。</li><li id="0aa9" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><code class="fe lc ld le lf b">Addend</code>是我们可能需要在重定位公式中使用的常数。根据重定位类型，<a class="ae lb" href="https://man7.org/linux/man-pages/man1/readelf.1.html" rel="noopener ugc nofollow" target="_blank"> readelf </a>实际上将解码后的符号名添加到输出中，因此列名在上面的<code class="fe lc ld le lf b">Sym. Name + Addend</code>中，但是实际的字段只存储加数。</li></ul><p id="19bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，这些条目告诉我们需要在偏移量<code class="fe lc ld le lf b">0x20</code>和<code class="fe lc ld le lf b">0x2d</code>处修补<code class="fe lc ld le lf b">.text</code>部分。为了计算在那里放置什么，我们需要应用<code class="fe lc ld le lf b">R_X86_64_PLT32</code>重定位类型的公式。在网上搜索，我们可以找到不同的ELF规范——像<a class="ae lb" href="https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf" rel="noopener ugc nofollow" target="_blank">这个</a>——它会告诉我们如何实现<code class="fe lc ld le lf b">R_X86_64_PLT32</code>重定位。规范提到这种重定位的结果是<code class="fe lc ld le lf b">word32</code>——这是我们所期望的，因为在我们的例子中<code class="fe lc ld le lf b">callq</code>参数是32位——我们需要应用的公式是<code class="fe lc ld le lf b">L + A - P</code>，其中:</p><ul class=""><li id="9f2c" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated"><code class="fe lc ld le lf b">L</code>是符号的地址，相对于它执行重定位(在我们的例子中是<code class="fe lc ld le lf b">add5</code>)</li><li id="04d7" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><code class="fe lc ld le lf b">A</code>是常量加数(在我们的例子中是<code class="fe lc ld le lf b">4</code>)</li><li id="b9d3" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><code class="fe lc ld le lf b">P</code>是我们存储重定位结果的地址/偏移量</li></ul><p id="6464" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当重定位公式引用一些符号地址或偏移量时，我们应该在计算中使用实际的——在我们的例子中是运行时——地址。例如，我们将使用<code class="fe lc ld le lf b">text_runtime_base + 0x2d</code>作为第二次重新定位的<code class="fe lc ld le lf b">P</code>，而不仅仅是<code class="fe lc ld le lf b">0x2d</code>。因此，让我们试着在我们的对象加载器中实现这个重定位逻辑:</p><p id="c46e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg"> loader.c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="6ab9" class="lp lq iq lf b gy lr ls l lt lu">...<br/> <br/>/* from https://elixir.bootlin.com/linux/v5.11.6/source/arch/x86/include/asm/elf.h#L51 */<br/>#define R_X86_64_PLT32 4<br/> <br/>...<br/> <br/>static uint8_t *section_runtime_base(const Elf64_Shdr *section)<br/>{<br/>    const char *section_name = shstrtab + section-&gt;sh_name;<br/>    size_t section_name_len = strlen(section_name);<br/> <br/>    /* we only mmap .text section so far */<br/>    if (strlen(".text") == section_name_len &amp;&amp; !strcmp(".text", section_name))<br/>        return text_runtime_base;<br/> <br/>    fprintf(stderr, "No runtime base address for section %s\n", section_name);<br/>    exit(ENOENT);<br/>}<br/> <br/>static void do_text_relocations(void)<br/>{<br/>    /* we actually cheat here - the name .rela.text is a convention, but not a<br/>     * rule: to figure out which section should be patched by these relocations<br/>     * we would need to examine the rela_text_hdr, but we skip it for simplicity<br/>     */<br/>    const Elf64_Shdr *rela_text_hdr = lookup_section(".rela.text");<br/>    if (!rela_text_hdr) {<br/>        fputs("Failed to find .rela.text\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/> <br/>    int num_relocations = rela_text_hdr-&gt;sh_size / rela_text_hdr-&gt;sh_entsize;<br/>    const Elf64_Rela *relocations = (Elf64_Rela *)(obj.base + rela_text_hdr-&gt;sh_offset);<br/> <br/>    for (int i = 0; i &lt; num_relocations; i++) {<br/>        int symbol_idx = ELF64_R_SYM(relocations[i].r_info);<br/>        int type = ELF64_R_TYPE(relocations[i].r_info);<br/> <br/>        /* where to patch .text */<br/>        uint8_t *patch_offset = text_runtime_base + relocations[i].r_offset;<br/>        /* symbol, with respect to which the relocation is performed */<br/>        uint8_t *symbol_address = section_runtime_base(&amp;sections[symbols[symbol_idx].st_shndx]) + symbols[symbol_idx].st_value;<br/> <br/>        switch (type)<br/>        {<br/>        case R_X86_64_PLT32:<br/>            /* L + A - P, 32 bit output */<br/>            *((uint32_t *)patch_offset) = symbol_address + relocations[i].r_addend - patch_offset;<br/>            printf("Calculated relocation: 0x%08x\n", *((uint32_t *)patch_offset));<br/>            break;<br/>        }<br/>    }<br/>}<br/> <br/>static void parse_obj(void)<br/>{<br/>...<br/> <br/>    /* copy the contents of `.text` section from the ELF file */<br/>    memcpy(text_runtime_base, obj.base + text_hdr-&gt;sh_offset, text_hdr-&gt;sh_size);<br/> <br/>    do_text_relocations();<br/> <br/>    /* make the `.text` copy readonly and executable */<br/>    if (mprotect(text_runtime_base, page_align(text_hdr-&gt;sh_size), PROT_READ | PROT_EXEC)) {<br/> <br/>...<br/>}<br/> <br/>...</span></pre><p id="e4d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在在标记我们的<code class="fe lc ld le lf b">.text</code>副本可执行文件之前调用<code class="fe lc ld le lf b">do_text_relocations</code>函数。我们还添加了一些调试输出来检查重新定位计算的结果。让我们试一试:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="3353" class="lp lq iq lf b gy lr ls l lt lu">$ gcc -o loader loader.c <br/>$ ./loader <br/>Calculated relocation: 0xffffffdc<br/>Calculated relocation: 0xffffffcf<br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 52</span></pre><p id="0b53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！我们导入的代码现在可以正常工作了。通过遵循编译器留给我们的重定位提示，我们已经得到了与本文开头的猴子修补计算相同的结果。我们的重定位计算还涉及到<code class="fe lc ld le lf b">text_runtime_base</code>地址，这在编译时是不可用的。这就是为什么编译器不能首先计算<code class="fe lc ld le lf b">callq</code>参数，而必须发出重定位的原因。</p><h2 id="f672" class="lp lq iq bd mf mg mh dn mi mj mk dp ml ko mm mn mo ks mp mq mr kw ms mt mu mv bi translated">处理常量数据和全局变量</h2><p id="3a94" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">到目前为止，我们一直在处理只包含没有状态的可执行代码的目标文件。也就是说，导入的函数可以仅基于输入来计算它们的输出。让我们看看，如果我们向导入的代码中添加一些常量数据和全局变量依赖项，会发生什么。首先，我们给我们的<code class="fe lc ld le lf b">obj.o</code>增加了一些功能:</p><p id="61f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg">对象c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="c99e" class="lp lq iq lf b gy lr ls l lt lu">...<br/> <br/>const char *get_hello(void)<br/>{<br/>    return "Hello, world!";<br/>}<br/> <br/>static int var = 5;<br/> <br/>int get_var(void)<br/>{<br/>    return var;<br/>}<br/> <br/>void set_var(int num)<br/>{<br/>    var = num;<br/>}</span></pre><p id="474b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">get_hello</code>返回一个常量字符串，<code class="fe lc ld le lf b">get_var</code> / <code class="fe lc ld le lf b">set_var</code>分别获取和设置一个全局变量。接下来，让我们重新编译<code class="fe lc ld le lf b">obj.o</code>并运行我们的加载程序:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="324f" class="lp lq iq lf b gy lr ls l lt lu">$ gcc -c obj.c<br/>$ ./loader <br/>Calculated relocation: 0xffffffdc<br/>Calculated relocation: 0xffffffcf<br/>No runtime base address for section .rodata</span></pre><p id="188d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来我们的加载器试图处理更多的重定位，但是找不到<code class="fe lc ld le lf b">.rodata</code>部分的运行时地址。以前，我们甚至没有一个<code class="fe lc ld le lf b">.rodata</code>部分，但是现在添加了它，因为我们的<code class="fe lc ld le lf b">obj.o</code>需要某个地方来存储常量字符串<code class="fe lc ld le lf b">Hello, world!</code>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="1e88" class="lp lq iq lf b gy lr ls l lt lu">$ readelf --sections obj.o<br/>There are 13 section headers, starting at offset 0x478:<br/> <br/>Section Headers:<br/>  [Nr] Name              Type             Address           Offset<br/>       Size              EntSize          Flags  Link  Info  Align<br/>  [ 0]                   NULL             0000000000000000  00000000<br/>       0000000000000000  0000000000000000           0     0     0<br/>  [ 1] .text             PROGBITS         0000000000000000  00000040<br/>       000000000000005f  0000000000000000  AX       0     0     1<br/>  [ 2] .rela.text        RELA             0000000000000000  00000320<br/>       0000000000000078  0000000000000018   I      10     1     8<br/>  [ 3] .data             PROGBITS         0000000000000000  000000a0<br/>       0000000000000004  0000000000000000  WA       0     0     4<br/>  [ 4] .bss              NOBITS           0000000000000000  000000a4<br/>       0000000000000000  0000000000000000  WA       0     0     1<br/>  [ 5] .rodata           PROGBITS         0000000000000000  000000a4<br/>       000000000000000d  0000000000000000   A       0     0     1<br/>  [ 6] .comment          PROGBITS         0000000000000000  000000b1<br/>       000000000000001d  0000000000000001  MS       0     0     1<br/>  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000ce<br/>       0000000000000000  0000000000000000           0     0     1<br/>  [ 8] .eh_frame         PROGBITS         0000000000000000  000000d0<br/>       00000000000000b8  0000000000000000   A       0     0     8<br/>  [ 9] .rela.eh_frame    RELA             0000000000000000  00000398<br/>       0000000000000078  0000000000000018   I      10     8     8<br/>  [10] .symtab           SYMTAB           0000000000000000  00000188<br/>       0000000000000168  0000000000000018          11    10     8<br/>  [11] .strtab           STRTAB           0000000000000000  000002f0<br/>       000000000000002c  0000000000000000           0     0     1<br/>  [12] .shstrtab         STRTAB           0000000000000000  00000410<br/>       0000000000000061  0000000000000000           0     0     1<br/>Key to Flags:<br/>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br/>  L (link order), O (extra OS processing required), G (group), T (TLS),<br/>  C (compressed), x (unknown), o (OS specific), E (exclude),<br/>  l (large), p (processor specific)</span></pre><p id="ff67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还有更多<code class="fe lc ld le lf b">.text</code>重新定位:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="3589" class="lp lq iq lf b gy lr ls l lt lu">$ readelf --relocs obj.o<br/> <br/>Relocation section '.rela.text' at offset 0x320 contains 5 entries:<br/>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br/>000000000020  000a00000004 R_X86_64_PLT32    0000000000000000 add5 - 4<br/>00000000002d  000a00000004 R_X86_64_PLT32    0000000000000000 add5 - 4<br/>00000000003a  000500000002 R_X86_64_PC32     0000000000000000 .rodata - 4<br/>000000000046  000300000002 R_X86_64_PC32     0000000000000000 .data - 4<br/>000000000058  000300000002 R_X86_64_PC32     0000000000000000 .data - 4<br/>...</span></pre><p id="328c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译器这次又发出了三次<code class="fe lc ld le lf b">R_X86_64_PC32</code>重定位。它们引用带有索引<code class="fe lc ld le lf b">3</code>和<code class="fe lc ld le lf b">5</code>的符号，所以让我们看看它们是什么:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="82f1" class="lp lq iq lf b gy lr ls l lt lu">$ readelf --symbols obj.o<br/> <br/>Symbol table '.symtab' contains 15 entries:<br/>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br/>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br/>     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS obj.c<br/>     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1<br/>     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3<br/>     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4<br/>     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5<br/>     6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    3 var<br/>     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    7<br/>     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    8<br/>     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    6<br/>    10: 0000000000000000    15 FUNC    GLOBAL DEFAULT    1 add5<br/>    11: 000000000000000f    36 FUNC    GLOBAL DEFAULT    1 add10<br/>    12: 0000000000000033    13 FUNC    GLOBAL DEFAULT    1 get_hello<br/>    13: 0000000000000040    12 FUNC    GLOBAL DEFAULT    1 get_var<br/>    14: 000000000000004c    19 FUNC    GLOBAL DEFAULT    1 set_var</span></pre><p id="73c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">条目<code class="fe lc ld le lf b">3</code>和<code class="fe lc ld le lf b">5</code>没有附加任何名称，但是它们分别引用索引为<code class="fe lc ld le lf b">3</code>和<code class="fe lc ld le lf b">5</code>的部分中的内容。在上面的section表的输出中，我们可以看到索引为<code class="fe lc ld le lf b">3</code>的section是<code class="fe lc ld le lf b">.data</code>，索引为<code class="fe lc ld le lf b">5</code>的section是<code class="fe lc ld le lf b">.rodata</code>。要复习ELF文件中最常见的部分，请查看我们之前的<a class="ae lb" href="https://pqsec.org/2021/03/02/execute-an-object-file-part-1.html" rel="noopener ugc nofollow" target="_blank">帖子</a>。为了导入我们新添加的代码并使其工作，除了<code class="fe lc ld le lf b">.text</code>部分之外，我们还需要映射<code class="fe lc ld le lf b">.data</code>和<code class="fe lc ld le lf b">.rodata</code>部分，并处理这些<code class="fe lc ld le lf b">R_X86_64_PC32</code>重定位。</p><p id="0044" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过有一点需要注意。如果我们检查<a class="ae lb" href="https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf" rel="noopener ugc nofollow" target="_blank">规范</a>，我们会看到<code class="fe lc ld le lf b">R_X86_64_PC32</code>重定位产生一个类似于<code class="fe lc ld le lf b">R_X86_64_PLT32</code>重定位的32位输出。这意味着内存中<code class="fe lc ld le lf b">.text</code>中修补位置和引用符号之间的“距离”必须足够小，以适合32位值(1位用于正负符号，31位用于实际数据，因此小于2147483647字节)。我们的<code class="fe lc ld le lf b">loader</code>程序使用<a class="ae lb" href="https://man7.org/linux/man-pages/man2/mmap.2.html" rel="noopener ugc nofollow" target="_blank"> mmap系统调用</a>为对象段副本分配内存，但是<a class="ae lb" href="https://man7.org/linux/man-pages/man2/mmap.2.html" rel="noopener ugc nofollow" target="_blank"> mmap </a>几乎可以在进程地址空间的任何地方分配映射。如果我们修改<code class="fe lc ld le lf b">loader</code>程序来分别为每个部分调用<a class="ae lb" href="https://man7.org/linux/man-pages/man2/mmap.2.html" rel="noopener ugc nofollow" target="_blank"> mmap </a>，我们可能会导致<code class="fe lc ld le lf b">.rodata</code>或<code class="fe lc ld le lf b">.data</code>部分被映射到离<code class="fe lc ld le lf b">.text</code>部分太远的地方，并且不能处理<code class="fe lc ld le lf b">R_X86_64_PC32</code>重定位。换句话说，我们需要确保<code class="fe lc ld le lf b">.data</code>和<code class="fe lc ld le lf b">.rodata</code>部分在运行时相对靠近<code class="fe lc ld le lf b">.text</code>部分:</p><figure class="lh li lj lk gt mc gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/06dc82312f32d3e1f4246218d756e78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*i97yxPGYABSAXnof2F82WQ.png"/></div></figure><p id="4dd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现这一点的一个方法是通过一个<a class="ae lb" href="https://man7.org/linux/man-pages/man2/mmap.2.html" rel="noopener ugc nofollow" target="_blank"> mmap调用</a>来分配所有部分所需的内存。然后，我们将它分成块，并为每个块分配适当的访问权限。让我们修改我们的<code class="fe lc ld le lf b">loader</code>程序来做到这一点:</p><p id="c2b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg"> loader.c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="4d26" class="lp lq iq lf b gy lr ls l lt lu">...<br/> <br/>/* runtime base address of the imported code */<br/>static uint8_t *text_runtime_base;<br/>/* runtime base of the .data section */<br/>static uint8_t *data_runtime_base;<br/>/* runtime base of the .rodata section */<br/>static uint8_t *rodata_runtime_base;<br/> <br/>...<br/> <br/>static void parse_obj(void)<br/>{<br/>...<br/> <br/>    /* find the `.text` entry in the sections table */<br/>    const Elf64_Shdr *text_hdr = lookup_section(".text");<br/>    if (!text_hdr) {<br/>        fputs("Failed to find .text\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/> <br/>    /* find the `.data` entry in the sections table */<br/>    const Elf64_Shdr *data_hdr = lookup_section(".data");<br/>    if (!data_hdr) {<br/>        fputs("Failed to find .data\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/> <br/>    /* find the `.rodata` entry in the sections table */<br/>    const Elf64_Shdr *rodata_hdr = lookup_section(".rodata");<br/>    if (!rodata_hdr) {<br/>        fputs("Failed to find .rodata\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/> <br/>    /* allocate memory for `.text`, `.data` and `.rodata` copies rounding up each section to whole pages */<br/>    text_runtime_base = mmap(NULL, page_align(text_hdr-&gt;sh_size) + page_align(data_hdr-&gt;sh_size) + page_align(rodata_hdr-&gt;sh_size), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);<br/>    if (text_runtime_base == MAP_FAILED) {<br/>        perror("Failed to allocate memory");<br/>        exit(errno);<br/>    }<br/> <br/>    /* .data will come right after .text */<br/>    data_runtime_base = text_runtime_base + page_align(text_hdr-&gt;sh_size);<br/>    /* .rodata will come after .data */<br/>    rodata_runtime_base = data_runtime_base + page_align(data_hdr-&gt;sh_size);<br/> <br/>    /* copy the contents of `.text` section from the ELF file */<br/>    memcpy(text_runtime_base, obj.base + text_hdr-&gt;sh_offset, text_hdr-&gt;sh_size);<br/>    /* copy .data */<br/>    memcpy(data_runtime_base, obj.base + data_hdr-&gt;sh_offset, data_hdr-&gt;sh_size);<br/>    /* copy .rodata */<br/>    memcpy(rodata_runtime_base, obj.base + rodata_hdr-&gt;sh_offset, rodata_hdr-&gt;sh_size);<br/> <br/>    do_text_relocations();<br/> <br/>    /* make the `.text` copy readonly and executable */<br/>    if (mprotect(text_runtime_base, page_align(text_hdr-&gt;sh_size), PROT_READ | PROT_EXEC)) {<br/>        perror("Failed to make .text executable");<br/>        exit(errno);<br/>    }<br/> <br/>    /* we don't need to do anything with .data - it should remain read/write */<br/> <br/>    /* make the `.rodata` copy readonly */<br/>    if (mprotect(rodata_runtime_base, page_align(rodata_hdr-&gt;sh_size), PROT_READ)) {<br/>        perror("Failed to make .rodata readonly");<br/>        exit(errno);<br/>    }<br/>}<br/> <br/>...</span></pre><p id="48a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了运行时地址<code class="fe lc ld le lf b">.data</code>和<code class="fe lc ld le lf b">.rodata</code>，我们可以更新重定位运行时地址查找函数:</p><p id="7e0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg"> loader.c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="f9d8" class="lp lq iq lf b gy lr ls l lt lu">...<br/> <br/>static uint8_t *section_runtime_base(const Elf64_Shdr *section)<br/>{<br/>    const char *section_name = shstrtab + section-&gt;sh_name;<br/>    size_t section_name_len = strlen(section_name);<br/> <br/>    if (strlen(".text") == section_name_len &amp;&amp; !strcmp(".text", section_name))<br/>        return text_runtime_base;<br/> <br/>    if (strlen(".data") == section_name_len &amp;&amp; !strcmp(".data", section_name))<br/>        return data_runtime_base;<br/> <br/>    if (strlen(".rodata") == section_name_len &amp;&amp; !strcmp(".rodata", section_name))<br/>        return rodata_runtime_base;<br/> <br/>    fprintf(stderr, "No runtime base address for section %s\n", section_name);<br/>    exit(ENOENT);<br/>}</span></pre><p id="8707" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以导入并执行我们的新功能:</p><p id="67a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg"> loader.c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="6aea" class="lp lq iq lf b gy lr ls l lt lu">...<br/> <br/>static void execute_funcs(void)<br/>{<br/>    /* pointers to imported functions */<br/>    int (*add5)(int);<br/>    int (*add10)(int);<br/>    const char *(*get_hello)(void);<br/>    int (*get_var)(void);<br/>    void (*set_var)(int num);<br/> <br/>...<br/> <br/>    printf("add10(%d) = %d\n", 42, add10(42));<br/> <br/>    get_hello = lookup_function("get_hello");<br/>    if (!get_hello) {<br/>        fputs("Failed to find get_hello function\n", stderr);<br/>        exit(ENOENT);<br/>    }<br/> <br/>    puts("Executing get_hello...");<br/>    printf("get_hello() = %s\n", get_hello());<br/> <br/>    get_var = lookup_function("get_var");<br/>    if (!get_var) {<br/>        fputs("Failed to find get_var function\n", stderr);<br/>        exit(ENOENT);<br/>    }<br/> <br/>    puts("Executing get_var...");<br/>    printf("get_var() = %d\n", get_var());<br/> <br/>    set_var = lookup_function("set_var");<br/>    if (!set_var) {<br/>        fputs("Failed to find set_var function\n", stderr);<br/>        exit(ENOENT);<br/>    }<br/> <br/>    puts("Executing set_var(42)...");<br/>    set_var(42);<br/> <br/>    puts("Executing get_var again...");<br/>    printf("get_var() = %d\n", get_var());<br/>}<br/>...</span></pre><p id="738d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试一试:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="9ba7" class="lp lq iq lf b gy lr ls l lt lu">$ gcc -o loader loader.c <br/>$ ./loader <br/>Calculated relocation: 0xffffffdc<br/>Calculated relocation: 0xffffffcf<br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 52<br/>Executing get_hello...<br/>get_hello() = ]�UH��<br/>Executing get_var...<br/>get_var() = 1213580125<br/>Executing set_var(42)...<br/>Segmentation fault</span></pre><p id="d62e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">啊哦！我们忘记实现新的<code class="fe lc ld le lf b">R_X86_64_PC32</code>重定位类型。这里的<a class="ae lb" href="https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf" rel="noopener ugc nofollow" target="_blank">搬迁公式</a>就是<code class="fe lc ld le lf b">S + A - P</code>。我们已经知道了<code class="fe lc ld le lf b">A</code>和<code class="fe lc ld le lf b">P</code>。关于<code class="fe lc ld le lf b">S</code>(引自<a class="ae lb" href="https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf" rel="noopener ugc nofollow" target="_blank">spec</a>):</p><blockquote class="lv lw lx"><p id="87c4" class="kf kg lg kh b ki kj jr kk kl km ju kn ly kp kq kr lz kt ku kv ma kx ky kz la ij bi translated">"其索引驻留在重定位条目中的符号的值"</p></blockquote><p id="6c91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，它本质上与<code class="fe lc ld le lf b">R_X86_64_PLT32</code>的<code class="fe lc ld le lf b">L</code>相同。我们可以重用实现，并在过程中删除调试输出:</p><p id="f18c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg"> loader.c </em>:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="c79a" class="lp lq iq lf b gy lr ls l lt lu">...<br/> <br/>/* from https://elixir.bootlin.com/linux/v5.11.6/source/arch/x86/include/asm/elf.h#L51 */<br/>#define R_X86_64_PC32 2<br/>#define R_X86_64_PLT32 4<br/> <br/>...<br/> <br/>static void do_text_relocations(void)<br/>{<br/>    /* we actually cheat here - the name .rela.text is a convention, but not a<br/>     * rule: to figure out which section should be patched by these relocations<br/>     * we would need to examine the rela_text_hdr, but we skip it for simplicity<br/>     */<br/>    const Elf64_Shdr *rela_text_hdr = lookup_section(".rela.text");<br/>    if (!rela_text_hdr) {<br/>        fputs("Failed to find .rela.text\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/> <br/>    int num_relocations = rela_text_hdr-&gt;sh_size / rela_text_hdr-&gt;sh_entsize;<br/>    const Elf64_Rela *relocations = (Elf64_Rela *)(obj.base + rela_text_hdr-&gt;sh_offset);<br/> <br/>    for (int i = 0; i &lt; num_relocations; i++) {<br/>        int symbol_idx = ELF64_R_SYM(relocations[i].r_info);<br/>        int type = ELF64_R_TYPE(relocations[i].r_info);<br/> <br/>        /* where to patch .text */<br/>        uint8_t *patch_offset = text_runtime_base + relocations[i].r_offset;<br/>        /* symbol, with respect to which the relocation is performed */<br/>        uint8_t *symbol_address = section_runtime_base(&amp;sections[symbols[symbol_idx].st_shndx]) + symbols[symbol_idx].st_value;<br/> <br/>        switch (type)<br/>        {<br/>        case R_X86_64_PC32:<br/>            /* S + A - P, 32 bit output, S == L here */<br/>        case R_X86_64_PLT32:<br/>            /* L + A - P, 32 bit output */<br/>            *((uint32_t *)patch_offset) = symbol_address + relocations[i].r_addend - patch_offset;<br/>            break;<br/>        }<br/>    }<br/>}<br/> <br/>...</span></pre><p id="dd88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们应该完成了。另一种尝试:</p><pre class="lh li lj lk gt ll lf lm ln aw lo bi"><span id="53ee" class="lp lq iq lf b gy lr ls l lt lu">$ gcc -o loader loader.c <br/>$ ./loader <br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 52<br/>Executing get_hello...<br/>get_hello() = Hello, world!<br/>Executing get_var...<br/>get_var() = 5<br/>Executing set_var(42)...<br/>Executing get_var again...<br/>get_var() = 42</span></pre><p id="cf84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次我们可以成功地导入引用静态常量数据和全局变量的函数。我们甚至可以通过定义的访问器接口来操纵目标文件的内部状态。和以前一样，这篇文章的完整源代码可以在GitHub 上找到。</p><p id="e527" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一篇文章中，我们将研究导入和执行引用外部库的目标代码。敬请期待！</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="bdb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lg">这是我从</em> <a class="ae lb" href="https://blog.cloudflare.com/how-to-execute-an-object-file-part-2/" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> Cloudflare博客</em> </a>转贴的帖子</p></div></div>    
</body>
</html>