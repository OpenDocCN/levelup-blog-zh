<html>
<head>
<title>Javascript Functional Programming Features — Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript函数式编程特性—函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-functional-programming-features-functions-f972a084a0a4?source=collection_archive---------10-----------------------#2020-05-07">https://levelup.gitconnected.com/javascript-functional-programming-features-functions-f972a084a0a4?source=collection_archive---------10-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/64f7bb497e275e625c0a42479d6ef688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dD-s95uA7eyELytp"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@chaurasia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Chandan Chaurasia </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fb81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。它还使用了许多函数式编程特性，使我们的生活更加轻松。</p><p id="bfe6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究JavaScript函数的函数式编程特征。</p><h1 id="78f1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">高阶函数</h1><p id="aba3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">高阶函数是接受其他函数参数或在其结果中返回函数的函数。</p><p id="a26f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，这意味着JavaScript代码可以接受回调或返回函数。</p><p id="13bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">高阶函数的例子包括数组实例的<code class="fe mh mi mj mk b">map</code>方法，我们可以通过编写如下代码来调用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="44b2" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3].map(a =&gt; a * 2);</span></pre><p id="12a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用回调函数<code class="fe mh mi mj mk b">a =&gt; a * 2</code>调用了<code class="fe mh mi mj mk b">map</code>方法，</p><p id="0be7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mh mi mj mk b">map</code>方法将调用回调，通过将每个条目加倍，将每个条目从其原始值映射到新值，将每个映射的条目添加到新数组中，并返回新数组。</p><p id="d955" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有许多其他的数组实例方法接受回调，包括<code class="fe mh mi mj mk b">some</code>、<code class="fe mh mi mj mk b">every</code>、<code class="fe mh mi mj mk b">find</code>、<code class="fe mh mi mj mk b">findIndex</code>、<code class="fe mh mi mj mk b">filter</code>等。</p><p id="cfbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写如下代码来创建一个返回函数的函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="788a" class="mt lf it mk b gy mu mv l mw mx">const returnAdd = () =&gt; (a, b) =&gt; a + b;<br/>const result = returnAdd()(1, 2);</span></pre><p id="c617" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mh mi mj mk b">returnAdd</code>函数，它返回一个将两个数相加的函数。</p><p id="f2ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过先调用<code class="fe mh mi mj mk b">returnAdd</code>函数返回加数的函数，再调用返回的函数加数并返回和，来调用返回的函数加2数。</p><p id="33da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，上例中的<code class="fe mh mi mj mk b">result</code>应该是3。</p><h1 id="4c4e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一级功能</h1><p id="88d1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">一级函数是像对待任何其他对象一样对待的函数。它们可以存储在变量中，传递，从其他函数返回，并拥有自己的属性。</p><p id="80ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上一节我们可以看到，函数可以传递给另一个函数，函数也可以作为函数中的参数返回。</p><p id="c24e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它们还可以具有属性。例如，我们可以通过编写如下代码来设置函数的属性:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a5a2" class="mt lf it mk b gy mu mv l mw mx">const foo = () =&gt; {};<br/>foo.bar = 1;</span></pre><p id="cbdb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们在第一行定义了<code class="fe mh mi mj mk b">foo</code>函数。然后我们在<code class="fe mh mi mj mk b">foo</code>函数上创建<code class="fe mh mi mj mk b">bar</code>属性，然后将其值设置为1。</p><p id="cdf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们记录<code class="fe mh mi mj mk b">foo.bar</code>的值时，我们应该看到<code class="fe mh mi mj mk b">foo.bar</code>是1。</p><p id="ddd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，函数就像任何对象一样，它们可以有自己的属性。</p><p id="9885" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们需要创建方法的静态属性时，这对于构造函数更有用。</p><p id="9d0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的构造函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="da44" class="mt lf it mk b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span></pre><p id="d1dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以为它定义一个静态方法，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="674a" class="mt lf it mk b gy mu mv l mw mx">Person.greet = () =&gt; console.log('hello');</span></pre><p id="03a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个静态的<code class="fe mh mi mj mk b">greet</code>方法，我们可以在<code class="fe mh mi mj mk b">Person</code>上调用它。那么我们可以这样称呼它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e4f8" class="mt lf it mk b gy mu mv l mw mx">Person.greet();</span></pre><p id="e363" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到<code class="fe mh mi mj mk b">'hello'</code>已经登录到控制台。</p><p id="5912" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们在前面的例子中看到的，可以做同样的事情来为函数添加属性。</p><p id="3b97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为JavaScript类只是构造函数上的语法糖。我们可以像定义构造函数一样定义JavaScript类的静态成员。</p><p id="b1d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="847a" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span></pre><p id="e2fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以在它上面定义一个静态方法如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b7c3" class="mt lf it mk b gy mu mv l mw mx">Person.greet = () =&gt; console.log('hello');</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/4c145bd36a1b4a1d07c7dd769fdba774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EYglwQKsfTpYaVcp"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Borna Bevanda 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b73e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">递归</h1><p id="6205" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">递归是函数调用自身的地方。像大多数语言一样，我们可以定义一个递归函数。许多循环可以用递归方式重写。在某些函数式语言中，使用递归是循环遍历项的默认方式。</p><p id="3ab0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，它们更难理解，所以为了使阅读代码更容易，我们坚持使用循环和数组方法来迭代和操作数据。</p><p id="9263" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们下面的循环:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2f66" class="mt lf it mk b gy mu mv l mw mx">for (let i = 0; i &lt;= 4; i++) {<br/>  console.log(i);<br/>}</span></pre><p id="71c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">产生与以下递归函数相同的结果:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e988" class="mt lf it mk b gy mu mv l mw mx">const loop = (i = 0) =&gt; {<br/>  console.log(i);<br/>  if (i === 4) {<br/>    return;<br/>  }<br/>  loop(i + 1);<br/>}</span><span id="c819" class="mt lf it mk b gy mz mv l mw mx">loop();</span></pre><p id="2a56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，循环要短得多，也更容易理解。</p><p id="06b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用递归<code class="fe mh mi mj mk b">loop</code>函数，我们必须像使用<code class="fe mh mi mj mk b">for</code>循环一样运行<code class="fe mh mi mj mk b">console.log</code>，但是还必须检查<code class="fe mh mi mj mk b">i</code>为4时的基本情况，然后如果<code class="fe mh mi mj mk b">i</code>达到4，我们必须结束循环。</p><p id="696e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们让函数调用它自己。</p><p id="3602" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于遍历不确定深度级别的树结构更有用。</p><h1 id="74df" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="2c9d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，函数和其他对象一样。我们可以给它设置属性，把它作为参数传入，函数可以返回函数。</p><p id="78a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归也是函数式编程的一个重要部分。我们可以用它来创建一个调用自身的函数。</p></div></div>    
</body>
</html>