<html>
<head>
<title>Improving memory usage and stability on AWS Lambda (.NET)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高AWS Lambda(上的内存使用和稳定性。网)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improving-memory-usage-and-stability-on-aws-lambda-net-7c0c47c5b52e?source=collection_archive---------23-----------------------#2020-06-29">https://levelup.gitconnected.com/improving-memory-usage-and-stability-on-aws-lambda-net-7c0c47c5b52e?source=collection_archive---------23-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b5d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">这个简单的优化技巧将提高你的内存消耗和稳定性</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/9b9f77e3e2cb2e1356c471a6b2d6b48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n8KeN1g5ufAalLyz"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae lc" href="https://unsplash.com/@hobiindustri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">霍比工业</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9237" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最近意识到了一个意想不到的问题，即在dotnet core中的AWS Lamba上的无服务器功能的垃圾收集(这可能也适用于其他提供无服务器产品的云提供商)。幸运的是有一个简单的修复方法！</p><p id="7fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当Lambda函数在长时间内经历一致的调用时，问题就出现了。当这种情况发生时，将需要该函数的所有并发实例，并且工作线程将很少被回收。在这种情况下，我们依靠垃圾收集器来移除未使用的资源并释放内存。如果不这样做，worker最终会耗尽内存并崩溃。</p><p id="09c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常开发人员不需要关心垃圾收集器。这就是它们被制造出来的原因:为了简化内存管理。但是，在无服务器函数中运行时，垃圾收集器可能无法正常工作。要解决这个问题，我们需要对dotnet中的垃圾收集器有更多的了解。</p><p id="6402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dotnet核心中有两种类型的垃圾收集:工作站垃圾收集和服务器垃圾收集。<strong class="jp ir">服务器GC </strong>针对服务器使用进行了优化，假设CPU使用比内存使用具有更高的优先级。这种类型的垃圾收集允许更高的内存使用率，这在大型服务器上可能没有问题，但对于内存非常稀缺的Lambda函数(毕竟我们正在为此付出代价！)这可能并不总是最好的方法。<strong class="jp ir">在很多情况下，当内存有限时，工作站GC </strong>可以提高性能，例如对于无服务器功能或资源有限的docker容器。</p><p id="c22b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是<strong class="jp ir">服务器GC </strong>是ASP.NET核心应用的默认垃圾收集器。</p><p id="bf63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看来自微软<a class="ae lc" href="https://docs.microsoft.com/en-us/aspnet/core/performance/memory?view=aspnetcore-3.1#gc-using-docker-and-small-containers" rel="noopener ugc nofollow" target="_blank">的一些示例图表</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ld"><img src="../Images/c141efcd461f325593e6ff8b63a450f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_wJzCnmcx_2LmiVr"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">服务器垃圾收集—更高的内存消耗和更少的垃圾收集(三角形)</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi le"><img src="../Images/ad3b7e67d31fa6a88561d3faf060fc14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FVn3kaUy2VAyQn_i"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">工作站GC —更低的内存消耗和频繁的垃圾收集</figcaption></figure><p id="3f00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的差别是相当大的；服务器垃圾收集在收集之前会消耗高达300 MB的内存，而工作站垃圾收集的内存不足10MB。</p><p id="4ce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，这里的修复很容易，只需将以下属性添加到您的。lambda的csproj文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="8740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，您的lambda函数的内存消耗可能会随着您的应用程序而变化，但随着时间的推移，这应该会在您的lambda函数上产生更稳定的内存消耗。这将减少工人撞车，从而减少冷启动。</p><p id="81e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">附加信息:</p><div class="lh li gp gr lj lk"><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/memory?view=aspnetcore-3.1#gc-using-docker-and-small-containers" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">ASP.NET核心中的内存管理和模式</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">内存管理是复杂的，即使是在像. NET这样的托管框架中。</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">docs.microsoft.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly kw lk"/></div></div></a></div><div class="lh li gp gr lj lk"><a href="https://blog.markvincze.com/troubleshooting-high-memory-usage-with-asp-net-core-on-kubernetes/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">Kubernetes上ASP.NET核心的高内存使用率故障排除</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">在工作中，我们在Google Cloud (GCE-Google…)的Kubernetes托管版本上运行几个ASP.NET核心API</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">blog.markvincze.com</p></div></div><div class="lt l"><div class="lz l lv lw lx lt ly kw lk"/></div></div></a></div></div></div>    
</body>
</html>