<html>
<head>
<title>Depth and Breadth First Search using Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift进行深度和广度优先搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/depth-and-breadth-first-search-using-swift-ecd19324543a?source=collection_archive---------9-----------------------#2021-05-06">https://levelup.gitconnected.com/depth-and-breadth-first-search-using-swift-ecd19324543a?source=collection_archive---------9-----------------------#2021-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db825ce29567f2c06b4cccfd34a78a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A3NvP1Mh43jyIs-FQQEuDA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/photos/rfg4l6_lu3c?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/rfg4l6_lu3c?utm_source=unsplash&amp;UTM _ medium = referral&amp;UTM _ content = creditShareLink</a></figcaption></figure><p id="fced" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的文章重点介绍了广泛使用的树遍历技术<strong class="kf ir">(广度和深度优先搜索)。</strong>在我们深入遍历的实现部分之前，我想回顾一下最基本的知识，以便我们理解<strong class="kf ir">树</strong>的数据结构是什么样子。</p><h1 id="8317" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">树</h1><p id="e70d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">树是由节点组成的数据结构。每个节点以自上而下的方式连接到其他节点。</p><p id="7147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顶部的节点被认为是根节点。<strong class="kf ir">根</strong>可以有一个或多个子代。</p><p id="3caf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有子节点的节点称为“<strong class="kf ir">叶节点</strong>”。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/e0f1278bc52480b8e863ab204a0aa56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/0*iJQmo6DDQUANZkrT"/></div></figure><h2 id="0656" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp lp ks mq mr lt kw ms mt lx mu bi translated">基本树节点实现</h2><pre class="mf mg mh mi gt mv mw mx my aw mz bi"><span id="c438" class="mj lc iq mw b gy na nb l nc nd">public class TreeNode{<br/>    public var val:Int<br/>    public var left: TreeNode?<br/>    public var right: TreeNode?<br/>    public init() {<br/>        self.val = 0<br/>        self.left = nil<br/>        self.right = nil<br/>    }<br/>    public init(_ val:Int) {<br/>        self.val = val<br/>        self.left = nil<br/>        self.right = nil<br/>    }<br/>    <br/>    public init(_ val:Int,_ left:TreeNode?, _ right: TreeNode?){<br/>        self.val = val<br/>        self.left = left<br/>        self.right = right<br/>    }<br/>}</span></pre><h1 id="ba04" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">深度优先搜索</h1><p id="0870" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">深度优先搜索是一种以特定模式遍历树的算法。问题是，除非我们到达树的底部，否则我们会一直以特定的模式遍历节点。</p><p id="c744" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个算法中可以使用不同类型的遍历，但是总体概念是相同的。</p><h2 id="15f8" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp lp ks mq mr lt kw ms mt lx mu bi translated">遍历类型</h2><ul class=""><li id="e46c" class="ne nf iq kf b kg lz kk ma ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kf ir">按顺序</strong> —左—根—右</li><li id="940f" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kf ir">前序</strong> —根—左—右</li><li id="21b7" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kf ir">发布顺序</strong> —左—右—根</li></ul><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f2396613701b36a67b45cd8be6e7e772.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*9Xe-Xlf59YIwaYfe"/></div></figure><h2 id="8324" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp lp ks mq mr lt kw ms mt lx mu bi translated">DFS实施</h2><pre class="mf mg mh mi gt mv mw mx my aw mz bi"><span id="8646" class="mj lc iq mw b gy na nb l nc nd">//Inorder Traversal<br/>var result:[TreeNode] = [TreeNode]()</span><span id="920a" class="mj lc iq mw b gy nt nb l nc nd">func dfs_inorder(_ root: TreeNode?) -&gt; TreeNode? {<br/>    <br/>    if root == nil {<br/>        return root<br/>    }<br/>    <br/>    dfs_inorder(root?.left)<br/>    if let root = root {<br/>        result.append(root)<br/>    }<br/>    dfs_inorder(root?.right)<br/>    <br/>    return root;<br/>    <br/>}<br/>// Preorder<br/>func dfs_preorder(_ root: TreeNode?) -&gt; TreeNode? {<br/>    <br/>    if root == nil {<br/>        return root<br/>    }</span><span id="3427" class="mj lc iq mw b gy nt nb l nc nd">    if let root = root {<br/>        result.append(root)<br/>    }<br/>    dfs_inorder(root?.left)<br/>    dfs_inorder(root?.right)<br/>    <br/>    return root;<br/>    <br/>}<br/>//PostOrder<br/>func dfs_postorder(_ root: TreeNode?) -&gt; TreeNode? {<br/>    <br/>    if root == nil {<br/>        return root<br/>    }<br/>    <br/>    dfs_inorder(root?.left)<br/>    dfs_inorder(root?.right)<br/>    if let root = root {<br/>        result.append(root)<br/>    }<br/>    return root;<br/>    <br/>}</span></pre><p id="faf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这涵盖了树中深度优先遍历的实现部分。如果您想执行DFS，请记住使用递归来遍历树。对于树来说，这是最常用的遍历技术之一。</p><h1 id="17d4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">广度优先搜索(BFS)</h1><p id="dbe8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">BFS是另一种被强烈推荐的遍历树和图的技术。树顶部的节点被认为是在零层，然后它从上到下向前移动。树中的节点基于<strong class="kf ir">级别</strong>而不是深度进行分组。</p><p id="5864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，人们对使用递归来实现BFS有一种误解，但实际上这是使用<strong class="kf ir">队列</strong>来实现的。如果你理解遍历算法，这相当简单。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b582985a28e1271f3056e9f1aa2a10ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/0*0vokw7I91U6x2hZi"/></div></figure><h2 id="c8e2" class="mj lc iq bd ld mk ml dn lh mm mn dp ll ko mo mp lp ks mq mr lt kw ms mt lx mu bi translated">BFS实施</h2><pre class="mf mg mh mi gt mv mw mx my aw mz bi"><span id="f534" class="mj lc iq mw b gy na nb l nc nd">var bfsResult:[Int] = []<br/>func bfs(_ queue: inout [TreeNode], _ root: TreeNode?) {<br/>    <br/>    guard let root = root else {return}<br/>    <br/>    if queue.isEmpty {<br/>        queue.append(root)<br/>    }<br/>    <br/>    while !queue.isEmpty {<br/>        <br/>        var counter = queue.count - 1<br/>        <br/>        while counter &gt;= 0 {<br/>            <br/>            let removedEl =  queue.removeFirst()<br/>            bfsResult.append(removedEl.val)<br/>            <br/>            if let left = removedEl.left {queue.append(left)}<br/>            if let right = removedEl.right {queue.append(right)}<br/>            counter -= 1<br/>            <br/>        }<br/>    }<br/>}</span></pre><p id="17c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这涵盖了BFS的实施细节。</p><p id="79f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章能帮助你理解使用Swift实现树遍历的基础知识。下一篇文章再见。</p><p id="832f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编码快乐！干杯</p></div></div>    
</body>
</html>