# 围棋里慌是可以的

> 原文：<https://levelup.gitconnected.com/its-ok-to-panic-in-go-8169e4e3ce6c>

![](img/23c2b33d98ac245360cfabd2a2608c49.png)

照片由 [DDP](https://unsplash.com/@moino007?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

Go 的错误处理非常明确。与其他语言相比，它也可能非常冗长。我想谈谈我们如何通过将*预期的*和*非预期的*错误分开，来最小化对显式错误处理的需求。

## 预期误差

预期错误通常是您可以提前测试/检查/验证的，或者不会对系统产生不利影响的。预期错误的一些例子有:

1.  从输入中验证电子邮件地址。
2.  验证用户有权访问系统的某个部分。
3.  在已知的易损坏或缓慢的 API 端点上重试。

预期的错误应该总是返回一个错误。这让呼叫者决定在这种情况下做什么。它可能希望消除错误，或者选择退出当前操作。

这是显式错误处理代码真正出彩的地方(与隐式错误处理如异常相比)，因为您必须决定在这种情况下做什么。

## 意外错误

意外错误是指会将系统置于不合理的状态，或者在没有明确处理该情况的情况下无法恢复的错误。

意外错误的一些示例如下:

1.  **除以零。**在围棋中这将引起恐慌。有时候我们知道要提前检查(比如`len(myslice) == 0`)并做出相应的处理，但并不总是这样。
2.  **数据库不可用或变得不可用。**当然，假设你使用的是数据库。申请可能无法继续。
3.  **不可能或无效的状态。**例如，如果您的应用程序依赖于一个用户会话，而该会话在某个时候变得为零，那么当`nil`会话被取消引用时，您几乎肯定会遇到麻烦。我们不需要在每次函数调用时检查`nil`会话，因为我们期望*它在应用程序正常运行时总是有效的。*

大多数意想不到的错误(比如取消引用一个`nil`指针或者被零除)都被认为是理所当然的。我们不会编写代码来检查这些情况，除非我们认为它们是潜在的情况。那么它就变成了一个预期误差。否则，我们将生成大量的错误检查代码。其中大部分可能无法测试。

## 运用这种区分

希望到目前为止，这似乎是合理的。请注意，您可能显式处理的一些错误实际上可能是意外的错误。恐慌是可以的。否则，现在每个返回意外错误的函数都必须由调用它的其他函数来处理。一路向上。嘘！

对于一般的意外错误，调用者通常不会做任何明智的事情。死机的堆栈跟踪在这里通常也更有用。我们应该避免产生更多的复制/粘贴代码，这些代码只是将意外的错误向上传递到堆栈中。

让我们看一个从数据库中获取一些行的函数示例:

这个函数对于它要做的事情来说实在是太冗长了。有几个地方我们必须返回一个错误。但是，上述所有错误情况都是意外错误，因为它们发生在系统处于不良或不可恢复状态时。查询无效，或者数据库在试图检索结果时已经离开。这些是我们不应该返回的意外错误。这并不意味着我们忽视他们！

当我们将所有意外错误替换为死机时，我们注意到根本不需要返回错误:

这对`getUsersWithFavouriteColor`的所有呼叫者都更好。尽管如此，仍然存在一些问题。接下来我们需要处理函数仍然有多冗长。

很可能你会有几个或更多这样的函数，在内部检查所有这些错误是一件痛苦的事情。此外，通过单元测试只对现实(预期)的情况进行单元测试是合理的，因此所有这些恐慌都不会被涵盖。

让我们把它分成更多可重用的代码:

`getUsersWithFavouriteColor`现在看起来简洁多了。它只关注它需要的逻辑，不会浪费代码去处理意外的错误。

这篇文章发布后，出现了一些关于死机如何影响正在运行的服务的评论。需要说明的是，恐慌不会影响你的整体服务。事实上，它甚至不会影响同时发生的请求。这是因为在请求/工作单元本身的顶层会有一个`recover()`。如果你正在使用一个框架(比如`http`包),你将免费得到这个。