<html>
<head>
<title>Complete VueX 4 Guide: States, Getters, Mutations, Actions, Modules, Plugins, and Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完整的VueX 4指南:状态、Getters、突变、动作、模块、插件和组合API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/complete-vuex-4-guide-states-getters-mutations-actions-modules-plugins-and-composition-api-eff469c43b4f?source=collection_archive---------1-----------------------#2021-05-19">https://levelup.gitconnected.com/complete-vuex-4-guide-states-getters-mutations-actions-modules-plugins-and-composition-api-eff469c43b4f?source=collection_archive---------1-----------------------#2021-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6ab9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看完整的视频课程:</p><p id="1dee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://www.udemy.com/course/complete-vuejs-3-course/?referralCode=75F591E320BC4EA22188" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/complete-vuejs-3-course/?referral code = 75f 591 e 320 BC 4 ea 22188</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/d33ed85ecc359a121d875446fe490f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*KzUsftUBa92G6oxK_ttMlg.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">VueX 4</figcaption></figure><p id="4b54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vue应用由一系列嵌套组件组成。我们在最外面有一个根组件。它有零个或几个嵌套的子组件。每个子组件都可以有自己的子组件。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lb"><img src="../Images/ad704ba4240b485013e4c42e29607b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mp6JRXPfOYXR4vwYrrnyBQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">一个三级Vue演示应用</figcaption></figure><p id="3d59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了向内发送数据，也就是从父组件向其子组件发送数据，我们使用了props。子组件可能会从用户那里收集信息，因此需要将信息向上发送给其父组件。向上发送数据需要自定义事件。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lg"><img src="../Images/4b27ccccc4bb54949e79540af7ccc967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imTeYmCml7QQmUrJEF0qFA.png"/></div></div></figure><p id="7845" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着我们的项目变得越来越复杂，我们可能需要在一个组件和嵌套在其中的另一个组件之间交换数据。兄弟组件可能也需要相互交换数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lh"><img src="../Images/fd0b6886beca4f8159f913b525f66d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENDCODrt5mC4eWlejHYDVQ.png"/></div></div></figure><p id="7cb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这些情况下，Props和自定义事件相当不方便，因为它们只在父组件和其子组件之间传递信息。这就是开发VueX的原因。</p><p id="a365" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueX是Vue官方插件。它提供了对所有组件的平等访问，不管它们嵌套有多深。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi li"><img src="../Images/7aecb4133b8d35d07c7a2c45d4926f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwtojFs4EFit0IwVDkJGmw.png"/></div></div></figure><p id="85de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueX是使用<strong class="js iu">单例</strong>模式设计的。它是一个<strong class="js iu">共享的</strong>数据存储位置。所有组件读取和写入<strong class="js iu">相同的</strong>数据集。</p><p id="19a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的关键点是<strong class="js iu">只有一个数据集</strong>。所有组件都使用相同的数据集。任何数据修改将立即对所有组件可见，任何组件都不会收到过时的数据。</p><p id="e757" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们的程序有三个层次的组件:根、子和孙。在我们安装了VueX之后，每个组件的实例对象都将获得一个新的属性:美元符号存储。这就是组件访问VueX的方式。这也是VueX如何保证对所有组件的平等访问，不管它们嵌套得有多深。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lj"><img src="../Images/bce45b45c676f1c94d5eb59e307994a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IT64fz8kUPpowy4B5RlysA.png"/></div></div></figure><p id="3d1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存储在VueX中的数据称为状态。我们可以基于状态属性创建定制的getters。</p><p id="04c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要改变状态属性值，我们需要突变方法。只有突变方法可以改变状态值，并且所有的突变方法必须是同步的。为了从后端API检索数据，我们使用了动作方法。动作方法可以处理异步操作。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lk"><img src="../Images/6dc9a052f2491cf0dc87b766953e56b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jJyXrMOXfHm1tDy9TmZ0A.png"/></div></div></figure><p id="0398" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">突变和动作都是VueX方法。VueX具体将其方法分为两组。来自变异组的方法改变状态，来自动作组的方法处理与后端API的连接。这样的设计保证了所有的状态修改都是<strong class="js iu">同步</strong>的，因此可以以可预测的顺序执行。</p><p id="7dc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了触发变异方法，我们使用了<em class="ll"> $store.commit() </em>方法。至于动作方法，我们使用<em class="ll"> $store.dispatch() </em>方法。</p><p id="e1f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueX是使用单例模式设计的。所有东西都只有一份拷贝，所有东西都存储在同一个地方。随着我们项目规模的增长，VueX商店可能会变得非常臃肿。</p><p id="1f15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了帮助实现这一点，VueX允许我们将VueX商店划分为多个模块。每个模块都是一个子库，有自己的状态、获取器、变异和动作。一个模块甚至可以有自己的子模块。</p><p id="4251" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">状态、getter、变异、动作、模块是VueX的五大核心概念。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lm"><img src="../Images/02d9cc555da1c23f64ec55dc1f8e4f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9LzDJ7PgEc3KNPX_45Vdg.png"/></div></div></figure><p id="9999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们创建第一个VueX程序。我们需要的VueX版本是4。要安装VueX，我们复制CDN地址。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ln"><img src="../Images/241e9ac594f7c31fc47650ad8142197a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16vQEKZxitVyGl2JLbrhVA.png"/></div></div></figure><p id="a748" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的Vue程序中，我们添加了一个新的脚本标签，并使用复制的CDN地址设置它的<em class="ll">源</em>属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lo"><img src="../Images/9002fccd8c88cef827c49ee58398e674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*barDKdFgip1_I1CVhlUrZw.png"/></div></div></figure><p id="6caf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以通过<em class="ll"> Vuex </em>访问VueX api。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lm"><img src="../Images/2480a111f820cb7772630d679106ccc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmFW9G9WKNplBzovJjY_yQ.png"/></div></div></figure><p id="4579" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们正在使用的程序是一个非常简单的计数器应用程序。在根模板中，我们显示了number属性。当我们点击按钮时，我们触发了<em class="ll">增量</em>方法，该方法将数值增加1。我们还有一个子组件。目前，子组件仅显示标题。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ln"><img src="../Images/2f81775882d3f80d514aaadd0275c9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHbow3UsckYi74FOeztxAQ.png"/></div></div></figure><p id="053b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将VueX添加到程序中。</p><p id="fc1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们创建一个常数。我们把它命名为商店。商店是最常用的名称。不要选择其他名字。</p><p id="ab3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用VueX api中的createStore方法设置存储值。我们向createStore方法传递一个对象。这个对象是我们定义状态、getters、突变和动作的地方。我们将这个对象命名为VueX选项对象。</p><p id="859b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们用<em class="ll"> use </em>方法附加app实例，并向其传递存储常量。</p><p id="ffec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，VueX安装完成。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lp"><img src="../Images/a2576ae7687dc2dc5097f9c4a2d02396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pepU4BjuYbrDJrmnMNAtuw.png"/></div></div></figure><p id="928a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查根组件实例。我们可以看到它收到了一个新的属性:美元符号商店。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/53cea369f1d635d4ddefbaaf555ede6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*dbu1jIS4ywPOosgT0PUVGg.png"/></div></figure><p id="a54e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在子组件中也可以找到相同的属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/c5abebd5815ee0f70132e62facc923da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*azbrO0yfOM805A3Uv6gHaA.png"/></div></figure><p id="4c7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们比较这两个商店属性，我们将得到true，因为只有一个VueX商店。它由所有组件共享。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/c3738517b8c7f1d45b0e15b2dc6f858b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*JR9to7udEo3Pz90FijLlYQ.png"/></div></figure><p id="baa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存储在美元符号存储属性中的对象实际上是由createStore方法返回的同一对象。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/404dace810e72e21eff5fdc589330631.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*kAYVKN-l2KI0su-mHnoKuw.png"/></div></figure><p id="9506" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们从数据选项中删除数字属性。也不再需要<em class="ll">增量</em>方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lu"><img src="../Images/0622e2bef9c1647684bfb4caaa30bb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpOGrx4eKIpnDBQBEUkYAg.png"/></div></div></figure><p id="8ff5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在createStore对象中，我们添加了state选项。它的语法与我们在组件选项对象中设置的数据选项相同。我们使用一个函数来设置它的值，并在其中返回一个对象。我们在返回的对象中定义状态属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lv"><img src="../Images/68c7a7d503eb8d3ddb9259f11c7a48e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8H2hc8wtdLSio_t8kRWqA.png"/></div></div></figure><p id="b90d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也可以直接将对象指定给状态选项。这就是我们对以前的VueX版本所做的。结果是一样的。</p><p id="72d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们选择更复杂的函数语法是为了保证如果我们在创建其他VueX模块时重用options对象，state对象不会被共享。该函数将创建状态对象的新实例。我们将在模块课程中向您展示详细信息。</p><p id="9f5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果不打算重用options对象，则可以使用object语法。我个人会一直使用函数语法。</p><p id="a356" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们添加突变选项。它的值是一个对象。我们定义了一个名为<em class="ll">增量</em>的变异方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lw"><img src="../Images/ca2a9f03584fa564f2e2cf715024a0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqAhzaL6f6-MkHZ8jYuFuQ.png"/></div></div></figure><p id="cbdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变异方法自动接收状态对象作为它的第一个参数值。这是它们访问状态属性的方式。我们给<em class="ll">状态点号</em>加一。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lx"><img src="../Images/fdfd02382f19d345c692dafb1cd88e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZT5_WDjn50b9ZaeSxiQpTg.png"/></div></div></figure><p id="74cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下<em class="ll">虚拟机。$store </em>对象。我们找到<em class="ll">状态</em>属性并打开它。</p><p id="67ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数字属性存储在这里。我们还可以看到state属性的值是一个代理对象。这就是状态属性能够反应的原因。该机制与组件实例中的数据属性相同。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/ea4dbc1467a315cf9a71dbf3fd6c5561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*5iF7kR1nO6105CufMFsf_w.png"/></div></figure><p id="0cbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在组件模板中，我们可以通过<em class="ll"> $store.state </em>访问状态属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lz"><img src="../Images/5e9fa77b4c3699b85d3b7fe7b51b947e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zANQkXdQH9syKflnBVrewQ.png"/></div></div></figure><p id="b5f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了触发一个突变方法，我们使用了<em class="ll"> commit() </em>方法。<em class="ll">提交</em>方法也来自于<em class="ll"> $store </em>对象。它的第一个参数是我们想要触发的变异方法的名称。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ma"><img src="../Images/e92881aafc39040cb3c8a57584b4355e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVTfHOzdhGgCRH62lCeVZw.png"/></div></div></figure><p id="cb4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，柜台app完成了。它由VueX提供动力。数据存储在VueX中，并通过VueX突变方法进行修改。</p><p id="03c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们复制H1和按钮标签，并将它们粘贴到子组件的模板中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mb"><img src="../Images/75cb9c38feed795649f4eadcfb47d5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsBdWIybstX1s-eXUd_6dA.png"/></div></div></figure><p id="30d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">子组件与父组件访问相同的号码状态属性。如果我们改变一个组件中的数字状态，另一个组件将自动接收改变后的状态。</p><p id="bc37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两个按钮来自两个不同的组件，但是它们触发相同的方法并修改相同的状态属性。两个H1标签显示相同的数字状态属性。因此，它们总是同步的。</p><h1 id="b5ec" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak"> VueX详细状态</strong></h1><p id="1635" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">现在，让我们仔细看看VueX州属性。我已经预定义了三个状态属性。分别是品牌，型号，年份。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nf"><img src="../Images/becb084ecae1f24aa24eb588de25c355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iUmx5TIEhtfZA3bmaULkw.png"/></div></div></figure><p id="c35a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在组件模板中，我们通过在名称前加上前缀<em class="ll"> $store.state </em>来显示状态属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ng"><img src="../Images/ac11b124d456e892dfcc5b341cc67706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgRQMpGPzb6QonsZOxfqqg.png"/></div></div></figure><p id="cce3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这么长的前缀真的不方便。</p><p id="83ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以将状态属性作为计算属性映射到组件实例中。打开VueX API，你会发现四个名字以<em class="ll"> map </em>开头的方法。mapState方法是我们所需要的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nh"><img src="../Images/a0bb8b5646308f4e95a068e0cd83d72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77NHhpVmRJPtIYz1CqhCiA.png"/></div></div></figure><p id="5ce2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用mapState方法设置computed选项。我们将一个数组传递给mapState方法。我们使用状态属性名来设置数组元素。不要忘记用引号将数组元素括起来。这里有一个窍门:基本上VueX的所有内容都需要用引号括起来。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ni"><img src="../Images/b56841778751782665589975cb85814a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBamtjCB1jaB-IxzlnmU5g.png"/></div></div></figure><p id="f71e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，品牌、型号和年份都被映射到组件实例的根级别。在组件模板中，我们可以在不使用任何前缀的情况下访问它们。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nj"><img src="../Images/f6f3f884dbd64dfb572436c2326c52fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WeaoIBfFSTN3Mb0YslLQ6Q.png"/></div></div></figure><p id="2a83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在控制台表上运行mapState方法。让我们看看它返回什么。</p><p id="5b44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们发现一个物体。此返回对象中的属性以传递给mapState方法的数组元素命名。属性值是mappedState函数。这个函数供内部使用，它帮助我们从VueX状态中检索值。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nk"><img src="../Images/05b5ed6fa3cb85ec07048e83bb08e3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7vYNofMpdfOJh8hhBcDBw.png"/></div></div></figure><p id="002d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用mapState方法设置computed选项的值，我们将无法设置自己的计算属性。</p><p id="b0e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案是使用原始语法设置计算对象。在对象内部，我们用spread操作符作为mapState方法的前缀。将从返回的对象中检索属性，并将其插入到计算对象中。在mapState方法下面，我们可以设置自己的计算属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nl"><img src="../Images/c499a2128194cc6ea374badd4d2b5797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h15lQx0qxWsYK_Ldh8FFHw.png"/></div></div></figure><p id="24cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">mapState方法还支持对象语法，这需要更多的工作，但作为回报，它给了我们更多的控制权。</p><p id="e440" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要为想要映射到组件实例的每个状态属性设置一个属性名。州属性名应该用引号括起来。属性名不必与州名相同。我们可以设置别名。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nm"><img src="../Images/9b1dff9260ef1c8691ecd21aac759dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZOw_hcwXQ95WvV576Z8Pg.png"/></div></div></figure><p id="4a69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设置别名并不是我们使用对象语法的主要原因。我们使用object语法来设置定制的getters。</p><p id="ed72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Getter函数将接收状态对象，因此可以访问所有状态属性。这在getter函数中仍然指向组件实例，从而使我们能够访问组件数据属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nn"><img src="../Images/9bbb3ba50475992d4d6ff4c08672592f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UqsTvhMvxBY48wqDRTrig.png"/></div></div></figure><p id="97cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想要创建一个<em class="ll"> age </em>属性来反映车龄。</p><p id="d663" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先创建一个新的date对象来获取当前年份。然后我们从中减去<em class="ll">州点年份</em>。state参数让我们可以访问状态属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi no"><img src="../Images/c22796f540d0f68a95d15e727c775bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLoWDIie7IGzuEtsnSS2Cw.png"/></div></div></figure><h1 id="d96e" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">VuX吸气剂详情</h1><p id="1542" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated"><em class="ll">计算的</em>选项是数据选项的扩展。计算属性只是基于数据属性的getters和setters。</p><p id="0e9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueX中的状态选项与Vue组件中的<em class="ll">数据</em>选项的作用相同。它存储用于存储数据的属性。getter选项是与<em class="ll">计算的</em>选项等价的VueX。我们用它来定义基于状态属性的getters。</p><p id="e562" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">列表状态属性存储五辆汽车的信息。我们想列出所有手动挡汽车。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi np"><img src="../Images/244a9a5528692c97dd9cbca17bad801e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHXA1-ckaWKH1g_9Vp2ZVg.png"/></div></div></figure><p id="3b3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在getters选项中，我们创建了一个新属性:manualCar。它的值是一个getter函数。</p><p id="0d88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueX中的Getter函数自动接收两个参数:state和getter。State是第一个参数，getter是第二个参数。</p><p id="0046" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个参数帮助我们访问状态属性。第二个帮助我们访问其他getter属性，以防您需要为另一个getter创建一个getter。</p><p id="b0fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过<em class="ll">状态点列表</em>访问列表数组。我们在附录中加入了过滤方法来隔离所有的手动汽车。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nq"><img src="../Images/795faf1fb97145cc948718606c7ced5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQU_GKl552CiedEpzdxJKg.png"/></div></div></figure><p id="231d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用mapGetters方法，我们可以将getter属性映射到computed选项中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nr"><img src="../Images/a3a3f886cff1da74db8bc4dd7a9cab2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8dFfVGtKnvQ9Yb6rCVX7Q.png"/></div></div></figure><p id="f851" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以选择数组语法或对象语法。对象语法允许我们将一个getter映射到一个不同的名称。但这是它能做的全部，我们不能像在mapState方法中那样定义另一个getter函数。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ns"><img src="../Images/64be823926b9af1077cbdc9e666d2847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sW3L5ripu1PTZggsayVzow.png"/></div></div></figure><p id="f278" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，如果您希望保留原始的getter名称，请向mapGetters方法传递一个数组。如果要将getters映射到新名称，请使用object语法。更改名称是您可以对对象语法做的唯一事情。</p><p id="7ac8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，manualCar数组已经被插入到同名的根组件实例对象的根级别中。在组件模板中，我们将list切换到manualCar。现在只会上市手动挡的车。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nt"><img src="../Images/49b8361bbad35904c7431d255c6b7c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHNGAtoH0SWPsbS0U_UDRg.png"/></div></div></figure><p id="d9f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们尝试第二个参数:getters。它让我们可以访问getters对象，这意味着我们可以基于另一个getter创建一个getter。</p><p id="1cfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如我们想知道手动挡汽车的总数。我们使用第二个参数访问manualCar getter。然后我们在它后面加上长度属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nu"><img src="../Images/226ff9ca4c1671d6c0d1d7d1eea2f280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wzx79i8SRBCv6_-eIha6A.png"/></div></div></figure><p id="f761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> VueX突变详情</strong></p><p id="64f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这节课中，我们将学习突变方法。在我们开始之前，请记住只有突变方法可以修改状态值，并且所有的突变方法必须是同步的。不要将任何突变方法连接到任何后端API。变异方法的唯一工作是为状态属性设置新值。</p><p id="09bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一种变异方法的名字叫做<em class="ll">型</em>。这个函数体被称为<em class="ll">处理器</em>。处理函数必须是同步的。</p><p id="1a12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有的变异方法都会自动接收状态对象。这是它们访问状态属性的方式。他们不依赖于此。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nv"><img src="../Images/a78b35aa8612959da0265ad6cb54d3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05YG6eZhgf21ObV-wNuyow.png"/></div></div></figure><p id="8fb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了触发一个突变方法，我们使用了<em class="ll">提交</em>方法。我们将方法名传递给<em class="ll">提交</em>方法。commit方法接受第二个参数。它将作为第二个参数值传递给提交的变异方法。如果您需要向提交的变异方法传递几个值，请将它们放在一个对象或数组中。</p><p id="3b6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在组件方法内部触发了<em class="ll">提交</em>方法。我们可以将组件数据属性传递给它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nw"><img src="../Images/f68e57df39d6a09a820e51d0c01200c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9xcIxAnRkHIp5Qd3HOGwA.png"/></div></div></figure><p id="fe82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有另一种设置<em class="ll">提交</em>方法的方式。我们传递一个对象给它。我们使用<em class="ll">类型</em>属性来指定我们想要触发的突变方法。记住要用引号将突变方法的名称括起来。然后我们可以设置任意多的属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nx"><img src="../Images/99458c061f33beda40b14f5101c27676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emVS_MhjAtncfgofOAj-Lg.png"/></div></div></figure><p id="5a07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传递给<em class="ll">提交</em>方法的整个对象将作为第二个参数传递给提交的变异方法。通常，我们将第二个参数命名为<em class="ll">有效载荷</em>。我们需要从有效载荷对象中检索我们需要的属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ny"><img src="../Images/06c3713f970a6213e2a9fff9b72c46eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmxPJoMBv7pY4OM0FlMAeA.png"/></div></div></figure><p id="4739" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们定义一个新的变异方法。我们称之为<em class="ll">减量</em>。它从number state属性值中减去1。</p><p id="dc23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次，我们希望将<em class="ll">减量</em>突变方法映射到组件实例中。<em class="ll"> mapMutations() </em>方法与<em class="ll"> mapGetter() </em>方法相同。您可以使用数组语法将变异方法映射到它自己的名称。使用object语法，您可以选择不同的名称。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nz"><img src="../Images/182f065504b8f5be042fd69f7cbecbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsyEI80Q5Finx92C4wB6rA.png"/></div></div></figure><p id="c05d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，减量突变方法已经被映射到同名的根组件实例。我们将它作为普通的组件方法来调用。不需要<em class="ll">提交</em>方法。</p><p id="0c83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的实际项目中，最好不要映射任何突变或动作方法。只需使用<em class="ll">提交</em>和<em class="ll">分派</em>方法来触发它们。</p><h1 id="46c9" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">v型和VueX</h1><p id="ae50" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">我们这里有一个输入标签。使用<em class="ll"> v model </em>指令，我们在输入表单和消息数据属性之间建立了一条双向路径。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oa"><img src="../Images/10b29c8c28eae5d6518842871356dbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0ZA4-POK62uhrrm2eq_Kw.png"/></div></div></figure><p id="0f82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想要将<em class="ll">消息</em>属性移动到VueX状态，但是我们要求输入标签保持和以前一样。换句话说，我们需要启用v模块指令来处理VueX的状态属性。知道怎么做吗？</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ob"><img src="../Images/e4b4d4beb5ea616d928a90b1fda12cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPYKtu0DFF0U-dVIRqfazg.png"/></div></div></figure><p id="77e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在组件选项对象中，我们添加了计算选项。我们使用对象语法声明了一个<em class="ll">消息</em>属性。我们为它设置了getter和setter。</p><p id="3c04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在getter函数中，我们返回<em class="ll">这个点美元符号存储点状态点消息</em>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nh"><img src="../Images/b7f991780d315c09ac697f40117c5ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*516AXP9qRzljBsRtvCVn7w.png"/></div></div></figure><p id="2994" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在setter函数中，我们将用户提交的值分配给消息状态属性。只有突变方法可以操作状态属性的值。所以我们需要定义一个变异方法来帮助我们进行赋值。</p><p id="87c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将新的变异方法命名为<em class="ll">更新</em>。我们将其第二个参数值赋给消息状态属性。然后在setter函数中，我们“提交”了<em class="ll"> update </em>突变方法，并将新的消息值作为第二个参数传递给它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oc"><img src="../Images/aed495932ffa131b98f9fa9b16f5518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdaKeDOkWtcw3JCZO8Oqfw.png"/></div></div></figure><p id="e49f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经在消息状态属性和输入表单之间建立了一个双向数据路径。关键是设置一个可写的计算属性作为中间人。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi od"><img src="../Images/0edb862c59e8ba5c600b03cb1a10def1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTMf3s7ATdxXL0KdMi4IPw.png"/></div></div></figure><h1 id="c3b2" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak"> VueX行动详情</strong></h1><p id="df65" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">我们这里有一个半成品的天气应用程序。我们将使用VueX来检索所选城市的天气描述。</p><p id="d6b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将城市名存储在根组件中，并使用VueX来检索和存储天气信息。当我们点击这个按钮时，我们希望载入当前城市的天气信息。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oe"><img src="../Images/d72ef22448b6569de167d92a938ad896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLbunIBCVC26cvwP-WdNIg.png"/></div></div></figure><p id="3620" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从后端API检索数据是一个异步操作，因此应该使用action方法来完成。</p><p id="14b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经安装了axios。我们转到VueX并添加操作选项。我们添加了一个名为query的新动作方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi of"><img src="../Images/5ec7e29e48cd4a02fa6b004a814d3a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1he1vpSWhZ1so9Q27jTX8A.png"/></div></div></figure><p id="3b57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查询方法接收两个参数。第一个是语境。第二个是我们设定的。我们把它命名为城市。我们用它将城市名传递给查询方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi og"><img src="../Images/17c8b504cab50a3724396aa0ce9bbed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5H7_U8obqDXRYGXVLcQ9CA.png"/></div></div></figure><p id="f48c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在触发器方法中，我们“分派”查询操作方法。我们将<em class="ll">这个点城市</em>传递给<em class="ll"> dispatch </em>方法作为它的第二个参数值。现在，当我们单击按钮时，城市名称将被传递给<em class="ll">查询</em>操作方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oh"><img src="../Images/0ffcf11adb8a1d09db9363b79e64eb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uB1W0rEdncQNKxpWyCovw.png"/></div></div></figure><p id="fa68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个参数<em class="ll">上下文</em>让我们访问整个VueX商店。我们可以访问状态和getter属性。我们还可以提交突变，甚至调度其他动作方法。</p><p id="5bde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们定义<em class="ll">查询</em>动作方法。我们首先给它加上前缀<em class="ll">异步</em>。</p><p id="c66b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们准备API地址。API地址包含两条外部信息:城市名和验证密钥。</p><p id="85ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">城市名来自函数参数。我们可以直接访问它。</p><p id="34d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">验证密钥以VueX状态存储。我们通过<em class="ll">上下文</em>访问它。我们用<em class="ll">上下文点状态</em>作为关键字的前缀。</p><p id="d85d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，API地址已经设置好了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oi"><img src="../Images/9b32e11a7b349fb4e9f4db5b47c03b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p99vvurYDvuPUA4yT0-t3g.png"/></div></div></figure><p id="d7e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们添加了TRY CATCH语句。</p><p id="3780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在TRY部分，我们'<em class="ll">等待</em>，<em class="ll"> axios get </em>方法，并将API地址传递给它。我们将返回的对象存储在结果变量中。然后，我们在控制台日志中记录城市名和检索到的天气描述。</p><p id="22ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在CATCH部分，我们在控制台记录错误消息。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oj"><img src="../Images/a725ce6261c4fb0d9c3fed05fd624bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzNLGq_FO24L0bEFPB3EuA.png"/></div></div></figure><p id="c12e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的目标是将检索到的天气描述分配给<em class="ll">描述</em>状态属性。这就需要一个突变的方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ok"><img src="../Images/d6993ee63c3264c819b3991c9121c23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f8xTs3Xo4Ztx-VWOuj6CsQ.png"/></div></div></figure><p id="e86e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们增加了突变选项。我们定义了一个名为<em class="ll"> update </em>的变异方法。<em class="ll">更新</em>方法将其第二个参数值赋给<em class="ll">描述</em>状态属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ol"><img src="../Images/be3e238d5313b658600fd09bab05ed31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_p6pgZwbZ-weL9T8-WNd1Q.png"/></div></div></figure><p id="c178" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们回到查询方法的TRY部分。</p><p id="839d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们“提交”了<em class="ll">更新</em>变异方法，并将检索到的天气描述传递给它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi om"><img src="../Images/057d1945797dc6397f816e26154089de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7erfTa57CgB1tqXL76VtA.png"/></div></div></figure><p id="e723" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，程序完成了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi on"><img src="../Images/37da901187c6fc826aca2dd3d530539d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*git5SCOiH8PiN8BzVetglQ.png"/></div></div></figure><h1 id="69cd" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">练习:创建一个天气应用程序。</h1><p id="4eca" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">在这一部分，我们仍将致力于天气应用程序。但是我们会让事情变得更复杂，这样我们就可以尝试我们所知道的关于VueX的一切。</p><p id="0c74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ll">城市</em>和<em class="ll">描述</em>都是VueX状态属性，但是我们不希望在组件模板中使用长前缀。这要求我们将它们映射到组件实例中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oo"><img src="../Images/047e6d1b347583816f0ee4a82c9c8045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehK90O2Rdm4t9P_Es0IfGw.png"/></div></div></figure><p id="9ca7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们添加了<em class="ll">计算的</em>选项，并在其中‘传播’了mapState方法。我们将城市和描述映射到组件实例中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi op"><img src="../Images/6286f16be6d8072e58746e9cce9c98b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rh1l7oOjDUVpbgsg-H9tCg.png"/></div></div></figure><p id="159a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们单击city按钮时，我们触发了<em class="ll"> change </em>方法，并将新的城市名传递给它。我们需要将新的城市名称传递给city state属性。这需要我们“提交”一个突变方法。</p><p id="a6e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们转到VueX并添加突变选项。</p><p id="8318" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义了一个名为changeCity的变异方法。我们用<em class="ll">国家点城市</em>设置它的第二个参数。在<em class="ll"> change </em>方法中，我们提交changeCity突变方法，并将新的城市名传递给它。</p><p id="fded" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以通过单击城市按钮来更改城市名称。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oq"><img src="../Images/9303668180557ecd433f2446739e529e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KG8I062T_U7TPdZ-2x2RgQ.png"/></div></div></figure><p id="0cd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们回到VueX。我们添加了actions选项，并定义了一个名为<em class="ll"> query </em>的异步操作方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi or"><img src="../Images/454cd865a4bf2fc3af6cccbbf43ae880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ccABdkd438lvNSCi-hSymw.png"/></div></div></figure><p id="9d6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上一课中，我们为查询方法设置了两个参数。第二个参数是城市名。这里，我们采取不同的方法。我们只保留第一个论点。我们没有将城市名传递给查询方法。</p><p id="2638" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API地址中使用了城市名称。我们可以使用getter来生成API地址。在getters选项中，我们创建了一个名为API的getter。我们在其中返回API地址。城市和键值都来自VueX州。我们在它们前面加上州名。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi os"><img src="../Images/f5fc31569775e38502cfc6bd0b5cdb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0DDbHu8WXV5NPcOL_QSxw.png"/></div></div></figure><p id="3d88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，每次我们更改城市名称时，API getter都会返回一个新的API地址。</p><p id="2b87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<em class="ll">查询</em>动作方法中，我们添加了TRY CATCH语句。在TRY部分，我们等待<em class="ll"> axios get </em>方法。我们将<em class="ll">上下文点getters点API </em>传递给get方法。当我们更改城市名称时，API地址会自动更新。然后我们将返回的对象存储在一个名为<em class="ll"> result </em>的变量中。我们在控制台日志中记录了城市名称和天气描述。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ot"><img src="../Images/545752ce03e0a514eb71cc2ed6d1d03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHJIpgJR6adeTOqDbBSasw.png"/></div></div></figure><p id="d535" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要一个突变方法来更新描述状态属性。我们将其命名为更新天气。在查询操作方法中，检索到天气描述后，我们“提交”updateWeather突变方法，并将检索到的天气描述传递给它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ou"><img src="../Images/05ddc579aa051e18b59ae1a3b48f61c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fu3pec90kclyc5cxsCTl9A.png"/></div></div></figure><p id="646e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们更改了城市名称之后，我们需要将描述状态重置为<em class="ll">加载信息</em>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ov"><img src="../Images/862dbecfc1a1fb3d2d51d65fd7de8162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQZAfO6WiQn7HTyHSiC4eA.png"/></div></div></figure><p id="d230" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们在VueX方面的工作已经完成。</p><p id="eee7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<em class="ll"> change </em>方法中，在我们提交了<em class="ll"> changeCity </em>变异之后，我们分派了<em class="ll">查询</em>动作。变异方法都是同步的。在这里，我们可以放心，在发送查询操作之前，城市名称将被更改。如果您愿意，可以在<em class="ll"> changeCity </em>突变方法中调度<em class="ll">查询</em>动作。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ow"><img src="../Images/1707f62155b00010096cd8f215864071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXuGbAKB8RYghHeikI6WFg.png"/></div></div></figure><p id="f928" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们添加创建的钩子，并在其中分派<em class="ll">查询</em>动作。这是为了加载初始数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ox"><img src="../Images/6e4e22018f585704ba30563e98ce76aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJV8_3Kyy3umvK-On8S1hQ.png"/></div></div></figure><p id="cb1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，程序完成了。每当我们选择一个新的城市，该城市的天气描述将被检索。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oy"><img src="../Images/948c13271cca67814b3b1d7c07042408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMYY2JgjlSZv_jZPuVNaOw.png"/></div></div></figure><h1 id="7887" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak"> VueX模块</strong></h1><p id="730e" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">VueX只保留一组数据。但是随着我们的项目越来越完善，一个数据集可能是不够的。这就是引入VueX模块的原因。</p><p id="b38e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了根存储，我们可以为它创建几个子存储。每个子店都是独立的，不会干扰其他店。</p><p id="87c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传递给createStore方法的对象是我们定义根模块的地方。我们添加了模块选项，并为其分配了一个对象。这个对象是我们声明子VueX模块的地方。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oz"><img src="../Images/335dee7c22c8ced9f42c2ff956da6f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5NTC2n4TcjEG0UvYyFcow.png"/></div></div></figure><p id="5c10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们创建两个模块:模块A和模块b。</p><p id="d2c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在模块A中，我们添加了state选项并声明了一个title属性。在模块B中，我们做同样的事情。这两个标题状态是独立的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pa"><img src="../Images/2cec19fa0b78b3c17ffd512b17297f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2G1agbvUpvI8QlEMDOukg.png"/></div></div></figure><p id="12df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们在模块选项中注册这两个模块。我们在模块选项中设置的属性名将被用作模块名。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pb"><img src="../Images/1a5c07b66b8e53fd9b944a0aaa9b40c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p91poMVDSLOtsF46DjvSFA.png"/></div></div></figure><p id="70e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查存储变量。</p><p id="022f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们打开状态对象。我们可以看到状态对象已经接收了两个子对象。它们以模块名命名。两个子模块的状态属性存储在这两个对象中。</p><p id="7f2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">createStore方法的options对象中定义的状态属性是根状态属性。根状态属性存储在状态对象的根级别。这就是为什么我们在同一个名字下有两个状态属性，但是它们不会互相冲突。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pc"><img src="../Images/9248d4c1d599f3efb457f88e7c216683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_zC4kZUtJ6DutE3e465Qw.png"/></div></div></figure><p id="05ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们在所有权名下有三个州的财产。让我们将它们映射到组件实例对象中。</p><p id="da40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们添加了计算选项。我们使用对象语法设置mapState方法，这样我们就可以为三个标题状态属性设置别名。</p><p id="6267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于根状态属性，我们可以通过名称直接访问它们。对于子模块的状态属性，我们需要函数语法。我们返回状态点模块名点属性名。</p><p id="d0ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，三个标题属性已经被映射到根组件实例中。我们通过他们的化名来访问他们。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pd"><img src="../Images/8a6bec2929bb21dca1105e69c89aaed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSdAy7RyHO0Wh5GLk7XaAw.png"/></div></div></figure><p id="b56c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们尝试getters。在模块A中，我们添加了getters选项并创建了一个capTitle getter。我们返回大写的标题值。</p><p id="8d22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">getter函数有三个参数。第一个是当前模块的状态对象。第二个是当前模块的getter对象。第三个指向根状态对象。为了从当前模块中访问状态属性，我们使用第一个参数。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pe"><img src="../Images/ca608c747f7b1a2ddb9c4176059174b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bekT2v5ZVnpvBgO3sO78VA.png"/></div></div></figure><p id="eacf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们复制getters选项并粘贴到moduleB中。现在，我们有两个队长。它们会引起命名冲突吗？</p><p id="496a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们收到一条错误消息。上面写着重复的getter键。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pf"><img src="../Images/641cf70a60e0e70bf60c77880d399a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J07xSlx-5Ju8SEL2f1ZgZg.png"/></div></div></figure><p id="83c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们禁用一个capTitle getter，错误消息就会消失。</p><p id="f6ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来自所有模块的Getters将直接合并到getters对象的根级别。与状态对象不同，不会有任何子对象。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pg"><img src="../Images/accef54b7e15bffb40543afd73c09a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vudNHuBwI_32vowt0FD35Q.png"/></div></div></figure><h1 id="36ab" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">命名空间</h1><p id="6f59" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">在这一课中，我们将讨论命名空间。它帮助我们区分不同模块的getters、mutations和actions，这样相同的名字就不会引起命名冲突。</p><p id="c241" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">状态属性不需要名称空间，因为它们有自己的方式来避免命名冲突。</p><p id="1cec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根状态属性将存储在状态对象的根级别中。来自子模块的那些将被存储在以模块名命名的子对象中。此功能仅适用于状态属性。</p><p id="5a7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来自所有模块的Getters将被合并到同一个对象中。因此，相同的getter名称会导致命名冲突。</p><p id="52e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时，可能很难保持getter名称的唯一性，在这种情况下，我们可以使用namespace在getter名称前面加上它们的模型名称。</p><p id="1253" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将<em class="ll">命名空间</em>选项添加到模块A中，并将其值设置为true。不要漏掉最后一个字母d。</p><p id="24fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模块B还没有打开名称空间，所以它的getter没有前缀。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ph"><img src="../Images/2e31d24ba14d4fd5e8ef8f8b3fea9b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXYUu-h1m2arqKexMSUGxw.png"/></div></div></figure><p id="20de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议打开除根模块之外的所有模块的名称空间。打开根模块的名称空间是没有意义的，因为根模块没有名称，因此，根getters不会收到任何前缀。</p><p id="60e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将这三个capTitle getters映射到组件实例中。</p><p id="fd8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望保持getter名称不变，所以我们使用数组语法。子模块中的Getters需要以它们的模块名为前缀，并用斜杠分隔。根getters不需要前缀。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pi"><img src="../Images/4ed0c2612e065903a59c5b4204e058bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8NQ_EySKKuNnrgV7QTHPgw.png"/></div></div></figure><p id="20d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有三个capTitle吸气剂已被添加到它。感谢前缀，不会有任何命名冲突。</p><p id="836c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了访问根getters，我们直接使用它们的名字。</p><p id="a136" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至于来自子模块的getters，它们的名字包含一个特殊的字符斜杠，我们需要把它们的名字放在方括号中并用引号括起来。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/74e2658a62ccd94a76fc99ecdeeba543.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*O417dqdmqNG5YNiA8BjSog.png"/></div></figure><p id="9d5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时，一个组件可能只需要一个模块的getters。在这种情况下，我们可以在mapGetters方法中指定目标模块的名称空间。</p><p id="77b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将模块名作为第一个参数值传递给mapGetters方法。现在，这个mapGetters方法只适用于模块a。我们不再需要在getter名称前加上模块名。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pk"><img src="../Images/be9b953ee703652a22ccc548c910937f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbehNTDyyKoG3iliQwCsyA.png"/></div></div></figure><p id="200a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有映射方法都支持名称空间。例如，我们添加了mapState方法，并将其第一个参数值设置为a。</p><p id="624c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传递给aTitle方法的状态对象只包含模块A的状态对象的属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pl"><img src="../Images/ee83ddf793347bf9b6fc2591d7d5b305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfiWEpJeNqpgYJKz6TDDWg.png"/></div></div></figure><p id="1888" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样的规则也适用于突变和动作。</p><p id="1ef5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时，我们可能需要在模块内部定义全局操作方法。在这种情况下，我们需要使用对象语法来定义操作方法。我们仍将使用测试方法作为示例。我们把它的功能体转换成一个对象。</p><p id="a8e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对象中，我们添加根属性并将其值设置为true。</p><p id="49f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们添加handler属性来定义函数体。handler方法与普通的action方法相同。它有两个参数:上下文和有效负载。有效负载的值取决于如何调度测试操作方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pm"><img src="../Images/fce88179da1939095b4548ea315e5201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mtu6dG4Irwobq4_EPPh6-Q.png"/></div></div></figure><p id="bf05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">测试操作方法是全局的，但它仍在模块A中定义。其上下文对象中的状态属性仍指向模块A的状态对象，而不是根状态对象。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pn"><img src="../Images/e5a7962530f747506d34fda8fefd4f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5D4-IgqA2d24Zve3yQBrdg.png"/></div></div></figure><p id="57f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">若要访问根状态或其他模块中的状态，请使用rootState属性。吸气剂也是如此。有一个getters属性和一个rootGetters属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi po"><img src="../Images/716ecdc8ec12968d98f87261acb998b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJj7qzncoHg8VqLVxKOeZw.png"/></div></div></figure><p id="ebff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们制作测试动作的副本，并将其粘贴到根模块中。</p><p id="72a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们有两个测试操作方法，但它们都是全局的。让我们看看VueX是如何处理这种情况的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pp"><img src="../Images/69475e28a3a7e4f1a30cd6d41f4784d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d04m5P5HrN92zs7rtPRiIA.png"/></div></div></figure><p id="6869" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们刷新页面并检查商店对象。</p><p id="1449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下划线操作中，只有一个测试属性，但它的值是一个数组。两种测试操作方法都存储在这里。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pq"><img src="../Images/1e33e5923709ef8e9268c16d2e5772c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKJlpxkMYBOJQNDOPywjgg.png"/></div></div></figure><p id="d054" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，当我们分派测试动作时，我们将同时触发这两个动作。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pr"><img src="../Images/114b2360f0b65aea25f70155bed3a27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ljabCzF-rK0wpDs9JwibRA.png"/></div></div></figure><h1 id="0c46" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak">动态VueX模块</strong></h1><p id="354d" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">在本节中，我们将讨论动态模块。</p><p id="63a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用registerModule方法注册动态模块。registerModule方法有两个参数。第一个是模块名，第二个是用于定义模块的选项对象。options对象只是一个普通的对象。我们可以反复使用。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lh"><img src="../Images/bbc15f89cb6682445d243db40ada9f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzdOZng56_SylyqU92YUSQ.png"/></div></div></figure><p id="bc3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<em class="ll"> hasModule </em>方法，我们可以检查一个模块名是否已经注册。</p><p id="20bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<em class="ll"> unregisterModule </em>方法，我们可以删除一个模块。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ps"><img src="../Images/a9e1fee65df031910d7a17b9923f83fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0wbEvOZRbmxiEx1-wllyw.png"/></div></div></figure><p id="5a9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们复制registerModule方法。我们将新模块命名为A2。A1和A2是使用相同的选项对象创建的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pt"><img src="../Images/b688fab5401334a3042de9ea7aed8c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PqBxQZraXaKfOINMFwcFg.png"/></div></div></figure><p id="f1bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还记得我们提到过最好使用函数语法来设置状态选项吗？现在，你会明白为什么。</p><p id="b0a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同一个options对象用于创建两个模块。自然，我们希望这两个模块是独立的。</p><p id="b094" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们使用对象语法重置它的状态选项。我们移除该函数，并将an对象直接分配给state选项。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pu"><img src="../Images/117a754c8a08abf8b683fe4723bc7265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQh2XvGNBzDLnf6wheBYAg.png"/></div></div></figure><p id="4191" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从模块A1重新加载页面并重置标题状态。</p><p id="a2f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后让我们检查状态对象。</p><p id="98ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以看到问题了。模块A2的标题也已更改。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pv"><img src="../Images/284ad5f94cada5121c3e8f22ddf56f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtSt990Hb9eWfppMKEwr6Q.png"/></div></div></figure><p id="e53c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模块A 1和A2共享同一个状态对象。更改模块A1的状态属性也会影响模块A2。</p><p id="29e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然，这不是我们想要的。这就是为什么您应该使用函数语法来设置state选项。函数语法确保使用相同的选项对象创建的模块将有它们自己的状态对象。更改一个模块的状态属性不会影响其他模块。</p><p id="a5cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于永远不会重用的选项对象，可以使用对象语法。但就个人而言，我会一直坚持函数语法。</p><p id="4dd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">registerModule方法将一个config对象作为其第三个参数。我们可以在其中设置<em class="ll"> preserverState </em>属性。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pw"><img src="../Images/125e9b513d02c54931db10f680072263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTGigSK4ghUhvQfsoovBMg.png"/></div></div></figure><p id="c0ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将preserveState属性设置为true可防止将模块的状态属性添加到VueX存储中。</p><p id="e03d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueX假设当前存储已经包含该模块的状态，并且您不想覆盖它。换句话说，对于不需要状态属性的模块，可以将<em class="ll">preserve estate</em>设置为true来放弃它们。</p><p id="c558" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也意味着这个模块的突变和getters将不再工作。</p><p id="8d99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们从模块A1“提交”changeTitle突变方法，我们将得到一个错误消息，因为标题状态属性尚未添加到VueX存储中。</p><h1 id="71ee" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak"> VueX插件</strong></h1><p id="5c00" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">在这一节，我们将学习VueX插件。</p><p id="6c90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueX插件只是钩子函数，当我们第一次加载程序时会被触发。</p><p id="50ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在根模块中，我们添加了插件选项，并为它分配了一个数组。这个数组是我们注册插件函数的地方。我们把它命名为P1。</p><p id="8769" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们定义一个名为P1的函数。插件函数将接收存储对象。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi px"><img src="../Images/459939cf5c67b742f397665862befd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AD6qjMkMoqIYgzpNaWPmxQ.png"/></div></div></figure><p id="1219" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们第一次加载程序时，插件功能会自动触发。分派动作或提交突变不会再次触发插件功能。</p><p id="04cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了监控突变或动作方法，我们需要两个subscribe方法。subscribe方法监视变异方法。对于操作方法，请使用subscribeAction方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/ea6a3c11fa0cf28d8bcc07837f178a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*vwxcmamfIqmH5ZKzjqFBdQ.png"/></div></figure><p id="9697" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两种订阅方法是独立的，它们不依赖于插件。它们只是插件中最常用的。</p><p id="168e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在P1插件中，我们添加了subscribe方法来监控突变。我们向subscribe方法传递一个回调。这个回调有两个参数:突变和状态。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi py"><img src="../Images/89630577fa227535391903ff53fa847a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yuPuCiFs5UDkKr60zTd3A.png"/></div></div></figure><p id="d411" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回调的第一个参数是一个具有两个属性的对象。</p><p id="e177" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<em class="ll">类型</em>属性，我们可以判断哪个突变方法被触发。<em class="ll">有效负载</em>属性存储传递给突变方法的参数值。</p><p id="8f52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个参数是VueX存储的状态对象。它反映了最新的状态，意味着其中的属性已经被“变异”了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi pz"><img src="../Images/c921375dc3fe38c2cb53fe4d1e3a46d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*FRlkGQVOh89eWuQJuNJjHw.png"/></div></div></figure><p id="6702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以添加任意多的<em class="ll">订阅</em>方法。它们将被推入一个队列，并按照添加时的顺序执行。</p><p id="ea8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以选择一个subscribe方法，并将其移动到队列的开头，这样它将首先被执行。</p><p id="2e7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所选subscribe方法的回调后面，我们添加了一个config对象。我们将<em class="ll">前置</em>设置为真。现在，第二个订阅方法将被添加到队列的第一个位置。因此，它将首先被执行。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qa"><img src="../Images/0fb7b680bf29359d5aa5565cba858dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePGWbNl4jbnE1JLlvH6Caw.png"/></div></div></figure><p id="d141" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在开发阶段，我们可能需要拍摄状态快照，以比较突变前和突变后的状态。这可以通过比较两个状态对象来完成。第一个状态对象来自插件函数，第二个来自订阅方法。</p><p id="89a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经安装了<em class="ll"> low dash </em>这是一个JS函数库。它有一个叫做cloneDeep的方法。它创建对象的深层副本。深度复制意味着复制所有嵌套的对象。</p><p id="0056" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在subscribe方法之外，我们对state对象进行深度克隆，并将副本存储在名为<em class="ll"> pre </em>的变量中。状态对象来自传递给插件函数的存储对象。这是变异前的状态。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qb"><img src="../Images/ab22a140e6edb97cd61b4a2b04abfd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nD8_Tx9poq70KkTK-_V-Zw.png"/></div></div></figure><p id="906f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在subscribe方法的回调中，我们对state对象进行了第二次深度克隆。我们将复制的对象存储在名为post的变量中。</p><p id="0563" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次，状态对象来自回调的第二个参数。这是变异后的状态。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qc"><img src="../Images/74de3b46bc21c2910736dd7f452df21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3EOfYDnPbMQ53nIJz_G4Yw.png"/></div></div></figure><p id="a86e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在<em class="ll"> pre </em>存储旧状态，<em class="ll"> post </em>存储新状态。</p><p id="c6e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们输出它们进行比较。</p><p id="f008" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将post分配给pre。注意，赋值必须放在最后，在我们输出<em class="ll"> pre </em>和<em class="ll"> post </em>之后。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ov"><img src="../Images/ac7c844acfacc3b03e58719f2bca5dea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5ZD4enLx8RA-Af_BiQSGw.png"/></div></div></figure><p id="39b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试试这个程序。</p><p id="587c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以比较突变前和突变后的状态。深度克隆技术仅用于开发目的。不要在生产环境中使用它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qd"><img src="../Images/8d8672bfaa72d8e8e7e0ac6b98649403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szAwhRNX7Ni1PmwLfW1iBQ.png"/></div></div></figure><p id="a7bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">subscribe方法返回一个unsubscribe方法。调用它，subscribe方法将被取消。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qe"><img src="../Images/f30e1ffa7b8b165e880dc41575f7250c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKUr_A0McJshZK8k5hC2IQ.png"/></div></div></figure><p id="5859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了监视操作方法，我们使用subscribeAction方法。其语法与subscribe方法相同。传递给它的回调接收两个参数:action和state。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qf"><img src="../Images/26970a8e0e48199f12e0dcbf5248f752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3Ld7TBhjQQUfW6m3t5zxA.png"/></div></div></figure><p id="e8db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">action参数仍然是一个具有两个属性的对象:type和payload。</p><p id="dd9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型告诉我们被调度的动作方法的名称。Payload告诉我们传递给调度的action方法的参数值。</p><p id="5ee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">动作方法不修改状态属性。因此，状态参数存储突变前的状态。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qg"><img src="../Images/3def72b01eaaec791af2e610e995ad6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euzsPT_YVzJH6vUxsaTbUQ.png"/></div></div></figure><p id="d1c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还可以使用object语法设置subscribeAction方法。我们不是向它传递回调，而是向它传递一个对象。对象允许我们设置两个方法:before和after。</p><p id="9e98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如它们的名字所暗示的那样，这两个方法将在一个动作方法被调度之前和之后被触发。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qh"><img src="../Images/5ba0d7df07ef84fd8556a6ef0d03b5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FlN_GWgeqjUEQtP0AoVmjw.png"/></div></div></figure><p id="b993" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在调度action方法之前，触发方法之前的<em class="ll">。自然地，它具有突变前的状态。</em></p><p id="05ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在调度action方法后，触发方法后的<em class="ll">。变异方法是同步的，从动作方法内部提交。因此，</em>法之后的<em class="ll">也是在变异法背后触发的。因此，它具有后突变状态。</em></p><p id="935a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果订阅的动作方法查询后端API，那么在查询开始之前会触发<em class="ll"> before </em>方法。查询结束后会触发<em class="ll"> after </em>方法。我们可以使用这两种方法来打开和关闭加载通知。</p><h1 id="5eab" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">VueX组合API</h1><p id="e742" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">在本节中，我们将向您介绍如何在设置功能中使用VueX。</p><p id="7d34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">挑战在于如何在设置功能中访问VueX商店。组件实例尚未创建。所以<em class="ll">这个。$store </em>在这里行不通。</p><p id="7ae7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们声明一个名为store的变量。我们使用<em class="ll"> createStore </em>方法设置它的值。现在，我们可以在设置功能中访问VueX商店。useStore方法将搜索已安装的VueX存储并返回它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qi"><img src="../Images/ba1bb457e195da51710457a17302c836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtW_nRcc1idHe-Mq1MMkqw.png"/></div></div></figure><p id="6576" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想将num和title状态添加到组件实例中。</p><p id="5e4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在setUp函数中，我们返回一个对象。在返回的对象中，我们添加了一个数字属性，并使用<em class="ll">计算的</em>方法设置其值。我们设置了一个getter函数，并在其中返回<em class="ll">存储点状态点号</em>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qj"><img src="../Images/26dc7cb05f1a9e75885249aabe8e9455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-gXRHf594OaFsNv7bWMjA.png"/></div></div></figure><p id="b7ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意这里，数字状态属性本身不会被添加到组件实例中。返回对象中的number属性实际上是数字状态的getter。</p><p id="8a22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们改变<em class="ll"> number </em>状态时，返回的number属性也会随之改变。这就是为什么我们选择计算方法而不是参考T21方法。</p><p id="447f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至于<em class="ll"> title </em>属性，我们可以使用<em class="ll"> ref </em>方法设置它的值，因为我们不想改变<em class="ll"> title </em>状态。如果不需要反应性，您甚至可以跳过<em class="ll">参考</em>方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qk"><img src="../Images/3afd841cc1366ea9a132dc42b9b5169a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUAbU8PzQsO5CcejphT7WA.png"/></div></div></figure><p id="6474" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仔细想想，返回对象中的<em class="ll">号</em>和<em class="ll">标题</em>属性，不过是VueX状态属性的外壳。</p><p id="d421" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了将突变和动作方法添加到组件实例中，我们使用相同的策略:为它们创建外壳。</p><p id="2030" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为<em class="ll"> numberUp </em>突变方法定义了一个shell方法。我们把它命名为<em class="ll"> shellNumUp </em>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ql"><img src="../Images/9a7b8cf3b31bc05dca34a8157a349fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfm0vmKd5IFctoZrXyKjdQ.png"/></div></div></figure><p id="310f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了向组件实例添加一个动作方法，我们仍然创建一个shell方法。shell方法调度目标操作。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi qm"><img src="../Images/0e13a853047d2cb94b4dae76a5d517fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfh2EiiHqHbv9U-PKsQ9EA.png"/></div></div></figure><p id="0cf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，setUp函数可以很容易地将VueX状态和方法添加到组件实例中。我们只需要把它们放在返回的对象中。不再需要任何映射方法。</p><p id="1cbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于状态和getters，我们在computed方法中返回它们。</p><p id="ef2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于突变和动作，我们为它们创建一个shell方法。外壳方法的唯一工作是提交或分派目标方法。</p><h2 id="70d6" class="qn md it bd me qo qp dn mi qq qr dp mm kb qs qt mq kf qu qv mu kj qw qx my qy bi translated">[未完待续……]</h2></div></div>    
</body>
</html>