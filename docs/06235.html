<html>
<head>
<title>Learning Python: Tuples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Python:元组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-python-tuples-b1972bcb8570?source=collection_archive---------8-----------------------#2020-11-05">https://levelup.gitconnected.com/learning-python-tuples-b1972bcb8570?source=collection_archive---------8-----------------------#2020-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/74c6d429bccd7603c0c7e576cf24f53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*12vj1LYPMnVxXFQ0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="629d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">元组是最不为人知和最难理解的数据结构之一，但是当列表或字典不太正确时，元组在某些情况下会很有用。在本文中，我将讨论什么是元组以及如何在Python中使用它们。</p><h1 id="f8b2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义和创建的元组</h1><p id="db32" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">元组(发音为“too-ple”或“tuh-ple”)是一个逗号分隔的值列表。当您希望在一个对象中存储相关信息时，可以使用元组。例如，您可以在一个元组中存储学生的姓名和他们在一次测试中的成绩。这比在列表中存储这样的数据更有意义，因为通常列表的元素都具有相同的数据类型。您还可以将这些数据存储在一个字典中，将学生姓名作为键，将成绩列表作为值，但是检索单个成绩比使用元组要困难得多。</p><p id="48c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">元组的另一个有趣的用途是用于执行值交换，我们将在文章的最后看看它是如何工作的。</p><p id="56c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">元组最重要的特征是它们是不可变的。这意味着如果不重新分配完整的元组，就不能改变元组中的一个或多个元素，就像处理字符串一样。</p><p id="c044" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">元组是通过向变量分配逗号分隔的列表来创建的。这里有一个例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8efb" class="mq lf it mm b gy mr ms l mt mu">letters = 'a', 'b', 'c', 'd','e'</span></pre><p id="274a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为这看起来很奇怪，更常见的是将元组创建为括号内的列表，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bff7" class="mq lf it mm b gy mr ms l mt mu">letters = ('a', 'b', 'c', 'd','e')</span></pre><p id="4600" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过使用元组变量作为参数调用type函数来验证对象是否为元组:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ad25" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; letters = ('a','b','c','d','e')<br/>&gt;&gt;&gt; letters<br/>('a', 'b', 'c', 'd', 'e')<br/>&gt;&gt;&gt; print(type(letters))<br/>&lt;class 'tuple'&gt;</span></pre><p id="30c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，请注意，仅将单个值放在括号中并不能使其成为元组:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="59ab" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; notTuple = ('z')<br/>&gt;&gt;&gt; print(type(notTuple))<br/>&lt;class 'str'&gt;</span></pre><p id="477b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多添加一个值确实会使对象成为元组:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9794" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; aTuple = ('y','z')<br/>&gt;&gt;&gt; print(type(aTuple))<br/>&lt;class 'tuple'&gt;</span></pre><p id="b533" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以用<code class="fe mv mw mx mm b">tuple</code>函数创建一个元组。下面是一个创建空元组的示例:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5b27" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; newTuple = tuple()<br/>&gt;&gt;&gt; print(type(newTuple))<br/>&lt;class 'tuple'&gt;</span></pre><p id="1ba6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mv mw mx mm b">tuple</code>函数，您可以从单个字符序列(比如一个字符串)创建一个元组。例如:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="24a0" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; wordTuple = tuple("hello")<br/>&gt;&gt;&gt; print(type(wordTuple))<br/>&lt;class 'tuple'&gt;</span></pre><p id="b767" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，对象<code class="fe mv mw mx mm b">wordTuple</code>将保存一个字符串而不是一个元组。</p><h1 id="7881" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用元组</h1><p id="a685" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以使用索引来访问元组值，如下例所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="26aa" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; letters = ('a','b','c','d','e')<br/>&gt;&gt;&gt; print(letters[0], letters[1])<br/>a b</span></pre><p id="32bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">切片操作符也可以工作:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="849e" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; letters<br/>('a', 'b', 'c', 'd', 'e')<br/>&gt;&gt;&gt; print(letters[2:4])<br/>('c', 'd')</span></pre><p id="727b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用关系运算符来比较元组。Python将基于所使用的关系运算符进行逐个元素的比较。例如:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e5b0" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; grades1 = (91, 88, 84)<br/>&gt;&gt;&gt; grades2 = (91, 89, 84)<br/>|&gt;&gt;&gt; grades1 &gt; grades2<br/>False<br/>&gt;&gt;&gt; grades1 &lt; grades2<br/>True</span></pre><p id="73be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二元组大于第一元组，因为第二元素<code class="fe mv mw mx mm b">grades2</code>89大于第二元素<code class="fe mv mw mx mm b">grades1</code>88。</p><p id="ddca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">元组可以是函数的返回值。这很有趣，因为函数只能返回一个值。当您需要从一个函数返回两个或多个值时，您可以将这些值放入一个元组中并返回该元组。</p><p id="1b8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有两个例子。第一个示例返回数字列表中的最大值和最小值:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="224e" class="mq lf it mm b gy mr ms l mt mu">from random import seed<br/>from random import randint</span><span id="a3d9" class="mq lf it mm b gy my ms l mt mu">def minMax(lyst):<br/>  return max(lyst), min(lyst)</span><span id="5861" class="mq lf it mm b gy my ms l mt mu">numbers = []<br/>for i in range(1, 11):<br/>  numbers.append(randint(1,100))<br/>print(numbers)<br/>print("Max/min values:",minMax(numbers))</span></pre><p id="1c91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bb34" class="mq lf it mm b gy mr ms l mt mu">[24, 72, 57, 83, 38, 52, 32, 37, 19, 45]<br/>Max/min values: (83, 19)</span></pre><h1 id="5205" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用元组作为变长函数参数</h1><p id="38d1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通过使用<code class="fe mv mw mx mm b">*</code>操作符，您可以编写一个接受可变数量参数的函数。这个操作符收集了一个函数的所有参数，并将它们放入一个元组中。然后可以迭代元组来访问参数。</p><p id="cd85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个示例，它实现了一个对不同数量的参数求和的函数。函数定义使用了<code class="fe mv mw mx mm b">len</code>函数，它作用于元组就像作用于列表和字典一样。下面是函数定义和一个测试程序:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5174" class="mq lf it mm b gy mr ms l mt mu">def sum(*numlist):<br/>  total = 0<br/>  for i in range(0, len(numlist)):<br/>    total += numlist[i]<br/>  return total</span><span id="3f0d" class="mq lf it mm b gy my ms l mt mu">print(sum(1,2,3))<br/>print(sum(1,2,3,4,5))<br/>print(sum(1,2,3,4,5,6,7,8,9,10))</span></pre><h1 id="72e3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">元组、列表和zip函数</h1><p id="35b1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">zip</code>函数获取两个列表，并通过将每个列表的连续元素放在一起形成一个元组来构建一组元组。例如，如果一个列表是<code class="fe mv mw mx mm b">[“Jones”,”Smith”]</code>，另一个列表是<code class="fe mv mw mx mm b">[88, 81]</code>，那么得到的元组是<code class="fe mv mw mx mm b">((“Jones”, 88), (“Smith”, 81))</code>。</p><p id="4718" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是说明该示例的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a793" class="mq lf it mm b gy mr ms l mt mu">names = ["Jones","Smith"]<br/>grades = [88,81]<br/>roster = zip(names, grades)<br/>for student in roster:<br/>  print(student)</span></pre><p id="21eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9634" class="mq lf it mm b gy mr ms l mt mu">('Jones', 88)<br/>('Smith', 81)</span></pre><h1 id="a38e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">元组、字典和项目方法</h1><p id="dc99" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">items</code>方法将字典中的键/值对作为元组序列返回。例如:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9bc6" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; grades = {'Smith':88, 'Jones':81, 'Brown':90}<br/>&gt;&gt;&gt; print(grades.items())<br/>dict_items([('Smith', 88), ('Jones', 81), ('Brown', 90)])</span></pre><p id="a05d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用它来遍历字典，并在遍历过程中打印键/值对:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c93e" class="mq lf it mm b gy mr ms l mt mu">&gt;&gt;&gt; grades<br/>{'Smith': 88, 'Jones': 81, 'Brown': 90}<br/>&gt;&gt;&gt; for student,grade in grades.items():<br/>...   print(student,":",grade)<br/>...<br/>Smith : 88<br/>Jones : 81<br/>Brown : 90</span></pre><h1 id="20c8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用元组交换变量值</h1><p id="ddad" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">交换两个变量的值通常涉及到第三个变量。下面的程序演示了这一点:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1462" class="mq lf it mm b gy mr ms l mt mu">a = 1<br/>b = 2<br/>print("a:",a,"b:",b)<br/>temp = a<br/>a = b<br/>b = temp<br/>print("a:",a,"b:",b)</span></pre><p id="62c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="43e3" class="mq lf it mm b gy mr ms l mt mu">a: 1 b: 2<br/>a: 2 b: 1</span></pre><p id="9f66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用元组，您可以在不需要临时变量的情况下完成同样的事情。您可以通过创建元组<code class="fe mv mw mx mm b">(b,a)</code>并将其分配给元组<code class="fe mv mw mx mm b">(a,b)</code>来实现这一点。这个程序是这样的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="480b" class="mq lf it mm b gy mr ms l mt mu">a = 1<br/>b = 2<br/>print("a:",a,"b:",b)<br/>a,b = b,a<br/>print("a:",a,"b:",b)</span></pre><h1 id="0f00" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">排序和反转元组</h1><p id="43b9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">内置函数<code class="fe mv mw mx mm b">sort</code>和<code class="fe mv mw mx mm b">reverse</code>不处理元组，但是还有另外两个函数<code class="fe mv mw mx mm b">sorted</code>和<code class="fe mv mw mx mm b">reversed</code>处理元组，尽管这两个函数都将排序或反转的元组作为列表返回。</p><p id="32fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从排序一个元组开始。下面是一个程序，它构建一个由十个元素组成的随机数元组，然后使用<code class="fe mv mw mx mm b">sorted</code>函数将该元组按升序排序:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6fbc" class="mq lf it mm b gy mr ms l mt mu">from random import seed<br/>from random import randint</span><span id="c6df" class="mq lf it mm b gy my ms l mt mu">numbers = []<br/>for i in range(1,11):<br/>  numbers.append(randint(1,100))<br/>nums = tuple(numbers)<br/>print(nums)<br/>sortedNums = sorted(nums)<br/>print(sortedNums)</span></pre><p id="2ae4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5eea" class="mq lf it mm b gy mr ms l mt mu">(39, 74, 11, 95, 51, 47, 53, 19, 100, 89)<br/>[11, 19, 39, 47, 51, 53, 74, 89, 95, 100]</span></pre><p id="06fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，假设我们希望看到降序排列的元组。我们可以通过使用<code class="fe mv mw mx mm b">reversed</code>函数反转元素的顺序来实现。这个函数返回一个迭代器，允许以相反的顺序访问给定的序列。在调用函数之后，你还需要将对象转换成一个列表，以便于访问。</p><p id="24e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是前面的程序，最后添加了对<code class="fe mv mw mx mm b">reversed </code>函数的调用:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f1ff" class="mq lf it mm b gy mr ms l mt mu">from random import seed<br/>from random import randint</span><span id="9b31" class="mq lf it mm b gy my ms l mt mu">numbers = []<br/>for i in range(1,11):<br/>  numbers.append(randint(1,100))<br/>nums = tuple(numbers)<br/>print(nums)<br/>sortedNums = sorted(nums)<br/>print(sortedNums)<br/>numsSorted = tuple(sortedNums)<br/>nums = tuple(numsSorted)<br/>descNums = list(reversed(nums))<br/>print(descNums)</span></pre><p id="4eb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="028d" class="mq lf it mm b gy mr ms l mt mu">(77, 53, 48, 98, 15, 41, 93, 100, 75, 15)<br/>[15, 15, 41, 48, 53, 75, 77, 93, 98, 100]<br/>[100, 98, 93, 77, 75, 53, 48, 41, 15, 15]</span></pre><p id="84b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我对元组的讨论到此为止。元组不是Python中最常用的数据结构，但是对于交换变量和变长函数参数之类的东西有一些明确的用途。</p><p id="a30e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您以前从未使用过元组，请尝试一下，看看它们如何简化您的Python程序。</p><p id="75d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请将您的意见和建议发邮件至mmmcmillan1@att.net<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">给我。</a></p></div></div>    
</body>
</html>