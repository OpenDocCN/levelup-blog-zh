<html>
<head>
<title>Design Patterns: Top 5 Techniques for Implementing Fault Tolerance in Distributed Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:在分布式系统中实现容错的5大技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-top-5-techniques-for-implementing-fault-tolerance-in-distributed-systems-81bef4408c3b?source=collection_archive---------2-----------------------#2021-06-09">https://levelup.gitconnected.com/design-patterns-top-5-techniques-for-implementing-fault-tolerance-in-distributed-systems-81bef4408c3b?source=collection_archive---------2-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3ae0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">思想建筑师</h2><div class=""/><div class=""><h2 id="96ac" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使系统能够在某些模块出现故障时继续正常运行</h2></div><p id="00d8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在过去的四十年中，许多监控和容错技术得到了发展、应用和改进，为系统架构设计中反复出现的问题提供了通用解决方案。在本文中，我将重点介绍在与其他模块通信时应该使用的技术，以使您的模块在分布式系统中具有容错和监控能力。</p><h1 id="a08b" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">什么是分布式系统？</h1><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/aee4cd8ebd6fdd58efbdb3bd91708224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dmf9AjPmMR90gaMPwa4DuA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">分布式的计算机系统</figcaption></figure><p id="41e8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">分布式系统是这样一种系统，其组件位于不同的联网计算机上，这些计算机通过从任何系统相互传递消息来进行通信并协调它们的动作。</p><h1 id="55e3" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">容错</h1><p id="d59d" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">这是分布式系统中的一个重要术语。它是系统在部分故障的情况下继续运行的能力，但整体性能可能会受到影响。</p><p id="2649" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">由于分布式系统由各种组件组成，开发一个接近百分之百容错的系统实际上是非常具有挑战性的。</p><h2 id="8cff" class="na lo it bd lp nb nc dn lt nd ne dp lx la nf ng lz le nh ni mb li nj nk md iz bi translated">系统失败的原因</h2><p id="6e6a" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">故障的发生主要有以下两个原因。</p><ul class=""><li id="fcab" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><strong class="kt jd"> <em class="nu">节点故障:</em> </strong>硬件或软件故障。</li><li id="d5f5" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><strong class="kt jd"> <em class="nu">恶意错误:</em> </strong>非授权访问导致。</li></ul><blockquote class="oa"><p id="84e7" class="ob oc it bd od oe of og oh oi oj lm dk translated">当一个系统不能实现它的承诺时，这个系统就失败了。</p></blockquote><h2 id="8af9" class="na lo it bd lp nb ok dn lt nd ol dp lx la om ng lz le on ni mb li oo nk md iz bi translated">为什么我们在分布式系统中需要容错？</h2><p id="41bc" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">在分布式系统中使用容错，我们可以获得如下质量优势。</p><ul class=""><li id="c592" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><strong class="kt jd"><em class="nu"/></strong>:关注没有任何中断的连续服务。</li><li id="1c83" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><strong class="kt jd"> <em class="nu">可用性</em> </strong>:关注系统的读取准备情况。</li><li id="80ae" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><strong class="kt jd"> <em class="nu">安全</em> </strong>:防止任何未经授权的访问。</li></ul><blockquote class="oa"><p id="beb4" class="ob oc it bd od oe of og oh oi oj lm dk translated">在分布式系统中，一台你甚至不知道存在的计算机的故障会使你自己的计算机变得不可用。</p></blockquote><p id="778b" class="pw-post-body-paragraph kr ks it kt b ku op kd kw kx oq kg kz la or lc ld le os lg lh li ot lk ll lm im bi translated">失败是难以避免的，所以拥抱它们吧！！！</p><h1 id="6429" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">如何实现—容错模式？</h1><p id="9b7e" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">容错技术有三个方面，分为错误检测、错误恢复和错误屏蔽。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/cbe34ea7d66419f82679f8b5f1aba0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9Ivgyk4OwzEZV_RaCgLuA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">容错的阶段</figcaption></figure><ul class=""><li id="949f" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><strong class="kt jd"> <em class="nu">错误检测:</em> </strong> <code class="fe ou ov ow ox b">Acknowledgement</code>、【你还活着吗】、<code class="fe ou ov ow ox b">Circuit Breaker</code>、故障停止处理器、“我还活着”。</li><li id="930c" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><strong class="kt jd"> <em class="nu">错误恢复:</em> </strong>备份，<code class="fe ou ov ow ox b">Roll Forward</code>和<code class="fe ou ov ow ox b">Roll Back</code>。</li><li id="9641" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><strong class="kt jd"> <em class="nu">错误屏蔽</em> </strong> : <code class="fe ou ov ow ox b">Active Replication</code>，半主动复制，半被动复制，被动复制复制。</li></ul><p id="3e5d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有许多模式，但我们将只关注在实践中普遍应用的重要模式。</p><h2 id="ac00" class="na lo it bd lp nb nc dn lt nd ne dp lx la nf ng lz le nh ni mb li nj nk md iz bi translated">确认</h2><p id="d2ea" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">其思想是通过在指定的时间间隔内确认接收到输入来检测系统中的错误。</p><p id="d679" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">背景和问题</strong></p><p id="3a0e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">确认模式适用于被监控系统和监控系统之间的交互频率可能在已知时间内变化很大的系统。</p><ul class=""><li id="5f4e" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">最小化由检测技术引入的时间开销。</li><li id="6865" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">减少被监控系统和监控系统之间的通信。</li></ul><p id="407b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">解决方案</strong></p><p id="b2db" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">其思想是通过在指定的时间间隔内确认输入的接收来检测系统中的错误。</p><p id="a512" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">结构</strong></p><p id="dd32" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在确认模式中，<code class="fe ou ov ow ox b">Sender</code>与<code class="fe ou ov ow ox b">Timer</code>共同构成<strong class="kt jd">监控系统</strong>，而<code class="fe ou ov ow ox b">Receiver</code>与<code class="fe ou ov ow ox b">Acknowledger</code>实体共同构成<strong class="kt jd">被监控系统</strong>。</p><ul class=""><li id="f37f" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">Sender</code>单独负责联系<strong class="kt jd">被监控系统</strong>。</li><li id="1363" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">每当<code class="fe ou ov ow ox b">Sender</code>向<code class="fe ou ov ow ox b">Receiver</code>发送输入时，负责在每次向<strong class="kt jd">监控系统</strong>提供输入时倒计时超时时间的<code class="fe ou ov ow ox b">Timer</code>被激活。</li><li id="99e8" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">在收到<code class="fe ou ov ow ox b">Sender</code>的输入后，<code class="fe ou ov ow ox b">Receiver</code>通知<code class="fe ou ov ow ox b">Acknowledger</code>。然后<code class="fe ou ov ow ox b">Acknowledger</code>负责向<code class="fe ou ov ow ox b">Timer</code>发送接收到输入的确认。如果<code class="fe ou ov ow ox b">Timer</code>的超时时间连续N次没有收到<strong class="kt jd">监控系统</strong>的确认，则<code class="fe ou ov ow ox b">Timer</code>检测到<strong class="kt jd">监控系统</strong>出错并通知<code class="fe ou ov ow ox b">Sender</code>。</li></ul><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/69cb6fba347134c2a5f0af4ad5142dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWRuvOVRZWdpgf6DC5tiJw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">确认模式的4个组成部分</figcaption></figure><p id="9f77" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">后果</strong></p><p id="2060" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">确认模式具有以下优点:</p><ul class=""><li id="62ea" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">引入的设计复杂度非常低。</li><li id="c3d2" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">不会引入任何空间开销。</li></ul><p id="881c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是确认模式也有一些缺点:</p><ul class=""><li id="004f" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">不提供容忍系统故障的方法。相反，它提供了检测错误的方法。</li><li id="e5ce" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">它引入了相对较高的空间开销，这与它可以处理的并发错误数成正比</li></ul><h2 id="43f2" class="na lo it bd lp nb nc dn lt nd ne dp lx la nf ng lz le nh ni mb li nj nk md iz bi translated">断路器模式</h2><p id="f1bd" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">如果你以任何方式熟悉保险丝在你家的配电板中的工作方式，你就会理解断路器模式的原理。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/a37bce2f60d8a41f3ddcc556a281d8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lT0-M4zXvD4tYsvjqmyvZQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">保险丝的工作方式</figcaption></figure><p id="54d9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">背景与问题</strong></p><p id="e45c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如何防止网络或组件故障蔓延到其他组件？</p><p id="129a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">解决方案</strong></p><p id="90d9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">“<code class="fe ou ov ow ox b">Circuit Breaker</code>”模式提出的上述问题的解决方案是基于</p><p id="53e7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">结构</strong></p><p id="5868" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">断路器有三种不同的状态，<code class="fe ou ov ow ox b">closed</code>、<code class="fe ou ov ow ox b">open</code>和<code class="fe ou ov ow ox b">half-open</code>。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/106f06b006f549bdec4f36205d694b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnAAdoa_fb-_ndXnYn41xQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">断路器的整个生命周期</figcaption></figure><ul class=""><li id="b65d" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><strong class="kt jd">关闭状态:</strong>关闭状态是默认的“一切正常”状态。请求可以自由通过。当某些故障发生时，它们会导致电路断开，闭合移动打开。</li><li id="a558" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><strong class="kt jd">打开状态:</strong>打开状态在固定时间内拒绝所有请求，而不尝试发送它们。一旦断路器跳闸，它就进入断开状态。此时，对该服务的任何请求都将自动失败。</li><li id="d4e6" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><strong class="kt jd">半开状态:</strong>断路器允许一定数量的请求通过，以测试资源的状态。半开状态决定电路是返回闭合还是打开。</li></ul><p id="89cb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">用例</strong></p><p id="9b9c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们使用这种模式来防止应用程序试图调用远程服务或访问共享资源，如果这种操作很可能失败的话。</p><p id="5c55" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是对于以下两个用例，不推荐使用这种模式。</p><ul class=""><li id="aef3" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">用于处理对应用程序中本地私有资源的访问，如内存中的数据结构。在这种环境下，使用断路器会增加系统开销。</li><li id="c607" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">作为在应用程序的业务逻辑中处理异常的替代。</li></ul><p id="be2f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">它在实践中是如何使用的？</strong></p><p id="dbc5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">断路器模式有三种不同的实现方法:客户端断路器、服务器端断路器和代理断路器。</p><p id="7119" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Hystrix库提供了断路器最著名的实现之一，它允许将Java代码包装在一个由断路器控制的过程中。</p><p id="d75d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">后果</strong></p><p id="eabf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">断路器模式需要额外的请求和响应，以便在每次通信之前执行某种握手。</p><h2 id="9cc6" class="na lo it bd lp nb nc dn lt nd ne dp lx la nf ng lz le nh ni mb li nj nk md iz bi translated">向前滚动</h2><p id="5e56" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">一旦我们检测到一个错误，系统必须从错误中恢复，以符合容错标准。</p><p id="e87e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">背景和问题</strong></p><p id="e6f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当可检测到错误并且系统能够保存其当前状态并加载新的state⁴.时，我们应用这种模式</p><p id="01fe" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">解决方案</strong></p><p id="c8fa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">前滚模式通过使用检查点将组件恢复到错误或故障事件发生前的稳定状态，避免了工作丢失。</p><p id="7fac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">结构</strong></p><p id="1586" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">前滚模式由以下元素组成。</p><ul class=""><li id="69bc" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">replicas</code>是原始系统的复制版本，每个副本都能够导出它们的状态，并根据请求导入新的状态。每个副本还必须映射到不同的故障单元。</li><li id="d224" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">manager</code>，负责接收所有针对容错系统的输入，并将其转发给相应的<code class="fe ou ov ow ox b">replica</code>。在没有错误的情况下，<code class="fe ou ov ow ox b">manager</code>触发从处理最新输入的<code class="fe ou ov ow ox b">replica</code>到保持先前无错误状态的另一个<code class="fe ou ov ow ox b">replicas</code>的新状态的复制。</li><li id="d984" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">manager</code>还依靠错误检测机制来检测<code class="fe ou ov ow ox b">replicas</code>上可能出现的错误。当一个<code class="fe ou ov ow ox b">replica</code>出现这样的错误时，<code class="fe ou ov ow ox b">manager</code>负责丢弃那个<code class="fe ou ov ow ox b">replica</code>。</li><li id="659a" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">manager</code>必须映射到与任何<code class="fe ou ov ow ox b">replicas</code>不同的故障单元。</li></ul><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/cd733e1a48f221651dd8109e332b6bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVb_Li4lHHvgdROCbAe_fA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">前滚模式的结构</figcaption></figure><p id="5801" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">后果</strong></p><p id="28b0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这种模式的设计复杂度和时间开销相对较低，但是这种模式也有以下一些缺点。</p><ul class=""><li id="b1ff" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">空间开销相对较高，并且整个系统被复制。</li><li id="3e2b" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">没有错误时的时间开销很高，因为在当前副本能够接收和处理新输入之前，它必须将其新状态复制到另一个副本。</li></ul><h2 id="c98d" class="na lo it bd lp nb nc dn lt nd ne dp lx la nf ng lz le nh ni mb li nj nk md iz bi translated">击退</h2><p id="ee46" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">这种模式是使用系统副本从错误发生中恢复的另一种技术。它具有与前滚机制相似的功能；但是，如果出现故障，一个复制副本将回滚到上一个无错误状态。</p><p id="964f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">背景和问题</strong></p><p id="e579" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当可以检测到错误并且系统能够保存其当前状态并加载新状态时，我们应用这种模式。</p><p id="ff22" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">此模式通过最小化无错误系统执行的时间开销，并确保在错误发生后恢复的无错误状态尽可能接近失败副本的上一个无错误状态，解决了从错误中恢复的问题。</p><p id="e67e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">解决方案</strong></p><p id="21ac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">解决上述问题的基础是使用系统的两个副本和一个存储器来保存检查点。</p><p id="d77d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">结构</strong></p><p id="3f3f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">回滚模式由以下元素组成。</p><ul class=""><li id="24a8" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">replicas</code>，它们是彼此相同的原始系统的副本，并被监控错误。</li><li id="9458" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">storage</code>，用于存储包含处理输入的<code class="fe ou ov ow ox b">replica</code>在某个时刻输出的状态的<code class="fe ou ov ow ox b">checkpoints</code>。</li><li id="115d" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">replicas</code>可以以如下方式替换<code class="fe ou ov ow ox b">storage</code>:当检查点被创建时，每个<code class="fe ou ov ow ox b">replica</code>将它们导出到另一个<code class="fe ou ov ow ox b">replicas</code>，并从它们那里导入这些<code class="fe ou ov ow ox b">replicas</code>创建的检查点。</li></ul><blockquote class="oa"><p id="4892" class="ob oc it bd od oe of og oh oi oj lm dk translated">请记住，如果使用存储，那么它一定不能出错。</p></blockquote><figure class="oy oz pa pb pc mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/02c59fce9987f2c7f9c5b821852304be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mAmOapwOo6qMaNY6R8Rtg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">回滚模式的结构</figcaption></figure><ul class=""><li id="d02b" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">manager</code>负责接收容错系统的所有输入，并将其转发给相应的<code class="fe ou ov ow ox b">replica</code>。</li><li id="4147" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">在没有错误的情况下，<code class="fe ou ov ow ox b">manager</code>触发从处理最后输入的<code class="fe ou ov ow ox b">replica</code>到<code class="fe ou ov ow ox b">storage</code>的新状态的拷贝。</li><li id="6b58" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">manager</code>还依靠错误检测机制来检测<code class="fe ou ov ow ox b">replicas</code>上可能出现的错误。当一个<code class="fe ou ov ow ox b">replica</code>出现这样的错误时，<code class="fe ou ov ow ox b">manager</code>负责丢弃那个<code class="fe ou ov ow ox b">replica</code>。必须将<code class="fe ou ov ow ox b">manager</code>映射到不同于<code class="fe ou ov ow ox b">replicas</code>的故障单元。</li></ul><p id="fc68" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">后果</strong></p><p id="6f11" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这种模式的优点和缺点与前滚模式一样。</p><h2 id="aa09" class="na lo it bd lp nb nc dn lt nd ne dp lx la nf ng lz le nh ni mb li nj nk md iz bi translated"><strong class="ak">主动复制模式</strong></h2><p id="6c4c" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">主动复制模式是从错误检测到错误屏蔽的故障停止Processor⁵模式的增强。</p><p id="1e08" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">背景和问题</strong></p><p id="71e4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">确定性的应用程序或关键系统，它们可能会遇到与接收到的输入无关的错误。系统应该能够经历可能导致故障的错误。</p><p id="7574" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如何屏蔽系统中的错误以避免系统故障。一些应用，特别是航空和卫生保健系统，需要屏蔽错误，以避免可能导致错误的系统故障。</p><p id="88e8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">解决方案</strong></p><p id="9523" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个问题的解决方案受以下因素的影响:</p><ul class=""><li id="5b40" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">系统接收到的输入必须被处理并提供指定的输出，而与系统是否发生错误无关。</li><li id="54de" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">系统的无错执行必须遭受最小的时间损失。</li><li id="9b82" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">存在错误时由解决方案引入的时间损失必须保持非常低。</li><li id="6b7b" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">系统必须是确定性的。</li></ul><p id="26ce" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将使用一组处理器，这些处理器接收相同的输入和交付订单，并独立地、同时地对它们的输入进行处理。来自每个处理器的输出将被比较，并且正确的输出将被选择并传送到系统。</p><p id="fa6d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">结构</strong></p><p id="00d0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">主动复制模式引入的实体如下。</p><ul class=""><li id="2b11" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><strong class="kt jd"> </strong> <code class="fe ou ov ow ox b">Sender</code>将输入发送给分配器，而不是直接发送给系统。</li><li id="8e94" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">Distributor</code>初始化所有处理器，并将相同的输入传递给各个处理器进行处理。</li><li id="e845" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">Processor 1, Processor 2 and Processor 3</code> <strong class="kt jd"> </strong>从分发器接收输入，每个分发器对输入执行相同的操作，但是它们是独立执行的。</li><li id="2438" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">当所有三个处理器完成对输入的处理时，它们将输出传送到<code class="fe ou ov ow ox b">Comparator</code>。<code class="fe ou ov ow ox b">Comparator</code> <strong class="kt jd"> </strong>接收三路输出上<code class="fe ou ov ow ox b">Processors</code>和<code class="fe ou ov ow ox b">compares</code>的输出(如多数表决)。它选择一个输出并丢弃不提供输出或不正确输出的<code class="fe ou ov ow ox b">processor</code>,即与它选择的正确输出不同的输出。</li><li id="6413" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated"><code class="fe ou ov ow ox b">Comparator</code>向系统提供正确的输出。系统代表从<code class="fe ou ov ow ox b">comparator</code>获得正确输出的受保护应用或环境。</li></ul><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/07958aeef726928677ec29eb02e05b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3n39gYqkqMZEVMN_4kqwQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">活动复制模式的结构</figcaption></figure><p id="a48d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">后果</strong></p><p id="2c23" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">主动复制模式具有以下优点。</p><ul class=""><li id="04f0" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">这种模式在无错误系统执行中引入的时间开销很低。在存在错误的情况下，这种模式引入的时间开销也很低。</li><li id="55c4" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">设计复杂度相对较低。</li></ul><p id="b88b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">主动复制模式有以下缺点。</p><ul class=""><li id="7c8d" class="nl nm it kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">这种模式的空间开销非常高，需要2N+1个副本来屏蔽N个错误。</li><li id="3bb5" class="nl nm it kt b ku nv kx nw la nx le ny li nz lm nq nr ns nt bi translated">分配器和比较器也是系统中的单点故障。</li></ul><h1 id="4c5f" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">结论</h1><p id="9ea0" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">总结本文，我们可以说创建容错系统的目标是防止单点故障引起的中断，确保关键任务应用程序或系统的高可用性。这有助于业务进展顺利。</p><p id="be54" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">很简单，对吧？</p><h1 id="9da5" class="ln lo it bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">参考</h1><p id="dac4" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">[1]塔嫩鲍姆，安德鲁s；Steen，Maarten van (2002年)。<a class="ae pd" href="https://www.distributed-systems.net/index.php/books/ds3/" rel="noopener ugc nofollow" target="_blank"> <em class="nu">分布式系统:原理与范例</em> </a>。新泽西州上萨德尔河:皮尔逊·普伦蒂斯霍尔。<a class="ae pd" href="https://en.wikipedia.org/wiki/ISBN_(identifier)" rel="noopener ugc nofollow" target="_blank">ISBN</a><a class="ae pd" href="https://en.wikipedia.org/wiki/Special:BookSources/0-13-088893-1" rel="noopener ugc nofollow" target="_blank">0–13–088893–1</a>。</p><p id="2a76" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[2] I. A. Buckley和E.B. Fernandez，“容错的三种模式”，Procs。2009年10月26日。</p><p id="9c76" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae pd" href="https://github.com/Netflix/Hystrix" rel="noopener ugc nofollow" target="_blank">https://github.com/Netflix/Hystrix</a></p><p id="f52a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[4] Saurabh Hukerikar，Christian Engelmann，高性能计算弹性的基于模式的建模。橡树岭国家实验室。</p><p id="cda3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[5]施耐德，弗雷德。(2001).故障停止处理器方法。</p></div></div>    
</body>
</html>