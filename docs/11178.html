<html>
<head>
<title>What is Composite and Builder Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是复合和生成器设计模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-composite-and-builder-design-pattern-8b2b60783e0?source=collection_archive---------12-----------------------#2022-02-22">https://levelup.gitconnected.com/what-is-composite-and-builder-design-pattern-8b2b60783e0?source=collection_archive---------12-----------------------#2022-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06a4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们用树来理解这两种模式。</h2></div><p id="619f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复合模式提供了一种处理树形结构的方法。换句话说，具有父/子关系的数据结构。比如JSON，HTML，XML等等。</p><p id="50b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在。NET framework中，XElement是使用复合设计模式开发的。这种模式非常重要，甚至微软也在使用它。</p><p id="b8ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件系统就是一个真实的例子。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/65df942de2e8315a90fbac776e3e9833.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*xC523kN1_QTeCs_mCQOE_w.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图1:文件系统</figcaption></figure><p id="a896" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在上面的图像中看到的，该目录可以包含多个目录或文件。但是，文件不能包含更多的文件或目录，因为它们被视为<strong class="kh ir">叶节点</strong>。</p><p id="9226" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复合模式使客户机能够以统一的方式与单个对象或对象的组合进行交互。<strong class="kh ir">(作文遵循“有关系”)</strong></p><p id="8bb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复合模式不仅仅是对树形结构建模，更重要的是，使客户端能够统一地对这些树形结构进行操作。让我们通过我们的文件结构例子来理解这意味着什么。如果我想得到一个单独的文件的大小，那么我可以在这些单独的文件上使用一个方法来给我它的大小，作为回报，我将得到文件的字节数。但是如果我想知道整个目录的大小，比如说我想从图1中得到目录Blog的大小。我只需要在目录博客上调用一个方法，作为一个消费者，我不想担心通过内部逻辑得到目录博客的总大小。</p><p id="bec8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">从概念上来说，这就是复合模式的用途，无论我是想在粒度级别还是单个叶节点上操作。复合模式将使我们能够统一处理所有这些问题。</strong></p><p id="037f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看一下概念图。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/63933b280db4446e3843e9f29a8a6880.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*jl0OiAqxJj6vRKqxzWA48g.jpeg"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">复合设计模式的概念图</figcaption></figure><h1 id="d55e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">说够了！！</h1><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="bc0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从添加一个组件类开始。这个类本质上是抽象的，因为它依赖于实际的对象来实现它的梦想。我们需要一个抽象的方法来获取文件或目录的大小。</p><p id="7248" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清单1:一个组件类</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mi mh l"/></div></figure><h2 id="a410" class="mj lp iq bd lq mk ml dn lu mm mn dp ly ko mo mp ma ks mq mr mc kw ms mt me mu bi translated">下一个！</h2><p id="41ef" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我们需要照顾叶节点。在我们的例子中，文件是叶节点。因此，为文件节点创建一个类，它将实现我们在清单1中创建的抽象类。</p><p id="93ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清单2:类FileItem</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mi mh l"/></div></figure><h2 id="002c" class="mj lp iq bd lq mk ml dn lu mm mn dp ly ko mo mp ma ks mq mr mc kw ms mt me mu bi translated">继续前进，</h2><p id="7d18" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我们拥有的另一个组件是目录。让我们遵循同样的规则，即实现我们在清单1中创建的抽象类。</p><p id="4aed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清单3:类目录</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mi mh l"/></div></figure><h2 id="91ed" class="mj lp iq bd lq mk ml dn lu mm mn dp ly ko mo mp ma ks mq mr mc kw ms mt me mu bi translated">最后，</h2><p id="bfbe" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我们的客户端类也称为调用者类，它将利用这种模式。</p><p id="560f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清单4:类程序</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mi mh l"/></div></figure><p id="34bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在运行你的程序并检查输出…</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5be04edff664c50b6cdba7bbe0c08ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*PFvd-yMvPh4ZKFLcNCIDRg.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">输出</figcaption></figure><h2 id="36bf" class="mj lp iq bd lq mk ml dn lu mm mn dp ly ko mo mp ma ks mq mr mc kw ms mt me mu bi translated">它完美地工作。</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nb mh l"/></div></figure><p id="7b6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切都很顺利，甚至迈克尔也在庆祝。</p><h2 id="2829" class="mj lp iq bd lq mk ml dn lu mm mn dp ly ko mo mp ma ks mq mr mc kw ms mt me mu bi translated">除了一件事！！</h2><p id="ff1a" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">调用者类相当混乱</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nc mh l"/></div></figure><p id="d19f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在没有适当顺序的情况下添加文件，加上每次我们必须初始化一个目录或文件，我们必须使用一个新的关键字，这看起来相当混乱。</p><p id="08ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以做的是在中间添加一个构建器类。以下是设计构建器模式的方法。你可以在这里详细了解<a class="ae nd" href="https://medium.com/@RikamPalkar/builder-design-pattern-e0cd6b439bdd" rel="noopener"> Builder设计模式</a><a class="ae nd" href="https://medium.com/@RikamPalkar/builder-design-pattern-e0cd6b439bdd" rel="noopener">。</a></p><p id="afb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清单5:类FileSystemBuilder</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mi mh l"/></div></figure><p id="fc71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，请注意，在我们的方法SetCurrentDirectory()中。我们不执行递归来搜索目录，因为如果目录足够大，这不是最佳解决方案。相反，我们使用了基于堆栈的迭代解决方案。</p><p id="c33d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不知道栈是什么？别担心，我帮你搞定了，阅读<a class="ae nd" href="https://medium.com/@RikamPalkar/builder-design-pattern-e0cd6b439bdd" rel="noopener">这篇</a>文章。</p><p id="0a78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在看看我们的调用类是什么样子的:</p><p id="2b47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清单6:类程序</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mi mh l"/></div></figure><p id="37aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将以JSON格式显示该对象，以查看其树状结构。</p><p id="0e7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当您运行此应用程序时，您将获得以下输出:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/f0bb5fc20e014ff4340c70befc40ce77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P15GX84gnzFAcLHoLGh_tw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">最终输出</figcaption></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj mh l"/></div></figure><h2 id="684c" class="mj lp iq bd lq mk ml dn lu mm mn dp ly ko mo mp ma ks mq mr mc kw ms mt me mu bi translated">这才是你该做的。</h2><p id="4808" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">先从概念上理解，那么实现起来就容易了。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="fc08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我真诚地希望您喜欢这篇文章，并希望您受到启发，将所学知识应用到自己的应用程序中。谢谢你。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="08d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯，里卡姆！</p><p id="555e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Linkedin上找到我！！</p><div class="nr ns gp gr nt nu"><a href="https://www.linkedin.com/in/rikampalkar/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">Rikam Palkar -软件工程师-小天鹅-威德福| LinkedIn</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">通过编写可伸缩的代码让世界变得更美好。我从来没有在大学里发现我对编码的热情，也没有在…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.linkedin.com</p></div></div><div class="od l"><div class="oe l of og oh od oi lh nu"/></div></div></a></div><h1 id="5116" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">编码快乐！</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oj"><img src="../Images/d01b53d0edd46bf80f9943c7ea52b6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1ItS5NM19WSXlxqe"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">照片由<a class="ae nd" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>在<a class="ae nd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div></div>    
</body>
</html>