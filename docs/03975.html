<html>
<head>
<title>How to write a Tetris Bot in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python写一个俄罗斯方块机器人</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tetris-ai-in-python-bd194d6326ae?source=collection_archive---------5-----------------------#2020-06-04">https://levelup.gitconnected.com/tetris-ai-in-python-bd194d6326ae?source=collection_archive---------5-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="37af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有机器学习的俄罗斯方块人工智能</p><p id="eafd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之前用Python写了一个小的<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/writing-tetris-in-python-2a16bddb5318">俄罗斯方块游戏</a>。由于我自己懒得玩，就给它写个人工智能小程序吧。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h2 id="6e4b" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated">创建一个俄罗斯方块人工智能模块</h2><p id="e76f" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">首先，我们创建一个名为<code class="fe lu lv lw lx b">tetris_ai.py</code>的新文件，其内容如下:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="8f8c" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">import </strong>pygame<br/><br/><br/><strong class="lx iu">class </strong>Event():<br/>    type = <strong class="lx iu">None<br/>    </strong>key = <strong class="lx iu">None<br/><br/>    def </strong>__init__(self, type, key):<br/>        self.type = type<br/>        self.key = key<br/><br/><br/>counter = 0<br/><strong class="lx iu">def </strong>run_ai():<br/>    <strong class="lx iu">global </strong>counter<br/>    counter += 1<br/>    <strong class="lx iu">if </strong>counter &lt; 3:<br/>        <strong class="lx iu">return </strong>[]<br/>    counter = 0<br/>    e = Event(pygame.KEYDOWN, pygame.K_UP)<br/>    <strong class="lx iu">return </strong>[e]</span></pre><p id="e113" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很简单:目前，每第三次(为了减慢AI的速度)它会返回一个<code class="fe lu lv lw lx b">pygame.K_UP</code>键，所以这个数字会旋转。现在还没有别的。</p><p id="c516" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，我们应该从我们的游戏中读出这个:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="bf22" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">import </strong>tetris_ai</span></pre><p id="917d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并替换为以下代码行:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="33b9" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">for </strong>event <strong class="lx iu">in </strong>pygame.event.get():</span></pre><p id="f54a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="d864" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">for </strong>event <strong class="lx iu">in </strong>list(pygame.event.get()) + tetris_ai.run_ai():</span></pre><p id="4e69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这之后，AI所做的就是一直旋转图形，这里没有什么有趣的东西可看:</p><figure class="ly lz ma mb gt ml gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/3a3aa3559189a5ea553fde1f317e708e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*A_TCXErVYAwnCx8ElIy-Ug.gif"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">总是旋转人工智能</figcaption></figure></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h2 id="72d1" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated">将需要的参数传递给AI</h2><p id="5a63" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">我们需要什么来做决定？我们需要游戏场地、它的尺寸和当前的数字:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="183d" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">for </strong>event <strong class="lx iu">in </strong>list(pygame.event.get()) + tetris_ai.run_ai(<br/>        game.field, game.figure, game.width, game.height<br/>):</span></pre><p id="08d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="6a29" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">def </strong>run_ai(game_field, game_figure, game_width, game_height):</span></pre><p id="60f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们有希望做出正确的决定。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h2 id="c030" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated">“人工智能”</h2><p id="95cc" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">我们习惯于只将运行Tensorflow或至少某种线性回归的东西称为“人工智能”。</p><p id="5397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你是为了这些现代技术之类的东西而来，你会失望的，因为我正打算用一个双for-loop来代替所有的监督机器学习算法，因为我懒得教它。</p><p id="5d7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">算法是这样的:</p><ul class=""><li id="4226" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">对于每个图形旋转和每个水平位置，模拟“空格键”并检查我们的新塔的高度和“洞”的数量。</li><li id="9f16" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">选择最好的一个，然后</li><li id="1711" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">如果旋转不一致，按“向上”键</li><li id="4d3a" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">按“左”或“右”键移动到相应的位置。</li><li id="fe09" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">如果位置正确，请按空格键。</li></ul></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h2 id="6655" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated">代码</h2><p id="a28c" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">我们已经到了必须实际编写一些代码的阶段。我在这里也很懒，但是我知道这段代码可以节省我玩俄罗斯方块的时间，所以我们就这么做吧。</p><p id="0a87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从现在开始，我们只在<code class="fe lu lv lw lx b">tetris_ai.py</code>写代码。</p><p id="9f01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">先从复制游戏中的<code class="fe lu lv lw lx b">intersects</code>函数开始，模拟“旋转-位置”组合:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="4101" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">def </strong>intersects(game_field, x, y, game_width, game_height, game_figure_image):<br/>    intersection = <strong class="lx iu">False<br/>    for </strong>i <strong class="lx iu">in </strong>range(4):<br/>        <strong class="lx iu">for </strong>j <strong class="lx iu">in </strong>range(4):<br/>            <strong class="lx iu">if </strong>i * 4 + j <strong class="lx iu">in </strong>game_figure_image:<br/>                <strong class="lx iu">if </strong>i + y &gt; game_height - 1 <strong class="lx iu">or </strong>\<br/>                        j + x &gt; game_width - 1 <strong class="lx iu">or </strong>\<br/>                        j + x &lt; 0 <strong class="lx iu">or </strong>\<br/>                        game_field[i + y][j + x] &gt; 0:<br/>                    intersection = <strong class="lx iu">True<br/>    return </strong>intersection</span><span id="a485" class="kw kx it lx b gy ng mh l mi mj"><strong class="lx iu">def </strong>simulate(game_field, x, y, game_width, game_height, game_figure_image):<br/>    <strong class="lx iu">while not </strong>intersects(game_field, x, y, game_width, game_height, game_figure_image):<br/>        y += 1<br/>    y -= 1<br/><br/>    height = game_height<br/>    holes = 0<br/>    filled = []<br/>    <strong class="lx iu">for </strong>i <strong class="lx iu">in </strong>range(game_height-1, -1, -1):<br/>        <strong class="lx iu">for </strong>j <strong class="lx iu">in </strong>range(game_width):<br/>            u = <strong class="lx iu">'_'<br/>            if </strong>game_field[i][j] != 0:<br/>                u = <strong class="lx iu">"x"<br/>            for </strong>ii <strong class="lx iu">in </strong>range(4):<br/>                <strong class="lx iu">for </strong>jj <strong class="lx iu">in </strong>range(4):<br/>                    <strong class="lx iu">if </strong>ii * 4 + jj <strong class="lx iu">in </strong>game_figure_image:<br/>                        <strong class="lx iu">if </strong>jj + x == j <strong class="lx iu">and </strong>ii + y == i:<br/>                            u = <strong class="lx iu">"x"<br/><br/>            if </strong>u == <strong class="lx iu">"x" and </strong>i &lt; height:<br/>                height = i<br/>            <strong class="lx iu">if </strong>u == <strong class="lx iu">"x"</strong>:<br/>                filled.append((i, j))<br/>                <strong class="lx iu">for </strong>k <strong class="lx iu">in </strong>range(i, game_height):<br/>                    <strong class="lx iu">if </strong>(k, j) <strong class="lx iu">not in </strong>filled:<br/>                        holes += 1<br/>                        filled.append((k,j))<br/><br/>    <strong class="lx iu">return </strong>holes, game_height-height</span></pre><p id="4b4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，如果图形在位置<code class="fe lu lv lw lx b">x,y</code>并且有旋转图像<code class="fe lu lv lw lx b">game_figure_image</code>，我们计算孔的数量和塔的高度。</p><p id="a630" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们通过每个位置和旋转，并模拟它。在旅途中，我们找到最佳的位置-旋转组合。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="023b" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">def </strong>best_rotation_position(game_field, game_figure, game_width, game_height):<br/>    best_height = game_height<br/>    best_holes = game_height*game_width<br/>    best_position = <strong class="lx iu">None<br/>    </strong>best_rotation = <strong class="lx iu">None<br/><br/>    for </strong>rotation <strong class="lx iu">in </strong>range(len(game_figure.figures[game_figure.type])):<br/>        fig = game_figure.figures[game_figure.type][rotation]<br/>        <strong class="lx iu">for </strong>j <strong class="lx iu">in </strong>range(-3, game_width):<br/>            <strong class="lx iu">if not </strong>intersects(<br/>                    game_field,<br/>                    j,<br/>                    0,<br/>                    game_width,<br/>                    game_height,<br/>                    fig):<br/>                holes, height = simulate(<br/>                    game_field,<br/>                    j,<br/>                    0,<br/>                    game_width,<br/>                    game_height,<br/>                    fig<br/>                )<br/>                <strong class="lx iu">if </strong>best_position <strong class="lx iu">is None or </strong>best_holes &gt; holes <strong class="lx iu">or </strong>\<br/>                    best_holes == holes <strong class="lx iu">and </strong>best_height &gt; height:<br/>                    best_height = height<br/>                    best_holes = holes<br/>                    best_position = j<br/>                    best_rotation = rotation<br/>    <strong class="lx iu">return </strong>best_rotation, best_position</span></pre><p id="9172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在主函数中应用它:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="71df" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">def </strong>run_ai(game_field, game_figure, game_width, game_height):<br/>    <strong class="lx iu">global </strong>counter<br/>    counter += 1<br/>    <strong class="lx iu">if </strong>counter &lt; 3:<br/>        <strong class="lx iu">return </strong>[]<br/>    counter = 0<br/>    rotation, position = best_rotation_position(game_field, game_figure, game_width, game_height)<br/>    <strong class="lx iu">if </strong>game_figure.rotation != rotation:<br/>        e = Event(pygame.KEYDOWN, pygame.K_UP)<br/>    <strong class="lx iu">elif </strong>game_figure.x &lt; position:<br/>        e = Event(pygame.KEYDOWN, pygame.K_RIGHT)<br/>    <strong class="lx iu">elif </strong>game_figure.x &gt; position:<br/>        e = Event(pygame.KEYDOWN, pygame.K_LEFT)<br/>    <strong class="lx iu">else</strong>:<br/>        e = Event(pygame.KEYDOWN, pygame.K_SPACE)<br/>    <strong class="lx iu">return </strong>[e]</span></pre><p id="f095" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们检查旋转是否是最好的，如果不是，就旋转。然后我们检查位置是否是最好的，如果不是，移动。如果一切正常，就放弃吧！</p><p id="1ff1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看我们有什么:</p><figure class="ly lz ma mb gt ml gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/3be870fedf2ae83739b7a0b5a21fc103.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*NG5hmQGpLz-8cWaJIelrEA.gif"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">“线”应该向右:(</figcaption></figure><p id="3eb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，如果“线”的数字会去的权利，这将是更好的，但我们从来没有检查，如果一些线在这里被填满…所以，让我们这样做。</p><p id="b305" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们更改模拟函数:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="6012" class="kw kx it lx b gy mg mh l mi mj"><strong class="lx iu">def </strong>simulate(game_field, x, y, game_width, game_height, game_figure_image):<br/>    <strong class="lx iu">while not </strong>intersects(game_field, x, y, game_width, game_height, game_figure_image):<br/>        y += 1<br/>    y -= 1<br/><br/>    height = game_height<br/>    holes = 0<br/>    filled = []<br/>    breaks = 0<br/>    <strong class="lx iu">for </strong>i <strong class="lx iu">in </strong>range(game_height-1, -1, -1):<br/>        it_is_full = <strong class="lx iu">True<br/>        </strong>prev_holes = holes<br/>        <strong class="lx iu">for </strong>j <strong class="lx iu">in </strong>range(game_width):<br/>            u = <strong class="lx iu">'_'<br/>            if </strong>game_field[i][j] != 0:<br/>                u = <strong class="lx iu">"x"<br/>            for </strong>ii <strong class="lx iu">in </strong>range(4):<br/>                <strong class="lx iu">for </strong>jj <strong class="lx iu">in </strong>range(4):<br/>                    <strong class="lx iu">if </strong>ii * 4 + jj <strong class="lx iu">in </strong>game_figure_image:<br/>                        <strong class="lx iu">if </strong>jj + x == j <strong class="lx iu">and </strong>ii + y == i:<br/>                            u = <strong class="lx iu">"x"<br/><br/>            if </strong>u == <strong class="lx iu">"x" and </strong>i &lt; height:<br/>                height = i<br/>            <strong class="lx iu">if </strong>u == <strong class="lx iu">"x"</strong>:<br/>                filled.append((i, j))<br/>                <strong class="lx iu">for </strong>k <strong class="lx iu">in </strong>range(i, game_height):<br/>                    <strong class="lx iu">if </strong>(k, j) <strong class="lx iu">not in </strong>filled:<br/>                        holes += 1<br/>                        filled.append((k,j))<br/>            <strong class="lx iu">else</strong>:<br/>                it_is_full = <strong class="lx iu">False<br/>        if </strong>it_is_full:<br/>            breaks += 1<br/>            holes = prev_holes<br/><br/>    <strong class="lx iu">return </strong>holes, game_height-height-breaks</span></pre><p id="6e13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，结果真的很好:</p><figure class="ly lz ma mb gt ml gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d10f9034459a4367307ece68875c8b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*K2v4QmzdnybZCDCU2ceZZA.gif"/></div></figure><p id="307c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢它！</p></div></div>    
</body>
</html>