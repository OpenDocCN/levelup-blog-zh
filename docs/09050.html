<html>
<head>
<title>My Top React Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我最常反应的面试问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-top-react-interview-questions-c31b95a60471?source=collection_archive---------2-----------------------#2021-06-30">https://levelup.gitconnected.com/my-top-react-interview-questions-c31b95a60471?source=collection_archive---------2-----------------------#2021-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0c8671267941cea3e09aa6e025143baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6xkgoSIFnnXtCw06.jpg"/></div></div></figure><p id="c6d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章总结了一系列我会问应聘者的问题，也是我在面试中经常被问到的问题。</p><h1 id="5d7f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">1.什么是反应？</h1><p id="5664" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>是一个“用于构建用户界面的JavaScript库”,由脸书于2011年开发。</p><p id="9513" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是MVC(模型-视图-控制器)中的V，所以它是一个开源的UI库，而不是一个框架。</p><h1 id="6c71" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">2.React的优势是什么？</h1><ul class=""><li id="2630" class="ma mb iq ka b kb lu kf lv kj mc kn md kr me kv mf mg mh mi bi translated">良好表现:由于VDOM，见<a class="ae lz" href="https://mokkapps.de/blog/my-top-react-interview-questions/#7-what-is-the-virtual-dom" rel="noopener ugc nofollow" target="_blank"> #17 </a>。</li><li id="8e4f" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">简单易学:有了基本的JavaScript知识，你就可以开始构建应用程序了。像Angular这样的框架需要更多关于其他技术和模式的知识，比如RxJS、TypeScript和依赖注入。</li><li id="8ff3" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">单向数据流:这种流也称为“父到子”或“从上到下”,可以防止错误并方便调试。</li><li id="90cb" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">可重用组件:在代码的其他部分甚至在不同的项目中重用React组件只需很少或不需要修改。</li><li id="0dc2" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">巨大的社区:该社区提供了大量可用于构建React应用程序的库。</li><li id="0284" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">很受开发者欢迎。</li></ul><h1 id="59d0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">3.React的缺点是什么？</h1><ul class=""><li id="9c2e" class="ma mb iq ka b kb lu kf lv kj mc kn md kr me kv mf mg mh mi bi translated">由于React只提供了MVC模型的视图部分，所以在你的项目中你还会依赖其他技术。因此，每个React项目可能看起来非常不同。</li><li id="8a47" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">有些人认为JSX太难把握，太复杂。</li><li id="7ec7" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">React及其库的文档通常很差。</li></ul><h1 id="4c6c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">4.什么是JSX？</h1><p id="8bea" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">JSX (JavaScript XML)允许我们在JavaScript中编写HTML。<a class="ae lz" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>将其描述为“JavaScript的语法扩展”。</p><p id="c9f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React推荐使用JSX，但是也有可能根本不使用JSX 来创建应用<a class="ae lz" href="https://reactjs.org/docs/react-without-jsx.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4bf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个简单的JSX例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c71e" class="mx kx iq mt b gy my mz l na nb">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span></pre><h1 id="d9f9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">5.如何在组件之间传递数据？</h1><ol class=""><li id="0146" class="ma mb iq ka b kb lu kf lv kj mc kn md kr me kv nc mg mh mi bi translated">使用props将数据从父节点传递到子节点。</li><li id="6e44" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nc mg mh mi bi translated">使用回调将数据从子节点传递到父节点。</li><li id="925a" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nc mg mh mi bi translated">使用以下任一方法在同级之间传递数据:</li></ol><ul class=""><li id="cc5c" class="ma mb iq ka b kb kc kf kg kj nd kn ne kr nf kv mf mg mh mi bi translated">综合上述方法。</li><li id="b2c1" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">使用<a class="ae lz" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。</li><li id="19c1" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">利用<a class="ae lz" href="https://reactjs.org/docs/context.html#api" rel="noopener ugc nofollow" target="_blank"> React的上下文API </a>。</li></ul><h1 id="07dc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">6.功能组件和类组件有什么区别？</h1><p id="917d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>在React 16.8中引入。在以前的版本中，功能组件被称为无状态组件，不提供与类组件相同的功能(例如，访问状态)。钩子使功能组件具有与类组件相同的特性。没有从React中移除类组件的计划。</p><p id="adc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们来看看它们的区别:</p><h1 id="a483" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">声明和道具</h1><h2 id="6824" class="mx kx iq bd ky ng nh dn lc ni nj dp lg kj nk nl lk kn nm nn lo kr no np ls nq bi translated">功能成分</h2><p id="2825" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">功能组件是JavaScript函数，因此可以使用arrow函数或<code class="fe nr ns nt mt b">function</code>关键字来声明。Props是简单的函数参数，可以直接在JSX内部使用:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b168" class="mx kx iq mt b gy my mz l na nb">const Card = (props) =&gt; {<br/> return(<br/> 	&lt;h2&gt;Title: {props.title}&lt;/h2&gt;<br/> )<br/>}<br/><br/>function Card(props){<br/> return(<br/>	&lt;h2&gt;Title: {props.title}&lt;/h2&gt;<br/> )<br/>}</span></pre><h2 id="c7bd" class="mx kx iq bd ky ng nh dn lc ni nj dp lg kj nk nl lk kn nm nn lo kr no np ls nq bi translated">类别组件</h2><p id="39a6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用ES6 <code class="fe nr ns nt mt b">class</code>关键字声明类组件。需要使用<code class="fe nr ns nt mt b">this</code>关键字来访问道具:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d557" class="mx kx iq mt b gy my mz l na nb">class Card extends React.Component{<br/> constructor(props){<br/>   super(props);<br/> }<br/><br/> render(){<br/>   return(<br/>	&lt;h2&gt;Title: {this.props.title}&lt;/h2&gt;<br/>   )<br/> }<br/>}</span></pre><h1 id="8d3c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">处理状态</h1><h2 id="b5dd" class="mx kx iq bd ky ng nh dn lc ni nj dp lg kj nk nl lk kn nm nn lo kr no np ls nq bi translated">功能组件</h2><p id="0b25" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在功能组件中，我们需要使用<code class="fe nr ns nt mt b">useState</code>钩子来处理状态:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="036d" class="mx kx iq mt b gy my mz l na nb">const Counter = (props) =&gt; {<br/>	const [counter, setCounter] = useState(0);<br/>	<br/>	const increment = () =&gt; {<br/>		setCounter(++counter);<br/>	}<br/>	<br/>	return (<br/>		&lt;div&gt;<br/>			&lt;p&gt;Count: {counter}&lt;/p&gt;<br/>			&lt;button onClick={increment}&gt;Increment Counter&lt;/button&gt;<br/>		&lt;/div&gt;<br/>	)<br/>}</span></pre><h2 id="aec5" class="mx kx iq bd ky ng nh dn lc ni nj dp lg kj nk nl lk kn nm nn lo kr no np ls nq bi translated">类别组件</h2><p id="0a34" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在类组件中不能使用React钩子，因此在类组件中状态处理是不同的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c427" class="mx kx iq mt b gy my mz l na nb">class Counter extends React.Component {<br/>	constructor(props){<br/>    	super(props);<br/>        this.state = {counter : 0};<br/>        this.increment = this.increment.bind(this);<br/>    }<br/>	<br/>	increment {<br/>		this.setState((prevState) =&gt; {<br/>			return {counter: prevState.counter++};<br/>		});<br/>	}<br/>	<br/>	render() {<br/>	return (<br/>			&lt;div&gt;<br/>			&lt;p&gt;Count: {this.state.counter}&lt;/p&gt;<br/>			&lt;button onClick={this.increment}&gt;Increment Counter&lt;/button&gt;<br/>		&lt;/div&gt;<br/>		)<br/>	}<br/>}</span></pre><h1 id="04ed" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">7.什么是虚拟DOM？</h1><p id="eb9c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虚拟DOM (VDOM) 是一个轻量级的JavaScript对象，它包含了真实DOM的副本。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/266dfed4922732fe664d3f5b97750910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1GHh2GIZrjW1Efg1PRkFA.png"/></div></div></figure><h1 id="f121" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">8.影子DOM和虚拟DOM一样吗？</h1><p id="57ae" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">不，他们是不同的。</p><p id="e2a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">影子DOM是一种浏览器技术，主要用于在web组件中定义变量和CSS。</p><p id="dcfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虚拟DOM是一个由浏览器API之上的JavaScript库实现的概念。</p><h1 id="e277" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">9.什么是“反应纤维”？</h1><p id="7756" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">纤程是React 16中新的协调引擎。</p><p id="e110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的主要特点是增量渲染:能够将渲染工作分成块，并分散到多个帧上。</p><p id="89ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://github.com/acdlite/react-fiber-architecture" rel="noopener ugc nofollow" target="_blank">阅读更多</a>。</p><h1 id="5674" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">10.状态和道具有什么区别？</h1><p id="91a4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">道具和状态都是普通的JavaScript对象。</p><p id="a8f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">props(properties的缩写)是由父组件传递给组件的任意输入的对象。</p><p id="d22d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">状态是由组件初始化和管理的变量，并且在该组件的特定实例的生存期内发生变化。</p><p id="d411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kent C. Dodds的这篇文章提供了更详细的解释。</p><h1 id="0922" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">11.受控组件和非受控组件有什么区别？</h1><p id="b21d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">受控React组件中输入元素的值由React控制。</p><p id="b4da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不受控制的React组件中输入元素的值由DOM控制。</p><h1 id="e28b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">12.受控组件和非受控组件有什么区别？</h1><p id="7d11" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">React类组件提供了这些生命周期方法:</p><ul class=""><li id="4290" class="ma mb iq ka b kb kc kf kg kj nd kn ne kr nf kv mf mg mh mi bi translated"><code class="fe nr ns nt mt b">componentDidMount()</code>:组件输出渲染到DOM后运行。</li><li id="0532" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><code class="fe nr ns nt mt b">componentDidUpdate()</code>:更新发生后立即运行。</li><li id="ac56" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><code class="fe nr ns nt mt b">componentWillUnmount()</code>:在组件从DOM中卸载后运行，用于清理内存空间。</li></ul><p id="a9d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一些其他<a class="ae lz" href="https://reactjs.org/docs/react-component.html#rarely-used-lifecycle-methods" rel="noopener ugc nofollow" target="_blank">很少使用的</a>和<a class="ae lz" href="https://reactjs.org/docs/react-component.html#legacy-lifecycle-methods" rel="noopener ugc nofollow" target="_blank">遗留的</a>生命周期方法。</p><p id="c2a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">钩子用在功能组件中，而不是上面提到的生命周期方法。效果挂钩<code class="fe nr ns nt mt b">useEffect</code>增加了例如执行副作用的能力，并提供与<code class="fe nr ns nt mt b">componentDidMount</code>、<code class="fe nr ns nt mt b">componentDidUpdate</code>和<code class="fe nr ns nt mt b">componentWillUnmount</code>相同的功能。</p><h1 id="7ab4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">13.如何提高React应用的性能？</h1><ul class=""><li id="9962" class="ma mb iq ka b kb lu kf lv kj mc kn md kr me kv mf mg mh mi bi translated">使用<a class="ae lz" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank">反应。PureComponent </a>是一个类似<code class="fe nr ns nt mt b">React.Component</code>的基类，但是在某些情况下，如果它的<code class="fe nr ns nt mt b">render()</code>函数在给定相同的属性和状态的情况下呈现相同的结果，它会提供性能提升。</li><li id="a681" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">使用<a class="ae lz" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> useMemo钩子</a>来记忆在每次渲染时执行昂贵计算的函数。只有当其中一个依赖项(传递给钩子)发生变化时，它才会重新计算内存化的值。</li><li id="ce7e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">状态托管是将状态移至您需要的位置的过程。一些React应用程序在其父组件中有许多不必要的状态，这使得代码更难维护，并导致许多不必要的重新呈现。<a class="ae lz" href="https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster" rel="noopener ugc nofollow" target="_blank">本文</a>提供了关于状态托管的详细解释。</li><li id="4071" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">延迟加载组件以减少应用程序的加载时间。反应<a class="ae lz" href="https://reactjs.org/docs/react-api.html#suspense" rel="noopener ugc nofollow" target="_blank">暂停</a>可以用来延迟加载组件。</li></ul><h1 id="93f8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">14.React中的键是什么？</h1><p id="d68f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">React需要键来识别哪些元素被更改、添加或删除。数组中的每一项都需要有一个提供稳定标识的键。</p><p id="3ab9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果项的顺序可能改变，不建议对键使用索引，因为这会对性能产生负面影响，并可能导致状态问题。如果没有为列表项指定显式键，React将使用索引作为键。</p><p id="3bba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看罗宾·波科尔尼的文章，深入了解使用指数作为关键字的负面影响。如果你有兴趣了解更多，这里有另一个<a class="ae lz" href="https://reactjs.org/docs/reconciliation.html#recursing-on-children" rel="noopener ugc nofollow" target="_blank">关于为什么钥匙是必要的</a>的深入解释。</p><h1 id="5da2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">15.什么是高阶元件？</h1><p id="d2f9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://reactjs.org/docs/higher-order-components.html#use-hocs-for-cross-cutting-concerns" rel="noopener ugc nofollow" target="_blank">高阶分量(HOC) </a>是取一个分量并返回一个新分量的函数。</p><p id="8189" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们是React中重用组件逻辑的高级技术，本质上它们不是React API的一部分。它们是从React的组合性质中显现出来的一种模式:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="099d" class="mx kx iq mt b gy my mz l na nb">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span></pre><p id="5bc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个组件将props转换成UI，而一个更高级的组件将一个组件转换成另一个组件。</p><h1 id="0668" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">16.什么是误差边界？</h1><p id="0de0" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">React 16引入了“错误边界”的新概念。</p><p id="56e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://reactjs.org/docs/error-boundaries.html#gatsby-focus-wrapper" rel="noopener ugc nofollow" target="_blank">错误边界</a>是React组件，它捕捉子组件树中任何地方的JavaScript错误，记录这些错误，并显示一个回退UI，而不是崩溃的组件树。错误边界在渲染期间、在生命周期方法中以及在它们下面的整个树的构造函数中捕捉错误。</p><h1 id="2354" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">17.为什么要引入钩子？</h1><ul class=""><li id="3901" class="ma mb iq ka b kb lu kf lv kj mc kn md kr me kv mf mg mh mi bi translated">钩子允许你在不改变组件层次结构的情况下重用有状态逻辑。</li><li id="744f" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">钩子允许您根据相关的部分将一个组件分成更小的功能(比如设置订阅或获取数据)。</li><li id="6a95" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">钩子让你不用类就可以使用更多的React特性。</li><li id="fd51" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">它消除了在类组件中处理关键字<code class="fe nr ns nt mt b">this</code>的复杂性。</li></ul><p id="00c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://reactjs.org/docs/hooks-intro.html#motivation" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p><h1 id="50dd" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">18.useEffect钩子的用途是什么？</h1><p id="c83a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">效果挂钩</a>让我们在功能组件中执行副作用。它帮助我们避免在一个类组件的不同生命周期方法中出现冗余代码。它有助于对相关代码进行分组。</p><h1 id="d0ab" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">19.React中的合成事件是什么？</h1><p id="8bd2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank"> SyntheticEvent </a>是围绕浏览器本地事件的跨浏览器包装器。它与浏览器的本地事件具有相同的API，包括<code class="fe nr ns nt mt b">stopPropagation()</code>和` preventDefault()，除了这些事件在所有浏览器中的工作方式相同。</p><h1 id="ad3a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">20.参考文献有什么用？</h1><p id="eefa" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个<a class="ae lz" href="https://reactjs.org/docs/glossary.html#refs" rel="noopener ugc nofollow" target="_blank"> Ref </a>是一个可以附加到任何组件的特殊属性。它可以是由<code class="fe nr ns nt mt b">React.createRef()</code>创建的对象、回调函数或字符串(在遗留API中)。</p><p id="9a1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要直接访问DOM元素或组件实例，可以使用ref属性作为回调函数。该函数接收底层DOM元素或类实例(取决于元素的类型)作为其参数。</p><p id="3c19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在大多数情况下，引用应该少用。</p><h1 id="cf52" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="4ac8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我希望这份React面试问题清单能帮助你获得下一个React职位。如果你知道任何其他重要的面试问题，请给我留言。</p><p id="a440" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请在Twitter上关注我，从我这里获得关于新博客文章和更多内容的通知。</p><p id="b744" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在寻找更多的面试问题，你应该看看这个<a class="ae lz" href="https://github.com/sudheerj/reactjs-interview-questions" rel="noopener ugc nofollow" target="_blank">500个面试问题的列表&amp;答案</a>。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="0fe9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="oc">原发布于</em><a class="ae lz" href="https://www.mokkapps.de/blog/my-top-react-interview-questions" rel="noopener ugc nofollow" target="_blank"><em class="oc">https://www . mokkapps . de</em></a><em class="oc">。</em></p></div></div>    
</body>
</html>