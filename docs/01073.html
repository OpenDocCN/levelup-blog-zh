<html>
<head>
<title>Using Classes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-classes-in-javascript-e677d248bb6e?source=collection_archive---------0-----------------------#2019-11-05">https://levelup.gitconnected.com/using-classes-in-javascript-e677d248bb6e?source=collection_archive---------0-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3ffe0e1eaaf50374cff207b22c22c65a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rZDk8rie-gEHwOMQ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@shemul?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特·谢穆尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4cb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的类是其原型继承模型的特殊语法，它是基于类的面向对象语言中的类似继承。类只是添加到ES6中的特殊函数，用来模仿其他语言中的关键字<code class="fe le lf lg lh b">class</code>。在JavaScript中，我们可以有<code class="fe le lf lg lh b">class</code>声明和<code class="fe le lf lg lh b">class</code>表达式，因为它们只是函数。所以像所有其他函数一样，有函数声明和函数表达式。</p><p id="1b36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类充当创建新对象的模板。</p><p id="0fa9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">需要记住的最重要的事情:</strong>类只是普通的JavaScript函数，不使用<code class="fe le lf lg lh b">class</code>语法也可以完全复制。它是ES6中添加的特殊语法糖，使声明和继承复杂对象变得更容易。</p><h1 id="ea68" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">定义类别</h1><p id="2842" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">要声明一个类，我们使用<code class="fe le lf lg lh b">class</code>关键字。例如，要声明一个简单的类，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8660" class="mt lj it lh b gy mu mv l mw mx">class Person{<br/>  constructor(firstName, lastName) {<br/>    this.firstName= firstName;<br/>    this.lastName = lastName;<br/>  }<br/>}</span></pre><p id="5490" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类声明没有被提升，所以在代码中定义之前不能使用，因为JavaScript解释器不会自动将它们提升到顶部。因此，在代码中定义之前，上面的类不会工作，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b963" class="mt lj it lh b gy mu mv l mw mx">const person = new Person('John', 'Smith');</span><span id="d5ba" class="mt lj it lh b gy my mv l mw mx">class Person{<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>}</span></pre><p id="e28d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们将得到一个<code class="fe le lf lg lh b">ReferenceError</code>。</p><p id="172a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以通过一个类表达式来定义一个类，这是另一种语法。它们可以是命名的，也可以是未命名的。我们也可以像处理函数一样，给变量分配一个类。如果我们这样做了，我们可以通过它的名字来引用这个类。例如，我们可以定义:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3a7d" class="mt lj it lh b gy mu mv l mw mx">let Person = class {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>}</span></pre><p id="a50e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要获得上面未命名的类的名称，我们可以用<code class="fe le lf lg lh b">name</code>属性获得名称，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2e51" class="mt lj it lh b gy mu mv l mw mx">console.log(Person.name);</span></pre><p id="a1df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以定义一个命名类，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b48b" class="mt lj it lh b gy mu mv l mw mx">let Person = class Person2 {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>}</span></pre><p id="a8d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后为了获得类名，我们可以再次使用<code class="fe le lf lg lh b">name</code>属性。所以我们如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2494" class="mt lj it lh b gy mu mv l mw mx">console.log(<!-- -->Person.name)</span></pre><p id="779c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">Person2</code>日志。</p><p id="fa46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类体是用花括号定义的。我们在括号内定义类成员。类的主体是在严格模式下执行的，所以在严格模式下定义的所有东西都适用于类的定义，所以我们不能像<code class="fe le lf lg lh b">var</code>、<code class="fe le lf lg lh b">let</code>或<code class="fe le lf lg lh b">const</code>那样定义前面没有关键字的变量，还有很多其他规则在你定义类的时候也适用。</p><p id="3d08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的类也有一个<code class="fe le lf lg lh b">constructor</code>方法，让我们在用<code class="fe le lf lg lh b">class</code>实例化对象时设置字段。每个类中只能有一个<code class="fe le lf lg lh b">constructor</code>方法。如果不止一个，那么就会抛出<code class="fe le lf lg lh b">SyntaxError</code>。如果类扩展了父类，那么<code class="fe le lf lg lh b">constructor</code>也可以调用<code class="fe le lf lg lh b">super</code>方法来调用超类的<code class="fe le lf lg lh b">constructor</code>。</p><p id="3ce9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">未声明的方法<code class="fe le lf lg lh b">static</code>构成了该类的原型方法。在使用<code class="fe le lf lg lh b">new</code>关键字创建一个对象后，它们被调用。例如，下面的类只有原型方法:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="269f" class="mt lj it lh b gy mu mv l mw mx">class Person{<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }</span><span id="ebd4" class="mt lj it lh b gy my mv l mw mx">  get fullName(){<br/>    return `${this.firstName} ${this.lastName}`  <br/>  }</span><span id="6b03" class="mt lj it lh b gy my mv l mw mx">  sayHi(){<br/>    return `Hi, <!-- -->${this.firstName} ${this.lastName}<!-- -->`<br/>  }<br/>}</span></pre><p id="32fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的<code class="fe le lf lg lh b">Person</code>类中，<code class="fe le lf lg lh b">fullName</code>和<code class="fe le lf lg lh b">sayHi</code>是原型方法。它们被这样称呼:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f2c0" class="mt lj it lh b gy mu mv l mw mx">const person = new Person('Jane', 'Smith');<br/>person.fullName() // 'Jane Smith'</span></pre><p id="b035" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">静态方法是不用使用<code class="fe le lf lg lh b">new</code>关键字从类中创建对象就可以调用的方法。例如，我们可以有如下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fbe0" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>  get fullName() {<br/>    return `${this.firstName} ${this.lastName}`<br/>  }<br/>  sayHi() {<br/>    return `Hi, ${this.firstName} ${this.lastName}`<br/>  }<br/>  static personCount() {<br/>    return 3;<br/>  }<br/>}</span></pre><p id="3edf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以调用<code class="fe le lf lg lh b">personCount</code>函数而不使用<code class="fe le lf lg lh b">new</code>关键字来创建类的实例。所以如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3f91" class="mt lj it lh b gy mu mv l mw mx">Person.personCount</span></pre><p id="89b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到3个返回。</p><p id="6c3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原型方法中的<code class="fe le lf lg lh b">this</code>值将是对象的值。对于静态方法，<code class="fe le lf lg lh b">this</code>的值具有静态方法所在的类作为值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/ce4abb6d10f879a8fd1c9e7ca80a4c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BvO6QcBmjOGtcHnL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@thkelley?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托马斯·凯利</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="ac74" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Getters和Setters</h1><p id="fade" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript类可以有getter和setter函数。顾名思义，Getters是一种让我们从类中获取一些数据的方法。Setters是让我们能够设置类的一些字段的方法。我们用关键字<code class="fe le lf lg lh b">get</code>表示getter函数，用关键字<code class="fe le lf lg lh b">set</code>表示setter函数。例如，我们可以编写一个具有getters和setters的类，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1c6b" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(firstName, lastName) {<br/>    this._firstName = firstName;<br/>    this._lastName = lastName;<br/>  }<br/>  get fullName() {<br/>    return `${this.firstName} ${this.lastName}`<br/>  }<br/>  get firstName() {<br/>    return this._firstName<br/>  }<br/>  get lastName() {<br/>    return this._lastName<br/>  }<br/>  sayHi() {<br/>    return `Hi, ${this.firstName} ${this.lastName}`<br/>  }<br/>  set firstName(firstName) {<br/>    this._firstName = firstName;<br/>  }<br/>  set lastName(lastName) {<br/>    this._lastName = lastName;<br/>  }<br/>}</span></pre><p id="a620" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们使用<code class="fe le lf lg lh b">new</code>关键字来构造一个<code class="fe le lf lg lh b">Person</code>对象时，我们可以按照以下方式使用它们:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="940b" class="mt lj it lh b gy mu mv l mw mx">const person = new Person('Jane', 'Smith');<br/>person.firstName = 'John';<br/>person.lastName = 'Doe';<br/>console.log(person.firstName, person.lastName)</span></pre><p id="416e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们有getter和setter函数，我们可以用它们直接设置数据来设置<code class="fe le lf lg lh b">Person</code>类的<code class="fe le lf lg lh b">firstName</code>和<code class="fe le lf lg lh b">lastName</code>的数据。在以关键字<code class="fe le lf lg lh b">set</code>开始的setter函数中，当我们给它们赋值时，它传递给参数并在类的成员中设置。在由<code class="fe le lf lg lh b">get</code>表示的getter函数中，我们返回成员值，该值触发相关的<code class="fe le lf lg lh b">get</code>函数。</p><h1 id="c7ba" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">JavaScript继承</h1><p id="5aeb" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，我们可以创建一些类，这些类的属性可以包含在子类的属性中。</p><p id="05e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以有一个包含所有子类共有的属性的高级类，并且子类可以有自己的特殊属性，这些属性不在任何其他类中。</p><p id="3d9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个具有公共属性和方法的<code class="fe le lf lg lh b">Animal</code>类，比如<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">eat</code>方法，那么<code class="fe le lf lg lh b">Bird</code>类可以继承<code class="fe le lf lg lh b">Animal</code>类中的公共属性。它们不必在<code class="fe le lf lg lh b">Bird</code>类中再次定义。</p><p id="c7b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用JavaScript编写以下代码来实现继承:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6af2" class="mt lj it lh b gy mu mv l mw mx">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  eat() {<br/>    console.log('eat');<br/>  }<br/>}</span><span id="a7e8" class="mt lj it lh b gy my mv l mw mx">class Bird extends Animal {<br/>  constructor(name, numWings) {<br/>    super(name);<br/>    this.numWings = numWings;<br/>  }<br/>}</span><span id="6e39" class="mt lj it lh b gy my mv l mw mx">const bird = new Bird('Joe', 2);<br/>console.log(bird.name)<br/>bird.eat();</span></pre><p id="333d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们有父类<code class="fe le lf lg lh b">Animal</code>，它有<code class="fe le lf lg lh b">eat</code>方法，所有来自<code class="fe le lf lg lh b">Animal</code>的<code class="fe le lf lg lh b">extends</code>类都会有，所以它们不必再定义<code class="fe le lf lg lh b">eat</code>。</p><p id="2ff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有扩展了<code class="fe le lf lg lh b">Animal</code>类的<code class="fe le lf lg lh b">Bird</code>类。注意，在<code class="fe le lf lg lh b">Bird</code>类的<code class="fe le lf lg lh b">constructor</code>中，我们有<code class="fe le lf lg lh b">super()</code>函数调用来调用父类的构造函数，以填充父类的属性和子类的属性。</p><p id="73de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类不能扩展常规对象，常规对象不能用关键字<code class="fe le lf lg lh b">new</code>构造。如果我们想从一个常规对象继承，我们必须使用<code class="fe le lf lg lh b">Object.setPrototypeOf</code>函数来设置一个从常规对象继承的类。例如:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f2d1" class="mt lj it lh b gy mu mv l mw mx">const Animal = {<br/>  eat() {<br/>    console.log(`${this.name} eats`);<br/>  }<br/>};</span><span id="430b" class="mt lj it lh b gy my mv l mw mx">class Cat{<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="3b39" class="mt lj it lh b gy my mv l mw mx">class Chicken{<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="279f" class="mt lj it lh b gy my mv l mw mx">Object.setPrototypeOf(Cat.prototype, Animal);<br/>Object.setPrototypeOf(Chicken.prototype, Animal);</span><span id="7854" class="mt lj it lh b gy my mv l mw mx">let cat = new Cat('Bob');<br/>let c<!-- -->hicken <!-- -->= new <!-- -->Chicken<!-- -->('Joe');<br/>cat.eat();<br/>c<!-- -->hicken<!-- -->.eat();</span></pre><p id="1db1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的示例代码，我们可以看到记录的<code class="fe le lf lg lh b">Bob eats</code>和<code class="fe le lf lg lh b">Joe eats</code>，因为我们从<code class="fe le lf lg lh b">Animal</code>对象继承了<code class="fe le lf lg lh b">eat</code>函数。</p><h1 id="b431" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">this</code>关键字</h1><p id="802c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">关键字<code class="fe le lf lg lh b">this</code>允许我们在对象内部访问当前对象的属性，除非你使用了箭头函数。</p><p id="b8a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的例子中我们可以看到，我们可以在对象中获得子类和父类的实例的属性。</p><h1 id="a7a6" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">混合蛋白</h1><p id="f5bd" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用mixins在JavaScript中进行多重继承。Mixins是创建类的模板。我们需要mixins来做多重继承，因为JavaScript类只能从一个超类继承，所以多重继承是不可能的。</p><p id="05a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个基类，我们可以定义mixin，通过调用一个mixin来组合多个类中的成员，然后将返回的结果作为参数传递给下一个mixin，以此类推，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="488d" class="mt lj it lh b gy mu mv l mw mx">class Base {<br/>  baseFn() {<br/>    console.log('baseFn called');<br/>  }<br/>}</span><span id="fa2d" class="mt lj it lh b gy my mv l mw mx">let classAMixin = Base =&gt; class extends Base {<br/>  a() {<br/>    console.log('classAMixin called');<br/>  }<br/>};</span><span id="2a4e" class="mt lj it lh b gy my mv l mw mx">let classBMixin = Base =&gt; class extends Base {<br/>  b() {<br/>    console.log('classBMixin called');<br/>  }<br/>};</span><span id="0dd5" class="mt lj it lh b gy my mv l mw mx">class Bar extends classAMixin(classBMixin(Base)) {}<br/>const bar = new Bar();<br/>bar.baseFn()<br/>bar.a()<br/>bar.b()</span></pre><p id="393d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将<code class="fe le lf lg lh b">Base</code>类传递给<code class="fe le lf lg lh b">classBMixin</code>以将<code class="fe le lf lg lh b">b</code>函数传递给<code class="fe le lf lg lh b">Base</code>类，然后我们通过将<code class="fe le lf lg lh b">classBMixin(Base)</code>的结果传递给<code class="fe le lf lg lh b">classAMixin</code>的参数来调用<code class="fe le lf lg lh b">classAMixin</code>，以将<code class="fe le lf lg lh b">classAMixin</code>中的<code class="fe le lf lg lh b">a</code>函数返回给<code class="fe le lf lg lh b">Base</code>类，然后返回整个类，并将所有类中的所有函数合并为一个。</p><p id="8a92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们像创建一个<code class="fe le lf lg lh b">Bar</code>对象的实例那样调用上面的所有函数，然后调用<code class="fe le lf lg lh b">baseFn</code>、<code class="fe le lf lg lh b">a</code>和<code class="fe le lf lg lh b">b</code>函数，我们会得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4cd0" class="mt lj it lh b gy mu mv l mw mx">baseFn called<br/>classAMixin called<br/>classBMixin called</span></pre><p id="f909" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们已经将mixins中的所有函数合并到了新的<code class="fe le lf lg lh b">Bar</code>类中。</p><p id="b0f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，类只是语法糖，通过让我们以一种更像基于类的面向对象继承模式中的典型继承的方式来构造代码，使JavaScript的原型继承更加清晰。这意味着我们编写类来使用<code class="fe le lf lg lh b">new</code>关键字从类中创建对象，但是在语法糖的下面，我们仍然使用原型继承来扩展对象。我们可以从对象扩展类，也可以使用mixins在JavaScript类中进行多重继承。</p></div></div>    
</body>
</html>