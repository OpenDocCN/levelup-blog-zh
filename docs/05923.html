<html>
<head>
<title>Scala journals — Futures: No thread lock no cry [PART 1]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala期刊——未来:没有线程锁就没有哭泣(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-futures-no-thread-lock-no-cry-part-1-2986081d525?source=collection_archive---------15-----------------------#2020-10-12">https://levelup.gitconnected.com/scala-journals-futures-no-thread-lock-no-cry-part-1-2986081d525?source=collection_archive---------15-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="53f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">欢迎阅读关于Scala中并发和非阻塞代码基础的一系列文章。鉴于这个话题的广泛性，我需要把它分成几个部分。我将主要关注<code class="fe ko kp kq kr b">Future</code>,因为它代表了实现并发性的最基本的构件。我很快会谈到高级主题，但今天我们将从非常简单的开始:我将重点关注阻塞与非阻塞的基础知识以及<code class="fe ko kp kq kr b">Future</code>的基础知识。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/c6d5f57747e5acf90fd8c407b10548ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dI1JLvVrdmBdwtld"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">来源:<a class="ae li" href="https://images.unsplash.com/photo-1586864387634-2f33030dab41?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1650&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="cc2f" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">屏蔽还是不屏蔽</h1><p id="df03" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">首先让我们谈谈阻塞和非阻塞。简单地说，当你的代码强迫程序暂停直到它返回时，你的代码就是阻塞的，因此它阻塞了下一个代码的执行。如果您所做的只是将整数相加，这不是一个大问题，但是请考虑您有两个非常长的计算，可能是一些网络或数据库分析调用，如下所示:</p><pre class="kt ku kv kw gt mm kr mn mo aw mp bi"><span id="803e" class="mq lk it kr b gy mr ms l mt mu">val firstComputation = 2 // ...this takes 1000 ms to complete<br/>val secondComputation = 4 // ...and this takes 3000 ms to complete</span><span id="c4ef" class="mq lk it kr b gy mv ms l mt mu">val completelyUnrelatedThing = sendEmail() // 2 ms</span></pre><p id="07e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的伪代码中<code class="fe ko kp kq kr b">completelyUnrelatedThing</code>只需要2毫秒，即使它根本不依赖于<code class="fe ko kp kq kr b">firstComputation</code>或<code class="fe ko kp kq kr b">secondComputation</code>，也会在至少4000毫秒后执行。所以简单来说，我们的总执行时间是<code class="fe ko kp kq kr b">4002 ms</code>。</p><p id="ff68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你决定改变并编写你的代码<code class="fe ko kp kq kr b">non-blocking</code>，你基本上要做的是允许<code class="fe ko kp kq kr b">firstComputation</code>、<code class="fe ko kp kq kr b">secondComputation</code>和<code class="fe ko kp kq kr b">completelyUnrelatedThing</code>并行运行。这可能意味着，如果我们上面的三个计算在三个线程上运行，这意味着我们可以将响应时间减少到<code class="fe ko kp kq kr b">3000ms</code>(再次简化)。您也没有阻塞线程，这意味着您耗尽内存/线程的可能性要小得多。</p><h1 id="41c1" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">介绍…期货！</h1><p id="e3a3" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">让我们从Scala文档中的一个定义开始:</p><blockquote class="mw mx my"><p id="3529" class="jq jr mz js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated"><em class="it">“期货代表一个当前可用或不可用的值，但在某个时间点将可用，或者如果该值不可用，则为例外。”</em></p></blockquote><p id="3059" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，一个<code class="fe ko kp kq kr b">Future</code>代表一个在<strong class="js iu">未来</strong>可用的值，因此得名。如果有人告诉你他们会在未来的某个时候给你写信，那么有些事情是你不能/不应该做的，例如:</p><ul class=""><li id="9fb7" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated">在他们写完信并寄出之前，你不能查看这封信(让我们也暗示“在它真正到达之前”)</li><li id="5c42" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">你不应该停下你的生活，只是盯着邮箱，直到邮递员送来信</li></ul><p id="7ff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把那想象成<code class="fe ko kp kq kr b">Future[Letter]</code>。现在把它想象成<code class="fe ko kp kq kr b">Future[Int]</code> …</p><p id="4135" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我第一次遇到<code class="fe ko kp kq kr b">Futures</code>时，这让我很困惑——如果一个方法返回<code class="fe ko kp kq kr b">Future[Int]</code>,我需要得到那个<code class="fe ko kp kq kr b">Int</code>来用它计算一些东西，我该如何访问它呢？这取决于你如何得到那个<code class="fe ko kp kq kr b">Int</code>你要么阻止要么不阻止，换句话说:你要么以错误的方式，要么以正确的方式使用期货。让我们涵盖一些非常基础的内容:</p><ul class=""><li id="cdfb" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><code class="fe ko kp kq kr b">Future</code>有两种可能的结果:一个<code class="fe ko kp kq kr b">Success</code>或者一个<code class="fe ko kp kq kr b">Failure</code>。第一个保存计算值。后者通常与异常相关，它包含计算遇到的问题。</li><li id="dbc2" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">一个<code class="fe ko kp kq kr b">Future</code>类型包装了另一个将来会出现的类型。你不只是与<code class="fe ko kp kq kr b">Future</code>单独合作。<code class="fe ko kp kq kr b">Future</code>需要一个类型参数，它将在某个阶段返回什么。比如:<br/> <code class="fe ko kp kq kr b">Future[Int]</code>:未来某个阶段会有一个Int返回。<br/> <code class="fe ko kp kq kr b">Future[String]</code>:未来某个阶段会返回一个字符串<br/> <code class="fe ko kp kq kr b">Future[List[Customer]]</code>:未来某个阶段会返回一个客户列表</li><li id="89a9" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><code class="fe ko kp kq kr b">Futures</code>内部使用<code class="fe ko kp kq kr b">Promises</code>(下面再多讲一点<code class="fe ko kp kq kr b">Promises</code>)</li><li id="68cb" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><code class="fe ko kp kq kr b">Future</code>定义时开始执行。</li></ul><pre class="kt ku kv kw gt mm kr mn mo aw mp bi"><span id="95b6" class="mq lk it kr b gy mr ms l mt mu">val result: Future[Result] = getResult() // already executing!</span></pre><ul class=""><li id="e978" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated"><code class="fe ko kp kq kr b">Future</code> <strong class="js iu">不应该被</strong>挡住。这意味着<strong class="js iu">除非</strong>你需要保持主线程活动<strong class="js iu">或者</strong>你正在编写测试代码，否则在任何情况下你都不应该调用<code class="fe ko kp kq kr b">Await</code>来“获取值”:</li></ul><p id="3153" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不好，你挡住了:</p><pre class="kt ku kv kw gt mm kr mn mo aw mp bi"><span id="411d" class="mq lk it kr b gy mr ms l mt mu">Await.ready(getPrice(product), 4 seconds) <br/>// you are actively waiting, in other words: staring at the letter box if the postman is there yet!</span></pre><p id="5261" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是很好的，非常经典的用法。您没有阻止:</p><pre class="kt ku kv kw gt mm kr mn mo aw mp bi"><span id="0eaa" class="mq lk it kr b gy mr ms l mt mu">// whenever getPrice returns then with the returned value we will call "getSimilarProducts" <br/>getPrice(product).flatMap(price =&gt; getSimilarProducts(price))</span></pre><p id="ddca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe ko kp kq kr b">flatMap</code>上，记住:任何<code class="fe ko kp kq kr b">flatMap</code> / <code class="fe ko kp kq kr b">map</code>的链也可以被翻译成<a class="ae li" href="http://for comprehension" rel="noopener ugc nofollow" target="_blank">以便理解</a>，如果你的转换链很长的话，这会使你的代码可读性更好。</p><p id="cd16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您需要显式错误处理，这也很好，因为您没有阻塞:</p><pre class="kt ku kv kw gt mm kr mn mo aw mp bi"><span id="b200" class="mq lk it kr b gy mr ms l mt mu">getPrice(product) match {<br/>  case Success(price)   =&gt; continue(price)<br/>  case Failure(problem) =&gt; handleProblem(problem)<!-- --> <br/>}</span></pre><p id="a48d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回调，你没有阻挡。但是要注意，<code class="fe ko kp kq kr b">onComplete</code>会丢弃返回值，返回<code class="fe ko kp kq kr b">Unit</code>。在使用回调之前，请检查它们的返回类型！</p><pre class="kt ku kv kw gt mm kr mn mo aw mp bi"><span id="e7fb" class="mq lk it kr b gy mr ms l mt mu">getPrice(product).<!-- -->onComplete<!-- --> {<br/>  case Success(price)   =&gt; continue(price)<br/>  case Failure(problem) =&gt; handleProblem(problem)<!-- --> <br/>} // return Unit</span></pre><p id="3929" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击了解更多关于<code class="fe ko kp kq kr b">Futures</code>和<a class="ae li" href="https://www.scala-lang.org/api/current/scala/concurrent/Future.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h1 id="df70" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我也听说过承诺，它像未来吗？</h1><p id="ceb0" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">编号<code class="fe ko kp kq kr b">Promise</code>由<code class="fe ko kp kq kr b">Future</code>在内部使用。每次你创建一个<code class="fe ko kp kq kr b">Future</code>你就创建了一个<code class="fe ko kp kq kr b">Promise</code>。一个<code class="fe ko kp kq kr b">Future</code>没有一个<code class="fe ko kp kq kr b">Promise</code>就无法工作，但是当我们每天和<code class="fe ko kp kq kr b">Futures</code>一起工作时，这一点对我们来说几乎是隐藏的。A <code class="fe ko kp kq kr b">Promise</code>是<code class="fe ko kp kq kr b">Future</code>的返回值的实际来源。简而言之:<code class="fe ko kp kq kr b">Promise</code>被写入，但实际读取的是<code class="fe ko kp kq kr b">Future</code>。有少量非常专业的用例，我们希望获得如此低的控制级别，以便直接使用<code class="fe ko kp kq kr b">Promises</code>。然而，由于这是足够罕见的，我决定现在跳过进入细节。将来我可能会在另一篇文章中讨论这个话题(没有双关语的意思)。</p><h1 id="7b68" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">接下来…</h1><p id="8775" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在下一篇文章中，我将深入探讨什么是<code class="fe ko kp kq kr b">ExecutionContext</code>，为什么当你想使用<code class="fe ko kp kq kr b">Futures</code>时总是需要它，以及如何选择一个正确的。我还会谈到为什么我们有时会听到Scala在并发性方面比其他语言更好。</p><p id="5827" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">敬请期待！</p></div></div>    
</body>
</html>