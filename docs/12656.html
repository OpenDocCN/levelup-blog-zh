<html>
<head>
<title>5 LeetCode Questions to Crack the Coding Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解编码面试的5个LeetCode问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-leetcode-questions-to-crack-the-coding-interview-889b48f3879a?source=collection_archive---------6-----------------------#2022-06-27">https://levelup.gitconnected.com/5-leetcode-questions-to-crack-the-coding-interview-889b48f3879a?source=collection_archive---------6-----------------------#2022-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们讨论一些LeetCode问题的解决方案，为编码面试做准备</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f5c11068fc222ad6c0f629c19fbd13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zCtacSjdjPAAtto-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ourlifeinpixels?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>上的我们的生活像素</figcaption></figure><p id="0446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码面试是开发人员职位的关键部分。熟悉基本的算法和数据结构是我们一直期望你做的事情。在这里，我们将讨论LeetCode问题，这将有助于你为大型科技公司的编码面试做准备。在本文中，我们将讨论一些软件工程师职位要求的简单和中级问题:</p><ul class=""><li id="9335" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">汇总范围(简单)</li><li id="5fc3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">给定时间内做作业的学生人数(简单)</li><li id="3a67" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">区间列表交叉点(中等)</li><li id="e4e6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">删除一个元素后1的最长子数组(中)</li><li id="8ce1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">字符串压缩(中等)</li></ul><p id="64a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个简单的热身问题:</p><h2 id="e0ed" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">1.汇总范围</h2><div class="nc nd gp gr ne nf"><a href="https://leetcode.com/problems/summary-ranges/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">汇总范围— LeetCode</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">leetcode.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><p id="cfc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给你一个<strong class="lb iu">排序的唯一的</strong>整数数组<code class="fe nu nv nw nx b">nums</code>。</p><p id="2cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu">范围</strong> <code class="fe nu nv nw nx b">[a,b]</code>是从<code class="fe nu nv nw nx b">a</code>到<code class="fe nu nv nw nx b">b</code>(含)的所有整数的集合。</p><p id="4161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回<em class="ny"/><strong class="lb iu"><em class="ny">最小排序的</em> </strong> <em class="ny">范围列表，即</em> <strong class="lb iu"> <em class="ny">正好覆盖数组中的所有数字</em> </strong>。也就是说，<code class="fe nu nv nw nx b">nums</code>的每个元素恰好被其中一个范围覆盖，不存在整数<code class="fe nu nv nw nx b">x</code>使得<code class="fe nu nv nw nx b">x</code>在其中一个范围内而不在<code class="fe nu nv nw nx b">nums</code>内。</p><p id="b8b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表中的每个范围<code class="fe nu nv nw nx b">[a,b]</code>应输出为:</p><ul class=""><li id="0545" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nu nv nw nx b">"a-&gt;b"</code>如果<code class="fe nu nv nw nx b">a != b</code></li><li id="1491" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nu nv nw nx b">"a"</code>如果<code class="fe nu nv nw nx b">a == b</code></li></ul><p id="b9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案:</p><ul class=""><li id="fe96" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们可以迭代<code class="fe nu nv nw nx b">nums</code>数组中的每个元素，并检查它们是否相差1。如果是这种情况，将一个元素追加到当前范围元组中。如果不是这种情况，在<code class="fe nu nv nw nx b">ranges</code>中创建一个新的范围。</li><li id="2104" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据结构:除了输入列表<code class="fe nu nv nw nx b">nums</code>之外，我们正在使用<code class="fe nu nv nw nx b">ranges</code>列表。</li><li id="1784" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">复杂度:线性的<code class="fe nu nv nw nx b">O(n)</code>，因为我们迭代输入<code class="fe nu nv nw nx b">nums</code>和<code class="fe nu nv nw nx b">ranges</code>数组。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b5a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里还有一个类似于合并间隔的解决方案。我觉得看起来更简洁，更有pythonic的味道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="7bad" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">2.给定时间内做作业的学生人数</h2><div class="nc nd gp gr ne nf"><a href="https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">给定时间内做作业的学生数量— LeetCode</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">给定两个整数数组startTime和endTime，并给定一个整数queryTime。第I个学生开始做他们的…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">leetcode.com</p></div></div><div class="no l"><div class="ob l nq nr ns no nt ks nf"/></div></div></a></div><p id="e1b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定两个整数数组<code class="fe nu nv nw nx b">startTime</code>和<code class="fe nu nv nw nx b">endTime</code>，给定一个整数<code class="fe nu nv nw nx b">queryTime</code>。</p><p id="e58c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">ith</code>学生在<code class="fe nu nv nw nx b">startTime[i]</code>时间开始做作业，在<code class="fe nu nv nw nx b">endTime[i]</code>时间完成作业。</p><p id="4170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回在时间<code class="fe nu nv nw nx b">queryTime</code>做作业的学生数量。更正式的说法是，返回<code class="fe nu nv nw nx b">queryTime</code>位于区间<code class="fe nu nv nw nx b">[startTime[i], endTime[i]]</code>内的学生人数。</p><p id="640c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案:</p><ul class=""><li id="efe0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">相当简单的解决方案。只需迭代数组<code class="fe nu nv nw nx b">startTime</code>和<code class="fe nu nv nw nx b">endTime</code>并计算<code class="fe nu nv nw nx b">queryTime</code>位于<code class="fe nu nv nw nx b">startTime[i], endTime[i]</code>之间的次数。</li><li id="0399" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据结构:我们没有使用任何额外的集合，只是输入列表和int <code class="fe nu nv nw nx b">queryTime</code>。</li><li id="9e6d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">复杂度:<code class="fe nu nv nw nx b">O(n)</code>当我们迭代输入<code class="fe nu nv nw nx b">startTime</code>和<code class="fe nu nv nw nx b">endTime</code>时。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="96fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来解决中级问题。但首先，让我们来看看可爱的柯基放松一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/29d9ff37335ed863d7954f4b23fadf14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4bC2RtiP_HeZ-UsV"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@samanthadeestudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨曼莎·让</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="56b6" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">3.区间列表交集</h2><div class="nc nd gp gr ne nf"><a href="https://leetcode.com/problems/interval-list-intersections/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">区间列表交叉点LeetCode</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">给你两个闭区间列表，firstList和secondList，其中firstList[i] = [starti，迪恩]和…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">leetcode.com</p></div></div><div class="no l"><div class="od l nq nr ns no nt ks nf"/></div></div></a></div><p id="6478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给你两个封闭区间列表，<code class="fe nu nv nw nx b">firstList</code>和<code class="fe nu nv nw nx b">secondList</code>，其中<code class="fe nu nv nw nx b">firstList[i] = [starti, endi]</code>和<code class="fe nu nv nw nx b">secondList[j] = [startj, endj]</code>。每个区间列表是成对的<strong class="lb iu">不相交的</strong>并且按照<strong class="lb iu">排序的</strong>。</p><p id="1dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回这两个区间列表的交集。</p><p id="0dfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu">闭区间</strong> <code class="fe nu nv nw nx b">[a, b]</code>(带<code class="fe nu nv nw nx b">a &lt;= b</code>)表示一组带<code class="fe nu nv nw nx b">a &lt;= x &lt;= b</code>的实数<code class="fe nu nv nw nx b">x</code>。</p><p id="fc43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个闭区间的<strong class="lb iu">交集</strong>是一组实数，要么为空，要么表示为闭区间。比如<code class="fe nu nv nw nx b">[1, 3]</code>和<code class="fe nu nv nw nx b">[2, 4]</code>的交点就是<code class="fe nu nv nw nx b">[2, 3]</code>。</p><p id="90b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案:</p><ul class=""><li id="5da4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在这个任务中，我们同时迭代<code class="fe nu nv nw nx b">firstList</code>和<code class="fe nu nv nw nx b">secondList</code>。在每一步中，我们在两个范围之间进行选择，一个是左边界的<code class="fe nu nv nw nx b">lower</code>(我们称之为<code class="fe nu nv nw nx b">lower</code>)，另一个是左边界的<code class="fe nu nv nw nx b">higher</code>(我们称之为<code class="fe nu nv nw nx b">higher</code>)。</li><li id="e405" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">首先，我们需要定义重叠范围。两个范围相互重叠的条件是:<code class="fe nu nv nw nx b">lower</code>范围的右边界应该大于等于<code class="fe nu nv nw nx b">higher</code>范围的左边界。</li><li id="3278" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">然后，为了传递到下一对范围，我们应该从输入列表<code class="fe nu nv nw nx b">firstList</code>或<code class="fe nu nv nw nx b">secondList</code>中删除具有最小右边界的范围。</li><li id="fc3f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据结构:输入列表<code class="fe nu nv nw nx b">firstList</code>、<code class="fe nu nv nw nx b">secondList</code>和元组<code class="fe nu nv nw nx b">lower</code>、<code class="fe nu nv nw nx b">higher</code>。</li><li id="db89" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">复杂性:并行迭代两个输入列表花费的时间最多<code class="fe nu nv nw nx b">O(n+m)</code>。在每次迭代结束时，我们搜索并删除<code class="fe nu nv nw nx b">O(log(n))</code>中右边界最低的范围。所以总时间是<code class="fe nu nv nw nx b">O((n+m)log(n))</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/ab8ac0a2e084a91103dd17fdacfdffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9QqCH0dUJ58omMhkhwyDCQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">交叉案例(图片由作者提供)</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="946b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更快和更简洁的<a class="ae ky" href="https://leetcode.com/problems/interval-list-intersections/discuss/647482/Python-Two-Pointer-Approach-%2B-Thinking-Process-Diagrams" rel="noopener ugc nofollow" target="_blank">解决方案</a>可以是使用两个指针来跟踪两个列表中的范围，而无需移除它们。</p><ul class=""><li id="4b99" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">与前面的解决方案一样，我们跟踪重叠范围的开始和结束。</li><li id="2521" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为了识别重叠，我们同样检查具有较低左边界的范围的右边界是否高于另一个范围的左边界。</li><li id="61da" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">然后从一个范围移动到另一个范围，我们增加指针。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="29a2" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">4.删除一个元素后1的最长子数组</h2><div class="nc nd gp gr ne nf"><a href="https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">删除一个元素后1的最长子数组— LeetCode</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">给定一个二进制数组nums，你应该从中删除一个元素。返回最长的非空子数组的大小…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">leetcode.com</p></div></div><div class="no l"><div class="of l nq nr ns no nt ks nf"/></div></div></a></div><p id="6d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定一个二进制数组<code class="fe nu nv nw nx b">nums</code>，你应该从中删除一个元素。</p><p id="bfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回<em class="ny">结果数组</em>中只包含 <code class="fe nu nv nw nx b">1</code> <em class="ny">的最长非空子数组的大小。如果没有这样的子阵，返回<code class="fe nu nv nw nx b">0</code>。</em></p><p id="3fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案:</p><ul class=""><li id="3c02" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们创建元组的空列表<code class="fe nu nv nw nx b">ones</code>来存储输入数组<code class="fe nu nv nw nx b">nums</code>中一序列的起始索引和长度。所以<code class="fe nu nv nw nx b">nums : list[(start_id, seq_len)]</code>。</li><li id="1a6e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果<code class="fe nu nv nw nx b">nums</code>的两个连续元素为1，我们增加<code class="fe nu nv nw nx b">ones</code>中当前序列的长度。否则，如果前一个元素是1，下一个元素是0，我们将一个新的元组追加到<code class="fe nu nv nw nx b">ones</code>。这意味着我们传递到新的序列。</li><li id="7072" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">下一步是找出<code class="fe nu nv nw nx b">nums</code>中最长的1序列的长度。为此，我们对<code class="fe nu nv nw nx b">ones</code>进行迭代，并寻找两个连续元组的总长度的最大值。我们还考虑了1的序列被一个以上的0分开的情况。这里我们应该检查单个序列的长度，如果它大于任何两个连续序列的总和。</li><li id="7757" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们需要检查拐角情况，以防<code class="fe nu nv nw nx b">nums</code>中只有1或0。这种情况下，答案分别是<code class="fe nu nv nw nx b">len(nums)-1</code>和<code class="fe nu nv nw nx b">0</code>。</li><li id="8318" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据结构:输入列表<code class="fe nu nv nw nx b">nums</code>，元组列表<code class="fe nu nv nw nx b">ones</code>，int <code class="fe nu nv nw nx b">maxlen</code>。</li><li id="6512" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">复杂性:当我们在<code class="fe nu nv nw nx b">nums</code>上迭代两次，然后在<code class="fe nu nv nw nx b">ones</code>上迭代两次时，时间最多是<code class="fe nu nv nw nx b">O(2n)</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论中提出的一个<a class="ae ky" href="https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708731/Python-3-Faster-than-100-Explanation" rel="noopener ugc nofollow" target="_blank">更快的解决方案</a>是使用列表<code class="fe nu nv nw nx b">ones</code>只存储序列的长度。这里，我们以与上一个解决方案相同的方式检查序列之间的过渡，并处理拐角情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="8ac3" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">5.字符串压缩</h2><div class="nc nd gp gr ne nf"><a href="https://leetcode.com/problems/string-compression/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">字符串压缩— LeetCode</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">给定一个字符chars的数组，使用下面的算法压缩它:以一个空字符串s开始。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">leetcode.com</p></div></div><div class="no l"><div class="og l nq nr ns no nt ks nf"/></div></div></a></div><p id="5c39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定一个字符数组<code class="fe nu nv nw nx b">chars</code>，使用以下算法压缩它:</p><p id="2fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以空字符串<code class="fe nu nv nw nx b">s</code>开始。对于<code class="fe nu nv nw nx b">chars</code>中的每组<strong class="lb iu">连续重复字符</strong>:</p><ul class=""><li id="c9ae" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果组的长度为<code class="fe nu nv nw nx b">1</code>，则将字符追加到<code class="fe nu nv nw nx b">s</code>。</li><li id="64da" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">否则，在字符后面加上组的长度。</li></ul><p id="4143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">压缩后的字符串<code class="fe nu nv nw nx b">s</code> <strong class="lb iu">不应该单独返回</strong>，而是存储<strong class="lb iu">在输入字符数组</strong> <code class="fe nu nv nw nx b"><strong class="lb iu">chars</strong></code>中。注意，<code class="fe nu nv nw nx b">10</code>或更长的组长度将在<code class="fe nu nv nw nx b">chars</code>中被分割成多个字符。</p><p id="79dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你完成<strong class="lb iu">修改输入数组后，</strong>返回<em class="ny">数组的新长度</em>。</p><p id="a6db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须编写一个只使用常量额外空间的算法。</p><p id="7f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案:</p><ul class=""><li id="838f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们开始迭代<code class="fe nu nv nw nx b">chars</code>并寻找相同字符序列之间的转换。我们传递到下一个序列，并将计数器<code class="fe nu nv nw nx b">count</code>设置为1，否则，我们将其递增1。</li><li id="4719" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们创建一个空字符串<code class="fe nu nv nw nx b">s</code>,在一个新序列开始后，如果它大于1，我们追加<code class="fe nu nv nw nx b">count</code>。</li><li id="3828" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我们将字符串<code class="fe nu nv nw nx b">s</code>转换成一个字符列表，并将其分配给<code class="fe nu nv nw nx b">chars</code>。</li><li id="ecdb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据结构:除了输入列表<code class="fe nu nv nw nx b">chars</code>之外，我们还使用一个字符串<code class="fe nu nv nw nx b">s</code>和一个计数器。</li><li id="28fa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">复杂性:因为我们在<code class="fe nu nv nw nx b">chars</code>上迭代一次，所以时间是线性的<code class="fe nu nv nw nx b">O(n)</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="a919" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">最后的想法</h2><p id="4c1f" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">如果你对这些解决方案有什么意见和反馈，请在下面的评论区告诉我。Leetcoding快乐！</p><p id="9a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢☕️的文章，请不要犹豫，支持我的写作。它帮助我在ML和数据科学上产生更多有趣和有用的内容:)</p><div class="nc nd gp gr ne nf"><a href="https://betterprogramming.pub/log-machine-learning-experiments-with-mlflow-on-azure-databricks-5a85955c9d3a" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">用MLflow在Azure Databricks上进行日志机器学习实验</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在Databricks中获取远程MLflow tracking服务器上记录的模型、指标和工件</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">better编程. pub</p></div></div><div class="no l"><div class="om l nq nr ns no nt ks nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://betterprogramming.pub/automate-your-machine-learning-experiments-with-mlflow-8c9e42df421" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">使用MLflow自动化您的机器学习实验</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">少花钱多办事的简要指南</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">better编程. pub</p></div></div><div class="no l"><div class="on l nq nr ns no nt ks nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://medium.com/@evgeniimunin47/multipath-errors-in-gps-signals-de3a20440cf9" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">GPS信号中的多径误差</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">GPS信号经常受到不同类型的事件的影响，导致定位质量下降。在许多情况下…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="oo l nq nr ns no nt ks nf"/></div></div></a></div></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><h1 id="2e63" class="ow mk it bd ml ox oy oz mo pa pb pc mr jz pd ka mu kc pe kd mx kf pf kg na pg bi translated">分级编码</h1><p id="c5a1" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae ky" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>。<br/>跟随:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae ky" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="lb iu">升一级正在改造理工大招聘➡️ </strong> <a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>