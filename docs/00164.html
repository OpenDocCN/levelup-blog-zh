<html>
<head>
<title>Making an Animated 3D Facing Widget</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作3D动画小部件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/making-a-3d-facing-widget-8ab51a9eb573?source=collection_archive---------0-----------------------#2018-07-04">https://levelup.gitconnected.com/making-a-3d-facing-widget-8ab51a9eb573?source=collection_archive---------0-----------------------#2018-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/57286d34e89b27b81f74623c7ee33197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kXgxQa9SPNJcsTrI.jpg"/></div></div></figure><p id="c03d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到“每周小部件”系列，在这里我拍摄了令人敬畏的UI/UX组件的gif或视频，并用代码将它们赋予生命。</p><blockquote class="kw"><p id="35bc" class="kx ky iq bd kz la lb lc ld le lf kv dk translated"><em class="lg">查看本周文章</em>  <em class="lg">中的所有</em> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="https://levelup.gitconnected.com/wotw/home"> <em class="lg">小部件，并关注Gitconnected，确保您不会错过任何即将到来的小部件教程</em></a></p></blockquote><p id="024d" class="pw-post-body-paragraph jy jz iq ka b kb li kd ke kf lj kh ki kj lk kl km kn ll kp kq kr lm kt ku kv ij bi translated">这一次，我们将创建一个3D小部件，当我们在屏幕上移动光标时，它会“看”着光标。</p><p id="5800" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">灵感来自于史蒂文·汉利创造的运球，看起来是这样的:</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/e7350a3d9ea72f54d643555b4e0cb783.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/0*_MeUEqewPMK2qxXw.gif"/></div></figure><h2 id="d74a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kj mb mc md kn me mf mg kr mh mi mj mk bi translated">准备</h2><p id="7dac" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">对于今天的小部件，我们将使用<a class="ae lh" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>，对于“环视”动画，我们将使用<a class="ae lh" href="https://greensock.com/tweenmax" rel="noopener ugc nofollow" target="_blank"> TweenMax </a>。</p><p id="7c0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想继续，你可以派生这个已经有依赖关系的<a class="ae lh" href="https://codepen.io/ederdiaz/pen/bMLbNp" rel="noopener ugc nofollow" target="_blank"> codepen模板</a>。</p><h2 id="3caf" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kj mb mc md kn me mf mg kr mh mi mj mk bi translated">初始标记</h2><p id="d20c" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">对于这个组件，标记应该非常简单。我们需要我们的应用程序，一个容器，里面有一个图像，标题和一些随机文本的卡片。</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="429a" class="ls lt iq mr b gy mv mw l mx my">&lt;div id="app"&gt;<br/>  &lt;div class="container center"&gt;<br/>    &lt;img class="image" src="https://www.dropbox.com/s/b0h57o6sxznnowy/drone-00.webp?raw=1"&gt;<br/>    &lt;h1 class="title"&gt;Dr. one&lt;/h1&gt;<br/>    &lt;div class="card"&gt;<br/>      &lt;p&gt;<br/>        Chupa chups lollipop jelly cake icing wafer chocolate <br/>        lollipop candy canes. Marzipan dragée biscuit cotton candy <br/>        sweet roll sugar plum. Toffee sweet jelly beans cake <br/>        gummies gummies jujubes cotton candy sugar plum.<br/>      &lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="942a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能已经注意到，我们已经添加了一些类，以便在下一步中设计每个节点的样式。</p><h2 id="3474" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kj mb mc md kn me mf mg kr mh mi mj mk bi translated">式样</h2><p id="fe79" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">首先，为了匹配参考背景，我们将简单地放入以下规则:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="9c26" class="ls lt iq mr b gy mv mw l mx my">body {<br/>  background-color: #36B5B2<br/>}</span></pre><p id="f309" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步，我们将中心的容器，也增加了一些上限，所以它有一些移动空间在顶部。</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="5f2b" class="ls lt iq mr b gy mv mw l mx my">.container {<br/>  position: relative;<br/>  margin-top: 40px;<br/>}<br/><br/>.center {<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>}</span></pre><p id="60db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mz na nb mr b">position: relative</code>属性将允许我们操作带有<code class="fe mz na nb mr b">absolute</code>定位的内部元素，而不会让它们超出原始容器(除非我们希望它们这样做)。</p><p id="f05c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标题将水平居中，略低于垂直中心(<code class="fe mz na nb mr b">top: 150px</code>)，我们将尽量匹配字体大小和家庭。</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="9207" class="ls lt iq mr b gy mv mw l mx my">.title {<br/>  position: absolute;<br/>  top: 150px;<br/>  text-align: center;<br/>  color: white;<br/>  font-size: 80px;<br/>  font-family: Helvetica, Arial, Sans-Serif;<br/>}</span></pre><p id="32de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后卡片将类似地定位在水平中心，但这次它将在图像下方一点(<code class="fe mz na nb mr b">bottom: -20px</code>)，并具有固定的<code class="fe mz na nb mr b">height</code>和<code class="fe mz na nb mr b">width</code>:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="de0a" class="ls lt iq mr b gy mv mw l mx my">.card {<br/>  position: absolute;<br/>  background-color: white;<br/>  bottom: -20px;<br/>  padding: 20px;<br/>  width: 400px;<br/>  height: 100px;<br/>}</span></pre><p id="d171" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们应该有这样的东西:</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/2dd9fbc328d90afd83d96d148a3c86e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-0hyT06KJDmFsKDw.png"/></div></div></figure><h2 id="475a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kj mb mc md kn me mf mg kr mh mi mj mk bi translated">行为</h2><p id="ad0c" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在我们开始编写Vue应用程序之前，让我们分析一下实现所需动画需要什么，让我们再看一下参考资料:</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/225bf2bd0b248f22fa15823aa17cf64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/0*x8BT6_2kk4rmUafN.gif"/></div></figure><p id="bd51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们的输入将是鼠标位置，根据它我们应该改变容器的旋转。这种旋转应该被控制，因为我们不希望对象旋转360度，它实际上只旋转了足够多的角度来获得它面对鼠标的感觉，我说每个方向大约20度。</p><p id="2912" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以用这些知识来设置我们的Vue应用程序，让我们声明一个带有自由度的常数和几个数据属性来跟踪对象旋转:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="533e" class="ls lt iq mr b gy mv mw l mx my">const maxRotationDegrees = 20<br/>new Vue({<br/>  el: '#app',<br/>  data: {<br/>    rotX: 0,<br/>    rotY: 0<br/>  }<br/>})</span></pre><p id="826a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是添加一个方法来跟踪鼠标位置，我们希望知道它在应用程序中的位置，而不仅仅是小部件，所以我们需要在主HTML节点中添加一个<code class="fe mz na nb mr b">mousemove</code>处理程序，如下所示:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="6130" class="ls lt iq mr b gy mv mw l mx my">&lt;div id="app" @mousemove="mouseMoved"&gt;<br/>  &lt;!-- the rest of the markup --&gt;</span></pre><p id="12e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要创建<code class="fe mz na nb mr b">mouseMoved</code>方法，在该方法中，我们将使用事件的<code class="fe mz na nb mr b">pageX</code>和<code class="fe mz na nb mr b">pageY</code>属性获取鼠标位置。之后，我们将标准化输入，乘以自由度，最后将它们存储到我们的<code class="fe mz na nb mr b">rotX</code>和<code class="fe mz na nb mr b">rotY</code>属性中:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="f8bb" class="ls lt iq mr b gy mv mw l mx my">// vue app ...<br/>  methods: {<br/>    mouseMoved (e) {<br/>       // This gives us a number between -1 and 1<br/>       const mousePercX = (e.pageX / document.body.clientWidth) * 2 - 1<br/>       const mousePercY = (e.pageY / document.body.clientHeight) * 2 - 1<br/>      <br/>      <br/>       this.rotX = mousePercX * maxRotationDegrees<br/>       this.rotY = mousePercY * -maxRotationDegrees<br/>    }<br/>  }</span></pre><p id="943a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了开始在我们的小部件中看到一些移动，我们需要改变它的样式，所以我们将创建一个名为<code class="fe mz na nb mr b">rotation</code>的计算属性，它将生成应用于小部件的CSS转换:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="f1e4" class="ls lt iq mr b gy mv mw l mx my">// vue app ...<br/>  computed: {<br/>    rotation () {<br/>      return {<br/>        transform: `perspective(1000px) rotateY(${this.rotX}deg) rotateX(${this.rotY}deg)`<br/>      }<br/>    }<br/>  },</span></pre><p id="1269" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到，我们有带有<code class="fe mz na nb mr b">rotX</code>属性的<code class="fe mz na nb mr b">rotateY</code>属性，以及带有<code class="fe mz na nb mr b">rotateX</code>属性的类似属性，这不是一个错误。</p><p id="455b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发生的情况是，当在3D空间中旋转对象时，<code class="fe mz na nb mr b">Y</code>轴中的旋转使对象水平地改变其朝向，而<code class="fe mz na nb mr b">X</code>轴中的旋转使其垂直地改变朝向。</p><p id="494c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在下图中更清楚地看到，橙色箭头对应于<code class="fe mz na nb mr b">rotateY</code>属性，绿色箭头是<code class="fe mz na nb mr b">rotateX</code>属性:</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f76c8a0a92bc94bad4eca140b7beea30.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*FMpbkZsbV4GNSlDi.png"/></div></figure><p id="44d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解释完之后，我们现在可以在内联样式属性中将这些转换添加到我们的小部件中，如下所示:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="ab45" class="ls lt iq mr b gy mv mw l mx my">&lt;!-- app --&gt;<br/>   &lt;div class="container center" :style="rotation"&gt;</span></pre><p id="4fd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们测试，我们应该看到小部件移动…但有些不对劲，对象完全是平的:</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/b499ac6018d85a899c58c21544785759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0gOXwwFacCqAVHgT.png"/></div></div></figure><p id="76ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使我们在计算的<code class="fe mz na nb mr b">rotation</code>中添加了一个透视属性，我们仍然需要改变内部零件的<code class="fe mz na nb mr b">z</code>位置。看起来应该是图像在后面，标题在中间，卡片在前面，所以让我们稍微改变一下他们的CSS:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="0473" class="ls lt iq mr b gy mv mw l mx my">.image {<br/>  transform: translateZ(-100px);<br/>}<br/><br/>.title {<br/>  /* other props */<br/>  transform: translateZ(20px);<br/>}<br/><br/>.card {<br/>  /* other props */<br/>  transform: translateZ(100px);<br/>}</span></pre><p id="f718" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Mmmh看起来还是平的…</p><p id="da0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在阅读了一些<a class="ae lh" href="https://www.w3schools.com/cssref/css3_pr_transform-style.asp" rel="noopener ugc nofollow" target="_blank">文档</a>之后，我发现一个节点的子节点总是扁平的，除非你明确地说不是这样，所以我们需要在我们的容器中添加以下属性:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="7c95" class="ls lt iq mr b gy mv mw l mx my">.container {<br/>  /* other props */<br/>  transform-style: preserve-3d;<br/>}</span></pre><p id="b6f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将允许节点的子节点在3D空间中正确呈现。</p><p id="91ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以说我们完成了，但我觉得动画有点僵硬。我们可以通过用这样的补间替换<code class="fe mz na nb mr b">mouseMoved</code>方法的最后一部分来平滑它:</p><pre class="lo lp lq lr gt mq mr ms mt aw mu bi"><span id="2142" class="ls lt iq mr b gy mv mw l mx my">// mouseMoved...<br/>      // remove these<br/>      // this.rotX = mousePercX * maxRotationDegrees<br/>      // this.rotY = mousePercY * -maxRotationDegrees<br/><br/>      // add this<br/>      TweenLite.to(this, 0.5, {<br/>        rotX: mousePercX * maxRotationDegrees,<br/>        rotY: mousePercY * -maxRotationDegrees<br/>      })</span></pre><p id="cfb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而现在最后的结果！</p><figure class="lo lp lq lr gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a624" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是本周的<strong class="ka ir">小部件。下周见，关注<a class="ae lh" href="https://levelup.gitconnected.com" rel="noopener ugc nofollow" target="_blank"> gitconnected </a>获取每周小工具！</strong></p><p id="aa9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你渴望更多，你可以查看其他WotW: <br/> — <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/cards-hover-animation-wotw-7d1304f16ec6">卡片悬停动画</a> <br/> — <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/making-a-scrolling-card-list-wotw-bcd5e31fbcc5">滚动卡片列表</a> <br/> — <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/making-an-animated-nav-component-wotw-e94b6bca04c4">动画导航</a></p><p id="a509" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，如果你想看下周的某个小部件，可以在评论区发表。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="6e27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="no">最初发表于</em> <a class="ae lh" href="http://ederdiaz.com/blog/2018/07/04/making-a-3d-facing-widget/" rel="noopener ugc nofollow" target="_blank"> <em class="no">埃德迪亚兹</em> </a> <em class="no">。</em></p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi np"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure></div></div>    
</body>
</html>