<html>
<head>
<title>How to Add a Double Border to SVG Shapes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何给SVG形状添加双边框</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-add-a-double-border-to-svg-shapes-d525c522cfde?source=collection_archive---------18-----------------------#2021-05-04">https://levelup.gitconnected.com/how-to-add-a-double-border-to-svg-shapes-d525c522cfde?source=collection_archive---------18-----------------------#2021-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6fc96a068a713287aae0d4d6798a13ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIUHFIjE6GfE0VMpa0TP1w.png"/></div></div></figure><p id="4453" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设有人要求您为一些随机的几何SVG形状添加一个双<strong class="kd iu">边框。出于某种原因，您不能使用任何图形编辑器——它们需要在运行时生成——所以您必须使用CSS或SVG语法来解决它。</strong></p><p id="b786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你的第一个问题可能是:SVG中有类似于<code class="fe kz la lb lc b">stroke-style: double</code>的东西吗？嗯，答案是<a class="ae ld" href="https://dev.w3.org/SVG/modules/vectoreffects/master/SVGVectorEffectsPrimer.html#VectorEffects" rel="noopener ugc nofollow" target="_blank">还没有</a>而且<a class="ae ld" href="http://tavmjong.free.fr/blog/?p=1257" rel="noopener ugc nofollow" target="_blank">没那么容易</a>。但无论如何我会尝试看看我能发现什么方法。我将探索三种不同基本形状的可能性:圆形、矩形和多边形。指着两条线中间能保持透明颜色的。</p><blockquote class="le lf lg"><p id="bdcc" class="kb kc lh kd b ke kf kg kh ki kj kk kl li kn ko kp lj kr ks kt lk kv kw kx ky im bi translated"><strong class="kd iu">剧透警告:</strong>所有的结果都有缺点，至少对于CSS和SVG是这样，但是让我来告诉你我的意图。</p></blockquote><h1 id="2705" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">简单的解决方案</h1><p id="f0d3" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">这些方法并不适用于所有形状，但它们是最简单的解决方案。</p><h2 id="bcb5" class="mo lm it bd ln mp mq dn lr mr ms dp lv km mt mu lz kq mv mw md ku mx my mh mz bi translated"><code class="fe kz la lb lc b">outline</code>和<code class="fe kz la lb lc b">box-shadow</code></h2><p id="b84f" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">CSS属性<code class="fe kz la lb lc b">outline</code>和<code class="fe kz la lb lc b">box-shadow</code>只适用于形状或SVG的边界框，所以两者都是很好的解决方案<strong class="kd iu">只适用于正方形和矩形</strong>。它们还允许使用自定义属性的灵活颜色。</p><p id="a15a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只用了两行带<code class="fe kz la lb lc b">outline</code>的CSS，加上通过形状保持背景色可见。</p><ul class=""><li id="f7e2" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">🙁仅一种形状的解决方案。</li><li id="40eb" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅简单代码</li><li id="1079" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅的边界是平滑的</li><li id="9e7e" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅透明背景</li></ul><p id="9a1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">box-shadow</code>只需要一行CSS，但是我们必须<strong class="kd iu">确保每个形状都有自己的SVG </strong>，因为我们不能直接将<code class="fe kz la lb lc b">box-shadow</code>应用到形状上。另一件要考虑的事情是，我们必须在声明中应用背景的颜色。</p><ul class=""><li id="7bbe" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">🙁仅一种形状的解决方案</li><li id="14c1" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅简单代码</li><li id="0421" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅的边界是平滑的</li><li id="e784" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁没有透明背景</li></ul><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="14d7" class="mo lm it bd ln mp mq dn lr mr ms dp lv km mt mu lz kq mv mw md ku mx my mh mz bi translated">SVG渐变</h2><p id="2fad" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">SVG径向渐变仅适用于圆形☺️.我们可以直接在笔画上应用渐变，但是最好使用变量，因为我们必须在代码中多次声明颜色。</p><ul class=""><li id="d1cb" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">🙁仅一种形状的解决方案</li><li id="9e8a" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅简单代码</li><li id="da88" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁边框是平滑的</li><li id="bb7a" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁没有透明背景</li></ul><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="cbd2" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">所有形状的解决方案</h1><p id="f69f" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">这些将适用于所有形状，但代码可能会变得臃肿或复杂。</p><h2 id="d21f" class="mo lm it bd ln mp mq dn lr mr ms dp lv km mt mu lz kq mv mw md ku mx my mh mz bi translated"><code class="fe kz la lb lc b">filter:</code>T9】</h2><p id="a849" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">最后，所有形状的一个解决方案！我们必须让每个形状都有自己的<code class="fe kz la lb lc b">&lt;svg&gt;</code>，因为<code class="fe kz la lb lc b">filter</code>不会直接应用到形状上。我们在CSS中使用了一个声明，并且使用了可变的颜色。坏处呢？边界看起来不太平滑。</p><ul class=""><li id="f52c" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">✅为所有形状提供一个解决方案</li><li id="a072" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅简单代码</li><li id="3ee7" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁边框看起来像素化</li><li id="51b9" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁没有透明背景</li></ul><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="4ddf" class="mo lm it bd ln mp mq dn lr mr ms dp lv km mt mu lz kq mv mw md ku mx my mh mz bi translated">SVG过滤器</h2><p id="702a" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">这是一个非常灵活的解决方案。我们可以创建一个过滤器，并通过SVG的<code class="fe kz la lb lc b">filter</code>属性将其添加到形状中。这里复杂的部分是过滤器本身。我们需要三幅画，一幅画外边框，一幅画背景色，最后一幅画正面的形状。结果看起来比使用<code class="fe kz la lb lc b">drop-shadow</code>要好，但是边界仍然是像素化的。</p><ul class=""><li id="fa86" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">✅为所有形状提供一个解决方案</li><li id="426c" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁复杂代码</li><li id="ba88" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁边框看起来像素化</li><li id="254b" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁没有透明背景</li></ul><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="a137" class="mo lm it bd ln mp mq dn lr mr ms dp lv km mt mu lz kq mv mw md ku mx my mh mz bi translated">重用形状</h2><p id="598b" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">这里有几个可能的选择。</p><p id="1e12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">选项1:转换</strong></p><p id="ca6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个解决方案需要转换。我们将一个图形放在另一个图形上，其中主图形有一种填充颜色和一种描边颜色，而另一个图形没有填充颜色，一种红色描边，并且被缩放和重新定位到中心。我们在<code class="fe kz la lb lc b">&lt;defs&gt;</code>上定义了我们的形状。诀窍是<strong class="kd iu">将</strong> <code class="fe kz la lb lc b">viewBox</code> <strong class="kd iu">的一半平移到负空间</strong>，这样，当我们缩放它们时，我们可以从图形的中心开始。</p><ul class=""><li id="8ace" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">✅为所有形状提供一个解决方案</li><li id="a36e" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁重复代码</li><li id="5c85" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅的边界是平滑的</li><li id="ff51" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅透明背景</li></ul><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c4c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">选项二:</strong> <code class="fe kz la lb lc b"><strong class="kd iu">&lt;use&gt;</strong></code></p><p id="2a9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在Doug Schepers的www-svg邮件列表中找到了一个聪明的解决方案。同样，它需要定义形状一次，并使用&lt;使用&gt;引用两次。这次主造型笔画更大。第二个形状的描边是主形状的一半，没有填充，描边与背景色匹配。</p><ul class=""><li id="eced" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">✅为所有形状提供一个解决方案</li><li id="8c97" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁重复代码</li><li id="6134" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">✅的边界是平滑的</li><li id="6c82" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">🙁没有透明背景</li></ul><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="193d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">以下是完整的结果！</h1><p id="f3fb" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">这样你就可以把它们都放在一个地方。如果你能想到其他可能的解决方案，请告诉我！</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="nu nt l"/></div></figure><blockquote class="le lf lg"><p id="41b4" class="kb kc lh kd b ke kf kg kh ki kj kk kl li kn ko kp lj kr ks kt lk kv kw kx ky im bi translated">这篇文章最初发表在<a class="ae ld" href="https://css-tricks.com/how-to-add-a-double-border-to-svg-shapes/" rel="noopener ugc nofollow" target="_blank"> CSS-Tricks </a>上。感谢<a class="ae ld" href="https://chriscoyier.net/" rel="noopener ugc nofollow" target="_blank">克里斯·科伊尔</a>和<a class="ae ld" href="https://geoffgraham.me/" rel="noopener ugc nofollow" target="_blank">杰夫·格拉汉姆</a> ♥的编辑</p></blockquote></div></div>    
</body>
</html>