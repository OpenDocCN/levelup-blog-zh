# 用于 iOS 开发的 GraphQL

> 原文：<https://levelup.gitconnected.com/graphql-for-ios-development-cfeff5bdc043>

![](img/214d82554d8cb9c36b5452d2ddd5aed5.png)

# 什么是 GraphQL(初级读本)

GraphQL 是一种用于 API 的查询语言。它指定了客户端与服务器通信的方式。如果您熟悉 REST API，您可以将它视为一种替代方法。REST APIs 通常被定义为一组端点，这些端点代表可以通过 HTTP 方法执行 CRUD 操作的资源……对于一个博客应用程序(像 Medium)来说，这些资源可能是`Authors`、`Posts`、`Comments`等。在 GraphQL 中，资源不是由 API 端点定义的**而不是**，它们是由客户端自省的模式定义的，然后客户端将制定他们想要的任何查询，只要根据该模式它们是有效的。

![](img/0fe208aaadfb9afc0c2ba670f4c79d5a.png)

！？但这到底意味着什么！？

如果这听起来像是一堆术语，我将尝试简化它:使用 REST， **API 端点决定了什么数据可以通过网络交换。有了 GraphQL 端点，**客户机** **确定**将通过网络交换什么数据，只要它受模式支持。**

从客户端的角度来看，GraphQL 的实现如下:

*   从 GraphQL API 获取模式
*   自省模式以了解哪些操作和类型是可用的
*   为您的客户端构建所需的查询
*   将您的查询指向 GraphQL API 端点。

…稍后将详细介绍。

# 为什么选择 GraphQL？

我们的应用程序本身完全没问题！为什么我要从使用 REST 转向使用 GraphQL？

这个论点是公平的，GraphQL 有一点点的学习曲线……你可能无法通过使用它而不是 REST 来解决太多问题。但它确实非常好地解决了一系列问题:

## 更少的网络呼叫和“特殊端点”

大多数数据模型都是相互关联的，以博客为例:`Users`可能有`Posts` , `Posts`可能有`Comments`，那些评论会有关联的`Users`，如此循环往复。作为 iOS 开发人员，我们都遇到过这样的问题，我们需要链接 API 请求来获得所有的资源，以便填充特定的视图。我们 ***讨厌*** 这个。我们希望尽可能少地访问网络，这样可以获得更干净、更高性能的代码和更好的用户体验。这个问题的一个解决方案是不断地向 API 作者询问“特殊”的端点。这是休息开始崩溃的地方。这个“特殊的”端点不一定代表任何特定的资源，但是它代表了特定客户端将需要的微调响应。API 作者可能不愿意创建这些“特殊的”端点，因为它会分散整个 REST 范式的注意力，并可能导致他们端出现一些混乱的代码…但是出于性能原因，我们通常可以强迫他们这么做。

使用 GraphQL，客户端可以在每个请求中准确地指定它想要的内容，不多也不少。响应的形状将与请求的形状相同。这意味着:

## 不再有对多个资源的链式请求。

## 不再有没有明确要求的无关数据，拥挤的回应

## 对于特殊的端点，不再需要与 API devs 来回切换

# GraphQL:细节

GraphQL 支持三种不同的操作

***查询*** ，取数据。

***突变*** ，哪个(你猜对了！)变异数据。

***订阅*** ，为客户端订阅实时更新。

要执行其中的任何一个，您都必须使用 GraphQL 查询语言来表述它们。

下面是一个查询示例，后面是一个变异示例。要了解更多关于 GraphQL 查询语言语法的信息，请查看文档

```
query HeroNameAndFriends {
  hero {
    name
    friends {
      name
    }
  }
}
```

事实是，当**通过查询获取**数据时，GraphQL 比 REST 更出色，但是所有的 CRUD 操作当然都受 GraphQL 规范的支持。

```
mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {
  createReview(episode: $ep, review: $review) {
    stars
    commentary
  }
}
```

如果您第一次看到这种类型的语法，您肯定会有一些疑问:

*   我如何知道这些字段代表什么数据类型？
*   ***我怎么知道*** `***createView(:)***` ***是我可以在这个 API 上执行的操作？***
*   我怎么知道我可以请求这些字段呢？

嗯，答案很简单 **GraphQL 模式自省。**客户可以自省 API 提供的模式，以生成文档和验证查询。这是我最喜欢 GraphQL 的一点。您不需要关于每个端点的请求/响应数据的文档。一旦你自省了这个模式，你将能够看到这个 API 的所有可能。

在我的工作流程中，我使用了一个叫做*失眠(*[https://insomnia.rest/graphql/](https://insomnia.rest/graphql/))的工具。它充当一个 GraphQL 客户端，可以自省您的模式并生成所有必要的文档。由于失眠症患者现在知道了您的模式，您可以在您的服务器上测试一些查询和变化，并提供完全的自动完成和实时验证支持！

最后，现在我们可以得到这个职位的面包和黄油。你可以用失眠作为客户端，这很可爱，但我们真的希望我们的 iOS 应用程序成为客户端！

# iOS 上 GraphQL 的问题

![](img/86de03104fc95f657dddb5047bc96649.png)

如果你在寻找如何在 iOS 上实现 GraphQL 的参考资料时偶然发现了这篇文章，你可能已经意识到大多数途径都将你带到一个框架: [Apollo Client for iOS](https://www.apollographql.com/docs/ios/) 。

这不一定是个问题，毕竟 Apollo 可能是 GraphQL 在任何平台上的行业标准实现。我要告诉你我在使用阿波罗客户端时遇到的问题。这些问题可能不适用于您的用例，如果不适用，您应该尽快跳到他们的文档中开始！

阿波罗客户端对你的应用程序非常苛刻。它将参与您的建模、网络和缓存层。它将自省您的模式，并允许您用 GraphQL 查询语言在文本文件中编写查询。它将接受您编写的查询，并为您生成代码中的模型和操作。然后，您将使用 Apollo 的网络和缓存抽象在代码中执行这些查询。由于所有这些工作，您可以绝对肯定您的请求将会工作，并且您的模型的形状是正确的(当然，如果 API 的模式在您下面没有改变的话)。

虽然阿波罗客户端会为你做好这一切，但这可能不是你想要的。也许你的应用程序已经有了一个相当广泛的网络层，它有你所依赖的缓存机制。也许你的应用程序使用了过多的 API，而你正慢慢地将其中一些转移到 GraphQL。也许您有一些现有的模型，由于某些特殊的原因，您不想用 Apollo 客户端生成的模型来替换它们。这些都是阻止我将这个框架集成到一个 app 中的原因。对于你来说，它们可能是完全无效的理由，尤其是在你从头开始开发一个将严重依赖 GraphQL 的应用程序的情况下。这些也是我对这个框架的***结论，如果有方法使用它而不遇到这些问题，我很乐意听到它们或者在他们的文档中澄清它们。**

# Apollo 客户端 iOS 的替代方案

如果我们想避免一个笨重的框架的开销，我们将不得不放弃它的一些奢侈品。没有 Apollo-Client，我们可以用几种不同的方式编写请求。我们仍将获得 GraphQL 查询的好处(减少我们的网络调用)，但我们不会直接****享受模式验证，让我们知道我们正在做的事情在我们的 API 上是可能的。

归根结底，GraphQL 请求通常是 HTTP POST 请求主体中的 JSON 编码字符串。这意味着我们可以自己用代码生成这个字符串，然后把它发送给我们的 API。这并不理想，它甚至在 GQL 文档中这样说，作为使用 GQL 变量的论据:

> 直接在查询字符串中传递这些动态参数并不是一个好主意，因为这样我们的客户端代码将需要在运行时动态操作查询字符串，并将其序列化为特定于 GraphQL 的格式

***但是*** ，这真的是我们目前在不集成阿波罗客户端的情况下得到的最好的了。幸运的是，有一些开源库可以让我们以一种非常快捷友好的方式构建我们的 GraphQL 查询。我目前使用的这个叫做 [Sociable Weaver](https://github.com/NicholasBellucci/SociableWeaver) ，它是一个很好的轻量级库，允许我们使用 GraphQL 查询构建由新的`@functionbuilder` Swift 语言特性支持的 DSL。我强烈建议你去看看！

创建一个请求(在这个库中称为`Weave`)看起来像这样:

```
Weave(.query) {
    Object(Post.self) {
        Field(Post.CodingKeys.id)
        Field(Post.CodingKeys.title)
        Field(Post.CodingKeys.content)
    }
}
```

这将生成以下请求

```
query {
    post {
        id
        title
        content
    }
}
```

这是一个非常基本的库，但是这个库可以用来表达更复杂的请求…

那么，如果你想绕开 Apollo 客户端 iOS，使用像 SociableWeaver 这样的库，工作流程会是什么样的呢？

首先，我会推荐使用某种 GraphQL IDE/Playground/Client，不管你想叫它什么(正如我在使用[失眠症 GQL IDE](https://insomnia.rest/graphql/) 之前提到的)。因此，您仍然可以自省 API 的模式并测试请求。这样，您就知道您计划在代码中构建的请求实际上是有效的。此外，这将为您提供完整的 API 文档！

接下来，使用您认为合适的查询构建库来生成您的请求。了解数据是如何从服务器返回的非常重要，这样您就可以正确地解码它。在 GraphQL 中，您将得到一个`data`字段，可能还有一个操作名，您必须钻取它才能得到您的响应对象。

请记住，对于一些 GQL 纯粹主义者来说，这种方法可能看起来不太好，但是我发现对于那些不想进行大规模重构的移动开发人员来说，这种方法非常有用，可以开始支持一些很酷的新 GQL API。我确信会有更多的工具在我们的 iOS 应用中无缝实现 GraphQL！

我希望这有所帮助，并随时留下任何问题或评论！