<html>
<head>
<title>Behind the Scenes of ExpressJS: A Deep Dive into Nodejs’ Most Popular Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ExpressJS的幕后:深入了解Nodejs最受欢迎的库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/expressjs-deep-dive-387f07c50d95?source=collection_archive---------22-----------------------#2022-12-19">https://levelup.gitconnected.com/expressjs-deep-dive-387f07c50d95?source=collection_archive---------22-----------------------#2022-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/403fc7aecd2c59c57d0390076fec1ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAIoObWqwP2P-EMJjBEdqQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">快速JS内部</figcaption></figure><p id="4f7c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Express是最常用的Nodejs库之一，真正了解这个库而不仅仅是一个用户是非常重要的。它不是一个复杂的库，在这篇文章中，我们想深入了解内部发生了什么。这可能有助于我们更好地了解我们的express应用程序何时出现问题。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="2a38" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">你将在这篇文章中读到什么</h1><p id="496b" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">本文假设您已经对ExpressJS有所了解，并且希望对ExpressJS有更深入的了解。</p><p id="b42e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们来看看<em class="mk">为什么表达很重要，以及它的利弊。</em></p><p id="7bc9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们要检查一下<strong class="ke ir"> ExpressJS </strong>的源代码，并指出重要的部分:</p><ul class=""><li id="646c" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mq mr ms mt bi translated"><em class="mk">创建快递应用</em></li><li id="daaf" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated"><em class="mk">添加中间件</em></li><li id="a3cc" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated"><em class="mk">处理请求</em></li><li id="aa53" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated"><em class="mk">下一个功能</em></li></ul></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="bb0e" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">为什么要快递？</h1><p id="92e3" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">Express仍然是世界上使用最多的后端框架之一，因此值得一试，看看它的优缺点，然后深入了解内部实现。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/97f4d61aaa54edf71be25d7047752f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HobgUJcldYro71ioSgLWA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">最流行的后端框架</figcaption></figure><p id="40d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我已经在ExpressJS工作了5年，根据我的个人经验，这些是优点和缺点。</p><h2 id="3cc1" class="ne li iq bd lj nf ng dn ln nh ni dp lr kn nj nk lv kr nl nm lz kv nn no md np bi translated">赞成的意见</h2><ul class=""><li id="5641" class="ml mm iq ke b kf mf kj mg kn nq kr nr kv ns kz mq mr ms mt bi translated"><strong class="ke ir">广泛使用</strong>:正如你在这个视觉报告中看到的，对工作机会的需求仍然很大。</li><li id="4b66" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated"><strong class="ke ir">社区和大量集成工具</strong>:由于有这么多人在使用ExpressJS，你可以找到许多库来解决围绕ExpressJS的问题。</li><li id="2ce5" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated"><strong class="ke ir">简单</strong>:初级开发人员需要花几分钟时间学会如何用ExpressJS创建一个简单的应用。</li><li id="f864" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated"><strong class="ke ir">中间件</strong>:如今，中间件的思想已经在大多数框架中实现，这是一件好事，它解决了应用程序中一些重复出现的问题。</li></ul><h2 id="7d90" class="ne li iq bd lj nf ng dn ln nh ni dp lr kn nj nk lv kr nl nm lz kv nn no md np bi translated">骗局</h2><ul class=""><li id="00af" class="ml mm iq ke b kf mf kj mg kn nq kr nr kv ns kz mq mr ms mt bi translated"><strong class="ke ir">性能</strong>:你可以在基准测试中看到，它并不是Nodejs中最快的HTTP库，与类似<a class="ae nt" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> Fastify </strong> </a>的东西相比，它要慢一些！</li><li id="7b7d" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">安全:默认情况下，它不提供一些安全检查所需的功能或验证，所以你需要自己实现或使用第三方库。</li></ul><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/2915dae139aa8308c15668f7e9c50fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04cQ9rRWAzOA_oSk1x7awg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Nodejs框架<a class="ae nt" href="https://www.fastify.io/benchmarks/" rel="noopener ugc nofollow" target="_blank">基准</a> 2022</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="ae72" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">让我们看看Express是如何处理请求的！</h1><h2 id="fbea" class="ne li iq bd lj nf ng dn ln nh ni dp lr kn nj nk lv kr nl nm lz kv nn no md np bi translated">克隆Express的存储库</h2><p id="76cf" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">使用以下命令之一:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="1dff" class="oa li iq nw b be ob oc l od oe">git clone https://github.com/expressjs/express.git</span></pre><pre class="of nv nw nx bn ny nz bi"><span id="c0bb" class="oa li iq nw b be ob oc l od oe">git clone git@github.com:expressjs/express.git</span></pre><p id="a31f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你不想克隆这个库，完全没问题，我把重要的代码放在这里。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="7206" class="ne li iq bd lj nf ng dn ln nh ni dp lr kn nj nk lv kr nl nm lz kv nn no md np bi translated"><strong class="ak">当我们创建一个Express app(创建应用程序功能)时会发生什么？</strong></h2><p id="ef7e" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">我们通常这样创建我们的Express实例:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="ad61" class="oa li iq nw b be ob oc l od oe">const app = require('express')();</span></pre><p id="a315" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们正在运行默认的导出函数。我们可以在<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/express.js" rel="noopener ugc nofollow" target="_blank">lib/express.js</a></code>中找到这个函数</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="f46e" class="oa li iq nw b be ob oc l od oe">var bodyParser = require('body-parser');<br/>var EventEmitter = require('events').EventEmitter;<br/>var mixin = require('merge-descriptors');<br/>var proto = require('./application');<br/>var Route = require('./router/route');<br/>var Router = require('./router');<br/>var req = require('./request');<br/>var res = require('./response');<br/><br/>exports.json = bodyParser.json;<br/>exports.text = bodyParser.text;<br/>exports.raw = bodyParser.raw;<br/>exports.urlencoded = bodyParser.urlencoded;<br/><br/>exports = module.exports = createApplication;<br/><br/>function createApplication() {<br/>  var app = function(req, res, next) {<br/>    app.handle(req, res, next);<br/>  };<br/><br/>  mixin(app, EventEmitter.prototype, false);<br/>  mixin(app, proto, false);<br/><br/>  // expose the prototype that will get set on requests<br/>  app.request = Object.create(req, {<br/>    app: { configurable: true, enumerable: true, writable: true, value: app }<br/>  })<br/><br/>  // expose the prototype that will get set on responses<br/>  app.response = Object.create(res, {<br/>    app: { configurable: true, enumerable: true, writable: true, value: app }<br/>  })<br/><br/>  app.init();<br/>  return app;<br/>}</span></pre><p id="65ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以默认功能是<code class="fe og oh oi nw b">createApplication</code>。</p><p id="644b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看这方面的进展:</p><p id="4c5d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/body-parser" rel="noopener ugc nofollow" target="_blank">body-parser</a></code>库是导入的，使用过四种方法:<code class="fe og oh oi nw b">json</code>、<code class="fe og oh oi nw b">text</code>、<code class="fe og oh oi nw b">urlencoded</code>和<code class="fe og oh oi nw b">raw</code>。因此，每次您在Express应用程序中调用<code class="fe og oh oi nw b">res.json({ someData: true })</code>时，您实际上都在使用<code class="fe og oh oi nw b">body-parser</code>库。(如果你想知道这个库是如何解析你的请求体的，请查看这个文件)</p><p id="8e79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe og oh oi nw b">createApplication</code>函数中有一个名为<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/express.js#L42" rel="noopener ugc nofollow" target="_blank">mixin</a></code>的函数，它是<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/component/merge-descriptors" rel="noopener ugc nofollow" target="_blank">merge-descriptors</a></code>库。这个函数只是将第二个参数的方法添加到传递的第一个对象中。</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="f0eb" class="oa li iq nw b be ob oc l od oe">const mixin = require('merge-describpto')<br/>var thing = {<br/>  get name() {<br/>    return 'jon'<br/>  }<br/>};<br/>var animal = {<br/>};<br/>mixin(animal, thing);<br/>animal.name === 'jon'</span></pre><p id="587b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">两个对象与我们的express实例混合在一起。第一个是<a class="ae nt" href="https://javascript.plainenglish.io/how-we-can-use-node-js-event-emitter-5c9e39c38749" rel="noopener ugc nofollow" target="_blank">事件发射器</a>，用于事件发射行为(我们希望监听类似错误的事件，并且我们还希望发射一些事件来让监听器知道已经发生了一些事情)，第二个是<code class="fe og oh oi nw b">proto</code>，它是存储库中的这个文件:<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/application.js" rel="noopener ugc nofollow" target="_blank">lib/application.js</a></code></p><p id="95d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/express.js#L70" rel="noopener ugc nofollow" target="_blank">createApplication</a></code>的第三部分，它从这两个文件中分配<code class="fe og oh oi nw b">request</code>和<code class="fe og oh oi nw b">response</code>对象:</p><p id="4298" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/request.js" rel="noopener ugc nofollow" target="_blank">lib/request.js</a></code>和<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/response.js" rel="noopener ugc nofollow" target="_blank">lib/response.js</a></code>。</p><p id="25e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里找到的另一个方法是<code class="fe og oh oi nw b">listen</code>:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="f8f9" class="oa li iq nw b be ob oc l od oe">app.listen = function listen() {<br/>  var server = http.createServer(this);<br/>  return server.listen.apply(server, arguments);<br/>};</span></pre><p id="acc7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这里，您可以看到express将处理请求的对象传递到这里，并将所有逻辑传递到Nodejs HTTP核心库。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="4f40" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">快速路由器:添加中间件</strong></p><p id="8ccc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们在Express instance上使用的一个重要方法是<code class="fe og oh oi nw b">use</code>函数，当我们想要在我们的应用程序上注册一个中间件时(<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/router/route.js" rel="noopener ugc nofollow" target="_blank">lib/router/index.js</a></code>):</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="ac93" class="oa li iq nw b be ob oc l od oe">proto.use = function use(fn) {<br/>  var offset = 0;<br/>  var path = '/';<br/><br/>  // default path to '/'<br/>  // disambiguate router.use([fn])<br/>  if (typeof fn !== 'function') {<br/>    var arg = fn;<br/><br/>    while (Array.isArray(arg) &amp;&amp; arg.length !== 0) {<br/>      arg = arg[0];<br/>    }<br/><br/>    // first arg is the path<br/>    if (typeof arg !== 'function') {<br/>      offset = 1;<br/>      path = fn;<br/>    }<br/>  }<br/><br/>  var callbacks = flatten(slice.call(arguments, offset));<br/><br/>  if (callbacks.length === 0) {<br/>    throw new TypeError('Router.use() requires a middleware function')<br/>  }<br/><br/>  for (var i = 0; i &lt; callbacks.length; i++) {<br/>    var fn = callbacks[i];<br/><br/>    if (typeof fn !== 'function') {<br/>      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))<br/>    }<br/><br/>    // add the middleware<br/>    debug('use %o %s', path, fn.name || '&lt;anonymous&gt;')<br/><br/>    var layer = new Layer(path, {<br/>      sensitive: this.caseSensitive,<br/>      strict: false,<br/>      end: false<br/>    }, fn);<br/><br/>    layer.route = undefined;<br/><br/>    this.stack.push(layer);<br/>  }<br/><br/>  return this;<br/>};</span></pre><p id="4881" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个函数的第一部分，它检查是否只有一个中间件被传递，或者它是否是一个数组。如你所知，我们可以这样使用它:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="a0e4" class="oa li iq nw b be ob oc l od oe">app.use(firstMiddleware, secondMiddleware);<br/>app.use([firstMiddleware, secondMiddleware]);</span></pre><p id="443b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，它检查并返回一个错误，如果没有中间件通过。如果我使用这样的代码，我会得到这个错误:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="e1c5" class="oa li iq nw b be ob oc l od oe">app.use(); // or app.use([])</span></pre><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/fbd7c2cc35de013c5795b90c4a9566dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bS5r6oGYzyQFEflk88g4w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">没有向应用程序传递中间件时出错。使用函数</figcaption></figure><p id="8465" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如你所见，这是我们得到的同一个错误:<code class="fe og oh oi nw b">requires a middleware function</code>。</p><p id="e0ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下一部分，你会看到<strong class="ke ir">使</strong>回调变平。这也很重要。我们甚至可以在嵌套数组中传递中间件。一个例子是这样的:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="d0ad" class="oa li iq nw b be ob oc l od oe">const app = require('./lib/express')();<br/><br/>const first = (req, res, next) =&gt; {console.log('first');next();}<br/>const second = (req, res, next) =&gt; {console.log('second');next();}<br/>const third = (req, res, next) =&gt; {console.log('third');res.send('text');}<br/><br/>app.use([first, [second, third]]);</span></pre><p id="bcab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此<code class="fe og oh oi nw b">use</code>函数需要将这些中间件展平为一个数组，如下所示:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="d2af" class="oa li iq nw b be ob oc l od oe">[1, [2, 3]] =&gt; Flatten =&gt; [1, 2, 3]</span></pre><p id="c963" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是这个<strong class="ke ir">展平</strong>功能正在做的事情。现在我们有了一组中间件，我们需要循环遍历它们，并添加它们以保存在某个地方。这是下一步:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="9c82" class="oa li iq nw b be ob oc l od oe">var layer = new Layer(path, {<br/>      sensitive: this.caseSensitive,<br/>      strict: false,<br/>      end: false<br/>    }, fn);<br/><br/>layer.route = undefined;<br/><br/>this.stack.push(layer);</span></pre><p id="da65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这一部分最重要的事情是，我们将这些中间件(以稍微不同的形式)添加到一个实现了<code class="fe og oh oi nw b">push</code>函数的对象或数组中，称为<code class="fe og oh oi nw b">stack</code>这是Express保存中间件并在需要时执行函数的地方。<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/router/layer.js#L33" rel="noopener ugc nofollow" target="_blank">Layer</a></code>是一个简单的构造函数，以不同的形式保存中间件的数据:</p><p id="5451" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里找到图层:<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/router/layer.js#L33" rel="noopener ugc nofollow" target="_blank">lib/router/layer.js</a></code>。如你所见，这只是一些任务，并没有真正重要的事情发生。</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="e83a" class="oa li iq nw b be ob oc l od oe">function Layer(path, options, fn) {<br/>  if (!(this instanceof Layer)) {<br/>    return new Layer(path, options, fn);<br/>  }<br/><br/>  debug('new %o', path)<br/>  var opts = options || {};<br/><br/>  this.handle = fn;<br/>  this.name = fn.name || '&lt;anonymous&gt;';<br/>  this.params = undefined;<br/>  this.path = undefined;<br/>  this.regexp = pathRegexp(path, this.keys = [], opts);<br/><br/>  // set fast path flags<br/>  this.regexp.fast_star = path === '*'<br/>  this.regexp.fast_slash = path === '/' &amp;&amp; opts.end === false<br/>}</span></pre><h2 id="3fa2" class="ne li iq bd lj nf ng dn ln nh ni dp lr kn nj nk lv kr nl nm lz kv nn no md np bi translated">快速路由器:处理请求和下一个功能</h2><p id="8339" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">我们看到我们有一个名为<code class="fe og oh oi nw b">handle</code>的函数。</p><p id="8d47" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们想看看请求是如何处理的。它调用这个文件<code class="fe og oh oi nw b">lib/router/index.js</code>中的<code class="fe og oh oi nw b">handle</code>函数。<code class="fe og oh oi nw b">proton.handle</code>:</p><p id="ef34" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我有意删除了handle函数的一些部分，以便我们可以专注于重要的部分:</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="08ba" class="oa li iq nw b be ob oc l od oe">proto.handle = function handle(req, res, out) {<br/>  var self = this;<br/>  var idx = 0;<br/>  var sync = 0;<br/>  // middleware and routes<br/>  var stack = self.stack;<br/>  // setup next layer<br/>  req.next = next;<br/>  next();<br/>  // ... here is the next function implementation<br/>};</span></pre><p id="3190" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe og oh oi nw b">idx</code>用于跟踪中间件数组中的当前索引(<code class="fe og oh oi nw b">stack</code>)。它调用下一个函数。让我们看看<strong class="ke ir">下一个函数</strong>的实现。(同样在这里，删除了一些部分，以专注于主要部分)</p><pre class="na nb nc nd gt nv nw nx bn ny nz bi"><span id="2eac" class="oa li iq nw b be ob oc l od oe">  function next(err) {<br/>    // no more matching layers<br/>    if (idx &gt;= stack.length) {<br/>      setImmediate(done, layerError);<br/>      return;<br/>    }<br/>    // find next matching layer<br/>    var layer;<br/>    var match;<br/>    var route;<br/>    while (match !== true &amp;&amp; idx &lt; stack.length) {<br/>      layer = stack[idx++];<br/>      // Match the current path and middlewares<br/>      match = matchLayer(layer, path);<br/>      route = layer.route;<br/>      if (match !== true) {<br/>        continue;<br/>      }<br/>      if (layerError) {<br/>        // routes do not match with a pending error<br/>        match = false;<br/>        continue;<br/>      }<br/><br/>      var method = req.method;<br/>      var has_method = route._handles_method(method);<br/>    }<br/><br/>    // no match<br/>    if (match !== true) {<br/>      return done(layerError);<br/>    }<br/><br/>    // store route for dispatch on change<br/>    if (route) {<br/>      req.route = route;<br/>    }<br/><br/>    // this should be done for the layer<br/>    self.process_params(layer, paramcalled, req, res, function (err) {<br/>      if (err) {<br/>        next(layerError || err)<br/>      } else if (route) {<br/>        layer.handle_request(req, res, next)<br/>      } else {<br/>        trim_prefix(layer, layerError, layerPath, path)<br/>      }<br/><br/>      sync = 0<br/>    });<br/>  }</span></pre><p id="5b95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它检查的第一件事是是否有更多应该检查的中间件:<code class="fe og oh oi nw b">if (idx &gt;= stack.length)</code>所以如果没有更多需要检查的，它就返回。</p><p id="badd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步是检查哪些层符合当前请求。您会看到一个<em class="mk"> while循环</em>，它会一直运行，直到找到匹配的中间件。在while循环中，您可以看到一个查找匹配的检查:<code class="fe og oh oi nw b"><a class="ae nt" href="https://github.com/expressjs/express/blob/master/lib/router/index.js#L226" rel="noopener ugc nofollow" target="_blank">match = matchLayer(layer, path);</a></code>。</p><p id="d1f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">实现的最后一部分是调用<code class="fe og oh oi nw b">self.process_params</code>进行一些检查，如果没有错误，它最终调用<code class="fe og oh oi nw b">layer.handle_request</code>，这是您传递给匹配中间件的函数<code class="fe og oh oi nw b">(req, res, next)=&gt;{...}</code>。如果该中间件返回响应，则处理该请求的过程完成，否则，它调用<code class="fe og oh oi nw b">next</code>函数，并再次进入相同的过程，只是值<code class="fe og oh oi nw b">idx</code>有一个简单的不同，因此它在中间件数组中找到下一个匹配。</p><h1 id="1e9e" class="lh li iq bd lj lk ok lm ln lo ol lq lr ls om lu lv lw on ly lz ma oo mc md me bi translated">摘要</h1><p id="4189" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">尽管我们忽略了ExpressJS实现中的许多细节，但我们对express将中间件放在哪里以及如何处理每个请求有了更好的理解。</p><p id="b522" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们检查的第一件事是Express实例的创建，以及Express如何向该对象添加不同的功能，并最终用<code class="fe og oh oi nw b">listen</code>函数服务于HTTP服务器。</p><p id="f431" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们看到，通过调用Express实例上的<code class="fe og oh oi nw b">use</code>或方法函数，我们可以将这些中间件添加到一个名为<code class="fe og oh oi nw b">stack</code>的对象中。</p><p id="a007" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了处理一个请求，Express调用handle函数，并在一些检查和参数改变之后调用<em class="mk">下一个函数</em>，并且<em class="mk">下一个函数</em>可以访问中间件所在的<code class="fe og oh oi nw b">stack</code>对象，然后它在中间件上循环，如果发现匹配，它就调用中间件。</p><div class="op oq gp gr or os"><a href="https://statisticsanddata.org/data/most-popular-backend-frameworks-2012-2022/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">2012/2022年最受欢迎的后端框架</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">最受欢迎的后端框架- 2012/2022。阅读更多了解2012-2022年最流行的后端框架。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">statisticsanddata.org</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg jw os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://www.fastify.io/benchmarks/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">基准</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">利用我们在Node.js性能方面的经验，Fastify已经从头开始构建，速度可与…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">www.fastify.io</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg jw os"/></div></div></a></div></div></div>    
</body>
</html>