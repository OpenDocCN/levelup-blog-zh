<html>
<head>
<title>Software Engineering is a Loser’s Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件工程是失败者的游戏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/software-engineering-is-a-losers-game-94cf1f4df0c6?source=collection_archive---------12-----------------------#2021-09-20">https://levelup.gitconnected.com/software-engineering-is-a-losers-game-94cf1f4df0c6?source=collection_archive---------12-----------------------#2021-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">要变得更好，从你的错误中学习，停止犯非受迫性错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6cb14a7d14409ce6cf6b931ef58ac7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kY92CDuwIXKm9o1s"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nathanael240606?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">nathanal Desmeules</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="aea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近迷上了“赢家的游戏”和“输家的游戏”的概念有几篇很棒的文章深入地解释了这个想法，但是这里有一个简短的总结:</p><p id="04bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Simon Ramo在1973年观察到，业余网球和职业网球比赛的获胜方式有很大的不同。</p><p id="6e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个业余对手在比赛时，比赛往往不是通过胜利者的高超技巧而是由于失败者的失误而获胜。失败者经常犯非受迫性失误，如击球出界、错过容易的击球或双误。换句话说，输的人打自己。失败者“失去”的分数多于胜利者“赢得”的分数。这是一场“失败者的游戏”</p><p id="53a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个职业对手在比赛时，比赛的胜负主要取决于胜者的技巧。两个球员都没有犯很多非受迫性错误。胜利者把他的球打得很好，并且胜过他的对手来击败他。在这种游戏中，胜利者“赢得”的点数多于失败者“失去”的点数。这是一场“赢家的游戏”</p><p id="12d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果你在玩一个失败者的游戏，一个成功的策略就是尽量避免犯错，让你的对手打败自己。</p><p id="160f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(如果你以前打过网球或乒乓球，我希望此时你点头表示认可。作为一名狂热的乒乓球运动员，我每天都在办公室里看到这样的场景。)</p><p id="bdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个观察的应用是，你应该试图理解你参与的任何给定的活动是赢家的游戏还是输家的游戏。获得这种理解会教会你应该如何玩这个游戏。</p><p id="90cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在Charles Ellis的这篇<a class="ae ky" href="https://www.empirical.net/wp-content/uploads/2012/06/the_losers_game.pdf" rel="noopener ugc nofollow" target="_blank">文章</a>、FS博客的这篇<a class="ae ky" href="https://fs.blog/2014/06/avoiding-stupidity/" rel="noopener ugc nofollow" target="_blank">文章</a>或者Ben Hosking的这篇<a class="ae ky" href="https://thehosk.medium.com/software-development-is-a-losers-game-fc68bb30d7eb" rel="noopener">文章</a>中读到更多关于这些想法的内容。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dcd4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">与软件工程相似</h1><p id="6e12" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，如果我们认为软件工程是失败者的游戏呢？也就是说，我们经常通过犯非受迫性错误和犯错来打败自己。如果我们是业余爱好者，可以这么说，我们如何让球保持在比赛中，而不是把它打到网里？</p><p id="e891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说“如果你想变好，就停止犯错”是很简单的事情。但这多少有些于事无补。这就像对那些贫穷的人说，“你为什么不停止贫穷？”</p><p id="0101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把这个类比做得太过，也是无益的。如果避免错误是软件工程的终极目标，那么最好的软件工程师就是不写代码或者什么都不做的人吗？显然，不是的。软件工程师是靠写代码来帮助实现一些产品，以实现一些愿景(赚钱、解决现实世界的问题、简化任务等)。)，所以那一定是真正的终极目标。</p><p id="1e5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，看来我们必须在生产有价值的产品和避免错误之间取得平衡。这就引出了一个有趣的思想实验:我们在哪些方面战胜了自己，如何才能避免犯这些业余错误？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="31ca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">非受迫性失误</h1><p id="000a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">以下是我们可能犯的非受迫性错误的列表。我相信你也可以在这个列表中添加更多的内容。</p><ul class=""><li id="4f5e" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">在尝试编码解决方案之前不了解问题</li><li id="d2a7" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">不了解我们使用的工具或编程语言</li><li id="29c3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在要求代码审查之前，没有仔细审查我们自己的代码</li><li id="19af" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在要求代码评审之前，不要手工测试我们自己的代码</li><li id="3bed" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">不编写单元测试</li><li id="a05f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">不遵守商定的公司标准</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b4ca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决这些非受迫性错误</h1><p id="6551" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们已经确定了一些潜在的非受迫性错误，我们如何避免犯这些错误呢？</p><p id="0ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们可以实施保护措施，帮助我们在错误变得代价高昂之前发现并纠正错误。所有代码仓库都应该配置代码链接器、代码格式化器和一套自动化测试。在允许任何代码被合并之前，这些安全措施可以作为CI管道的一部分运行。</p><p id="8b64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编写代码时，我们也可以更彻底地关注细节。在创建了一个合并请求之后，我们应该总是在请求其他人审查我们的代码之前进行自我代码审查。我们也应该总是手动验证我们的更改。</p><p id="2285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个代码审查者，没有什么比审查别人的代码更令人沮丧的了，这些代码显然不是他们自己做的。当代码评审者不得不捕捉简单的错误，如注释掉的代码、错误的格式、失败的单元测试或代码中损坏的功能时，这浪费了他的时间。所有这些错误都很容易被代码作者或CI管道发现。</p><p id="70a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当合并请求经常充满错误时，它将代码审查过程变成了一个把关过程，在这个过程中，少数更高级的工程师充当把关者。这是一个不利的场景，会产生瓶颈并降低团队的速度。它还分散了代码评审的更高目的，即知识共享。</p><p id="cff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用清单和合并请求模板来提醒自己要仔细检查的事情。你审查过你自己的代码吗？你写过单元测试吗？您是否根据需要更新了任何文档？对于前端代码，您是否在公司支持的每个浏览器中验证了您的更改？你确保所有面向用户的文本都被翻译了吗？您是否确保了UI符合可访问性标准和指南？</p><p id="89d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在自动化工具的帮助下，通过我们自己进行这些检查，我们表现出了更多的专业精神和对同事的尊重。信任会增长，速度会提高。关键是要勤快自律。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1b9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="785d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">软件工程是失败者的游戏。所以让我们学会玩游戏，不要再输给自己了。</p></div></div>    
</body>
</html>