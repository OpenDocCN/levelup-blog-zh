<html>
<head>
<title>Achieving asynchronous behavior using asyncio in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用asyncio实现异步行为</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/achieving-asynchronous-behavior-using-asyncio-in-python-e09153defbd9?source=collection_archive---------27-----------------------#2020-09-14">https://levelup.gitconnected.com/achieving-asynchronous-behavior-using-asyncio-in-python-e09153defbd9?source=collection_archive---------27-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/edfffca802b11edc9656c2baffe29a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wjojNkhTHSa-wREU.png"/></div></div></figure><p id="f2b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自从我上次发表关于使用celery在Python中处理长时间运行的异步任务的文章以来，发生了很多变化。上次我们用它来运行一些异步任务，从一些服务<a class="ae kz" href="https://ranvir.xyz/blog/using-celery-to-run-long-running-task-asynchronously" rel="noopener ugc nofollow" target="_blank">中获取数据，大约需要1-5分钟</a>。</p><p id="72d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管我仍将使用celery来处理这些类型的长时间运行的任务，但是有一部分任务更适合在执行线程内部处理。今天我们将讨论处理这种操作的方法。</p><p id="7302" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于认识我的人来说，一年前我换了一个新的角色，这让我可以编写Node.js，从那以后我一直在从事这项工作。在我使用它工作和构建API的过程中，我开始喜欢Node处理<a class="ae kz" href="https://ranvir.xyz/blog/basic-introduction-to-node.js-async-await" rel="noopener ugc nofollow" target="_blank">异步行为和长期运行任务</a>的方式。</p><p id="a774" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个想法很简单，如果任务正在等待IO，我们可以同时运行其他任务。只有需要它的部分，才会等待它。</p><p id="ba76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想在Python中使用同样的概念。</p><p id="f04d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，在Python版本<code class="fe la lb lc ld b">3.4</code>中，他们为了同样的目的引入了<code class="fe la lb lc ld b">asyncio</code>。在这篇文章中，我们将谈一点，并试图理解它的重要性。</p><p id="d028" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章的结尾，你将能够理解异步函数的重要性，并且能够开始在你的代码库中使用它们。</p><h1 id="9d1d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">先决条件</h1><p id="a0b8" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我在本教程中使用了<code class="fe la lb lc ld b">Python 3.8</code>,你可能也想使用它来运行和测试例子。你也可以在网上试试<a class="ae kz" href="https://www.python.org/shell/" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="ceef" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python中的基本异步函数</h1><p id="ace8" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">这就是我们如何用Python写一个基本的异步函数。</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="92e2" class="mp lf it ld b gy mq mr l ms mt">import asyncio</span><span id="136f" class="mp lf it ld b gy mu mr l ms mt">async def func1(a):<br/>    print(f"started func 1: {a + 1}")<br/>    await asyncio.sleep(1)<br/>    return a + 1</span><span id="027b" class="mp lf it ld b gy mu mr l ms mt">asyncio.run(func1(1))</span></pre><p id="63d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">响应</strong></p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="d7f5" class="mp lf it ld b gy mq mr l ms mt">started func 1: 2<br/>2</span></pre><p id="9557" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你必须从导入<code class="fe la lb lc ld b">asyncio</code>模块开始。异步函数的定义就像普通函数一样，你只需要添加关键字<code class="fe la lb lc ld b">async</code>。如果你想等待某个<a class="ae kz" href="https://docs.python.org/3/library/asyncio-task.html#coroutines" rel="noopener ugc nofollow" target="_blank">协程</a>的执行，你必须使用关键字<code class="fe la lb lc ld b">await</code>。最后，您可以使用<code class="fe la lb lc ld b">asyncio.run</code>方法运行该函数。</p><blockquote class="mv mw mx"><p id="02e4" class="kb kc my kd b ke kf kg kh ki kj kk kl mz kn ko kp na kr ks kt nb kv kw kx ky im bi translated"><em class="it">无论何时在异步函数中使用await关键字，线程都不会向前移动，直到我们从被调用的函数得到响应。</em></p></blockquote><p id="3436" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个简单的实现不会帮助您理解使用异步函数的优势。在下一节中，我们将讨论执行所用的时间，在那里您将真正开始看到差异。</p><h1 id="51c2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">完全执行所用的时间</h1><p id="9431" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">为了理解使用<code class="fe la lb lc ld b">async</code>函数的好处，我们将比较在<code class="fe la lb lc ld b">async</code>和<code class="fe la lb lc ld b">sync</code>行为中运行相同代码所花费的时间。</p><p id="5c1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先编写异步代码。</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="08a9" class="mp lf it ld b gy mq mr l ms mt">import asyncio<br/>import time<br/>start = time.time()</span><span id="7b78" class="mp lf it ld b gy mu mr l ms mt">async def async_sleep():<br/>    await asyncio.sleep(1)</span><span id="be79" class="mp lf it ld b gy mu mr l ms mt">async def func1(a):<br/>    print(f"started func 1: {a + 1}")<br/>    await async_sleep()<br/>    return a + 1</span><span id="233b" class="mp lf it ld b gy mu mr l ms mt">async def func2(a):<br/>    print(f"started func 2: {a + 2}")<br/>    await async_sleep()<br/>    return a + 2</span><span id="d2a2" class="mp lf it ld b gy mu mr l ms mt">async def func3(a):<br/>    print(f"started func 3: {a + 3}")<br/>    await async_sleep()<br/>    return a + 3</span><span id="9c27" class="mp lf it ld b gy mu mr l ms mt">async def func4(a):<br/>    print(f"started func 4: {a + 4}")<br/>    await async_sleep()<br/>    return a + 4</span><span id="21a8" class="mp lf it ld b gy mu mr l ms mt">async def main():<br/>    tasks = (func1(1), func2(1), func3(1), func4(1))<br/>    await asyncio.gather(*tasks)<br/>    print(f"Completed after: {time.time() - start}")</span><span id="b965" class="mp lf it ld b gy mu mr l ms mt">asyncio.run(main())</span></pre><p id="f08e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我定义了4个不同的函数做几乎相同的事情。让我们假设有一个名为<code class="fe la lb lc ld b">async_sleep</code>的长期运行的函数正在进行一些IO操作。例如:从数据库中获取数据。</p><blockquote class="mv mw mx"><p id="d0e3" class="kb kc my kd b ke kf kg kh ki kj kk kl mz kn ko kp na kr ks kt nb kv kw kx ky im bi translated"><code class="fe la lb lc ld b"><em class="it">asyncio.gather()</em></code> <em class="it">用于并发运行传递给它的任务。</em></p></blockquote><p id="baf7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行这段代码后的响应如下。</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="09a9" class="mp lf it ld b gy mq mr l ms mt">started func 1: 2<br/>started func 2: 3<br/>started func 3: 4<br/>started func 4: 5<br/>Completed after: 1.1852593421936035</span></pre><p id="c15b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于每次执行，该函数大约在1-2秒内完成执行。(运行5次以进行检查)。</p><p id="17a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们试着运行相同代码的<code class="fe la lb lc ld b">sync</code>版本。</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="a854" class="mp lf it ld b gy mq mr l ms mt">import time<br/>start = time.time()</span><span id="46c3" class="mp lf it ld b gy mu mr l ms mt">def sync_sleep():<br/>    time.sleep(1)</span><span id="dd68" class="mp lf it ld b gy mu mr l ms mt">def func1(a):<br/>    print(f"started func 1: {a + 1}")<br/>    sync_sleep()<br/>    return a + 1</span><span id="5639" class="mp lf it ld b gy mu mr l ms mt">def func2(a):<br/>    print(f"started func 2: {a + 2}")<br/>    sync_sleep()<br/>    return a + 2</span><span id="0d96" class="mp lf it ld b gy mu mr l ms mt">def func3(a):<br/>    print(f"started func 3: {a + 3}")<br/>    sync_sleep()<br/>    return a + 3</span><span id="79a1" class="mp lf it ld b gy mu mr l ms mt">def func4(a):<br/>    print(f"started func 4: {a + 4}")<br/>    sync_sleep()<br/>    return a + 4</span><span id="946c" class="mp lf it ld b gy mu mr l ms mt">def main():<br/>    func1(1)<br/>    func2(1)<br/>    func3(1)<br/>    func4(1)<br/>    print(f"Completed after: {time.time() - start}")</span><span id="1f4a" class="mp lf it ld b gy mu mr l ms mt">main()</span></pre><p id="4895" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行此操作后，我们得到的回应是:</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="f039" class="mp lf it ld b gy mq mr l ms mt">started func 1: 2<br/>started func 2: 3<br/>started func 3: 4<br/>started func 4: 5<br/>Completed after: 4.168870687484741</span></pre><p id="1a8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这为我们执行4个功能节省了<code class="fe la lb lc ld b">~3</code>秒。现在，如果我们想运行10000个这样的函数，我们可以节省<code class="fe la lb lc ld b">~2000</code>秒/即<code class="fe la lb lc ld b">35-40</code>分钟。</p><p id="c0e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太棒了，对吧。</p><p id="5227" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使我们在每次迭代中只运行2-3个这样的函数，这些小的节省对于为您的客户提供更好的用户体验也是非常重要的。</p><p id="ffb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们已经理解了使用<code class="fe la lb lc ld b">async</code>函数的优点，我们必须知道更多关于它的事情。</p><h1 id="eb82" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">异步函数的执行顺序</h1><p id="d161" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们应该明白，在异步模式下运行函数时，我们并不真正知道函数执行的顺序。让我们用一个例子来理解这个概念。</p><p id="35a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦执行完成，函数就会返回。我们可以通过使用<code class="fe la lb lc ld b">random.randint(0, 10) * 0.1</code>在0和1之间随机休眠一段时间来模拟不同的执行时间。</p><p id="b881" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是完整的代码。</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="d67b" class="mp lf it ld b gy mq mr l ms mt">import asyncio<br/>import time<br/>import random<br/>start = time.time()</span><span id="ee29" class="mp lf it ld b gy mu mr l ms mt">def random_sleep_time():<br/>    return random.randint(0, 10) * 0.1</span><span id="47f6" class="mp lf it ld b gy mu mr l ms mt">async def async_sleep():<br/>    await asyncio.sleep(random_sleep_time())</span><span id="cec2" class="mp lf it ld b gy mu mr l ms mt">async def func1(a):<br/>    await async_sleep()<br/>    print(f"completed func {a}: {a + 1}")<br/>    return a + 1</span><span id="2550" class="mp lf it ld b gy mu mr l ms mt">async def main():<br/>    tasks = [func1(a) for a in range(0, 5)]<br/>    await asyncio.gather(*tasks)<br/>    print(f"Completed after: {time.time() - start}")</span><span id="3d4c" class="mp lf it ld b gy mu mr l ms mt">asyncio.run(main())</span></pre><p id="7b96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对以下代码的响应是，</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="d5a5" class="mp lf it ld b gy mq mr l ms mt">completed func 0: 1<br/>completed func 3: 4<br/>completed func 1: 2<br/>completed func 2: 3<br/>completed func 4: 5<br/>Completed after: 0.9764895439147949</span></pre><h1 id="ab24" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实际用法</h1><p id="2e11" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">Python 3.8发布后，将<code class="fe la lb lc ld b">asyncio.run()</code>方法移到了稳定的API，您可以开始使用它，没有任何问题。</p><p id="01a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从<code class="fe la lb lc ld b">synchronous</code>方法转移到异步方法的唯一问题是改变思考问题的方式。你必须改变你对每一个小细节的思考方式。相信我，一旦你开始考虑异步函数，你会爱上它的。</p><h1 id="9b63" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">它是如何在引擎盖下工作的？</h1><p id="8684" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">让我们检查异步函数的类型。</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="b304" class="mp lf it ld b gy mq mr l ms mt">type(main())</span><span id="458f" class="mp lf it ld b gy mu mr l ms mt"># &lt;class 'coroutine'&gt;</span></pre><p id="12b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，异步函数的类型是<code class="fe la lb lc ld b">coroutine</code>。</p><p id="308f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇<a class="ae kz" href="https://www.geeksforgeeks.org/coroutine-in-python/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks文章</a>很好地解释了协程。</p><p id="0783" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总结一下他们在文章中写的内容，<strong class="kd iu">子程序</strong>是一组有一个入口点并连续执行的指令。</p><p id="23b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，<strong class="kd iu">协程</strong>可以暂停或放弃对其他协程的控制，允许多个任务同时运行。</p><p id="8dd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python使用这个概念来支持异步行为。</p><h1 id="2423" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">处理异步函数中的超时</h1><p id="4fc5" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">必须有一个等待任务完成的超时。我们不应该永远等待它完成。<code class="fe la lb lc ld b">asyncio</code>还提供了向异步函数添加超时的能力，这样您可以在它完成之前跳过执行。</p><p id="e0a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种情况的一个实际应用是，当您在应用程序中调用第三方API时，第三方本身就关闭了。那样的话，你不会想等很久的。</p><p id="97ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以用<code class="fe la lb lc ld b">timeout</code>方法来解决你的问题。</p><p id="2ab8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参见代码示例:</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="a32b" class="mp lf it ld b gy mq mr l ms mt">async def async_sleep():<br/>    await asyncio.sleep(2)<br/>    print('Execution completed')</span><span id="d549" class="mp lf it ld b gy mu mr l ms mt">async def main():<br/>    try:<br/>        await asyncio.wait_for(async_sleep(), timeout=1.0)<br/>    except asyncio.TimeoutError:<br/>        print('Timeout error')</span><span id="57f8" class="mp lf it ld b gy mu mr l ms mt">asyncio.run(main())</span></pre><p id="fa13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果在给定的<code class="fe la lb lc ld b">timeout</code>被传递之前协程没有返回，异步函数将引发<code class="fe la lb lc ld b">TimeoutError</code>。执行上述代码后的响应是</p><pre class="mh mi mj mk gt ml ld mm mn aw mo bi"><span id="968f" class="mp lf it ld b gy mq mr l ms mt">Timeout error</span></pre><p id="122a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">asyncio</code>模块里还有其他牛逼的方法。你可以在<a class="ae kz" href="https://docs.python.org/3/library/asyncio-task.html" rel="noopener ugc nofollow" target="_blank"> python官网</a>查看。</p><h1 id="0bd5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="6f16" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">如果你想为你的用户提供更好更快的体验，你可以开始在你的应用中使用<code class="fe la lb lc ld b">asyncio</code>模块。这肯定会帮助您找到可以减少API或您正在做的任何事情的执行时间的情况。</p><p id="86bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只要强迫自己这样写几个月，就能在未来获得巨大回报。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="3590" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my">原载于2020年8月30日</em><a class="ae kz" href="https://ranvir.xyz/blog/asynchronous-behaviour-using-asyncio-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="my">https://ran vir . XYZ</em></a><em class="my">。</em></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="aed3" class="le lf it bd lg lh nj lj lk ll nk ln lo lp nl lr ls lt nm lv lw lx nn lz ma mb bi translated">分级编码</h1><p id="659c" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">感谢您成为我们社区的一员！<a class="ae kz" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae kz" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="no np gp gr nq nr"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">编写面试问题</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">掌握编码面试的过程</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">技术开发</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jz nr"/></div></div></a></div></div></div>    
</body>
</html>