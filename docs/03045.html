<html>
<head>
<title>Learning C++: The STL and the stack Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL和堆栈类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-the-stl-and-the-stack-class-ee8232530051?source=collection_archive---------19-----------------------#2020-04-16">https://levelup.gitconnected.com/learning-c-the-stl-and-the-stack-class-ee8232530051?source=collection_archive---------19-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9767fc46326a1b3d0d472a4b707945ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iEOuv8m2ZMWbaCHt"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1ffc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">stack类提供了一个非常专门化的容器接口。堆栈是一种后进先出(LIFO)容器，它具有最少数量的成员函数，您可以使用这些函数来操作存储在堆栈中的数据。在计算机科学和计算机编程的几个领域中，堆栈扮演着重要的角色。本文将讨论如何在C++编程中使用堆栈，并演示一些使用堆栈的应用程序。</p><h1 id="8dc8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">堆栈概述</h1><p id="312b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">堆栈是一个容器，所有数据从容器的顶部进出。您可以在堆栈上执行的三个主要操作是:1) <em class="mh">将新数据推送到堆栈上</em>；2) <em class="mh">弹出</em>栈顶数据元素；3)查看堆栈顶部的<em class="mh">和</em>。</p><p id="44fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想想一个现实生活中的推论，想想自助餐厅的托盘。当顾客走进自助餐厅，拿到一个托盘时，他们会把托盘从堆叠的顶部拿走。当洗碗机清洗托盘并将其放回原处时，托盘会放在托盘堆的顶部。当您查看托盘堆栈时，您可以完全看到的唯一托盘是顶部托盘。</p><p id="8d3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我前面提到的，堆栈被认为是一个后进先出的容器，因为推到堆栈顶部的最后一个元素是从堆栈顶部弹出的第一个元素。</p><h1 id="1fcd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">声明堆栈</h1><p id="bcc7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">stack类的头文件是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b86d" class="mr lf it mn b gy ms mt l mu mv">#include &lt;stack&gt;</span></pre><p id="b8a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mn b">stack</code>类是一个模板类，因此您必须在声明中提供一个数据类型，如下例所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ecc2" class="mr lf it mn b gy ms mt l mu mv">stack&lt;int&gt; numbers;<br/>stack&lt;string&gt; people;<br/>stack&lt;double&gt; ratios;<br/>stack&lt;char&gt; operators;</span></pre><p id="49c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你不能用初始化列表来初始化一个栈，也不能像其他容器一样指定一个初始容量作为构造函数的参数。</p><h1 id="9d65" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">向堆栈添加数据并查看堆栈顶部</h1><p id="fe85" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">只有一种方法可以将数据添加到堆栈中——<code class="fe mw mx my mn b">push</code>函数。<code class="fe mw mx my mn b">push</code>函数获取一个元素并将其存储在堆栈的顶部。栈顶也是栈中唯一可以访问的元素。这个类有一个检查栈顶的函数——<code class="fe mw mx my mn b">top</code>函数。</p><p id="634b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个简短的程序，它将一些数据推送到堆栈上，然后检查堆栈的顶部:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="22d8" class="mr lf it mn b gy ms mt l mu mv">#include &lt;iostream&gt;<br/>#include &lt;stack&gt;<br/>using namespace std;</span><span id="8262" class="mr lf it mn b gy mz mt l mu mv">int main()<br/>{<br/>  stack&lt;int&gt; numbers;<br/>  numbers.push(2);<br/>  numbers.push(4);<br/>  numbers.push(8);<br/>  cout &lt;&lt; "top of stack: " &lt;&lt; numbers.top() &lt;&lt; endl;  // 8<br/>  return 0;<br/>}</span></pre><p id="3569" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7ab0" class="mr lf it mn b gy ms mt l mu mv">top of stack: 8</span></pre><h1 id="4c06" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从堆栈中删除数据</h1><p id="fdc4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用<code class="fe mw mx my mn b">pop</code>函数从堆栈中移除数据。这个函数只能移除栈顶的元素。正如我前面提到的，除了顶部的元素，栈上没有其他元素是可访问的。</p><p id="3c76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个从堆栈中弹出数据的示例，在每次弹出后检查堆栈的顶部:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="257f" class="mr lf it mn b gy ms mt l mu mv">int main()<br/>{<br/>  stack&lt;int&gt; numbers;<br/>  numbers.push(2);<br/>  numbers.push(4);<br/>  numbers.push(8);<br/>  cout &lt;&lt; "top of stack: " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>  // top of stack: 8<br/>  numbers.pop();<br/>  cout &lt;&lt; "top of stack: " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>  // top of stack: 4<br/>  numbers.pop();<br/>  cout &lt;&lt; "top of stack: " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>  // top of stack: 2<br/>  numbers.pop();<br/>  cout &lt;&lt; "top of stack: " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>  // this line does not execute<br/>  return 0;<br/>}</span></pre><p id="fb40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个<code class="fe mw mx my mn b">cout</code>语句没有执行，因为我试图弹出一个空堆栈。您可以使用一个函数<code class="fe mw mx my mn b">empty</code>，它可以让您知道堆栈是空的还是仍然有数据。让我们修改上面的程序，利用<code class="fe mw mx my mn b">empty</code>功能:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d827" class="mr lf it mn b gy ms mt l mu mv">int main()<br/>{<br/>  stack&lt;int&gt; numbers;<br/>  numbers.push(2);<br/>  numbers.push(4);<br/>  numbers.push(8);<br/>  while (!numbers.empty()) {<br/>    cout &lt;&lt; "top of stack: " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>    numbers.pop();<br/>  }<br/>  return 0;<br/>}</span></pre><p id="4700" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个可以用来帮助确定堆栈何时为空的函数是<code class="fe mw mx my mn b">size</code>函数。这个函数返回堆栈中元素的数量。下面是如何使用它来防止弹出一个空堆栈:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9c6c" class="mr lf it mn b gy ms mt l mu mv">int main()<br/>{<br/>  stack&lt;int&gt; numbers;<br/>  numbers.push(2);<br/>  numbers.push(4);<br/>  numbers.push(8);<br/>  while (numbers.size() &gt; 0) {<br/>    cout &lt;&lt; "top of stack: " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>    numbers.pop();<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="004b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一些堆栈应用程序</h1><p id="7197" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">堆栈可以用于一些有趣的算法和应用程序。以下是其中的几个。</p><h1 id="4a78" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将十进制数转换为二进制数</h1><p id="bf70" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我将讨论的第一个算法是将基数为10(十进制)的数字转换为基数为2(二进制)的数字。以下是算法w，其中n是十进制数，B是基数(2):</p><p id="f4fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mh"> 0。</em> <em class="mh">从空栈开始。</em></p><p id="5419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mh"> 1。</em> <em class="mh">取n乘n % B的最右位，将结果压入堆栈。</em></p><p id="2327" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mh"> 2。</em> <em class="mh">将n替换为n/b</em></p><p id="f7d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mh"> 3。</em> <em class="mh">重复步骤1和2，直到n = 0。</em></p><p id="02cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mh"> 4。</em> <em class="mh">从堆栈中弹出并打印数字，产生二进制数。</em></p><p id="a313" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是实现该算法的程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="fe84" class="mr lf it mn b gy ms mt l mu mv">int main()<br/>{<br/>  stack&lt;int&gt; binDigits;<br/>  int decNumber;<br/>  cout &lt;&lt; "Enter a decimal number: ";<br/>  cin &gt;&gt; decNumber;<br/>  int number = decNumber;<br/>  const int BASE = 2;<br/>  int digit;<br/>  while (decNumber &gt; 0) {<br/>    digit = decNumber % BASE;<br/>    binDigits.push(digit);<br/>    decNumber /= BASE;<br/>  }<br/>  string binNumber = "";<br/>  while (!binDigits.empty()) {<br/>    binNumber += to_string(binDigits.top());<br/>    binDigits.pop();<br/>  }<br/>  cout &lt;&lt; number &lt;&lt; " is " &lt;&lt; binNumber<br/>       &lt;&lt; " in binary." &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="adc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序的一次运行:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c26f" class="mr lf it mn b gy ms mt l mu mv">Enter a decimal number: 53<br/>53 is 110101 in binary.</span></pre><h1 id="6ef2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">寻找回文</h1><p id="c74e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果一个单词正反拼写相同，那么这个单词就是回文。雷达和赛车这两个词就是回文的例子。我们可以使用堆栈来确定一个单词是否是回文，方法是将一个单词的每个字母推到堆栈上。然后，我们可以通过将堆栈弹出到另一个单词中，直到堆栈为空，来形成该单词的反转。如果原词和由栈形成的词相等，那么这个词就是回文。</p><p id="b0e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个检查单词是否是回文的程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c401" class="mr lf it mn b gy ms mt l mu mv">int main()<br/>{<br/>  stack&lt;char&gt; letters;<br/>  string word;<br/>  cout &lt;&lt; "Enter a word to check: ";<br/>  cin &gt;&gt; word;<br/>  for (unsigned i = 0; i &lt; word.size(); i++) {<br/>    letters.push(word[i]);<br/>  }<br/>  string revWord = "";<br/>  while (!letters.empty()) {<br/>    revWord += letters.top();<br/>    letters.pop();<br/>  }<br/>  if (revWord == word) {<br/>    cout &lt;&lt; word &lt;&lt; " is a palindrome." &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; word &lt;&lt; " is not a palindrome." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="ffa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的一些运行情况:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4179" class="mr lf it mn b gy ms mt l mu mv">Enter a word to check: radar<br/>radar is a palindrome.</span><span id="938e" class="mr lf it mn b gy mz mt l mu mv">Enter a word to check: racecar<br/>racecar is a palindrome.</span><span id="e542" class="mr lf it mn b gy mz mt l mu mv">Enter a word to check: railcar<br/>railcar is not a palindrome.</span></pre><p id="b5cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们习惯写的算术语句都是用中缀写的，比如:<em class="mh"> (9.0/5.0) * 100 + 32.0 </em>。但是，如果不能直接依赖正常的操作顺序，就必须用括号来表示正确的操作顺序。另一方面，后缀表达式可以不用括号，并且保持正确的操作顺序。</p><p id="8681" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们构建一个简单的中缀到后缀的转换器，它适用于不包含括号的算术语句，比如<em class="mh"> a+b*c </em>。对于这个转换器，我们将根据优先级将算术运算符推到堆栈上，并将标识符放到后缀语句上。</p><p id="5894" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">程序如下:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3919" class="mr lf it mn b gy ms mt l mu mv">#include &lt;iostream&gt;<br/>#include &lt;stack&gt;<br/>using namespace std;</span><span id="fef0" class="mr lf it mn b gy mz mt l mu mv">int getPrecedence(char op) {<br/>  if (op == '+' || op == '-') {<br/>    return 1;<br/>  }<br/>  else if (op == '*' || op == '/') {<br/>    return 2;<br/>  }<br/>  else if (op == '^') {<br/>    return 3;<br/>  }<br/>  else {<br/>    return 0;<br/>  }<br/>}</span><span id="a95d" class="mr lf it mn b gy mz mt l mu mv">bool isOp(char ch) {<br/>  if (ch == '+' || ch == '-' || ch == '*' ||<br/>      ch == '/' || ch == '^') {<br/>    return true;<br/>  }<br/>  return false;<br/>}</span><span id="8a3c" class="mr lf it mn b gy mz mt l mu mv">int main()<br/>{<br/>  stack&lt;char&gt; s;<br/>  string infix = "a+b*c";<br/>  string postfix = "";<br/>  char ch;<br/>  for (unsigned i = 0; i &lt; infix.size(); i++) {<br/>    ch = infix[i];<br/>    if (isOp(ch)) {<br/>      if (s.empty()) {<br/>        s.push(ch);<br/>      }<br/>      else if (getPrecedence(ch) &gt;= getPrecedence(s.top())) {<br/>        s.push(ch);<br/>      }<br/>    }<br/>    else {<br/>      postfix += ch;<br/>    }<br/>  }<br/>  if (!s.empty()) {<br/>    while (!s.empty()) {<br/>      postfix += s.top();<br/>      s.pop();<br/>    }<br/>  }<br/>  cout &lt;&lt; infix &lt;&lt; endl;<br/>  cout &lt;&lt; postfix &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="2548" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对这个程序的一个很好的扩展是添加括号检查，这样你就可以转换更复杂的表达式。如果你做这个扩展，我很想看你的节目。</p><h1 id="5396" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用堆栈</h1><p id="58de" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我刚刚展示了三个使用堆栈解决编程问题的例子。在更技术性的计算机科学中，堆栈用于管理函数(参见<a class="ae kf" href="https://en.wikipedia.org/wiki/Call_stack" rel="noopener ugc nofollow" target="_blank">调用堆栈</a>)、管理内存(参见<a class="ae kf" href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" rel="noopener ugc nofollow" target="_blank">基于堆栈的内存分配</a>)以及回溯算法(参见<a class="ae kf" href="https://en.wikipedia.org/wiki/Backtracking" rel="noopener ugc nofollow" target="_blank">回溯</a>)并使许多其他算法更加高效。</p><p id="e19d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请发送电子邮件提出您的意见和建议。</p></div></div>    
</body>
</html>