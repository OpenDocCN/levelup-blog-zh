<html>
<head>
<title>Improve JavaScript Performance with OffscreenCanvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用屏幕外画布提高JavaScript性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improve-javascript-performance-with-offscreencanvas-1180dc5376e9?source=collection_archive---------2-----------------------#2021-01-02">https://levelup.gitconnected.com/improve-javascript-performance-with-offscreencanvas-1180dc5376e9?source=collection_archive---------2-----------------------#2021-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="09b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解如何通过使用OffscreenCanvas来提高在canvas中渲染的性能</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c54378e585766454961e6c1c49817753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14vHYu_2xjwaX0UbOegBNw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://www.pexels.com/@snapwire?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Snapwire </a>从<a class="ae lb" href="https://www.pexels.com/photo/man-riding-bicycle-on-city-street-310983/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</figcaption></figure><p id="c0f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OffscreenCanvas接口允许在Workers中使用画布渲染上下文(2D和WebGL)。它增加了网络中的并行性，从而提高了多核系统的性能。</p><p id="c8cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用OffscreenCanvas，我们可以在工作线程中呈现一个画布，这样主线程就不会受到干扰，这样我们的web应用程序就可以顺利工作。</p><p id="d3dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跨浏览器的屏幕外画布支持可以在这里找到<a class="ae lb" href="https://caniuse.com/#feat=offscreencanvas" rel="noopener ugc nofollow" target="_blank">can use</a>。</p><p id="0992" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有两种方法可以使用<code class="fe lc ld le lf b"><strong class="jp ir">OffscreenCanvas</strong></code></p><ol class=""><li id="f898" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated">从现有画布创建屏幕外画布</li><li id="4367" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">手动创建一个屏幕外画布，并将其渲染到现有画布上</li></ol><h2 id="a1d2" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">1.从现有画布创建屏幕外画布</h2><p id="c75c" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们可以调用canvas元素上的<code class="fe lc ld le lf b">transferControlToOffscreen</code> <strong class="jp ir"> </strong>方法来获得一个<code class="fe lc ld le lf b">OffscreenCanvas</code>元素，该元素可以被传递给worker。<strong class="jp ir">应用于</strong> <code class="fe lc ld le lf b"><strong class="jp ir">OffscreenCanvas</strong></code> <strong class="jp ir">的操作会自动渲染到源画布上。</strong></p><p id="6d87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例子</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2c40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们从<code class="fe lc ld le lf b"><strong class="jp ir">canvas</strong></code> <strong class="jp ir"> </strong>元素中创建了一个<code class="fe lc ld le lf b"><strong class="jp ir">offscreenCanvas</strong></code>，它被传输到worker中，渲染将在worker线程中进行。</p><p id="fed7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在offscreen_worker.js文件中</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/24b692de09f7ab6690a2f9d732142721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3f2lI6p_La0F0aQDXhx76Q.png"/></div></div></figure><p id="cd39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>如果您已经在此画布上使用了<code class="fe lc ld le lf b">getContext</code>，您将无法将其转移到worker。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="acc1" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated"><strong class="ak"> 2。手动创建一个屏幕外画布，并将其渲染到现有画布上</strong></h2><p id="9872" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">第二种方法是创建一个<code class="fe lc ld le lf b">OffscreenCanvas</code>对象并在画布中渲染，然后从<code class="fe lc ld le lf b">offscreenCanvas</code>中获取图像数据并将其渲染回原始画布。通过使用这种方式，我们可以一次在多个画布上进行渲染。</p><p id="886c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要显示来自<code class="fe lc ld le lf b">offscreenCanvas</code>的图像(<code class="fe lc ld le lf b">ImageBitmap</code>，您可以使用一个<code class="fe lc ld le lf b">ImageBitmapRenderingContext</code>上下文，它可以通过在原始画布元素上调用<code class="fe lc ld le lf b"><strong class="jp ir">canvas.getContext("bitmaprenderer")</strong></code>来创建。这个上下文只提供用给定的<code class="fe lc ld le lf b">ImageBitmap</code>替换画布内容的功能。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="61ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在worker中，我们将使用画布并制作一些动画:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1d9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的应用在canvas中涉及一些复杂的渲染操作，你可以在你的web应用中使用<code class="fe lc ld le lf b">offscreenCanvas</code>。</p><p id="3970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。跟随<a class="mv mw ep" href="https://medium.com/u/f9ffc26e7e69?source=post_page-----1180dc5376e9--------------------------------" rel="noopener" target="_blank"> Javascript Jeep🚙💨</a>。</p></div></div>    
</body>
</html>