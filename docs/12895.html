<html>
<head>
<title>Short Codes, Big Effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">短代码，大效果</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/short-codes-big-effects-cfdc1e91ee34?source=collection_archive---------25-----------------------#2022-07-18">https://levelup.gitconnected.com/short-codes-big-effects-cfdc1e91ee34?source=collection_archive---------25-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6eeb4aa355fdab26bb4dd24af9fa4df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZxXy9SDGCfdkMKeUdZhBQ.png"/></div></div></figure><p id="4c14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有编程语言中都有一组短代码，它们具有重要的、也许是意想不到的效果，这是一个特别吸引人的地方，因为通常最看似无害的代码会导致各种各样的问题。一些有史以来最聪明的代码行(如Python中的一行程序)依赖于非常紧凑的编写，接近“Kolmogorov复杂性”般的优化。</p><p id="0998" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Java中的<code class="fe kw kx ky kz b">System.exit();</code>命令及其翻译成其他编程语言之后，这类代码中最广为人知的是Linux机器上的<code class="fe kw kx ky kz b">rm -r ./</code>。它对破坏你的计算机非常有效，以至于你不能在“普通模式”下执行这个代码。试图在我的虚拟Linux Mint上执行它，导致它删除了我所有的文件，但没有删除系统必需的文件:</p><ul class=""><li id="b185" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">rm</code>是一个可以删除文件的工具</li><li id="136e" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">-r</code>标志表示“递归”选项，用于删除文件夹及其内容</li><li id="491f" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">./</code>表示包含Linux操作系统所有内容的根文件夹。</li></ul><p id="b266" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Windows机器上，对应的命令是<code class="fe kw kx ky kz b">del -r *</code>。这两个命令不仅永久地损坏你的计算机，而且主动地破坏它，因此它们基本上被禁止使用。</p><p id="ca1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在编程时，应该实现对无限循环的保护，以免导致服务器完全崩溃。但是<code class="fe kw kx ky kz b">while (true) {}</code>和它的翻译在实践中是没有用的，除了阻止事件循环执行其他任何事情之外，没有任何作用。因此他们很少使用。</p><p id="b07d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，<code class="fe kw kx ky kz b">sleep()</code>函数，一个被美化了的<code class="fe kw kx ky kz b">while (true) {}</code>，有许多折衷的用例，从创建一个更加用户友好的UI，到降低应用程序的功耗，以及“通过删除策略性放置的睡眠功能来提高性能”的笑话用法。然而，滥用它的关键在于<code class="fe kw kx ky kz b">sleep</code>是在毫秒级别上使用的:如果睡眠时间很长，一些进程可能看起来永远不会结束，因此崩溃API调用或执行线程的一种快速方法是在很长的时间限制内偷偷使用这个函数。</p><p id="fe23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了无限循环和这些沉睡的生物，你还有算法复杂的函数，它们可能不是无限的，但对于足够大的输入来说可能需要足够长的时间，以至于它们很快成为不可接受的编程形式(大约n)，镜像<code class="fe kw kx ky kz b">sleep</code>和<code class="fe kw kx ky kz b">while(true) {}</code>。NP问题也是这些程序的一部分，因为据我们所知，它们只能在指数时间内可解。例如，哈密尔顿路径问题可能需要非常非常长的时间来运行，使得算法看起来可能永远不会停止。</p><p id="1b0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这些算法通常需要编写多行代码，并且很容易在代码审查中被识别为需要解构的算法。进入优雅的<em class="lo">阿克曼函数。这看起来是一个足够简单的递归函数，可以用5行简单的Python代码来表达。但是，请注意，一些玩具输入会导致意想不到的最大递归极限错误:</em></p><pre class="lp lq lr ls gt lt kz lu lv aw lw bi"><span id="7b0a" class="lx ly iq kz b gy lz ma l mb mc"><em class="lo">def</em> A(<em class="lo">m</em>, <em class="lo">n</em>):<br/>   if <em class="lo">m</em> == 0:<br/>      return <em class="lo">n</em>+1<br/>   if n == 0:<br/>      return A(m-1,n)<br/>   return A(m-1, A(m,n-1))</span><span id="5aee" class="lx ly iq kz b gy md ma l mb mc">print(A(2,2)) # 7<br/>print(A(2,3)) # 9<br/>print(A(3,2)) # 29<br/>print(A(3,3)) # 61<br/>print(A(4,2)) # maximum recursion depth exceeded<br/>print(A(4,1)) # maximum recursion depth exceeded</span></pre><p id="1fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实证明，<code class="fe kw kx ky kz b">A(4,2)</code>会吐出(如果我们有无限的计算资源)一个超过19000位数的数字！不仅如此，它还会通过手动添加数字1来计算，直到到达那里。函数不只是一个疯狂的指数函数，而是一个复杂度<code class="fe kw kx ky kz b">O(mA(m, n))</code>的函数。换句话说，函数的复杂性随着它产生的值而增加，这是一个非常不直观的概念。用其他编程语言编写，可以减少到3行，比如用c。</p><pre class="lp lq lr ls gt lt kz lu lv aw lw bi"><span id="3a48" class="lx ly iq kz b gy lz ma l mb mc"><em class="lo">int</em> A(<em class="lo">int</em> <em class="lo">m</em>, <em class="lo">int</em> <em class="lo">n</em>) {<br/>    if (<em class="lo">m</em> == 0) { return <em class="lo">n</em>+1; }<br/>    if (<em class="lo">n</em> == 0) { return A(<em class="lo">m</em>-1,1); }<br/>    return A(<em class="lo">m</em>-1, A(<em class="lo">m</em>,<em class="lo">n</em>-1));<br/>}</span></pre><p id="9735" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这些讨厌的怪物函数依赖于“递归溢出”，但有一个依赖于“线程溢出”的简短shell代码:<em class="lo"> forkbomb </em>，一个众所周知的红队漏洞，我从Ben Clark 的<a class="ae me" href="https://www.goodreads.com/book/show/21419959-red-team-field-manual" rel="noopener ugc nofollow" target="_blank"> RTFM: Red Team Field Manual中复制了它，它是用shell编写的，看起来像这样:<code class="fe kw kx ky kz b">:(){:|:&amp;};:</code></a></p><p id="9d72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段非常短的代码定义了一个函数，该函数创建了两个线程，这两个线程依次执行相同的函数，从而创建了另外两个线程，这样，在仅仅10个递归步骤中，就有1024个线程都在执行更多的线程创建操作。不管你的硬件是什么，这都会使你的电脑变慢，直到你需要重启电脑来清理线程。</p><p id="39b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住这些事情，当人们在一个软件项目上一起工作时，也有适当的规则，这样每个人都可以和谐地管理他们的代码。在软件工程方面，典型的毁灭性命令(或者我应该说，“选项”)是什么？)是迷化的<code class="fe kw kx ky kz b">git push ––force</code>，这是一个不幸的知识，因为人们可能会在工作中偶然用到它:</p><ul class=""><li id="245f" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">git</code> <em class="lo"> </em>指定用于版本控制的git工具</li><li id="6120" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">push</code>告诉实用程序将您在本地机器上所做的更改放到远程存储库中</li><li id="3901" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">––force</code>标志告诉它覆盖远程存储库上的任何更改，因此冒着丢失来自其他团队成员的更改的风险。</li></ul><p id="0719" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这个命令可以删除以前完成的工作，这就意味着永远不要使用这个选项，因为它很容易浪费人们重写代码的时间。</p><p id="3c49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，还有更多的小片段可以造成真正的破坏(<code class="fe kw kx ky kz b">kill</code><em class="lo"/><code class="fe kw kx ky kz b">shutdown</code>或<code class="fe kw kx ky kz b">while(true) { malloc(10) }</code>)，这里介绍的几个只是整个系列的一小部分。但是知道它们是很好的，它总是很好地提醒我们一些字符是多么危险，平庸的代码审查是如何成就或摧毁超级计算机的。</p></div></div>    
</body>
</html>