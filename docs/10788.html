<html>
<head>
<title>Game Development: Breakout in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">游戏开发:JavaScript的突破</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/game-development-breakout-in-javascript-5e5d142d3203?source=collection_archive---------0-----------------------#2022-01-11">https://levelup.gitconnected.com/game-development-breakout-in-javascript-5e5d142d3203?source=collection_archive---------0-----------------------#2022-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/00195766ead55a2ee54de5d3eac84715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1RPnxoNCukh9T9ytx63JCA.png"/></div></div></figure><p id="d088" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们创建了一个<strong class="kd iu">完整的</strong>突围式<strong class="kd iu">游戏</strong>。HTML <strong class="kd iu">画布</strong>提供了游戏容器，我们通过<strong class="kd iu"> JavaScript </strong>在其中绘制图形。在学习了如何使用画布来制作图形和动画之后，我们将使用圆形和矩形等基本形状来研究碰撞背后的算法。有了这些概念和一些游戏循环和声音，我们很快就会有一个游戏可以玩了！</p><p id="9450" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的<a class="ae kz" href="https://github.com/melcor76/js-breakout" rel="noopener ugc nofollow" target="_blank"> GitHub资源库js-breakout </a>或者<a class="ae kz" href="https://affectionate-shockley-c3f5d7.netlify.app/" rel="noopener ugc nofollow" target="_blank">里查看代码玩游戏</a>！</p><p id="9f91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢JavaScript游戏，可以看看我写的关于俄罗斯方块的文章:</p><ul class=""><li id="9d1e" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><a class="ae kz" href="https://michael-karen.medium.com/learning-modern-javascript-with-tetris-92d532bcd057" rel="noopener">用俄罗斯方块学习现代JavaScript】</a></li></ul></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="6abe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">说到传奇游戏，<strong class="kd iu">突围</strong>榜上有名。不仅仅是因为它是雅达利的Pong单机版续作，还因为史蒂夫·乔布斯和史蒂夫·沃兹尼亚克都曾开发过它，后来用部分资金创立了苹果公司。以现代的标准来看，这个游戏相当简单，但是在1976年，我出生的那一年，它是革命性的。十年后，随着泰托1986年的arkan oid问世，这一概念有了新的发展，它本身也催生了数十个模仿者。这种游戏被称为方块游戏。</p><p id="4ae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这款游戏的成功延续至今，雅达利继续将其移植到新的平台上。事实上，你可以在Android、iPhone和iPad上找到一个官方端口。越狱是有史以来最克隆的游戏之一。让我们看看，在这门课的帮助下，我们能否增加这些数据。</p><h1 id="2eee" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">游戏设计</h1><p id="cc0f" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">所有突破式游戏至少有三个共同点——每个游戏都包含<strong class="kd iu">桨、球和砖块</strong>。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/1cefa47546fccf6b95222e513dff971b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwVTa3334WF6POSMGBllZA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">第一个游戏设计。</figcaption></figure><p id="aa9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">玩家必须用球拍将球弹起，穿过一排排砖墙。这些砖有不同的颜色。根据颜色的不同，砖块可以奖励更多的分数，并且更难破碎。为了让游戏更具挑战性，在游戏的某些时候，速度可能会增加。作为最后一栏，当玩家突破最后一排时，桨可以减小它的尺寸。如果玩家丢球三次，游戏就结束了。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="6788" class="lq lr it bd ls lt nc lv lw lx nd lz ma mb ne md me mf nf mh mi mj ng ml mm mn bi translated">入门指南</h1><p id="0009" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">在开始游戏的功能之前，我们需要创建一个基本的结构来渲染游戏。我们可以用HTML和<code class="fe nh ni nj nk b">&lt;canvas&gt;</code>元素做到这一点。</p><p id="9cbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使项目不是很大，将代码分成不同的文件也是一个很好的做法:</p><ul class=""><li id="8c16" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><code class="fe nh ni nj nk b">index.html</code> —链接到其他文件的主文件。我们在最后添加的脚本的顺序是至关重要的。</li><li id="8472" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated"><code class="fe nh ni nj nk b">styles.css</code> —包含样式。</li><li id="349e" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated"><code class="fe nh ni nj nk b">breakout.js</code> —游戏的JavaScript代码。</li></ul><p id="6f3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当JavaScript变大时，我们可以考虑将它分成多个文件。</p><h2 id="50d3" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">HTML和CSS</h2><p id="ae33" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">HTML文档结构非常简单，因为游戏呈现在<code class="fe nh ni nj nk b">&lt;canvas&gt;</code>元素上。我们唯一需要担心的是启动游戏的按钮。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="25fe" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">JavaScript</h2><p id="5ddb" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">在HTML文件的末尾，我们添加了对JavaScript文件的引用。<code class="fe nh ni nj nk b">&lt;script&gt;</code>元素包含浏览器执行的JavaScript代码。</p><p id="2e61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以添加一个对应于添加到播放按钮的<code class="fe nh ni nj nk b">onclick</code>事件的空函数:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="45de" class="nq lr it nk b gy oi oj l ok ol">function play() {}</span></pre><p id="d39e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，我们的游戏容器就设计好了，等待代码。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="0f1f" class="lq lr it bd ls lt nc lv lw lx nd lz ma mb ne md me mf nf mh mi mj ng ml mm mn bi translated">帆布</h1><p id="daef" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">在浏览器中绘制图形和创建动画有几种不同的方式。在本课程中，我们使用<strong class="kd iu"> HTML5 Canvas </strong>，其功能集非常适合制作2D和3D游戏。canvas元素是使用<code class="fe nh ni nj nk b">width</code>和<code class="fe nh ni nj nk b">height</code>属性在HTML代码中定义的。然后我们可以通过编写JavaScript来使用HTML5 Canvas API。我们通过绘图函数访问画布来动态生成图形。</p><h2 id="9cf8" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">画布上下文</h2><p id="bed5" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">画布有一个<strong class="kd iu"> 2D绘图上下文</strong>用于绘制形状、文本、图像和其他对象。首先，我们选择颜色和画笔，然后我们绘画。我们可以在画之前改变画笔和颜色，或者继续使用现有的。</p><p id="94c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nh ni nj nk b">HTMLCanvasElement.getContext()</code>方法返回一个绘图上下文，我们在其中渲染图形。通过提供<code class="fe nh ni nj nk b">'2d'</code>作为参数，我们得到画布2D渲染上下文:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="02d5" class="nq lr it nk b gy oi oj l ok ol">const ctx = canvas.getContext('2d');</span></pre><blockquote class="om on oo"><p id="17b8" class="kb kc op kd b ke kf kg kh ki kj kk kl oq kn ko kp or kr ks kt os kv kw kx ky im bi translated">还有其他可用的上下文，比如用于三维呈现上下文的<code class="fe nh ni nj nk b">webgl</code>，超出了本文的范围。</p></blockquote><h2 id="507e" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">坐标系</h2><p id="eaff" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">HTML画布是一个二维网格。画布的左上角有坐标(0，0)。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/4f433330115ad021db9c2c23effe3741.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*lFDoEkqVdAzNs2WWY_uOnA.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">画布坐标系。</figcaption></figure><p id="25fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您对画布的更多细节感兴趣，可以查看我的文章:</p><ul class=""><li id="0bba" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><a class="ae kz" href="https://medium.com/dailyjs/how-to-get-started-with-canvas-animations-in-javascript-cb2ccf37515c" rel="noopener">如何开始使用JavaScript制作画布动画</a></li></ul><h1 id="a158" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">制图法</h1><p id="1b50" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">为了让游戏看起来更好，我们可以使用图像来绘制球。但是，在此之前，我们需要跟踪球的位置和其他相关值。为此，我们可以定义一个<code class="fe nh ni nj nk b">ball</code>对象。我们从定义唯一一个我们知道的常量值开始，这个值就是<code class="fe nh ni nj nk b">radius</code>:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="1856" class="nq lr it nk b gy oi oj l ok ol">const ball = {<br/>  radius: 10<br/>}</span></pre><p id="2b8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当游戏开始时，我们想给球一些初始值，比如它的位置。我们在函数<code class="fe nh ni nj nk b">resetBall()</code>中将球的起始<code class="fe nh ni nj nk b">x</code>和<code class="fe nh ni nj nk b">y</code>坐标定义为画布的底部中心部分，然后我们从<code class="fe nh ni nj nk b">play()</code>函数调用该函数:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="bd8c" class="nq lr it nk b gy oi oj l ok ol">function resetBall() {<br/>  ball.x = canvas.width / 2,<br/>  ball.y = canvas.height — 100<br/>}</span></pre><p id="a609" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将有助于以后有一个函数来重置球的初始值，而不是在球对象中定义它们。</p><p id="0a19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们<strong class="kd iu">定义用于球和背景的图像</strong>。对于每个对象属性，我们首先将其创建为一个<code class="fe nh ni nj nk b">new Image()</code>，然后将其<code class="fe nh ni nj nk b">src</code>设置为我们正在使用的文件:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="c78e" class="nq lr it nk b gy oi oj l ok ol">let images = {<br/>  background: new Image(),<br/>  ball: new Image()<br/>}</span><span id="da00" class="nq lr it nk b gy ou oj l ok ol">images.background.src = 'bg-space.webp';<br/>images.ball.src = 'ball.webp';</span></pre><blockquote class="om on oo"><p id="ea7d" class="kb kc op kd b ke kf kg kh ki kj kk kl oq kn ko kp or kr ks kt os kv kw kx ky im bi translated">这些图像采用的是<strong class="kd iu"> WebP </strong>格式，生成的文件较小，但质量与PNG或JPEG相同。</p></blockquote><p id="3945" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了绘制图像，我们使用了<code class="fe nh ni nj nk b">drawImage()</code>，它提供了在画布上绘制图像的不同方法:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="eed5" class="nq lr it nk b gy oi oj l ok ol">ctx.drawImage(image, x, y, width, height);</span></pre><p id="5554" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们提供图像左上角的坐标，然后是图像的大小。对于<strong class="kd iu">背景，</strong>我们使用画布的宽度和高度来让背景图像覆盖整个比赛场地。对于<strong class="kd iu">球，</strong>我们将半径加倍以得到直径，它作为球图像的宽度和高度:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="0dcc" class="nq lr it nk b gy oi oj l ok ol">// draw background<br/>ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);</span><span id="d93f" class="nq lr it nk b gy ou oj l ok ol">// draw ball<br/>ctx.drawImage(images.ball, ball.x, ball.y, 2*ball.radius, 2*ball.radius);</span></pre><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/d57737e6d073ee8e6723fb1285f1da30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*4a06xL4fY2IkSTVXe5hHvg.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">球和背景。</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="60e4" class="lq lr it bd ls lt nc lv lw lx nd lz ma mb ne md me mf nf mh mi mj ng ml mm mn bi translated">动画</h1><p id="28b1" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">现在我们知道了如何在画布上画画，我们准备好进行下一步——让球移动。为此，我们在屏幕上绘制球，清除它，然后在不同的位置再次绘制它。在画布上制作动画就像制作一部定格电影。我们在每一帧中稍微移动物体来制作动画。</p><h2 id="a50e" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">绘图循环</h2><p id="dc30" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">Canvas使用<strong class="kd iu">即时渲染</strong>——当我们画图时，它会立即在屏幕上渲染。但是，这是一个“一劳永逸”的系统。在我们画了一些东西之后，画布忘记了这个物体，只知道它是像素。所以没有我们能移动的物体。而是要再画一遍。</p><p id="65a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要做到这一点，我们需要定义一个绘图函数，每次运行时使用一组不同的变量值。我们可以使用JavaScript计时函数一遍又一遍地运行函数，比如<code class="fe nh ni nj nk b">requestAnimationFrame()</code>，它比<code class="fe nh ni nj nk b">setInterval()</code>有一些明显的优势:</p><p id="9476" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">-它支持浏览器优化。<br/> -它处理帧速率。<br/> -动画仅在可见时运行。</p><p id="6eea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用<code class="fe nh ni nj nk b">requestAnimationFrame()</code>制作动画的方法是创建一个绘制帧的函数，然后调度它自己再次调用。通过这样做，我们得到了一个异步循环，它在我们在画布上绘图时执行。我们反复调用<code class="fe nh ni nj nk b">paint()</code>函数，直到我们决定停止。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f452" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们必须记住使用<code class="fe nh ni nj nk b">cancelAnimationFrame()</code>方法来取消先前预定的请求。如果我们忘记这样做，我们会注意到每次按play时游戏运行得更快，因为我们会有越来越多的动画循环在代码中运行。</p><p id="6924" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以将<code class="fe nh ni nj nk b">requestId</code>添加到游戏对象中，并在运行新动画之前检查一个值。然后，我们在每次运行新的<em class="op"> requestAnimationFrame </em>时设置这个变量:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9330" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一件事要做。我们需要计算动画多长时间前进一帧，<strong class="kd iu">否则动画会在高刷新率屏幕上运行得更快。</strong></p><h2 id="9ed5" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">计时器</h2><p id="5e47" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">当需要为下一次重画更新动画时，我们调用<code class="fe nh ni nj nk b">requestAnimationFrame()</code>函数。但是考虑到不同的屏幕刷新率，我们需要计算我们是否应该在这个调用中更新我们的游戏。</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="f5d1" class="nq lr it nk b gy oi oj l ok ol">requestAnimationFrame(callback);</span></pre><p id="f302" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回调函数被传递一个参数，一个类似于由<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="noopener ugc nofollow" target="_blank">performance.now()</a></code>返回的<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="noopener ugc nofollow" target="_blank">DOMHighResTimeStamp</a></code>，指示<code class="fe nh ni nj nk b">requestAnimationFrame()</code>开始执行回调函数的时间点。我们可以使用这个时间戳来计算何时绘制和更新我们的游戏。</p><p id="c7af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们添加一个时间对象来跟踪所有相关的东西，并在<code class="fe nh ni nj nk b">resetGame()</code>函数中设置它:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="2688" class="nq lr it nk b gy oi oj l ok ol">function resetGame() {<br/>  game.time = {<br/>    start: performance.now(),<br/>    elapsed: 0,<br/>    refreshRate: 16<br/>  };<br/>}</span></pre><p id="644a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在<code class="fe nh ni nj nk b">play()</code>函数中添加了对<code class="fe nh ni nj nk b">resetGame()</code>的调用。然后在动画循环中，我们添加代码来检查<code class="fe nh ni nj nk b">refreshRate</code>的16ms是否已经过去，以查看是否该绘制另一帧了:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f00b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了一个在每一帧持续绘制游戏的循环，我们需要在下一次绘制之前改变位置。</p><h2 id="e9ab" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">移动球</h2><p id="0773" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">我们用球对象的坐标在画布的底部中心部分定义了起点。画完球后，我们要改变<code class="fe nh ni nj nk b">x</code>和<code class="fe nh ni nj nk b">y</code>来移动它到一个新的位置。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/b76e81352ea21526191ca44d5e37ab51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*M_Pfcry3oYdOpqS836tOVQ.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">x和y的变化。</figcaption></figure><p id="529b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无需过多探究背后的数学原理，我们可以使用<code class="fe nh ni nj nk b">dx</code>和<code class="fe nh ni nj nk b">dy</code>来定义变化。变化值越大，球移动得越快。</p><blockquote class="om on oo"><p id="65b7" class="kb kc op kd b ke kf kg kh ki kj kk kl oq kn ko kp or kr ks kt os kv kw kx ky im bi translated">希腊字母δ(delta)表示<em class="it">变量的变化。</em></p></blockquote><p id="4b04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要一个<code class="fe nh ni nj nk b">speed</code>设置作为其他运动相关变量的基础。为了加快游戏速度，我们改变这个属性。</p><p id="ac34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们发射球时，它应该是随机向上的。如果我们总是有相同的轨迹，游戏会很快变得可预测。当<code class="fe nh ni nj nk b">dy</code>为负值时，球向上移动，所以我们用<code class="fe nh ni nj nk b">Math.Random()</code>将其设置为<code class="fe nh ni nj nk b">-speed.</code>，我们可以在x轴上随机化球射出的方向:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8c56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们用每一帧的变化来更新<code class="fe nh ni nj nk b">x</code>和<code class="fe nh ni nj nk b">y</code>。每次更新时，球都会被画在新的位置上。添加这两行给了我们这个<code class="fe nh ni nj nk b">update()</code>函数:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="e9b1" class="nq lr it nk b gy oi oj l ok ol">function update() {<br/>  ball.x += ball.dx;<br/>  ball.y += ball.dy;<br/>}</span></pre><p id="bb90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在画完当前帧后从<code class="fe nh ni nj nk b">animate()</code>函数调用<code class="fe nh ni nj nk b">update()</code>。这样，我们就为下一次油漆准备好了新的位置。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/1dcfa1d081d71863630a0aa29a30f58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*9XKL3X4PdfE_0ru6LNnEVw.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">向不同的方向移动球。</figcaption></figure><p id="077b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在每个新帧之前，我们需要清空画布。我们可以用<code class="fe nh ni nj nk b">CanvasRenderingContext2D.clearRect()</code>方法做到这一点，它通过将像素设置为透明黑色来擦除矩形区域中的像素。但是相反，我们可以通过绘制背景来开始每个新帧，这也清除了前一帧中的所有内容。为了保持动画函数的简洁，我们可以将所有与画布上的绘图对象相关的代码添加到一个<code class="fe nh ni nj nk b">paint()</code>函数中:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="7728" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过绘制背景来清除每个框架画布。然后，我们在更新下一帧的x和y值之前绘制球。通过用<code class="fe nh ni nj nk b">requestAnimationFrame()</code>安排<code class="fe nh ni nj nk b">animate()</code>功能的新运行，我们创建了一个动画循环。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/27cc59096749302623fd00bcc97a878b.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/1*Hk-TakGLYpDiV9Fs-EN5DA.gif"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">球动画</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="13e2" class="lq lr it bd ls lt nc lv lw lx nd lz ma mb ne md me mf nf mh mi mj ng ml mm mn bi translated">冲突检出</h1><p id="efa6" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">在前一章中，我们让球动了起来。但它很快就离开了屏幕，结束了这种乐趣。我们需要实现<em class="op">碰撞检测</em>来让球从墙壁上弹开。</p><p id="2889" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要计算碰撞何时发生。之后，我们需要思考当我们击中目标物体时，我们正在向哪个方向移动。然后我们可以在击球后将球向相反的方向送出。</p><h2 id="ef41" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">边界</h2><p id="b165" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">要使球在比赛场地内，以下三个条件都必须成立:</p><p id="55a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">- <strong class="kd iu">球的X </strong>大于左墙的X。<br/> - <strong class="kd iu">球的X </strong>小于右墙的X。<br/> - <strong class="kd iu">球的Y </strong>大于屋顶的Y。</p><p id="4684" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">球被绘制到画布上左上角的坐标处。我们需要考虑球的宽度。因此，我们需要考虑球的宽度时，检查对双方的碰撞。宽度或直径等于球半径的两倍(2r)。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/35d63b65d9ed93c377e0054174185187.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Z-hqysbpggqJcVUQ-PDdWA.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">球坐标与半径。</figcaption></figure><h2 id="e09f" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">检测碰撞</h2><p id="cb4e" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">球飞过的第一堵墙是正确的。我们可以通过检查<code class="fe nh ni nj nk b">x</code>何时大于画布的宽度来检测球何时与它发生碰撞。在这种情况下，我们需要添加<code class="fe nh ni nj nk b">2*ball.radius</code>，因为碰撞发生在球的右侧。</p><p id="446d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当碰撞发生时，我们通过对δx(dx)求反，使球在x轴上反向运动，使球向相反方向运动:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="1756" class="nq lr it nk b gy oi oj l ok ol">if (ball.x + 2 * ball.radius &gt; canvas.width) {<br/>  ball.dx = -ball.dx;<br/>}</span></pre><p id="4ea6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们碰到左边的墙时，我们再次反转x轴的方向。这次我们检查x何时小于零，也就是x轴的起点。在这种情况下，碰撞发生在球的左侧，这意味着我们不需要改变x值:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="e6a7" class="nq lr it nk b gy oi oj l ok ol">if (ball.x &lt; 0) {<br/>  ball.dx = -ball.dx;<br/>}</span></pre><p id="e4c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们需要从屋顶跳下来。在这种情况下，当y值低于零时，我们反转y轴上的移动。y轴上的水平移动由δy表示:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="9139" class="nq lr it nk b gy oi oj l ok ol">if (ball.y &lt; 0) {<br/>  ball.dy = -ball.dy;<br/>}</span></pre><p id="9a50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将所有这些检查一起添加到函数<code class="fe nh ni nj nk b">detectCollision()</code>中:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="72cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这段代码做了它应该做的事情，但是它可能很难读懂。为了增加可读性，我们添加了返回计算结果的函数表达式。我们还需要确保坐标不在游戏区域之外。所以我们确保将坐标移回墙上:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9e70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那更好！随着代码的实现，我们已经处理了所有需要球反弹的墙。但是你可能已经注意到有一个冲突我们还没有处理。</p><h1 id="0d18" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">游戏结束</h1><p id="badc" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">当球落在地板上时，我们不希望它反弹回来，但相反，这是我们输掉游戏的时候——游戏结束。</p><p id="a875" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们安排下一轮<code class="fe nh ni nj nk b">animate()</code>之前，我们检查球是否在球场底部出界。如果游戏输了，我们会向用户显示一条消息。我们通过设置<code class="fe nh ni nj nk b">fillStyle</code>在屏幕上书写文本，并用<code class="fe nh ni nj nk b">fillText()</code>告诉我们想要的内容和位置。在这里，我们将消息计算在画布的中间。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9447" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<code class="fe nh ni nj nk b">return</code>语句来短路<code class="fe nh ni nj nk b">animate()</code>循环。如果<code class="fe nh ni nj nk b">isGameOver()</code>返回真，我们不请求下一帧。现在，如果我们运行代码，球会像它应该的那样从墙上弹回，当球落在界外时，我们会在屏幕上看到一个游戏。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b6e3ebfa41ae2f86e0e40cdda50876f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*qYizDUDBLY0vBR0djKWZVA.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">屏幕上的游戏</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="3eb1" class="lq lr it bd ls lt nc lv lw lx nd lz ma mb ne md me mf nf mh mi mj ng ml mm mn bi translated">涉水</h1><p id="a641" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">现在我们有了一个从墙上弹回的球，是时候通过增加玩家互动将这个演示演变成一个游戏了。让我们添加一个玩家可以控制和弹开球的球拍！</p><p id="597c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像往常一样，我们首先添加一些变量来定义一个<code class="fe nh ni nj nk b">paddle</code>对象:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="be3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">球拍在球场底部移动，因此y轴上的值是恒定的。对同一个对象的height属性存在依赖，这意味着我们需要使用一个<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" rel="noopener ugc nofollow" target="_blank"> getter </a>。</p><p id="593c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，我们需要跟踪桨在每个时刻在x轴上的位置。我们希望每次开始新的生活或关卡时，球拍都从球场中央开始，所以我们定义了一个函数<code class="fe nh ni nj nk b">resetPaddle()</code>，在这里我们计算x值:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="790b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，球拍必须比球快，这样我们才有机会接住球，所以我们将球拍的<code class="fe nh ni nj nk b">dx</code>设置为游戏速度的增量。</p><h2 id="2e2b" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">划桨</h2><p id="eab8" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">接下来，我们添加在每一帧绘制船桨所需的代码。我们向我们的<code class="fe nh ni nj nk b">images</code>对象添加一个<code class="fe nh ni nj nk b">paddle</code>属性，并将<code class="fe nh ni nj nk b">src</code>设置为球拍的图像。然后我们在<code class="fe nh ni nj nk b">paint()</code>函数中使用<code class="fe nh ni nj nk b">drawImage()</code>作为背景和球，在每一帧的正确位置绘制球拍:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="ec4c" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">控制桨</h2><p id="5dce" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">现在我们已经添加了绘图逻辑，我们可以从有趣的部分开始——让用户控制桨！我们应该按住左右箭头键来移动桨。为了实现这一点，我们需要:</p><ul class=""><li id="f49b" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">变量来存储左右键的状态。</li><li id="8501" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">事件侦听器知道按键何时被按下和释放。</li></ul><p id="0a22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以将<code class="fe nh ni nj nk b">leftKey</code>和<code class="fe nh ni nj nk b">rightKey</code>添加到我们的<em class="op">游戏对象</em>中，默认值为<code class="fe nh ni nj nk b">false</code>，因为这些按钮在游戏开始时不会被按下:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="6ed5" class="nq lr it nk b gy oi oj l ok ol">let game = {<br/>  speed: 8,<br/>  requestId: null,<br/>  <strong class="nk iu">leftKey: false,<br/>  rightKey: false</strong><br/>}</span></pre><p id="62e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们为<code class="fe nh ni nj nk b">keydown</code>和<code class="fe nh ni nj nk b">keyup</code>事件添加事件监听器。这些将监听按键和释放:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="80ad" class="nq lr it nk b gy oi oj l ok ol">document.addEventListener('keydown', keyDownHandler);<br/>document.addEventListener('keyup', keyUpHandler);</span></pre><p id="a0eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您按下键盘上的一个键时，<code class="fe nh ni nj nk b">keydown</code>事件触发并调用<code class="fe nh ni nj nk b">keyDownHandler()</code>函数。随着键的释放，<code class="fe nh ni nj nk b">keyup</code>事件触发并调用<code class="fe nh ni nj nk b">keyUpHandler()</code>函数。以下代码定义了这些功能以及我们用于左右移动的按键:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="1afd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个函数都将事件作为参数，由<code class="fe nh ni nj nk b">e</code>变量表示。<code class="fe nh ni nj nk b">key</code>属性保存关于被按下的键的信息。现代浏览器使用<code class="fe nh ni nj nk b">ArrowRight</code>和<code class="fe nh ni nj nk b">ArrowLeft</code>作为左/右箭头键。当我们按下一个键时，相关变量被设置为<code class="fe nh ni nj nk b">true</code>。当释放该键时，变量变回<code class="fe nh ni nj nk b">false</code>。</p><h2 id="20e8" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">移动船桨</h2><p id="00ac" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">现在我们已经设置了变量、事件和函数来更新变量，我们可以使用这些按下的变量来更新球拍在屏幕上移动的x位置。我们可以在<code class="fe nh ni nj nk b">update()</code>功能中这样做，如果按下左键或右键，我们将改变<code class="fe nh ni nj nk b">x</code>坐标:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8549" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果按键被按下，我们通过增加或减少<code class="fe nh ni nj nk b">paddle.dx</code>来更新<code class="fe nh ni nj nk b">paddle.x</code>变量。我们还需要检查是否已经到达墙壁，在这种情况下，我们将<code class="fe nh ni nj nk b">x</code>变量保持在这些最小值和最大值。</p><h2 id="11ab" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">把球从球拍上弹开</h2><p id="5b3f" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">最后，我们必须为桨添加碰撞检测。当球碰到球拍时，球应该会反弹回比赛场地。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/a23d4329388e985f5fc6d1a03d45c7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*GID4E2RzYvEU1NlylsJYUQ.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">球拍里的球。</figcaption></figure><p id="3ebc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要做到这一点，我们可以检查球是否已经到达球拍，是否在球拍的左右边缘之间。由于我们从左上角开始测量球，所以在检查球是否到达球拍时，我们需要加上2 *半径。这就是为什么我们必须在检查碰撞之前更新坐标的值。同样，当我们检查球是否击中水平面上的球拍时，我们必须记住计算中的半径:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4be4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行代码，我们可以控制球拍并用它拍球。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e3716f6ef9a937ff4112ed1dde446f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*cqOb0KzWgL3YxptH16GatA.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">球从球拍上弹开</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="899b" class="lq lr it bd ls lt nc lv lw lx nd lz ma mb ne md me mf nf mh mi mj ng ml mm mn bi translated">砖块</h1><p id="30a6" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">在墙上拍球很有趣，但很快就会变得无聊。我们需要的是可以摧毁的东西！这就是我们在本课中所做的，创建一个砖场。</p><h2 id="de5b" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">定义砖块</h2><p id="7202" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">首先，我们需要设置一些变量来定义砖块。将以下代码行添加到您的代码中，以创建一个块配置对象:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="6576" class="nq lr it nk b gy oi oj l ok ol">let brick = {<br/>  rows: 5,<br/>  cols: 10,<br/>  get width() {<br/>    return canvas.width / this.cols;<br/>  },<br/>  height: 30<br/>}</span></pre><p id="1176" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们定义砖块的行数和列数以及它们的高度。我们使用一个getter来根据列数计算砖块的宽度。</p><h2 id="63e1" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">砖场</h2><p id="30f5" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">我们将所有的砖块放在一个名为<code class="fe nh ni nj nk b">brickField.</code>的数组中，它包含了所有砖块对象的位置和大小，以便在屏幕上绘制每块砖块。我们用行和列循环初始化数组。然后，我们在每次迭代中向<code class="fe nh ni nj nk b">brickField</code>数组添加一个具有以下属性的砖块:</p><ul class=""><li id="1ab2" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">x位置</li><li id="239c" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">y位置</li><li id="6527" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">高度</li><li id="e6b5" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">宽度</li><li id="5fd4" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">颜色</li><li id="6322" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">点</li><li id="c54b" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">hitsLeft</li></ul><p id="c8fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们根据行和列以及砖块的宽度和高度计算出<code class="fe nh ni nj nk b">x</code>和<code class="fe nh ni nj nk b">y</code>坐标。<code class="fe nh ni nj nk b">topMargin</code>在画布的顶部留下了一些空间，我们稍后会用到。</p><p id="2c9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们按行设置了<code class="fe nh ni nj nk b">color</code>，但是在创建新的关卡时，我们可以更有创造性。<code class="fe nh ni nj nk b">points</code>也依赖于这一行，我们通过的每一行砖块都会得到更多的分数。砖块可以承受撞击，有时需要多次撞击才能被摧毁。这里我们用<code class="fe nh ni nj nk b">hitsLeft</code>属性设置第一行的砖块在两次点击后消失:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3d08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码将遍历行和列，并创建我们添加到砖块数组中的新砖块对象。</p><h2 id="8157" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">画砖</h2><p id="c4ff" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">现在让我们创建一个绘制砖块的函数。首先，我们检查<code class="fe nh ni nj nk b">hitsLeft</code>是否大于零，这意味着砖块仍然可见。如果它有左击，它会被画在屏幕上。然后，在使用<code class="fe nh ni nj nk b">fillRectangle()</code>和<code class="fe nh ni nj nk b">strokeRectangle()</code>绘制砖块之前，我们从砖块属性中设置<code class="fe nh ni nj nk b">color</code>:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b874" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们需要在<code class="fe nh ni nj nk b">paint()</code>函数中添加一个对<code class="fe nh ni nj nk b">drawBricks()</code>的调用，来绘制每一帧中砖块的领域。</p><h1 id="a2c5" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">砖块碰撞</h1><p id="f4c5" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">现在我们已经让砖块出现在屏幕上了，是时候让它们在我们用球击中它们时消失了。</p><p id="26f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们检查球和砖块之间的碰撞时，我们首先检查球是否在砖块内部。然后，我们检查球从哪个方向击中砖块，以了解要做出什么方向的改变。</p><p id="cde8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要使球在砖块内，以下四个条件都必须成立:</p><ul class=""><li id="9ec9" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">球的x位置大于砖块的x位置。</li><li id="f8f4" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">球的x位置小于砖块的x位置加上它的宽度。</li><li id="d899" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">球的y位置大于砖块的y位置。</li><li id="9334" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">球的y位置小于砖块的y位置加上它的高度。</li></ul><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/6b024698cd5b84d7f18c5114e42fef28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*AnBHBMBvydFdYogycy3Xzg.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">计算中使用的球和砖坐标</figcaption></figure><p id="4332" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们要创建一个碰撞检测函数，循环遍历所有砖块，将球与其位置进行比较。为了提高代码的可读性，我们为所有的计算定义了一个函数表达式<code class="fe nh ni nj nk b">isBallInsideBrick</code>。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="ec90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们前面看到的，当我们绘制砖块时，我们通过<code class="fe nh ni nj nk b">hitsLeft</code>属性知道砖块是否可见。当砖块被击中时，我们减少它。我们还将最上面一行的颜色设置为灰色，该行在被销毁之前需要两次点击。</p><p id="56a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们击中砖块时，砖块会消失，但如果球在我们这样做时改变方向，那也很好。</p><h1 id="4b1a" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">碰撞方向</h1><p id="beac" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">为了在碰撞后将球弹向正确的方向，我们需要知道球击中了砖块的哪一面。</p><p id="2555" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过移除变化<code class="fe nh ni nj nk b">ball.dx</code>来计算球是来自左边还是右边，并找出球在撞击前是在砖块的左边还是右边。如果这是真的，我们否定<code class="fe nh ni nj nk b">dx</code>使球从它来的地方反弹回来。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="855a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这两种情况都不成立，那么我们知道球击中了砖块的顶部或底部，在这种情况下，我们否定<code class="fe nh ni nj nk b">ball.dy</code>使球反弹回来。</p><p id="3fa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时我们会在同一个框架中击中多个砖块。例如，如果我们从底部击中两块砖，并改变方向两次，球将会穿过砖。出于这个原因，我们需要一个变量<code class="fe nh ni nj nk b">directionChanged</code>来跟踪，这样我们每帧只改变一次方向。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d94c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后要做的是将对<code class="fe nh ni nj nk b">detectBrickCollision()</code>函数的调用添加到我们的<code class="fe nh ni nj nk b">animate()</code>函数中，就在<code class="fe nh ni nj nk b">collisionDetection()</code>调用的下面。有了这些变化，我们就能敲碎砖头了。当我们击中一个球时，球会像预期的那样反弹。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/1ced3192a1dca8d4cd4fc9f49a343c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/1*Fq-iGrm_M8eZjEE8a9EjXQ.gif"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">球碰到砖块改变了方向。</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a6ad" class="lq lr it bd ls lt nc lv lw lx nd lz ma mb ne md me mf nf mh mi mj ng ml mm mn bi translated">分数、等级和生活</h1><p id="0a99" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">现在我们可以摧毁砖块，游戏准备奖励击中砖块的分数，并记录总分数。当所有的砖块都被清除后，游戏应该会进入下一关。而在我们抓不住球的时候，有不止一次的生命去获得另一次机会，不是很好吗？</p><h2 id="ba95" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">游戏变量</h2><p id="4f10" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">为了跟踪游戏中的所有这些新状态，我们将它们添加到游戏对象中。由于这些值需要在每个游戏开始时重置，我们将它们添加到<code class="fe nh ni nj nk b">resetGame()</code>函数中:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="73c0" class="nq lr it nk b gy oi oj l ok ol">function resetGame() {<br/>  game.speed = 8;<br/>  <strong class="nk iu">game.score = 0;<br/>  game.level = 1;<br/>  game.lives = 3;</strong><br/>}</span></pre><h2 id="4560" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">显示文本</h2><p id="a72f" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">在画布上绘制文本类似于绘制形状。首先，我们设置<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font" rel="noopener ugc nofollow" target="_blank">font</a></code>的大小和类型。接下来，我们使用<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle" rel="noopener ugc nofollow" target="_blank">fillStyle</a></code>来设置字体的颜色，最后使用<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillText" rel="noopener ugc nofollow" target="_blank">fillText()</a></code>来告诉我们想要在画布上显示什么文本以及显示在哪里。</p><p id="c9ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是在屏幕上显示所有这些新的变量，这样玩家就可以随时获得最新的信息。让我们添加一个<code class="fe nh ni nj nk b">drawScore()</code>函数，用<code class="fe nh ni nj nk b">level</code>和<code class="fe nh ni nj nk b">score</code>创建和更新显示:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b080" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码在屏幕顶部打印当前级别和点数。</p><h2 id="0d33" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">剩余生命</h2><p id="b08c" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">我们也可以用文字来书写生命，但为了让它更有趣，我们可以为我们剩余的每一个生命展示一个小小的桨。我们可以通过使用与桨相同的图像，并为我们剩下的每个生命绘制它来做到这一点:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="95ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，一个小桨出现在屏幕的右上方，代表我们每个人的生活。为了使用我们为游戏信息创建的函数，我们在<code class="fe nh ni nj nk b">draw()</code>函数中添加了对它们的调用:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="452e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">更新值</h1><p id="7e64" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">现在我们在屏幕上显示了所有的变量，我们需要更新它们来增加分数和等级，同时记录我们失去的生命。</p><h2 id="43e3" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">得分</h2><p id="d4dd" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">还记得上一章我们添加了每块砖的价值点数吗？每当我们摧毁一个，现在是时候把这些加到我们的总得分上了。</p><p id="57ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了增加分数，我们在<code class="fe nh ni nj nk b">detectBrickCollisions()</code>中每击中一次砖块，就增加砖块的价值分数:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="bdf6" class="nq lr it nk b gy oi oj l ok ol">game.score += brick.points;</span></pre><p id="e5dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，那很容易！下一个值有点复杂。</p><p id="7e1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想添加一个高分列表，请阅读我的文章:</p><ul class=""><li id="2443" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><a class="ae kz" href="https://michael-karen.medium.com/how-to-save-high-scores-in-local-storage-7860baca9d68" rel="noopener">如何在本地存储中保存高分</a></li></ul><h2 id="b99c" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">级别</h2><p id="44ea" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">当没有更多的砖块时，我们进行到下一个水平。当所有砖块的<code class="fe nh ni nj nk b">hitsLeft</code>都等于零时，就没有砖块了。我们如何检查一个数组中的所有元素来得到一个特定的属性值呢？</p><p id="941f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最适合的数组方法是<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank"> every() </a>。它可以检查数组中的所有元素是否都通过了我们提供的测试。检查何时没有砖块剩余，如果是这样，进入下一关:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0af0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在<code class="fe nh ni nj nk b">animate()</code>函数中添加了一个对<code class="fe nh ni nj nk b">isLevelCompleted()</code>的调用，如果该级别已经完成，则在请求新的帧之前退出:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="51cb" class="nq lr it nk b gy oi oj l ok ol">if (isLevelCompleted() || isGameOver()) return;</span></pre><p id="6e9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们没有剩余的砖块时，我们增加<code class="fe nh ni nj nk b">game.level</code>。当我们突破得更好时，开始速度变得太容易了。太容易意味着无聊。当我们升级时，我们通过增加<code class="fe nh ni nj nk b">game.speed</code>来增加难度。</p><p id="37e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们重新设置比赛场地，结果球和球拍在新的关卡上移动得更快了。请记住，如果关卡完成，我们会停止动画。原因是我们想在继续游戏之前显示几秒钟的屏幕。我们使用<code class="fe nh ni nj nk b">setTimeout()</code>并设置在继续游戏前暂停的毫秒数。</p><p id="eeb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似地，正如我们对<code class="fe nh ni nj nk b">cancelAnimationFrame()</code>所做的，我们将<code class="fe nh ni nj nk b">clearTimeout(game.timeoutId)</code>添加到<code class="fe nh ni nj nk b">play()</code>函数的开头，使得在没有另一个动画循环启动的情况下开始一个新游戏成为可能。</p><h2 id="585c" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">生活</h2><p id="eaee" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">最后，我们修改<code class="fe nh ni nj nk b">gameOver()</code>函数，在游戏结束前检查我们是否还有生命。我们减少<code class="fe nh ni nj nk b">lives</code>，当我们达到零时，游戏结束。否则，我们通过调用<code class="fe nh ni nj nk b">resetBall()</code>得到一个新球:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/94af8cee1b5898a99bb9549635684c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCpF5ha4-cXznKX8UsbO_w.png"/></div></div></figure><h1 id="ce6f" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">声音</h1><p id="3928" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">在我们至少加入一些音效之前，没有一个游戏是完整的。有许多免费网站可以找到声音样本使用。我从freesound.org的作品中选了一些。</p><p id="aa53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将为以下内容添加音效:</p><ul class=""><li id="4b50" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">球击中了球拍</li><li id="8ffc" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">球撞上了砖块</li><li id="d107" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">球发射</li><li id="923c" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">游戏结束</li><li id="ac5b" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">完成的级别</li></ul><p id="ace9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nh ni nj nk b"><strong class="kd iu">Audio()</strong></code>构造函数创建并返回一个新的<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement" rel="noopener ugc nofollow" target="_blank">HTMLAudioElement</a></code>用于播放音频:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="b56f" class="nq lr it nk b gy oi oj l ok ol">const audioElement = new Audio(url);<br/>audioElement.play();</span></pre><p id="53f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可选的<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMString" rel="noopener ugc nofollow" target="_blank">DOMString</a></code>包含音频文件的URL。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4437" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了可以在构造函数中添加URL之外，我们添加声音的方式类似于我们创建图像的方式。</p><p id="ea52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以在找到这些元素在代码中的位置时播放它们。例如，我们将<code class="fe nh ni nj nk b">gameOver</code>声音添加到<code class="fe nh ni nj nk b">gameOver()</code>函数中。有时我们会撞上多块砖。为了在我们敲击下一块砖时重新播放声音，我们将<code class="fe nh ni nj nk b">currentTime</code>设置为零:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="9757" class="nq lr it nk b gy oi oj l ok ol">sounds.brick.currentTime = 0;<br/>sounds.brick.play();</span></pre><p id="4ba1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经注意到我们在sounds对象中添加了<code class="fe nh ni nj nk b">music</code>。游戏音乐在我们按下开始键时开始，在游戏结束时结束。因为我们不想让音乐结束，所以我们将它设置为重复播放:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="12ad" class="nq lr it nk b gy oi oj l ok ol">sounds.music.loop = true;</span></pre><p id="73ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以将音频的音量设置在0到1之间。为了确保音乐在开始时不会太大声，我们可以将其设置为比最大值低一点:</p><pre class="mu mv mw mx gt oe nk of og aw oh bi"><span id="1ab1" class="nq lr it nk b gy oi oj l ok ol">sounds.music.volume = 0.6;</span></pre><p id="c9a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以在<code class="fe nh ni nj nk b">keyDownHandler</code>中添加一些键盘触发器来切换音乐的开关和控制音量。随着所有的声音到位，我们真的有一些东西开始类似于一个完整的游戏。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="fde7" class="lq lr it bd ls lt nc lv lw lx nd lz ma mb ne md me mf nf mh mi mj ng ml mm mn bi translated">结论</h1><p id="ac31" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">今天我们学习了如何用HTML画布和JavaScript创建一个完整的游戏。我希望你喜欢这篇文章，并学到了一些新东西。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><div class="mu mv mw mx gt pa"><a href="https://www.educative.io/courses/game-development-js-tetris" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">用JavaScript开发游戏:创建俄罗斯方块-互动学习</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">在本课程中，您将获得使用JavaScript进行游戏开发的实践经验。使用俄罗斯方块的经典游戏…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">www.educative.io</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po jz pa"/></div></div></a></div><h2 id="d584" class="nq lr it bd ls nr ns dn lw nt nu dp ma km nv nw me kq nx ny mi ku nz oa mm ob bi translated">资源</h2><ul class=""><li id="373e" class="la lb it kd b ke mo ki mp km pp kq pq ku pr ky lf lg lh li bi translated"><a class="ae kz" href="https://medium.com/dailyjs/how-to-get-started-with-canvas-animations-in-javascript-cb2ccf37515c" rel="noopener">如何开始使用JavaScript制作画布动画</a></li><li id="faea" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated"><a class="ae kz" href="https://michael-karen.medium.com/how-to-save-high-scores-in-local-storage-7860baca9d68" rel="noopener">如何在本地存储中保存高分</a></li><li id="873c" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated"><a class="ae kz" href="https://michael-karen.medium.com/learning-modern-javascript-with-tetris-92d532bcd057" rel="noopener">用俄罗斯方块学习现代JavaScript】</a></li><li id="afc3" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated"><a class="ae kz" href="https://github.com/melcor76/js-breakout" rel="noopener ugc nofollow" target="_blank">带有js-breakout的GitHub库</a>。</li><li id="dd8d" class="la lb it kd b ke nl ki nm km nn kq no ku np ky lf lg lh li bi translated">声音来自<a class="ae kz" href="https://freesound.org/" rel="noopener ugc nofollow" target="_blank">freesound.org</a></li></ul></div></div>    
</body>
</html>