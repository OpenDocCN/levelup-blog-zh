<html>
<head>
<title>Unit Testing Controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试控制器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-controllers-9e832bca1bae?source=collection_archive---------10-----------------------#2021-06-27">https://levelup.gitconnected.com/unit-testing-controllers-9e832bca1bae?source=collection_archive---------10-----------------------#2021-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5090" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用HttpContext、Request、ModelState对操作方法进行单元测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3d1f5848d8d735de7f1ded9a8502b2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mo-PDVZ6VPnm2V0HhyztXg.png"/></div></div></figure><p id="819c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们针对控制器进行不同级别的测试。当单元测试控制器逻辑时，测试只执行动作方法本身，而不通过框架的请求/响应管道。换句话说，过滤器属性(例如，<code class="fe lq lr ls lt b">Authorize</code>属性)、模型绑定和中间件不影响控制器的单元测试。因此，单元测试控制器逻辑非常类似于测试一个常规的类，我们可以模拟依赖关系，存放输入值并验证输出。</p><p id="3183" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，有一点很特别，控制器有一个隐式的依赖关系，<code class="fe lq lr ls lt b">ControllerContext</code>，它是从<code class="fe lq lr ls lt b">ControllerBase</code>继承来的。<code class="fe lq lr ls lt b">ControllerContext</code>包括<code class="fe lq lr ls lt b">HttpContext</code>、<code class="fe lq lr ls lt b">ModelState</code>、<code class="fe lq lr ls lt b">Request</code>、<code class="fe lq lr ls lt b">Response</code>等常用特性。</p><p id="3b2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将回顾一些单元测试涉及<code class="fe lq lr ls lt b">HttpContext</code>的动作方法时的用例。例如，一个动作方法基于<code class="fe lq lr ls lt b">ClaimIdentity</code>检查当前用户的角色，一个动作方法检查HttpRequest头值。我们将看到如何上演<code class="fe lq lr ls lt b">HttpContext</code>和<code class="fe lq lr ls lt b">Request</code>。按照类似的方式，我们也应该知道如何在单元测试中放置<code class="fe lq lr ls lt b">Response</code>和<code class="fe lq lr ls lt b">ModelState</code>。</p><p id="dec0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">源代码在<a class="ae lu" href="https://github.com/dotnet-labs/ControllerUnitTests" rel="noopener ugc nofollow" target="_blank">我的GitHub库</a>里。现在让我们开始吧。</p><h1 id="8a2b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">要求</h1><p id="ec20" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">声明通常用于检查权限和/或区分结果。例如，在一个action方法中，我们可以首先使用<code class="fe lq lr ls lt b">User.FindFirstValue(ClaimTypes.Role)</code>获得一个用户的角色，然后根据角色的权限级别确定下一步。</p><p id="7858" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当单元测试一个动作方法时，我们想要检查不同用户角色的行为，因此我们需要模拟不同的用户访问API端点。在这种情况下，我们可以配置控制器的<code class="fe lq lr ls lt b">ControllerContext</code>并为期望的用户设置<code class="fe lq lr ls lt b">HttpContext</code>。让我们来看看下面的测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="42e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，第1行到第5行向用户展示了一个<code class="fe lq lr ls lt b">Admin</code>角色。然后，第6行到第9行实例化一个控制器实例，并将一个<code class="fe lq lr ls lt b">HttpContext</code>附加到控制器上，其中的<code class="fe lq lr ls lt b">HttpContext</code>包括登台用户。这样，第11行执行测试中的action方法，其余的被断言。</p><p id="8213" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，我们可以安排不同种类的声明，并将它们绑定到控制器上进行测试。</p><h1 id="5285" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">请求标题</h1><p id="7451" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">知道了如何将<code class="fe lq lr ls lt b">HttpContext</code>连接到控制器，我们可以尝试配置HTTP请求。</p><p id="dcbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们以一个人为的动作方法为例，它具有基于请求头中语言的逻辑，其中语言值可以通过使用<code class="fe lq lr ls lt b">var lang = Request.Headers["lang"].ToString();</code>获得。为了准备一个请求头键值对，我们可以首先将一个<code class="fe lq lr ls lt b">HttpContext</code>附加到控制器，然后设置所需的请求头。</p><p id="af87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的代码片段显示了一个单元测试示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8939" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第5行在请求头集合中设置了一个键值对。注意，第3行是必需的，因为<code class="fe lq lr ls lt b">Request</code>对象位于<code class="fe lq lr ls lt b">HttpContext</code>中。</p><h1 id="74fb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型状态</h1><p id="b259" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">由于单元测试不通过模型绑定过程运行，因此如果单元测试需要检查依赖于<code class="fe lq lr ls lt b">ModelState</code>的一些逻辑，那么<code class="fe lq lr ls lt b">ModelState</code>应该被分阶段。</p><p id="b4dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似于<code class="fe lq lr ls lt b">HttpContext</code>和<code class="fe lq lr ls lt b">Request</code>，我们可以根据自己的需要来操纵<code class="fe lq lr ls lt b">ModelState</code>对象。<code class="fe lq lr ls lt b">ModelState</code>对象存在于控制器中，因此暂存<code class="fe lq lr ls lt b">ModelState</code>可以很简单。让我们看看下面的示例测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，第3行和第4行演示了如何改变<code class="fe lq lr ls lt b">ModelState</code>对象。这段代码让我们能够验证动作方法中的验证逻辑。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="ac13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天到此为止。同样，源代码可以在<a class="ae lu" href="https://github.com/dotnet-labs/ControllerUnitTests" rel="noopener ugc nofollow" target="_blank">我的GitHub库</a>中找到。感谢阅读。</p></div></div>    
</body>
</html>