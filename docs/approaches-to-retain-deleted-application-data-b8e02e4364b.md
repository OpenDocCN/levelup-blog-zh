# 软删除会使你的应用变得复杂

> 原文：<https://levelup.gitconnected.com/approaches-to-retain-deleted-application-data-b8e02e4364b>

## 以下是变通方法和替代方法

![](img/615fb872a01ea39c7de1cbccfb09f86a.png)

图片由 [@devintavery](https://unsplash.com/@devintavery) 在 [Unsplash](https://unsplash.com/) 上

软件应用程序生成的数据是有价值的。对于可以从应用程序中删除的数据也是如此。保留已删除的数据有助于跟踪数据历史、趋势和数据之间的关系。除此之外，应用程序的某些部分可能能够利用已删除的历史数据。

因此，许多软件应用程序的设计方式是数据实际上永远不会被删除。实现这一点的一种流行方法是软删除。尽管这种方法看起来很简单，但它通常会导致复杂性。在这里，我们将看看是什么使软删除变得复杂。我们还将研究软删除的另一种方法及其优缺点。

# 支持软删除

为了支持软删除，我们只需向模式中添加一个新字段。根据此字段的值，记录被标记为已删除。例如，`users`表可能有以下模式:

```
id: string
username: string
password: string
created_date: Date
deleted: boolean
```

在上面的例子中，任何将`deleted`字段设置为`true`的用户都被视为已删除。

## 软删除的优点

软删除最吸引人的优点是，软删除的数据很容易恢复。恢复数据就像更改标志字段的值一样简单。

此外，软删除比硬删除快，因为数据库中的`UPDATE`操作通常比删除操作快。

由于提供的灵活性，软删除在调试生产数据时也很有帮助。当所有内容都在同一个表或集合中时，分析生产数据也更容易。

## 软删除的陷阱

尽管这些优点很吸引人，但是软删除也引入了一些通常难以处理的复杂性。

首先，应用程序中的每个查询都必须包含一个过滤掉已删除记录的条件。不这样做将导致被删除数据的泄露。该查询类似于以下内容:

```
SELECT * from users where deleted=false;
```

乍一看，这似乎微不足道，但是在处理大型代码库时，尤其是在使用大量连接的复杂查询中，很容易忘记这一条件。

但是，创建应用此条件的数据库视图并查询视图而不是表可能是解决此问题的好方法。

此外，随着删除的数据越来越多，select 操作可能会变慢。单列索引没有帮助，因为必须在每个查询中使用`deleted`标志字段的值过滤结果。

添加一个多列索引，将第一列作为`deleted`标志字段，并在查询中巧妙利用它，应该会使这个过程更快。可以通过以下方式添加加速选择的索引:

```
CREATE INDEX "users_username_unique" ON users(deleted, username);
```

如果表中有很多被删除的记录，那么在同一个查询中用`deleted`和`username`过滤时，上述索引会显著减少搜索空间。

```
SELECT * FROM users WHERE deleted=false AND username="foobar";
```

我们同样可以为每个字段或字段集创建多个列索引，我们通常会为这些字段创建索引。然而，由于增加多列索引的成本，这些多列索引最终可能会降低`UPDATE`操作的性能。

创建多列索引并不是什么大事。然而，在支持软删除的表中，处理一些数据库约束也会变得很麻烦。

假设我们在`users`表的`email`字段上有一个唯一的约束。我们将有一个问题，如果有一个用户用电子邮件`foo@bar.com`删除他们的帐户，然后用相同的电子邮件创建一个新的。

为了解决这个问题，我们需要添加一个[部分索引](https://en.wikipedia.org/wiki/Partial_index)来代替常规索引。部分索引允许我们在创建索引时使用 WHERE 子句只对字段的子集创建索引，如下所示:

```
CREATE UNIQUE INDEX "users_username_unique" ON users(deleted, email) WHERE deleted=false;
```

这只会为实时记录添加唯一索引。这意味着对于已删除的记录，是否重复使用`email`并不重要。然而，部分索引只被一些数据库支持，并且也可能因为增加部分索引的成本而减慢`UPDATE`操作。

尽管如此，我遇到过很多应用程序不允许重用像`username`和`email`这样的唯一字段的值，即使它们已经被删除了。所以，这种做法似乎是可以接受的。

最后，在进行软删除时，通常只需设置标志字段就可以了。但是，一些表和集合可能包含实际上应该删除的敏感数据。因此，在执行软删除时，我们需要单独处理敏感数据。如下例所示。

```
UPDATE users set deleted=true, deleted_date=NOW(), credit_card_number=NULL where id='someId';
```

# 另一种选择:复制硬删除

现在，让我们看看使用硬删除的软删除的替代方案。

使用这种方法时，记录在删除前被复制到另一个表中。另一个表充当已删除数据的归档。

实现这一点最简单的方法是使用数据库触发器。下面是一个使用 PostgreSQL 的示例。

## 复制硬删除的优点

使用这种方法的主要优点是，删除的数据和活动的数据是明确分开的。因此，没有泄露已删除数据的机会。

此外，很容易将原始表中的字段子集移动到存档表中。这使我们可以只挑选我们感兴趣的领域，删除敏感数据并最小化空间。

最后，在数据库级别，我们不必仅仅因为有了`deleted`标志字段就创建复杂的索引。

## 复制时硬删除的陷阱

尽管这种方法比软删除有明显的优势，但它也有相当多的缺点。

这种方法的一个主要缺点是恢复被删除的数据很复杂，因为记录必须从存档表复制到原始表。然而，一个好的数据库设置应该已经有可用于恢复数据的定期备份。最重要的是，恢复被删除的数据通常是一项特殊的请求，而不是一项日常任务。因此，多花一点时间来恢复被删除的数据通常是可以接受的。

另一个缺点是`DELETE`操作通常比`UPDATE` 操作慢。在此基础上，我们用触发器添加了几毫秒，并插入到存档表中。然而，我们已经在不支持任何形式的软删除或归档的表中使用了`DELETE`查询。此外，实际删除记录将确保我们的索引只包含实时数据，而不是包含已删除数据和实时数据的混合。因此，使用`DELETE`查询应该不成问题。

最后一个缺点是很难维护存档表上的关系。例如，如果`users`表与`companies`表有多对一的关系，那么`users_archive`中的记录所指向的公司可能存在于`companies`(对于活动的公司)或`companies_archive`(对于已删除的公司)。

# 结论

软删除更容易设置，但是在使用支持它的表和集合时，开发人员应该注意一些技术问题。由于索引的复杂性，这也可能导致一些性能问题。尽管如此，软删除提供了一些生活质量特性，如删除数据之间的关系和轻松恢复。

相比之下，使用触发器和额外的表来设置带复制的硬删除有点复杂，但对于开发人员来说，在处理查询时更容易。它还确保索引不复杂，并且更容易检查性能问题。这种方法还牺牲了一些生活质量特性，以便更好地分离关注点。

我认为最好根据应用程序的性质和开发团队的实践来权衡这两种方法的优缺点，而不是宣称一种比另一种好。这两种方法各有利弊。也就是说，我个人只会在业务需求需要时选择软删除。