<html>
<head>
<title>Learn how to create job scheduler in the Spring Boot application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何在Spring Boot应用程序中创建作业调度程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-how-to-create-job-schedulers-in-spring-boot-application-8def2c476424?source=collection_archive---------4-----------------------#2020-08-19">https://levelup.gitconnected.com/learn-how-to-create-job-schedulers-in-spring-boot-application-8def2c476424?source=collection_archive---------4-----------------------#2020-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="33bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘿伙计们，怎么了？在这篇博客中，我们将通过一个独特的例子来学习如何在Spring Boot应用程序中创建一个作业调度程序。</p><p id="f8f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，我们将从<a class="ae kl" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>创建一个项目。只需对Spring Boot应用程序进行简单的设置，我们就可以创建任意多的调度程序。下图显示了所需的依赖关系。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4b1edbdc25d5ac942ec5aed0fd3bc839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXmTPWY4tHlgy8HZVP6WSg.png"/></div></div></figure><p id="873c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个微服务，可以导出一些数据，如zip文件或任何类型的文件，存储在数据库中。一种显而易见的方法是通过REST端点启动流程，并等待文件生成。如果数据不复杂，并且大小很小，您可以在几秒钟内得到您期望的结果。这称为同步作业。但是，如果数据很复杂，涉及许多数据库查询和其他内部操作，并且需要更多时间来生成，该怎么办呢？结果是糟糕的用户体验。当然，我们可以通过增加客户端和服务器之间的超时来解决这个问题。同样，这不是一个有效的解决方案。</p><p id="7d80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的日程表来了。我们仍将使用相同的端点来启动流程。但是这一次，我们没有等待它完成，而是启动并立即返回一个带有元数据的200 OK。小心，我们现在处理的是一个状态；你以后就知道了，为什么。下面是这个过程。为了简单起见，我只是模拟了启动-导出过程。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/7b448bfd424a6fb1a37b294526251e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14LGJd9A_e3elvdA18nqpA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">FileExportController.java</figcaption></figure><p id="a312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述API的响应如下图所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ld"><img src="../Images/8cdf625637e49801816f59653512c422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4L9u8CRYgswS66fwJpIuJQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">response.json</figcaption></figure><p id="4ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候编写我们的作业调度程序了。用Spring的方式，我们会写一个组件。我喜欢Spring boot的原因是它的自动配置概念。只需一个名为<em class="le"> @EnableScheduling </em>的注释，我们就可以编写简单的调度程序。在下面的代码中，我没有添加这个注释。你可以在这里或主类中添加它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lf"><img src="../Images/c96a1c83246b46444fc2bc83c6159278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRFLQqqas0k5b9rEcUzfRA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">FileExportScheduler.java</figcaption></figure><p id="e6ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们浏览一下文件。我们需要的只是一个运行作业和Java的ExecutorService的方法，以及一个处理并发性的映射。这样我们可以确保线程安全。Spring提供了不同类型的调度器，比如cron作业、固定延迟类型的作业等等。但是现在，我们将看到固定延迟类型。这种类型与固定费率类型的唯一区别在于，后者不会等待之前的唤醒呼叫结束。所以固定延迟类型在作业之间有更多的控制。</p><p id="87ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用注释<em class="le"> @Scheduled，</em>我们将<em class="le"> wakeUp() </em>方法标记为调度程序。Spring会处理剩下的事情，我们可以专注于我们的逻辑。在上一步中，我们通过将状态保存为PENDING来启动作业。我们将在后面看到，为什么IN_PROGRESS也被考虑。为了避免在<em class="le">执行程序</em>中重复提交作业，我们有一个<em class="le">并发哈希表</em>。也就是说，只有当作业不在地图上时，我们才会提交它。现在你可能会想，为什么我们需要在地图上保持这种状态？这让我想到了另一个场景。假设我们有其他资源可以调用这个方法。说到底，<em class="le"> wakeUp() </em>方法是一个公共方法。状态被保存在一个地方(这个调度器类),而不是复制，无论应用程序中有多少个源试图做同样的工作，映射都会处理好。与<em class="le"> SynchronizedMap </em>相比，更喜欢这个map的一个小技巧是，前者将在其bucket级别锁定。更多信息可在此<a class="ae kl" href="https://stackoverflow.com/a/20417527/6487148" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。</p><p id="ac5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们会将当前状态标记为进行中。一旦流程成功完成，我们会将作业标记为已完成，如果出现异常，则会将其标记为失败。我们还通过任何通知机制通知客户。为了更好的可读性和类型安全性，这些状态值可以作为枚举来维护。</p><p id="cf40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个概念实现的主要问题是，“当服务突然停止或任何其他可能干扰过程的技术故障时，如何处理”。因为整个过程都是在后台完成的。用户永远不知道幕后发生了什么。这就是我们在选择查询中包含IN_PROGRESS的原因。一旦服务启动并运行，在灾难发生后，将在初始延迟30秒后执行<em class="le"> wakeUp() </em>方法，其余的将再次执行。当然，IO清理是必需的，您可以将其作为“后处理”来完成。</p><p id="6a1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我想就这样了。你可以自己试试这个。您可以将它与Spring Boot现成的事件监听器结合使用。端点将发布事件，侦听器方法将使用事件对象并触发文件导出方法。所有这些步骤都可以异步执行。调度程序将负责灾难恢复。</p><p id="d704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢，祝您愉快！</p></div></div>    
</body>
</html>