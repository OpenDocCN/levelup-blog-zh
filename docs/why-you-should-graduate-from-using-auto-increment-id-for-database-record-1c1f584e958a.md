# 为什么您应该放弃使用数据库记录的自动递增 ID

> 原文：<https://levelup.gitconnected.com/why-you-should-graduate-from-using-auto-increment-id-for-database-record-1c1f584e958a>

插入新的数据库记录时，从序列号开始移动。

![](img/dee585ef91a62a9afdb5e9461447c0dd.png)

数据库模式。

在任何数据库中，我们总是需要一个标识符来区分不同的记录，通常称为主键。现在，假设我们想要创建一个表来记录用户信息。我们经常会创建这样的表格:

```
create table user(
  id serial primary key,
  full_name varchar
);
```

我们中的大多数人习惯于创建主键序列。记住`serial`是通过`sequence`实现的，它的作用有点像计数器。每当我们向当前表中插入新数据时，下一个序列值就会递增。例如，如果当前表中有 5 行，最后一行的 id 为 5，那么我们插入到表中的下一个数据将创建一个 id 为 6 的记录。

# 那么使用序列号作为主键有什么问题呢？

## 不想要的信息泄露

假设您创建了一个页面来查看用户配置文件，并且您创建了一个格式为`/users/user_id`的路径，其中`user_id`基本上是指用户表上的主键。如果您想计算给定表中的行数，您所要做的就是让系统生成一个新的实体并检查它的 id。想象你去*脸书*，创建一个新账户。你可以大致知道*脸书*里面的总用户记录。

## 易迭代实体

假设前一个端点对公众开放。即使是最没有经验的攻击者现在也可以通过从端点 1 到 n 开始循环并点击端点来获取我们的表信息。抓取所有实体变得非常容易。

## 水平可伸缩性的瓶颈

我们的桌子迟早会变得很大，我们希望它仍然能尽可能快地为用户服务。首先，垂直增加数据库大小的选择是显而易见的，从 2 核 4 GB 增加到 4 核 8 GB，等等。我们的数据库迟早会达到增长的极限。然后我们学习水平扩展，我们可以用几个主数据库来分担输入负载。

现在假设我们有 5 个主数据库来处理新记录的插入，我们像以前一样使用`serial int`作为主键来设置表定义。自然，我们不希望数据库 A 和数据库 B 具有引用不同用户的相同 id 值。id 为 1 的记录应该属于服务中的一个用户。这是一个重要的需求，因为我们通常有其他表使用外键或对用户 id 的引用。假设我们在数据库 A 中有 id 为 1 的用户 A，在数据库 B 中有 id 为 1 的用户 B，然后我们有一个 id 为 1 和用户 id 为 1 的地址表。它属于用户 A 还是用户 B？因此，我们需要在所有数据库中保持一个唯一的 id。

为了保持用户 id 的惟一性，我们需要一种方法在将数据插入任何数据库之前存储实际的 last `sequence`值。假设我们用最简单的方法来做，我们要求所有的数据库返回它的最后一个`sequence`值，取最大的一个值并加 1。正如您所看到的，这引入了一个瓶颈，因为您需要运行对所有数据库的查询来查找下一个增量 id。

我看过一个服务，为了解决这个问题，他们把`sequence`放在另一个数据库里，比如`Redis`，这个数据库仍然足够快，可以提供信息。我反对使用另一个数据库，比如`Redis`，因为用一个不同的表来计算下一个`sequence`值很奇怪。在使用像`Redis`这样的数据库的最坏情况下，当`Redis`重启时，我们只是失去了`sequence`的踪迹。此外，我们添加了太多的编排，只是为了做像插入新记录这样简单的事情。正如你所看到的，虽然这在一定程度上可能行得通，但这显然不是一个合适的解决方案。

# 那么解决办法是什么呢？

不使用`serial id`，而是使用`uuid`作为主键。`UUID`代表*通用唯一标识符。* `UUID`肯定是*通用惟一的*，这使它成为主键的良好候选。

记住`UUID`值是随机产生的。该属性意味着:

*   它并不公开我们的表中当前有多少记录之类的信息。
*   它不容易被迭代，因为它是随机的。
*   它不会在我们的系统中引入水平可伸缩性的瓶颈，因为我们不需要找出下一个`sequence`值是什么。我们可以生成一个新的`UUID`并将其插入到任何数据库中。

因此，它解决了使用`serial id`的所有问题。

## 使用`UUID`有什么弊端？

基本上，我们没有一个有保证的唯一性。然而，碰撞的概率相当小。请记住，在极不可能发生 UUIDs 冲突的情况下，由于主键约束，它将被 DB 捕获。在最坏的情况下，我们可以尝试用新生成的 UUID 重新插入新数据。

对于好奇的灵魂来说，你可以在这里详细阅读碰撞概率[。](https://en.wikipedia.org/wiki/Universally_unique_identifier#Collisions)

瞧，我们完成了。现在，你们应该更好地理解为什么我们应该放弃使用自动递增或`serial id`而使用`UUID`了。