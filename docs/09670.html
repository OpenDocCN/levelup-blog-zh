<html>
<head>
<title>Generating Swagger API Docs And UI Automatically For Express.js Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Express.js应用程序自动生成Swagger API文档和UI</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/generating-swagger-api-docs-and-ui-automatically-for-express-js-apps-2ea1436a0f59?source=collection_archive---------1-----------------------#2021-09-01">https://levelup.gitconnected.com/generating-swagger-api-docs-and-ui-automatically-for-express-js-apps-2ea1436a0f59?source=collection_archive---------1-----------------------#2021-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3dda1098be9a43b344fd9cddcc25873e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cfv7-UWvMi3ZqtddIsrfug.png"/></div></div></figure><p id="26e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你正在编写你的express js API，你可能会遇到这样的情况:你的路由数量在增长，在你的团队内部或团队外部，公开地或私下地交流你的路由及其输入和输出变得越来越困难。</p><p id="7449" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决这个问题的一个常见的选择是用swagger或open API docs这样的标准来记录你的API。尽管这确实可以产生很好的标准化文档，但是您的团队必须管理，并且文档可能会偏离您正在部署的实际API。</p><p id="c1e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我想提出一个很好的解决方案，允许您自动为您的API生成最新的swagger文档，文档与路线一致，这样就可以很容易地看到路线何时发生了变化，以及文档是否相应地发生了变化。像这样的解决方案也使得用API提供您的文档变得容易，使您部署的API的状态更容易以他们可能已经熟悉的标准格式与他人交流。</p><h1 id="597e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">生成Swagger文档</h1><p id="5764" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在，我假设您正在使用express js运行您的API，但是其他框架也有类似的解决方案。为了自动生成API文档，我们将使用swagger-autogen包来生成JSON格式的swagger文档。</p><div class="mc md gp gr me mf"><a href="https://www.npmjs.com/package/swagger-autogen" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">斯瓦格-自动发电机</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">这个模块执行Swagger文档的自动构造。该模块能够识别…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.npmjs.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jz mf"/></div></div></a></div><p id="60ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以通过这个链接阅读更多关于swagger doc标准的内容，微软这样的公司用它来交流他们众多API中的一些。</p><div class="mc md gp gr me mf"><a href="https://swagger.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">面向团队的API文档和设计工具| Swagger</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">使用我们的开源专业工具集，为用户、团队和企业简化API开发。了解如何…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">swagger.io</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt jz mf"/></div></div></a></div><p id="9ebb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，为express设置了一个简单的API服务器，其中包含一些基本路由。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="eb17" class="ne la it na b gy nf ng l nh ni">const express = require('express')<br/>import { handleErrorResponse } from "../../common/response"; // Generic handler for req, res<br/>const app = express()<br/>const port = 3000</span><span id="a61e" class="ne la it na b gy nj ng l nh ni">app.get("/calculate", async (req, res, next) =&gt; {<br/>  res.setHeader('Content-Type', 'application/json')<br/>  try {<br/>    return res.status(200).json({ createdAt: new Date().toISOString(), result: 100 });<br/>  } catch (err) {<br/>    return handleErrorResponse(res, err);<br/>  }<br/>});</span><span id="cd66" class="ne la it na b gy nj ng l nh ni">app.listen(port, () =&gt; {<br/>  console.log(`Example app listening at <a class="ae nk" href="http://localhost:${port}`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`</a>)<br/>})</span></pre><p id="7de1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望用这样一个大摇大摆的配置文件来配置我们要记录的应用程序。最好是定义您的应用程序名和您的API需要的任何重要的头，以便与使用该文档的人进行交流。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="33cf" class="ne la it na b gy nf ng l nh ni">const config = {<br/>  info: {<br/>    title: "Your cool API name",<br/>    description: "A description for your cool API",<br/>  },<br/>  host: `localhost:${process.env.API_PORT}`,<br/>  securityDefinitions: {<br/>    api_key: {<br/>      type: "apiKey",<br/>      name: "api-key",<br/>      in: "header",<br/>    },<br/>  },<br/>  schemes: ["http"],<br/>  definitions: {<br/>    "server side error": {<br/>      $status: "ERROR",<br/>      $msg: "some error message",<br/>      error: {<br/>        $message: "Error message caught",<br/>        $name: "Error name",<br/>        stack: "Error stack",<br/>      },<br/>    },<br/>    "calculation": {<br/>      $createdAt: "2020-03-31T00:00:00.000Z",<br/>      $result: 100,<br/>    },<br/>  },<br/>};</span></pre><p id="d5f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将在本文档中注意到，在定义的键下，这些可能看起来像一般的返回类型或对象。现在请记住这些，以便在本文稍后实现它们时使用。</p><p id="256f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过简单地在我们的服务器启动脚本中添加下面一行，我们可以在每次启动服务器时为我们的API生成新的swagger文档。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6c90" class="ne la it na b gy nf ng l nh ni">const swaggerAutogen = require("swagger-autogen")();</span><span id="f336" class="ne la it na b gy nj ng l nh ni">const outputFile = "./swagger-output.json";<br/>const endpointsFiles = ["./app.js"];<br/>const config = {}</span><span id="e194" class="ne la it na b gy nj ng l nh ni">swaggerAutogen()(outputFile, endpointsFiles, config).then(async () =&gt; {<br/>  await import('./index.js'); // Your express api project's root file where the server starts<br/>});</span></pre><p id="35ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你看这个<strong class="kd iu"> <em class="nl">。/swagger-output.json，</em> </strong>您会注意到，在这个简单的API实现示例中，路由将被自动选取。然而，随着您的设置变得越来越复杂，您肯定希望用您自己的信息和对它的修正来覆盖一些自动检测到的API文档。</p><h1 id="9fa7" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">记录API路线</h1><p id="a8d1" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">随着您的API在构建过程中变得越来越复杂，您可能会发现，在启动时，您的API的一些编程方面可能不会被自动检测到并填写在API文档中。此时，您将需要使用swagger docs inline comments语法来记录您的路由部分，例如元数据，如路由路径参数或接受的头的标记和描述。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cc07" class="ne la it na b gy nf ng l nh ni">const express = require('express')<br/>const handleErrorResponse = require("../../common/response"); // Generic handler for req, res<br/>const app = express()<br/>const port = 3000</span><span id="7fae" class="ne la it na b gy nj ng l nh ni">app.get("/calculate", async (req, res, next) =&gt; {<br/>  /*<br/>    #swagger.tags = ["calculations"]<br/>    #swagger.description = 'Fetch a calculation result'<br/>  */<br/> <br/> // Recognizes the 'consumes' automatically<br/>  res.setHeader('Content-Type', 'application/json')</span><span id="9266" class="ne la it na b gy nj ng l nh ni">try {<br/>    /* #swagger.responses[200] = {<br/>      description: "Category configs fetched successfully",<br/>      schema: { $ref: "#/definitions/calculation"<br/>    } */<br/>    return res.status(200).json({ createdAt: new Date().toISOString(), result: 100 });<br/>  } catch (err) {<br/>    /* #swagger.responses[500] = {<br/>      description: "Unknown server side error",<br/>      schema:  { $ref: "#/definitions/server side error" }<br/>    } */<br/>    return handleErrorResponse(res, err);<br/>  }<br/>});</span><span id="795c" class="ne la it na b gy nj ng l nh ni">app.listen(port, () =&gt; {<br/>  console.log(`Example app listening at <a class="ae nk" href="http://localhost:${port}`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`</a>)<br/>})</span></pre><p id="3a46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我工作的工程团队中。我发现让这种文档更接近实现会导致它有更高的机会保持最新，因为工程可能会回到代码库并更新实现，并且当它是内联的并且接近它所记录的实现时，也会看到有文档要更新。</p><h1 id="634b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">记录路线参数</h1><p id="4ee7" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Swagger autogen尽最大努力根据使用情况自动生成一些属性。在下面的例子中，swagger将根据您声明的路由路径和传入的参数来获取您的参数使用情况。如果您想要向routes参数描述符添加额外的细节，或者如果它们由于任何原因没有被自动选取，我还包括了行内注释阶段。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2d91" class="ne la it na b gy nf ng l nh ni">app.get('/users/:id', (req, res) =&gt; {<br/>        ...<br/>        //  #swagger.parameters['id'] = { description: 'User ID' }<br/>        ...<br/>    })</span><span id="101b" class="ne la it na b gy nj ng l nh ni">app.post('/books', (req, res) =&gt; {<br/>        ...<br/>        /*  #swagger.parameters['obj'] = {<br/>                in: 'body',<br/>                type: 'object',<br/>                description: 'Book data'<br/>        } */<br/>        users.addUser(req.body)<br/>        ...<br/>    })</span><span id="b712" class="ne la it na b gy nj ng l nh ni">app.post('/users', (req, res) =&gt; {<br/>        ...<br/>        /*  #swagger.parameters['obj'] = {<br/>                in: 'body',<br/>                description: 'Add a user',<br/>                schema: { $ref: '#/definitions/AddUser' }<br/>        } */<br/>        ...<br/>    })</span><span id="c0e1" class="ne la it na b gy nj ng l nh ni">app.get('/users', async (req, res) =&gt; {<br/>        /*  #swagger.parameters['item'] = {<br/>                in: 'query',<br/>                description: 'Any item...'<br/>        } */<br/>        let test = req.query.item<br/>    });</span></pre><h1 id="efee" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">引用和重用公共对象</h1><p id="6aff" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果您还记得，在您的swagger配置中，我们已经在定义的键下声明了一些公共对象。现在，这些对象将是您的通用返回类型响应和数据模型，它们将在您的API中使用。在下面的例子中，你可以看到如何使用<strong class="kd iu"><em class="nl">#/definitions/&lt;definition-key&gt;</em></strong>语法从配置文件中引用它们。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ecae" class="ne la it na b gy nf ng l nh ni">const express = require('express')<br/>const handleErrorResponse = require("../../common/response"); // Generic handler for req, res<br/>const app = express()<br/>const port = 3000</span><span id="d8a6" class="ne la it na b gy nj ng l nh ni">app.get("/calculate", async (req, res, next) =&gt; {<br/>  /*<br/>    #swagger.tags = ["calculations"]<br/>    #swagger.description = 'Fetch a calculation result'<br/>  */<br/> <br/> // Recognizes the 'consumes' automatically<br/>  res.setHeader('Content-Type', 'application/json')</span><span id="0902" class="ne la it na b gy nj ng l nh ni">try {<br/>    /* #swagger.responses[200] = {<br/>      description: "Calculation fetched successfully",<br/>      schema: { $ref: "#/definitions/calculation"<br/>    } */<br/>    return res.status(200).json({ createdAt: new Date().toISOString(), result: 100 });<br/>  } catch (err) {<br/>    /* #swagger.responses[500] = {<br/>      description: "Unknown server side error",<br/>      schema:  { $ref: "#/definitions/server side error" }<br/>    } */<br/>    return handleErrorResponse(res, err);<br/>  }<br/>});</span><span id="71f8" class="ne la it na b gy nj ng l nh ni">app.listen(port, () =&gt; {<br/>  console.log(`Example app listening at <a class="ae nk" href="http://localhost:${port}`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`</a>)<br/>})</span></pre><p id="84dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">老实说，通过重用这些公共对象，您节省了大量用于记录API的样板代码；你还需要花时间来定义一些公共模型，这些模型可以是你的API的输入或输出，这将有助于提高你的API的效率或简化API。</p><p id="a949" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我自己的上一个项目中，我发现我们几乎所有的数据返回都返回了稍微不同的键命名约定，并且很快被指向一个重构，如果所有的键名称在模型和端点中遵循相同的模式，那么可以完成这个重构，使API探索变得更加自然。</p><h1 id="6d00" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为您生成的招摇博士服务</h1><p id="3d37" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这样，您就可以从API实现旁边的内联swagger定义中自动生成整个API文档。你可能会问，我现在还能用我拥有的这个大摇大摆的文档做些什么。既然您已经在标准文档中清晰地定义了API定义，那么一件方便的事情就是您可以轻松地将它注入到其他工具中，以便更容易地探索API。</p><p id="5870" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果您想通过一个UI展示您的API及其所有路线，您可以使用swagger-UI-express包在熟悉的swagger UI中自动提供您生成的swagger文档。</p><div class="mc md gp gr me mf"><a href="https://www.npmjs.com/package/swagger-ui-express" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">斯瓦格-ui-express</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">这个模块允许你基于swagger.json从express提供自动生成的swagger-ui生成的API文档…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.npmjs.com</p></div></div><div class="mo l"><div class="nm l mq mr ms mo mt jz mf"/></div></div></a></div><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/8c6f959bd1074e32a5787cb67c8efb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htagLA6BJ-SehFJDHzsbrw.png"/></div></div></figure><p id="ccc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以很容易地设置一个途径，将您的API文档的这个UI提供给任何想要了解您的API的当前部署版本的能力的人。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6599" class="ne la it na b gy nf ng l nh ni">const router = require('express').Router();<br/>const swaggerUi = require('swagger-ui-express');<br/>const swaggerDocument = require('./swagger.json');</span><span id="69e6" class="ne la it na b gy nj ng l nh ni">router.use('/api-docs', swaggerUi.serve);<br/>router.get('/api-docs', swaggerUi.setup(swaggerDocument));</span></pre><p id="18d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了正式的文档和UI，任何人都没有理由不知道API中有什么，以及如何在最好的情况下与它通信，这样就可以省去一些关于所支持的API的常见问题。</p><h1 id="f59b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">最后的想法</h1><p id="c494" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">将您的文档放在您的API实现代码旁边使得更新和保存您的文档变得更加容易，这在几乎所有的开发环境中都是有用的。</p><p id="b3ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过利用swagger标准，您有机会轻松地交流您的API当前规范，进行API客户端的配置。正如我们在上面的swagger UI中看到的，如果您的工具支持swagger文件输入，那么您已经准备好使用您生成的swagger文档了。</p><p id="d80b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想看看完整的swagger docs示例是什么样的，您可以看看下面的公共API示例，它向您展示了共享这些文档对于快速交流您的项目以及每个开发人员可能需要的详细程度是多么强大。</p><div class="mc md gp gr me mf"><a href="https://petstore.swagger.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">Swagger UI</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">编辑描述</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">petstore.swagger.io</p></div></div></div></a></div><h1 id="dfd8" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">进一步连接</h1><ul class=""><li id="8668" class="no np it kd b ke lx ki ly km nq kq nr ku ns ky nt nu nv nw bi translated">如果你正在考虑购买一份中等订阅，你可以通过我的推荐链接来帮我。</li><li id="58d6" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">查看我在<a class="ae nk" href="https://medium.com/@aaron-kt-berry" rel="noopener">媒体</a>上的其他文章，如果你想了解最新消息，请通过<a class="ae nk" href="https://aaron-kt-berry.medium.com/subscribe" rel="noopener">电子邮件</a>订阅。</li><li id="4395" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">如果你想聊天，请在Twitter或LinkedIn上联系我，如果你想雇佣我，我在Codementor上。</li></ul></div></div>    
</body>
</html>