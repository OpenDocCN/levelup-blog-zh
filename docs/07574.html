<html>
<head>
<title>Creating a development environment with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker创建开发环境</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-development-environment-with-docker-15f054832f9a?source=collection_archive---------8-----------------------#2021-02-24">https://levelup.gitconnected.com/creating-a-development-environment-with-docker-15f054832f9a?source=collection_archive---------8-----------------------#2021-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/9837112fc33f1d39060e3ff37e66f212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pfz0GRSL1ozwiCxl46DO6A.jpeg"/></div></figure><p id="6a30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了创建这个开发环境，我将使用docker-compose，以便用一个命令管理整个环境。这种环境可以在本地或远程运行，因为只需要一个shell连接。</p><p id="1fe3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将创建一个docker-compose.yaml文件来定义应用程序的所有系统依赖项。根据系统架构，这个文件可以用于在生产中部署，但是如果我们在生产中使用Kubernetes或Aws ECS，通常这是不可能的。</p><p id="54f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个例子中，将使用一个简单的Symfony应用程序，它使用MySql和Elasticseach。</p><p id="7b34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04" rel="noopener ugc nofollow" target="_blank">在Ubuntu中安装docker</a></p><h1 id="fd61" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用docker-compose</h1><p id="951d" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">很有可能一个项目需要一些外部依赖，如Mysql、MariaDB、Redis、Memcached或Elasticsearch。所有这些依赖关系应该在开发期间(可能在CI/CD期间)以简单的方式可用。</p><p id="280c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Docker-compose us是一个Docker工具，允许用一个命令来构建、运行和停止几个容器。所需的配置在一个文件中，其中定义了要使用的映像、暴露的端口、环境变量…</p><p id="a923" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c0aa" class="mf ku iq mb b gy mg mh l mi mj">#docker-compose -f docker/dev/docker-compose.yml up<br/>version: '3'<br/>services:<br/>  blog:<br/>    build: .<br/>    ports:<br/>        - 81:80<br/>    volumes:<br/>        - ../../:/var/www<br/>        - ../uploads:/media/uploads<br/>    command: /usr/sbin/apache2ctl -D FOREGROUND<br/>    environment:<br/>      - "DATABASE_PASSWORD=12345"<br/>      - “DATABASE_USER=mysql_user"<br/>      - "DATABASE_HOST=mysql"<br/>      - "DATABASE_DB_NAME=site"<br/>  mysql:<br/>      image: mysql<br/>      ports:<br/>          - 6603:3306<br/>      environment:<br/>        MYSQL_ROOT_PASSWORD: "12345"<br/>      volumes:<br/>          - ../data:/var/lib/mysql</span></pre><p id="cb96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个文件中，有两个服务被定义为“博客”和“mysql”。Docker-compose将在每个正在运行的容器中的/etc/hosts中添加所需的行，以便它们可以在用作主机的服务名下互相查看。这意味着从blog容器ping mysql run将向mysql容器发送一个ping。这意味着当在生产环境中运行博客时，我们可以定义一个额外的名为mysql的主机，指向生产mysql服务器，而无需更改代码。</p><p id="db74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在博客服务中，Docker将使用位于同一目录中的Docker文件构建图像。</p><p id="363f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">端口80也将暴露给映射到主机端口81的“外部世界”。</p><h1 id="a631" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">文件持久性、Docker卷</h1><p id="6d32" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">源代码和上传将存储在两个卷中，这两个卷是安装在容器内的主机目录。这意味着在主机上更改的文件将同时在容器中更新。</p><p id="78de" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当容器被销毁时，在容器文件中所做的更改将会丢失(一般来说，这是因为有一个命令可以使用在运行的容器中所做的更改来创建新的映像)。例如，在上传目录的情况下，如果它没有映射到外部卷，如果我们停止容器，所有更改都将丢失。</p><p id="77b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">MySql也是如此。如果数据目录未映射到卷，则如果容器映像被更新或被删除，所有数据都将丢失。</p><h1 id="5220" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在Docker中运行命令</h1><p id="85d9" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">当运行命令结束时，Docker容器“死亡”。Docker设计为每个容器运行一个命令。当这个命令完成时，容器被停止。</p><p id="8314" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在博客服务的例子中，命令块定义了将在容器中运行的命令，启动Apache服务器，并使其在前台监听端口80的请求。因此，如果Apache停止，容器也会停止。</p><h1 id="bf1c" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">定义环境</h1><p id="376b" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在这个块中，变量可以以一种不需要改变代码的方式来定义，以便将应用程序移植到另一个服务器或环境。例如，数据库连接参数是在代码之外定义的，所以如果blog容器映像将被部署在不同的服务器上，更改环境变量就足够了。</p><h1 id="3f44" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">数据库</h1><p id="031f" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">如前所述，当容器映像更新或容器死亡时，容器中的更改会丢失。如果数据库正在该容器上运行，则数据目录必须映射到卷，否则所有数据都会丢失。</p><p id="360a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用Docker还是不用Docker来运行数据库是很有主见的。根据项目类型，它可能是一个问题，也可能不是。</p><p id="c89a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于开发环境来说，这非常实用，因为我们可以运行任何运行在linux上的数据库，并在Windos、MacOs、Linux上开发我们的应用程序……只需很少的更改。</p><p id="8d37" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在生产环境中也是可能的，但取决于使用情形。Docker“迫使”我们制作无状态的应用，这些应用运行在随时可能死亡和旋转的容器中。这使得我们的应用程序很容易扩展，但是在数据库的情况下就不那么容易扩展或缩小了。</p><p id="0773" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我的生产环境中，我更喜欢使用更传统的数据库方法，并在外部机器上设置它。</p><h1 id="4343" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">运行开发环境</h1><p id="145a" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">一旦docker-compose.yaml文件准备好了，就该测试它了。</p><p id="4ebb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">运转</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ae1e" class="mf ku iq mb b gy mg mh l mi mj">docker-compose up</span></pre><p id="ffde" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在文件所在的同一个目录中，或者在另一个路径中</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8a70" class="mf ku iq mb b gy mg mh l mi mj">docker-compose -f /path/to/docker-compose.yml up</span></pre><p id="7e89" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">码头将被docker进程“锁定”,并将显示所有集装箱的日志。要在不锁定终端的情况下运行环境，需要在命令末尾添加-d选项。在这种情况下，要检查日志，我们需要运行以下命令:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5875" class="mf ku iq mb b gy mg mh l mi mj">docker-compose -f /path/to/docker-compose.yml</span></pre><p id="23e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">或者</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3bbe" class="mf ku iq mb b gy mg mh l mi mj">docker-compose -f /path/to/docker-compose.yml -f</span></pre><p id="938b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">跟踪日志并查看实时更新。</p><p id="7760" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为我们可以选择到docker-compose文件的路径，所以我们可以准备好不同的环境并启动我们需要的东西。</p><p id="e336" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要停止环境，我们可以停止它或停止并删除它</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e4d9" class="mf ku iq mb b gy mg mh l mi mj">docker-compose -f /path/to/docker-compose.yml stop<br/>docker-compose -f /path/to/docker-compose.yml down</span></pre><p id="f4b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要查看正在运行的命令:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="47b7" class="mf ku iq mb b gy mg mh l mi mj">docker ps</span></pre><p id="36dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">得到这样一个列表:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a1b6" class="mf ku iq mb b gy mg mh l mi mj">69b34ec43ed1 mysql “docker-entrypoint.s…" 2 seconds ago Up 3 seconds 0.0.0.0:6603-&gt;3306/tcp mysql-container<br/>ee022eb58b03 dev_blog “/usr/sbin/apache2ct…" 2 seconds ago Up 2 seconds 0.0.0.0:81-&gt;80/tcp blog_app</span></pre><p id="3793" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要在容器中运行终端来执行某些任务，或者调试它，我们可以运行:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3259" class="mf ku iq mb b gy mg mh l mi mj">docker exec -ti ee022eb58b03 bash</span></pre><p id="a51c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">控制台提示将改变，命令将在容器内运行。要返回主机终端，我们可以键入“exit”并按enter键。</p><p id="f49e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要访问该应用程序，我们可以在浏览器中打开<a class="ae ks" href="http://localhost:81/" rel="noopener ugc nofollow" target="_blank"> http://localhost:81 </a>。</p><p id="9a6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了访问数据库，我们可以连接到localhost，但是使用端口6603(在docker-compose文件中映射的端口)和定义的凭证。</p><h1 id="ca78" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Dockerfile，我们的应用程序依赖于操作系统级别</h1><p id="1766" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Docker文件告诉Docker如何构建一个映像，该映像稍后将用于运行运行我们的应用程序的容器。</p><p id="1ff2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要获得更多关于Dockerfile语法的信息，请点击这里。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c051" class="mf ku iq mb b gy mg mh l mi mj">FROM ubuntu:xenialENV DEBIAN_FRONTEND noninteractive<br/># php7.1 Repo<br/>RUN apt-get update -y &amp;&amp; apt-get install -y software-properties-common python3-software-properties &amp;&amp; \<br/>    LC_ALL=C.UTF-8 add-apt-repository -y ppa:ondrej/php &amp;&amp; \<br/>    apt-get update -y</span><span id="bc4c" class="mf ku iq mb b gy mk mh l mi mj">#Timezone at container level.<br/>ENV TZ=Europe/Madrid<br/>RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><span id="2f96" class="mf ku iq mb b gy mk mh l mi mj"># System update and packets update<br/>RUN apt-get install -y \<br/>    git \<br/>    imagemagick \<br/>    apache2 \<br/>    jpegoptim \<br/>    php7.1 \<br/>    acl \<br/>    libapache2-mod-php7.1 \<br/>    php7.1-curl \<br/>    php7.1-xml \<br/>    php7.1-mbstring \<br/>    nodejs \<br/>    unzip \<br/>    npm \<br/>    php7.1-gd \<br/>    php7.1-intl \<br/>    php7.1-xsl \<br/>    php7.1-mysql</span><span id="4c8c" class="mf ku iq mb b gy mk mh l mi mj"># Apache and php config file<br/>COPY apache/site.conf /etc/apache2/sites-available/site.conf<br/>COPY php/php.ini /etc/php/7.1/apache2/php.ini</span><span id="b76a" class="mf ku iq mb b gy mk mh l mi mj"># Enable apache site config file and disable default one<br/>RUN a2ensite site.conf &amp;&amp; \<br/>    a2dissite 000-default.conf</span><span id="1dfe" class="mf ku iq mb b gy mk mh l mi mj"># Enable apache needed modules<br/>RUN a2enmod php7.1 &amp;&amp; \<br/>    a2enmod rewrite &amp;&amp; \<br/>    a2enmod actions &amp;&amp; \<br/>    a2enmod deflate &amp;&amp; \<br/>    a2enmod expires &amp;&amp; \<br/>    a2enmod headers &amp;&amp; \<br/>    a2enmod actions &amp;&amp; \<br/>    a2enmod proxy</span><span id="1c5f" class="mf ku iq mb b gy mk mh l mi mj"># Install npm needed packages <br/>RUN npm install -g less &amp;&amp; \<br/>    npm install uglify-js -g &amp;&amp; \<br/>    npm install uglifycss -g</span><span id="367e" class="mf ku iq mb b gy mk mh l mi mj"># Creating symfony directorie<br/>RUN mkdir -p /var/www/app/cache &amp;&amp; \<br/>    mkdir -p /var/www/app/logs &amp;&amp; \<br/>    mkdir -p /media/tmp &amp;&amp; \<br/>    mkdir -p /media/uploads</span><span id="8df4" class="mf ku iq mb b gy mk mh l mi mj"># Symlink to nodejs for symfony<br/>RUN ln -s /usr/bin/nodejs /usr/bin/node</span><span id="efc3" class="mf ku iq mb b gy mk mh l mi mj"># Directory permisions <br/>RUN chmod -R 777 /media/tmp &amp;&amp; \<br/>    chmod -R 777 /media/uploads<br/>RUN chown -R www-data:www-data /media/tmp &amp;&amp; \<br/>    chown -R www-data:www-data /media/uploads</span></pre><p id="4201" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个Dockerfile用Apache和Php 7.1构建了一个基于Ubuntu的映像，还有一些由app使用的模块，Nodejs和assetic用来管理css和js的另外两个模块。</p><p id="7eff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在构建过程中，Apache和Php配置文件被复制到映像中。体积也可以用于测试不同的值。在这种情况下，一旦改变，容器必须重新启动，但我们节省了构建映像的时间。</p><h1 id="ee95" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="ffc1" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">使用Docker和Docker-compose创建可以移植到其他开发者并且不耦合到底层操作系统的环境是很容易的。</p><p id="94d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">维护Dockerfile文件的不同版本(如果有的话),我们确保应用程序可以在任何环境下正常运行，而无需处理每个环境的依赖性。</p><p id="cacf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是<a class="ae ks" href="https://carlos-compains.medium.com/creando-un-entorno-de-desarrollo-con-docker-a56790af6271" rel="noopener">本帖</a>的英文版。</p></div></div>    
</body>
</html>