<html>
<head>
<title>Tracking Service with Go and Redis V2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Go和Redis V2的跟踪服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tracking-service-with-go-and-redis-v2-8701026e0e23?source=collection_archive---------0-----------------------#2018-10-04">https://levelup.gitconnected.com/tracking-service-with-go-and-redis-v2-8701026e0e23?source=collection_archive---------0-----------------------#2018-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a951434e8ab49d639e9850a547a74a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z0ybOWboDFodgTIk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@slelham?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">史蒂文·勒勒姆</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="f631" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你还记得我的上一篇文章吗？在那篇文章中，我写了一个服务来寻找像优步这样的司机。如果没有，你可以在这里检查<a class="ae kc" href="https://medium.com/douglasmakey/tracking-service-with-go-and-redis-efa9f3c1d130" rel="noopener"/>所以现在，我们要写我们服务的V2。</p><p id="a64f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击查看我们服务<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/tracking-service-with-go-and-redis-efa9f3c1d130">的简单版本1。</a></p><p id="498d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们服务的当前状态是，当用户使用资源“search”时，用户会收到一个响应，其中包含离他最近的驱动程序。但是如果用户身边没有司机会怎么样呢？</p><p id="5f33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望服务客户机向同一个端点发出大量请求来寻找驱动程序。我们想要做的是遵循优步使用的模式，那就是我们的客户端只发出一个请求，这个请求引发了一个任务，这个任务为我们寻找驱动程序X次，然后，用户收到结果。</p><p id="ab06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们将使用Go提供的一些工具:Goroutines、Channels和<code class="fe lb lc ld le b">time.Ticker</code> struct。</p><p id="623d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:这将是一个基本的实现。</strong></p><h1 id="2cbf" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">戈罗廷</h1><p id="f37f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">一个goroutine是轻量级的，只需要分配一点堆栈空间。栈开始很小，所以它们很便宜，并且根据需要通过分配(和释放)堆存储来增长。</p><p id="8418" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将一个函数作为goroutine运行，只需在func调用之前放上关键字<code class="fe lb lc ld le b">go</code>。当func完成时，goroutine会安静地退出。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="06e5" class="mq lg iq le b gy mr ms l mt mu">go list.Sort()  // run list.Sort concurrently; don't wait for it.</span></pre><p id="d179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:Goroutines在同一个地址空间中运行，所以对共享内存的访问必须同步。sync包提供了有用的原语，尽管在Go中你不太需要它们，因为还有其他原语。</p><p id="397a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://golang.org/doc/effective_go.html?#goroutines" rel="noopener ugc nofollow" target="_blank">有效Go — Goroutines </a></p><h1 id="1e36" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">频道</h1><p id="b7eb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">通道是一种类型化的管道，通过它您可以使用通道操作符<code class="fe lb lc ld le b">&lt;-</code>发送和接收值。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="978c" class="mq lg iq le b gy mr ms l mt mu">ch &lt;- v    // Send v to channel ch.<br/>v := &lt;-ch  // Receive from ch, and<br/>           // assign value to v.</span></pre><p id="3477" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(数据按箭头方向流动。)</p><p id="b1a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像地图一样，通道是用<code class="fe lb lc ld le b">make</code>分配的，结果值作为对底层数据结构的引用。如果提供了可选的整数参数，它将设置通道的缓冲区大小。对于无缓冲或同步通道，默认值为零。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="36b8" class="mq lg iq le b gy mr ms l mt mu">ci := make(chan int)            // unbuffered channel of integers<br/>cj := make(chan int, 0)         // unbuffered channel of integers<br/>cs := make(chan *os.File, 100)  // buffered channel of pointers to Files</span></pre><p id="b730" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无缓冲通道将通信(值的交换)与同步结合在一起，保证两个计算(goroutines)处于已知状态。</p><p id="5021" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多使用频道的好习惯用法。这里有一个让我们开始。在上一节中，我们在后台启动了一个排序。通道可以允许正在启动的goroutine等待排序完成。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4413" class="mq lg iq le b gy mr ms l mt mu">c := make(chan int)  // Allocate a channel.<br/>// Start the sort in a goroutine; when it completes, signal on the channel.<br/>go func() {<br/>    list.Sort()<br/>    c &lt;- 1  // Send a signal; value does not matter.<br/>}()<br/>doSomethingForAWhile()<br/>&lt;-c   // Wait for sort to finish; discard sent value.</span></pre><p id="0e02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接收器总是阻塞，直到有数据要接收。如果通道无缓冲，发送方会阻塞，直到接收方收到该值。如果通道有缓冲区，则发送方仅在值被复制到缓冲区之前阻塞；如果缓冲区已满，这意味着要等到某个接收器检索到一个值。</p><p id="d793" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://golang.org/doc/effective_go.html?#channels" rel="noopener ugc nofollow" target="_blank">有效Go通道</a></p><h1 id="5cad" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">时间。心脏</h1><p id="9fa2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">计时器是当你想在未来做某件事的时候用的——ticker是当你想定期重复做某件事的时候用的。这是一个定期滴答直到我们停止它的例子。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="739f" class="mq lg iq le b gy mr ms l mt mu">package main</span><span id="af74" class="mq lg iq le b gy mv ms l mt mu">import "time"<br/>import "fmt"</span><span id="8a0d" class="mq lg iq le b gy mv ms l mt mu">func main() {</span><span id="55db" class="mq lg iq le b gy mv ms l mt mu">    // Tickers use a similar mechanism to timers: a<br/>    // channel that is sent values. Here we'll use the<br/>    // `range` builtin on the channel to iterate over<br/>    // the values as they arrive every 500ms.<br/>    ticker := time.NewTicker(500 * time.Millisecond)<br/>    go func() {<br/>        for t := range ticker.C {<br/>            fmt.Println("Tick at", t)<br/>        }<br/>    }()</span><span id="b157" class="mq lg iq le b gy mv ms l mt mu">    // Tickers can be stopped like timers. Once a ticker<br/>    // is stopped it won't receive any more values on its<br/>    // channel. We'll stop ours after 1600ms.<br/>    time.Sleep(1600 * time.Millisecond)<br/>    ticker.Stop()<br/>    fmt.Println("Ticker stopped")<br/>}</span></pre><h1 id="6da9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">让我们开始编码吧</h1><p id="74aa" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">首先，我们将创建一个名为tasks的新文件夹，在其中创建一个“request.go ”,其中包含执行搜索的代码。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1bca" class="mq lg iq le b gy mr ms l mt mu">// FILE: tasks/search.go</span><span id="ac0f" class="mq lg iq le b gy mv ms l mt mu">// These are the reasons which a request is invalid.<br/>var (<br/>    ErrExpired  = errors.New("request expired")<br/>    ErrCanceled = errors.New("request canceled")<br/>)</span><span id="5f1a" class="mq lg iq le b gy mv ms l mt mu">// RequestDriverTask is a simple struct that contains info about the user, request and driver, you can add more information if you want.<br/>type RequestDriverTask struct {<br/>    ID       string<br/>    UserID   string<br/>    Lat, Lng float64<br/>    DriverID string<br/>}</span><span id="da80" class="mq lg iq le b gy mv ms l mt mu">// NewRequestDriverTask create and return a pointer to RequestDriverTask<br/>func NewRequestDriverTask(id, userID string, lat, lng float64) *RequestDriverTask {<br/>    return &amp;RequestDriverTask{<br/>        ID:     id,<br/>        UserID: userID,<br/>        Lat:lat,<br/>        Lng:lng,<br/>    }<br/>}</span></pre><p id="6e13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们实现了<strong class="kf ir"> Run </strong>方法，这个func将从处理程序中启动。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f396" class="mq lg iq le b gy mr ms l mt mu">// FILE: tasks/search.go<br/><br/>// Run is the function for executing the task, this task validating the request and launches another goroutine called 'doSearch' which does the search.<br/>func (r *RequestDriverTask) Run() {<br/>    // We create a new ticker with 30s time duration, this it means that each 30s the task executes the search for a driver.<br/>    ticker := time.NewTicker(time.Second * 30)<br/><br/>    // With the done channel, we receive if the driver was found<br/>    done := make(chan struct{})<br/><br/>    for {<br/>        // The select statement lets a goroutine wait on multiple communication operations.<br/>        select {<br/>        case &lt;-ticker.C:<br/>            err := r.validateRequest()<br/>            switch err {<br/>            case nil:<br/>                log.Println(fmt.Sprintf("Search Driver - Request %s for Lat: %f and Lng: %f", r.ID, r.Lat, r.Lng))<br/>                go r.doSearch(done)<br/>            case ErrExpired:<br/>                // Notify to user that the request expired.<br/>                sendInfo(r, "Sorry, we did not find any driver.")<br/>                return<br/>            case ErrCanceled:<br/>                log.Printf("Request %s has been canceled. ", r.ID)<br/>                return<br/>            default: // defensive programming: expected the unexpected<br/>                log.Printf("unexpected error: %v", err)<br/>                return<br/>            }<br/><br/>        case _, ok := &lt;-done:<br/>            if !ok {<br/>                sendInfo(r, fmt.Sprintf("Driver %s found", r.DriverID))<br/>                ticker.Stop()<br/>                return<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="a58e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在我们要为<code class="fe lb lc ld le b">RequestDriverTask</code>创建两个方法。</p><p id="dc9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个方法是<code class="fe lb lc ld le b">validateRequest</code>，这个函数验证密钥，如果密钥是活动的，或者如果密钥过期，如果请求无效，将返回一个错误，比如一个原因。</p><p id="660d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二种方法是<code class="fe lb lc ld le b">doSearch</code>，这个函数使用我们的RedisClient及其函数<code class="fe lb lc ld le b">SearchDrivers</code>进行搜索。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3dbb" class="mq lg iq le b gy mr ms l mt mu">// FILE: tasks/search.go</span><span id="78e4" class="mq lg iq le b gy mv ms l mt mu">// validateRequest validates if the request is valid and return an error like a reason in case not.<br/>func (r *RequestDriverTask) validateRequest() error {<br/>    rClient := storages.GetRedisClient()<br/>    keyValue, err := rClient.Get(r.ID).Result()<br/>    if err != nil {<br/>        // Request has been expired.<br/>        return ErrExpired<br/>    }</span><span id="90f6" class="mq lg iq le b gy mv ms l mt mu">    isActive, _ := strconv.ParseBool(keyValue)<br/>    if !isActive {<br/>        // Request has been canceled.<br/>        return ErrCanceled<br/>    }</span><span id="99f9" class="mq lg iq le b gy mv ms l mt mu">    return nil<br/>}</span><span id="065d" class="mq lg iq le b gy mv ms l mt mu">// doSearch do search of driver and close to the channel.<br/>func (r *RequestDriverTask) doSearch(done chan <!-- -->struct{}<!-- -->) {<br/>    rClient := storages.GetRedisClient()<br/>    drivers := rClient.SearchDrivers(1, r.Lat, r.Lng, 5)<br/>    if len(drivers) == 1 {<br/>        // Driver found<br/>        // Remove driver location, we can send a message to the driver for that it does not send again its location to this service.<br/>        rClient.RemoveDriverLocation(drivers[0].Name)<br/>        r.DriverID = drivers[0].Name<br/>        close(done)<br/>    }</span><span id="8ba7" class="mq lg iq le b gy mv ms l mt mu">    return<br/>}</span></pre><p id="02eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe lb lc ld le b">sendInfo</code>只是一个例子，如果你愿意，你可以实现另一个服务或推送通知或WebSocket，我想写另一篇文章，我用FCM实现了一个例子，我写了一个小库<a class="ae kc" href="https://github.com/douglasmakey/go-fcm" rel="noopener ugc nofollow" target="_blank"> go-fcm </a>来通知用户。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9396" class="mq lg iq le b gy mr ms l mt mu">// sendInfo this func is only example, you can use another services, websocket or push notification for send data to user.<br/>func sendInfo(r *RequestDriverTask, message string) {<br/>    log.Println("Message to user:", r.UserID)<br/>    log.Println(message)<br/>}</span></pre><p id="8ccb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们已经有了搜索任务的函数。现在我们需要为我们的服务创建新的端点。我们将在handler中创建一个名为<code class="fe lb lc ld le b">v2</code>的新文件夹，并在其中创建<code class="fe lb lc ld le b">search.go</code>。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2098" class="mq lg iq le b gy mr ms l mt mu">// FILE: handler/v2/search.go</span><span id="c504" class="mq lg iq le b gy mv ms l mt mu">func SearchV2(w http.ResponseWriter, r *http.Request) {<br/>    rClient := storages.GetRedisClient()</span><span id="d391" class="mq lg iq le b gy mv ms l mt mu">    // We use Redis to keep a key unique for each request.<br/>    // With this key also we will know if the request is active or if the user canceled the request.<br/>    requestID, err := rClient.Incr("request_id").Result()<br/>    if err != nil {<br/>        return<br/>    }<br/>    key := strconv.Itoa(int(requestID))</span><span id="5003" class="mq lg iq le b gy mv ms l mt mu">    // Set true value for the key and also the expiration time, this expiration time is the duration that has the request to find a driver.<br/>    rClient.Set(key, true, time.Minute*4)<br/>    body := struct {<br/>        Lat, Lng float64<br/>    }{}</span><span id="4f7f" class="mq lg iq le b gy mv ms l mt mu">    if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil {<br/>        log.Printf("could not decode request: %v", err)<br/>        http.Error(w, "could not decode request", http.StatusInternalServerError)<br/>        return<br/>    }</span><span id="56e3" class="mq lg iq le b gy mv ms l mt mu">    // We create a new task and launch with a goroutine.<br/>    rTask := tasks.NewRequestDriverTask(key, fmt.Sprintf("requestor_%s", key), body.Lat, body.Lng)<br/>    go rTask.Run()</span><span id="3261" class="mq lg iq le b gy mv ms l mt mu">    // Return 200 and request_id<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Write([]byte(fmt.Sprintf(`{"request_id": %s}`, key)))</span><span id="4305" class="mq lg iq le b gy mv ms l mt mu">}</span></pre><p id="2513" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们为端点<code class="fe lb lc ld le b">v2/cancel</code>创建处理程序来取消请求，因为如果用户不想等待搜索，它可以取消请求。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="901d" class="mq lg iq le b gy mr ms l mt mu">// FILE: handler/v2/search.go</span><span id="476c" class="mq lg iq le b gy mv ms l mt mu">func CancelRequest(w http.ResponseWriter, r *http.Request) {<br/>    rClient := storages.GetRedisClient()</span><span id="f94d" class="mq lg iq le b gy mv ms l mt mu">    body := struct {<br/>        RequestID string `json:"request_id"`<br/>    }{}</span><span id="1aee" class="mq lg iq le b gy mv ms l mt mu">    if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil {<br/>        log.Printf("could not decode request: %v", err)<br/>        http.Error(w, "could not decode request", http.StatusInternalServerError)<br/>        return<br/>    }</span><span id="a7ea" class="mq lg iq le b gy mv ms l mt mu">    rClient.Set(body.RequestID, false, time.Minute*1)<br/>    w.WriteHeader(http.StatusOK)<br/>    return</span><span id="646b" class="mq lg iq le b gy mv ms l mt mu">}</span></pre><p id="7238" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要在路由中添加新的端点。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7a9b" class="mq lg iq le b gy mr ms l mt mu">// FILE: handler/base.go</span><span id="484a" class="mq lg iq le b gy mv ms l mt mu">import (<br/>    "net/http"<br/>    "github.com/douglasmakey/tracking/handler/v2"<br/>)</span><span id="19c8" class="mq lg iq le b gy mv ms l mt mu">func NewHandler() *http.ServeMux {<br/>    mux := http.NewServeMux()<br/>    mux.HandleFunc("/tracking", tracking)<br/>    mux.HandleFunc("/search", search)</span><span id="3a4c" class="mq lg iq le b gy mv ms l mt mu">    //V2<br/>    mux.HandleFunc("/v2/search", v2.SearchV2)<br/>    mux.HandleFunc("/v2/cancel", v2.CancelRequest)<br/>    return mux<br/>}</span></pre><h1 id="de63" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">例子</h1><p id="d9c4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">查找最近的驱动程序</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fc1a" class="mq lg iq le b gy mr ms l mt mu">curl -i --header "Content-Type: application/json" --data '{"lat": -33.44262, "lng": -70.63054}' http://localhost:8000/v2/search<br/></span><span id="3179" class="mq lg iq le b gy mv ms l mt mu">HTTP/1.1 200 OK<br/>Date: Sat, 29 Sep 2018 15:33:48 GMT<br/>Content-Length: 17<br/>Content-Type: application/json</span><span id="6709" class="mq lg iq le b gy mv ms l mt mu">{"request_id": 1}</span></pre><p id="fa03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果驱动程序没有接近客户端位置，并且超过了4分钟或我们设置的持续时间，请求将会过期，而不会找到任何驱动程序。</p><p id="2490" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务器日志</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e828" class="mq lg iq le b gy mr ms l mt mu">2018/09/30 01:57:53 Starting HTTP Server. Listening at ":8000"<br/>Search Driver - Request 1 for Lat: -33.442620 and Lng: -70.630540<br/>Search Driver - Request 1 for Lat: -33.442620 and Lng: -70.630540<br/>Search Driver - Request 1 for Lat: -33.442620 and Lng: -70.630540<br/>Search Driver - Request 1 for Lat: -33.442620 and Lng: -70.630540<br/>Search Driver - Request 1 for Lat: -33.442620 and Lng: -70.630540<br/>Search Driver - Request 1 for Lat: -33.442620 and Lng: -70.630540<br/>Search Driver - Request 1 for Lat: -33.442620 and Lng: -70.630540<br/>Search Driver - Request 1 for Lat: -33.442620 and Lng: -70.630540<br/>Message to user:  requestor_1<br/>Sorry, we did not find any driver.</span></pre><p id="b55d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将向<code class="fe lb lc ld le b">v2/search</code>发出另一个请求，但是在另一个终端1分钟后，我们将驱动程序位置发送给服务。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7cb8" class="mq lg iq le b gy mr ms l mt mu">// Another Terminal<br/>curl -i --header "Content-Type: application/json" --data '{"id": "1", "lat": -33.44091, "lng": -70.6301}' <a class="ae kc" href="http://localhost:8000/tracking" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/tracking</a></span><span id="13b8" class="mq lg iq le b gy mv ms l mt mu">// Terminal with main<br/>2018/09/30 02:12:03 Starting HTTP Server. Listening at ":8000"<br/>2018/09/30 02:12:38 Search Driver - Request 2 for Lat: -33.442620 and Lng: -70.630540<br/>2018/09/30 02:13:08 Search Driver - Request 2 for Lat: -33.442620 and Lng: -70.630540<br/>2018/09/30 02:13:38 Search Driver - Request 2 for Lat: -33.442620 and Lng: -70.630540<br/>2018/09/30 02:13:38 Message to user: requestor_2<br/>2018/09/30 02:13:38 Driver 1 found</span></pre><p id="2de0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，现在我们将向<code class="fe lb lc ld le b">v2/search</code>发出另一个请求，但这次我们将向<code class="fe lb lc ld le b">v2/cancel</code>发出取消订单的请求，因为我们等不及了。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="27dc" class="mq lg iq le b gy mr ms l mt mu">// Another Terminal<br/>curl -i --header "Content-Type: application/json" --data '{"request_id": "3"}' <a class="ae kc" href="http://localhost:8000/v2/cancel" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/v2/cancel</a></span><span id="857c" class="mq lg iq le b gy mv ms l mt mu">// Terminal with main<br/>2018/09/30 02:19:24 Starting HTTP Server. Listening at ":8000"<br/>2018/09/30 02:19:56 Search Driver - Request 3 for Lat: -33.442620 and Lng: -70.630540<br/>2018/09/30 02:19:56 Request 3 has been canceled.</span></pre></div></div>    
</body>
</html>