<html>
<head>
<title>Handling websocket and http on the same port with Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rust处理同一个端口上的websocket和http</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-websocket-and-http-on-the-same-port-with-rust-f65b770722c9?source=collection_archive---------4-----------------------#2021-02-03">https://levelup.gitconnected.com/handling-websocket-and-http-on-the-same-port-with-rust-f65b770722c9?source=collection_archive---------4-----------------------#2021-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/86627b5c18ee897dd16e73728ed7df50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3zbaSxM3COvB-9oaSkwwA.jpeg"/></div></div></figure><h2 id="151f" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">介绍</h2><p id="4608" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我将通过我所能找到的最简单、最灵活的方法来为异步服务器创建脚手架，该服务器能够在Rust中监听一个端口的同时服务于websocket连接和http请求。这个例子将使用未加密的websocket连接。您可以在https://github.com/tsidea/http-ws-server-rs找到与本文相关的完整运行示例。</p><p id="8ebd" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">在我们开始之前，我们需要了解一些关于websockets的细节，特别是它们是如何创建的。它们最初只是一个简单的http请求。当您在Javascript中构造一个<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" rel="noopener ugc nofollow" target="_blank"> Websocket </a>对象时，它首先向提供的url发送一个http请求，并要求服务器使用<a class="ae lp" href="https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header" rel="noopener ugc nofollow" target="_blank">升级头</a>将连接升级到Websocket。如果请求包含所有必要的头，服务器通过发回包含其他特定头的响应来表示同意。这叫做<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#the_websocket_handshake" rel="noopener ugc nofollow" target="_blank"> websocket握手</a>。握手之后，http连接保持打开，服务器和客户端都可以对其进行读写。websocket协议还指定了客户端和服务器都需要应用的某些消息帧，以便进行通信。这意味着该连接不仅仅是一个原始的TCP连接，它在TCP之上使用了一些帧。即便如此，从websockets读写的开销也是最小的，因此它<a class="ae lp" href="https://blog.feathersjs.com/http-vs-websockets-a-performance-comparison-da2533f13a77" rel="noopener ugc nofollow" target="_blank">为我们提供了一个非常高性能的通信层，而不是http </a>。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="270a" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">初始设置</h2><p id="807a" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">为了测试我们的服务器设置，我们需要用<code class="fe mc md me mf b">curl</code>来测试http部分，用<code class="fe mc md me mf b"><a class="ae lp" href="https://github.com/vi/websocat" rel="noopener ugc nofollow" target="_blank">websocat</a></code>来测试websocket部分。你也可以使用任何带有websocket客户端扩展的浏览器，比如Firefox的简单Websocket客户端。我假设您已经安装了<code class="fe mc md me mf b">curl</code>，那么让我们使用下面的命令安装<code class="fe mc md me mf b">websocat</code>:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="b44a" class="jy jz iq mf b gy mo mp l mq mr">cargo install websocat</span></pre><p id="1881" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">没错，<code class="fe mc md me mf b">websocat</code>可以用<code class="fe mc md me mf b">cargo</code>安装。</p><p id="adeb" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在让我们像这样创建我们的rust项目:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3c4f" class="jy jz iq mf b gy mo mp l mq mr">cargo new http-ws-server-rs</span></pre><p id="795c" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">接下来，我们需要将本例中使用的依赖项添加到<code class="fe mc md me mf b">Cargo.toml</code>的依赖项部分:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3300" class="jy jz iq mf b gy mo mp l mq mr">[dependencies]<br/>futures = { version="0.3" }<br/>tokio = { version="1.0", features=["rt","macros"] }<br/>hyper={ version="0.14", features=["server","http1","http2","tcp"] }<br/>tungstenite={ version="0.12", default-features=false }<br/>tokio-tungstenite={ version="0.13" }</span></pre><p id="0c56" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">因为我们正在编写一个异步服务器，所以我们需要<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/futures/0.3.12/futures/" rel="noopener ugc nofollow" target="_blank">futures</a></code>机箱。我们还需要一个异步服务器的运行时，由<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/tokio/1.1.1/tokio/" rel="noopener ugc nofollow" target="_blank">tokio</a></code>提供。为我们提供http构建模块的机箱是<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/hyper/0.14.2/hyper/" rel="noopener ugc nofollow" target="_blank">hyper</a></code>。然后<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/tungstenite/0.12.0/tungstenite/" rel="noopener ugc nofollow" target="_blank">tungstenite</a></code>为我们提供了websocket握手实现，而<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/tokio-tungstenite/0.13.0/tokio_tungstenite/" rel="noopener ugc nofollow" target="_blank">tokio-tungstenite</a></code>给了我们一个<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/tokio-tungstenite/0.13.0/tokio_tungstenite/struct.WebSocketStream.html" rel="noopener ugc nofollow" target="_blank">WebsocketStream</a></code>实现。我只选择了构建我们的示例所需的<a class="ae lp" href="https://doc.rust-lang.org/cargo/reference/features.html" rel="noopener ugc nofollow" target="_blank">机箱特征</a>，您可能需要更多的特征。</p><h2 id="c673" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">使用<a class="ae lp" href="https://hyper.rs/guides/" rel="noopener ugc nofollow" target="_blank"> hyper </a>的HTTP服务器</h2><p id="1aba" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我们将使用<code class="fe mc md me mf b"><a class="ae lp" href="https://hyper.rs/guides/server/hello-world/" rel="noopener ugc nofollow" target="_blank">hyper</a></code> <a class="ae lp" href="https://hyper.rs/guides/server/hello-world/" rel="noopener ugc nofollow" target="_blank">自己的例子</a>使用<code class="fe mc md me mf b">hyper</code>来构建一个简单的web服务器。下面是我们将从<code class="fe mc md me mf b">src/main.rs</code>文件开始的代码:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9046" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">如果你看一下<code class="fe mc md me mf b"><a class="ae lp" href="https://hyper.rs/guides/server/hello-world/" rel="noopener ugc nofollow" target="_blank">hyper</a></code> <a class="ae lp" href="https://hyper.rs/guides/server/hello-world/" rel="noopener ugc nofollow" target="_blank">的例子</a>，你会发现这段代码几乎是一样的，只有一些小的不同。第一个区别是添加到main的属性:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="8c63" class="jy jz iq mf b gy mo mp l mq mr">#[tokio::main(flavor = "current_thread")]</span></pre><p id="3d77" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><a class="ae lp" href="https://docs.rs/tokio/1.1.1/tokio/attr.main.html" rel="noopener ugc nofollow" target="_blank">这指示</a> <code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/tokio/1.1.1/tokio/attr.main.html" rel="noopener ugc nofollow" target="_blank">tokio</a></code> <a class="ae lp" href="https://docs.rs/tokio/1.1.1/tokio/attr.main.html" rel="noopener ugc nofollow" target="_blank">在当前线程</a>上运行。构建自己的服务器时，您必须决定服务器是多线程的还是单线程的。我们只是让这个例子简单一些。</p><p id="43be" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">另一个区别是，在第22行和第26行，你可以看到我们将远程地址传递给了我们的处理函数。这绝对不是必需的，这只是为了展示一种情况，在这种情况下，您可能希望在处理程序中方便地保存这些信息，以备记录之需。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="43e9" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在让我们运行这个服务器，看看会发生什么:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="1008" class="jy jz iq mf b gy mo mp l mq mr"><strong class="mf ir">~/http-ws-server-rs</strong>$ cargo run <br/><strong class="mf ir">    Finished</strong> dev [unoptimized + debuginfo] target(s) in 0.02s <br/><strong class="mf ir">     Running</strong> `target/debug/http-ws-server-rs` <br/>Listening on 127.0.0.1:3000 for http or websocket connections.</span></pre><p id="34ad" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在服务器启动了，让我们使用<code class="fe mc md me mf b">curl</code>来连接它:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="9a1a" class="jy jz iq mf b gy mo mp l mq mr"><strong class="mf ir">~/http-ws-server-rs</strong>$ curl localhost:3000 <br/>Hello there connection 127.0.0.1:34830</span></pre><p id="f811" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">正如我们所预料的那样，我们收到了一个hello问候和发出请求的地址。我们现在可以继续增强处理程序的功能。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="8a2b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">处理http与websocket</h2><p id="48de" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">现在我们有了处理函数，我们需要做的就是弄清楚什么时候请求实际上是一个websocket握手请求，而不仅仅是一个普通的http请求。正如简介中提到的，我们可以只查看<a class="ae lp" href="https://docs.rs/hyper/0.14.2/hyper/header/constant.UPGRADE.html" rel="noopener ugc nofollow" target="_blank">升级头</a>来判断客户端是否试图启动websocket连接。自然，我们将为此使用一个<code class="fe mc md me mf b"><a class="ae lp" href="https://doc.rust-lang.org/rust-by-example/flow_control/match.html" rel="noopener ugc nofollow" target="_blank">match</a></code>模块。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3df0" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">如您所见，<code class="fe mc md me mf b">match</code>块匹配一个由uri路径和一个告诉我们升级头是否存在的布尔值组成的<a class="ae lp" href="https://doc.rust-lang.org/rust-by-example/primitives/tuples.html" rel="noopener ugc nofollow" target="_blank">元组</a>。如果Upgrade头存在，那么我们可以假设该请求是一个websocket握手请求。从<code class="fe mc md me mf b">match</code>块可以看出，我们只接受第一个分支上的websocket连接，这与<code class="fe mc md me mf b">/ws_echo</code>上的uri路径相匹配。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="77d8" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">Websocket握手响应</h2><p id="116b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">接受连接的第一步是用握手响应来回答握手请求。为此，我们将使用<code class="fe mc md me mf b">tungstenite</code> crate方法<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/tungstenite/0.12.0/tungstenite/handshake/server/fn.create_response_with_body.html" rel="noopener ugc nofollow" target="_blank">create_response_with_body</a></code>，它将创建一个正确的握手响应，并验证该请求是否为正确的websocket握手请求。下面是能够创建握手响应的块:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0bf6" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">最后你会看到这一切是如何联系在一起的。现在只需注意我们匹配了<code class="fe mc md me mf b">create_response_with_body</code>的返回值。如果方法返回<code class="fe mc md me mf b">Ok</code>，那么我们可以启动websocket连接。如果该方法返回<code class="fe mc md me mf b">Err</code>，这意味着该请求不是有效的websocket握手请求。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="947b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">启动websocket流</h2><p id="d58e" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">一旦我们收到来自<code class="fe mc md me mf b">create_response_with_body</code>的包含握手响应的<code class="fe mc md me mf b">Ok</code>，我们就可以继续使用请求来创建我们的websocket连接，如下所示:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e592" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">我们要做的第一件事是<a class="ae lp" href="https://docs.rs/tokio/1.1.1/tokio/task/fn.spawn.html" rel="noopener ugc nofollow" target="_blank">生成一个任务</a>，该任务将在websocket连接的剩余生命周期中处理它。然后，我们使用<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/hyper/0.14.2/hyper/upgrade/fn.on.html" rel="noopener ugc nofollow" target="_blank">hyper::upgrade::on</a></code>方法将请求升级到持久连接。在这一部分，我们将请求转换成流，以便能够对其进行读写。<code class="fe mc md me mf b">hyper::upgrade::on</code>方法返回一个<a class="ae lp" href="https://doc.rust-lang.org/std/future/trait.Future.html" rel="noopener ugc nofollow" target="_blank">未来</a>，所以我们必须<code class="fe mc md me mf b"><a class="ae lp" href="https://doc.rust-lang.org/std/keyword.await.html" rel="noopener ugc nofollow" target="_blank">await</a></code>它来接收结果。成功后，我们得到一个带有<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/hyper/0.14.2/hyper/upgrade/struct.Upgraded.html" rel="noopener ugc nofollow" target="_blank">Upgraded</a></code>对象的<code class="fe mc md me mf b">Ok</code>，我们将通过从它创建一个<code class="fe mc md me mf b">WebSocketStream</code>来使用它作为我们的<code class="fe mc md me mf b"><a class="ae lp" href="https://docs.rs/tokio-tungstenite/0.13.0/tokio_tungstenite/struct.WebSocketStream.html" rel="noopener ugc nofollow" target="_blank">WebSocketStream</a></code>的基础。您可以将<code class="fe mc md me mf b">Upgraded</code>对象或多或少地视为请求的底层TCP连接的句柄。除了<code class="fe mc md me mf b">Upgraded</code>对象之外，我们还需要<code class="fe mc md me mf b">WebSocketStream</code>，因为<code class="fe mc md me mf b">WebSocketStream</code>能够添加和删除【websocket消息所需的帧和开销。它还能给我们一个<a class="ae lp" href="https://docs.rs/futures/0.3.12/futures/stream/trait.Stream.html" rel="noopener ugc nofollow" target="_blank">流</a>，带有<code class="fe mc md me mf b">Upgraded</code>对象所缺少的所有<a class="ae lp" href="https://docs.rs/futures/0.3.12/futures/stream/trait.StreamExt.html" rel="noopener ugc nofollow" target="_blank">花里胡哨</a>。</p><p id="f1cd" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在我们有了这个东西，我们可以用它做任何我们想做的事情。在这个例子中，我们只是将拆分为<a class="ae lp" href="https://docs.rs/futures/0.3.12/futures/sink/trait.Sink.html" rel="noopener ugc nofollow" target="_blank">接收器</a>和<a class="ae lp" href="https://docs.rs/futures/0.3.12/futures/stream/trait.Stream.html" rel="noopener ugc nofollow" target="_blank">流</a>，这样我们就可以<a class="ae lp" href="https://docs.rs/futures/0.3.12/futures/stream/trait.StreamExt.html#method.forward" rel="noopener ugc nofollow" target="_blank">将流</a>转发到接收器，从而实现回声。一旦连接关闭，转发将失败，整个任务将结束。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="9bb1" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">完成请求处理程序</h2><p id="ba53" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">现在让我们把所有这些放到一个完整的处理程序中，看看它是什么样子的。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7424" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在我们只需用这个函数替换<code class="fe mc md me mf b">src/main.rs</code>文件中最初的一行程序<code class="fe mc md me mf b">handle_request</code>函数。包括所有必要的<code class="fe mc md me mf b">use</code>语句。</p><h2 id="f1e9" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">测试最终处理器</h2><p id="396c" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">用上面的完整处理程序实现更新初始处理程序后，我们可以启动改进的服务器:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="add4" class="jy jz iq mf b gy mo mp l mq mr"><strong class="mf ir">~/http-ws-server-rs</strong>$ cargo run <br/><strong class="mf ir">    Finished</strong> dev [unoptimized + debuginfo] target(s) in 0.02s <br/><strong class="mf ir">     Running</strong> `target/debug/http-ws-server-rs` <br/>Listening on 127.0.0.1:3000 for http or websocket connections.</span></pre><p id="c3d7" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在让我们看看它如何处理<code class="fe mc md me mf b">curl</code>请求和<code class="fe mc md me mf b">websocat</code>连接。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="c4b1" class="jy jz iq mf b gy mo mp l mq mr"><strong class="mf ir">~/http-ws-server-rs</strong>$ curl localhost:3000 <br/>This / url doesn't do much, try accessing the /ws_echo url instead. <br/><strong class="mf ir">~/http-ws-server-rs</strong>$ curl localhost:3000/whichever_path <br/>This /whichever_path url doesn't do much, try accessing the /ws_echo url instead. <br/><strong class="mf ir">~/http-ws-server-rs</strong>$ curl localhost:3000/ws_echo <br/>Getting even warmer, try connecting to this url using a websocket client. <br/><strong class="mf ir">~/http-ws-server-rs</strong>$ websocat ws://127.0.0.1:3000/ws_echo <br/>hello, my name is... <br/>hello, my name is...</span></pre><p id="7793" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">成功！我们有一个服务器在同一个端口上处理http和weboscket。</p></div></div>    
</body>
</html>