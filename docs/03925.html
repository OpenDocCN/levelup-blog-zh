<html>
<head>
<title>Can you solve these 3 (seemingly) easy Python problems?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你能解决这3个(看似)简单的Python问题吗？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/can-you-solve-these-3-seemingly-easy-python-problems-2c793967cd2c?source=collection_archive---------4-----------------------#2020-06-02">https://levelup.gitconnected.com/can-you-solve-these-3-seemingly-easy-python-problems-2c793967cd2c?source=collection_archive---------4-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决方案会让你大吃一惊。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e46e28f79e0aa87a3cef4e945070283e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dHq4A4-ZhnhBFRCISC7ug.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1641959" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/FreePhotosART-3184606/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1641959" rel="noopener ugc nofollow" target="_blank"> FreePhotosART </a></figcaption></figure><p id="a7b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试着解决下面的问题，然后检查下面的答案。</p><p id="6f67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的问题都有一些共同点，所以在解决剩下的问题之前检查第一个问题的解决方案可以减少挑战。</p><h2 id="85a1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">问题1 </strong></h2><p id="0e2b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们有几个变量:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6205" class="lv lw it mu b gy my mz l na nb">x = 1<br/>y = 2<br/>l = [x, y]<br/>x += 5</span><span id="8fe7" class="lv lw it mu b gy nc mz l na nb">a = [1]<br/>b = [2]<br/>s = [a, b]<br/>a.append(5)</span></pre><p id="305a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印<code class="fe nd ne nf mu b">l</code>和<code class="fe nd ne nf mu b">s</code>会产生什么结果？</p><p id="dfb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#707e" rel="noopener ugc nofollow">跳转到解决方案</a></p><h2 id="dcfd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题2</h2><p id="3eed" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们定义一个简单的函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9f93" class="lv lw it mu b gy my mz l na nb">def f(x, s=set()):<br/>    s.add(x)<br/>    print(s)</span></pre><p id="4d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你打电话会发生什么？</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="88f4" class="lv lw it mu b gy my mz l na nb">&gt;&gt;f(7)<br/>&gt;&gt;f(6, {4, 5})<br/>&gt;&gt;f(2)</span></pre><p id="1777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">?</p><p id="bafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#aa97" rel="noopener ugc nofollow">跳转到解决方案</a></p><h2 id="83e1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题3</h2><p id="5fd2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们定义三个简单的函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="80bb" class="lv lw it mu b gy my mz l na nb">def f():<br/>    l = [1]<br/>    def inner(x):<br/>        l.extend([x])<br/>        return l<br/>    return inner</span><span id="5bfa" class="lv lw it mu b gy nc mz l na nb">def g():<br/>    y = 1<br/>    def inner(x):<br/>        y += x<br/>        return y<br/>    return inner</span><span id="8209" class="lv lw it mu b gy nc mz l na nb">def h():<br/>    l = [1]<br/>    def inner(x):<br/>        l += [x]<br/>        return l<br/>    return inner</span></pre><p id="9192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下命令的结果会是什么？</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="bc47" class="lv lw it mu b gy my mz l na nb">&gt;&gt;f_inner = f()<br/>&gt;&gt;print(f_inner(2))</span><span id="6b74" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;g_inner = g()<br/>&gt;&gt;print(g_inner(2))</span><span id="451d" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;h_inner = h()<br/>&gt;&gt;print(h_inner(2))</span></pre><p id="1727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#42ad" rel="noopener ugc nofollow">跳转到解决方案</a></p><p id="5501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你对自己的答案有多自信？让我们看看你是不是对的。</p><h2 id="707e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">问题1的解决方案</strong></h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="48c7" class="lv lw it mu b gy my mz l na nb">&gt;&gt;print(l)<br/>[1, 2]</span><span id="b680" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;print(s)<br/>[[1, 5], [2]]</span></pre><p id="76db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么第二个列表会对其第一个元素<code class="fe nd ne nf mu b">a.append(5)</code>的变化做出反应，而第一个列表却完全忽略了类似的变化<code class="fe nd ne nf mu b">x+=5</code>？</p><h2 id="aa97" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题2的解决方案</h2><p id="7696" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们看看会发生什么:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d66b" class="lv lw it mu b gy my mz l na nb">&gt;&gt;f(7)<br/>{7}</span><span id="d74c" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;f(6, {4, 5})<br/>{4, 5, 6}</span><span id="a14a" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;f(2)<br/>{2, 7}</span></pre><p id="6bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，最后输出的不应该是<code class="fe nd ne nf mu b">{2}</code>吗？</p><h2 id="42ad" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题3的解决方案</h2><p id="a745" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">产出如下:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9bd1" class="lv lw it mu b gy my mz l na nb">&gt;&gt;f_inner = f()<br/>&gt;&gt;print(f_inner(2))<br/>[1, 2]</span><span id="04ae" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;g_inner = g()<br/>&gt;&gt;print(g_inner(2))<br/>UnboundLocalError: local variable ‘y’ referenced before assignment</span></pre><p id="4f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么<code class="fe nd ne nf mu b">g_inner(2)</code>不输出<code class="fe nd ne nf mu b">3</code>？为什么<code class="fe nd ne nf mu b">f() </code>的内部函数记得它的外部作用域，而<code class="fe nd ne nf mu b">g()</code>的内部函数却不记得？他们实际上是一样的！</p><h1 id="661c" class="ng lw it bd lx nh ni nj ma nk nl nm md jz nn ka mg kc no kd mj kf np kg mm nq bi translated">说明</h1><p id="3a93" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们来探讨一下Python中<strong class="lb iu">可变</strong>和<strong class="lb iu">不可变</strong>对象的区别。</p><p id="cd77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">像列表、集合或字典<strong class="lb iu">这样的可变对象</strong>可以就地改变</strong>(变异)。<strong class="lb iu">不可变对象</strong>如整数、字符串和元组<strong class="lb iu">不能</strong>——这种对象的“改变”导致新对象的创建。</p><h2 id="2ef7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题1的解释</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f698" class="lv lw it mu b gy my mz l na nb">x = 1<br/>y = 2<br/>l = [x, y]<br/>x += 5</span><span id="da50" class="lv lw it mu b gy nc mz l na nb">a = [1]<br/>b = [2]<br/>s = [a, b]<br/>a.append(5)</span><span id="2902" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;print(l)<br/>[1, 2]</span><span id="030c" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;print(s)<br/>[[1, 5], [2]]</span></pre><p id="1450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe nd ne nf mu b">x</code>是不可变的，操作<code class="fe nd ne nf mu b">x+=5</code>不会改变原来的对象，而是创建一个新的对象。列表的第一个元素仍然指向原始对象，因此它的值保持不变。</p><p id="e20b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是可变对象<code class="fe nd ne nf mu b">a</code>，<code class="fe nd ne nf mu b">a.append(5)</code>改变了原来的对象，因此list <code class="fe nd ne nf mu b">s</code>会“看到”这种改变。</p><h2 id="b116" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题2的解释</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="977f" class="lv lw it mu b gy my mz l na nb">def f(x, s=set()):<br/>    s.add(x)<br/>    print(s)</span><span id="a271" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;f(7)<br/>{7}</span><span id="a23a" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;f(6, {4, 5})<br/>{4, 5, 6}</span><span id="bdc8" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;f(2)<br/>{2, 7}</span></pre><p id="cfcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前两个输出总的来说是有意义的:首先将<code class="fe nd ne nf mu b">7</code>的值添加到默认的空集，产生<code class="fe nd ne nf mu b">{7}</code>，然后将<code class="fe nd ne nf mu b">6</code>的值添加到<code class="fe nd ne nf mu b">{4, 5}</code>的集合，产生<code class="fe nd ne nf mu b">{4, 5, 6}</code>。</p><p id="a1f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是接下来奇怪的事情发生了:<code class="fe nd ne nf mu b">2</code>的值不是添加到默认的空集，而是添加到<code class="fe nd ne nf mu b">{7}</code>的一个集合。为什么？<strong class="lb iu">可选参数s的默认值仅评估一次</strong>——仅在第一次调用期间<code class="fe nd ne nf mu b">s</code>将被初始化为空集。由于<code class="fe nd ne nf mu b">s</code>在调用<code class="fe nd ne nf mu b">f(7)</code>后<strong class="lb iu">是可变的</strong>,所以它被就地修改。第二次调用<code class="fe nd ne nf mu b">f(6, {4, 5})</code>不会影响默认参数——所提供的设置<code class="fe nd ne nf mu b">{4, 5}</code>隐藏了它，换句话说<code class="fe nd ne nf mu b">{4, 5}</code>是一个不同的变量。第三次调用<code class="fe nd ne nf mu b">f(2)</code>使用了第一次调用中使用的相同的<code class="fe nd ne nf mu b">s</code>变量，但是s没有被重新初始化为一个空集——而是使用了它之前的值<code class="fe nd ne nf mu b">{7}</code>。</p><p id="4fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么<strong class="lb iu">你不应该使用可变的默认参数</strong>。在这种情况下，应按照以下方式修改函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d4d2" class="lv lw it mu b gy my mz l na nb">def f(x, s=None):<br/><strong class="mu iu">    if s is None:<br/>        s = set()</strong><br/>    s.add(x)<br/>    print(s)</span></pre><h2 id="c6eb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题3的解释</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c8da" class="lv lw it mu b gy my mz l na nb">def f():<br/>    l = [1]<br/>    def inner(x):<br/>        l.extend([x])<br/>        return l<br/>    return inner</span><span id="71e9" class="lv lw it mu b gy nc mz l na nb">def g():<br/>    y = 1<br/>    def inner(x):<br/>        y += x<br/>        return y<br/>    return inner</span><span id="391a" class="lv lw it mu b gy nc mz l na nb">def h():<br/>    l = [1]<br/>    def inner(x):<br/>        l += [x]<br/>        return l<br/>    return inner</span><span id="a92e" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;f_inner = f()<br/>&gt;&gt;print(f_inner(2))<br/>[1, 2]</span><span id="9491" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;g_inner = g()<br/>&gt;&gt;print(g_inner(2))<br/>UnboundLocalError: local variable ‘y’ referenced before assignment</span><span id="1601" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;h_inner = h()<br/>&gt;&gt;print(h_inner(2))<br/>UnboundLocalError: local variable ‘l’ referenced before assignment</span></pre><p id="6e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个问题中，我们处理<strong class="lb iu">闭包</strong>——内部函数记得它们的封闭名称空间在定义时的样子。</p><p id="6c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么发生了什么？如果您只比较前两个函数的行为，您可能会再次认为差异与作为可变列表的<code class="fe nd ne nf mu b">l</code>和作为不可变字符串的<code class="fe nd ne nf mu b">x</code>有关。</p><p id="ecac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看带有函数<code class="fe nd ne nf mu b">h</code>的示例，可以看出还有其他的东西。这里就像在函数<code class="fe nd ne nf mu b">f</code>中一样，我们试图改变一个可变列表，但是这次我们失败了。你可能会认为操作<code class="fe nd ne nf mu b">l.extend([x])</code>和<br/> <code class="fe nd ne nf mu b">l += [x]</code>是等价的，但实际上它们之间有一个微妙的区别:在幕后<code class="fe nd ne nf mu b">l.extend</code>将导致编译器调用<code class="fe nd ne nf mu b">LOAD_DEREF</code>指令，该指令将加载非局部列表<code class="fe nd ne nf mu b">l</code>(然后列表将被修改)，而使用<code class="fe nd ne nf mu b">l += [x]</code>编译器将调用<code class="fe nd ne nf mu b">LOAD_FAST</code>，该指令在内部函数的局部范围内寻找变量<code class="fe nd ne nf mu b">l</code>并因此失败。</p><p id="9610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免使用<code class="fe nd ne nf mu b">UnboundLocalError</code>，你可以使用<code class="fe nd ne nf mu b">nonlocal</code>关键字:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e951" class="lv lw it mu b gy my mz l na nb">def g():<br/>    y = 1<br/>    def inner(x):<br/>        <strong class="mu iu">nonlocal</strong> y<br/>        y += x<br/>        return y<br/>    return inner</span><span id="e2f3" class="lv lw it mu b gy nc mz l na nb">def h():<br/>    l = [1]<br/>    def inner(x):<br/>        <strong class="mu iu">nonlocal</strong> l<br/>        l += [x]<br/>        return l<br/>    return inner</span><span id="f405" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;g_inner = g()<br/>&gt;&gt;print(g_inner(2))<br/>3</span><span id="c714" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;h_inner = h()<br/>&gt;&gt;print(h_inner(2))<br/>[1, 2]</span></pre><h1 id="adae" class="ng lw it bd lx nh ni nj ma nk nl nm md jz nn ka mg kc no kd mj kf np kg mm nq bi translated"><strong class="ak">结论</strong></h1><p id="c9da" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这里有几条建议:</p><p id="9778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意可变变量和不可变变量之间的区别。</p><p id="2bc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">不要使用可变的默认参数。</strong></p><p id="11e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在内部函数中改变闭包变量时要小心。使用nonlocal关键字声明变量不是局部的。</strong></p><p id="4f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意分享您的回答中由于误用可变和不可变对象而导致的潜在问题的其他例子。如果你想了解可变和不可变对象在列表复制中扮演什么角色，请查看<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/five-ways-to-copy-a-list-in-python-f6f179d9785b">我的下一篇文章</a>。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ny"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">编写面试问题</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">技术开发</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div></div></div>    
</body>
</html>