# 使用 Immer 来管理您不可变的 React 状态

> 原文：<https://levelup.gitconnected.com/use-immer-to-manage-your-immutable-react-state-519f4555fb8c>

![](img/921e8fb871b7f0885c22a2e35f6ab3a6.png)

如果您使用过 React，或者坦率地说，任何 JavaScript 框架，您可能都遇到过保持状态“不可变”的想法。换句话说，在处理状态时，您希望避免在修改特定值时改变状态对象。不变性是面向对象和函数式编程的核心概念，所以在我深入了解 Immer 的神奇之处之前，我只想花一点时间来阐述什么是不变性，以及为什么它在我们构建的应用程序中很重要。

# 什么是“不变性”？

不管编程环境如何，不可变的根本含义就是不可改变。基本上，木已成舟，没有回头路。教科书定义和纲领性定义的不同之处在于，不是*能不能*你的问题，而是*应该*你的问题？

因为我的编程知识非常局限于 web 领域，所以任何关于不可变编程实践的进一步讨论都将在 JavaScript 的上下文中进行。

我认为对 JS 中变异的一个常见误解是重新分配一个已经声明的变量。

例如:

然而，这是不正确的，因为可变性严格处理`object`原始类型，因此将`name`重新分配给`age`不是突变。顺便提一下，如果这是您想要阻止的行为，要么考虑使用 TypeScript，将`name`指定为`const`，要么两者都用(我的偏好)。

# React 促进不可变的状态交互

如果您曾经使用过 React，您可能已经知道该框架是不变性的倡导者和采纳者。文档[进一步讨论了这一点，但是我可以给你 TL；博士像 React 这样的 JS 框架的终极目标就是“反应式”。换句话说，当一个 JavaScript 值改变时，对它做出反应！这可以是更改按钮颜色、数值，或者可能是项目列表中的一个项目。让我们以这种状态结构为例:](https://reactjs.org/docs/update.html)

如果您想为 Bob 添加一个爱好，考虑到这个结构，您可以直接推送到他的`hobbies`数组:

然而，这种方法的缺点是，您无法知道自从该对象的前一个副本被覆盖以来，该状态对象中哪些特定的*属性发生了变化。这就是当您深入一个对象以更新一个属性而不关心该对象的其他属性时所发生的情况。*

现代钩子时代无疑改变了我们在 React 应用中处理状态的方式。最值得注意的是，我们不再需要将组件的所有状态存储在一个巨大的对象中。`useState`钩子允许我们在给定的组件中逐项列出我们的状态对象。如果您和我一样，我非常喜欢将相关的组件状态组合在一个`useState`钩子中。换句话说，我经常使用多个`useState`钩子来处理对象，而不是单一值。

下面是我最常用的方法之一，用来更新在`useState`钩子中定义的给定状态对象的状态:

每当我在状态对象中更新一个值时，我必须确保不要改变整个对象。提供给从`useState`返回的两个值中的第二个值的初始参数是基于作为参数传递的值的先前状态。

这不是那么糟糕，对不对？非常简洁，如果你熟悉箭头函数、隐式返回和对象扩展的话，可读性很好，但这是最简单的情况。如果我们处理的不是一个表单，而是一组用户对象，比如:

当用户确认他们的电子邮件时，我们希望为他们的用户对象更新`emailConfirmed`属性。

因此，当映射到以前的用户状态时，当我们发现用户的 id 等于`confirmedUserId`时，我们希望扩展到该对象并更新其`emailConfirmed`属性。同样，这并不疯狂，但是你可以看到当你的状态嵌套得越多，你的应用程序变得越复杂，这就变得越麻烦。

# Immer 是来帮忙的

我知道，我花了一秒钟去 Immer，但我想为我为什么喜欢使用它设置场景。在过去的几年里，它在 React 领域越来越受欢迎。Immer 基于[写时复制](https://en.wikipedia.org/wiki/Copy-on-write)范式运行，这基本上意味着它能够创建状态的草稿副本，对于对该副本所做的任何修改，将基于这些修改发布新的状态。我将从 [Immer 文档](https://immerjs.github.io/immer/docs/introduction)中窃取一幅插图，因为我想不出更好的可视化流程:

![](img/b2532e9c88842ef8bafd7a4a3829b356.png)

资料来源:https://immerjs.github.io/immer/docs/introduction

所以 Immer 的关键是它的“产生”函数，该函数接受你的原始状态副本作为参数，然后用该状态的草稿版本进行回调。在这个回调中，你可以随心所欲地修改草稿，Immer 将确保最终结果保持不变。很酷，对吧？我也这么认为让我们看看如何使用`produce`来更新用户的`emailConfirmed`属性:

在某个点击处理程序中，我们会像这样使用这个生成器:

就像这样，我们能够更直接地更新状态，从我们的角度来看，改变目标用户的对象(即使 Immer 在这方面支持我们)。不过，在我看来，这有点笨拙。另一种我们可以达到同样效果并且更简洁的方法是通过编写一个[curred producer](https://immerjs.github.io/immer/docs/curried-produce)。我不会深入探讨 JavaScript 中的 currying 是什么，但基本上 curried producer 只需要一个状态来产生一个新值，以及与操作相关的任何附加参数。上面定义的`updateUsers`的一个简化版本是:

请注意普通制作人和咖喱制作人之间的区别:

```
*regular: produce(state, recipe) => nextState**currying: produce(recipe) => state => nextState*
```

如果您想提取组件之外的功能进行单元测试，这可能很好，但是我个人并不经常使用这种方法。有一个名为 [use-immer](https://www.npmjs.com/package/use-immer) 的小软件包是由 immer 的作者创建和维护的，它提供了一个`useImmer`(和`useImmerReducer`)钩子，允许你像使用`useState`一样使用组件状态。在我使用 Immer 的大多数情况下，我使用的是`useImmer`钩子。因此，复制我们最初用`useImmer`更新用户数组的方法看起来会像这样:

就我个人而言，我喜欢将从这个钩子返回的值命名为不同于我用常规的`useState`钩子所命名的值，只是为了区分这两者。此外，有了这个钩子，我不再觉得有必要详细列举/分组状态，因为不管状态对象如何嵌套，用 Immer 更新它都相对简单。

# 补丁

Immer 还允许您使用[补丁](https://immerjs.github.io/immer/docs/patches)来跟踪状态的增量变化。当然，并不是每个状态对象都需要这样，但是对于某些用例来说，这可能非常方便，特别是当您希望拥有撤销/重做功能的时候。这不一定与不变性有关，但我认为这是 Immer 的一个非常好的选择加入特性。这里有一个简单的例子，说明如何使用 Immer 的`produceWithPatches`将补丁合并到上面的状态设置中。请记住，您必须稍微调整一下函数的结构，以处理它返回的元组:

注意:为了使包尽可能小，默认情况下，Immer 禁用补丁。如果您希望启用它们，请在应用程序的根目录下调用 Immer 的`enablePatches()` 方法

在这里，我们的`nextState`将是更新后的状态对象，`patches`将是应用于状态的变更的详细列表，如果凯文的`emailConfirmed`属性被更新，它将看起来像这样:

而`inversePatches`就是这样一个函数——撤销`patches`中包含的所有更改。很漂亮，对吧？至少我是这样认为的。如果你想玩玩`produceWithPatches`，看看这个[沙盒](https://stackblitz.com/edit/react-gxzkyx)。

我最喜欢 Immer 的部分是它做的很少。它提供了这样一个最小的 API，在浏览完文档后，从零知识到开始运行是非常容易的。这无疑让我在 React 中的开发经历变得更加愉快，我希望在这之后你会愿意尝试一下！当然，除非你喜欢自己处理不变性；)

此外，关于 Immer，Sebastian Markbå ge 说:

如果这不是一种认可，我不知道什么是。

感谢您的倾听👋🏻