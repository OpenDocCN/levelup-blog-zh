<html>
<head>
<title>An Unfiltered Journey Writing a Cleanup Program in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python编写清理程序的未过滤之旅</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-uncensored-timeline-of-writing-a-cleanup-python-project-cee4ea728541?source=collection_archive---------7-----------------------#2020-05-17">https://levelup.gitconnected.com/an-uncensored-timeline-of-writing-a-cleanup-python-project-cee4ea728541?source=collection_archive---------7-----------------------#2020-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ef8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从构思到完成的混乱过程，展示了开发过程背后的想法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea0bfa1ae4f29a18f3f6b6905d519748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAoa_hN6be716GSpUf2ehQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/person-looking-searching-clean-2371/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae ky" href="https://www.pexels.com/@gratisography?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">地形</a>拍摄</figcaption></figure><p id="f995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">嗨</span>欢迎来到混沌！不是不受控制的混乱，而是从想法到产品的路径。在这篇文章中，我想尝试一些新的东西。通常情况下，文章会经过润色和微调，为您提供一份食谱。代码及其背后的所有工作都经过过滤和清理，因此您不会被幕后进行的所有思考所干扰。</p><p id="f69c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你能从未经过滤的时间线中获益会怎样？代码背后的思想才是真正重要的吗？文档将指导你，并给你一个函数能做的所有事情的总体概述。你知道使用它的所有方法吗？你知道如何走出错误吗？并不总是这样，我相信观察别人是如何思考的，尤其是他们是如何改正错误的，这很有价值。</p><p id="976f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你看一个youtube教程，身体前倾看别人如何改正错误时，你不讨厌吗？相反，他们剪切视频，说“那么…现在它工作了，让我们继续吧”</p><p id="4b43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加入我从纸上到屏幕的旅程，我会告诉你我所有的错误，以及我如何从A到b。</p><p id="c1d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过包括所有的谷歌搜索，试验和错误，以及草图，我希望你能够了解我的过程。</p><p id="4d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想法→研究→初始代码→重构代码</p><p id="6e19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你通读这篇文章，偶然发现一些糟糕的代码或可怕的错误，请让我知道。请务必通读一遍，这样你就可以看到我是否一路修正了错误。如前所述，本文的大部分内容都是关于试错的。</p><p id="d35f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是为初学Python的程序员而写的，但是任何人都应该能够从中有所收获。最终结果是一个工作程序，但是与操作系统的集成可以更好。我们会回来的。</p><h2 id="474d" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">让旅程开始吧…</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/0d28ac01bbe649a761726d9d0d1fb940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxA1NC4EdaYbyx0e0anmVw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/brown-road-sign-on-pavement-near-mountain-2009968/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@mark-neal-201020?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马克·尼尔</a>的照片</figcaption></figure><h1 id="9b9f" class="my mf it bd mg mz na nb mj nc nd ne mm jz nf ka mp kc ng kd ms kf nh kg mv ni bi translated">开始打扫(。py)</h1><blockquote class="nj"><p id="b430" class="nk nl it bd nm nn no np nq nr ns lu dk translated">老实说，你真的有时间手动清理文件夹吗？</p></blockquote><p id="c0b4" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">每当我开始一个新项目，我做的第一件事就是试图找到程序的范围。我的程序到底应该让<strong class="lb iu">做什么</strong>？什么问题应该由<strong class="lb iu">来解决</strong>？</p><p id="7101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我想创建一个程序，将清理文件夹。像<em class="ny">下载</em>或<em class="ny">桌面</em>这样的文件夹会很快变得杂乱。老实说，你真的有时间手动清理文件夹吗？</p><p id="e5ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个功能可以应用于清理程序。这里有一些很快在纸上勾画出来的想法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/2ebb02af112f20eba979ca6c39bdb56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZhlAXXh8ZyacjOhMhV4fA@2x.jpeg"/></div></div></figure><p id="240b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个最初的草图之后，我决定采用文件扩展名→文件夹的方法。这意味着该程序将寻找文件扩展名，并创建与扩展名同名的文件夹。它会将文件移动到相应的文件夹中。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="daff" class="me mf it ob b gy of og l oh oi"># make the script run on intervals. Once per day maybe?</span><span id="4d95" class="me mf it ob b gy oj og l oh oi"># go to folder</span><span id="b820" class="me mf it ob b gy oj og l oh oi"># loop through files</span><span id="4c20" class="me mf it ob b gy oj og l oh oi"># create folders based on file type</span><span id="dbc1" class="me mf it ob b gy oj og l oh oi"># move files to corresponding folder</span><span id="1906" class="me mf it ob b gy oj og l oh oi"># (sort with subfolders on month ?)</span><span id="15ad" class="me mf it ob b gy oj og l oh oi"># (additional options on what to do with the files?)</span></pre><p id="7ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">伪代码帮助我规划出代码中的各个部分。一次专注于一个问题比试图一口气创造出一个成品更容易。即使你像这样列出功能，也不意味着你需要按时间顺序来解决它。</p><p id="f834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，让脚本自动运行并不是目前的首要任务。如果我没有一个可以运行的程序，让它自己运行是没有意义的。</p><p id="3d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们期待的最终结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/caf041ddda185ef832826f4d4481dc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*f590Q1TfqNMMZn5BCt6xAw.gif"/></div></div></figure><h1 id="8ba7" class="my mf it bd mg mz na nb mj nc nd ne mm jz nf ka mp kc ng kd ms kf nh kg mv ni bi translated">文件和文件夹</h1><p id="7116" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">当我查看我的伪代码时，很明显我需要查看如何访问磁盘上的文件并使用它们。</p><p id="16d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Python浏览磁盘上的文件已经做了一百万次了，所以我很有信心有一个专门的库。我也相信谷歌搜索就能给我所有我需要知道的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/f3e47e2263e4eab3f039f343e30449ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BUc9GMSOZJKcPZFwsraqA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">没过多久，谷歌就给出了正确的搜索词</figcaption></figure><p id="dd08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次点击把我带到…你猜对了——stack overflow。</p><p id="2bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我去搜索的线程的链接:目录中的<a class="ae ky" href="https://stackoverflow.com/questions/10377998/how-can-i-iterate-over-files-in-a-given-directory" rel="noopener ugc nofollow" target="_blank">文件</a></p><p id="f66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">投票最高的答案在他/她的代码中包含以下内容:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="a3e2" class="me mf it ob b gy of og l oh oi">import os<br/>for filename in os.listdir(directory):</span></pre><p id="33ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个回答中我能读到的是<code class="fe or os ot ob b">os</code>会帮助我们完成任务。方法<code class="fe or os ot ob b">listdir()</code>用于列出目录(文件夹)中的内容。但是我并不喜欢仅仅获取和使用这些信息。既然我知道操作系统可以帮助我们，我想更多地了解<code class="fe or os ot ob b">os</code>本身。我通常会做以下事情:</p><ol class=""><li id="9d5f" class="ou ov it lb b lc ld lf lg li ow lm ox lq oy lu oz pa pb pc bi translated">去python.org看文档</li><li id="5e66" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu oz pa pb pc bi translated">使用<code class="fe or os ot ob b">os</code>上的终端阅读文档</li><li id="dd65" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu oz pa pb pc bi translated">去geeks for geeks(<a class="ae ky" href="http://www.geeksforgeeks.org" rel="noopener ugc nofollow" target="_blank">www.geeksforgeeks.org</a>)找例子</li></ol><p id="6e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作系统文档位于此处:<a class="ae ky" href="https://docs.python.org/3/library/os.html?highlight=os#module-os" rel="noopener ugc nofollow" target="_blank">操作系统文档</a></p><p id="08bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用终端简要查看文档:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/7f9f59e3ecd8017f927819fd4c265511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8G3axdk8y7ZDXsGxY7bLg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">寻找关于“操作系统”的文档</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/deb81d6336531525154f7f5ea9536783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2giuSnEr6nkQGkV5mjyizw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">享受阅读文档的乐趣</figcaption></figure><p id="0c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在geeks上为极客们阅读一些好例子:<a class="ae ky" href="https://www.geeksforgeeks.org/os-module-python-examples/" rel="noopener ugc nofollow" target="_blank">操作系统例子</a></p><p id="5439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我已经研究了如何攻击伪代码中的两个要点:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ceb0" class="me mf it ob b gy of og l oh oi"># go to folder<br/># loop through files</span></pre><h2 id="8b32" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">循环浏览文件</h2><p id="6d0c" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">我在我的Mac上创建了一些随机文件，所以我有一些数据要处理。我确保我有多种文件类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/eaac28dc986c9864138e0254e16a3627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VN1jsJy8svDXYkbZwL6mvg.png"/></div></div></figure><p id="1d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="3a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是输出，正如我所料。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/4c841e5f399d99d9b4875f3878828e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpV5m7ANtle9qA7NMqZ95A.png"/></div></div></figure><h2 id="36ae" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">调整可读性</h2><p id="69ce" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">我不得不承认我是一个打印的家伙…我知道我不应该依靠打印来解决代码问题，但是我喜欢它给我即时反馈的方式，我可以完全控制它。有了python3的格式，设置起来真是一件乐事。</p><p id="b96f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是重构后的代码，这样我就可以看到发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="bd39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我更容易阅读。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/28b80f48bc335039cb375dacbf970370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YjUv9S6gjM_qSdXWG94VFQ.png"/></div></div></figure><p id="40ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我的程序，我将删除<code class="fe or os ot ob b">.DS_Store</code>文件。根据您的操作系统和设置，您可能会遇到一组不同的规则。</p><h2 id="6e3a" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">Python关键词？</h2><p id="8613" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">现在我正在处理文件，我开始想我是否必须小心，这样我就不会在代码中错误地使用python关键字。比如说<code class="fe or os ot ob b">file</code>是不是一个python关键字？</p><p id="edea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想知道是否使用了python的任何关键字作为变量名，您可以运行以下代码(或者阅读在线文档):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/7ec7c07777e205515a5c7f6768a12828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsWyzTsmWfTvjxOpHGYHxA.png"/></div></div></figure><h2 id="b061" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">创建文件夹</h2><p id="794a" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">我们拿到文件了。现在，我们希望基于文件类型创建文件夹。</p><p id="0f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe or os ot ob b">os</code>有一个模块叫<code class="fe or os ot ob b">path</code>,<code class="fe or os ot ob b">os.path</code>有一个模块叫<code class="fe or os ot ob b">os.path.splitext()</code>。我最近在发表了另一篇文章后了解到这一点，文章中一些程序员同事建议使用<code class="fe or os ot ob b">splitext()</code>。我想在真实案例中尝试使用它。</p><p id="2894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用它来创建我们想要的子文件夹。我必须弄清楚如何不创建一个已经存在的文件夹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="1b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码抛出一个语法错误:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="a751" class="me mf it ob b gy of og l oh oi">return ([file for file in os.listdir(directory)] if file != '.DS_Store')</span><span id="fd8f" class="me mf it ob b gy oj og l oh oi">^</span><span id="3788" class="me mf it ob b gy oj og l oh oi">SyntaxError: invalid syntax</span></pre><p id="9d96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个愚蠢的语法错误，应该很容易修复。我似乎放错了我的<code class="fe or os ot ob b">)</code>，在我想排除<code class="fe or os ot ob b">‘.DS_Store’</code>的时候把<code class="fe or os ot ob b">]</code>落在了列表理解的后面。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="a197" class="me mf it ob b gy of og l oh oi">return ([file for file in os.listdir(directory) if file != '.DS_Store'])</span></pre><p id="8f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复它会将我带到下一个错误。这个错误更有趣。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="8287" class="me mf it ob b gy of og l oh oi">os.mkdir(get_ext)</span><span id="0816" class="me mf it ob b gy oj og l oh oi">TypeError: mkdir: path should be string, bytes or os.PathLike, not tuple</span></pre><p id="7d82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解错误，我将它分解并隔离问题。由于错误与<code class="fe or os ot ob b">mkdir</code>有关，我需要看看我正在尝试做什么。这个错误还告诉我它想要一个字符串，而不是一个元组。那么，是什么创造了元组呢？</p><p id="bb8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前写的函数<code class="fe or os ot ob b">def strip_file_ext(file_input)</code>，就是做这个的。如果我仔细观察我的输出，我可以看到这样一行:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="e2d0" class="me mf it ob b gy of og l oh oi">found file extension: ('project_registration', '.mov')</span></pre><p id="079a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看，这就是为什么我喜欢在实际编码时在代码中使用print。❤️</p><p id="e2b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们分解它时，我们可以看到它打印的行。我们有一个返回元组的函数。首先，它返回<code class="fe or os ot ob b">filename</code>，然后返回<code class="fe or os ot ob b">extension</code>。因为我们想要创建扩展名为的文件夹——在本例中是<code class="fe or os ot ob b">mov</code>,所以我们需要找到一种方法来做到这一点。如果我们打印get_ext[1],我们得到:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="b6ef" class="me mf it ob b gy of og l oh oi">successfully created .mov folder</span></pre><p id="b594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不想在我的文件夹名中出现点号，所以我开始想办法解决这个问题，我想这是其他人在我之前做过的事情，所以我又开始了搜索。我的发现是什么？大多数答案只涉及如何完全移动扩展。我们已经知道了。</p><ul class=""><li id="51de" class="ou ov it lb b lc ld lf lg li ow lm ox lq oy lu pn pa pb pc bi translated">我可以在<code class="fe or os ot ob b">get_ext[1]</code>上使用<code class="fe or os ot ob b">replace()</code></li><li id="374e" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu pn pa pb pc bi translated">我可以用<code class="fe or os ot ob b">strip()</code>去掉<code class="fe or os ot ob b">.</code></li><li id="62ee" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu pn pa pb pc bi translated">我可以调查一下<code class="fe or os ot ob b">pathlib</code></li></ul><p id="e69c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我处于必须决定如何前进的位置时，我喜欢尝试一下。以下是对他们所有人的测试:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="5a21" class="me mf it ob b gy of og l oh oi">import os<br/>from pathlib import Path</span><span id="c50a" class="me mf it ob b gy oj og l oh oi">file_string = 'somefile.txt'<br/>print (os.path.splitext(file_string)[1].replace('.' , ''))</span><span id="4788" class="me mf it ob b gy oj og l oh oi">print (os.path.splitext(file_string)[1].strip('.'))</span><span id="619b" class="me mf it ob b gy oj og l oh oi">check = Path(file_string)<br/>print(check.suffix.strip('.'))</span></pre><p id="7f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它输出我们想要的东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/60065d9afae2a6e8e20e509b08e3181c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q26efuzLXXk7k9pIN_R3fQ.png"/></div></div></figure><p id="77bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不能决定选哪个，你可以用数学来支持它。使用计时器检查哪个代码运行时间更长。也许这能帮你做决定:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/0061ba4b7146b480ff41c47b2a3f8eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Py_dusTL9W6zowoTTrKyAA.png"/></div></div></figure><p id="c2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望阅读这篇文章的人会指出一个来源，在那里我可以读到如何获得不带点的扩展名。这些至少是你可以做到的一些不同的方法。由于<code class="fe or os ot ob b">pathlib</code>对我来说是新的，我想试着用它继续前进。我对os给我的东西很满意，但是我决定尝试一下这个后缀，以便更好地了解它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="93e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码根据文件扩展名为我们创建文件夹。它无法检查文件夹是否存在，所以是时候做更多的挖掘了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/cbc31a09013fef47068b91eff022fce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77rt6KjhPpgOpgmpgQzNAA.png"/></div></div></figure><p id="ea9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要研究的代码是这样的:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="7f17" class="me mf it ob b gy of og l oh oi">if get_ext not in check_existing_folders:<br/>    os.mkdir(check_folder + get_ext)<br/>    print (f'successfully created {get_ext} folder')</span></pre><p id="c30a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想做的第一件事是检查类型。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="7691" class="me mf it ob b gy of og l oh oi">print (type(get_ext))<br/>print (type(check_existing_folders))</span><span id="d57c" class="me mf it ob b gy oj og l oh oi">&lt;class 'str'&gt;<br/>&lt;class 'generator'&gt;</span></pre><p id="e2cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那个get_ext是一个字符串，我在创建它的时候就非常确定。os.walk是一个发电机。首先想到的是转换成列表。如果我对照列表中的字符串检查单个字符串，我可能会成功。你可能不能直接把它转换成一个列表。让我们试一试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="8676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行两次，我们可以检查它是否工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/55347d292bdae05faecf36a01a25ccf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-j-xetyk5CTWDYLwHDDQzQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/636aa45e4376b5f0ede151e0677cac71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBrWEL8CFA-RmRa7Uy9r8Q.png"/></div></div></figure><p id="9288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到它如何列出文件夹:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="38d7" class="me mf it ob b gy of og l oh oi">('/Users/martinandersson/local_projects/clean_up/txt', [], [])('/Users/martinandersson/local_projects/clean_up/pdf', [], [])('/Users/martinandersson/local_projects/clean_up/png', [], [])('/Users/martinandersson/local_projects/clean_up/mov', [], [])</span></pre><p id="b4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在做了一些研究之后，我了解到os.walk()返回一个元组。极客对极客的解释很好:</p><p id="2933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/os-walk-python/" rel="noopener ugc nofollow" target="_blank"> os.walk()解释</a></p><p id="b06b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我需要更深入地挖掘新的东西时，我会创建一个新文档并专注于那一件事。下面是我写的一些测试代码，看看是否有办法在创建文件夹之前完成文件夹检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="4920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用list comprehension来获取元组的第0个元素，并创建一个新的列表来检查目录。</p><p id="41fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个敏锐的观察者已经开始认为我会遇到巴布亚新几内亚和巴布亚新几内亚等问题。所以我会用。lower()在进行检查之前将png转换为PNG。</p><p id="dbc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是更新后的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="f007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码已更新，但仍然出现同样的错误。我需要检查我的if语句是否有效。我还需要检查循环本身，因为它在mp4上丢失了。这里似乎发生了几个问题。调试时间到了。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="6865" class="me mf it ob b gy of og l oh oi">FileExistsError: [Errno 17] File exists: '/Users/martinandersson/local_projects/clean_up/png'</span></pre><h2 id="a226" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">将所有事情分解到最低限度</h2><p id="f3a3" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">经历了很多挫折后，我需要打破它。显然有些事情我没有完全理解。我把<code class="fe or os ot ob b">main()</code>减到绝对最小。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="6e66" class="me mf it ob b gy of og l oh oi">def main():<br/>    check_folder = '/Users/martinandersson/local_projects/clean_up/'<br/>    list_folders = list(os.walk(check_folder))<br/>    for folders in list_folders:<br/>        print (folders)</span></pre><p id="1a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出给了我一个想法。<code class="fe or os ot ob b">os.walk()</code>列出给定路径中的所有目录及其子目录。我已经在前面的文档中读到过这一点。我只是选择了错误的方法。目录列表就在那里！只要我们从中吸取教训，犯傻也没关系😉</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/3293743f5ed31b4a63062be752c1c363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iol5EWu4U-RbrKFB-rnE9Q.png"/></div></div></figure><p id="294b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行清楚地显示了我可能要寻找的是元组的第二个索引。那里的列表包含所有的目录。我错过了这么简单的事情吗？</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="36ce" class="me mf it ob b gy of og l oh oi">def main():<br/>    check_folder = '/Users/martinandersson/local_projects/clean_up/'<br/>    list_folders = list(os.walk(check_folder))<br/>    <strong class="ob iu">list_folders = list_folders[0][1]</strong><br/>    for folders in list_folders:<br/>        print (folders)</span></pre><p id="e6c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也意味着有一个非常简单的方法来访问当前文件夹中的文件。如果我将代码改写成这样，我可以遍历文件并尝试再次创建文件夹:</p><h2 id="9a4f" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">重构重新开始</h2><p id="19f4" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">此时，稍微重构一下代码是有意义的。有了这个新发现，一些部分变得没用了，而另一些部分变得干净多了。我做了以下工作:</p><ul class=""><li id="0513" class="ou ov it lb b lc ld lf lg li ow lm ox lq oy lu pn pa pb pc bi translated">杀了<code class="fe or os ot ob b">function list_files()</code></li><li id="04c4" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu pn pa pb pc bi translated">创建了一个新功能，可以检查文件夹/目录和文件，<code class="fe or os ot ob b">list_content(path, return_type)</code></li><li id="efd5" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu pn pa pb pc bi translated">扒下<code class="fe or os ot ob b">main()</code>重新开始。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="d9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到起点肯定感觉有很多工作要做，但是这里发生了一些重要的事情。</p><ol class=""><li id="f13c" class="ou ov it lb b lc ld lf lg li ow lm ox lq oy lu oz pa pb pc bi translated">我现在明白os.walk()的用法了</li><li id="b016" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu oz pa pb pc bi translated">我对代码进行了重构，使之成为我认为最有利于程序通用性的部分</li><li id="be6b" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu oz pa pb pc bi translated">有了重构，我应该能够在没有任何严重错误的情况下编写剩下的部分。</li></ol><p id="1ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候回到创建文件夹了。我将再次查看文件的扩展名。如果没有该扩展名的文件夹，将会创建该文件夹。这段代码将通过一些打印来告诉我们结果，从而为我们做检查。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ff93" class="me mf it ob b gy of og l oh oi">if get_ext not in list_content(check_folder, 'directory'):<br/>    print (f'no such folder. Time to create it.')<br/>else:<br/>    print (f'folder exists. Skipping...')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/de21f788bbd0785d39663f3399a549d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHbeKXu8yDzBoG4T6LUesw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/301ff9e7ade3934ac72503c71b2764ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YX9o7H-WslIiPSHFNFybxg.png"/></div></div></figure><p id="b1a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码有效。现在是时候确保我们可以创建目录了。这不需要太多。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="d8ea" class="me mf it ob b gy of og l oh oi">if get_ext not in list_content(check_folder, 'directory'):<br/>    os.mkdir(check_folder + get_ext)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/28610e992b8a51fd1f7384aae4307fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qS1bvcma3x_0ajkp4UKjRA.png"/></div></div></figure><h2 id="8236" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">移动文件</h2><p id="9b39" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">我之前知道我可以使用<code class="fe or os ot ob b">shutil</code>来移动文件。快速的谷歌搜索也会把我们带到几个有这种建议的网站。如果你想了解更多关于<code class="fe or os ot ob b">shutil</code>的内容，可以查看geeks和python文档。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ad7b" class="me mf it ob b gy of og l oh oi">shutil.move((check_folder + file) , (check_folder + get_ext))</span></pre><p id="bffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行就是移动文件的全部。我把它放在if/else语句之后，这样我们可以确保所有的文件夹问题都得到解决。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/fb9322b02141188af2474326e3096926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWWs6AD29SPcu34UcZBHVg.png"/></div></div></figure><h1 id="d8a9" class="my mf it bd mg mz na nb mj nc nd ne mm jz nf ka mp kc ng kd ms kf nh kg mv ni bi translated">间隔运行</h1><p id="55ef" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">现在我们已经有了功能，我们需要弄清楚如何让它每天运行。谷歌搜索应该能让我们找到正确的方向。这里有一些文档:</p><p id="2537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/22715086/scheduling-python-script-to-run-every-hour-accurately" rel="noopener ugc nofollow" target="_blank"> StackOverflow —调度器</a></p><p id="3249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/agronholm/apscheduler/blob/master/examples/schedulers/blocking.py" rel="noopener ugc nofollow" target="_blank">调度程序—阻塞</a></p><p id="ad0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/29338066/mac-osx-execute-a-python-script-at-startup" rel="noopener ugc nofollow" target="_blank"> StackOverflow —启动时执行脚本</a></p><p id="22d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让调度程序运行非常简单。我将<code class="fe or os ot ob b">main()</code>改写为<code class="fe or os ot ob b">execute_folder_cleanup()</code>，并添加了这段代码块，以使动作每20秒运行一次</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="f0de" class="me mf it ob b gy of og l oh oi">if __name__ == '__main__':<br/>    scheduler = BlockingScheduler()</span><span id="0326" class="me mf it ob b gy oj og l oh oi">    scheduler.add_job(execute_folder_cleanup, 'interval', seconds=20)<br/>    scheduler.start()<br/>    print (f'scheduler started. Press Ctrl+C to cancel')</span></pre><p id="d392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我将python文件保存为main.py。这样，每当文件运行时，它都会执行调度。如果我们现在执行main.py，它将开始清理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="ceb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">互动真的很有趣:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/caf041ddda185ef832826f4d4481dc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*f590Q1TfqNMMZn5BCt6xAw.gif"/></div></div></figure><h1 id="d720" class="my mf it bd mg mz na nb mj nc nd ne mm jz nf ka mp kc ng kd ms kf nh kg mv ni bi translated">重构代码</h1><p id="e551" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">程序运行，大家都很开心。我想对代码做的最后一步是重构它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><h1 id="df92" class="my mf it bd mg mz na nb mj nc nd ne mm jz nf ka mp kc ng kd ms kf nh kg mv ni bi translated">启动时运行</h1><p id="3593" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">这个程序完全符合我们的初衷，最后一步是让它在我登录时运行。我不太喜欢这个函数，因为为了更好的控制，我宁愿自己执行清理脚本，但这可能是一个很好的教训。</p><p id="f4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我们从健康的研究开始。我想先试试shell脚本版本。</p><p id="e4be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这个sh文件添加到登录项应该可以完成这个任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="c6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"> →系统偏好设置→用户与群组→用户→登录项目</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ca"><img src="../Images/2b3ff7b949e6a8e327fa5046437a7b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXLi2e7pdCRL5XYl11jVsg.png"/></div></div></figure><p id="ec93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在一些文件的重新安排和重新启动。手指交叉…</p><p id="4a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，交叉手指不起作用，所以我们需要做更多的挖掘。当我重新登录时，什么也没有发生，所以它看起来根本没有运行。在StackOverflow和其他网站、博客等等上寻找了很久之后，我尝试了以下方法:</p><ul class=""><li id="bd65" class="ou ov it lb b lc ld lf lg li ow lm ox lq oy lu pn pa pb pc bi translated">chmod +x文件，以确保它有适当的权限。</li><li id="231a" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu pn pa pb pc bi translated">进入<code class="fe or os ot ob b">get info</code>设置默认程序启动到终端</li><li id="0ee2" class="ou ov it lb b lc pd lf pe li pf lm pg lq ph lu pn pa pb pc bi translated">授予终端访问所有文件和文件夹的权限</li></ul><div class="kj kk kl km gt ab cb"><figure class="ps kn pt pu pv pw px paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/95f9f6e99bd1641ae1887b57149497cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*YzhGyQnXG0y31gCRZZ-Biw.png"/></div></figure><figure class="ps kn py pu pv pw px paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3b7026bdf3dbf2175dcfbb766c0b20e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*Og1oxAT6jlP3mEjQHzKveg.png"/></div></figure></div><p id="7847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行了，但是没有用python3运行。在sh文件中用python3替换python也不行。</p><p id="bfce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过数小时的研究，我尝试创建一个. sh文件来执行我的python脚本，我尝试使用。plist，让Mac OS用Launch Deamon启动它，我试了一下Automator。</p><p id="a9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定再试一次，把cleanup.sh脚本从我的登录项中删除，重新开始使用Automator。</p><p id="3346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Mac上，您可以前往Automator并创建新的应用程序。然后使用实用程序→运行Shell脚本。</p><p id="a3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我试着运行与之前shell脚本设置相同的命令，但是它不能运行python，当我将路径改为实际的python路径时，它找不到<code class="fe or os ot ob b">pathlib</code>或<code class="fe or os ot ob b">apscheduler</code>。</p><p id="0d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我运行过一次:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/c523f1c75a512c356bf59810355c33c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3G4_kT6w8hY6OkoVOTYCA.png"/></div></div></figure><p id="4965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得脚本运行，我可以恢复到这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/4fc7a5b13a75d059661ccd8dfe4665f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3bp-90Ap6lG_3CtF9XEMQ.png"/></div></div></figure><p id="63b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难题的最后一部分是将这个脚本添加到登录项中，就像我们之前尝试的那样。</p><p id="87d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存脚本并添加它，以便在登录时启动。</p><p id="e4f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置工作，但我不舒服的方式强行通过。我的下一步将是获得对我的环境的完全控制，并找出为什么<code class="fe or os ot ob b">pathlib</code>和<code class="fe or os ot ob b">abscheduler</code>没有跳出盒子。</p><h1 id="b684" class="my mf it bd mg mz na nb mj nc nd ne mm jz nf ka mp kc ng kd ms kf nh kg mv ni bi translated">最后</h1><p id="aff0" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">从想法到最终产品可能是一项艰巨的任务。不管你有多有条理，都会有一些混乱。有时候你知道自己想做什么，但不知道如何去做。这是研究阶段开始的时候，也是学习的最佳阶段之一。我们已经完成了这个演练，但是可以自由地做进一步的实验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/80a068a786359fde2d619c57c958f7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-W_R_7El4AZr1UTHbHGkug.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/photo-of-woman-standing-on-sunflower-field-3756168/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@olly?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Andrea Piacquadio </a>拍摄</figcaption></figure><p id="fc38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我根据日期跳过了子文件夹。也许你想知道如何做到这一点。基于文件的所有者呢？如果你在办公室，也许你想创建<code class="fe or os ot ob b">Bob-</code>或<code class="fe or os ot ob b">Susan</code>用户文件夹(因为在美国，所有的办公室职员似乎都叫鲍勃和苏珊……)</p><h2 id="d499" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">如何？</h2><p id="84c7" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">做事情有很多不同的方法。仅仅因为你知道做某事的一种方法并不意味着没有其他选择。确保你通读了你能找到的所有不同方法的例子，并对如何进行下一步下了决心。你也可以依靠专家，在StackOverflow或脸书的群组上发布你的问题。</p><h2 id="8b38" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">计划免责声明</h2><p id="7bfb" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">这个项目远未完成，也不是它能达到的最好水平，但是本文的重点并不是最终结果。是关于去那里的路。你可能也注意到了这个程序并不是在所有的环境下都能工作。. tar.gz文件呢？也许你想调查一下<code class="fe or os ot ob b">suffixes()</code>等。为此。我希望这篇文章关注的是<em class="ny">思维过程</em>。</p><h2 id="a0d2" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">研究！</h2><p id="6764" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">在这篇对我的项目至关重要的文章中，我没有谈到的一件事是寻找灵感。也许有人在你之前已经这样做了。当我写这篇文章时，我不想检查卡勒·哈尔登的清理脚本，以避免任何偏见。我知道他有一个非常好的分类清理脚本和一个正常工作的自动启动器。你可以在这里查看:</p><p id="b455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=HcZ3gS1Rgcs" rel="noopener ugc nofollow" target="_blank">桌面清洁器，第一部分</a> <br/> <a class="ae ky" href="https://www.youtube.com/watch?v=LfxZMofHs_U" rel="noopener ugc nofollow" target="_blank">桌面清洁器，第二部分</a></p><p id="5c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有订阅卡勒的频道，我建议你看看。一个非常好的，随和的家伙，有一些很好的编程技巧。</p><p id="ebf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我本可以将Automator部分排除在本文之外，因为它相当不成功，但我想保留它，以表明有时您使一些东西工作，但您对它不满意，您应该从头开始。</p><h2 id="eecc" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">最后的想法</h2><p id="ba5f" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">请记住，在我们的python生涯中，我们都处于不同的阶段。我不是职业程序员。拥有解决问题的心态是这一切如此有趣的原因。学习方面是一个额外的收获，坐在那里学习某种课程是跨越临时终点线的一枚不错的奖牌。</p><p id="95a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随时对文章提出反馈。我确信有很多程序员知道更好的方法来处理代码，或者我如何从A到b。</p><p id="893c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的宝贵时间！</p><p id="e9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">-M</p></div></div>    
</body>
</html>