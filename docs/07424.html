<html>
<head>
<title>Can Exactly Once Processing Queue in Real Systems even Exist?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实际系统中是否存在一次性处理队列？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/can-exactly-once-processing-queue-in-real-systems-even-exist-b5eacc77ab83?source=collection_archive---------10-----------------------#2021-02-16">https://levelup.gitconnected.com/can-exactly-once-processing-queue-in-real-systems-even-exist-b5eacc77ab83?source=collection_archive---------10-----------------------#2021-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2aac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您如何设计您的应用程序将决定该属性是否有保证。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1ab6c2d315fc3387e866a2ab39954ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/0*5X-FG6LD5uJqGqnf.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">由作者提供</figcaption></figure><p id="1dde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">FIFO队列是一个消息队列，它保证只传递一次，在接收端没有重复的消息。这个属性听起来很简单，但是在分布式系统环境中很难实现。</p><p id="ca88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如今，很多云技术已经将所有分布式系统组件抽象成我们理解的术语。然而，即使他们可以推销他们的服务或消息队列是FIFO队列，对这些属性仍然有某些限制。你不能仅仅依赖他们的一次性消息传递和FIFO队列服务，也不能像通常那样水平地设计你的系统，因为在那个环境中可能不具备这样的特性。</p><p id="588a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，让我们深入研究FIFO队列的属性，我将带您了解破坏这些属性的三个简单场景，以及如何解决这个问题。在本文的最后，您可以自己确定FIFO队列属性是否可以存在于分布式系统中。</p><h1 id="796b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">现实世界中的FIFO队列</h1><p id="13db" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">FIFO队列是按先进先出顺序排列的消息队列。这意味着您发布到消息队列的任何消息都将按照发布的顺序进行检索。</p><p id="ae89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这听起来很容易理解。我们经常在101课程中学习创建一个队列来回答算法问题。我们意识到顺序在先进先出的方式中很重要。这也意味着—检索时不会有重复的消息。</p><p id="5f49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们可以得出结论，FIFO队列的两个主要属性是——消息以先进先出的方式排序，以及系统中没有重复的消息。</p><h1 id="d374" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">消息排序</h1><p id="cb37" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在单一环境中创建FIFO队列非常简单。单个发布者发布到消息系统，单个订阅者订阅消息系统。发布者会等到订阅者确认消息后，再将消息发送到下一个值。</p><p id="2283" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的场景中，我们有一个发布者线程和一个订阅者线程。我们可以通过某种时间戳或序列id来保证消息是有序的。</p><p id="e622" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在多个并发的发布者和消费者环境中，消息排序很难实现。为什么？让我们看看下面的场景，我们有许多发布者和一个订阅者，以及多个订阅者和一个发布者。</p><p id="f1a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在多发布者环境中，导致消息乱序的一种情况是每个发布者都向消息代理发布消息。代理通常需要确认他们已经收到了来自订阅者的消息，否则消息将会丢失。如果代理服务器关闭，发布者通常会再次向代理发送消息。</p><p id="8a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您有两个发布者——发布者A和发布者b。发布者A在发布者b之前向消息系统发送带有时间戳的消息。当发布者A向代理发送消息时，代理由于某些内部服务器错误而未能确认该消息。几次过后，它又回来了。同时，发布者B将其消息发送给消息代理。消息代理从发布者b接收消息。然后，发布者A以重试的间隔再次向消息代理发送消息。我们有一个订单信息不匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/82ca56cddbd023a554a883bde790420f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RbfKoy_fyLP7u192.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">由作者提供</figcaption></figure><p id="de36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实现消息排序，多个发布者需要相互协调先发送哪条消息。有两种方法可以做到这一点:要么发布者相互协调以附加一个顺序概念，要么消息系统必须确保每个传入系统的顺序概念。无论哪种方式，我们都需要一种集中的方法来获得时间戳概念，以避免时钟漂移和序列id，从而提供一致性。我们可以有一个协调系统，如Zookeeper，来协调消息发送后的订单交付。然而，上述解决方案意味着我们需要将我们的吞吐量限制在一次一个发布者。</p><p id="3357" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再来看接收端。如果我们有多个订阅者订阅一个队列，可能会出现消息乱序的情况。如果您有两个订户—订户A和订户b，在订户A确认它从队列中轮询的消息后，实例死亡。同时，订户B从队列中接收下一个即将到来的消息，接受并处理它。一旦订户A备份，它就处理该消息。在这种情况下，系统违反了字母排序属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ms"><img src="../Images/fc7ca6bb908f064b53b400de3feb9037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EyO-zi87arQySwD3.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">由作者提供</figcaption></figure><p id="2449" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以使用与发布者场景相同的解决方案，其中一个订阅者将等待前一个订阅者完成处理，然后轮询下一条消息。在这种情况下，我们还将吞吐量限制为一次一个订户。</p><p id="e3d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上面的两个例子中，我们知道创建消息排序的解决方案是限制一次一个发布者和订阅者的吞吐量。假设publisher的多个线程异步发布到同一个消息系统。那样的话，秩序就没有意义了。根据发布者的计划时间，消息显示在队列中。在订户端，我们需要一次处理一条消息，以避免任何混乱。</p><h1 id="fd0f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">恰好一次消息</h1><p id="ac7c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">为了得到一个恰好一次的消息，我们不希望在消息系统中复制数据。让我们从同步环境的角度出发，深入研究多个发布者和订阅者场景。</p><p id="ad75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同步环境中很少会出现重复消息。发布者一次可以发布一个数据；一旦收到前一个，就发布下一个，以确保代理中没有重复的数据。在用户端，我们一次接收一个数据。因此，不会出现信息被多个订户接收的任何竞争情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/f8f177dd901c604601592164cc9b863a.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/0*Cx1tnS_K48U5_RRQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">由作者提供</figcaption></figure><p id="6008" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在多发布者环境中，我们可以看到重复数据是如何出现在消息系统中的。假设多个发布者发布到消息队列。如果消息代理由于某个发布者不可用而未能向其发送确认，那么他们将多次重试系统以避免消息丢失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/abff1f32dd33542d83632dae000e14e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*orXDda_LBczOWCm2.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">由作者提供</figcaption></figure><p id="e675" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决这个问题的一个方法是创建一个相关标识符。相关标识符将是标识消息上的幂等键的id。因此，如果消息系统接收到相同的相关标识符，它知道它之前已经被接收过。例如，亚马逊SQS将FIFO队列中的<code class="fe mv mw mx my b">deduplicationId</code>用作关联id。但是，它有5分钟的过期时间。如果发布者在5分钟后发送第二条消息，消息代理不能保证它是否拒绝重复的消息。</p><p id="ef5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，在多个用户中几乎不可能实现一次交付。然而，即使您可以在传输层上确保一次，您可能也不希望这样。如果消息代理在订阅者收到消息后立即删除它，那么即使在订阅者处理数据之前，仍然有崩溃的可能。在这种情况下，您希望消息系统再次传递消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mz"><img src="../Images/0a3cd3d096f82d2000fde62c05cc6f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F2Jzuhig8oa5E72L.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">由作者提供</figcaption></figure><p id="a998" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接收复制消息恰好一次处理是可能的。让我们来看一个场景:订户A收到了来自代理的消息。就在订户A将要删除消息之前，订户B轮询代理的消息。因此，订户B将具有与订户a相同的消息。对此的一个解决方案是在接收器端创建持久存储。订户可以在每次轮询期间将传入消息写入持久存储。一旦成功写入存储，它将从消息代理中删除队列。持久存储将防止重复值。同时，将有另一个消息处理异步运行的后台线程来处理这些消息。这个概念类似于各种数据库系统如何使用预写日志来存储提交。</p><h1 id="7433" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">关闭</h1><p id="cf92" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">单一环境中的FIFO队列很容易理解。然而，在分布式环境中，系统可以通过让单个发布者一次发布一个消息来实现FIFO队列，以提供排序并创建防止消息复制的系统。</p><p id="0c1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你设计的系统可以处理上述两种情况，那么你的FIFO队列可以存在于分布式系统中。如果您不能在队列中提供这两个属性，您的系统就不能进行一次性处理。</p><p id="7866" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，你告诉我，在整个系统中能确切地——一次性处理事件存在吗？</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="e83a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">感谢阅读！如果你喜欢这篇文章，你可以关注我，也可以关注我的</strong> <a class="ae nh" href="https://medium.com/@edwardgunawan880" rel="noopener"> <strong class="kw iu">中型</strong> </a> <strong class="kw iu">更多类似的文章。</strong></p><p id="66c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ni">最初发表于</em><a class="ae nh" href="https://edward-huang.com/distributed-system/architecture/cloud/2021/02/15/can-exactly-once-processing-queue-in-real-systems-even-exist/" rel="noopener ugc nofollow" target="_blank"><em class="ni">https://edward-huang.com</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>