<html>
<head>
<title>Microservices in Go with gRPC, API Gateway, and Authentication — Part 1/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用gRPC、API网关和身份认证的微服务—第1/2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/microservices-with-go-grpc-api-gateway-and-authentication-part-1-2-393ad9fc9d30?source=collection_archive---------0-----------------------#2022-03-29">https://levelup.gitconnected.com/microservices-with-go-grpc-api-gateway-and-authentication-part-1-2-393ad9fc9d30?source=collection_archive---------0-----------------------#2022-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ca7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Go中创建3个微服务和1个API网关(2022年)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a27f41f61bb3fab435bc15ea973aba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KxQoysHwwn3bKGg-uGfCQ.png"/></div></div></figure><p id="2ac5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将开发3个微服务和1个API网关来处理传入的HTTP请求。gRPC会将HTTP请求转发给这些微服务。此外，我们处理JWT认证。</p><p id="2cec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将分为两部分。点击<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/microservices-in-go-with-grpc-api-gateway-and-authentication-ba36cc32d167">此处</a>进入第二部分。</p><h1 id="fc9f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">我们要建造什么？</h1><p id="797e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们打算建立一个小型的电子商务系统。我们开发的项目和我在我的<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/nestjs-microservices-with-grpc-api-gateway-and-authentication-part-1-2-650009c03686">微服务和TypeScript </a>系列文章中开发的项目一样。唯一的区别是，我们将在Go中对所有内容进行编码，因此，可能会有一些自然的差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/d1e58f0d3e4defd0bc5a2b915b4a6148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27q-rUMfeOFEi9KrFndjNg.png"/></div></div></figure><h1 id="1b62" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">应用基础设施</h1><p id="cb72" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">本系列文章由两部分组成:</p><ol class=""><li id="f827" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated"><strong class="kw iu"> API网关:</strong>处理传入的HTTP请求</li><li id="8f76" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><strong class="kw iu">认证服务:</strong>提供<strong class="kw iu">注册</strong>、<strong class="kw iu">登录</strong>等功能，并由JWT生成<strong class="kw iu">令牌</strong></li><li id="f4c0" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><strong class="kw iu">产品服务:</strong>提供<strong class="kw iu">添加产品</strong>、<strong class="kw iu">减少库存</strong>、<strong class="kw iu">查找产品</strong>等功能</li><li id="3e4f" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><strong class="kw iu">订单服务:</strong>我们在这个微服务中提供的唯一特性是<strong class="kw iu">创建订单</strong></li></ol><p id="0602" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个微服务将是一个独立的项目。</p><p id="afa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这个系列文章已经花了很多阅读时间，我想保持这些微服务简单。所以我们不会处理Docker、截止日期或超时。</p><p id="470f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一部分的最后，我们可以使用1个API网关和1个微服务来创建一个新用户。但是需要对Go和gRPC有一个比较好的理解。</p><p id="b7fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们开始吧！</p><h1 id="bec1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建数据库</h1><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2baf" class="ni ls it ne b gy nj nk l nl nm">$ psql postgres<br/>$ CREATE DATABASE auth_svc;<br/>$ CREATE DATABASE order_svc;<br/>$ CREATE DATABASE product_svc;<br/>$ \l<br/>$ \q</span></pre><p id="1923" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是<code class="fe nn no np ne b">\l</code>应该有的样子。如您所见，我们已经创建了3个数据库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/44c74e59d0ce424ebf93c0054f835c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvCrzoseIYJUQb7R-7IIKw.png"/></div></div></figure><h1 id="2e8c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建项目</h1><p id="0830" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">首先，我们需要创建我们的项目。我建议创建一个工作空间目录来存储您的Go项目。入口目录由您决定。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2452" class="ni ls it ne b gy nj nk l nl nm">$ mkdir go-grpc-project<br/>$ cd go-grpc-project<br/>$ mkdir go-grpc-api-gateway go-grpc-auth-svc go-grpc-order-svc go-grpc-product-svc</span></pre><p id="0be0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将从API网关开始。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b2b9" class="ni ls it ne b gy nj nk l nl nm">$ cd go-grpc-api-gateway</span></pre><h1 id="ef28" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">API网关</h1><p id="8772" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">github:<a class="ae lq" href="https://github.com/hellokvn/go-grpc-api-gateway" rel="noopener ugc nofollow" target="_blank">https://github.com/hellokvn/go-grpc-api-gateway</a></p><p id="a2c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从API网关开始可能会很无聊，但实际上，这是有意义的，因为我们可以在完成后立即结合API网关测试每个微服务。</p><h2 id="08c7" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">初始化项目</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3c2f" class="ni ls it ne b gy nj nk l nl nm">$ go mod init github.com/YOUR_USERNAME/go-grpc-api-gateway</span></pre><h2 id="c09c" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">安装模块</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9f82" class="ni ls it ne b gy nj nk l nl nm">$ go get github.com/gin-gonic/gin<br/>$ go get github.com/spf13/viper<br/>$ go get google.golang.org/grpc</span></pre><h2 id="9b68" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">项目结构</h2><p id="0c5a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们需要建立这个项目。我更喜欢一开始就创建我们需要的所有文件夹和文件。所以要小心，那是很多的。</p><p id="88d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">文件夹</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0877" class="ni ls it ne b gy nj nk l nl nm">$ mkdir -p cmd pkg/config/envs pkg/auth/pb pkg/auth/routes pkg/order/pb pkg/order/routes pkg/product/pb pkg/product/routes</span></pre><p id="bd2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">文件</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="291f" class="ni ls it ne b gy nj nk l nl nm">$ touch Makefile cmd/main.go pkg/config/envs/dev.env pkg/config/config.go</span><span id="bdf3" class="ni ls it ne b gy oc nk l nl nm">$ touch pkg/auth/pb/auth.proto pkg/auth/routes/login.go pkg/auth/routes/register.go pkg/auth/client.go pkg/auth/middleware.go pkg/auth/routes.go</span><span id="a4d3" class="ni ls it ne b gy oc nk l nl nm">$ touch pkg/product/pb/product.proto pkg/product/routes/create_product.go pkg/product/routes/find_one.go pkg/product/client.go pkg/product/routes.go</span><span id="f5e8" class="ni ls it ne b gy oc nk l nl nm">$ touch pkg/order/pb/order.proto pkg/order/routes/create_order.go pkg/order/client.go pkg/product/routes.go</span></pre><p id="4cf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">项目结构</strong>现在应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6763b9e220251a31146b816b5d10e649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvac8T843IzH5SsL151NIg.png"/></div></div></figure><p id="8161" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们编码。</p><h1 id="48e7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Protobuf文件</h1><p id="1806" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">首先，我们需要添加所有三个Protobuf文件，每个微服务一个。</p><h2 id="0829" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">授权微服务的原型</h2><p id="b8c3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们要构建的第一个protobuf文件是用于认证微服务的。如您所见，我们将定义三个端点</p><ul class=""><li id="03ec" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp oe mv mw mx bi translated">注册</li><li id="229e" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp oe mv mw mx bi translated">注册</li><li id="af41" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp oe mv mw mx bi translated">验证(JSON Web令牌)</li></ul><p id="03fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/auth/pb/auth.proto</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="dc65" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">订单微服务的原型</h2><p id="5c9a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">订单微服务将只处理一个任务，即创建订单。为此，我们需要产品ID(我们稍后会得到)、数量和用户ID。</p><p id="f7fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/order/pb/order.proto</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="e516" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">产品微服务的原型</h2><p id="2920" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">与订单微服务沟通的准备工作已经完成，现在需要为产品微服务做同样的工作。</p><h2 id="5d2f" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">原型文件</h2><p id="ee95" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这一次，我们预计有三个终点</p><ul class=""><li id="47db" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp oe mv mw mx bi translated">创建产品</li><li id="739e" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp oe mv mw mx bi translated">找到一种产品</li><li id="4bd3" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp oe mv mw mx bi translated">减少产品库存</li></ul><p id="39d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们添加代码到<code class="fe nn no np ne b">pkg/product/pb/product.proto</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="d029" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">生成文件</h1><p id="b7cf" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">接下来，我们接触Makefile。这里，我们添加两个命令来执行其他命令。听起来可能很奇怪，但可以这么说，这是一条捷径。</p><p id="886c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们不再每次都键入<code class="fe nn no np ne b">protoc pkg/**…</code>，而是键入<code class="fe nn no np ne b">make proto</code>。</p><p id="ccd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">Makefile</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a296" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以基于刚刚创建的proto文件生成protobuf文件。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2cc3" class="ni ls it ne b gy nj nk l nl nm">$ make proto</span></pre><p id="9f4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">控制台中的输出应该非常简单，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/af5a6610c5a05d396c2315bb28348f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMP419M42FK1jxcfQSXWjg.png"/></div></div></figure><p id="f239" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">protobuf文件将在每个<code class="fe nn no np ne b">.proto</code>文件旁边生成。像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/2083de5d3c643622be238024098a59b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LK-o9Isa0JvPtmNQZFx0Yg.png"/></div></div></figure><h2 id="88eb" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">环境变量</h2><p id="5670" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们需要定义一些环境变量。</p><p id="6ac1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/config/envs/dev.env</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="1fa9" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">配置</h2><p id="c7a0" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这个文件中，我们将数据从环境文件中提取到API网关中。</p><p id="def5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/config/config.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2e11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">API网关的一般配置已经完成。现在我们需要对稍后将要编码的三个微服务的客户端进行编码。</p><h1 id="2e6e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">授权微服务的端点</h1><p id="c960" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，我们将对尚不存在的Auth微服务的实现进行编码。但是因为我们在这里定义了protobuf文件，所以我们知道每个微服务的请求和响应是什么样子的。</p><h2 id="7619" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">注册路线</h2><p id="edbe" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果用户想要注册一个帐户，他将向我们的API网关发送一个请求，在这里，我们得到这个请求，并将其转发给认证微服务。这个微服务会返回一个响应。同样，我们还没有对认证微服务进行编码，但是我们知道这个微服务对数据的期望以及它将返回什么作为响应。</p><p id="dfd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生的事情是，我们创建一个名为<code class="fe nn no np ne b">RegisterRequestBody</code>的结构，在这里我们绑定HTTP请求体，然后我们将它绑定到将要发出的gRPC请求的请求体。</p><p id="86ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/auth/routes/register.go</code>添加代码</p><blockquote class="oj ok ol"><p id="48a0" class="ku kv om kw b kx ky ju kz la lb jx lc on le lf lg oo li lj lk op lm ln lo lp im bi translated"><strong class="kw iu"> <em class="it">小心！</em> </strong> <em class="it">在大多数Go文件中，你需要用你的项目名替换项目名。在这里，您可以在第8行看到我的模块名。更换它。</em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="776b" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">登录路线</h2><p id="6e6c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">登录路径与注册路径非常相似。首先，我们绑定HTTP请求主体，然后我们将这个主体发送给认证微服务。</p><p id="2395" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">微服务的响应将是JSON Web Token，这个Token是我们即将编码的其他路由所需要的。</p><p id="60fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们添加代码到<code class="fe nn no np ne b">pkg/auth/routes/login.go</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="53a2" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">认证微服务客户端</h2><p id="e369" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为了与认证微服务通信，我们需要拨打它。请记住，我们将这个微服务的URL保存在我们的环境文件中，我们用<code class="fe nn no np ne b">config.go</code>文件对它进行了初始化。现在，我们可以访问这些数据。</p><p id="7db8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们添加代码到<code class="fe nn no np ne b">pkg/auth/client.go</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="7df3" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">认证中间件</h2><p id="da7f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们需要保护产品和订购微服务免受未经授权的请求。这意味着，在某些路线上，我们只允许登录用户访问我们受保护的微服务。</p><p id="e23a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们在这里做的比看起来要简单。我们从HTTP请求头中获取JSON Web令牌，然后，我们通过认证微服务<strong class="kw iu">验证</strong>这个令牌。记住，我们之前在<code class="fe nn no np ne b">auth.proto</code>文件中定义了一个<code class="fe nn no np ne b">validate</code>端点。</p><p id="e2e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果令牌有效，我们将让请求通过。否则，我们将抛出一个未经授权的HTTP错误。</p><p id="75c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/auth/middleware.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="51bc" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">初始化路线</h2><p id="5362" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为了能够到达我们刚刚编码的路线，我们需要注册它们。</p><p id="47ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/auth/routes.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="4af0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">订单微服务的端点</h1><p id="0366" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">所以现在我们需要为订单微服务做同样的事情。</p><h2 id="8c96" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">创建订单路线</h2><p id="ec32" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这个路由再次类似于我们之前编码的注册和登录路由。获取HTTP请求体，并将此数据转发给订单微服务。</p><p id="61d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/order/routes/create_order.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="767b" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">订单微服务客户端</h2><p id="3c03" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">订单微服务也需要有一个客户端。</p><p id="4773" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/order/client.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="7d06" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">初始化路线</h2><p id="a52e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为了能够到达我们刚刚编码的路线，我们需要注册它们。</p><p id="a7cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/order/routes.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="485e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">产品微服务的端点</h1><h2 id="6c2d" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">创建产品路线</h2><p id="e7c3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这条路线与之前的路线相似。</p><p id="a803" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/product/routes/create_product.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="1204" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">找到一条路线</h2><p id="a925" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这是我们第一次得到一条路线的参数。我们很快就在URL中定义了这个参数。但是在这里，我们得到了这个名为<code class="fe nn no np ne b">id</code>的参数，它将从一个字符串转换为一个整数，因为我们在<code class="fe nn no np ne b">product.proto</code>中将它定义为一个整数。</p><p id="1f76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/product/routes/find_one.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d3cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们没有为我们在<code class="fe nn no np ne b">product.proto</code>中定义的<code class="fe nn no np ne b">DecreaseStock</code>端点创建路由。这是因为这个端点不能从API网关直接到达。我们只能从我们将在本系列文章的第2部分中编写的订单微服务到达这个特定的端点。</p><h2 id="876d" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">产品微服务客户端</h2><p id="0dd5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">同样，我们需要定义与产品微服务通信的客户端。</p><p id="cfc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/product/client.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="3f39" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">初始化路线</h2><p id="61f3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">同样，我们需要注册刚刚创建的路由。</p><p id="4b45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/product/register.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="e92f" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">主文件</h2><p id="0c8a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">最后但同样重要的是，我们需要引导应用程序。记住，我们注册了路由，所以现在我们需要在启动应用程序时调用这些寄存器。</p><p id="7523" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">cmd/main.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="630b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！<strong class="kw iu">API网关完成了！</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="73ab" class="ni ls it ne b gy nj nk l nl nm">$ make server</span></pre><p id="61a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">终端中的输出应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/1d5cdc43cf0b9b37938959b6793ccf35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfOv8dLqMfYCg6_axzkVZA.png"/></div></div></figure><p id="8529" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们继续第一个微服务。</p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><h1 id="58cc" class="lr ls it bd lt lu oy lw lx ly oz ma mb jz pa ka md kc pb kd mf kf pc kg mh mi bi translated">授权微服务(go-grpc-auth-svc)</h1><p id="acdb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">github:<a class="ae lq" href="https://github.com/hellokvn/go-grpc-auth-svc" rel="noopener ugc nofollow" target="_blank">https://github.com/hellokvn/go-grpc-auth-svc</a></p><p id="f649" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将是我们将要编码的三个微服务中的第一个。我知道，这篇文章已经很长很费时间了，所以我尽量保持简单。有些事情，比如我们如何处理环境文件，将是相似的。</p><blockquote class="oj ok ol"><p id="58a9" class="ku kv om kw b kx ky ju kz la lb jx lc on le lf lg oo li lj lk op lm ln lo lp im bi translated"><strong class="kw iu"> <em class="it">请</em> </strong> <em class="it">到</em> <code class="fe nn no np ne b"><em class="it">go-grpc-auth-svc</em></code> <em class="it">你的终端里面去！</em></p></blockquote><h2 id="ab54" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">初始化项目</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="6e40" class="ni ls it ne b gy nj nk l nl nm">$ go mod init github.com/YOUR_USERNAME/go-grpc-auth-svc</span></pre><h2 id="fe05" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">安装模块</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5078" class="ni ls it ne b gy nj nk l nl nm">$ go get github.com/spf13/viper<br/>$ go get google.golang.org/grpc<br/>$ go get gorm.io/gorm<br/>$ go get gorm.io/driver/postgres<br/>$ go get golang.org/x/crypto/bcrypt<br/>$ go get github.com/golang-jwt/jwt</span></pre><h2 id="4e74" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">项目结构</h2><p id="468c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们需要建立这个项目。与API网关本身相比，认证微服务将会很小。</p><p id="ed44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">文件夹</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3fd5" class="ni ls it ne b gy nj nk l nl nm">$ mkdir -p cmd pkg/config/envs pkg/db pkg/models pkg/pb pkg/services pkg/utils</span></pre><p id="7a69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">文件</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d56c" class="ni ls it ne b gy nj nk l nl nm">$ touch Makefile cmd/main.go pkg/config/envs/dev.env pkg/config/config.go</span><span id="e98d" class="ni ls it ne b gy oc nk l nl nm">$ touch pkg/pb/auth.proto pkg/db/db.go pkg/models/auth.go pkg/services/auth.go pkg/utils/hash.go pkg/utils/jwt.go</span></pre><p id="abe3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">项目结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/f70df612a66accad620be70166004573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d34nU2JfxjMUGdAhfnhcYg.png"/></div></div></figure><h2 id="955a" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">生成文件</h2><p id="26ee" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这里，我们需要一个<code class="fe nn no np ne b">Makefile</code>来缩短我们的命令。</p><p id="6c12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">Makefile</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="a93e" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">原型文件</h2><p id="303c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们在两端都需要相同的proto文件，在微服务端和API网关端。</p><p id="75d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/pb/auth.proto</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="c59b" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">生成Protobuf文件</h2><p id="a42d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们需要生成protobuf文件。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9b75" class="ni ls it ne b gy nj nk l nl nm">$ make proto</span></pre><h2 id="5634" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">环境变量</h2><p id="b89f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这里我们需要的变量当然是gRPC服务器的端口，然后我们需要数据库的URL，我们需要JWT的密钥。</p><p id="22fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/config/envs/dev.env</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="2c33" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">配置</h2><p id="e095" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，我们需要为这个微服务创建一个<code class="fe nn no np ne b">config.g</code> o文件。</p><p id="296f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们添加代码到<code class="fe nn no np ne b">pkg/config/config.go</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="5c8c" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">数据库模型</h2><p id="6552" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这个模型中，我们在我们的<code class="fe nn no np ne b">auth_svc</code>数据库中创建一个表。记住，我们在PostgreSQL中创建了一个名为<code class="fe nn no np ne b">auth_svc</code>的数据库。</p><p id="c2d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/models/auth.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="1fb1" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">数据库连接</h2><p id="09b3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这里，我们连接到这个数据库。</p><p id="0488" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们启动这个应用程序，<code class="fe nn no np ne b">db.AutoMigrate</code>函数将自动为我们创建表格。</p><p id="eadd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/db/db.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="a394" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">哈希助手</h2><p id="6bea" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这个文件中，我们有两个用bcrypt编码密码的函数，然后我们还有一个验证函数。</p><p id="cfe2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/utils/hash.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="342f" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">JWT助手</h2><p id="3a66" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这个助手中，我们基于我们在前面的<code class="fe nn no np ne b">dev.env</code>文件中定义的密钥来生成和验证JSON Web令牌。</p><p id="12b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/utils/jwt.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="5212" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">授权服务</h2><p id="58bb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这里，我们将对Auth微服务的业务逻辑进行编码。记住，我们在API网关中创建的认证路由会将请求转发到这个文件。</p><p id="1750" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">pkg/services/auth.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="3679" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">主文件</h2><p id="1e22" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">最后但同样重要的是，我们需要引导这个微服务。</p><p id="c803" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe nn no np ne b">cmd/main.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4eab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这样，我们终于完成了第1部分，包括API网关和第一个用于身份验证的微服务。</p><p id="99b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以生成protobuf文件并运行服务器。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="6d6b" class="ni ls it ne b gy nj nk l nl nm">$ make server</span></pre><p id="654e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">控制台中的输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/69ada6532c01b20f6f5354a371ade994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cl37rNPOzEtqG61_l9iLXQ.png"/></div></div></figure><h1 id="4ca9" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">测试授权微服务和API网关</h1><p id="6f11" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，我们可以向API网关发送两个HTTP请求。确保两个应用程序都已启动并正在运行。端口3000上的API网关和端口52001上的身份验证微服务。</p><h2 id="e215" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">注册新用户</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="055a" class="ni ls it ne b gy nj nk l nl nm">curl --request POST \<br/>  --url http://localhost:3000/auth/register \<br/>  --header 'Content-Type: application/json' \<br/>  --data '{<br/> "email": "elon@musk.com",<br/> "password": "1234567"<br/>}'</span></pre><h2 id="5455" class="ni ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">登录用户</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3661" class="ni ls it ne b gy nj nk l nl nm">curl --request POST \<br/>  --url <a class="ae lq" href="http://localhost:3000/auth/login" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/auth/login</a> \<br/>  --header 'Content-Type: application/json' \<br/>  --data '{<br/> "email": "<a class="ae lq" href="mailto:elon@musk.com" rel="noopener ugc nofollow" target="_blank">elon@musk.com</a>",<br/> "password": "1234567"<br/>}'</span></pre><p id="6f52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对这个请求的响应非常重要，因为这个请求将在我们完成了本系列文章第2部分中的另一个微服务之后，立即返回我们需要的JSON Web令牌。</p><p id="eb44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">响应</strong>将如下所示:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2164" class="ni ls it ne b gy nj nk l nl nm">{<br/> "status": 200,<br/> "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2ODAxMTk5NzAsImlzcyI6ImdvLWdycGMtYXV0aC1zdmMiLCJJZCI6MiwiRW1haWwiOiJlbG9uQG11c2suY29tIn0.oDirdoryUDBaOtbAUzVgtwTeakNi9SptPyW7ftobdrI"<br/>}</span></pre><p id="977a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第二部分:</strong></p><div class="pf pg gp gr ph pi"><a rel="noopener  ugc nofollow" target="_blank" href="/microservices-in-go-with-grpc-api-gateway-and-authentication-ba36cc32d167"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">采用gRPC、API网关和身份验证的微服务</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">在Go中创建3个微服务和1个API网关的第2部分</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ks pi"/></div></div></a></div><p id="3f47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干杯！</p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><p id="ce88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，可以考虑注册<a class="ae lq" href="https://medium.com/@hellokevinvogel/membership" rel="noopener">成为一名媒体成员</a>。每月只需5美元，你就可以无限制地使用Medium。</p><p id="42ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想支持我？给我买杯咖啡。</p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><h1 id="247e" class="lr ls it bd lt lu oy lw lx ly oz ma mb jz pa ka md kc pb kd mf kf pc kg mh mi bi translated">分级编码</h1><p id="9489" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">感谢您成为我们社区的一员！升级正在改变技术招聘。<a class="ae lq" href="https://jobs.levelup.dev/talent" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">在最好的公司</strong>找到你最完美的工作 </a> <strong class="kw iu">。</strong></p><div class="pf pg gp gr ph pi"><a href="https://jobs.levelup.dev/talent" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">提升——改变招聘流程</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">🔥让软件工程师找到他们热爱的完美角色🧠寻找人才是最痛苦的部分…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">作业. levelup.dev</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw ks pi"/></div></div></a></div></div></div>    
</body>
</html>