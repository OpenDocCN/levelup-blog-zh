<html>
<head>
<title>Building a Game With TypeScript. Input system 2/3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。输入系统2/3</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c?source=collection_archive---------1-----------------------#2020-12-29">https://levelup.gitconnected.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c?source=collection_archive---------1-----------------------#2020-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">教程<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">系列</a>中的第五章讲述了如何用TypeScript和本地浏览器API从头开始构建游戏</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/47e47aba9de737d0e4f5b00d2f65986d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jvmlh75gzmjdlT4CZJNWfw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/cloud" rel="noopener ugc nofollow" target="_blank">由vector juice-www.freepik.com创建的云矢量</a></figcaption></figure><p id="0e85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎回来，读者！<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">上次</a>我们配置了<code class="fe lc ld le lf b">Node</code>实体来监听<code class="fe lc ld le lf b">body</code> DOM元素上的<em class="lg"> click </em>事件。虽然这给了我们想要的东西:一种在事件发生时得到通知的方式，但它远非高效。事实上，如果我们运行代码并添加<code class="fe lc ld le lf b">debugger</code>或<code class="fe lc ld le lf b">console.log</code>，我们会注意到我们对事件做出了多次反应:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="3c50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们捕捉点击36次(目前游戏中的<code class="fe lc ld le lf b">Nodes</code>的数量):</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lj"><img src="../Images/54c6ef81d0ea2b8c6bac9c0228f1eecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knnyrZy3PvfVAMvlFchSlA.png"/></div></div></figure><p id="e79f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这并不特别可怕，因为我们仍然可以通过检查点击点是否在这个节点<code class="fe lc ld le lf b">Occupies</code>的区域内来将它缩小到特定的<code class="fe lc ld le lf b">Node</code>。但是，即使没有这种检查，36个事件侦听器也很难成为任何现代浏览器的性能瓶颈。然而，如果游戏的其他部分也应该听卡嗒声，这个问题可能会加剧。问题并不在于性能，至少在我们拥有数千个这样的元素之前是如此(老实说，如果我们构建一个更复杂的游戏，这是相当可行的)。问题是，对于这种设计，我们必须为每个这样的元素复制来自<code class="fe lc ld le lf b">Awake</code>的代码。我们可以做得更好，在这一期中，我们将讨论如何用更好的架构来重构我们的代码。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="b016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第五章<em class="lg">“输入系统”</em>中，我们将构建一个简单的系统，让玩家有机会与游戏交流。您可以在这里找到本系列的其他章节:</p><ul class=""><li id="9180" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="3e2d" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体和组成部分</a></li><li id="9944" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a>)</li><li id="df31" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第三章。绘制网格(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第五部分</a>)</li><li id="9b2c" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a></li><li id="0b0d" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>，第二部分<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">，第三部分</a>)</li><li id="3db7" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="dd68" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第七章。玛奇纳州</li><li id="0682" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第九章。比赛的输赢</li><li id="c49c" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第十章敌人AI</li></ul><blockquote class="mf mg mh"><p id="accb" class="jn jo lg jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">随意切换到<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lc ld le lf b">input-1</code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="ee6d" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">目录</h1><ol class=""><li id="ca7e" class="lr ls iq jp b jq nj ju nk jy nl kc nm kg nn kk no lx ly lz bi translated">介绍</li><li id="e49a" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk no lx ly lz bi translated">输入游戏组件</li><li id="7e47" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk no lx ly lz bi translated">快速内务处理</li><li id="5c38" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk no lx ly lz bi translated">Onclick组件</li><li id="0603" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk no lx ly lz bi translated">Onclick，抽象组件</li><li id="f106" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk no lx ly lz bi translated">结论</li></ol></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="26b3" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">输入游戏组件</h1><p id="da33" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">我们有这么多事件处理程序的原因是我们为每个<code class="fe lc ld le lf b">Node</code>附加了它们。这就更奇怪了，因为从DOM的角度来看，我们实际上是在听整个<code class="fe lc ld le lf b">body</code>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ns"><img src="../Images/1d14a7b99959e0fc794f726c32761446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jq5lJIsPMY46Kl3CyazbAg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/technology" rel="noopener ugc nofollow" target="_blank">宏向量-www.freepik.com创建的技术向量</a></figcaption></figure><p id="c5e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只有一个<code class="fe lc ld le lf b">body</code>，所以我们可以在实体的层次结构中向上移动监听器:一直到<code class="fe lc ld le lf b">Game</code>。这几乎不是<code class="fe lc ld le lf b">Game</code>本身的核心特征，而是一个我们可以打开或关闭的组件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="ab67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">IComponent</code>接口要求我们实现<code class="fe lc ld le lf b">Awake</code>和<code class="fe lc ld le lf b">Update</code>，并定义<code class="fe lc ld le lf b">Entity</code>。此外，我们不应该忘记桶文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="a4bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在，只要组件唤醒，我们就可以开始监听点击事件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="648d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不错！因为我们只有一个<code class="fe lc ld le lf b">Game</code>实体，所以我们可以确保不添加任何多余的侦听器。</p><p id="7960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">HandleClick</code>有一些重要的职责。首先，它必须确保点击发生在游戏本身:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="cbca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个应该看着眼熟。我们将点击的点发送给<code class="fe lc ld le lf b">canvas</code>来分析这个点是否属于它。如果响应是否定的，我们忽略这个事件。</p><blockquote class="mf mg mh"><p id="1b0e" class="jn jo lg jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">注意，我们使用了<code class="fe lc ld le lf b">Background</code>层。正如我们上次讨论的，我们检查哪一层并不重要，因为它们实际上占据了相同的区域。在更复杂的情况下，当图层位置不同和/或我们关心Z坐标时，检查会更复杂。幸运的是，我们总是可以在需要的时候扩展这个组件。</p></blockquote><p id="a386" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了检查这是否有效，让我们在<code class="fe lc ld le lf b">point</code>检查之后添加<code class="fe lc ld le lf b">console.log</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="cbf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果我们用<code class="fe lc ld le lf b">npm start</code>运行游戏并打开浏览器，除了来自<code class="fe lc ld le lf b">Node</code>的旧日志之外，我们将看不到其他日志:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lj"><img src="../Images/54c6ef81d0ea2b8c6bac9c0228f1eecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knnyrZy3PvfVAMvlFchSlA.png"/></div></div></figure><p id="d392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那是因为我们忘记将新的<code class="fe lc ld le lf b">GameInputComponent</code>连接到<code class="fe lc ld le lf b">Game</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="5e88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你应该可以看到画布中每次点击的“游戏组件点击”日志消息以及“旧的”36条消息。请注意，游戏会忽略画布边界之外的事件:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nt"><img src="../Images/a73778ed79579d44fd05c2f7365b3aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7KGJY1W5yWnXIo9X5DDfA.png"/></div></div></figure><p id="3690" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完美，正如我们所愿。对于所有的点击，我们有一个集中的监听器，过滤掉所有无用的事件。但是我们没有机制来通知实际的响应者。毕竟，<code class="fe lc ld le lf b">Node</code>怎么知道点击发生了呢？</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="d5ea" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">快速内务处理</h1><p id="3b79" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">在我们开始解决这个问题之前，让我们先清理一下。首先，我们可以从根本上简化<code class="fe lc ld le lf b">game tests</code>。如果你还记得，前几集我们在测试<code class="fe lc ld le lf b">Game</code>实体时添加了一堆假组件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nu"><img src="../Images/22aa62bab30656a52d80d93beac5c7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdDlnbuU1mStcs7y9QHgkA.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/business" rel="noopener ugc nofollow" target="_blank">杰马斯托克-www.freepik.com</a>创建的业务向量</figcaption></figure><p id="a416" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当我们有一个真正的<code class="fe lc ld le lf b">Input Component</code>附加，我们可以摆脱假货:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="a9ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我简单地删除了所有与假组件<code class="fe lc ld le lf b">C1</code>、<code class="fe lc ld le lf b">C2</code>、<code class="fe lc ld le lf b">C3</code>相关的代码，并添加了一个测试来验证<code class="fe lc ld le lf b">Game</code>是否连接了真正的<code class="fe lc ld le lf b">GameInputComponent</code>并正在运行。</p><p id="0506" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，让我们为<code class="fe lc ld le lf b">Game</code>本身定义一个专用的模拟，我们很快就会用到它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="0489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传统上，更新枪管:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="8a1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并在测试中使用模拟:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="5c53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们的代码应该可以用<code class="fe lc ld le lf b">npm start</code>成功编译，并且所有的测试都应该通过<code class="fe lc ld le lf b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nv"><img src="../Images/38a5b244c10c0a999a3f1ab2bd822386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9K8y8YxgfERPd_mTbRHxg.png"/></div></div></figure><p id="1f99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，请允许我去掉我们上次添加的“脏”代码。不管怎样，我们已经实现了大部分:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="8320" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们清理完了。那么，<code class="fe lc ld le lf b">Nodes</code>、<code class="fe lc ld le lf b">Ships</code>和其他人如何获得解雇事件的通知呢？有许多方法可以实现这一点。</p><p id="368b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用我最喜欢的模式之一:<code class="fe lc ld le lf b">Observer</code>。为了实现这个模式，我们必须存储应该在<code class="fe lc ld le lf b">GameInputComponent</code>之前通知的所有项目的列表。这是一个非常强大的方法，但是，每当我们想要新的项目开始监听事件时，我们都必须更新这个列表。或者相反，让项目停止监听。该功能可能需要这些项目了解<code class="fe lc ld le lf b">GameInputComponent</code>。</p><p id="ef9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我宁愿避免这种耦合，而是建议我们再次利用我们的实体和组件。我们可以定义一个新的组件，比如说<code class="fe lc ld le lf b">Onclick</code>组件，并简单地通知所有拥有这个组件的<code class="fe lc ld le lf b">Game</code>子组件事件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="d27d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，<code class="fe lc ld le lf b">Game</code>的任何子节点都可以通过简单地附加<code class="fe lc ld le lf b">OnclickComponent</code>来“订阅”这些通知。当然打字稿投诉不存在的<code class="fe lc ld le lf b">OnclickComponent</code>。它完全有权这样做。我们还没有定义组件本身，但是这里有一个问题。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="ded4" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">Onclick组件</h1><p id="7b20" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">以前，我们所有的组件都属于某个<code class="fe lc ld le lf b">Entity</code>。<code class="fe lc ld le lf b">GameInputComponent</code>明确属于<code class="fe lc ld le lf b">Game</code>实体。<code class="fe lc ld le lf b">NodeDrawComponent</code>没有<code class="fe lc ld le lf b">Node</code>就无法揣测它的存在。</p><p id="c4ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">OnclickComponent</code>是异兽。它根本不关心一个特定的实体。它的唯一目的是向“连接我的实体，对点击事件感兴趣，并且必须对其做出反应”做出承诺。简单来说，它保证了public方法<code class="fe lc ld le lf b">ClickOn(point: Vector2D)</code>的存在。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/0c62711af7d6a166ecdcaaba3026cfd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eQhDeOel_lAlOlyH60j1g.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">【www.freepik.com T21】故事打造的营销载体</figcaption></figure><p id="9cd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自然是一个<code class="fe lc ld le lf b">interface</code>但是比<code class="fe lc ld le lf b">IComponent</code>稍微严格一点。它需要实现<code class="fe lc ld le lf b">ClickOn</code>方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="69d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于它不属于任何实体，我们可以将其放在<code class="fe lc ld le lf b">utils</code>下。让我们提醒自己关于桶文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="0b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这个接口的目的到底是什么呢？问题是，我们不知道哪些实体会利用点击功能。最重要的是，<code class="fe lc ld le lf b">GameInputComponent</code>也不知道。也不应该。</p><p id="817e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们希望<code class="fe lc ld le lf b">Node</code>收到点击通知。我们可以创建<strong class="jp ir">一个特定的</strong> <code class="fe lc ld le lf b">NodeOnclickComponent</code>来实现<code class="fe lc ld le lf b">IOnClickComponent</code>接口。同样，如果我们希望<code class="fe lc ld le lf b">Ship</code>被通知，我们可以定义<code class="fe lc ld le lf b">ShipOnclickComponent</code>。但是<code class="fe lc ld le lf b">GameInputComponent</code>只会知道<code class="fe lc ld le lf b">IOnClickComponent</code>并且调用任何实现这个接口的人。这有效地将<code class="fe lc ld le lf b">GameInputComponent</code>从任何关于对事件做出反应的逻辑中分离出来。更好的是:<code class="fe lc ld le lf b">GameInputComponent</code>甚至不需要跟踪“订户”</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="65cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唉，不管用。TypeScript不断向我们抛出一个讨厌的错误:<code class="fe lc ld le lf b">'IOnClickComponent' only refers to a type, but is being used as a value here</code>。</p><p id="5c1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">的确，接口只是一个<em class="lg">类型的</em>，而<code class="fe lc ld le lf b">HasComponent</code>和<code class="fe lc ld le lf b">GetComponent</code>都需要一个实际的<em class="lg">东西</em>。如果你还记得，我们的实体组件系统被设置为在<em class="lg">运行时</em>工作，这给了我们在游戏<em class="lg">运行</em>时添加和删除组件的灵活性。在运行时，没有留下接口，所以我们的ECS实际上没有任何东西可以使用。</p><p id="bf02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们如何解决这个难题呢？ECS需要一些“真实”的东西，比如函数、类或对象。我们可以将我们的<code class="fe lc ld le lf b">IOnClickComponent</code>转换成一个类:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="e970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以<strong class="jp ir">删除</strong>多余的<code class="fe lc ld le lf b">onclick.h</code>文件并更新桶:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="1448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你可能注意到我们必须按照<code class="fe lc ld le lf b">IComponent</code>的要求实现<code class="fe lc ld le lf b">Awake</code>和<code class="fe lc ld le lf b">Update</code>。这很烦人，更重要的是，从架构的角度来看，这是不正确的。<code class="fe lc ld le lf b">OnclickComponent</code>与<code class="fe lc ld le lf b">Awake</code>或<code class="fe lc ld le lf b">Update</code>无关。此外，正如我们之前讨论的，我们期望未来的组件(如<code class="fe lc ld le lf b">ShipOnclickComponent</code>、<code class="fe lc ld le lf b">NodeOnclickComponent</code>等)实现<code class="fe lc ld le lf b">IOnClickComponent</code>。<code class="fe lc ld le lf b">ClickOn</code>应该也会被覆盖。</p><p id="7773" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这还不够的话，整个类<code class="fe lc ld le lf b">OnclickComponent</code>本身存在<em class="lg">只有</em>需要扩展。我们不期望有这个类的实例。幸运的是，在OOP世界中有一个特殊的工具来完成这项工作:<em class="lg">抽象</em>类。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="a8c0" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">Onclick，抽象组件</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nx"><img src="../Images/a95cd6ae0a1f0a5833ec563bfa1ffb74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgYYykI_mf9fQYnUGPhV-w.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/photos/pattern" rel="noopener ugc nofollow" target="_blank">www.freepik.com线材制作的图案照片</a></figcaption></figure><p id="9a9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，我们可以简单地将这个类和所有我们期望被覆盖的方法标记为“抽象”并将实现委托给未来的“特定”类:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="315b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在我们可以更新<code class="fe lc ld le lf b">GameInputComponent</code>来使用这个抽象类而不是接口:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="0086" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Aaaaand它也不工作。我们消除了一个TS错误，却得到了另一个:<code class="fe lc ld le lf b">Argument of type 'typeof OnclickComponent' is not assignable to parameter of type 'constr&lt;OnclickComponent&gt;’</code>。这到底是什么意思？！</p><p id="ef1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别紧张。TypeScript只是试图通过迫使我们做出合理的、深思熟虑的选择来帮助我们。在这种情况下，它表明<code class="fe lc ld le lf b">OnclickComponent</code>很好，不是一个“通常的”类。你看，<a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">当我们设计我们的实体组件系统</a>时，我们从来没有想过组件可以是一个<strong class="jp ir">抽象</strong>类。看一下这段代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="7b41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类型<code class="fe lc ld le lf b">constr&lt;T&gt;</code>清楚地为组件设置了一个常规的期望(读:“可实例化的”)类。这里的关键词<code class="fe lc ld le lf b">new</code>正是这个原因。但是根据定义，类不能被实例化。</p><p id="e7b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们能做的是扩展我们的选择，允许<code class="fe lc ld le lf b">Entity</code>以抽象类的形式期待一个组件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="5b00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这并不意味着我们可以将一个抽象类直接附加到<code class="fe lc ld le lf b">Entity</code>上，但是我们可以检查、查找、甚至删除一个组件，这个组件是<em class="lg">扩展了</em>某个抽象类。正是我们现在需要的！</p><blockquote class="mf mg mh"><p id="2443" class="jn jo lg jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">这个<code class="fe lc ld le lf b">AbstractComponent&lt;T&gt;</code>型是怎么工作的？为了理解，我们必须回忆一下JavaScript中关于类的一些事情。首先，<code class="fe lc ld le lf b">class</code>本质上是围绕<code class="fe lc ld le lf b">constructor</code>函数的语法糖。当我们用<code class="fe lc ld le lf b">new</code>关键字运行一个函数时，我们是在构造一个对象的“上下文”中运行它。其次，JavaScript使用原型继承，这本身就是一个漫长而有趣的话题。为了简单起见，我只说一个对象的特殊保留属性<code class="fe lc ld le lf b">prototype</code>保存了对父构造函数的引用。当我们说<code class="fe lc ld le lf b">Function &amp; { prototype: T }</code>时，我们的意思是这个“东西”必须是一个函数，并且应该有一个特定的<code class="fe lc ld le lf b">T</code>类型的父构造函数。换句话说，它必须扩展那个<code class="fe lc ld le lf b">T</code>。</p></blockquote><p id="73bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们更新<code class="fe lc ld le lf b">Entity</code>错误消失，我们应该能够再次编译和运行所有测试:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nv"><img src="../Images/38a5b244c10c0a999a3f1ab2bd822386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9K8y8YxgfERPd_mTbRHxg.png"/></div></div></figure><blockquote class="mf mg mh"><p id="42ff" class="jn jo lg jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">你可以在<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lc ld le lf b">input-2</code>分支中找到这篇文章的完整源代码。</p></blockquote></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="ce5c" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">结论</h1><p id="b043" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">我们做了大量的工作，将前一期的“脏”代码转换成更健壮的系统。我们首先将<code class="fe lc ld le lf b">addEventListener</code>移到“食物链”的顶端:一直到<code class="fe lc ld le lf b">Game</code>实体，引入<code class="fe lc ld le lf b">GameInputComponent</code>。此外，我们很快更新了测试<code class="fe lc ld le lf b">Game</code>实体的方式，去掉了多余的假组件，并检查了实际运行中的组件。</p><p id="9b79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们花了很多时间谈论<code class="fe lc ld le lf b">OnclickComponent</code>。这个组件负责确保那些对点击事件感兴趣的人会收到他们的消息。这个讨论引导我们通过不同的方法:接口，常规类，最后是抽象类。</p><p id="3066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一切都很棒。然而，我们仍然需要定义一个实际的组件来扩展<code class="fe lc ld le lf b">OnclickComponent</code>和<strong class="jp ir">实际上</strong>对事件做出反应。我们也忽略了<code class="fe lc ld le lf b">GameInputComponent</code>的测试。我们将在第五章的最后一部分中处理所有这些<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener"/></p><p id="e678" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很想听听你的<strong class="jp ir">想法</strong>！如果你有任何<strong class="jp ir">评论</strong>、<strong class="jp ir">建议</strong>、<strong class="jp ir">问题</strong>，或者任何其他<strong class="jp ir">反馈</strong>，不要犹豫给我发私信或者在下面留言评论！如果你喜欢这个系列，<strong class="jp ir">请与他人分享</strong>。它真的帮助我继续努力。感谢您的阅读，我们下次再见！</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="7770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lg">这是系列教程</em> <strong class="jp ir"> <em class="lg">用打字稿</em> </strong> <em class="lg">构建游戏中的N章。其他章节可点击此处:</em></p><ul class=""><li id="1629" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="7804" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="261f" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a>)</li><li id="be37" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第三章。绘制网格(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>，第五部分)</li><li id="64f9" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="cd4b" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>，第二部分<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">，第三部分</a>)</li><li id="10a1" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="4606" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第七章。玛奇纳州</li><li id="1e64" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第八章。攻击系统:生命和伤害</li><li id="c714" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第九章。比赛的输赢</li><li id="f9cc" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">第十章敌人AI</li></ul></div></div>    
</body>
</html>