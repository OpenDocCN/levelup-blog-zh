<html>
<head>
<title>React Form Validation With Formik, Yup, and GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Formik、Yup和GraphQL进行表单验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-form-validation-with-graphql-formik-yup-f31e83f38bb0?source=collection_archive---------1-----------------------#2019-08-30">https://levelup.gitconnected.com/react-form-validation-with-graphql-formik-yup-f31e83f38bb0?source=collection_archive---------1-----------------------#2019-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dd48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">验证用户注册表单听起来很简单，不是吗？只要确保所提供的电子邮件格式正确，并且密码符合任何标准，就万事俱备了，对吗？</p><p id="b06f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，直到我开始实现代码，我才意识到实际上有很多活动的部分。当连接一个完整的栈<em class="kl"> JavaScript </em>应用程序时尤其如此，在这种情况下，一个<a class="ae km" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae km" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>客户端与一个<a class="ae km" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>和<a class="ae km" href="https://github.com/prisma/graphql-yoga" rel="noopener ugc nofollow" target="_blank"> GraphQL Yoga(还有Apollo) </a>服务器。有相当多的考虑最终会影响用户注册过程。</p><ol class=""><li id="ac0d" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">需要什么样的信条？<code class="fe kw kx ky kz b">email/password</code>还是<code class="fe kw kx ky kz b">email/name/password</code>还是更复杂更烦人的？</li><li id="ab2d" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk ks kt ku kv bi translated">发生了什么验证，它们发生在客户端还是服务器上——需要<code class="fe kw kx ky kz b">regex</code>吗？</li><li id="f7f9" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk ks kt ku kv bi translated">对于<code class="fe kw kx ky kz b">signup</code>突变来说<code class="fe kw kx ky kz b">schema</code>看起来像什么？</li><li id="1a56" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk ks kt ku kv bi translated">错误信息如何显示给用户——文本、颜色、在页面上的位置？</li><li id="7982" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk ks kt ku kv bi translated">在什么情况下会显示这些错误？</li></ol></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="d408" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">放弃</h1><p id="9ec2" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">完成这项任务的方法可能和实现它的开发人员一样多。这只是我最近偶然发现的一种方式，我喜欢它的结果。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/5c0974796b9eeb584fbf24d1b3351c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/0*NyrfDMkWH7hOsjab.gif"/></div></figure><h1 id="e4bf" class="lm ln iq bd lo lp mx lr ls lt my lv lw lx mz lz ma mb na md me mf nb mh mi mj bi translated">服务器逻辑</h1><p id="5714" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">服务器的细节没有我们将要关注的<a class="ae km" href="https://graphql.org/learn/queries/#mutations" rel="noopener ugc nofollow" target="_blank"> GraphQL变异</a>解析器重要，但是看到一切都在运行是有帮助的。克隆我的服务器样板文件，然后按照<code class="fe kw kx ky kz b">README</code>运行你自己的服务器，或者只是跟着做。</p><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="41bf" class="ng ln iq kz b gy nh ni l nj nk">git clone <a class="ae km" href="https://github.com/benjaminadk/graphql-server-boilerplate-ts" rel="noopener ugc nofollow" target="_blank">https://github.com/benjaminadk/graphql-server-boilerplate-ts</a></span></pre><p id="e299" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文真正关心的唯一代码是验证逻辑、<code class="fe kw kx ky kz b">signup</code>变异的解析器和相应的前端标记。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="c917" class="ng ln iq bd lo nl nm dn ls nn no dp lw jy np nq ma kc nr ns me kg nt nu mi nv bi translated">(计划或理论的)纲要</h2><ul class=""><li id="4452" class="kn ko iq jp b jq mk ju ml jy nw kc nx kg ny kk nz kt ku kv bi translated"><code class="fe kw kx ky kz b">signup</code>变异返回一个<code class="fe kw kx ky kz b">Error</code>或<code class="fe kw kx ky kz b">null</code>的数组</li><li id="17a7" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated">如果返回<code class="fe kw kx ky kz b">null</code>,我们可以假设一切正常，数据库中有了一个新用户</li><li id="2365" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated">每个<code class="fe kw kx ky kz b">Error</code>的<code class="fe kw kx ky kz b">path</code>指的是出错的字段的名称，因此在本例中是<code class="fe kw kx ky kz b">email</code>、<code class="fe kw kx ky kz b">name</code>或<code class="fe kw kx ky kz b">password</code></li><li id="7306" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated">每个<code class="fe kw kx ky kz b">Error</code>的<code class="fe kw kx ky kz b">message</code>是描述错误的短文本消息</li></ul><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="169b" class="ng ln iq kz b gy nh ni l nj nk">type Error {<br/>  path: String!<br/>  message: String!<br/>}<br/><br/>type Mutation {<br/>  signup(email: String!, name: String!, password: String!): [Error!]<br/>}</span></pre><h2 id="bd19" class="ng ln iq bd lo nl nm dn ls nn no dp lw jy np nq ma kc nr ns me kg nt nu mi nv bi translated">是错误验证</h2><ul class=""><li id="205b" class="kn ko iq jp b jq mk ju ml jy nw kc nx kg ny kk nz kt ku kv bi translated"><a class="ae km" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank">是</a>用于验证</li><li id="95b9" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated">语法类似于<a class="ae km" href="https://github.com/facebook/prop-types" rel="noopener ugc nofollow" target="_blank">反应道具类型</a></li><li id="df2b" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated">提供类型、最小/最大长度、整体对象形状等各种验证</li><li id="a3bc" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated">将自定义错误信息作为最后一个参数传递</li><li id="1fde" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated"><code class="fe kw kx ky kz b">formatYupError</code>将<em class="kl">是的</em>错误形状映射到我们的模式</li></ul><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="d659" class="ng ln iq kz b gy nh ni l nj nk">const yup = require('yup')<br/><br/>const emailNotLongEnough = 'email must be at least 3 characters'<br/>const nameNotLongEnough = 'name must be at least 3 characters'<br/>const passwordNotLongEnough = 'password must be at least 8 characters'<br/>const invalidEmail = 'email must be a valid email'<br/><br/>const validator = yup.object().shape({<br/>  email: yup<br/>    .string()<br/>    .min(3, emailNotLongEnough)<br/>    .max(100)<br/>    .email(invalidEmail),<br/>  name: yup<br/>    .string()<br/>    .min(3, nameNotLongEnough)<br/>    .max(100),<br/>  password: yup<br/>    .string()<br/>    .min(8, passwordNotLongEnough)<br/>    .max(100)<br/>})<br/><br/>const formatYupError = err =&gt; {<br/>  const errors = []<br/>  err.inner.forEach(e =&gt; {<br/>    errors.push({<br/>      path: e.path,<br/>      message: e.message<br/>    })<br/>  })<br/>  return errors<br/>}<br/><br/>module.exports = { validator, formatYupError }</span></pre><h2 id="9ae2" class="ng ln iq bd lo nl nm dn ls nn no dp lw jy np nq ma kc nr ns me kg nt nu mi nv bi translated">注册突变解析器</h2><ul class=""><li id="8b1a" class="kn ko iq jp b jq mk ju ml jy nw kc nx kg ny kk nz kt ku kv bi translated"><code class="fe kw kx ky kz b">User</code>表示您的服务器访问其数据库模型的方式</li><li id="cdae" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated"><code class="fe kw kx ky kz b">try/catch</code>与<code class="fe kw kx ky kz b">abortEarly: false</code>将在任何其他逻辑运行之前触发返回错误</li><li id="3760" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated">使用<code class="fe kw kx ky kz b">email</code>检查数据库中的现有用户，如果有，则抛出错误</li><li id="97a5" class="kn ko iq jp b jq la ju lb jy lc kc ld kg le kk nz kt ku kv bi translated">如果没有触发错误，最后创建<code class="fe kw kx ky kz b">User</code>，但返回<code class="fe kw kx ky kz b">null</code></li></ul><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="0c5b" class="ng ln iq kz b gy nh ni l nj nk">const { User } = require('./User')<br/>const { validator, formatYupError } = require('./errorHelpers')<br/><br/>module.exports = async (_, args) =&gt; {<br/>  const duplicateEmail = 'email already taken'<br/><br/>  try {<br/>    await validator.validate(args, { abortEarly: false })<br/>  } catch (err) {<br/>    return formatYupError(err)<br/>  }<br/><br/>  const { email, name, password } = args<br/><br/>  const userExists = await User.findOne({<br/>    where: { email },<br/>    select: ['id']<br/>  })<br/><br/>  if (userExists) {<br/>    return [<br/>      {<br/>        path: 'email',<br/>        message: duplicateEmail<br/>      }<br/>    ]<br/>  }<br/><br/>  const user = User.create({ email, name, password })<br/><br/>  await user.save()<br/><br/>  return null<br/>}<!-- --> </span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="fd96" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">客户端逻辑</h1><p id="a82d" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">同样，精确的前端设置没有<code class="fe kw kx ky kz b">SignupForm</code>组件本身重要。我喜欢<em class="kl">高阶组件</em>或者<em class="kl"> HOC </em>版本的<a class="ae km" href="https://jaredpalmer.com/formik/docs/api/withformik" rel="noopener ugc nofollow" target="_blank"> Formik </a>叫做<code class="fe kw kx ky kz b">withFormik</code>。组件<code class="fe kw kx ky kz b">InnerForm</code>包含表单的<em class="kl"> JSX </em>标记，从外部组件接收道具。外部<code class="fe kw kx ky kz b">SignupForm</code> if where <em class="kl"> Formik </em>选项定义了表单的行为方式。</p><h2 id="8439" class="ng ln iq bd lo nl nm dn ls nn no dp lw jy np nq ma kc nr ns me kg nt nu mi nv bi translated">注册表单</h2><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="f84c" class="ng ln iq kz b gy nh ni l nj nk">import React from 'react'<br/>import { withFormik } from 'formik'<br/><br/>import { normalizeErrors, formatError } from '../../../utils/errorHelpers'<br/>import { validUserSchema } from './validation'<br/>import { Form, Field, Button } from './styles'<br/>import Svg from '../../shared/Svg'<br/><br/>const fields = ['email', 'name', 'password']<br/><br/>const InnerForm = props =&gt; {<br/>  const { values, touched, errors, isSubmitting, handleChange, handleBlur, handleSubmit } = props<br/><br/>  return (<br/>    &lt;Form onSubmit={handleSubmit}&gt;<br/>      {fields.map(field =&gt; {<br/>        let error = Boolean(errors[field] &amp;&amp; touched[field])<br/><br/>        return (<br/>          &lt;Field key={field} error={error}&gt;<br/>            &lt;label&gt;{field}&lt;/label&gt;<br/>            &lt;input<br/>              type={field}<br/>              onChange={handleChange}<br/>              onBlur={handleBlur}<br/>              value={values[field]}<br/>              name={field}<br/>              placeholder={field === 'email' ? 'Ex. johndoe@mail.com' : ''}<br/>              spellCheck={false}<br/>            /&gt;<br/>            &lt;div className='error'&gt;{formatError(errors[field])}&lt;/div&gt;<br/>          &lt;/Field&gt;<br/>        )<br/>      })}<br/>      &lt;Button type='submit' disabled={isSubmitting}&gt;<br/>        {isSubmitting ? &lt;Svg name='logo' /&gt; : 'Sign up'}<br/>      &lt;/Button&gt;<br/>    &lt;/Form&gt;<br/>  )<br/>}<br/><br/>const SignupForm = withFormik({<br/>  mapPropsToValues: () =&gt; ({ email: '', name: '', password: '' }),<br/><br/>  validationSchema: validUserSchema,<br/><br/>  handleSubmit: async (values, { props, setErrors, setSubmitting }) =&gt; {<br/>    await new Promise(resolve =&gt; setTimeout(resolve, 3000))<br/>    const errors = await props.submit(values)<br/>    if (errors) {<br/>      setErrors(normalizeErrors(errors))<br/>    } else {<br/>      props.onFinish()<br/>    }<br/>    setSubmitting(false)<br/>  },<br/><br/>  displayName: 'SignupForm'<br/>})(InnerForm)<br/><br/>export default SignupForm</span></pre><p id="fe66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Formik </em>很有帮助，因为它处理了一些烦人的小细节，比如<code class="fe kw kx ky kz b">touched</code>——如果用户将光标放在给定的字段中，它就是<code class="fe kw kx ky kz b">true</code>。如果用户提交表单时没有输入任何字段，并将整个表单留空，则会触发所有错误。一旦用户在显示错误状态的字段中输入有效输入，该字段会自动返回正常状态，给用户即时反馈。<em class="kl"> Formik </em>还处理整个表单<code class="fe kw kx ky kz b">state</code>和每个字段的事件处理程序，以及整个表单。<em class="kl"> Formik的</em>验证被设计为，可选地，让<em class="kl">yes</em>验证一切。要了解全局，最好是看一下实际的表单。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/cf0680b6e273c50d331a2128aaedc103.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/0*_Z5ytlNCDCjZCLTW.gif"/></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="1732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我正在制作的一个<a class="ae km" href="https://offerup.com/" rel="noopener ugc nofollow" target="_blank">克隆体的完整组件。我在<code class="fe kw kx ky kz b">handleSubmit</code>函数上放了一个<code class="fe kw kx ky kz b">setTimeout</code>来说明<em class="kl"> Formik </em>的另一个内置特性——提交状态。<em class="kl"> Formik的</em> <code class="fe kw kx ky kz b">handleSubmit</code>选项可用的回调之一是<code class="fe kw kx ky kz b">setSubmitting</code>。当<code class="fe kw kx ky kz b">handleSubmit</code>被调用时，这被自动设置为<code class="fe kw kx ky kz b">true</code>，并且对应于传递给<code class="fe kw kx ky kz b">InnerForm</code>的<code class="fe kw kx ky kz b">isSubmitting</code>属性。我使用</a><a class="ae km" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式的组件</a>构建表单组件，将<code class="fe kw kx ky kz b">isSubmitting</code>传递给<code class="fe kw kx ky kz b">Button</code>组件允许我同时禁用按钮，防止多次提交，并显示一个加载微调器，让用户知道发生了什么。Formik 确实提供了<em class="kl">表单</em>、<em class="kl">字段</em>和其他包装组件，但我发现创建自己的组件更容易定制。</p><h2 id="0e07" class="ng ln iq bd lo nl nm dn ls nn no dp lw jy np nq ma kc nr ns me kg nt nu mi nv bi translated">确认</h2><p id="14aa" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><em class="kl"> Formik </em>提供多种验证选项，在这方面非常灵活。事实上，甚至不需要设置验证。记住，我们的服务器已经在运行自己的验证了。我们可以完全忽略客户端验证，但是在我们不需要的时候限制<em class="kl"> HTTP </em>请求会更好地提高性能，并且用户会更快地收到客户端验证的反馈。另一个验证策略是编写内联的<em class="kl"> JavaScript </em>函数<em class="kl"> Formik的</em> <a class="ae km" href="https://jaredpalmer.com/formik/docs/api/withformik#validate-values-values-props-props-formikerrors-values-promise-any" rel="noopener ugc nofollow" target="_blank">验证选项</a>，但是这比我们想要做的要多。最后，最后一个选项是将一个<a class="ae km" href="https://jaredpalmer.com/formik/docs/api/withformik#validationschema-schema-props-props-schema" rel="noopener ugc nofollow" target="_blank">验证模式</a>传递给<em class="kl"> Formik </em>。</p><p id="bcf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe kw kx ky kz b">validationSchema</code>看起来会很熟悉。它与服务器端验证几乎相同，但是增加了<code class="fe kw kx ky kz b">required</code>。由于使用了<code class="fe kw kx ky kz b">!</code>(非空)操作符，GraphQL 模式本身抛出了一个空字符串，错误被传递给了解析器。服务器验证仍然相关，因为当用户试图用已经存在的电子邮件注册时，它会抛出<code class="fe kw kx ky kz b">duplicateEmail</code>错误。验证也有助于测试，在开发中，我们可能会通过图形用户界面或程序输入数据，我们希望保持数据库的整洁和数据的正确性。</p><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="4e91" class="ng ln iq kz b gy nh ni l nj nk">import * as yup from 'yup'<br/><br/>const emailNotLongEnough = 'email must be at least 3 characters'<br/>const emailRequired = 'Please enter an email address'<br/>const invalidEmail = 'email must be a valid email'<br/>const nameNotLongEnough = 'name must be at least 3 characters'<br/>const passwordNotLongEnough = 'password must be at least 3 characters'<br/>const fieldRequired = 'This field is required'<br/><br/>export const validUserSchema = yup.object().shape({<br/>  email: yup<br/>    .string()<br/>    .min(3, emailNotLongEnough)<br/>    .max(100)<br/>    .email(invalidEmail)<br/>    .required(emailRequired),<br/>  name: yup<br/>    .string()<br/>    .min(3, nameNotLongEnough)<br/>    .max(100)<br/>    .required(fieldRequired),<br/>  password: yup<br/>    .string()<br/>    .min(8, passwordNotLongEnough)<br/>    .max(100)<br/>    .required(fieldRequired)<br/>})</span></pre><h2 id="ac53" class="ng ln iq bd lo nl nm dn ls nn no dp lw jy np nq ma kc nr ns me kg nt nu mi nv bi translated">突变容器</h2><p id="d6d3" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">完整的示例需要一个带有与服务器通信的逻辑的容器组件。<code class="fe kw kx ky kz b">submit</code>函数调用<code class="fe kw kx ky kz b">signup</code>突变，而<code class="fe kw kx ky kz b">onFinish</code>函数只有在一切顺利完成时才会被调用。这个设置最酷的地方在于，来自服务器的<code class="fe kw kx ky kz b">duplicateEmail</code>错误可以平滑地集成到<em class="kl"> Formik </em>系统中。现在，我们将客户端和服务器验证打包到同一个包中。</p><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="9454" class="ng ln iq kz b gy nh ni l nj nk">import { useMutation } from 'react-apollo'<br/>import { withRouter } from 'react-router-dom'<br/>import gql from 'graphql-tag'<br/><br/>const signupMutation = gql`<br/>  mutation Signup($email: String!, $name: String!, $password: String!) {<br/>    signup(email: $email, name: $name, password: $password) {<br/>      path<br/>      message<br/>    }<br/>  }<br/>`<br/><br/>const SignupContainer = props =&gt; {<br/>  const [mutate] = useMutation(signupMutation)<br/><br/>  async function submit(values) {<br/>    const { data } = await mutate({<br/>      variables: values<br/>    })<br/>    if (data) {<br/>      return data.signup<br/>    }<br/>    return null<br/>  }<br/><br/>  function onFinish() {<br/>    props.history.push('/')<br/>  }<br/><br/>  return props.children({ submit, onFinish })<br/>}<br/><br/>export default withRouter(SignupContainer)</span></pre><p id="691a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器与<a class="ae km" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>模式一起使用，以将<code class="fe kw kx ky kz b">submit</code>、<code class="fe kw kx ky kz b">onFinish</code>或任何其他所需的逻辑传递给其子节点。</p><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="d7f5" class="ng ln iq kz b gy nh ni l nj nk">&lt;SignupContainer&gt;<br/>  {({ submit, onFinish }) =&gt; &lt;Signup submit={submit} onFinish={onFinish} /&gt;}<br/>&lt;/SignupContainer&gt;</span></pre><h2 id="9192" class="ng ln iq bd lo nl nm dn ls nn no dp lw jy np nq ma kc nr ns me kg nt nu mi nv bi translated">助手功能</h2><p id="2a97" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">受过训练的眼睛可能已经注意到了<code class="fe kw kx ky kz b">SignupForm</code>示例中的几个辅助函数。<code class="fe kw kx ky kz b">normalizeErrors</code>函数将服务器抛出的错误转换成<em class="kl"> Formik </em>格式，而<code class="fe kw kx ky kz b">formatError</code>只是将第一个字母大写以用于样式化。</p><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="00b7" class="ng ln iq kz b gy nh ni l nj nk">export const normalizeErrors = errors =&gt; {<br/>  return errors.reduce((acc, val) =&gt; {<br/>    acc[val.path] = val.message<br/>    return acc<br/>  }, {})<br/>}<br/><br/>export const formatError = error =&gt; error &amp;&amp; error[0].toUpperCase() + error.slice(1)</span></pre><p id="d414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更彻底的说，<em class="kl"> Formik </em> error，touched和state格式是一个<em class="kl"> JavaScript </em>对象。每个对象都包含一个带有表单中每个字段的name属性的键。</p><h2 id="2336" class="ng ln iq bd lo nl nm dn ls nn no dp lw jy np nq ma kc nr ns me kg nt nu mi nv bi translated">样式组件</h2><p id="627c" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">以下是我使用的相当基本的<em class="kl">风格的组件</em>。一切都相当简单，因为我使用了一个<code class="fe kw kx ky kz b">error</code>道具来切换指示验证错误的红色。</p><ul class=""><li id="1777" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nz kt ku kv bi translated">我使用的主题的相关部分</li></ul><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="06c2" class="ng ln iq kz b gy nh ni l nj nk">const theme = {<br/>  primary: '#00ab80',<br/>  black: '#4a4a4a',<br/>  white: '#ffffff',<br/>  error: '#e05666',<br/>  grey: [<br/>    '#FAFAFA',<br/>    '#F2F2F2',<br/>    '#E6E5E5',<br/>    '#D9D8D8',<br/>    '#CDCCCB',<br/>    '#C0BFBF',<br/>    '#B3B2B2',<br/>    '#A7A5A5',<br/>    '#9A9898',<br/>    '#817E7E',<br/>    '#747272',<br/>    '#676565',<br/>    '#5A5858',<br/>    '#4D4C4C',<br/>    '#403F3F'<br/>  ]<br/>}</span></pre><ul class=""><li id="b8a8" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nz kt ku kv bi translated">表单组件</li></ul><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="77c9" class="ng ln iq kz b gy nh ni l nj nk">export const Form = styled.form`<br/>  width: 300px;<br/>`</span></pre><ul class=""><li id="e639" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nz kt ku kv bi translated">场分量</li></ul><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="9f9d" class="ng ln iq kz b gy nh ni l nj nk">export const Field = styled.div`<br/>  display: flex;<br/>  flex-direction: column;<br/>  color: ${p =&gt; (p.error ? p.theme.error : p.theme.black)};<br/>  label {<br/>    color: currentColor;<br/>    font-size: 14px;<br/>    font-weight: 700;<br/>    text-transform: uppercase;<br/>    margin-bottom: 8px;<br/>  }<br/>  input {<br/>    color: currentColor;<br/>    border: 1px solid ${p =&gt; (p.error ? 'currentColor' : p.theme.grey[4])};<br/>    border-radius: 3px;<br/>    font-size: 16px;<br/>    padding: 12px 16px;<br/>    margin-bottom: 8px;<br/>    &amp;::placeholder {<br/>      color: ${p =&gt; p.theme.grey[5]};<br/>    }<br/>  }<br/>  .error {<br/>    display: ${p =&gt; (p.error ? 'block' : 'none')};<br/>    color: currentColor;<br/>    font-size: 14px;<br/>  }<br/>`</span></pre><ul class=""><li id="2446" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nz kt ku kv bi translated">按钮组件</li></ul><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="105b" class="ng ln iq kz b gy nh ni l nj nk">const spin = keyframes`<br/>  0% {<br/>    transform: rotate(0deg);<br/>  }<br/>  100% {<br/>    transform: rotate(360deg);<br/>  }<br/>`<br/><br/>const Button = styled.button`<br/>  width: 100%;<br/>  background-color: ${p =&gt; p.theme.primary};<br/>  color: ${p =&gt; p.theme.white};<br/>  border: 0;<br/>  border-radius: 3px;<br/>  font-size: 20px;<br/>  font-weight: 700;<br/>  line-height: 26px;<br/>  padding: 8px 20px;<br/>  margin-top: 20px;<br/>  cursor: pointer;<br/>  &amp;:hover {<br/>    background-color: ${p =&gt; `${darken(0.1, p.theme.primary)}`};<br/>  }<br/>  &amp;:disabled {<br/>    background-color: ${p =&gt; `${lighten(0.1, p.theme.primary)}`};<br/>  }<br/>  svg {<br/>    justify-self: center;<br/>    width: 25px;<br/>    height: 25px;<br/>    animation: ${spin} 1s linear infinite;<br/>  }</span></pre><ul class=""><li id="09dc" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nz kt ku kv bi translated">Svg微调器</li></ul><pre class="mq mr ms mt gt nc kz nd ne aw nf bi"><span id="496f" class="ng ln iq kz b gy nh ni l nj nk">&lt;svg viewBox='0 0 50 50' xmlns='http://www.w3.org/2000/svg'&gt;<br/>  &lt;path<br/>    d='M49.941 23.322c1.292 19.172-18.683 32.553-35.957 24.086C5.969 43.477.66 35.575.06 26.677-1.233 7.505 18.742-5.874 36.016 2.593a24.9754 24.9754 0 0 1 13.161 16.062L44.4 24.602l-4.909-5.421c-1.346-3.382-3.9-6.35-7.613-8.169-5.005-2.454-10.941-2.056-15.571 1.046-9.976 6.683-8.968 21.644 1.816 26.931 5.005 2.453 10.94 2.054 15.57-1.047 4.716-3.16 6.979-8.172 6.912-13.134l3.95 4.359 5.32-6.62c.027.257.049.517.066.775z'<br/>    fill='#ffffff'<br/>  /&gt;<br/>&lt;/svg&gt;</span></pre><p id="6582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看<a class="ae km" href="https://benjaminbrooke.me/posts/svg-icons-with-no-artistic-ability/" rel="noopener ugc nofollow" target="_blank">没有艺术才能的SVG</a>在React中了解更多关于SVG的内容。</p><p id="34e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于2019年8月30日</em><a class="ae km" href="https://benjaminbrooke.me/posts/react-form-validation-with-graphql-formik-and-yup/" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://Benjamin Brooke . me</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>