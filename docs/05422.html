<html>
<head>
<title>Async JS Crash Course — Callbacks, Promises, Async Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JS速成班——回调、承诺、异步等待</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/async-js-crash-course-callbacks-promises-async-await-2e5f11b67dc4?source=collection_archive---------3-----------------------#2020-08-27">https://levelup.gitconnected.com/async-js-crash-course-callbacks-promises-async-await-2e5f11b67dc4?source=collection_archive---------3-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cc8f158e641c527e83a5e161395d25c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQyCjkNiOLL7KN7GnoWghA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">阿瑟·里德在<a class="ae kf" href="https://unsplash.com/s/photos/linux?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5f65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">欢迎来到异步JS速成班。</p><p id="5a04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调、承诺和异步等待是处理异步数据的一种方式。JavaScript中的异步编程是这样一种方式，在这种方式下，程序不会等到某件事情正在执行时才开始。</p><p id="45a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们执行API调用来获取一些数据时，这很方便，这需要一些时间(可能2-3秒)。但是我们不希望我们的程序停止执行下一个语句，这就是所谓的Async JS。</p><p id="da91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们从一个jsbin开始，打开JavaScript和输出。这里，我们创建了一个对象posts数组，其中包含两个对象。</p><p id="b80f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们有了一个函数<strong class="ki iu"> getPosts() </strong>，在这个函数中，我们有<strong class="ki iu"> setTimeout() </strong>来模拟对API服务器的调用，这个调用运行时有1000毫秒的延迟。在那之后，我们只是循环遍历帖子，并将包含标题和摘要的<strong class="ki iu"> li </strong>和<strong class="ki iu"> p </strong>添加到输出中。</p><p id="965b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦forEach完成，我们就将它添加到主体中。</p><p id="a215" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，我们有了<strong class="ki iu"> createPost() </strong>，它只是将一个新的帖子推送到posts数组中。但它在2000毫秒后运行。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/8c5d2d203e433d70ea32ca3bc88be571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hu-W9V3WJIyk1iZWiJuhBg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">异步ˌ非同步(asynchronous)</figcaption></figure><p id="d4a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到上面的问题，因为运行了<strong class="ki iu"> createPost() </strong>但是延迟了2000毫秒，在此之前，已经绘制了DOM并且运行了<strong class="ki iu">get post()</strong>。</p><p id="cbe2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是使用异步编程的地方，我们将首先研究<strong class="ki iu">回调</strong>。</p><h2 id="792c" class="lj lk it bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated"><strong class="ak">回调</strong></h2><p id="0a21" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使用回调，我们在<strong class="ki iu"> createPost() </strong>中传递一个新的参数<strong class="ki iu"> callback </strong>。然后在<strong class="ki iu"> posts.push(post) </strong>之后，我们调用<strong class="ki iu"> callback() </strong>。现在在<strong class="ki iu"> createPost() </strong>调用中，我们正在传递第二个参数，它是函数<strong class="ki iu"> getPost </strong>。现在，只有在运行posts.push()之后，才会运行getPosts，我们将获得所有三个帖子。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/64748b21180cfdf6fc335d4bfc82f1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bq9NdUtXA1x9BBXGapWiqw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">回收</figcaption></figure><h2 id="caa9" class="lj lk it bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated"><strong class="ak">承诺</strong></h2><p id="8c6d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Promises是回调的更好版本，是在ES6中引入的。这里，我们不传递任何参数，而是将整个代码包装在一个Promise方法中并返回它。我们传递两个参数，<strong class="ki iu"> resolve </strong>和<strong class="ki iu"> reject </strong>给它。</p><p id="19e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，每当运行<strong class="ki iu"> resolve </strong>时，就会执行来自函数调用的<strong class="ki iu"> then() </strong>块。我们通过给<strong class="ki iu"> num </strong>为5来使其为真，这样三元运算符将为真。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/7281297f53540721be23c5afe62b5160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MEFdECLioaGR1jtLZImHig.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">承诺</figcaption></figure><p id="18b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们将num设为4，这样三元运算符为<strong class="ki iu"> false </strong>并且运行<strong class="ki iu"> reject() </strong>。现在，将执行<strong class="ki iu"> catch() </strong>并显示错误。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/057ffb9086a88134c5bb0f0bb2e0196b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QP-zoZUkKC6vSdcoW1ePCQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">承诺</figcaption></figure><p id="1eb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一种承诺的变化叫做<strong class="ki iu"> Promise.all </strong>，我们可以将承诺链接起来，一旦所有承诺完成，它就会显示结果，包括最慢的一个。在下面的例子中，最慢的承诺是代码1，但是一旦它在3秒后被解决，那么只有<strong class="ki iu"> then() </strong>将被执行。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/908ee0008ed4a5ac233bedac5e58f674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7f6Ss9P__wal4EW7eeaYg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">承诺。所有</figcaption></figure><h2 id="bf06" class="lj lk it bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">异步等待</h2><p id="14f9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在，我们将学习async-await，它是promises的升级。它被称为合成糖超过承诺，因为在引擎盖下，它是承诺。</p><p id="5522" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再次使用旧的承诺的例子。这里，我们创建了一个新函数<strong class="ki iu"> init() </strong>，但是使用了关键字<strong class="ki iu"> async </strong>。在函数内部，我们让<strong class="ki iu"> createPost() </strong>成为<strong class="ki iu">wait</strong>。这意味着它之后的函数将等待它的结果。所以，我们又一次把一切都安排妥当了。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/e20c3cd28c54249634e445aa4851bb19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bn5b6Ou2uMpx9T0cS13Waw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">承诺</figcaption></figure><p id="fe49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Async-await通常与<strong class="ki iu"> fetch </strong>一起使用，从外部API获取数据。我们将使用一个漂亮的假API端点来获取10个用户的数据。</p><p id="99d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们在<strong class="ki iu"> fetch() </strong>前面使用<strong class="ki iu"> await </strong>关键字从<strong class="ki iu"> jsonplaceholder </strong> api获取数据。使用<strong class="ki iu"> fetch() </strong>我们必须在<strong class="ki iu"> res.json() </strong>中再次使用await。之后，只需遍历数据并在浏览器中显示它。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/02e4b273bce1c1a3cee482d0572b857b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_EBnFiiYfPbAHrdlaR6vg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">数据</figcaption></figure><p id="1875" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的异步等待速成课程到此结束。你可以在这里找到所有的JSbins</p><p id="2bb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://jsbin.com/kihodag/3/edit?js,output" rel="noopener ugc nofollow" target="_blank">https://jsbin.com/kihodag/3/edit?js,output</a></p><p id="8df7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://jsbin.com/gadugan/1/edit?js,output" rel="noopener ugc nofollow" target="_blank">https://jsbin.com/gadugan/1/edit?js,output</a></p><p id="b73d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://jsbin.com/wayanap/1/edit?js,output" rel="noopener ugc nofollow" target="_blank">https://jsbin.com/wayanap/1/edit?js,output</a><br/>T43】https://jsbin.com/qukisuf/1/edit?js,output<br/>T46】https://jsbin.com/notowas/edit?js,output</p></div></div>    
</body>
</html>