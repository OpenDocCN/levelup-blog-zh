# 专业版之路-特别版:起毛

> 原文：<https://levelup.gitconnected.com/road-to-go-pro-special-edition-fuzzing-e1630dd58ade>

*在我们开始之前，你可以在这个* [*资源库*](https://github.com/songx23/RoadToGoPro) *中找到本教程使用的代码。你可以在这里* *找到 Road to Go Pro* [*的全部内容。如果你错过了最后一个，你可以通过这个*](https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad) [*链接*](/road-to-go-pro-special-edition-generics-88d6ac2b5b6c) *找到它。*

欢迎回到专业版之路。我开始这个新的 Go stories 分支是因为 Go 1.18 终于发布了。这个版本带来了一些令人兴奋的新功能，我迫不及待地想与你分享。我在上一篇文章中介绍了期待已久的特性:泛型。这一次，我们将涵盖一个测试功能:模糊。

# 起毛

![](img/b8e27c5aa5f02fa4e2f0b3f88fe16c53.png)

丹尼尔·西诺卡在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

Fuzzing 是一种测试技术，旨在不断改变目标函数的输入参数，并希望发现意外的错误和漏洞。最初，我认为这个特性是泛型特性的完美伴侣。泛型有时会使函数的行为不可预测，因为很难在心里检查所有可能的类型。一个向通用函数提供随机值的测试工具可以让你安心。但是，fuzzing 工具接受的参数类型仅限于原始类型，如`string`、`bool`、`int`、`float64`、`[]byte`等。我们不能使用自定义结构、切片或映射。由于这种限制，我很难找到一个很好的 fuzzing 用例。我将在后面的部分解释我的想法。但在此之前，让我们看看如何编写模糊测试。

首先，让我们故意写一个“有缺陷”的函数。

错误的相等函数

`faultyEqual`是一个非常简单的函数，检查提供的字节片是否相同。比较逻辑很简单，而上面的实现是不正确的。我知道你已经发现了问题，但是让我们假装在漫长而疲惫的一天后，我没有意识到这个示例函数中的问题。

单元测试错误的相等函数

因为我认为实现是完美的，所以我为`faultyEqual`函数编写了这个单元测试。考试通过了，开心吗？不完全是。我提出的测试用例也有一个不正确的假设。模糊测试将帮助我识别我没有意识到的潜在问题。

模糊测试

这是一个模糊测试。类似于单元测试，模糊测试函数需要以关键字`Fuzz`开始，并且它们必须接受一个且只有一个参数`f *testing.F`(而不是单元测试的`t *testing.T`)。模糊函数的主体不同于普通的单元测试。模糊测试从种子语料库添加开始。种子语料库只是用户提供的值，用于指导模糊引擎生成各种输入。可以添加一个或者多个种子语料库(我觉得不会有太大的区别)。第二步是调用`f.Fuzz`函数来测试目标函数。它取的函数参数是一个函数，取`*testing.T`和目标函数需要的任何参数。这部分有点棘手，因为在不知道输入的情况下很难验证结果。我们将在后面的章节中对此进行更多的讨论，但是让我们把重点放在解决`faultyEqual`函数中的问题上。

为了运行模糊测试，我们需要在 go test 命令中添加一个新的标志(`-fuzz`)。这是完整的命令:`go test -fuzz=FuzzFaultyEqual`。(注意:你不必在 fuzz 标签后添加函数名，它只是用来限制测试范围)。当然，测试会失败。什么会出错？

一旦模糊测试失败，它会生成一个文件，其中包含导致失败的输入。我们可以在`testdata/fuzz/FuzzFunctionName`文件夹下找到这个文件。对于我的测试运行，测试输入如下所示:

```
go test fuzz v1
[]byte("a")
[]byte("")
```

哦，现在我明白了。我在`faultyEqual`函数中做了一个错误的假设。我期望参数长度相同，但情况并非总是如此。在模糊测试的帮助下，我发现了一个我没有注意到的潜在错误。现在让我们来修复这个函数。

工作等价函数

随着 equal 函数中的长度检查，我修复了模糊测试出现的问题。值得注意的是，一旦模糊测试失败，当您运行正常的`go test`命令时，Go 将针对失败的模糊输入数据测试函数。我们的函数现在通过了之前失败的测试用例。让我们再模糊一下，看看我们是否遗漏了其他场景。

```
fuzz: elapsed: 0s, gathering baseline coverage: 0/8 completed                                                                                                                                                                                                                                                        ─╯
fuzz: elapsed: 0s, gathering baseline coverage: 8/8 completed, now fuzzing with 10 workers
fuzz: elapsed: 3s, execs: 1606150 (535202/sec), new interesting: 0 (total: 8)
fuzz: elapsed: 6s, execs: 3259858 (551232/sec), new interesting: 0 (total: 8)
fuzz: elapsed: 9s, execs: 4963491 (567876/sec), new interesting: 0 (total: 8)
fuzz: elapsed: 12s, execs: 6664091 (567060/sec), new interesting: 0 (total: 8)
fuzz: elapsed: 13s, execs: 6995876 (547978/sec), new interesting: 0 (total: 8)
PASS
```

运行模糊测试大约 10 秒钟后，看起来模糊引擎生成的输入都通过了。这是一个好迹象。当运行模糊测试时，一个问题是你必须手动停止它，否则，它将继续运行并尝试新的输入值。然而，模糊化是有代价的。这是一个 CPU 密集型的过程。起初，我不知道我必须停止测试，所以我让它运行几分钟。这让我的 M1 Macbook 的粉丝们兴奋不已。老实说，这是我第一次听到 M1 Macbook 的风扇噪音(我已经买了 4 个月了)。在检查 CPU 使用率后，它一直保持在 80–85%。如果您想将它集成到您的构建管道中，请注意资源消耗。您不想让您的构建器实例承受太多压力。

这是模糊测试。当我玩这个功能时，我的印象并不好。让我解释一下。

# 我的想法

我的第一印象是我很难找到它的用例。一个原因是它只适用于上面提到的原始类型。另一个原因是难以用未知的输入来验证输出。[官方围棋教程](https://go.dev/doc/tutorial/fuzz)中提到的函数就是一个很好的例子(我强烈推荐去看看那块)。目标函数反转输入字符串。为了验证输出，我们可以调用这个函数两次。输出应该与原始输入相同。这种验证机制是完美的，因为它独立于输入。但是，你多久写一次这样可逆的函数呢？我认为这很罕见。对于所有其他用例，我发现自己以另一种方式重新实现了目标函数逻辑，以便能够验证结果。感觉这不是一个好的验证方式，因为重新实现的正确性没有保证。这就变成了鸡和蛋的问题。

在这个阶段，我认为由于这些问题，模糊测试的用例非常有限。**如果你能想到任何使用模糊测试的好方法，请在下面留下评论。我很想听听你的想法。**

# 下一步是什么？

![](img/25b7063a31ba20804433edc6a1e63190.png)

在这个故事中，我们看了新的测试功能:模糊化。这是一个很酷的功能，但我对它有复杂的感觉。我真的很想听听你对这个新功能的看法。**请在下面留下你的评论。**下一期特别版是 Go 1.18 新功能的最后一期覆盖。敬请关注！

**感谢您的阅读！**

如果你想支持我，你可以通过这个推荐链接成为一个中等会员。谢谢你。

[](https://songx.medium.com/membership) [## 用我的推荐链接加入 Medium 宋 x。

### 作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…

songx.medium.com](https://songx.medium.com/membership)