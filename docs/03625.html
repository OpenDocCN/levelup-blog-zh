<html>
<head>
<title>Essential Tooling for Javascript Developers: Webpack In-Depth.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript开发人员的基本工具:Webpack深入。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/essential-tooling-for-javascript-developers-webpack-in-depth-be77f8d4f66c?source=collection_archive---------10-----------------------#2020-05-19">https://levelup.gitconnected.com/essential-tooling-for-javascript-developers-webpack-in-depth-be77f8d4f66c?source=collection_archive---------10-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7c4fb549ac62cb686bc3572be17b2a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qT0W4w6Ie7ua6LG_i82ziQ.png"/></div></div></figure><p id="f3ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个系列中，我们将讨论和理解所有Javascript开发人员生活中不可或缺的重要工具。我们将学习工具和技术，如<strong class="kd iu"> <em class="kz">命令行界面、NPM、Git和GitHub、Webpack和Babel、</em> </strong>等。同时了解他们每个人的目的和需求。</p><h1 id="78f2" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">该系列涵盖的主题—</h1><ol class=""><li id="cdf3" class="ly lz it kd b ke ma ki mb km mc kq md ku me ky mf mg mh mi bi translated"><a class="ae mj" href="https://medium.com/@alok.sharma61630/developers-best-friend-command-line-interface-bb841aea4b98?source=friends_link&amp;sk=bea4ceb19c8bb188c85c4ee7ce096cf3" rel="noopener">命令行界面。</a></li><li id="be33" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky mf mg mh mi bi translated"><a class="ae mj" href="https://medium.com/swlh/essential-tooling-for-javascript-developers-npm-in-depth-d6dad74cbedc?source=friends_link&amp;sk=49859b8b6bb216edd64e43f245f71861" rel="noopener"> NPM。</a></li><li id="91c5" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky mf mg mh mi bi translated">Git和Github。</li><li id="c171" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky mf mg mh mi bi translated"><strong class="kd iu">网络包和巴别塔。</strong></li></ol><p id="974a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将把<strong class="kd iu"> webpack </strong>分成一个系列，因为它无法在一篇文章中涵盖。本文将涵盖Webpack的内容、原因和方式(<em class="kz">基础到中级</em>)。接下来的文章将带您了解高级的Webpack概念。</p><h2 id="48f5" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">什么是Webpack？</strong></h2><blockquote class="nb"><p id="1128" class="nc nd it bd ne nf ng nh ni nj nk ky dk translated">Webpack是一个开源的Javascript模块/资产捆绑器。</p></blockquote><h2 id="f782" class="mp lb it bd lc mq nl dn lg ms nm dp lk km nn mv lo kq no mx ls ku np mz lw na bi translated">开放源码</h2><p id="d750" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">一个软件被称为<strong class="kd iu">开源</strong>如果它是<strong class="kd iu">公共可访问的</strong>，即用户可以使用、共享以及建议改进这样的软件。<strong class="kd iu">示例</strong> — <em class="kz"> Node.js、Bootstrap、Webpack、Linux等</em></p><h2 id="d777" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated">什么是模块捆绑器？</h2><p id="30b8" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">为了编写更多<em class="kz"> </em> <strong class="kd iu">可读</strong>、<strong class="kd iu">可扩展</strong>，以及<em class="kz"> </em> <strong class="kd iu">可维护</strong>的代码，我们作为开发人员利用'<strong class="kd iu">架构<em class="kz"> ' </em> </strong>和<strong class="kd iu"> <em class="kz"> ' </em>设计模式<em class="kz"> ' </em> </strong>将我们的应用拆分成多个<strong class="kd iu"> <em class="kz"> </em>更小的组件<em class="kz"> </em> </strong></p><p id="d8a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">模块捆绑器</strong>只是一个工具，由<strong class="kd iu">分析不同<strong class="kd iu">模块</strong>和<strong class="kd iu">之间的连接</strong>将所有这些不同的<strong class="kd iu">模块<em class="kz"> </em> </strong>捆绑在一起，形成每种类型的一个文件。</strong></p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/ecee4cf12f84ff87712543391eb98193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tl0jAH7miIK-Xg5vUP-Kzw.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd lc">网络包概述</strong></figcaption></figure><p id="f66b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz"> Webpack </em> </strong>就是这样一个<strong class="kd iu">模块捆绑器</strong>。如上图所示，Webpack采用了不同的模块<em class="kz">(文件如。scss，。js，。jpg，。png </em>)并将它们组合在一起，形成每种类型的单个文件(。js，。css等)。它还执行各种优化，如<strong class="kd iu">树抖动、平移、多填充、压缩、缩小、</strong>等<strong class="kd iu"> <em class="kz">。</em>T13】</strong></p><p id="0ff4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，为了理解<strong class="kd iu"> <em class="kz">我们为什么需要Webpack，</em> </strong>我们需要理解<strong class="kd iu">开发</strong>和<strong class="kd iu">生产</strong>代码的区别。</p><h2 id="03e6" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated">开发Vs生产？</h2><p id="7d5c" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">开发代码</em> </strong>就是开发者和程序员一起工作的代码。</p><ul class=""><li id="2718" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated">在进行一个项目时，如果开发人员只使用一个有数千行代码的<strong class="kd iu"> 'style.css' </strong>或<strong class="kd iu"> 'index.js' </strong>文件，那么我们的代码将很容易变得<strong class="kd iu">过度拥挤</strong>和<strong class="kd iu">难以管理</strong>。</li><li id="4222" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">因此，根据项目的<em class="kz">大小</em>和<em class="kz">范围</em>，不同的设置用于将应用程序分割成更小的组件，这些组件组合在一起形成完整的应用程序。这使得我们的代码更加<strong class="kd iu"> <em class="kz">可读，可伸缩，</em> </strong>和<strong class="kd iu"> <em class="kz">易于管理。</em>T45】</strong></li></ul><p id="7a96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">例如</strong> —本教程的开发项目结构即源代码(<em class="kz"> src) </em>看起来像是—</p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/983e22d26c41afd57b96516c64785f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*XSOt0W5K0SG_7OgV6riCtw.png"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd lc">开发设置</strong></figcaption></figure><p id="6cd1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见有多个<strong class="kd iu">。scss，。js </strong>文件出现在我们的源代码中。所有这些文件都是相互关联的。我已经把我所有的<strong class="kd iu"> sass </strong> <strong class="kd iu">分部文件</strong> ( <em class="kz">以_ </em>开头的文件)导入到了'<strong class="kd iu"> main.scss' </strong>和我所有的。<strong class="kd iu"> js </strong>文件如<strong class="kd iu"> feature1 </strong>、<strong class="kd iu"> feature2 </strong> …等在<strong class="kd iu"/><strong class="kd iu">【index . js】中。index.js' </strong>看起来会像这样<strong class="kd iu"> — </strong></p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/d4d92e11784aa3bb81342e99fbc8c12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0XO6k6-OwTEEmGPj7bf-SQ.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd lc"> index.js </strong></figcaption></figure><p id="1ea0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">生产代码</em> </strong>是指将在<strong class="kd iu">服务器</strong>上<strong class="kd iu">运行</strong>的最终代码，即用户将与之交互的代码。对于用户来说，代码库如何在幕后拆分和开发并不重要，因为他们不必处理代码，对他们来说重要的是应用程序是否工作以及效率是否太高。</p><p id="bdc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，在使用<strong class="kd iu">模块捆绑器</strong>的帮助下，我们最终的生产设置将看起来像这样—</p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d0a69abb8c5b58df4454b6792dba98ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*OVq4d_GdK7bfXP9-yERGFA.png"/></div></figure><p id="10f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，在'<strong class="kd iu"> js' </strong>文件夹内的'<strong class="kd iu"> dist' </strong>文件夹中只有一个'<strong class="kd iu"> bundle.js' </strong>文件。此外，在'<strong class="kd iu"> dist' </strong>'文件夹中没有样式文件，但是所有的样式都可以工作。(虽然我会告诉你，你也可以单独提取你的<strong class="kd iu"> CSS </strong>文件。)</p><p id="8359" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注—</strong>表示<strong class="kd iu">的“分配”。</strong>这只是一个标准名称，用于<strong class="kd iu">生产</strong>代码。同样，如果我查看一下<strong class="kd iu"> bundle.js </strong>，它看起来会是这样的——</p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/9f8793145db4ee247c489555baa490b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8mQ49K1VIRc3us_voLwsA.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd lc"> bundle.js </strong></figcaption></figure><p id="5b62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成<strong class="kd iu">胡言乱语</strong>！！。但是所有这些代码都是有效的。由于<strong class="kd iu">优化</strong>的缘故，它看起来就像这样，所以最终的捆绑文件是<strong class="kd iu">缩小、压缩的，</strong>和<strong class="kd iu">比</strong>小。</p><p id="69f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">结论— </strong> Webpack将对我们的源代码/开发代码(即<strong class="kd iu">“src”</strong>文件夹)进行一些转换，并将为我们提供最终优化的生产代码(即<strong class="kd iu">“dist”</strong>文件夹)。</p><p id="a14c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了了解<strong class="kd iu">‘web pack’</strong>是如何配置的，让我们创建一个项目</p><h2 id="bd49" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">项目启动者— </strong></h2><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/0548ebf4deb54ab9d56b123e39351bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*1qOS9mHba4kEtoAQ6zF9Kg.png"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd lc">项目启动人</strong></figcaption></figure><p id="27f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经创建了一个<em class="kz">项目文件夹</em>，命名为—<strong class="kd iu">web pack-In-Depth</strong>(<em class="kz">随便你选什么名字。</em>)</p><ul class=""><li id="e44e" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated">在根级别，它包含一个<strong class="kd iu"><em class="kz">index.html</em></strong>文件和一个<strong class="kd iu"> <em class="kz"> src </em> </strong>文件夹。你甚至可以在你的src文件夹中使用index.html，但我更喜欢这样使用。)</li><li id="89fd" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated"><strong class="kd iu"> <em class="kz"> src </em> </strong>文件夹进一步包含三个子文件夹——<strong class="kd iu"><em class="kz">资产</em> </strong> <em class="kz">(所有图像)</em> <strong class="kd iu"> <em class="kz">、js、</em> </strong>和<strong class="kd iu"> <em class="kz"> sass </em> </strong>。</li></ul><h2 id="42b5" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">安装Webpack — </strong></h2><p id="8d6f" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">要安装<strong class="kd iu"> <em class="kz"> Webpack </em> </strong>我们需要安装2个软件包。打开终端，写下命令—</p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="61d2" class="mp lb it om b gy oq or l os ot"><strong class="om iu">npm install webpack webpack-cli --save-dev</strong></span></pre><ul class=""><li id="1a03" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated"><strong class="kd iu"> <em class="kz"> webpack — </em> </strong>包含所有<strong class="kd iu">“web pack”</strong>功能的软件包。</li><li id="f558" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated"><strong class="kd iu"> webpack-cli — </strong>允许我们使用<strong class="kd iu">“web pack”</strong>功能的软件包。早先它是'<strong class="kd iu"> webpack' </strong>包本身的一部分，但随着<strong class="kd iu"> 'webpack4' </strong>的出现，它被分离到自己的包中。</li></ul><h2 id="380c" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">配置Webpack — </strong></h2><p id="176b" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">为了配置'<strong class="kd iu"> webpack' </strong>，我们需要在项目的根级别创建一个'<strong class="kd iu"> webpack.config.js' </strong>文件。</p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/1f5e1c2fa23e970303281c3bcb931828.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*6DKp1aO7ge61xQjYCRZtBQ.png"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd lc"> webpack.config.js </strong></figcaption></figure><p id="26cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<strong class="kd iu"><em class="kz">web pack . config . js</em></strong>中，我们需要编写我们的项目配置并将其导出。</p><h2 id="0fd8" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">逐步配置web pack—</strong></h2><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h2 id="9f55" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated">Webpack使用常见的Js模块</h2><p id="4d03" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">Webpack在幕后使用<strong class="kd iu"> <em class="kz"> Node.js </em> </strong>和<strong class="kd iu"> <em class="kz"> Node.js </em> </strong>使用<strong class="kd iu"> <em class="kz">普通js模块</em> </strong>作为标准<strong class="kd iu"> <em class="kz"> </em> </strong>而不是<strong class="kd iu"> <em class="kz"> ES6模块、</em> </strong>这就是为什么要导出配置我们需要使用<strong class="kd iu"> <em class="kz">模块. exports </em> </strong>而不是 </p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="0842" class="mp lb it om b gy oq or l os ot"><strong class="om iu">module.exports = {}</strong></span></pre><h2 id="81f0" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated">进入</h2><ul class=""><li id="04ce" class="ly lz it kd b ke ma ki mb km mc kq md ku me ky of mg mh mi bi translated">入口点是指<strong class="kd iu">“web pack”</strong>应该开始捆绑模块的起点，即<strong class="kd iu">。</strong>主javascript文件<strong class="kd iu">‘index . js’</strong>(在我的例子中是<em class="kz"/>)</li></ul><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="e0cd" class="mp lb it om b gy oq or l os ot"><strong class="om iu">entry: "./src/js/index.js"</strong></span></pre><p id="5e14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">注意— </em> </strong>如果您已经创建了不同的项目结构，请相应地选择路径。</p><h2 id="d61d" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak"> <em class="ox">输出</em> </strong></h2><ul class=""><li id="c2da" class="ly lz it kd b ke ma ki mb km mc kq md ku me ky of mg mh mi bi translated"><strong class="kd iu">输出</strong>仅指最终<strong class="kd iu">捆绑</strong>文件应该出现的位置，即在<strong class="kd iu">‘dist’</strong>文件夹中。</li><li id="8c47" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">输出属性是一个<strong class="kd iu"> <em class="kz">对象</em> </strong>，它进一步由属性<strong class="kd iu"> <em class="kz">路径</em> </strong>和<strong class="kd iu"> <em class="kz">文件名组成。</em>T99】</strong></li><li id="6bba" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">path是指最后一个<strong class="kd iu">捆绑</strong>文件的<strong class="kd iu">绝对路径</strong>。</li><li id="479f" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">为了构造<strong class="kd iu">绝对路径</strong>，我们需要利用<strong class="kd iu"> Node.js </strong>内置的'<strong class="kd iu"> path' </strong>包。</li></ul><p id="95f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">导入路径包— </strong></p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="bdd0" class="mp lb it om b gy oq or l os ot"><strong class="om iu">const path = require("path");</strong></span></pre><p id="4ad8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">构建绝对路径— </strong></p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="8dde" class="mp lb it om b gy oq or l os ot"><strong class="om iu">path: path.resolve(__dirnanme,"dist")</strong></span></pre><ul class=""><li id="438e" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated"><strong class="kd iu"> path.resolve </strong>只是帮助我们将一个路径解析成一个<strong class="kd iu">绝对路径。__dirname </strong>引用当前工作项目文件夹<strong class="kd iu"> Webpack-In-Depth </strong>(在我的例子中)。<strong class="kd iu"> </strong>所以，<strong class="kd iu"> path.resolve(__dirname) </strong>会构造我们当前工作文件夹的绝对路径。</li><li id="61e0" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">在我当前的工作文件夹中，我希望我的最终<strong class="kd iu">捆绑</strong>文件出现在“<strong class="kd iu">dist”</strong>文件夹中。</li><li id="68ac" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated"><strong class="kd iu">文件名</strong>指最终捆绑文件的名称。<strong class="kd iu">捆绑</strong>。<strong class="kd iu"> js </strong>是使用的标准名称。(<em class="kz">你可以选择任何你想要的名字</em></li><li id="6aa7" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">我希望'<strong class="kd iu"> bundle.js' </strong>出现在<strong class="kd iu"> dist </strong>文件夹内的<strong class="kd iu"> 'js' </strong>文件夹中，这就是为什么—</li></ul><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="c6f4" class="mp lb it om b gy oq or l os ot"><strong class="om iu">filename: "js/bundle.js"</strong></span></pre><ul class=""><li id="055d" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated">如果您不想在'<strong class="kd iu"> dist' </strong>内创建另一个'<strong class="kd iu"> js' </strong>文件夹，请仅用<strong class="kd iu"> bundle.js </strong>替换<strong class="kd iu">js/bundle . js</strong>—</li></ul><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="6ff2" class="mp lb it om b gy oq or l os ot"><strong class="om iu">filename: "bundle.js"</strong></span></pre><h2 id="6258" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">装载机</strong></h2><p id="f070" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">Webpack是一个javascript模块捆绑器，但它仍然可以捆绑和处理其他类型的<strong class="kd iu">模块</strong>，如<strong class="kd iu">。css，。scss，。jpg，。png、</strong>等借助装载机。</p><ul class=""><li id="6b90" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated">加载器只是在每个文件的基础上应用某种转换。</li><li id="ebe6" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">要使用装载机，我们需要先安装它们。(<em class="kz">没有附带webpack </em>)</li><li id="aff2" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">要配置加载程序，我们需要指定<strong class="kd iu">模块</strong>属性。</li><li id="b5e0" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated"><strong class="kd iu">模块</strong>属性是一个<strong class="kd iu">对象</strong>，它进一步由<strong class="kd iu">规则</strong>数组组成。</li><li id="868f" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated"><strong class="kd iu">规则</strong>数组包含如何处理特定类型文件的规则集。</li></ul><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="1354" class="mp lb it om b gy oq or l os ot"><strong class="om iu">module : { <br/>   rules: [] <br/>}</strong></span></pre><p id="34ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">处理风格(。css，。scss文件)— </strong>为了处理样式，我们需要安装一些加载器—</p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="031a" class="mp lb it om b gy oq or l os ot"><strong class="om iu">npm install style-loader css-loader sass-loader node-sass --save-dev</strong></span></pre><ul class=""><li id="796f" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated"><strong class="kd iu"> sass-loader </strong> —它利用<strong class="kd iu"> node-sass </strong>包将sass代码转换成等价的CSS代码</li><li id="2e02" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">css-loader  —它将css代码转换成等价的Javascript代码。</li><li id="f398" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated"><strong class="kd iu">样式加载器</strong> —将等效的javascript代码附加到<strong class="kd iu"> DOM </strong>中。</li></ul><p id="2b90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">指定规则</strong></p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="b944" class="mp lb it om b gy oq or l os ot"><strong class="om iu">rules: [ <br/> { <br/>   test: /\.scss$/',<br/>   use: ['style-loader','css-loader', 'sass-loader']<br/> }<br/>]</strong></span></pre><ul class=""><li id="be84" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated"><strong class="kd iu">测试</strong>属性是一个<strong class="kd iu">正则表达式。</strong></li></ul><p id="02b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意——</strong><em class="kz">你</em> <strong class="kd iu"> <em class="kz"> </em> </strong> <em class="kz">不需要学习</em> <strong class="kd iu"> <em class="kz">正则表达式</em> </strong> <em class="kz">用装载机工作只要记住上面的模式就可以了。但是如果你想深入了解你可以查看我的文章</em><strong class="kd iu"><em class="kz"/></strong><a class="ae mj" href="https://medium.com/@alok.sharma61630/demystifying-regex-1-40fadf9db9d0?source=friends_link&amp;sk=3e8fd2d6c809eafe862f6799426548f0" rel="noopener"><strong class="kd iu"><em class="kz">揭秘RegEx </em> </strong> </a> <em class="kz">。</em></p><ul class=""><li id="9bbe" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated"><strong class="kd iu"> use </strong>属性指定应该使用哪些加载程序来处理文件。如果我们想传递一些额外的配置，它不一定是一个数组，也可以是一个对象。)</li></ul><p id="5b5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">上面的规则简单地说明了— </strong>所有以<strong class="kd iu">结尾的文件。scss扩展</strong>应该由这些加载器处理— <strong class="kd iu">样式加载器、css加载器、sass加载器</strong></p><p id="7911" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意— </strong>确保顺序与从<strong class="kd iu">右到左</strong>的评估顺序相同。同样，如果你没有使用<strong class="kd iu"> sass </strong> <em class="kz"> </em>也不需要使用<strong class="kd iu"> sass-loader </strong>简单地省略它。</p><h2 id="1df9" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">插件</strong></h2><ul class=""><li id="8e25" class="ly lz it kd b ke ma ki mb km mc kq md ku me ky of mg mh mi bi translated">插件允许我们对最终的捆绑文件进行转换，如<strong class="kd iu">‘bundle . js’</strong></li><li id="e93a" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">要使用插件，我们需要首先安装和导入它们。</li></ul><p id="b2fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> html-webpack-plugin — </strong>它在“<strong class="kd iu">dist”</strong>文件夹中创建一个新的<strong class="kd iu">index.html<em class="kz"/></strong>文件，并会自动将我们的<strong class="kd iu"> bundle.js </strong>注入其中。安装</p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="6455" class="mp lb it om b gy oq or l os ot"><strong class="om iu">npm install html-webpack-plugin --save-dev</strong></span></pre><p id="ec19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">导入— </strong></p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="98b7" class="mp lb it om b gy oq or l os ot"><strong class="om iu">const HtmlWebpackPlugin = require('html-webpack-plugin');</strong></span></pre><p id="093a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">配置插件— </strong>我们需要使用<strong class="kd iu"> new </strong>关键字创建并配置一个实例，该实例将被传递一个对象作为配置。</p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="fd83" class="mp lb it om b gy oq or l os ot"><strong class="om iu">plugins: [</strong></span><span id="d476" class="mp lb it om b gy oy or l os ot"><strong class="om iu">  new HtmlWebpackPlugin({</strong></span><span id="df05" class="mp lb it om b gy oy or l os ot"><strong class="om iu">   filename: "index.html",</strong></span><span id="6296" class="mp lb it om b gy oy or l os ot"><strong class="om iu">   template: "./index.html",</strong></span><span id="a6eb" class="mp lb it om b gy oy or l os ot"><strong class="om iu">  }),</strong></span><span id="436b" class="mp lb it om b gy oy or l os ot"><strong class="om iu">]</strong></span></pre><ul class=""><li id="8707" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated"><strong class="kd iu">文件名</strong> —指您要在<strong class="kd iu">‘dist’</strong>文件夹中创建的新Html文件的名称。(index.html是标准的名字，你可以选择任何你想要的名字)。</li><li id="9501" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated"><strong class="kd iu">模板— <em class="kz"> </em> </strong>指的是要将内容复制到新建文件中的文件。</li></ul><p id="58ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">所以上面的插件会</strong> —在从<strong class="kd iu">模板</strong>文件中复制所有内容后，在“<strong class="kd iu">dist”</strong>文件夹中创建一个新的<strong class="kd iu"> 'index.html' </strong>文件，并将<strong class="kd iu"> bundle.js </strong>文件注入其中。</p><p id="57e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意— </strong>因为我的<strong class="kd iu">index.html</strong>文件存在于根级别，这就是为什么—</p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="7a30" class="mp lb it om b gy oq or l os ot"><strong class="om iu">template: './index.html'</strong></span></pre><p id="be0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你的index.html<strong class="kd iu">文件夹</strong>存在于<strong class="kd iu"> src </strong>文件夹中，那么你需要再次创建一个<strong class="kd iu">绝对路径</strong>作为—</p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="ff7c" class="mp lb it om b gy oq or l os ot"><strong class="om iu">template: __dirname + './src/index.html'</strong></span></pre><p id="cc85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是只有这个设置不能正常工作，因为有一个主要问题<strong class="kd iu"/>。</p><h2 id="5813" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">问题</strong> —</h2><ul class=""><li id="93e4" class="ly lz it kd b ke ma ki mb km mc kq md ku me ky of mg mh mi bi translated">假设在我们的<strong class="kd iu">index.html</strong>文件中使用了一些图像。所有图像都需要一个<strong class="kd iu"> src </strong>属性。并且<strong class="kd iu">index.html</strong>中的每个<strong class="kd iu"> src </strong>属性的值是相对于<strong class="kd iu">资产</strong>文件夹来写的，就像—</li></ul><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/6414c001fda8916055306284e70e4f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CkcuRCtb36U7bR4s87czw.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd lc">相对于资产文件夹的路径</strong></figcaption></figure><p id="a8f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是由于<strong class="kd iu"> html-webpack-plugin </strong>会在<strong class="kd iu">‘dist’文件夹中新建一个<strong class="kd iu">index.html</strong>文件<strong class="kd iu"> </strong>，</strong>所以这个<strong class="kd iu">路径</strong>会对'<strong class="kd iu">dist</strong>' '<strong class="kd iu">index . html '</strong>无效，因为'<strong class="kd iu"> dist' </strong>文件夹中没有'<strong class="kd iu"> src' </strong>文件夹。所以为了使这些路径<strong class="kd iu">动态</strong>我们需要利用一些<strong class="kd iu">装载器。</strong></p><p id="0a52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">处理图像文件(。svg，。jpg，。png，。gif) — </strong>为了处理图像，我们需要使用<strong class="kd iu"> html加载器</strong>和<strong class="kd iu">文件加载器</strong>。</p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="32c1" class="mp lb it om b gy oq or l os ot"><strong class="om iu">npm install html-loader file-loader --save-dev</strong></span></pre><p id="0e32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">配置html和文件加载器— </strong></p><pre class="nu nv nw nx gt ol om on oo aw op bi"><span id="0f47" class="mp lb it om b gy oq or l os ot"><strong class="om iu">{ test: /\.html$/, use: ["html-loader"] },</strong></span><span id="dff4" class="mp lb it om b gy oy or l os ot"><strong class="om iu">{</strong></span><span id="df3f" class="mp lb it om b gy oy or l os ot"><strong class="om iu">   test: /\.(svg|png|jpg|gif)$/,</strong></span><span id="2e16" class="mp lb it om b gy oy or l os ot"><strong class="om iu">   use: {</strong></span><span id="79ee" class="mp lb it om b gy oy or l os ot"><strong class="om iu">     loader: "file-loader",</strong></span><span id="9d70" class="mp lb it om b gy oy or l os ot"><strong class="om iu">     options: {</strong></span><span id="9bdc" class="mp lb it om b gy oy or l os ot"><strong class="om iu">       name: "[name].[ext]",</strong></span><span id="5c3a" class="mp lb it om b gy oy or l os ot"><strong class="om iu">       outputPath: "img",  </strong></span><span id="a79b" class="mp lb it om b gy oy or l os ot"><strong class="om iu">     },</strong></span><span id="4eda" class="mp lb it om b gy oy or l os ot"><strong class="om iu">   },</strong></span><span id="85af" class="mp lb it om b gy oy or l os ot"><strong class="om iu">},</strong></span></pre><p id="d8a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">文件加载器规则</strong>简单地陈述了<strong class="kd iu"/>——所有那些以<strong class="kd iu">结尾的文件。svg，。jpg。png，。gif </strong>扩展名应该由<strong class="kd iu">文件加载器</strong>处理。</p><ul class=""><li id="0386" class="ly lz it kd b ke kf ki kj km oc kq od ku oe ky of mg mh mi bi translated"><strong class="kd iu">文件加载器</strong>会将<strong class="kd iu">‘src’</strong>中的【T66’‘index . html’中遇到的所有图像文件复制到<strong class="kd iu">‘dist’</strong>文件夹<strong class="kd iu">中。</strong></li><li id="a02b" class="ly lz it kd b ke mk ki ml km mm kq mn ku mo ky of mg mh mi bi translated">对于上面的例子——它将把<strong class="kd iu">webpack-banner.png</strong>文件从<strong class="kd iu">资产</strong>文件夹复制到一个“<strong class="kd iu">img”</strong>文件夹中作为<strong class="kd iu">webpack-banner.png(【名称】)。[ext]) </strong>在'<strong class="kd iu"> dist' </strong>文件夹内。</li></ul><p id="3dcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">“html-loader”</strong>将自动确定其绝对路径，并将其注入到新创建的“<strong class="kd iu">index . html”</strong>的“<strong class="kd iu">dist”</strong>文件夹中。所以最终的index.html文件将会是这样的—</p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/8cdb4e376a83a6d7fb69e8001664bbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*wmnsz9oF2Wz66CF9w2P75w.png"/></div></figure><h2 id="167c" class="mp lb it bd lc mq mr dn lg ms mt dp lk km mu mv lo kq mw mx ls ku my mz lw na bi translated"><strong class="ak">运行Webpack </strong></h2><p id="943d" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">只需在您的<strong class="kd iu"> 'package.json' </strong>中创建新的npm脚本<strong class="kd iu"> </strong>，并将'<strong class="kd iu"> webpack config.js </strong>作为配置传递给它。</p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/00ed00b205d3b6d04f764183f2259f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*0S9EOy-qykNjCpKP1ipTSg.png"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd lc"> npm脚本</strong></figcaption></figure><p id="ff60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">— <strong class="kd iu">模式开发</strong> —开发包相对较大，但优化很少。</p><p id="bbb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">— <strong class="kd iu">生产模式</strong> —生产捆绑包非常小，经过各种优化。</p><p id="f150" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只需在终端中以<strong class="kd iu"> npm run build </strong>或<strong class="kd iu"> npm run dev </strong>的身份运行这些脚本，就能看到<strong class="kd iu"> webpack的</strong>魔力。</p><p id="0b26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文到此为止。其他高级Webpack概念将在后续文章中讨论。如果你觉得这篇文章有帮助，请告诉我。敬请期待！！！</p></div></div>    
</body>
</html>