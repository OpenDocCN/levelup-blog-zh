<html>
<head>
<title>Building an API To Clear All the Caches of Your Spring Boot Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个API来清除Spring Boot应用程序的所有缓存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-an-api-to-clear-all-the-caches-of-your-spring-boot-application-2d0dfdfe71b3?source=collection_archive---------4-----------------------#2021-04-20">https://levelup.gitconnected.com/building-an-api-to-clear-all-the-caches-of-your-spring-boot-application-2d0dfdfe71b3?source=collection_archive---------4-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b81d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过按需清除所有缓存数据来避免一致性问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f1eae05d6df786c31f262da89c84c5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1419OXsajZZPyoG1-zX6wA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@czapp_arpad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">áRPád Czapp</a>拍摄的照片</figcaption></figure><p id="c929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓存提高了性能，但是也引入了<a class="ae ky" href="https://en.wikipedia.org/wiki/Cache_coherence" rel="noopener ugc nofollow" target="_blank">一致性问题</a>。这就是为什么在我的Spring Boot应用程序中启用缓存后，我意识到提供一个按需清除所有缓存的过程是多么重要。</p><p id="c854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">登录到您的服务器，手动释放您的应用程序的所有缓存数据<strong class="lb iu"> </strong>应该是最后和绝望的选择。因此，我开始寻找方法，为管理员提供一种可靠、安全的方式，在需要时清除所有缓存。幸运的是，这可以通过几行代码轻松实现。</p><p id="d030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看如何定义一个自定义API来驱逐Spring Boot应用程序的缓存。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c00d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建API</h1><p id="7fda" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们假设您的应用程序已经使用了一个缓存引擎，采用了<a class="ae ky" href="https://spring.io/guides/gs/caching/" rel="noopener ugc nofollow" target="_blank"> Spring缓存模块</a>。一切都被认为是正确配置的。</p><p id="7620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理缓存，Spring在启动时在内部创建了一个<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/CacheManager.html" rel="noopener ugc nofollow" target="_blank"><em class="mz">cache manager</em></a>bean。尽管Spring没有提供按需清除所有缓存的特性，但是您可以通过利用这个缓存管理器来实现这一点。</p><p id="79f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，它的<code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/CacheManager.html#getCacheNames--" rel="noopener ugc nofollow" target="_blank">getCacheNames()</a></code>方法返回您的管理器已知的缓存名称的集合。通过迭代它们，您可以检索当前正在处理的每个<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/Cache.html" rel="noopener ugc nofollow" target="_blank"> <em class="mz">缓存</em> </a>实例，并对每个实例调用<code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/Cache.html#clear--" rel="noopener ugc nofollow" target="_blank">clear()</a></code>方法。</p><p id="8367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种简单的方法，您可以定义一种安全的方式来清除Spring Boot应用程序中使用的所有缓存。这就是为什么设计一个API来实现这样的目标并不复杂，并且可以如下实现:</p><h1 id="d92a" class="mc md it bd me mf ne mh mi mj nf ml mm jz ng ka mo kc nh kd mq kf ni kg ms mt bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="a94f" class="mc md it bd me mf ne mh mi mj nf ml mm jz ng ka mo kc nh kd mq kf ni kg ms mt bi translated">科特林</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="92f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，您只需要自动连接已实现的<em class="mz"> CacheManager </em> bean，并遵循上述方法。通过将这个逻辑封装在一个公开的端点中，您实际上定义了一个触发器，无论何时调用API都可以激活它。</p><p id="04bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，只有在插入第一个条目时，缓存才会被初始化。这意味着在任何数据被缓存之前，您不会在<code class="fe na nb nc nd b">CacheManager</code>中看到任何可用的缓存。</p><p id="0484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，应该只允许少数选定的用户访问这个API。这就是为什么我建议实现一个定制的身份验证系统。如需进一步阅读，您可以查看我以前的文章，其中我展示了如何在Spring Boot实现这样的目标。</p><div class="nl nm gp gr nn no"><a href="https://betterprogramming.pub/how-to-implement-custom-token-based-authentication-in-spring-boot-and-kotlin-5b59b55c1de2" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">如何在Spring Boot和科特林实现自定义的基于令牌的身份验证</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">构建更安全的Spring Boot应用程序</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">better编程. pub</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks no"/></div></div></a></div><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-implement-basic-access-authentication-in-spring-boot-eaded2e33d19"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">如何在Spring Boot实现基本接入认证</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">让您的Spring Boot API更加安全</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc ks no"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f4a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><p id="fdec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我刚才所展示的，单个API可以对您的应用程序产生巨大的影响。类似地，随着项目的增长，您很容易忽略正在进行的工作或当前部署的内容。这就是为什么你应该通过<a class="ae ky" href="https://betterprogramming.pub/building-an-api-to-list-all-endpoints-exposed-by-spring-boot-645f1f64ebf3" rel="noopener ugc nofollow" target="_blank">定义一个API来列出Spring Boot </a>暴露的所有端点来保护自己。</p><div class="nl nm gp gr nn no"><a href="https://betterprogramming.pub/building-an-api-to-list-all-endpoints-exposed-by-spring-boot-645f1f64ebf3" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">构建一个API来列出Spring Boot公开的所有端点</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">不再迷失在你的后端</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">better编程. pub</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc ks no"/></div></div></a></div><p id="a5cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您不应该让您的缓存增长太多。这就是为什么<a class="ae ky" href="https://betterprogramming.pub/how-to-add-compression-to-caching-in-spring-boot-d4d21533167c" rel="noopener ugc nofollow" target="_blank">在Spring Boot缓存中添加压缩功能</a>变得不可避免。</p><div class="nl nm gp gr nn no"><a href="https://betterprogramming.pub/how-to-add-compression-to-caching-in-spring-boot-d4d21533167c" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">如何在Spring Boot的缓存中添加压缩</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">释放您的缓存</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">better编程. pub</p></div></div><div class="nx l"><div class="of l nz oa ob nx oc ks no"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de30" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b1c8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">处理缓存可能会带来一些只有彻底清理才能解决的问题。这正是你应该通过添加一些管理工具来保护自己的原因。正如我所展示的，实现一个API来清除Spring Boot应用程序的所有缓存并不复杂，在大多数情况下，它可以节省您的时间。</p><p id="7aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望这篇文章对你有所帮助。如有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>