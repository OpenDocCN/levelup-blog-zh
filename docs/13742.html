<html>
<head>
<title>Neat trick with Angular Http Interceptor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有角度的Http拦截器的巧妙技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/neat-trick-with-angular-http-interceptor-5ba8412da84b?source=collection_archive---------1-----------------------#2022-10-02">https://levelup.gitconnected.com/neat-trick-with-angular-http-interceptor-5ba8412da84b?source=collection_archive---------1-----------------------#2022-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢棱角分明。总有一些技巧可以让你的应用程序开发变得更容易。我不知道我怎么没早点想到这个。</p><p id="645c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，不久前，我写了关于从零开始实现页面加载器的文章。然而，我遗漏了一个小细节(bug ),我将在这里解决它。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="9e5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次重新创建这个页面加载器组件和服务。概念我就不再解释了，这个仅供参考。裸机再次实现:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/bc57af349ec25b2dff684342d7e444a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_AAfa4HNHIKovh2RsMF_mA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">pageloader.service.ts</figcaption></figure><p id="425a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跟踪装载机状态的简单服务。现在是组件:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lj"><img src="../Images/b79fe884ae8246a8eea0116eb2670cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sC_rqznCASSysD_O3A1X8w.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">pageloader.component.html</figcaption></figure><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lk"><img src="../Images/e2146a70ad722422396554f840a153ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Csg0toKYvpCj88bMb1nV8g.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">pageloader.component.css</figcaption></figure><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ll"><img src="../Images/60473091c5f0865e1a4a4b49df53eec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNsgwnjITEkVfWgQcuR13w.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">pageloader.component.ts</figcaption></figure><p id="af31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该组件订阅服务来显示/隐藏带有“加载”文本的div。还是那句话，我不在乎这里的风格。</p><p id="39b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们什么时候使用页面加载器呢？从服务器获取一些数据是一个常见的场景，所以让我们为此创建一个服务:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lm"><img src="../Images/846ef0d62c0eba7f000b51d8551ea3ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YrTbwr771Z60pqZR34k8Pw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">api.service.ts</figcaption></figure><p id="32b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我创建了一个很小的后端项目，只有一个端点来返回随机数据。它得到这个<em class="ln">延迟</em>参数，这样我就可以指定呼叫将持续多长时间。否则，我几乎可以立即得到结果。后端部分超出了本文的范围，您可以使用<code class="fe lo lp lq lr b">express.js</code>或其他东西来完成。</p><p id="47ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鉴于上述所有情况，从某个组件获取的内容应该是这样的:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ls"><img src="../Images/c7943c9b7b979279e87cc954d8df2a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhI2tj3MM16YDwoNGB10PA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">一些组件</figcaption></figure><p id="af71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须显示页面加载器，获取数据，然后在成功或错误响应中隐藏它。为了！每一个！该死的。Http呼叫！</p><p id="661f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果页面加载器每次都自动出现和消失，那不是很好吗？没错。我们可以从一个<code class="fe lo lp lq lr b">HttpInterceptor</code>调用它。</p><p id="9e99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拦截器主要用于将JWT附加到传出请求的授权头，但是没有什么可以阻止我们做更多的事情。您还可以拦截http调用的<strong class="jp ir">响应</strong>。<strong class="jp ir"> </strong>想象力是极限。所以让我们实现这样的拦截器:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lt"><img src="../Images/da26f2dda2dd3c15609b3d38d3e0bc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pez9dlECWbVKCHgfdUWIA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">httpCall.interceptor.ts</figcaption></figure><p id="21b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单的东西。有很多关于如何使用角度拦截器的教程，所以我不会在这里讨论细节。主要思想是使用<code class="fe lo lp lq lr b">rxjs/pipe</code>和<code class="fe lo lp lq lr b">rxjs/map</code>操作符，并检查<code class="fe lo lp lq lr b">HttpEvent</code>是请求类型还是响应类型。只需注入<code class="fe lo lp lq lr b">pageloaderService</code>并调用适当的动作。这样，我们可以像这样重写<code class="fe lo lp lq lr b">getData()</code>函数:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lu"><img src="../Images/aedc5cad71b6cef10de79be7ab0c7135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyG23Ww2bXyWAcDuF-pCTA.png"/></div></div></figure><p id="0fca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">页面加载器将会自动显示和隐藏。酷毙了。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="68e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，并不是一切都很好。我在之前的帖子中提到过我没有解决一个bug，这个bug在这里也一直存在。幸运的是，这很容易解决。完成所有拦截器的工作后，考虑下面这段代码:</p><pre class="ku kv kw kx gt lv lr lw lx aw ly bi"><span id="b05c" class="lz ma iq lr b gy mb mc l md me">apiService.getData(delay: 2 seconds).subscribe(...);<br/>apiService.getData(delay: 1 second).subscribe(...);</span></pre><p id="f624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在这里试图模拟的是不止一个组件从服务器获取数据的情况。这些操作可能需要不同的时间，但是拦截器会为每个请求显示/隐藏页面加载器。在上面的场景中，第一个http调用显示页面加载器，然后第二个调用再次显示页面加载器(页面加载器已经启动，所以还没有任何问题)，但是第二个调用在第一个调用完成获取数据之前完成，并隐藏了加载器。不太好。</p><p id="dd42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要跟踪有多少东西被称为显示/隐藏页面加载器函数。只有当比率为0时，我们才能安全地隐藏它。这很容易实现。第回<code class="fe lo lp lq lr b">PageloaderService</code>:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mf"><img src="../Images/fd9d0bd64a7ffda2e37b2d9404211ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtZ7uRX2RrkibkBfgOiLaA.png"/></div></div></figure><p id="a9ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常愚蠢但有效的修复。只需添加一个数组。我称之为<code class="fe lo lp lq lr b">jobs</code>。每当调用<code class="fe lo lp lq lr b">showLoader()</code>时，将一个元素推入其中。每当调用<code class="fe lo lp lq lr b">hideLoader()</code>时，弹出一个元素，检查长度是否为0。这样，您就知道所有的<em class="ln">【作业】</em>都已完成，并且您可以安全地隐藏加载程序。或者，你可以使用<code class="fe lo lp lq lr b">jobCount: number </code>变量来代替数组。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="0858" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恐怕就这样了。不完全是火箭科学，但这应该是一件好事，对不对？</p><p id="f262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读:)</p></div></div>    
</body>
</html>