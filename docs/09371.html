<html>
<head>
<title>Why you shouldn’t use namespaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不应该使用名称空间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-you-shouldnt-use-namespaces-c136af9723d?source=collection_archive---------7-----------------------#2021-08-02">https://levelup.gitconnected.com/why-you-shouldnt-use-namespaces-c136af9723d?source=collection_archive---------7-----------------------#2021-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4cf7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更重要的是，为什么不应该使用名称空间STD</h2></div><p id="cec9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都做过。我们发现在cpp文件的顶部写一行代码可以节省一些时间。但是总有一天，就像我一样，当你意识到使用名称空间STD可能不是一个好主意的时候。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d396b73ce25645a58484f6f203ee1414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1oS5T0WQXoB7ozGx"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">潘卡杰·帕特尔在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b008" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要理解名称空间到底是什么。名称空间是用于排序和组织代码的声明性区域，这在你使用多个库时特别有用。如果你想调用一个包含在命名空间中的函数，你必须告诉编译器这个函数在哪个命名空间中，例如标准库中的字符输出。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="adb3" class="lx ly iq lt b gy lz ma l mb mc">std::cout &lt;&lt; "something" &lt;&lt; std::endl;</span></pre><p id="301c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，为了使事情变得更容易，自1995年以来，我们就包含在C++标准中，我们有能力创建一个作用域，从本质上告诉编译器，当我们调用一个没有名称空间的函数时，要在名称空间和全局作用域中查找。对于单个名称空间来说，这很好，特别是如果您将它用于自己的自定义名称空间，但是假设您使用的是标准库，这可能会有点混乱。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="af5e" class="lx ly iq lt b gy lz ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;functional&gt;</span><span id="6513" class="lx ly iq lt b gy md ma l mb mc">void print_values(const std::vector&lt;int&gt;&amp; values, const std::function&lt;void(int)&gt;&amp; func)<br/>{<br/>    for (auto value : values)<br/>    {<br/>        func(value);<br/>    }<br/>}</span><span id="d69d" class="lx ly iq lt b gy md ma l mb mc">int main()<br/>{<br/>    std::vector&lt;int&gt; numbers = { 4,2,30,2,9 };<br/>    std::vector&lt;int&gt; numbers_2 = { 4,3,30,5,9 };<br/>    auto lambda = [&amp;numbers_2](int a) mutable{<br/>        auto iter = std::find(numbers_2.begin(), numbers_2.end(), a)<br/>        if (iter != numbers_2.end())<br/>        {<br/>            std::cout &lt;&lt; "Value: " &lt;&lt; a &lt;&lt; std::endl;<br/>            numbers_2.erase(iter);<br/>        }<br/>    };<br/>    print_values(numbers, lambda);<br/>}</span></pre><p id="b4fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以这个例子为例，它非常容易阅读，我们知道所有的函数来自哪里，但是假设我在顶部引入了一个名称空间STD。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="18cb" class="lx ly iq lt b gy lz ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;functional&gt;</span><span id="9900" class="lx ly iq lt b gy md ma l mb mc">using namespace std;</span><span id="6a97" class="lx ly iq lt b gy md ma l mb mc">void print_values(const vector&lt;int&gt;&amp; values, const function&lt;void(int)&gt;&amp; func)<br/>{<br/>    for (auto value : values)<br/>    {<br/>        func(value);<br/>    }<br/>}</span><span id="c57c" class="lx ly iq lt b gy md ma l mb mc">int main()<br/>{<br/>    vector&lt;int&gt; numbers = { 4,2,30,2,9 };<br/>    vector&lt;int&gt; numbers_2 = { 4,3,30,5,9 };<br/>    auto lambda = [&amp;numbers_2](int a) mutable{<br/>        auto iter = find(numbers_2.begin(), numbers_2.end(), a)<br/>        if (iter != numbers_2.end())<br/>        {<br/>            cout &lt;&lt; "Value: " &lt;&lt; a &lt;&lt; endl;<br/>            numbers_2.erase(iter);<br/>        }<br/>    };<br/>    print_values(numbers, lambda);<br/>}</span></pre><p id="3677" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这样看起来更干净，但它为调试你的程序增加了额外的一层，你看，因为我在snake case中编写我的函数，因为标准库在snake case中编写它的函数，如果不是因为函数在顶部的事实，你可能会误认为是标准库函数。</p><p id="03c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用命名空间std时，可能会出现其他问题。假设你是一个疯子，决定写一个打印函数，并把它叫做cout。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="34d2" class="lx ly iq lt b gy lz ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;string&gt;</span><span id="6b42" class="lx ly iq lt b gy md ma l mb mc">void cout(const std::string&amp; message)<br/>{<br/>    std::cout &lt;&lt; message &lt;&lt; std::endl;<br/>}</span><span id="858c" class="lx ly iq lt b gy md ma l mb mc">int main()<br/>{<br/>    using namespace std;</span><span id="2d55" class="lx ly iq lt b gy md ma l mb mc">    cout((string)"Hello world");<br/>}</span></pre><p id="4300" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于大多数编译器，这应该会抛出一个错误，因为它发现了函数“cout”的两个实例，一个在标准库中，一个在全局环境中。</p><p id="855c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用库时可能会出现一个不同但相似的错误。假设您创建了一个名为functions的库，还创建了一个名为logging的库。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="39d2" class="lx ly iq lt b gy lz ma l mb mc">function.h</span><span id="568c" class="lx ly iq lt b gy md ma l mb mc">namespace functions<br/>{</span><span id="fe8b" class="lx ly iq lt b gy md ma l mb mc">}</span><span id="25c6" class="lx ly iq lt b gy md ma l mb mc">logging.h</span><span id="3565" class="lx ly iq lt b gy md ma l mb mc">namespace logging<br/>{<br/>    std::string print(const std::string&amp; message)<br/>    {<br/>        //use the message to work out how significant the error is<br/>        std::cout &lt;&lt; "ERROR" &lt;&lt; std::endl;<br/>    }<br/>}<br/>------------------------</span><span id="629d" class="lx ly iq lt b gy md ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;string&gt;</span><span id="efb3" class="lx ly iq lt b gy md ma l mb mc">#include "logging.h"<br/>#include "functions.h"</span><span id="77fe" class="lx ly iq lt b gy md ma l mb mc">int main()<br/>{<br/>    using namespace logging;<br/>    using namespace functions;</span><span id="81ba" class="lx ly iq lt b gy md ma l mb mc">    print((std::string)"Hello world");<br/>}</span></pre><p id="edaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您决定更新functions名称空间，以包含一个print函数，该函数恰好与logging名称空间中的函数同名，并采用相同的参数，但它有不同的输出。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="89de" class="lx ly iq lt b gy lz ma l mb mc">function.h</span><span id="7f64" class="lx ly iq lt b gy md ma l mb mc">namespace functions<br/>{<br/>    std::string print(const std::string&amp; message)<br/>    {<br/>        std::cout &lt;&lt; message &lt;&lt; std::endl;<br/>    }<br/>}</span><span id="e6c1" class="lx ly iq lt b gy md ma l mb mc">logging.h</span><span id="7f54" class="lx ly iq lt b gy md ma l mb mc">namespace logging<br/>{<br/>    std::string print(const std::string&amp; message)<br/>    {<br/>        //use the message to work out how significant the error is<br/>        std::cout &lt;&lt; "ERROR" &lt;&lt; std::endl;<br/>    }<br/>}<br/>------------------------</span><span id="2f82" class="lx ly iq lt b gy md ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;string&gt;</span><span id="b47d" class="lx ly iq lt b gy md ma l mb mc">#include "logging.h"<br/>#include "functions.h"</span><span id="92c2" class="lx ly iq lt b gy md ma l mb mc">int main()<br/>{<br/>    using namespace logging;<br/>    using namespace functions;</span><span id="c937" class="lx ly iq lt b gy md ma l mb mc">    print((std::string)"Hello world");<br/>}</span></pre><p id="dbf6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有一个问题，因为我们将会得到未定义的行为，并且没有任何逻辑原因使调试程序成为一场噩梦。</p><p id="4fb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到为什么不应该特别使用“名称空间标准”的问题。在YouTube上有一个很棒的视频，由切诺制作，讲述了为什么你不应该使用“名称空间标准”。该视频使用了EA的开源STL库的例子，该库在Frosbite引擎中使用。EA STL是EA的std库的等价物，所以通过使用“命名空间STD”和“命名空间STL ”,你会遇到许多问题(这些问题不容易解决，因为它们首先出现是没有意义的),因为许多函数名在两个库之间共享。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><p id="ee0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以名称空间本身真的很好，它们有助于使代码更有组织，并且它们允许你知道函数来自哪里，而不是你看你的cpp文件中有什么头文件，然后猜测那个函数来自哪里。我将以一些该做和不该做的事情来结束这篇文章。</p><ul class=""><li id="7dc2" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">不要使用命名空间std，但是如果一定要在小范围内使用if。</li><li id="af23" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">在任何情况下都不要在头文件中使用名称空间std，那会直接导致错误。</li><li id="bc71" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">一定要使用名称空间，它们会让你的代码更有条理。</li><li id="49b1" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">最后，如果你要使用名称空间STD，不要写与标准库中的函数同名的函数。</li></ul></div></div>    
</body>
</html>