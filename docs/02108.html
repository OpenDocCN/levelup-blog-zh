<html>
<head>
<title>Conditional Statements are a Code Smell — Here is Your Relief</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">条件语句是一种代码气味——这是您的解脱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/conditional-statements-are-a-code-smell-here-is-your-relief-38e50c023708?source=collection_archive---------0-----------------------#2020-02-19">https://levelup.gitconnected.com/conditional-statements-are-a-code-smell-here-is-your-relief-38e50c023708?source=collection_archive---------0-----------------------#2020-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/abc53fab2dbf3101805a5beb1a347cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EUziEx6RAz7YyyWaOgsyw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">蒂莫西·戴克斯在<a class="ae kc" href="https://unsplash.com/s/photos/condition?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">条件语句，如if-else和switch，是任何编程语言的核心。我们日复一日地使用它们，但令人惊讶的是，它在面向对象编程语言(OOP)中被视为一种代码味道。如果你想知道为什么我会这样，那么这篇文章是为我们写的。</p><p id="ff00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们深入之前，让我们理解OOP中两个非常重要的坚实原则的概念</p><ol class=""><li id="dffd" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://medium.com/@itIsMadhavan/single-responsibility-principle-a-beginners-note-cb1eaba1fecd" rel="noopener">单一责任原则</a></li><li id="715a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://stackify.com/solid-design-open-closed-principle/" rel="noopener ugc nofollow" target="_blank">开闭原理</a></li></ol><h2 id="814a" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">单一责任原则</h2><p id="8a04" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">Robert C. Martin将单一责任原则描述为:</p><p id="5416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“一个类应该只有一个改变的理由。”</p><p id="b01a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Martin将责任定义为改变的<em class="mn">原因，并得出结论，一个类或模块应该有且只有一个改变(即重写)的原因。</em></p><p id="5574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，考虑一个编译和打印报告的模块。设想这样一个模块可以因为两个原因而被改变。首先，报告的内容可能会改变。第二，报告的格式可以改变。这两件事因不同的原因而改变；一个实质性的，一个化妆品。</p><p id="1037" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单一责任原则认为问题的这两个方面实际上是两个独立的责任，因此应该在不同的类或模块中。将两个在不同时间因不同原因而变化的事物联系在一起是一个糟糕的设计。</p><p id="6d3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让一个班级专注于一个单独的问题是很重要的，因为这样可以使班级更加强大。阅读<a class="ae kc" href="https://medium.com/@itIsMadhavan/single-responsibility-principle-a-beginners-note-cb1eaba1fecd" rel="noopener">这里的</a>获得更详细的解释。</p><h2 id="07bb" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">开/关原则</h2><p id="9629" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">Robert C. Martin认为这个原则是“面向对象设计最重要的原则”。他将开/关原则描述为:</p><p id="0041" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">“软件实体(类、模块、功能等。)应该对扩展开放，但对修改关闭。”</strong></p><p id="d4fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个原则的一般方法是伟大的。它告诉你写你的代码，这样你就可以在不改变现有代码的情况下添加新的功能。这防止了对一个类的更改也需要修改所有依赖类的情况。阅读<a class="ae kc" href="https://stackify.com/solid-design-open-closed-principle/" rel="noopener ugc nofollow" target="_blank">这里的</a>获得更详细的解释。</p><p id="7d0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回到最初的问题，为什么条件语句是一个代码气味，并从一个简单的例子开始。</p><h1 id="0a16" class="mo lq iq bd lr mp mq mr lu ms mt mu lx mv mw mx ma my mz na md nb nc nd mg ne bi translated">问题:</h1><p id="1a2a" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">让我们假设下面的函数是一个名为“动物”的类的行为之一。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="0ceb" class="lp lq iq nk b gy no np l nq nr">private static String <strong class="nk ir">getSoundIfElseWay(</strong>String animal<strong class="nk ir">)</strong> <strong class="nk ir">{</strong> <br/> if <strong class="nk ir">(</strong>animal<strong class="nk ir">.</strong>equalsIgnoreCase<strong class="nk ir">(</strong>“Dog”<strong class="nk ir">))</strong> <br/>      return “Bark”<strong class="nk ir">;</strong> <br/> else <strong class="nk ir">if</strong> <strong class="nk ir">(</strong>animal<strong class="nk ir">.</strong>equalsIgnoreCase<strong class="nk ir">(</strong>“Cat”<strong class="nk ir">))</strong> <br/>      return “Mew”<strong class="nk ir">;</strong> <br/> else <strong class="nk ir">if</strong> <strong class="nk ir">(</strong>animal<strong class="nk ir">.</strong>equalsIgnoreCase<strong class="nk ir">(</strong>“Lion”<strong class="nk ir">))</strong> <br/>      return “Roar”<strong class="nk ir">;</strong> <br/> return “”<strong class="nk ir">;</strong> <br/><strong class="nk ir">}</strong></span></pre><p id="ee17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们有一个条件块，它根据对象的类型执行各种操作。这显然违反了单一责任原则。SRP提倡<strong class="kf ir"> a类</strong>应该有<strong class="kf ir">一个责任，</strong>但是拥有“狗”、“狮子”和“猫”的行为或责任显然违反了这一点。</p><p id="5904" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，这也违反了开/关原则。现在考虑我们需要实现一只“老虎”的声音，为了得到它，我们需要在上面的函数中再添加一个“else if”条件。当“动物”试图扩展一个行为时，这会迫使它进行修改，使其<strong class="kf ir">为修改而打开，为扩展而关闭。</strong>每次当我们想要添加/扩展任何功能时，我们都应该去更改它的源代码。</p><p id="d6ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在很明显，这里有条件的是一个<em class="mn">码闻</em>。那我们怎么解决呢？</p><p id="f949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几个从代码中移除条件的重构方法。</p><ol class=""><li id="8d7e" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><em class="mn">用状态/策略恢复条件</em></li><li id="6c6e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><em class="mn">用多态性恢复条件</em></li></ol><h1 id="5fb1" class="mo lq iq bd lr mp mq mr lu ms mt mu lx mv mw mx ma my mz na md nb nc nd mg ne bi translated">用多态恢复条件句</h1><p id="3d17" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="mn">多态性</em> </a> <em class="mn"> </em>在一个很幼稚的翻译中的意思是<em class="mn">名称相同，逻辑不同</em>。</p><p id="2cc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在大多数情况下，当我们用多态替换条件时，我们处理的是一个<em class="mn">子类型多态</em>。OOP中的这种多态性意味着通过在子类中提供同名方法来改变方法行为的能力。让我们考虑OOP教程中最著名的例子:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="5282" class="lp lq iq nk b gy no np l nq nr">abstract class Shape <br/>{<br/>    abstract public int getArea();<br/>}<br/><br/>class Square extends Shape<br/>{<br/>    protected int length;<br/>   <br/>   <strong class="nk ir">@Override<br/></strong>   public int getArea() {<br/>        return length*length;<br/>    }<br/>}<br/><br/>class Triangle extends Shape<br/>{<br/>    protected int height;<br/>    protected int base;</span><span id="ba6d" class="lp lq iq nk b gy ns np l nq nr"><strong class="nk ir">    @Override</strong><br/>    public int getArea() {<br/>        return this.height * this.base / 2;<br/>    }<br/>}</span><span id="c9a1" class="lp lq iq nk b gy ns np l nq nr">Shape square = new Square(4);<br/>square.getArea(); // 4<br/><br/>Shape triange= new Triange(2,4);<br/>triange.getArea(); // 4</span></pre><p id="b152" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码非常清楚地展示了子类型多态性。我们有一个基本类型<code class="fe nt nu nv nk b">Shape</code>和两个子类型(规格):<code class="fe nt nu nv nk b">Square</code>和<code class="fe nt nu nv nk b">Triangle</code>。这里的方法<code class="fe nt nu nv nk b">getArea()</code>代表了<em class="mn">多态</em>的定义:“相同的名字，不同的逻辑”。</p><blockquote class="nw"><p id="7f85" class="nx ny iq bd nz oa ob oc od oe of la dk translated"><em class="og">多态</em>:“同名，不同逻辑”</p></blockquote><p id="cb80" class="pw-post-body-paragraph kd ke iq kf b kg oh ki kj kk oi km kn ko oj kq kr ks ok ku kv kw ol ky kz la ij bi translated">现在让我们再次回到“Animal”类，实现多态方式:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="3a3b" class="lp lq iq nk b gy no np l nq nr">public abstract class Animal <strong class="nk ir">{</strong> <br/>    public abstract String <strong class="nk ir">say();</strong> <br/><strong class="nk ir">}</strong></span><span id="b836" class="lp lq iq nk b gy ns np l nq nr">public class Dog extends Animal<strong class="nk ir">{</strong>       <br/>   <strong class="nk ir"> @Override </strong>      <br/>    public String <strong class="nk ir">say()</strong> <strong class="nk ir">{</strong>            <br/>     return "Bark"<strong class="nk ir">;</strong>       <br/>    <strong class="nk ir">}</strong>  <br/><strong class="nk ir">}</strong></span><span id="a8bf" class="lp lq iq nk b gy ns np l nq nr">public class Cat extends Animal<strong class="nk ir">{</strong>       <br/>   <strong class="nk ir"> @Override</strong>       <br/>    public String <strong class="nk ir">say()</strong> <strong class="nk ir">{</strong>            <br/>     return "Meow"<strong class="nk ir">;</strong>       <br/>    <strong class="nk ir">}</strong>  <br/><strong class="nk ir">}</strong></span><span id="737e" class="lp lq iq nk b gy ns np l nq nr">public class Lion extends Animal<strong class="nk ir">{</strong>       <br/>   <strong class="nk ir"> @Override </strong>      <br/>    public String <strong class="nk ir">say()</strong> <strong class="nk ir">{</strong>            <br/>     return "Roar"<strong class="nk ir">;</strong>       <br/>    <strong class="nk ir">}</strong>  <br/><strong class="nk ir">}</strong></span></pre><p id="c343" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，Animal类被简化了，所有的逻辑都移到了各自的类中。</p><p id="4488" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的实现通过将行为/责任封装在相应的类中来理解单一责任原则。首先，所有动物的行为都被封装在一个类中，使得这个类违反了单一责任原则。现在我们被分成了独立的子类，我们把责任推给了它们，所以“狮子”行为的任何变化现在都是狮子的责任，而不是“动物”的责任。</p><p id="0418" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的实现也遵循了开放/封闭的原则，让我们看看，</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="2fad" class="lp lq iq nk b gy no np l nq nr">private static String <strong class="nk ir">getSoundPolymorphicWay(</strong>Animal animal<strong class="nk ir">){<br/>     </strong>return animal<strong class="nk ir">.</strong>say<strong class="nk ir">();</strong> <br/><strong class="nk ir">}</strong></span></pre><p id="29f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看上面的方法，它依赖于抽象(动物类)，所以任何实现抽象的类都可以在这个方法上工作。同样，如果需要实现一个新的行为，比如说“老虎”,我们不需要在实现<strong class="kf ir"> getSoundPolymorphicWay() </strong>和抽象<strong class="kf ir">动物中做任何改变。</strong></p><p id="b1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以为“Tiger”创建一个新类。这证明了“Animal”对进一步扩展是开放的，仍然不强制修改，无论是在“<strong class="kf ir"> getSoundPolymorphicWay </strong>”这样的实现中，还是在它本身。</p><h1 id="84b0" class="mo lq iq bd lr mp mq mr lu ms mt mu lx mv mw mx ma my mz na md nb nc nd mg ne bi translated">利益</h1><ul class=""><li id="725b" class="lb lc iq kf b kg mi kk mj ko om ks on kw oo la op lh li lj bi translated">这种技术遵循<em class="mn">告诉-不要问</em>原则:不是询问对象的状态，然后基于此执行操作，而是简单地告诉对象它需要做什么，让它自己决定如何做，这要容易得多。</li><li id="88a5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la op lh li lj bi translated">移除重复的代码。你去掉了许多几乎相同的条件句。</li><li id="86ec" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la op lh li lj bi translated">如果你需要添加一个新的执行变体，你所需要做的就是添加一个新的子类，而不触及现有的代码(<em class="mn">开/闭原则</em>)。</li></ul><p id="a0da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您阅读我的文章。如果你认为它有用，请分享，喜欢，鼓掌，评论✌☺</p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><div class="nf ng nh ni gt ox"><a href="https://gitconnected.com/resume-builder" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">软件工程师简历生成器和示例| gitconnected</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">免费打造不到5分钟的高质量软件工程简历。同步您的个人资料，我们会处理…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">gitconnected.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl jw ox"/></div></div></a></div></div></div>    
</body>
</html>