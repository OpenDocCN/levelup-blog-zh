<html>
<head>
<title>JavaScript Promise Chaining — Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺链—基础知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-promise-chaining-basics-e2618c5e74a9?source=collection_archive---------7-----------------------#2020-07-01">https://levelup.gitconnected.com/javascript-promise-chaining-basics-e2618c5e74a9?source=collection_archive---------7-----------------------#2020-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c765" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">没有看起来那么难。代码、图表和截图。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6fc5cbec50c2b36f114df1d013796366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-fx9rLb2GLUtaFdB8dxlQ.jpeg"/></div></div></figure><p id="d940" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章解释了什么是承诺链以及它是如何工作的。你可以在我之前的一篇简单易懂的文章中找到关于承诺的基本解释。如果你是这个话题的新手，那么我建议你<a class="ae ln" href="https://medium.com/swlh/javascript-promise-basics-d8465d70a54f" rel="noopener">先读一下</a>。</p><p id="f13f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然承诺和承诺链可能看起来复杂和难以理解，但它们可以让我们的生活更轻松。正如Marijn Haverbeke在他的书《雄辩的JavaScript》中所写的那样——编程的艺术是控制复杂性的技巧。JavaScript语言中加入了帮助管理代码复杂性的承诺。</p><p id="6708" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我看来，让承诺变得具有挑战性的是所有在后台发生的事情，这些事情在阅读代码后并不明显。这就是理解基本概念如此重要的原因。</p><blockquote class="lo"><p id="dbd3" class="lp lq iq bd lr ls lt lu lv lw lx lm dk translated">“编程的艺术是控制复杂性的技巧”——马林·哈弗贝克</p></blockquote></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="ecf2" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">一点点承诺理论</h1><p id="cb4e" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">承诺是一个具有许多属性和方法的对象。它可能处于以下三种状态之一:</p><ul class=""><li id="a520" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated"><strong class="kt ir"> <em class="nl">待定</em> </strong>:初始状态，既不履行也不拒绝<br/>[[承诺状态]]:<em class="nl">待定</em>”</li><li id="bd31" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated"><strong class="kt ir"> <em class="nl">已完成</em> </strong>:操作成功完成<br/> [[PromiseStatus]]: " <em class="nl">已解决</em>"</li><li id="fccb" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated"><strong class="kt ir"> <em class="nl">被拒绝</em> </strong>:操作失败<br/>[[PromiseStatus]]::<em class="nl">被拒绝</em></li></ul><p id="7abf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用构造函数<em class="nl"> Promise() </em>创建了一个Promise的实例。首次创建承诺对象时，它处于“待定”状态。构造函数有一个参数——执行函数(解析器)。executor函数启动一个异步任务，并定义实现和拒绝承诺的条件。</p><p id="6873" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用<em class="nl"> then() </em>方法将成功和错误处理程序附加到承诺上。我们可以在承诺达成(即履行或拒绝)之前或之后这样做。如果一个处理程序被附加到一个已解决的承诺，那么它会被尽快调用。</p><p id="0979" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">成功和错误处理程序总是返回承诺。如果我们从处理程序返回一个值，那么处理程序将返回自动生成的已解决的承诺，该值就是它的值。这些自动生成的已解决承诺可以由开发人员定义的新的待定承诺来替换。为此，您只需从处理程序返回一个新的承诺。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="4eeb" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">承诺链—演示代码</h1><p id="3d25" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">虽然下面的演示代码对于这样的文章来说可能有点太长，但是它非常简单。它包含大量重复的代码。它创建了一个承诺，第一个承诺的成功处理程序创建了另一个待定的承诺。有一系列的2个<em class="nl"> then() </em>方法加上最后的一个<em class="nl"> catch() </em>方法。延迟函数用于模拟异步任务。</p><p id="7366" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我设计了这个简短的程序来探索承诺的基本概念，所以请随意复制和使用它。图2中的图表A应该使逻辑非常清晰。</p><p id="69fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，我们从第一个Promise executor函数开始第一个异步任务，并执行程序的其余部分。这开始了承诺链。所有同步代码都在第一个异步任务完成之前完成。当第一个异步任务完成时，我们开始第二个异步任务。这两个任务都有各自的成功和错误处理程序。然后，我们从链中返回最终解决的承诺。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">承诺链—演示代码</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/570fdedf437245fc2523a538820d3d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*_rR0r4z2rTHjKtgb1c11GA.png"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">图一。安慰</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/6ecef3092ee33076faf8a63db1a03db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Deb6HxXTnyYqNPW_4aHoXA.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">图二。承诺链图。a:演示代码——独立的错误处理程序，B:备选方案——一个通用的错误处理程序。</figcaption></figure><p id="6de4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">演示代码的主干是这一部分(第61–64行)…</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="022b" class="oe mg iq oa b gy of og l oh oi"><strong class="oa ir">let finalPromise = new Promise( promiseExecutor1 )</strong>  // EXECUTOR<br/><strong class="oa ir">.then( then1success, then1failure ) </strong>                // THEN 1<br/><strong class="oa ir">.then( then2success, then2failure )</strong>                 // THEN 2<br/><strong class="oa ir">.catch( commonErrorHandler )</strong>                        // CATCH</span></pre><p id="40bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们先看看这里发生了什么，而不要深入细节。我们用承诺构造函数<em class="nl"> Promise() </em>创建了一个新的承诺对象finalPromise。我这样命名Promise对象是有原因的。它从承诺链的末端得到什么。finalPromise要么获取由最后一个<em class="nl"> then() </em>方法返回的承诺，要么获取由<em class="nl"> catch() </em>方法返回的承诺。在此之前，它处于挂起状态。</p><p id="3947" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我们调用Promise构造函数<em class="nl"> Promise() </em>，用一个executor函数作为参数。执行者函数<em class="nl"> promiseExecutor1() </em>被马上调用(执行者1)。这是我们开始异步任务并定义成功和失败条件的地方。</p><p id="c15e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们用一个<em class="nl"> then() </em>方法(THEN 1)为第一个异步任务附加成功和错误处理程序。<em class="nl"> Then() </em>采用两个参数—函数:</p><ul class=""><li id="7775" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">如果异步任务成功完成，则调用第一个函数(从executor函数调用<em class="nl"> resolve() </em>)</li><li id="13e4" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">第二个在异步任务失败时调用(从executor函数调用<em class="nl"> reject() </em>)。</li></ul><p id="34fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">方法会自动创建并返回新的已解析的承诺，这样我们就可以为这些新的承诺附加更多的成功和错误处理程序。这些自动生成的承诺可以替换为我们定义的承诺。这就是我们开始第二个异步任务的方式。我们可以从第一个<em class="nl"> then() </em>方法(THEN 1)返回一个新的待定承诺，并使用下一个<em class="nl"> then() </em>方法(THEN 2)为该待定承诺附加成功和错误处理程序。</p><p id="d043" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后是<em class="nl"> catch() </em>方法。它非常类似于<em class="nl"> then() </em>方法，除了它只定义了在失败或错误的情况下做什么。一个<em class="nl"> then() </em>方法的第二个参数是可选的。这意味着我们可以定义在承诺兑现的情况下做什么，并跳过错误处理。错误将通过链传播，直到被某个东西捕获。这就是通常位于链末端的<em class="nl"> catch() </em>方法。见图2 B。</p><p id="0f59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们抛出一个错误并且没有错误处理程序，我们将从承诺链中返回一个被拒绝的承诺。</p><h2 id="bf7c" class="oe mg iq bd mh oj ok dn ml ol om dp mp la on oo mr le op oq mt li or os mv ot bi translated">承诺1</h2><p id="5b27" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">正如我已经提到的，一切都从第61行开始。这里，我们创建了一个新的承诺对象— finalPromise。我们使用Promise构造函数<em class="nl"> Promise() </em>来实现。构造函数接受一个参数，这个参数是执行函数— <em class="nl"> promiseExecutor1() </em>。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="8e65" class="oe mg iq oa b gy of og l oh oi"><strong class="oa ir">let finalPromise = new Promise( promiseExecutor1 )</strong>  // EXECUTOR</span></pre><p id="5812" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nl">第6行定义的promiseExecutor1() </em>马上调用。这个函数在控制台中打印一条消息，让我们知道第一个异步任务刚刚开始(或者即将开始)，然后它调用<em class="nl"> setTimeout() </em> —我们的异步任务，然后它终止。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="9546" class="oe mg iq oa b gy of og l oh oi">Starting 1st async operation (promiseExecutor1)</span></pre><p id="0cfa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在执行了这个executor函数之后，我们刚刚用<em class="nl"> Promise() </em>创建的承诺被挂起，因为<em class="nl"> promiseExecutor1() </em>没有立即调用<em class="nl"> resolve() </em>，并且因为我们将成功和错误处理程序附加到了该承诺上。</p><p id="24fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">传递给<em class="nl"> setTimeout() </em>(第8行)的回调函数在延迟后运行，打印另一条消息。这一次它让我们知道任务已经完成了(图1)。我们的异步任务是在延迟后解析承诺。因此，它通过调用<em class="nl">resolve()—</em>executor函数的第一个参数来解析承诺。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="74ee" class="oe mg iq oa b gy of og l oh oi">1st async operation DONE</span></pre><p id="fb4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该承诺以值“承诺1已解决”解决。如果我们没有附加一个<em class="nl"> than() </em>方法，那么finalPromise将得到它，而没有任何成功或错误处理。这很容易通过注释掉链中所有的<em class="nl"> then() </em>和<em class="nl"> catch() </em>方法来测试(第62-64行)。</p><p id="2ff5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，我们有一个<em class="nl"> then() </em>方法。完成承诺会触发其成功或错误处理程序。第一个解析的承诺由first <em class="nl"> then() </em>方法(THEN 1)处理。使用<em class="nl"> resolve() </em>解析承诺，因此调用第27行定义的成功处理程序<em class="nl"> then1success() </em>。</p><h2 id="f704" class="oe mg iq bd mh oj ok dn ml ol om dp mp la on oo mr le op oq mt li or os mv ot bi translated">然后1</h2><p id="6e34" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">第一个<em class="nl"> then() </em>方法在控制台(图1)中打印出它的名字“Then1”和一个箭头，以及它从上面的executor函数接收到的任何内容。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="c2cd" class="oe mg iq oa b gy of og l oh oi">Then1 &lt;- <strong class="oa ir">Promise 1 resolved</strong></span></pre><p id="cdec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种先<em class="nl">后</em>的方法值得我们注意一下。在我学习承诺的时候，有一段时间让我止步不前的是我对基本概念的不理解。</p><p id="d01d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nl"> Then() </em>方法总是返回承诺。如果你做了…</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="ac92" class="oe mg iq oa b gy of og l oh oi"><strong class="oa ir">return 7</strong>   // returns a new promise resolved with 7 as its value</span></pre><p id="0d1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…然后，您返回一个用该价值解决的新承诺，而不是价值本身。失败处理程序<em class="nl"> then1failure() </em>返回一个自动生成的解析承诺，其值为message1。</p><p id="02c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用自己的承诺替换自动生成的已解决的承诺。这正是我们在成功处理程序中所做的事情— <em class="nl"> then1success() </em>(第30行)。</p><h2 id="683d" class="oe mg iq bd mh oj ok dn ml ol om dp mp la on oo mr le op oq mt li or os mv ot bi translated">承诺2</h2><p id="8982" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">在第30行，我们创建了一个新的承诺，它运行第15行中定义的executor函数— <em class="nl"> promiseExecutor2() </em>。这个executor函数几乎与第一个相同。唯一的区别是字符串。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="1e61" class="oe mg iq oa b gy of og l oh oi"><strong class="oa ir">return new Promise(promiseExecutor2)</strong> // returns our new promise</span></pre><p id="d8a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，当我们创建承诺时，executor函数会立即运行。它打印一条消息并启动一个异步任务，即第二个任务，然后终止，让承诺处于未决状态。这个消息让我们知道第二个任务刚刚开始(或者在我们开始阅读它之前就开始了)</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="5af6" class="oe mg iq oa b gy of og l oh oi">Starting 2nd async operation (promiseExecutor2)</span></pre><p id="babe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的好处是，我们为第二个承诺定义的成功或错误处理程序只有在承诺完成后才会被调用。在此之前，如果有必要，我们可以处理来自第一个异步任务的响应，处理一些事件，等待，或者做任何我们想做的事情。</p><p id="3be8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<em class="nl"> promiseExecutor2() </em>中实现的1秒延迟之后，我们的第二个承诺得到解决。同样，我们打印一条消息，让我们知道第二个任务现在已经完成。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="835d" class="oe mg iq oa b gy of og l oh oi">2nd async operation DONE</span></pre><p id="f93f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个<em class="nl"> then() </em>方法的成功处理程序被调用—第40行。第二个异步任务已经完成，我们已经准备好处理从它那里收到的值。</p><h2 id="d583" class="oe mg iq bd mh oj ok dn ml ol om dp mp la on oo mr le op oq mt li or os mv ot bi translated">然后2</h2><p id="dd41" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">第二个成功处理程序<em class="nl"> then2success() </em>也与第一个非常相似。这里的两个主要区别是信息，更重要的是我们从中返回了什么。同样，其中一条消息(message2)告诉我们处理程序的名称以及它从第二个异步任务收到了什么。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="8930" class="oe mg iq oa b gy of og l oh oi">Then2 &lt;- <strong class="oa ir">Promise 2 resolved</strong></span></pre><p id="c793" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个通知这是链条的终点。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="4938" class="oe mg iq oa b gy of og l oh oi">Returning final resolved Promise</span></pre><p id="7910" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们返回一个字符串——message 2，而不是像以前那样返回一个新的待定承诺。然而，正如我已经提到的，这个字符串将被自动创建的resolved Promise所包装。换句话说，我们从第二个成功处理程序返回的是一个新的解析承诺，其值为该字符串。</p><p id="82fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">链中没有更多的<em class="nl"> then() </em>方法，最后一个成功处理程序返回了一个已解析的承诺。我们在第61行创建的finalPromise将获得这个解析的承诺，其值为message2。</p><p id="fda6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我一路上跟不上你，请看图A(图2)。</p><p id="3ff2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总结这一部分:</p><ul class=""><li id="6be4" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">首先，创建一个新的承诺(finalPromise)。它将一直处于未决状态，直到我们在承诺链的末端返回已解决的承诺。</li><li id="00c2" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">executor函数(<em class="nl"> promiseExecutor1() </em>)使用<em class="nl"> setTimeout() </em>将第一个承诺(Promise1)的解析延迟1秒。</li><li id="1577" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">我们使用<em class="nl"> then() </em>方法将成功和错误回调附加到第一个承诺。</li><li id="5f6a" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">我们使用第二个<em class="nl"> then() </em>方法将成功和错误回调附加到从第一个<em class="nl"> then() </em>方法返回的第二个承诺(Promise2)。</li><li id="614d" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">暂时什么也没发生</li><li id="afaa" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">1秒钟的延迟到期，第一个承诺得到解决。第一个承诺的成功处理程序称为。这个成功处理程序返回一个新的待定承诺，该承诺将在另一个1秒钟的延迟后得到解决。</li><li id="d8d9" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">暂时什么也没发生</li><li id="c1a5" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">第二个1秒延迟到期，第二个承诺(Promise2)得到解决。第二个承诺的成功处理程序返回一个自动生成的承诺，以我们的消息作为其值。</li><li id="385d" class="nc nd iq kt b ku nm kx nn la no le np li nq lm nh ni nj nk bi translated">最终诺言终于解决了。</li></ul><h2 id="535b" class="oe mg iq bd mh oj ok dn ml ol om dp mp la on oo mr le op oq mt li or os mv ot bi translated">如果…会怎样</h2><p id="0c37" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">最好是编写自己的代码来探索一个新概念，但我认为本文中展示的演示代码是一个很好的起点。可以使用'<em class="nl"> if' </em>语句轻松地重定向承诺流，并且可以使用图表作为地图来帮助您浏览链的逻辑。</p><p id="d122" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尝试从一个<em class="nl"> then() </em>方法中抛出一个错误，并移除所有错误处理程序。让<em class="nl"> catch() </em>方法处理错误。如果用<em class="nl"> setTimeout() </em>包装成功/错误处理程序的全部代码，会发生什么？尝试从成功/错误处理程序返回您自己的承诺。尝试将第三个<em class="nl"> then() </em>方法添加到链中。看多简单。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="ed46" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结束了</h1><p id="3015" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">显然，还有更多。然而，我相信这是学习如何使用承诺链的一个很好的起点。我认为学习更复杂概念的最好方法是一次一小步。</p><p id="27dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇文章是有用的。如果你有任何问题或意见，请告诉我。</p></div></div>    
</body>
</html>