<html>
<head>
<title>Fully Automated NextJS Builds/Deployments (GitHub, AWS ECR, Fargate Service, ECS)- Part 1/4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完全自动化的NextJS构建/部署(GitHub、AWS ECR、Fargate Service、ECS)——第1/4部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-1-4-6216e58dcb89?source=collection_archive---------3-----------------------#2022-04-19">https://levelup.gitconnected.com/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-1-4-6216e58dcb89?source=collection_archive---------3-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c22f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程的第一部分，我将展示如何在ECR(弹性容器注册中心)上将您的NextJS应用程序部署为Docker映像，并预先使用Terraform推出ECR。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/110cc8220234b5d89d3c400592ab960e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fh0Jw1OEv-kaj2DtY11gsw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片来源:stock.adobe.com</figcaption></figure><p id="f160" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如在上一篇文章中承诺的，这个教程是关于非常实际的东西。所以我就不赘述长篇大论的序言了，直接切入正题。本教程的目标是自动化一个NextJS应用程序，通过GitHub工作流使其成为AWS上的Fargate服务。</p><h1 id="fbfa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">教程的内容</h1><p id="b9fd" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">第一部分— Docker图像/ ECR平台部署&amp;推送图像。</strong></p><p id="1e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二部分—全面的GitHub集成和TF后端AWS/S3</p><p id="f026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三部分—在AWS上部署Fargate Terraform(基础设施即代码)</p><p id="0cb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四部分—为生产优化Dockerfile</p><h1 id="4a58" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">语境</h1><p id="f161" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">假设你正在构建一个超级酷的web应用程序，比如用NextJS。当然，您希望涉众能够尽快提供反馈，因此您需要定期提供反馈。Docker容器是做到这一点的好方法。例如，AWS或Azure等云技术为我们提供了从一开始就测试应用程序的可接受性和稳定性的绝佳机会。</p><p id="686a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将了解web应用程序的持续集成/部署(CI/CD)。从我的角度来看，我们在这里将要讨论的所有内容都是及时开发软件的基本部分和第一步。在这一点上，我还想指出，自动化解决方案的推出应该是开发人员工具箱的一部分。凭借我们现在拥有的所有工具和知识，部署绝不是项目结束时的一个孤立步骤。</p><p id="619c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在这个系列教程中，我将展示我们如何毫不费力地以完全自动化的方式获得一个NextJS应用程序“<em class="me">生产就绪</em>”。在今天的节目中，我们将学习如何创建一个容器注册表(ECR)和一个初始的Docker映像。</p><h1 id="bee4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">需要什么</h1><p id="c72f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你不需要在你的机器上安装太多东西来跟随这个教程。</p><ul class=""><li id="b8aa" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><a class="ae mo" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>版本14或更高</li><li id="9a52" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated">本地<a class="ae mo" href="https://docs.docker.com/desktop/" rel="noopener ugc nofollow" target="_blank"> Docker </a>安装，例如Docker桌面(Mac或Windows)</li><li id="918a" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated"><a class="ae mo" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>账号；Git CLI</li><li id="e25a" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated"><a class="ae mo" href="https://aws.amazon.com/de/free/?all-free-tier.sort-by=item.additionalFields.SortRank&amp;all-free-tier.sort-order=asc&amp;awsf.Free%20Tier%20Types=*all&amp;awsf.Free%20Tier%20Categories=*all" rel="noopener ugc nofollow" target="_blank"> AWS账号</a>(如果没有，可以免费创建一个)</li><li id="da47" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated"><a class="ae mo" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a></li><li id="5222" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated"><a class="ae mo" href="https://learn.hashicorp.com/tutorials/terraform/install-cli" rel="noopener ugc nofollow" target="_blank">地形</a></li></ul><p id="87b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，该教程可以转移到其他技术。所以你可以用另一个NodeJS集成来代替NextJS应用，或者用GitHub代替GitLab等。</p><p id="e03e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要检查NodeJS在您的机器上是否可用以及是哪个版本，您可以在终端中执行以下命令…</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="b252" class="mz lc iq mv b gy na nb l nc nd">$ node -v<br/>v16.14.2</span></pre><p id="7ef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…对于Git CLI和AWS CLI，如下所示:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="3856" class="mz lc iq mv b gy na nb l nc nd">$ git --version<br/>$ aws --version</span></pre><p id="e99f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么都有吗？让我们最终开始吧…</p><h1 id="7cd8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">NextJS应用示例</h1><p id="f486" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们首先使用“create-next-app”创建一个示例项目。为此，请转到要创建项目的源文件夹。然后调用下面的命令。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="78e5" class="mz lc iq mv b gy na nb l nc nd">$ yarn create next-app</span></pre><p id="48ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将项目命名为您想要的名称。在这个例子中，我将它命名如下。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="1c36" class="mz lc iq mv b gy na nb l nc nd">What is your project named? › cicd-tutorial</span></pre><p id="02e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按回车键。</p><p id="8ca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，转到项目文件夹，测试应用程序是否可执行。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="4113" class="mz lc iq mv b gy na nb l nc nd">$ cd cicd-tutorial<br/>$ yarn run dev<br/>yarn run v1.22.17<br/>$ next dev<br/>ready - started server on 0.0.0.0:3000, url: http://localhost:3000<br/>wait  - compiling...<br/>event - compiled client and server successfully in 821 ms (124 modules)</span></pre><p id="a813" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您看到这里显示的输出，那么一切正常。</p><p id="094a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在浏览器中你可以调用网址<a class="ae mo" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>。如果一切正常，您将看到以下输出。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/613bc8040f54e58d8988fd09e6870311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4Od0jxHMuc97lU9mn-XRA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">本地主机上的NextJS应用示例:3000</figcaption></figure><p id="5d0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">酷！那很容易。</p><h1 id="611d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">准备Docker图像</h1><p id="27c3" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">接下来，我们需要一个Dockerfile文件来封装应用程序。为此，在我们项目的根文件夹中创建一个名为“Dockerfile”的文件。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="15a0" class="mz lc iq mv b gy na nb l nc nd">$ touch Dockerfile</span></pre><p id="474e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将以下内容添加到刚刚创建的Dockerfile文件中。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="aaaf" class="mz lc iq mv b gy na nb l nc nd">FROM node:16-alpine<br/>WORKDIR /app<br/><br/>COPY package.json yarn.lock ./<br/>RUN yarn install<br/><br/>COPY . .<br/>RUN yarn build<br/><br/>USER node<br/><br/>EXPOSE 3000<br/><br/>CMD ["yarn", "start"]</span></pre><p id="a795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程的这一部分中，我们将不会着重于为生产使用准备docker文件。我们将在本系列的最后一部分中讨论这个问题。首先，我们将重点了解如何将我们的应用程序放入Docker容器，并将其作为图像放在AWS ECR上。</p><p id="e8e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建一个本地映像，看看docker文件是否是这样工作的。</p><p id="6b9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们在终端中运行以下命令。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="2d06" class="mz lc iq mv b gy na nb l nc nd">$ docker build -t &lt;image-name&gt; .</span></pre><p id="181f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me"> -t </em>选项意味着我们给图像命名。在我的例子中，它是“<em class="me"> cicd-tutorial </em>”。注意:末尾的点是必需的，这意味着Dockerfile应该在本地目录中使用。</p><p id="0216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用下面的命令，我们可以检查Docker映像是否在本地可用。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="4309" class="mz lc iq mv b gy na nb l nc nd">$ docker images                                 <br/>REPOSITORY      TAG       IMAGE ID       CREATED         SIZE<br/>cicd-turorial   latest    f43f5a09ac05   6 minutes ago   1.06GB</span></pre><p id="010d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，太好了！它在那里。</p><p id="c9b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们试试容器中的应用程序是否如预期的那样运行，并将端口3000映射到我们的本地网络，以便我们可以在浏览器中访问web应用程序。如果您使用了不同的名称，您必须相应地替换“<em class="me"> cicd-tutorial </em>”。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="cff7" class="mz lc iq mv b gy na nb l nc nd">$ docker run -p 3000:3000 cicd-turorial</span></pre><p id="ae95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，您可以在浏览器中再次运行该应用程序，应该会得到如上所示的相同输出。</p><p id="ea17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我所说的，我现在故意保持docker文件简单，因为我想稍后再讨论我们如何让应用程序“<em class="me">生产就绪</em>”。</p><h1 id="34b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">弹性容器注册(ECR)。</h1><p id="b817" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">好了，我们现在已经确保我们的应用程序是容器就绪，现在将着眼于在AWS上创建一个容器注册表。AWS提供了一种叫做弹性容器注册中心(简称ECR)的服务，它允许我们将容器映像部署到私有存储库中。</p><p id="ac56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，由于我是完全自动化的粉丝，我们不会手动创建这个注册表并点击菜单，而是使用Terraform。<a class="ae mo" href="http://terraform.io" rel="noopener ugc nofollow" target="_blank"> Terraform </a>是一个“基础设施即代码”(简称IAC)工具。IAC允许您用代码定义、部署和更新基础设施。基本上，运行应用程序所需的一切都用代码表示。即服务器、数据库、网络、配置、日志、文档、测试、部署流程。IAC是在云环境中运行现代应用程序的基础。</p><p id="8e67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用Terraform描述所需的基础设施，我们首先需要扩展我们项目的结构。</p><p id="8b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们在项目的根目录下创建一个名为“terraform”的新文件夹，以Terraform代码的形式映射那里的基础设施。</p><p id="269a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于创建ECR是一个初始步骤，我们稍后将需要另一个部署步骤来在弹性容器服务(ECS)之上创建<a class="ae mo" href="https://aws.amazon.com/de/fargate/" rel="noopener ugc nofollow" target="_blank"> Fargate服务</a>，我建议为容器注册表创建一个单独的子文件夹，如下所示。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="b4ea" class="mz lc iq mv b gy na nb l nc nd">$ mkdir terraform &amp;&amp; mkdir terraform/registry</span></pre><p id="2e49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有了下面的项目结构。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="5cc8" class="mz lc iq mv b gy na nb l nc nd">.<br/>├── pages<br/>│   └── api<br/>├── public<br/>├── styles<br/>└── terraform<br/>    └── registry</span></pre><p id="a407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一步中，我们将在<em class="me"> /terraform/registry </em>文件夹中创建一个名为“<em class="me"> main.tf </em>的文件，在这里我们将放置第一个简单的terraform脚本，它将用于创建我们的容器注册表。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="2924" class="mz lc iq mv b gy na nb l nc nd">terraform {<br/>  required_version = "&gt;= 1.0.11"<br/><br/>  required_providers {<br/>    aws = {<br/>      source  = "hashicorp/aws"<br/>      version = "&gt;= 3.68.0"<br/>    }<br/>    random = {<br/>      source  = "hashicorp/random"<br/>      version = "&gt;= 3.1.0"<br/>    }<br/>  }<br/>}<br/><br/>variable "registry_name" {<br/>  type = string<br/>}<br/><br/>variable "aws_region" {<br/>  type = string<br/>}<br/><br/>provider "aws" {<br/>  region = var.aws_region<br/>}<br/><br/>resource "aws_ecr_repository" "repository" {<br/>  name                 = var.registry_name<br/>  image_tag_mutability = "MUTABLE"<br/>  tags                 = {<br/>    Name = var.registry_name<br/>  }<br/><br/>  image_scanning_configuration {<br/>    scan_on_push = true<br/>  }<br/>}<br/><br/>output "registry_id" {<br/>  description = "The account ID of the registry holding the repository."<br/>  value = aws_ecr_repository.repository.registry_id<br/>}<br/><br/>output "repository_name" {<br/>  description = "The name of the repository."<br/>  value = aws_ecr_repository.repository.name<br/>}<br/><br/>output "repository_url" {<br/>  description = "The URL of the repository."<br/>  value = aws_ecr_repository.repository.repository_url<br/>}</span></pre><p id="ac73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们转到目录'<em class="me"> terraform/registry </em>'来初始化terraform。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="52cf" class="mz lc iq mv b gy na nb l nc nd">$ cd terraform/registry/<br/>$ terraform init<br/>Terraform has been successfully initialized!</span></pre><p id="2e8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文件<em class="me"> main.tf </em>中，定义了两个变量‘registry _ name’和‘AWS _ region’。当然，这些必须在我们部署之前设置好。为此，我们创建一个<em class="me"> tfvars </em>文件，在其中可以定义所有变量。通过为不同的环境使用不同的<em class="me"> tfvars </em>文件，我们可以在下一步中管理不同的阶段。我将在本教程的后续章节中解释这是如何工作的。</p><p id="655b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们将这两个变量放在一个单独的文件中。为此，我们在“terraform/registry”文件夹中创建文件<em class="me"> vars.tfvars </em>，内容如下。当然，值可以自由选择。所有可用AWS区域的有效值可在<a class="ae mo" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="2409" class="mz lc iq mv b gy na nb l nc nd">registry_name = "codewithrico-cicd-pipeline"<br/>aws_region = "eu-central-1"</span></pre><p id="ca02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用Terraform将ECR存储库部署到AWS帐户，必须在本地机器上将AWS_ACCESS_KEY_ID和AWS_SECRET_ACCESS_KEY设置为环境变量。</p><p id="abc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以从AWS控制台中的配置文件<em class="me">菜单项→安全凭证→访问密钥</em>中获取这些变量。但是，我建议在AWS帐户上设置SSO，并创建一个专用用户。之后，您可以访问您的AWS控制台，如下所示:https://&lt;your organization&gt;.awsapps.com/start#/。</p><p id="48c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">登录后，您可以简单地将那里的值复制并粘贴到终端中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/021c779aa3914964331f250c9ae71547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eo8BrGkCOb1bxaH6Yf8Htg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">将AWS凭据复制到此处。</figcaption></figure><p id="f466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还应该配置MFA。使用SSO的优点是AWS密钥和秘密仅在有限的时间内有效，例如12小时。</p><p id="5637" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您不知道如何在AWS上配置SSO，我将很快介绍更多细节。现在，在您的终端中设置这两个环境变量很重要。</p><p id="a032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们终于可以在AWS上推出我们的容器注册了。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="dcb2" class="mz lc iq mv b gy na nb l nc nd">$ terraform apply -auto-approve -var-file=vars.tfvars</span></pre><p id="456c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用<em class="me">-自动批准</em>选项，无需进一步输入。通过<em class="me"> -var-file </em>，我们显示了预定义变量的位置。如上所述，我将在下一集更详细地介绍使用<em class="me"> var </em>文件的目的。</p><p id="e895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成功部署后，我们应该在终端中看到以下输出。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="dedf" class="mz lc iq mv b gy na nb l nc nd">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.<br/><br/>Outputs:<br/><br/>registry_id = "&lt;your account id&gt;"<br/>repository_name = "codewithrico-cicd-pipeline"<br/>repository_url = "&lt;your account id&gt;.dkr.ecr.eu-central-1.amazonaws.com/codewithrico-cicd-pipeline"</span></pre><h1 id="686e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">推送图像</h1><p id="73ae" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们简要总结一下目前为止我们所做的工作:</p><ul class=""><li id="4804" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">创建了包括Dockerfile的示例项目</li><li id="c95e" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated">本地构建Docker映像并测试容器</li><li id="8a57" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated">为部署ECR而创建的地形代码。</li><li id="fb9f" class="mf mg iq jp b jq mp ju mq jy mr kc ms kg mt kk mk ml mm mn bi translated">使用Terraform在AWS上推出容器存储库。</li></ul><p id="f38f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们在容器注册表上少了一些生命，对吗？！所以是时候将我们的NextJS应用程序作为一个映像部署在ECR上了。</p><p id="4b26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要登录ECR，这样我们就可以将我们的Docker映像推送到那里。</p><p id="02ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们如下获取帐户ID。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="5949" class="mz lc iq mv b gy na nb l nc nd">$ export ACCOUNT_ID=$(aws sts get-caller-identity | jq -r .Account)</span></pre><p id="020d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个，我们已经可以通过终端几乎在ECR上登录了。我们只需要将AWS_REGION设置为容器存储库所在的环境变量。对我来说，这是法兰克福。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="1dea" class="mz lc iq mv b gy na nb l nc nd">$ export AWS_REGION=eu-central-1<br/>$ aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin {ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com</span></pre><p id="0b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果成功，我们将在终端中看到输出“登录成功”。</p><p id="b918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后一步，我们仍然需要正确地标记并推送到容器注册中心。首先，我们用下面的命令获得正确的存储库URL。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="d63e" class="mz lc iq mv b gy na nb l nc nd">$ export REPOSITORY_NAME=&lt;name of your registry&gt;<br/>$ export REPOSITORY_URL=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPOSITORY_NAME}</span></pre><p id="de27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为注册表或存储库的名称，您必须使用您在<em class="me"> vars.tfvars </em>中定义的名称。在下一期，我将更详细地介绍如何在GitHub工作流中完全自动地传递这些变量。</p><p id="98d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要立即推送映像，仍然需要执行以下步骤。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="60e0" class="mz lc iq mv b gy na nb l nc nd">$ docker build --platform linux/amd64 -t ${REPOSITORY_NAME}:latest .<br/>$ docker tag ${REPOSITORY_NAME}:latest ${REPOSITORY_URL}:latest<br/>$ docker push ${REPOSITORY_URL}:latest</span></pre><p id="ffbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们可以通过AWS控制台检查图像是否可用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/0d3fc8397c835bd5366f599958615a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXF9yVfps_od9GQu01r7Nw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">AWS ECR上的Docker图像</figcaption></figure><p id="4fed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如正文中已经宣布的，在教程的下一集，我们将深入GitHub工作流，并将ECR和图像的创建放入GitHub工作流中。因此，自动化和CI/CD工作流将是我们的下一个重点。</p><p id="6dfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae mo" href="https://github.com/codewithrico/cicd-tutorial-part-1" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看资源库。</p></div></div>    
</body>
</html>