<html>
<head>
<title>Occam’s Razor: Keeping the Code Short and Simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">奥卡姆剃刀:保持代码简短</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/occams-razor-keeping-the-code-short-and-simple-7ce4b60f87d4?source=collection_archive---------6-----------------------#2019-12-22">https://levelup.gitconnected.com/occams-razor-keeping-the-code-short-and-simple-7ce4b60f87d4?source=collection_archive---------6-----------------------#2019-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/70999b59e1844c49f81f597c49c2f41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiZt64Bfp287J6ej1pIk1g.jpeg"/></div></div></figure><h1 id="7187" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">背景</h1><p id="3f22" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我的组随机数发生器应用程序中，我的MVP(最小可行积)的一个特性是创建一个保存组特性。当用户点击“保存组”按钮时，它会将当前选项列表保存为一个新组。但是，此功能的核心功能是，如果它找到具有相同选项的现有已保存组，不管顺序如何，都会出现一个警告，说明具有您当前选项列表的组已经存在。</p><p id="16b4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如，保存的组#1具有人员列表，“Sam”和“Bob”。如果我的当前选项列表是“Bob”和“Sam ”,并且我试图将其保存为一个新组，那么将弹出一个警告，说明“具有您的当前选项列表的已保存组已经存在”。它是保存组#1”。</p><p id="e99a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这篇博客中，我将讲述我是如何创建算法来创建这个检查功能和奥卡姆剃刀的应用的。如果你不熟悉奥卡姆剃刀，维基百科的定义是:</p><blockquote class="lz ma mb"><p id="fd4d" class="kw kx mc ky b kz lu lb lc ld lv lf lg md lw lj lk me lx ln lo mf ly lr ls lt ij bi translated"><strong class="ky ir">奥卡姆剃刀……</strong>是解题<a class="ae mg" href="https://en.wikipedia.org/wiki/Principle" rel="noopener ugc nofollow" target="_blank">原理</a>说的是“实体没有必要就不要相乘。”</p></blockquote><h1 id="a2e1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">校验分组算法的首次尝试</h1><p id="5b4b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面的代码是我第一次尝试检查组算法。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7956" class="mq jz iq mm b gy mr ms l mt mu">function checkGroups(savedGroup, currentListOfOptions) {</span><span id="3249" class="mq jz iq mm b gy mv ms l mt mu">  savedGroupHash = {}</span><span id="f554" class="mq jz iq mm b gy mv ms l mt mu">  // populates the savedGroupHash based on the contents of the   savedGroup array parameter</span><span id="1caa" class="mq jz iq mm b gy mv ms l mt mu">  for (let i = 0; i &lt; savedGroup.length; i++){<br/>    savedGroupHash[savedGroup[i]] = true<br/>  }</span><span id="0dc6" class="mq jz iq mm b gy mv ms l mt mu">  // checks the savedGroupHash against the current list of options to check if savedGroupHash contains all of the list of options</span><span id="7b3a" class="mq jz iq mm b gy mv ms l mt mu">  for (let j = 0; j &lt; currentListOfOptions.length; j++) {<br/>    if (!savedGroupHash.hasOwnProperty(currentListOfOptions[j])) {<br/>      return false<br/>    }<br/>  }<br/>  <br/>  return true<br/>}</span></pre><p id="186f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意:这个算法的参数都是数组。每当下面提到“选项”时，它指的是它们各自数组中的元素。</p><p id="7719" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了对我如何处理这个算法有一个全面的了解，我创建了两个for循环。第一个<code class="fe mw mx my mm b">for</code>循环根据<code class="fe mw mx my mm b">savedGroup</code>参数的内容填充了<code class="fe mw mx my mm b">savedGroupHash</code>。对于键-值对，键是选项，默认值为<code class="fe mw mx my mm b">true</code>。该值(或缺少)将在第二个for循环中用作布尔值。在第二个for循环中，我对照<code class="fe mw mx my mm b">savedGroupHash</code>检查了<code class="fe mw mx my mm b">currentListOfOptions</code>参数中的每个选项。一旦<code class="fe mw mx my mm b">currentListOfOptions</code>中的一个选项没有包含在<code class="fe mw mx my mm b">savedGroupHash</code>中，我将返回<code class="fe mw mx my mm b">false</code>，这将立即退出该函数。如果没有，那么最后一行将返回<code class="fe mw mx my mm b">true </code>，因为它没有从第二个for循环返回<code class="fe mw mx my mm b">false</code>。</p><h1 id="3c02" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">测试检验组算法的第一次尝试</h1><p id="5e6d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">基于我在上一篇博客中正确测试的经验，我决定创建一些测试用例来彻底测试我的算法。在这个案例中，我想到了三种情况。</p><p id="d52f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">1.<code class="fe mw mx my mm b">savedGroup</code>和<code class="fe mw mx my mm b">currentListOfOptions</code>实际上有完全相同的选项，但顺序不同。这应该归<code class="fe mw mx my mm b">true</code>。<br/> 2。<code class="fe mw mx my mm b">savedGroup</code>包括与<code class="fe mw mx my mm b">currentListOfOptions</code>相同的选项，但比<code class="fe mw mx my mm b">currentListOfOptions</code>多。这应该会返回<code class="fe mw mx my mm b">false</code>。<br/> 3。<code class="fe mw mx my mm b">currentListOfOptions</code>包括与<code class="fe mw mx my mm b">savedGroup</code>相同的选项，但选项比<code class="fe mw mx my mm b">savedGroup</code>多。这应该会返回<code class="fe mw mx my mm b">false</code>。</p><p id="0eb8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第一种情况，我们用<code class="fe mw mx my mm b">savedGroup = [“Sam, “Bob”]</code>和<code class="fe mw mx my mm b">currentListOfOptions = [“Bob”, “Sam”]</code>。接下来，让我们将这两个变量作为参数输入到算法中，并在控制台记录返回值。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2d33" class="mq jz iq mm b gy mr ms l mt mu">const savedGroup = ["Sam", "Bob"]<br/>const currentListOfOptions = ["Bob", "Sam"]</span><span id="a88a" class="mq jz iq mm b gy mv ms l mt mu">console.log(checkGroups(savedGroup, currentListOfOptions)) //true</span></pre><p id="aa47" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">看起来这通过了我们的第一个测试。让我们继续第二个测试案例。</p><p id="4227" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第二种情况，我们用<code class="fe mw mx my mm b">savedGroup = [“Sam”, “Bob”, “Jane”]</code>和<code class="fe mw mx my mm b">currentListOfOptions = [“Bob”, “Sam”]</code>。接下来，让我们将这两个变量输入到算法中，并在控制台记录返回值。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1f59" class="mq jz iq mm b gy mr ms l mt mu">const savedGroup = ["Sam", "Bob", "Jane"]<br/>const currentListOfOptions = ["Bob", "Sam"]</span><span id="36f0" class="mq jz iq mm b gy mv ms l mt mu">console.log(checkGroups(savedGroup, currentListOfOptions)) //true</span></pre><p id="b688" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">看起来这没有通过我们的第二个测试。让我们继续第三个测试案例。</p><p id="70f3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第三种情况，我们用<code class="fe mw mx my mm b">savedGroup = [“Sam”, “Bob”]</code>和<code class="fe mw mx my mm b">currentListOfOptions = [“Bob”, “Sam”, “Jane”]</code>。接下来，让我们将这两个变量输入到算法中，并在控制台记录返回值。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7cca" class="mq jz iq mm b gy mr ms l mt mu">const savedGroup = ["Sam", "Bob"]<br/>const currentListOfOptions = ["Bob", "Sam", "Jane"]</span><span id="e7e5" class="mq jz iq mm b gy mv ms l mt mu">console.log(checkGroups(savedGroup, currentListOfOptions)) //false</span></pre><p id="7a99" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">看起来这通过了我们的第三个测试。</p><p id="5533" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">嗯……看起来这个算法并没有像预期的那样工作。在分析了我的代码之后，看起来每个参数的长度差异可能会导致代码失效。如果是这种情况，让我们改变算法来适应这一点。</p><h1 id="2a89" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">检验组算法的第二次尝试</h1><p id="2d39" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面的代码是我第二次尝试检查组算法。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="50c8" class="mq jz iq mm b gy mr ms l mt mu">function checkGroups(savedGroup, currentListOfOptions) {</span><span id="729a" class="mq jz iq mm b gy mv ms l mt mu">  const savedGroupHash = {}</span><span id="6e4a" class="mq jz iq mm b gy mv ms l mt mu">  for (let i = 0; i &lt; savedGroup.length; i++) {<br/>    savedGroupHash[savedGroup[i]] = 1<br/>  }</span><span id="385d" class="mq jz iq mm b gy mv ms l mt mu">  for (let j = 0; j &lt; currentListOfOptions.length; j++) {<br/>    if (savedGroupHash.hasOwnProperty(currentListOfOptions[j])) {<br/>      savedGroupHash[currentListOfOptions[j]] -= 1<br/>    } else {<br/>      savedGroupHash[currentListOfOptions[j]] = 1<br/>    }<br/>  }<br/>  <br/>  let sum = Object.values(savedGroupHash).reduce( (acc, current) =&gt; acc += current)</span><span id="1bf5" class="mq jz iq mm b gy mv ms l mt mu">  if (sum === 0) {<br/>    //this means the same group already exists<br/>    return true<br/>  } else {<br/>    //this means the group does not already exist<br/>    return false<br/>  }</span><span id="bd05" class="mq jz iq mm b gy mv ms l mt mu">}</span></pre><p id="2631" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了提供该算法的概述，有两个for循环、一个累加器和一个if/else语句。第一个for循环与第一个算法中的第一个for循环做的事情几乎相同，但它提供的是默认值1。第二个for循环操作<code class="fe mw mx my mm b">currentListOfOptions</code>中每个选项的<code class="fe mw mx my mm b">savedGroupHash</code>。如果选项在<code class="fe mw mx my mm b">savedGroupHash</code>中，将值减1，这将导致0，如果不是，则添加一个新的键-值对，其中键是选项本身，值是1，类似于第一个for循环。</p><p id="1edc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">接下来，累加器将对<code class="fe mw mx my mm b">savedGroupHash</code>中的所有值求和。<code class="fe mw mx my mm b">sum</code>的目的是帮助确定<code class="fe mw mx my mm b">savedGroup</code>数组和<code class="fe mw mx my mm b">currentListOfOptions</code>数组之间是否存在长度差异。我在if/else语句的条件比较中使用了<code class="fe mw mx my mm b">sum</code>，以便返回<code class="fe mw mx my mm b">true</code>或<code class="fe mw mx my mm b">false</code>。</p><p id="8a89" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在是最伤脑筋的部分:测试这个新算法。</p><h1 id="e32d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">测试检验组算法的第二次尝试</h1><p id="7373" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了保持一致性，我将使用与第一次测试算法时相同的测试用例。为了简洁起见，我还将结合所有三个测试用例的代码和结果。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fb56" class="mq jz iq mm b gy mr ms l mt mu">//Test Case #1<br/>const savedGroup = ["Sam", "Bob"]<br/>const currentListOfOptions = ["Bob", "Sam"]</span><span id="3edf" class="mq jz iq mm b gy mv ms l mt mu">console.log(checkGroups(savedGroup, currentListOfOptions)) //true</span><span id="8314" class="mq jz iq mm b gy mv ms l mt mu">//Test Case #2<br/>const savedGroup = ["Sam", "Bob", "Jane"]<br/>const currentListOfOptions = ["Bob", "Sam"]</span><span id="b6ae" class="mq jz iq mm b gy mv ms l mt mu">console.log(checkGroups(savedGroup, currentListOfOptions)) //false</span><span id="54d2" class="mq jz iq mm b gy mv ms l mt mu">//Test Case #3<br/>const savedGroup = ["Sam", "Bob"]<br/>const currentListOfOptions = ["Bob", "Sam", "Jane"]</span><span id="e28e" class="mq jz iq mm b gy mv ms l mt mu">console.log(checkGroups(savedGroup, currentListOfOptions)) //false</span></pre><p id="6a6e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">是啊！看起来算法现在正在按预期工作！我们终于可以收工了，但是…</p><h1 id="4a79" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">奥卡姆剃刀</h1><p id="43c1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第二天，当我在开发分组随机数发生器应用程序时，我又看了一眼检查分组算法。我一直对这个算法的成功咧嘴笑着(因为我花了1-2个小时来开发它)，直到我意识到第二个算法完全是多余的。我这么说是什么意思？</p><p id="27f7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们再来看看测试用例，以及为什么我改变了算法的第一次尝试。测试失败的根本原因的最初假设是每个参数的数组长度(如测试案例#2所示)。在算法的第二次尝试中，我操纵了<code class="fe mw mx my mm b">savedGroupHash</code>散列，以便跟踪<code class="fe mw mx my mm b">savedGroup</code>和<code class="fe mw mx my mm b">currentListOfOptions</code>之间的数组长度差异。<code class="fe mw mx my mm b">sum</code>是数组长度之差。如果<code class="fe mw mx my mm b">sum</code>为0，那么数组长度相同，返回<code class="fe mw mx my mm b">true</code>。任何其他值都将返回<code class="fe mw mx my mm b">false</code>。</p><p id="ac36" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从另一个角度来看，我实际上是在检查<code class="fe mw mx my mm b">savedGroup</code>和<code class="fe mw mx my mm b">currentListOfOptions</code>是否长度相同。因为我知道这两个参数是数组类型，所以我可以对每个参数调用<code class="fe mw mx my mm b">.length</code>来确认它们的长度是否相等。如果这些长度不同，我可以立即返回<code class="fe mw mx my mm b">false</code>。下面的代码代表了这个实现。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2370" class="mq jz iq mm b gy mr ms l mt mu">if (savedGroup.length !== currentListOfOptions.length) {<br/>  return false<br/>}</span></pre><p id="d773" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我现在可以用上面的代码修改算法的第一次尝试。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f2e0" class="mq jz iq mm b gy mr ms l mt mu">function checkGroups(savedGroup, currentListOfOptions) {</span><span id="542b" class="mq jz iq mm b gy mv ms l mt mu">  //insert new code here<br/>  if (savedGroup.length !== currentListOfOptions.length) {<br/>    return false<br/>  }</span><span id="91f6" class="mq jz iq mm b gy mv ms l mt mu">  savedGroupHash = {}</span><span id="62cd" class="mq jz iq mm b gy mv ms l mt mu">  for (let i = 0; i &lt; savedGroup.length; i++){<br/>    savedGroupHash[savedGroup[i]] = true<br/>  }</span><span id="a9d4" class="mq jz iq mm b gy mv ms l mt mu">  for (let j = 0; j &lt; currentListOfOptions.length; j++) {<br/>    if (!savedGroupHash.hasOwnProperty(currentListOfOptions[j])) {<br/>      return false<br/>    }<br/>  }<br/>  <br/>  return true<br/>}</span></pre><p id="d68a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">接下来你可能会猜到，我用这个算法运行了所有三个测试用例，并且通过了所有三个测试用例！</p><p id="e50b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我能够简化检查数组长度的代码</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5877" class="mq jz iq mm b gy mr ms l mt mu">for (let j = 0; j &lt; currentListOfOptions.length; j++) {<br/>    if (savedGroupHash.hasOwnProperty(currentListOfOptions[j])) {<br/>      savedGroupHash[currentListOfOptions[j]] -= 1<br/>    } else {<br/>      savedGroupHash[currentListOfOptions[j]] = 1<br/>    }<br/>  }<br/>  <br/>  let sum = Object.values(savedGroupHash).reduce( (acc, current) =&gt; acc += current)</span><span id="094f" class="mq jz iq mm b gy mv ms l mt mu">if (sum === 0) {<br/>    //this means the same group already exists<br/>    return true<br/>  } else {<br/>    //this means the group does not already exist<br/>    return false<br/>  }</span><span id="37c6" class="mq jz iq mm b gy mv ms l mt mu">}</span></pre><p id="1e5d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">到</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ba65" class="mq jz iq mm b gy mr ms l mt mu">if (savedGroup.length !== currentListOfOptions.length) {<br/>  return false<br/>}</span></pre><h1 id="617f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">检查组算法的第一次尝试中的意外结果</h1><p id="ab0e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当我在第一个未修改的算法和第二个算法之间进行测试时，我意识到第一个未修改的算法实际上在做什么。虽然它没有达到我的目的，即检查组是否相同，但它检查了一个组<code class="fe mw mx my mm b">currentListOfOptions</code>是否是另一个组<code class="fe mw mx my mm b">savedGroup</code>的<em class="mc">子集</em>。我无意中创建了一个检查子集的算法，而不是检查整个集合。现在，如果我将来需要检查子集，我不需要从头开始重新创建算法，并利用第一个未修改的算法。</p><h1 id="68fc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关键要点</h1><p id="af51" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在创建这个算法的时候，我学到了两个主要的经验。</p><ol class=""><li id="a293" class="mz na iq ky b kz lu ld lv lh nb ll nc lp nd lt ne nf ng nh bi translated"><strong class="ky ir">不要让你的想法过于复杂，把自己陷入兔子洞。</strong></li></ol><p id="22c2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在算法的第二次尝试中，我一直在脑海中思考这个算法一定包含某种复杂的解决方案，因为这不是一个共同的特征(这可能不是真的)。正如你所看到的，我用迂回的方式解决了这个bug，而这本来可以用三行代码来完成(如果我不使用花括号，就用一行代码)。如果你开始认为你的解决方案开始变得复杂，后退一步，重新评估你试图实现的目标，看看是否可以用一种不同的方式来表达，以获得可能更好的方法。</p><p id="1eba" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">2.总体来说，研究算法确实有所帮助。</p><p id="3357" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">像许多有抱负的软件开发人员一样，我会在LeetCode这样的网站上学习不同的数据结构和算法，并练习求解算法。起初，我真的不明白学习这些算法的目的，因为我觉得我永远不会在技术面试之外应用这些算法。然而，在我第一次尝试创建校验组算法时，我直观地使用了一个散列来进行比较。当我思考我为什么这样做时，我突然明白了，这是因为使用哈希是解决LeetCode算法的一种常见方法，可以将时间复杂度从O(n)提高到O(n)。我现在看到，我研究的算法可能在我最不期望的时候适用于我的代码。</p></div></div>    
</body>
</html>