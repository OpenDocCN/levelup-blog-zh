<html>
<head>
<title>Show me the Java Money!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给我看看Java的钱！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/show-me-the-java-money-d3dcc3a75f8a?source=collection_archive---------4-----------------------#2021-09-26">https://levelup.gitconnected.com/show-me-the-java-money-d3dcc3a75f8a?source=collection_archive---------4-----------------------#2021-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="08d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解Java Money API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/503d0d6b725ddb535c50eafb53ca0b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*808XUHNPDTv8zej0zLjyaQ.jpeg"/></div></div></figure><p id="34ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Java是构建业务应用程序的一种非常成功的语言，部分原因是它不断扩大的基础包含了一些库，使得处理“人类”约定变得更加容易。日期和时间就是一个很好的例子。曾几何时，在大多数编程语言中，日期只是一个非常大的数字，用来度量七十年代某个时间点的秒数。这几乎不足以代表人类阴谋集团周围的时间，包括时区，12小时与24小时时钟，月，周，周末，以及各种国际惯例。Java 8版本通过提供一个综合的时间包解决了很多这样的问题，这个时间包包含了人类的日期/时间概念以及经常需要的复杂计算和转换。</p><p id="db6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">金钱是另一个领域，人类习俗的非理性给程序员带来了很多头痛。Java Money API (JSR 354) 正试图缓解其中的一些问题。已经有几个教程展示了如何使用这个API，所以我将重点演示如何在一个半真实的Spring Boot应用程序中使用它，而不是回顾基础知识。</p><h1 id="b9b9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">构建应用程序</h1><p id="5e00" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">示例应用程序提供了一个REST端点来创建发票。后端为客户收取费用，并将其相加以创建发票。另外，费用是以不同的货币计算的。合同规定了发票中出现的货币。此外，合同规定了适用于总金额的可选折扣。示例应用程序可以在GitHub上找到:<a class="ae ln" href="https://github.com/algorythmist/java-money-spring-poc" rel="noopener ugc nofollow" target="_blank">https://github.com/algorythmist/java-money-spring-poc</a>。</p><h2 id="3491" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">实体模型和持久性</h2><p id="7c6f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">具有货币意识的实体(如费用)应该包含货币金额引用，而不是单独的金额和货币字段。这种封装将保证基于货币的计算的完整性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f702" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如注释所示，这是一个由关系数据库支持的JPA实体。假设99%的情况下持久化机制是Hibernate，我们需要一个自定义的<code class="fe mz na nb nc b">UserType</code>来告诉Hibernate如何将这个值与数据库相互转换。在这里可以找到这样一个自定义类型的示例实现:<a class="ae ln" href="https://github.com/algorythmist/java-money-spring-poc/blob/master/src/main/java/com/tecacet/money/repository/MonetaryAmountUserType.java" rel="noopener ugc nofollow" target="_blank">https://github . com/algorythmist/Java-money-spring-POC/blob/master/src/main/Java/com/tecacet/money/repository/monetaryamountusertype . Java</a></p><h2 id="ed5d" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">货币计算</h2><p id="d445" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">货币可以被实数乘除，但不能被其他货币对象乘除。相反，相同货币的钱可以相加和相减。尝试添加不同货币的货币会导致异常，如下测试所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2c0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Java Money API并没有选择一个特定的类来实现<code class="fe mz na nb nc b">MonetaryAmount. MonetaryAmount.getNumber()</code>的amount部分，而是返回一个<code class="fe mz na nb nc b">NumberSupplier</code>,后者又返回一个可以转换为Number实现的<code class="fe mz na nb nc b">NumberValue</code>。例如，如果我们想用<code class="fe mz na nb nc b">BigDecimal</code>来表示数量，下面是提取它们的方法</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2984" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在一个货币数字化的世界里，一美元(或其他货币)的任何部分都应该是可兑换的，就像在某些交易所购买股票的部分一样。令人惊讶的是，仍然有实物货币被兑换，所以任何美元交易都必须四舍五入到美分的数字，也就是说，两位小数。其他世界货币也是如此，只是有些货币可以四舍五入到3位，有些货币必须四舍五入到整数。</p><p id="e2bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Java Money知道每种货币的正确取整，并且能够适当地取整。例如，巴林第纳尔(BHD)的适当四舍五入为3位，因为每第纳尔等于1000菲尔。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="e8d5" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">汇率和供应商</h2><p id="47d7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">货币偶尔会被创造和毁灭，但频率不高。另一方面，汇率在贪婪的投机市场的推动下不断变化。为了使汇率(或多或少)保持最新，Money API必须链接到一个汇率提供者。</p><p id="0d39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Moneta实现附带了一个提供者列表，当请求汇率时，会按顺序联系这些提供者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="845f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到这些提供者的连接需要相当长的时间来初始化，并且在运行测试时绝对应该避免，因为这将导致显著的速度下降(稍后将详细介绍测试)。我的猜测是，大多数应用程序将希望使用自己选择的提供者，而不是内置的提供者。好消息是实现一个定制的提供者非常容易。</p><p id="5cb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个定制提供者的实现，它通过由java-finance-api提供的Java客户端使用了<a class="ae ln" href="https://currencies.apps.grandtrunk.net/" rel="noopener ugc nofollow" target="_blank"> Grandtrunk </a>汇率API:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="853d" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">把所有的放在一起</h2><p id="6b8b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们结合这些概念来构建发票应用程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4f68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">合同在第11行指定了发票的货币。在第12行，我们获得了该货币的CurrencyConversion实例。在第13–16行，我们对费用进行了汇总，确保将每笔费用都转换为联系货币(第15行)。</p><p id="9029" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第18行，我们做了一些货币算术来减去折扣率。最后，在第19行，我们将最终金额四舍五入到货币指定的正确小数位数。</p><h2 id="4d62" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">测试</h2><p id="2781" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">正如我之前提到的，默认的汇率提供程序需要很长时间来启动，应该在测试中避免。在任何情况下，使用真实的汇率提供商都不会产生可重复的结果，因为兑换率一直在变化。</p><p id="9f7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，正如我们所看到的，实现汇率提供程序非常容易，所以我们可以专门为测试创建一个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="526b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了强制测试使用这个提供者，我们可以创建一个特定于测试概要文件的配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="2f4a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">最后的想法</h1><p id="7c32" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Java Money API为构建多货币应用程序提供了丰富的特性。有几个方面我不喜欢。一个是<code class="fe mz na nb nc b">CurrencyUnit </code>不同于Java现有的<code class="fe mz na nb nc b">Currency </code>类。技术原因很清楚:更多的属性是必要的，为了新的API而扩展<code class="fe mz na nb nc b">Currency </code>是没有意义的。然而，我希望它们能更好地互操作。我还发现API的某些部分在语法上有点麻烦，但还不至于让人望而却步。</p><p id="b5f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">API的通用性允许扩展到传统货币之外，它也可以用于加密货币。总的来说，这似乎是一个非常健壮的规范。我建议使用它而不是经历痛苦来开发一个本土的解决方案——当然，除非有一个非常好的理由这样做。</p><p id="ac29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个例子的源代码可以在https://github.com/algorythmist/java-money-spring-poc的<a class="ae ln" href="https://github.com/algorythmist/java-money-spring-poc" rel="noopener ugc nofollow" target="_blank">中找到。在</a><a class="ae ln" href="https://github.com/JavaMoney/jsr354-ri/blob/master/moneta-core/src/main/asciidoc/userguide.adoc" rel="noopener ugc nofollow" target="_blank">https://github . com/JavaMoney/JSR 354-ri/blob/master/Moneta-core/src/main/asciidoc/user guide . adoc</a>中可以找到Moneta实现的全面指南</p></div></div>    
</body>
</html>