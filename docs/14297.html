<html>
<head>
<title>8+ things you need to know when you want to use Spring @Async really well</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当你想很好地使用Spring @Async时，你需要知道的8件事情</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/8-things-you-need-to-know-when-you-want-to-use-spring-async-really-well-e5af4af259c5?source=collection_archive---------3-----------------------#2022-11-15">https://levelup.gitconnected.com/8-things-you-need-to-know-when-you-want-to-use-spring-async-really-well-e5af4af259c5?source=collection_archive---------3-----------------------#2022-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/78e910e805bb9b11cc2eb1f64800adb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uZWC0nmQNCP2LjIQG6xdQ.png"/></div></div></figure><p id="4a53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一名优秀的Java开发人员或架构师。我们必须掌握并发和异步这两个核心概念，这对我们设计和优化系统有很大的帮助。</p><p id="ea1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中。我就说说如何在异步处理上很好的使用spring annotation @Async。阅读后，你可以找到一些好的例子。T3】</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi la"><img src="../Images/31860c6aef845c86732bcc628f8d93b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*VVDhRbLd58WNLpnAHDb0gg.jpeg"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">代码—带走</figcaption></figure><h2 id="f4e7" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">1.我们需要了解什么时候使用它，为什么要使用它。</h2><p id="11ef" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated"><strong class="kd iu">场景一。服务之间的交互数据，没有顺序处理的要求</strong></p><p id="1e26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">订单服务传输给供应链服务的订单数据，比如订单A和订单B，它们传输给供应链系统的时机不影响供应链服务处理流程，对最终的业务结果没有影响。</p><p id="5c4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">场景二。邮件/消息分发。</strong></p><p id="7025" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在消息处理中，一条消息需要分发给多个用户，如果是同步处理，需要一条一条发送，但是因为是消息分发场景，不需要顺序处理，所以我们可以把同步处理一条一条优化成异步并发处理。也就是说，每个用户同时分配一个单独的线程来处理消息传递。</p><p id="212e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">比如我们需要给20个用户发消息，给一个用户发消息需要2s。</p><p id="f901" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同步:逐个处理一条消息需要40多秒，</p><p id="4b0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">异步并发:只需要2s+就可以完成流程。</p><p id="de2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这大大提高了消息处理的效率。</p><p id="0a3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">场景3。中间件消费。</strong></p><p id="fa11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在消息中间件的使用中，当你消费一条消息时，往往会有一个消费处理时间限制，如果时间过长会触发中间件将消费者标记为异常，并踢出消费群等情况。因此，我们需要优化和提高每次消息消费的时间和效率。但是，异步不需要等待处理完成，可以立即返回，所以这里可以使用异步处理来提高响应，缩短返回时间。</p><p id="ed6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">场景4。IO操作或需要大量计算的耗时操作</strong></p><p id="1040" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于网站或交易系统来说，消耗数据或执行延迟来换取用户延迟是值得的，因为用户体验会因此得到改善。活动跟踪、账单支付、报表处理显然应该是后台活动，很多步骤可以作为异步操作部分解决，以后能做的事情以后再做</p><p id="745a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好的。在我们理解了什么时候以及为什么需要使用它之后。那我们就去怎么用吧。</p><h1 id="9a35" class="mh lk it bd ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx bi translated">2.怎么用？</h1><p id="930d" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">只需简单地将@Async添加到您希望成为异步的方法中。</p><h1 id="4779" class="mh lk it bd ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx bi translated">3.怎么用好？</h1><p id="1c88" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">为了更好地利用它，我们需要知道什么条件会导致它失败(仍然以同步方式运行)。异步不起作用)</p><p id="b284" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1.如果使用SpringBoot框架必须在启动类中添加<strong class="kd iu"> @EnableAsync </strong>注释。</p><p id="5878" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.标记的方法使用静态的私有修改。【它必须只应用于<strong class="kd iu">的<em class="kz">公共</em>的</strong>方法。]</p><p id="d0c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.异步方法所在的类不使用@Component注释(或其他注释),所以spring无法扫描异步类</p><p id="193a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.被标记的方法不能与要调用的异步方法<br/>在同一个类中(原因是:spring扫描bean时，会扫描该方法是否包含@Async注释，如果包含，spring会为bean动态生成一个子类(即代理类，proxy)，该子类继承自原始bean。此时，当调用带注释的方法时，它实际上是由代理类调用的，这给调用增加了异步性。但是，如果被注释的方法被同一个类中的另一个方法调用，那么该方法不是通过代理类调用的，而是直接通过原bean调用的，所以没有添加异步效果，我们看到了@Async注释无效的现象。</p><p id="2efc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">推荐的方式</em> </strong>是按照业务将异步方法提取到对应的bean中，在外部需要使用时注入bean，然后在bean中调用异步方法。</p><p id="bc81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">5.该类需要使用@Autowired或@Resource等标注自动注入，不能手动新增对象[Self-invocation —不起作用。]</p><p id="f685" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为它绕过代理，直接调用底层方法。</p><p id="65ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">6.被标记的方法只能返回<strong class="kd iu"> void或Future </strong></p><p id="3538" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">7.在@Async方法上标记@Transactional不起作用。</p><p id="a500" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过将@Transactional添加到内部调用的方法中，可以将需要事务管理操作的方法放在异步方法中。</p><p id="396e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">举例。使用@Async/@Transactional进行注释的方法A不能产生事务控制目的。</p><p id="5904" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">标有@Async的方法B调用B中的C和D，C/D分别标有@Transactional，那么就可以达到事务控制的目的。</p><p id="3b4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">8.@Async注释导致spring循环依赖失败</p><p id="42ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设serviceA和serviceB对象相互依赖。在这种情况下，serviceA和serviceB中的一个将总是首先被实例化，如果在serviceA或serviceB中使用@Async注释，将导致循环依赖异常:</p><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="960f" class="nd lk it mz b be ne nf l ng nh">org.springframework.beans.factory BeanCurrentlyInCreationException<br/><br/>In springboot, the above error is caught and the exception thrown is: 'The dependencies of some of the beans in the application context form a cycle'</span></pre><p id="b0d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原因:<br/>我们知道，spring三级缓存通过在之前的三级缓存中加入ObjectFactory，在一定程度上解决了循环依赖问题</p><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="9aad" class="nd lk it mz b be ne nf l ng nh">populateBean(beanName, mbd, instanceWrapper)</span></pre><p id="4dd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它在A对象的实例化之后被执行，因此允许在实例化之后从B对象分配属性。在赋值过程中，可以从三级缓存中获取ObjectFactory，并调用getObject()方法来获取a的引用，然后B可以成功初始化并添加到IOC容器中。此时，在A对象完成属性分配后，它将执行</p><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="b5e6" class="nd lk it mz b be ne nf l ng nh">initializeBean(beanName, exposedObject, mbd)</span></pre><p id="0055" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重点是这里做的@Async标注的处理，对应的后处理器AsyncAnnotationBeanPostProcessor，在postProcessAfterInitialization方法中会返回代理对象，这个代理对象和B中保存的A对象引用不同，导致了上面的错误。</p><h2 id="0736" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">外卖</h2><ul class=""><li id="3048" class="ni nj it kd b ke mc ki md km nk kq nl ku nm ky nn no np nq bi translated">基本使用案例</li></ul><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="8948" class="nd lk it mz b be ne nf l ng nh">@Slf4j<br/>@RestController<br/>@RequestMapping(value = "/v1")<br/>public class AsyncController {<br/><br/>    @Autowired<br/>    public AsyncService asyncService;<br/><br/>    @GetMapping("/async/work")<br/>    public HttpStatus work() {<br/><br/>        log.info("in Controller");<br/>        asyncService.step1();<br/>        asyncService.step2();<br/>        asyncService.step3();<br/>        return HttpStatus.OK;<br/>    }<br/>}<br/><br/><br/>@Slf4j<br/>@Service<br/>public class AsyncService {<br/><br/>    @Async<br/>    public void step1(){<br/>        log.info("step 1");<br/>    }<br/><br/>    @Async("asyncExecutor")<br/>    public void step2(){<br/>        log.info("step 2");<br/>    }<br/><br/>    @Async("fixedThreadPool")<br/>    public void step3(){<br/>        log.info("step 3");<br/>    }<br/>}</span></pre><ul class=""><li id="4825" class="ni nj it kd b ke kf ki kj km nr kq ns ku nt ky nn no np nq bi translated">在同一个类中调用异步方法</li></ul><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="964a" class="nd lk it mz b be ne nf l ng nh">@Slf4j<br/>@RestController<br/>@RequestMapping(value = "/v1")<br/>public class AsyncController {<br/><br/>    @Autowired<br/>    public AsyncService asyncService;<br/><br/>    @GetMapping("/async/work/methodsInSameClass")<br/>    public HttpStatus work1() {<br/><br/>        log.info("test async working method in same class");<br/>        asyncService.allInSameClass();<br/>        return HttpStatus.OK;<br/>    }<br/><br/>    @GetMapping("/async/fail/methodsInSameClass")<br/>    public HttpStatus fail1() {<br/><br/>        log.info("test async not working");<br/>        asyncService.all();<br/>        return HttpStatus.OK;<br/>    }<br/>}<br/><br/><br/><br/>@Slf4j<br/>@Service<br/>public class AsyncService {<br/><br/>    @Autowired<br/>    public AnotherAsyncService anotherAsyncService;<br/><br/>    public void all(){<br/>        /**<br/>         * As step1() step2() step3() in same class as all().<br/>         * which will make those 3 steps called by same caller as all() not the proxy caller. then async fail<br/>         */<br/>        step1();<br/>        step2();<br/>        step3();<br/>        /**<br/>         * But as step4() step5() step6() in different class. then 4,5,6 will do async way.<br/>         */<br/>        anotherAsyncService.step4();<br/>        anotherAsyncService.step5();<br/>        anotherAsyncService.step6();<br/>    }<br/><br/>    public void allInSameClass(){<br/>        /**<br/>         *  Methods in the same class need to get the proxy object first, manually get the object<br/>         */<br/>        AsyncService bean = ApplicationContextUtil.getBean(AsyncService.class);<br/>        bean.step1();<br/>        bean.step2();<br/>        bean.step3();<br/>    }<br/>}</span></pre><ul class=""><li id="db87" class="ni nj it kd b ke kf ki kj km nr kq ns ku nt ky nn no np nq bi translated">处理未来的返回值</li></ul><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="294a" class="nd lk it mz b be ne nf l ng nh">@Slf4j<br/>@RestController<br/>@RequestMapping(value = "/v1")<br/>public class AsyncController {<br/><br/>    @Autowired<br/>    public AsyncService asyncService;<br/><br/>    @GetMapping("/async/workWithFutureReturn")<br/>    public HttpStatus workWithFutureReturn() {<br/><br/>        log.info("in workWithFutureReturn");<br/>        Future&lt;String&gt; stringFuture = asyncService.asyncInvokeReturnFuture(5);<br/><br/>        while (true) {<br/>            if (stringFuture.isDone() &amp;&amp; !stringFuture.isCancelled()) {<br/>                try {<br/>                    log.info("Get Future Value {}", stringFuture.get());<br/>                } catch (InterruptedException | ExecutionException e) {<br/>                    e.printStackTrace();<br/>                }<br/>                break;<br/>            }<br/>        }<br/>        return HttpStatus.OK;<br/>    }<br/>}<br/><br/>@Slf4j<br/>@Service<br/>public class AsyncService {<br/><br/>    @Async<br/>    public Future&lt;String&gt; asyncInvokeReturnFuture(int i) {<br/>        log.info("asyncInvokeReturnFuture, parementer={}", i);<br/>        Future&lt;String&gt; future;<br/>        try {<br/>            Thread.sleep(1000 * 1);<br/>            future = new AsyncResult&lt;String&gt;("success:" + i);<br/>        } catch (InterruptedException e) {<br/>            future = new AsyncResult&lt;String&gt;("error");<br/>        }<br/>        return future;<br/>    }<br/>}</span></pre><ul class=""><li id="f37e" class="ni nj it kd b ke kf ki kj km nr kq ns ku nt ky nn no np nq bi translated">自定义线程池，多个异步执行器</li></ul><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="8698" class="nd lk it mz b be ne nf l ng nh">@Slf4j<br/>@Configuration<br/>public class BaseAsyncConfigurer implements AsyncConfigurer {<br/><br/>    /**<br/>     * replace default Async Executor with Customize One.<br/>     */<br/><br/>    @Override<br/>    public Executor getAsyncExecutor() {<br/>        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();<br/>        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());<br/>        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors()*5);<br/>        executor.setQueueCapacity(Runtime.getRuntime().availableProcessors()*10);<br/>        executor.setThreadNamePrefix("replacedAsync-");<br/>        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());<br/>        executor.initialize();<br/>        return executor;<br/>    }<br/><br/>    ...<br/><br/>}</span></pre><pre class="nu my mz na bn nb nc bi"><span id="95f7" class="nd lk it mz b be ne nf l ng nh">//two customize asyncExecutors<br/>@Configuration<br/>public class AsyncConfig {<br/><br/>    private static final int MAX_POOL_SIZE = 50;<br/>    public static final int CORE_POOL_SIZE = 20;<br/><br/>    /**<br/>     * customize async Executor threadpool.<br/>     * @return<br/>     */<br/>    @Bean("asyncExecutor")<br/>    public AsyncTaskExecutor asyncTaskExecutor() {<br/>        ThreadPoolTaskExecutor async = new ThreadPoolTaskExecutor();<br/><br/>        async.setMaxPoolSize(MAX_POOL_SIZE);<br/>        async.setCorePoolSize(CORE_POOL_SIZE);<br/>        async.setThreadNamePrefix("async-threads-");<br/>        async.setWaitForTasksToCompleteOnShutdown(false);<br/>        async.setQueueCapacity(100);<br/><br/>        async.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());<br/>        return async;<br/>    }<br/><br/><br/>    /**<br/>     * use juc newFixedThreadPool<br/>     * @return<br/>     */<br/>    @Bean("fixedThreadPool")<br/>    public ExecutorService myFixedThreadPool() {<br/>        int processors = Runtime.getRuntime().availableProcessors();<br/>        return Executors.newFixedThreadPool(processors * 5);<br/>    }<br/>}<br/><br/>@Slf4j<br/>@Service<br/>public class AsyncService {<br/><br/>    @Async<br/>    public void step1(){<br/>        log.info("step 1");<br/>    }<br/><br/>    @Async("asyncExecutor")<br/>    public void step2(){<br/>        log.info("step 2");<br/>    }<br/><br/>    @Async("fixedThreadPool")<br/>    public void step3(){<br/>        log.info("step 3");<br/>    }<br/>}</span></pre><ul class=""><li id="5f35" class="ni nj it kd b ke kf ki kj km nr kq ns ku nt ky nn no np nq bi translated">异常的处理方式</li></ul><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="e529" class="nd lk it mz b be ne nf l ng nh">@Slf4j<br/>@Configuration<br/>public class BaseAsyncConfigurer implements AsyncConfigurer {<br/><br/>    ...<br/><br/>    /**<br/>     * override the getAsyncUncaughtExceptionHandler() method to return our custom asynchronous exception handler:<br/>     * !!! All the exception happened in @async will been handler here.<br/>     */<br/>    @Override<br/>    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {<br/>        return (Throwable ex, Method method, Object... params)-&gt;{<br/><br/>            try {<br/>                log.error("\n\n[Exception-Async-Handler] Class-Name: {}-{}\nType: {}\nException: {}\n\n",<br/>                        method.getDeclaringClass().getName(),method.getName(),<br/>                        ex.getClass().getName(),<br/>                        ex.getMessage());<br/>            } catch (Throwable nex) {<br/>                log.error("catch Async Exception: {}", nex);<br/>            }<br/>        };<br/>    }<br/><br/>}</span></pre><ul class=""><li id="e349" class="ni nj it kd b ke kf ki kj km nr kq ns ku nt ky nn no np nq bi translated">@Async调用中的事务处理机制</li></ul><pre class="lb lc ld le gt my mz na bn nb nc bi"><span id="adc9" class="nd lk it mz b be ne nf l ng nh">@Slf4j<br/>@Service<br/>public class AsyncService {<br/><br/>    @Autowired<br/>    public DataService dataService;<br/><br/>    @Async<br/>    public void dbOperate(){<br/>        log.info("some logic here first");<br/>        dataService.allStep();<br/>        log.info("some logic later");<br/>    }<br/><br/>}<br/><br/>@Slf4j<br/>@Service<br/>public class DataService {<br/><br/>    @Transactional<br/>    public void allStep(){<br/>        saveObj();<br/>        updateObj();<br/>    }<br/><br/>    public void saveObj(){<br/>      log.info("Some data saved");<br/>    }<br/><br/>    public void updateObj(){<br/>        log.info("Some another data updated");<br/>    }<br/>}</span></pre><p id="d73e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样。</p><p id="3e10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！如果你喜欢它或觉得它有帮助，请点击鼓掌:)</p><p id="5256" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快乐编码。下次见:)</p></div></div>    
</body>
</html>