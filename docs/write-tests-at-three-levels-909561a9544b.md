# 在三个层次上编写自动化测试

> 原文：<https://levelup.gitconnected.com/write-tests-at-three-levels-909561a9544b>

![](img/884eb5c41eb09f07f19b3c2c58aa9e18.png)

图片来源:[艾丽莎·斯科特](http://pluspng.com/three-bears-png-9172.html)

当然，测试的种类几乎和错误的分类一样多。然而，我发现在开发新功能时，特别关注三种类型是很有用的:

*   单元测试
*   组件测试
*   验收测试

考虑到 IT 世界的多样性和快节奏，这三个测试类别获得了许多同义词，每一个都有略微不同的侧重点，并且每个类别之间的界限通常很模糊。

但是通过一个简单的介绍:

*   单元测试是由开发人员在编码时编写的。这些测试往往是非常细粒度的——一个测试覆盖一个单一的功能或者类，基本上是一个功能单元或者(换句话说)一个单一的职责。
*   组件测试也是由开发人员在编码时编写的。这些测试比单元测试粒度更广——每个测试覆盖更多的代码，通常是一组密切相关的类。
*   验收测试由 BAs 指定，或者由与 BAs 直接接触的软件测试人员指定。这些是端到端的测试，覆盖了可能从系统的一端(例如 REST 端点)运行到另一端(可能是数据库查询)并返回的部分功能。

因此，有三种类型的测试，每一种都在不同的水平或范围上运行。

但是为什么要特别测试这三个级别呢？你可能会问，它们之间是否有太多的交叉，也就是重复的工作？

答案是它们各自提供了不同的好处，并且很好地相互补充。重复往往比你想象的要少得多，因为他们在测试不同的东西。

![](img/89ee108136a2bc285050d483bf23d477.png)

照片由[布里吉塔·施奈特](https://unsplash.com/@brisch27?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

将单元测试想象成一根钓鱼竿——精确的，瞄准特定的水域，设计用来钓一条鱼。相比之下，验收测试就是一张拖网。它将捕获数百条鱼，包括一些可能意想不到的“奖品”，尽管许多较小的鱼会穿过网，甚至不会被注意到。组件测试是“中间”尺寸，可能就像毛伊岛渔民在海浪中撒下的手持网。这是有针对性的，但仍然会捕捉到相当数量的鱼，而且网足够小，可以捕捉到否则会蜿蜒而过的小鱼。

但是这个牵强的比喻已经说得够多了…让我们更深入地看看每一级别的测试是如何提供它自己的好处的。

# 为什么要编写单元测试？

以下是一些在“单元”级别编写测试的好理由:

*   为了防止被测试的单个单元中的错误
*   根据它的接口(即基于契约的测试)，显示你正在编写的函数/方法按预期工作
*   更好地理解设计，并在一定程度上推动设计
*   质疑法典

所以，相当重要！然而，您会注意到，所有这三个好处都发生在您编写单元测试所针对的代码的时候。单元测试确实为设计提供了反馈——有了编码，你现在就在采煤工作面，发现什么是可能的，什么是不可能的。然而，一些单元测试的“效用窗口”很快就过去了，它们可以很快从资产变成负债。

将单元测试作为一种总括形式的回归测试是很诱人的。然而(回想一下钓鱼竿的比喻)，这真的不是他们的强项:事实上，他们在回归测试方面有点糟糕。他们撒的网不够宽。他们真正测试的是一个函数已经以特定的方式实现了。它们作为一种临时的、原位的开发工具比回归测试更有效。

# 为什么要编写组件测试？

以下是一些在“组件”级别编写测试的好理由:

*   为了防止在被测试的组件中引入错误
*   为了显示您正在编写的函数/方法如预期的那样工作，*根据需求*(理想情况下，从用户故事中分解出快乐路径和不快乐路径的场景)
*   更好地理解设计，并在一定程度上推动设计
*   验证设计
*   验证业务逻辑(例如，跨几个类运行的复杂状态机)是否按规定工作
*   提供一套测试，一个*回归安全网*，可以定期重新运行，以便尽早发现新的错误

单元测试有一些交叉，这并不奇怪，因为它们都是由开发人员在编程时编写的。但是也有很多好处是你无法从更细粒度的单元测试中真正得到的——或者至少，没有那么有效。

顺便说一下，正如我前面提到的，组件测试的工作是验证一组功能——一组密切相关的功能、类或职责，它们共同完成系统行为的一个特定项目。但是如何确定单个组件的范围呢？如果你是域驱动设计(DDD)的粉丝，测试中的*组件*通常匹配单个[集合](https://medium.com/ingeniouslysimple/aggregates-in-domain-driven-design-5aab3ef9901d)，或者如果包含在单个微服务中，匹配一个*有界上下文*。值得思考！

总的来说，我发现组件测试比单元测试更有效——更容易编写(比“白盒”更“黑盒”)；你不必写那么多，因为每一个都有更广的范围，所以涵盖了更多的代码。他们撒下了比单元测试更大的网。

因此，只剩下三个层次中最广泛的测试…

# 为什么要编写验收测试？

以下是一些编写验收测试的好理由:

*   质疑需求的深度或广度
*   验证业务逻辑是否按指定方式工作
*   确保错误情况得到处理，例如显示适当的错误消息，或者交易正确回滚，以保持数据完整性
*   提供一套测试，一个可以定期重新运行的*回归安全网*

与组件测试有一些重叠，但这实际上是组件测试真正有用的地方——就像验收测试一样，如果你从业务需求/故事场景而不是代码中驱动它们。

但是回到验收测试…

为了真正有效，验收测试场景应该由参与项目的主题专家——BAs，或者至少由与 BAs 直接接触的测试人员来指定。但是通常是开发人员需要将验收测试脚本转化为可运行的东西(例如，在 BDD [小黄瓜场景](https://cucumber.io/docs/gherkin/)背后实现 Java 或 Ruby 代码)。

验收测试是端到端的，撒下了最大的网；所以你会正确地认为它们是回归测试最有效的形式。缺点是它们通常比组件测试需要更长的运行时间，所以你要么少写一些，要么少运行一些。

# 哪一个刚刚好？

正如你所看到的，当在三个不同的级别测试时，你可能在所有级别下测试相同的代码库，但是你在每个级别上实现不同的目标。

思考这些区别的一个好方法是，单元测试验证你写的代码是正确的，而验收测试验证代码在做正确的事情。组件测试占据了一个经常被忽略的重要的中间地带。事实上，虽然所有三个级别的测试都很重要，但我倾向于将更多的注意力放在组件级别的[测试上，而不是其他两个……你也应该如此！](https://codeburst.io/component-tests-vs-unit-tests-tdd-71b921d48907)

*有兴趣了解更多？查看我即将出版的书，*[](https://www.domainorientedtesting.com/)**(预计 2020 年某个时候出版)，加入 LinkedIn 上的 DOT 讨论组* *。**

**顺便说一句，如果你是一名软件开发人员，并且你还没有* [*参加这个单元测试调查*](https://bit.ly/UnitTestingSurvey) *，请参加——这应该不到一分钟，并且你将有助于形成整个行业的单元测试实践的更准确的图像…谢谢！**