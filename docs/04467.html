<html>
<head>
<title>JavaScript Problem Solvers: Remove Outermost Parentheses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题解决程序:删除最外面的括号</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problem-solvers-remove-outermost-parentheses-90381c24b2c6?source=collection_archive---------11-----------------------#2020-06-28">https://levelup.gitconnected.com/javascript-problem-solvers-remove-outermost-parentheses-90381c24b2c6?source=collection_archive---------11-----------------------#2020-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aac7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">案例008:亲子鉴定</h2></div><p id="6de8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与我们在本系列中解决的最后两个问题一样，我们今天试图解决的问题是一个相当简单的模式匹配练习，其中有一些巧妙的技巧。</p><p id="0bb2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也是一个需要我动几下下巴才能弄清楚的问题，所以我觉得把它包含在这个系列中是个好主意。</p><p id="c1ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们开始解决。</p><h2 id="7a97" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">问题是</h2><p id="8762" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><a class="ae mc" href="https://leetcode.com/problems/remove-outermost-parentheses/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">这里是LeetCode </strong> </a>上问题的链接</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="787f" class="le lf it mi b gy mm mn l mo mp">A valid parentheses string is either empty (“”), “(” + A + “)”, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, “”, “()”, “(())()”, and “(()(()))” are all valid parentheses strings.</span><span id="88bc" class="le lf it mi b gy mq mn l mo mp">A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</span><span id="9c77" class="le lf it mi b gy mq mn l mo mp">Given a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + … + P_k, where P_i are primitive valid parentheses strings.</span><span id="fd5e" class="le lf it mi b gy mq mn l mo mp">Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.</span><span id="3233" class="le lf it mi b gy mq mn l mo mp">Constraints:<br/>  S.length &lt;= 10000<br/>  S[i] is “(“ or “)”<br/>  S is a valid parentheses string</span><span id="1090" class="le lf it mi b gy mq mn l mo mp">Test Cases:</span><span id="8249" class="le lf it mi b gy mq mn l mo mp">  (()())(())” =&gt; “()()()”<br/>  Explanation: The input string is “(()())(())”, with primitive decomposition “(()())” + “(())”. After removing outer parentheses of each part, this is “()()” + “()” = “()()()”.</span><span id="35d3" class="le lf it mi b gy mq mn l mo mp">  “(()())(())(()(()))” =&gt; “()()()()(())”<br/>  Explanation: The input string is “(()())(())(()(()))”, with primitive decomposition “(()())” + “(())” + “(()(()))”. After removing outer parentheses of each part, this is “()()” + “()” + “()(())” = “()()()()(())”.</span><span id="be52" class="le lf it mi b gy mq mn l mo mp">  “()()” =&gt; “”<br/>  Explanation: The input string is “()()”, with primitive decomposition “()” + “()”. After removing outer parentheses of each part, this is “” + “” = “”.</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="4502" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">崩溃了</h2><p id="6144" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">好吧，这个问题的解释向我们抛出了很多信息，我觉得它把它试图解释的东西复杂化了。让我们像往常一样，尝试将问题的解释分成更小的部分，以确保我们理解这里发生了什么:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a176" class="le lf it mi b gy mm mn l mo mp">A valid parentheses string is either empty (“”), “(” + A + “)”, or A + B, where A and B are valid parentheses strings, and + represents string concatenation.</span></pre><p id="2415" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，给我们一个括号字符串的定义。根据所提供的信息，似乎有效括号字符串的最基本示例是将1个左括号和1个右括号组合成一个字符串，或者简称为“()”。</p><p id="f5be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个<code class="fe my mz na mi b">“(” + A + “)”</code>的例子告诉我们，我们也可以嵌套括号。如果<code class="fe my mz na mi b">A</code>是一个有效的括号字符串，并且<code class="fe my mz na mi b">“()”</code>也是一个有效的括号字符串，我们可以用<code class="fe my mz na mi b">“()”</code>代替<code class="fe my mz na mi b">A</code>，并将<code class="fe my mz na mi b">“(“ + A + “)”</code>的例子简化为<code class="fe my mz na mi b">“(())”</code></p><p id="1b3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe my mz na mi b">A + B</code>的最后一个例子展示了更多的嵌套。如果我们再次用<code class="fe my mz na mi b">“()”</code>替换<code class="fe my mz na mi b">A</code>，我们可以用第一个例子<code class="fe my mz na mi b">“(” + A + “)”</code>或<code class="fe my mz na mi b">“(())”</code>替换<code class="fe my mz na mi b">B</code>。如果<code class="fe my mz na mi b">A</code>是<code class="fe my mz na mi b">“()”</code>而<code class="fe my mz na mi b">B</code>是<code class="fe my mz na mi b">“(())”</code>，我们可以假设<code class="fe my mz na mi b">A + B</code>等于<code class="fe my mz na mi b">“()(())”</code>，意味着<code class="fe my mz na mi b">“()(())”</code>也是一个有效的括号字符串。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5b66" class="le lf it mi b gy mm mn l mo mp">For example, “”, “()”, “(())()”, and “( () ( () ) )” are all valid parentheses strings.</span></pre><p id="3f99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些例子有助于澄清定义。这里重要的补充是我们得到了另一个<code class="fe my mz na mi b">“(()(()))”</code>的例子。但是，这只是嵌套在另一组括号中的<code class="fe my mz na mi b">A + B</code>示例。所以，如果我们对它进行“逆向工程”:<code class="fe my mz na mi b">“(()(()))”</code>也可以表示为<code class="fe my mz na mi b">“(” + A + B + “)”</code>。</p><p id="f68e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个模式需要注意:</p><p id="789f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有效的括号字符串总是有相等数量的左括号和右括号。</p><p id="6918" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><p id="63de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe my mz na mi b">“()” =&gt; 1 left parenthesis, 1 right parenthesis</code></p><p id="ab85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe my mz na mi b">“(())” =&gt; 2 left parentheses, 2 right parentheses</code></p><p id="e2a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe my mz na mi b">“()(())” =&gt; 3 left parentheses, 3 right parentheses</code></p><p id="42cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe my mz na mi b">“(()(()))” =&gt; 4 left parentheses, 4 right parentheses</code></p><p id="b970" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对我有意义。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8652" class="le lf it mi b gy mm mn l mo mp">A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</span></pre><p id="a825" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这似乎是问题解释中最令人困惑的部分。但它所解释的是，一个有效的括号字符串可以通过将其分成2部分<code class="fe my mz na mi b">(A + B)</code>来缩减，并且<code class="fe my mz na mi b">A</code>和<code class="fe my mz na mi b">B</code>都必须包含至少1组括号。一旦它不能再被分割，就被认为是一个<code class="fe my mz na mi b">primative</code>。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6e35" class="le lf it mi b gy mm mn l mo mp">Given a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + … + P_k, where P_i are primitive valid parentheses strings.</span></pre><p id="b18a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能是问题解释中最不必要的部分，并且可能会陷入过度解释的境地，但是我不是一个对礼物吹毛求疵的人。</p><p id="b669" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe my mz na mi b">S = P_1 + P_2 + … + P_k</code>的公式只是我们之前已经算出的公式的重新表示，如果这样更容易理解的话，可以重新定义为<code class="fe my mz na mi b">S = A + B + … + Z</code>。<code class="fe my mz na mi b">P_i</code>只是我们在一个有效的括号字符串中找到的每个分解的原语的一个表示。它所解释的是，如果需要的话，我们可以如何分解、拆分或分割一个深度嵌套的有效括号原语。</p><p id="5c1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住我之前提到的模式，有效的括号字符串总是有相等数量的左右括号。我们可以使用这种模式将深度嵌套的有效括号字符串分解成它的原语。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5076" class="le lf it mi b gy mm mn l mo mp">Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.</span></pre><p id="0ccb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们终于找到了我们所期望的<code class="fe my mz na mi b">return</code>，这是一个字符串。我们还发现，对于在给定字符串中找到的每个分解后的原语，我们需要删除最外面的一组括号。</p><p id="b5a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们回到我们的<code class="fe my mz na mi b">“(” + A + B + “)”</code>或<code class="fe my mz na mi b">“(()(()))”</code>示例。<code class="fe my mz na mi b">“(()(()))”</code>已经被认为是一个分解的原语，因为我们不能将它分成两个独立的部分，并且仍然让这两个部分都是有效的括号字符串。a将等于无效的<code class="fe my mz na mi b">“(()” ,</code>，B将等于同样无效的<code class="fe my mz na mi b">“(()))”</code>。</p><p id="72ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它已经是一个<code class="fe my mz na mi b">primitive</code>，我们可以去掉最外面的括号，返回<code class="fe my mz na mi b">“()(())”</code></p><p id="0142" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，简而言之，我们需要将任何给定的输入字符串分解成其最原始的形式，并删除我们找到的每组括号中最外面的括号。</p><p id="392f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单吧？嗯……算是吧。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="0843" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">制约因素</h2><p id="b70e" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">为我们提供的这三个约束稍微传统一点，但是将它们分解也总是好的，并且确保我们理解它们约束的是什么。我们还想寻找任何可能与潜在解决方案相关的暗示或线索:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="be81" class="le lf it mi b gy mm mn l mo mp">S.length &lt;= 10000</span></pre><p id="ea90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，我们期望在约束中得到一个下限和上限，无论是字符串，数组中的元素，还是其他。但是在这里，对于给定的输入字符串，我们只给出一个上限。这立即告诉我，我们将不得不容纳长度为0的空输入字符串。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3790" class="le lf it mi b gy mm mn l mo mp">S[i] is “(“ or “)”</span></pre><p id="0ee8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很有用，因为它告诉我们给定字符串中的任何字符都将是<code class="fe my mz na mi b">“(”</code>或<code class="fe my mz na mi b">“)”</code>，我们不必担心任何其他字母或特殊字符，也不必进行任何类型检查。在输入字符串为空的情况下，或者如果一个给定的字符串是<code class="fe my mz na mi b">“”</code>，那么<code class="fe my mz na mi b">S[i]</code>根本不存在，所以我们不能对空字符串应用这个约束。这意味着一个给定的字符串仍然可能是<code class="fe my mz na mi b">“”</code>，仍然是我们必须考虑的。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1855" class="le lf it mi b gy mm mn l mo mp">S is a valid parentheses string</span></pre><p id="6af0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个约束依赖于为我们提供的有效括号字符串的定义，并消除了我们可能遇到的任何错误处理，比如字符串是<code class="fe my mz na mi b">“)(”</code>、<code class="fe my mz na mi b">“()(())(”</code>还是简单的<code class="fe my mz na mi b">“)”</code>。我们不必担心任何这样的突变，因为它们都不符合有效括号字符串的定义。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="32ff" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">嫌疑犯</h2><p id="8efb" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我认为我们已经花了足够的时间来检查我们所拥有的所有信息，我们最终可以开始找出一个解决方案。</p><p id="d699" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用第一个测试用例来演示我们如何着手解决这个问题:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e1e7" class="le lf it mi b gy mm mn l mo mp">“(()())(())” =&gt; “()()()”</span><span id="db09" class="le lf it mi b gy mq mn l mo mp">Explanation: The input string is “(()())(())”, with primitive decomposition “(()())” + “(())”.After removing outer parentheses of each part, this is “()()” + “()” = “()()()”.</span></pre><p id="06a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要做的第一件事是把一个给定的字符串分割成它的分解原语。</p><p id="5cfb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将从我学到的模式开始，其中有效的括号字符串总是有相等数量的括号。对于分解的原语来说，情况似乎也是如此。<code class="fe my mz na mi b">“(()())”</code>和<code class="fe my mz na mi b">“(())”</code>都有相同数量的左右括号。</p><p id="dbd7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这告诉我，我们可以遍历一个给定的字符串，并使用一个频率计数器来计算我们找到的左右括号的数量。一旦两个键的值相等，我们就可以把从字符串开头到迭代器所在的地方的所有东西都切片，并把它推到一个数组中。</p><p id="6eb5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们正在迭代<code class="fe my mz na mi b">“(()())(())”</code>的第一个测试用例:</p><p id="2ed0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一次迭代中，我们找到<code class="fe my mz na mi b">“(”</code>，将其添加到频率计数器，并将其值设置为1:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6df3" class="le lf it mi b gy mm mn l mo mp">i: 0<br/>given string: “(()())(())”<br/>characters iterated through: “(”<br/>characters left: “()())(())”<br/>count = { “(”: 1 }</span></pre><p id="cdfc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二次迭代中，我们找到另一个<code class="fe my mz na mi b">“(”</code>，并给它的值加1:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="04be" class="le lf it mi b gy mm mn l mo mp">i: 1<br/>given string: “(()())(())”<br/>characters iterated through: “((”<br/>characters left: “)())(())”<br/>count = { “(”: 2 }</span></pre><p id="92a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第三次迭代中，我们找到一个<code class="fe my mz na mi b">“)”</code>，将其添加到频率计数器中，并将其值设置为1:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8d05" class="le lf it mi b gy mm mn l mo mp">i: 2<br/>given string: “(()())(())”<br/>characters iterated through: “(()”<br/>characters left: “())(())”<br/>count = { “(”: 2, “)”: 1 }</span></pre><p id="c809" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第4次迭代中，我们找到另一个<code class="fe my mz na mi b">“(”</code>，并给它的值加1:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c40d" class="le lf it mi b gy mm mn l mo mp">i: 3<br/>given string: “(()())(())”<br/>characters iterated through: “(()(”<br/>characters left: “))(())”<br/>count = { “(”: 3, “)”: 1 }</span></pre><p id="5a9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第五次迭代中，我们找到了另一个<code class="fe my mz na mi b">“)”</code>，并给它的值加1:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="194f" class="le lf it mi b gy mm mn l mo mp">i: 4<br/>given string: “(()())(())”<br/>characters iterated through: “(()()”<br/>characters left: “)(())”<br/>count = { “(”: 3, “)”: 2 }</span></pre><p id="e9c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在第6次迭代中，我们找到了另一个<code class="fe my mz na mi b">“)”</code>，并给它的值加1:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8f0f" class="le lf it mi b gy mm mn l mo mp">i: 5<br/>given string: “(()())(())”<br/>characters iterated through: “(()())”<br/>characters left: “(())”<br/>count = { “(”: 3, “)”: 3 }</span></pre><p id="8cbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">频率计数器中的两个值现在相等。这意味着我们已经找到了一个有效括号字符串的原语。</p><p id="5719" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们想把从字符串开头到迭代器所在的地方的所有东西都切片，并把它推到一个数组中:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1b87" class="le lf it mi b gy mm mn l mo mp">primativesArr = [“(()())”]</span></pre><p id="b139" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要重新开始，寻找另一个有效的括号字符串原语。这意味着我们将不得不重置我们的频率计数器，这样我们就可以正确地计算字符串剩余部分中字符的括号数。</p><p id="264f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要在找到第一个或前一个有效的括号原语后，跟踪迭代器的位置。这样我们就有了一个参考点来开始下一个切片。</p><p id="4e32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，回到第一个测试案例，如果我们添加一个整数来跟踪我们从哪里切片，并重置频率计数器:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6327" class="le lf it mi b gy mm mn l mo mp">i: 5<br/>num: i + 1 or 6 (stored iterator to start the next slice of a primitive)<br/>given string: “(()())(())”<br/>characters iterated through: “(()())”<br/>characters left: “(())”<br/>count: {} (reset after finding a valid parentheses primitive)</span></pre><p id="326c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第7次迭代时:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="bbbc" class="le lf it mi b gy mm mn l mo mp">i: 6<br/>num: 6 (does not change)<br/>given string: “(()())(())”<br/>characters iterated through: “(()())(”<br/>characters left: “())”<br/>count: { “(”: 1 }</span></pre><p id="0f8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第8次迭代:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="9a55" class="le lf it mi b gy mm mn l mo mp">i: 7<br/>num: 6<br/>given string: “(()())(())”<br/>characters iterated through: “(()())((”<br/>characters left: “))”<br/>count: { “(”: 2 }</span></pre><p id="2e5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第9次迭代:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7bf7" class="le lf it mi b gy mm mn l mo mp">i: 8<br/>num: 6<br/>given string: “(()())(())”<br/>characters iterated through: “(()())(()”<br/>characters left: “)”<br/>count: { “(”: 2, “)”: 1 }</span></pre><p id="fcf1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，第十次迭代:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="69e6" class="le lf it mi b gy mm mn l mo mp">i: 9<br/>num: 6<br/>given string: “(()())(())”<br/>characters iterated through: “(()())(())”<br/>characters left: “”<br/>count: { “(”: 2, “)”: 2 }</span></pre><p id="57ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">频率计数器中的两个值现在再次相等，这意味着我们找到了另一个有效的括号原语，因此我们可以将从<code class="fe my mz na mi b">num</code>到字符串末尾的所有字符推入<code class="fe my mz na mi b">primativesArr</code>:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8f04" class="le lf it mi b gy mm mn l mo mp">primativesArr = [“(()())”, “(())”]</span></pre><p id="266d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有分解后的原语。</p><p id="45ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在要做的就是遍历primitivesArr，并使用<code class="fe my mz na mi b">slice</code>方法删除最外面的括号:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1624" class="le lf it mi b gy mm mn l mo mp">primativesArr = [“()()”, “()”]</span></pre><p id="ebff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以将<code class="fe my mz na mi b">primitivesArr</code>和<code class="fe my mz na mi b">return</code>中的所有元素连接起来。</p><p id="adc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过我们迭代并将元素推入<code class="fe my mz na mi b">primitivesArr</code>的方式，我们不必担心空字符串。如果一个给定的输入字符串是空的，所有将被添加到<code class="fe my mz na mi b">primitivesArray</code>的将是更多的空字符串。一旦它们被连接起来，它们也将被连接成一个空字符串。</p><p id="bc5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">咻。我想我可能把事情搞复杂了。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="3ba0" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">伪代码</h2><p id="618c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">因为要经历很多，我们可以在尝试将这个计划付诸实施之前写一些伪代码:</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="3b2e" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">评论</h2><p id="91cd" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">好吧。让我们一步步来，开始写出我们潜在的解决方案:</p><p id="b58e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们定义我们的<code class="fe my mz na mi b">removeOuterParentheses</code>函数、我们的频率计数器、我们的迭代器跟踪器和我们的原语数组:</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="aae3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们设置两个<code class="fe my mz na mi b">for</code>循环:一个<code class="fe my mz na mi b">for</code>循环遍历输入字符串，一个<code class="fe my mz na mi b">for in</code>循环遍历原语数组:</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6a03" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以关注遍历给定输入字符串的逻辑。让我们添加频率计数器的逻辑:</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8149" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们添加一个<code class="fe my mz na mi b">if</code>语句，它将检查左右括号的数量是否相等:</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1a88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，添加我们的操作，将有效的括号原语推送到<code class="fe my mz na mi b">primitivesArr</code>，重置频率计数器，并跟踪我们希望在哪里分割我们找到的下一个有效的括号原语:</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e598" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以将逻辑添加到<code class="fe my mz na mi b">for in</code>循环中，该循环遍历<code class="fe my mz na mi b">primitivesArr</code>并分割<code class="fe my mz na mi b">element</code>的第一个和最后一个字符，然后重新分配它们。</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1040" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以加入<code class="fe my mz na mi b">primativesArr</code>和<code class="fe my mz na mi b">return</code>它:</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="43a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行我们的解决方案，我们应该匹配为我们提供的测试用例:</p><figure class="md me mf mg gt nb gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b5f30d19e3eb9b36617316f8c1094bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*aW-io8mlNJGwjrNrMBqSZw.jpeg"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="fc17" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">最终解决方案</h2><p id="98cb" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">让我们最后看一下不带注释的解决方案，并清理一些语法:</p><figure class="md me mf mg gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="13fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">耶。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="33d8" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">任务完成</h2><p id="7c8f" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我发现这个问题非常有趣，我希望我没有把我的解决方案解释得过于复杂。我觉得最初定义问题的方式并不是最好的，我想确保在前进之前对问题有一个很好的理解。我还想更详细地了解我的解决方案实际上是如何工作的，所以我希望它值得我们两人的努力。</p><p id="65c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再说一次，我写的关于解决LeetCode或HackerRank问题的博客并不是为了找到时间或空间复杂度最低的解决方案。他们关注的是解决问题的步骤。</p><p id="dd7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我当然明白我的解决方案不会是最好的或最有效的，但不管怎样，我希望它们能帮助你或其他人找到一种方法来解决你在这个旅程中遇到的问题，我们称之为JavaScript。</p><p id="5403" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保持安全…保持健康…继续为正义而战。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><div class="md me mf mg gt nh"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">编写面试问题</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">掌握编码面试的过程</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">技术开发</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv nf nh"/></div></div></a></div></div></div>    
</body>
</html>