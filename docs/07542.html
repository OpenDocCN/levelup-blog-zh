<html>
<head>
<title>CSS Character Styling Using Background-Clip</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用背景剪辑的CSS字符样式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/css-character-styling-using-background-clip-a1c512ad6d20?source=collection_archive---------11-----------------------#2021-02-23">https://levelup.gitconnected.com/css-character-styling-using-background-clip-a1c512ad6d20?source=collection_archive---------11-----------------------#2021-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9668d775268e49bda21b721efec8f54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mdckGGN5JAlCgAPiZFn-zg.png"/></div></div></figure><p id="4f7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Grace Omele 的文章“<a class="ae kz" href="https://medium.com/front-end-weekly/how-to-apply-css-to-halfstyle-a-character-or-a-text-588efc289f4c" rel="noopener">如何将CSS应用于半样式字符或文本</a>中，她介绍了<a class="ae kz" href="https://github.com/arbelh/HalfStyle" rel="noopener ugc nofollow" target="_blank">一个“插件”来帮助样式文本</a>。虽然这个概念是好的，但是执行起来还有很多需要改进的地方，因为它使用的脚本完全是垃圾，使用的技术是暴力的，CSS实际上可以用线性渐变和背景剪辑来完成所有的事情！</p><h1 id="e017" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">出现的问题</strong></h1><ol class=""><li id="8635" class="ly lz it kd b ke ma ki mb km mc kq md ku me ky mf mg mh mi bi translated">它用绝对定位和溢出创建每个角色的副本:隐藏以剪切掉部分。ttthhhiiisss rrreeesssuuullllttttsss iiinnnnnnoonnn—-vvviiiissuuaaauaallul uuussseeerrr aaaggggeeenntttsss rrreeaadddiiiinnggg yyyooouuurrr ttteeeexxxttt llllikkeettthhhiiisss…不完全是一种可取的行为。</li><li id="2990" class="ly lz it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">对于这种从上到下的着色，我们实际上不需要JavaScript的帮助！从上到下设置一个线性渐变，然后设置<code class="fe mo mp mq mr b">background-clip:text;</code>(和它的-webkit等价物)</li><li id="020e" class="ly lz it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">因此，不仅脚本比需要的要大很多倍，而且这是一个典型的写得很差的笨蛋，你可以从火车残骸的洗衣单中看到如何不写JavaScript，即jQuery。15年前推出时，它是一种无能的垃圾，到2021年，它就是一种令人麻木的愚蠢垃圾。我不知道那个臭屁是如何流行起来的。</li></ol><p id="d730" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">真的对我来说，如果你需要一个2k的脚本和7k的CSS的“插件”来做这件事，嗯…有些不对劲。这并不是说这完全取决于所述“插件”的原始创建者——Arbel Hakopian——考虑到当它被编写时——<em class="ms">显然是2014</em>——我们可以利用的许多花哨的CSS功能——<em class="ms">如背景剪辑</em>——甚至不可在现实世界中部署。</p><p id="093b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即便如此，这也是我从那些被dumbassery的灾难所迷惑的人们那里所期待的混乱类型，这些框架包括jQuery、Angular、React、Vue等等。</p><h1 id="bf33" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">做得更好</h1><p id="42bd" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">正如我所说，我们真正需要做的就是应用<code class="fe mo mp mq mr b">background-style</code>和<code class="fe mo mp mq mr b">background-clip</code>来解决这个问题。</p><p id="aa1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ms">注意，以下所有代码都假设正在使用复位。</em></p><p id="7507" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，从上到下的线性渐变:</p><pre class="mw mx my mz gt na mr nb nc aw nd bi"><span id="d853" class="ne lb it mr b gy nf ng l nh ni">&lt;p class=”test”&gt;To Bottom Gradient&lt;/p&gt;</span></pre><p id="409c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用此CSS:</p><pre class="mw mx my mz gt na mr nb nc aw nd bi"><span id="7c33" class="ne lb it mr b gy nf ng l nh ni">.test {<br/>  background-image:linear-gradient(<br/>    to bottom,<br/>    #FF0000 0%,<br/>    #0000FF 100%<br/>  );<br/>  background-clip:text;<br/>  --webkit-background-clip:text;<br/>  color:transparent;<br/>}</span></pre><p id="c055" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这基本上给了我们这个:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/d86052958478a0f9fab6816122299dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIJUR6BMuULZ7UJk-RWJIw.png"/></div></div></figure><p id="2534" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将容器切换为收缩到文本(内联块、浮动等)，并将“<code class="fe mo mp mq mr b">to bottom</code>”替换为“【T4”)，我们会得到这样的结果:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/6829a616ce0509aab159c0cd20f4508d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVTCqYc49G6qywjLkUTcPQ.png"/></div></div></figure><p id="a649" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嘭，我们完成了大部分工作。你可以对线性渐变做的任何事情，我们都可以对文本做。例如，如果我们将顶部到底部的渐变改为:</p><pre class="mw mx my mz gt na mr nb nc aw nd bi"><span id="d814" class="ne lb it mr b gy nf ng l nh ni">background-image:linear-gradient(<br/>  to bottom,<br/>  #FF0000 0%,<br/>  #FF0000 50%,<br/>  #0000FF 50%,<br/>  #0000FF 100%<br/>);</span></pre><p id="1763" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到这个:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/edba84e3adf92a2927eac748273e81fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83wtV4R8LGUOCFiPmK9_YQ.png"/></div></div></figure><h2 id="a956" class="ne lb it bd lc nk nl dn lg nm nn dp lk km no np lo kq nq nr ls ku ns nt lw nu bi translated">这是怎么回事？</h2><p id="be9d" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">通过设置文本为透明，我们让背景显示出来。<code class="fe mo mp mq mr b">background-clip:text;</code>设置告诉浏览器只绘制文本后面的背景…这就是它显示的方式。</p><p id="45d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单的柠檬榨汁机。</p><h1 id="b1db" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">每个角色呢？</h1><p id="e49e" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">您实际上可以在不编写脚本的情况下完成这项工作，尽管这有点痛苦。每个字符加一个跨度就行了。</p><pre class="mw mx my mz gt na mr nb nc aw nd bi"><span id="2623" class="ne lb it mr b gy nf ng l nh ni">&lt;p class="test"&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;/p&gt;</span></pre><p id="e614" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这真的很糟糕。它消耗带宽，消耗你的时间和精力，真糟糕。</p><p id="967a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我要使用Javascript来帮助…将标记转换成如下形式的地方:</p><pre class="mw mx my mz gt na mr nb nc aw nd bi"><span id="084e" class="ne lb it mr b gy nf ng l nh ni">&lt;p class="test jsWrapEachChar"&gt;To Right Third Each Char&lt;/p&gt;</span></pre><p id="dbb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用这个简单的小脚本:</p><pre class="mw mx my mz gt na mr nb nc aw nd bi"><span id="121b" class="ne lb it mr b gy nf ng l nh ni">(function(d) {<br/>  <br/>  for (var wrapper of d.getElementsByClassName("jsWrapEachChar")) {<br/>    var text = wrapper.textContent;<br/>    wrapper.textContent = "";<br/>    for (var char of text) {<br/>      var span = wrapper.appendChild(d.createElement('span'));<br/>      span.textContent = char;<br/>    }<br/>    <br/>  }<br/>  <br/>})(document);</span></pre><p id="146d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一种隔离范围的生活，这样我们就不用到处说“T1”了。jsWrapEachChar，获取它们的文本，清空元素，然后直接在DOM上为每个字符生成span。</p><p id="aa18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ms">又记，。appendChild返回追加的节点，因此我们不必等待应用值。同样，在脚本发布之前，不会呈现对DOM的脚本更改，所以不要让那些“批量更改”</em> <strong class="kd iu"> <em class="ms">骗子</em> </strong> <em class="ms">的人给你满嘴胡言。</em></p><h1 id="f945" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">让我们来看看它的实际应用</h1><p id="2360" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">这里有一只简单的笔，用多个例子展示了这一点。我使用包装器通过组合子来应用所有东西，而不是用表示类来破坏所有东西。请记住，使用类来说明您希望事情看起来像什么，这与JavaScript中应该做的事情是相反的，无论“HTML/CSS”框架用他们的废话和无能试图告诉您什么。</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="ba88" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">遗留问题</h1><ol class=""><li id="5401" class="ly lz it kd b ke ma ki mb km mc kq md ku me ky mf mg mh mi bi translated">如果文本分成多行，垂直渐变将延伸到容器，而不是每行。您可以通过应用与每个角色版本相同的方式来解决这个问题。</li><li id="2149" class="ly lz it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">整个文本的水平渐变指向父容器。这就是为什么codepen演示浮动并清除每个段落，使它们收缩到它们的内容。</li><li id="5bda" class="ly lz it kd b ke mj ki mk km ml kq mm ku mn ky mf mg mh mi bi translated">每个字符周围的一些空白被视为渐变的一部分，因此您可能希望通过将每个渐变的第一个和最后一个百分之五到百分之十作为统一的颜色来进行补偿。</li></ol><h1 id="06b3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="4110" class="pw-post-body-paragraph kb kc it kd b ke ma kg kh ki mb kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">不要只扑向JavaScript来暴力破解每一个答案。CSS现在有了更多的功能，如果迟早他们真的给了我们一种单独定位每个角色的方法，我一点也不奇怪。但是现在，严格地使用脚本来做普通CSS做不到的事情，并确保你彻底地调查，以确保你不是在复制已经存在的东西。</p><p id="24a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经看到了太多最近的暴力代码重新创建函数和功能，CSS或甚至普通的HTML应该做繁重的工作。</p></div></div>    
</body>
</html>