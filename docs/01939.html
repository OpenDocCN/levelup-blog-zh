<html>
<head>
<title>Introduction to Testing with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest测试简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-testing-with-jest-dea351005af0?source=collection_archive---------10-----------------------#2020-02-07">https://levelup.gitconnected.com/introduction-to-testing-with-jest-dea351005af0?source=collection_archive---------10-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/467590229733c259596a99f0d4ddaa03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vVWVCVDq5TxFKLVS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="606f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着应用程序变得如此复杂，我们需要一些方法来验证我们对应用程序的更改没有导致倒退。为此，我们需要单元测试。</p><p id="bbc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Jest test runner，我们可以轻松地将单元测试添加到JavaScript应用程序中。它很容易运行，我们可以用它编写大量运行迅速的测试。</p><p id="9988" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何从头开始设置Jest，并用它编写一些测试。同步和异步功能都将被测试。</p><h1 id="58b7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">入门指南</h1><p id="e597" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们只需运行几个命令。在我们应用程序的项目文件夹中，我们运行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8a23" class="mq lf it mm b gy mr ms l mt mu">yarn add --dev jest</span></pre><p id="96b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="59a3" class="mq lf it mm b gy mr ms l mt mu">npm install --save-dev jest</span></pre><p id="7d7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为我们的JavaScript应用程序添加Jest。</p><p id="1878" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们下面的例子将有2个简单的脚本，每个脚本包含一个有几个功能的模块。</p><p id="d736" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们创建要测试的代码。我们将测试调用和不调用API的代码。</p><p id="81a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建<code class="fe mv mw mx mm b">example.js</code>并放入以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2952" class="mq lf it mm b gy mr ms l mt mu">const add = (a, b) =&gt; a + b;<br/>const identity = a =&gt; a;<br/>const deepCopy = (obj, copiedObj) =&gt; {<br/>    if (!copiedObj) {<br/>        copiedObj = {};<br/>    }<br/>    for (let prop of Object.keys(obj)) {<br/>        copiedObj = {<br/>            ...copiedObj,<br/>            ...obj<br/>        };<br/>        if (typeof obj[prop] === 'object' &amp;&amp; !copiedObj[prop]) {<br/>            copiedObj = {<br/>                ...copiedObj,<br/>                ...obj[prop]<br/>            };<br/>            deepCopy(obj[prop], copiedObj);<br/>        }<br/>    }<br/>    return copiedObj;<br/>}<br/>module.exports = {<br/>    add,<br/>    identity,<br/>    deepCopy<br/>}</span></pre><p id="4fc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有两个函数，一个是将数字相加的函数，另一个是返回它传入的相同内容的函数。</p><p id="3a82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用下面的代码创建<code class="fe mv mw mx mm b">request.js</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c9ae" class="mq lf it mm b gy mr ms l mt mu">const fetchJokes = async () =&gt; {<br/>    const response = await fetch('<a class="ae kf" href="http://api.icndb.com/jokes/random/'" rel="noopener ugc nofollow" target="_blank">http://api.icndb.com/jokes/random/'</a>);<br/>    return response.json();<br/>};<br/>module.exports = {<br/>    fetchJokes<br/>}</span></pre><p id="cc7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码从<a class="ae kf" href="http://www.icndb.com/api/" rel="noopener ugc nofollow" target="_blank"> Chuck Norris笑话API </a>中获取随机笑话。</p><h1 id="b901" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为同步代码编写测试</h1><p id="bed8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们有了想要测试的代码，我们准备为它们创建一些测试代码。</p><p id="8b33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们为<code class="fe mv mw mx mm b">example.js</code>中的函数创建测试。</p><p id="ea78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加了以下测试:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fe01" class="mq lf it mm b gy mr ms l mt mu">const { add, identity } = require('./example');</span><span id="c450" class="mq lf it mm b gy my ms l mt mu">test('adds 1 + 2 to equal 3', () =&gt; {<br/>    expect(add(1, 2)).toBe(3);<br/>});</span><span id="51d7" class="mq lf it mm b gy my ms l mt mu">test('adds 1 + 2 is truthy', () =&gt; {<br/>    const sum = add(1, 2);<br/>    expect(sum).toBeTruthy();<br/>});</span><span id="1617" class="mq lf it mm b gy my ms l mt mu">test('adds 1 + 2 to be defined', () =&gt; {<br/>    const sum = add(1, 2);<br/>    expect(sum).not.toBeUndefined();<br/>    expect(sum).toBeDefined();<br/>});</span><span id="ebef" class="mq lf it mm b gy my ms l mt mu">test('identity(null) to be falsy', () =&gt; {<br/>    expect(identity(null)).toBeFalsy();<br/>    expect(identity(null)).not.toBeTruthy();<br/>});</span></pre><p id="5d70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码非常简单。它从<code class="fe mv mw mx mm b">example.js</code>导入函数，并用它运行测试。</p><p id="08e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个测试通过传入2个数字从<code class="fe mv mw mx mm b">example.js</code>调用<code class="fe mv mw mx mm b">add</code>,并检查返回的结果是否是我们所期望的。</p><p id="8574" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的两个测试非常相似，除了我们使用不同的匹配器函数来检查结果。</p><p id="a221" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个测试使用<code class="fe mv mw mx mm b">null</code>运行<code class="fe mv mw mx mm b">identity</code>函数，他们使用<code class="fe mv mw mx mm b">toBeFalsy</code>和<code class="fe mv mw mx mm b">not.toBeTruthy</code>匹配器来检查<code class="fe mv mw mx mm b">null</code>是否确实是假的。</p><p id="57be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总之，Jest有以下匹配器:</p><ul class=""><li id="9c65" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeNull</code> —仅匹配<code class="fe mv mw mx mm b">null</code></li><li id="b2c9" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeUndefined</code> —仅匹配<code class="fe mv mw mx mm b">undefined</code></li><li id="da31" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeDefined</code> —与<code class="fe mv mw mx mm b">toBeUndefined</code>相反</li><li id="fa6d" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeTruthy</code> —匹配任何真实的东西</li><li id="fc8d" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeFalsy</code> —匹配任何虚假的东西</li><li id="3e06" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeGreaterThan</code> —检查一个值是否比我们期望的大</li><li id="9358" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeGreaterThanOrEqual</code> —检查一个值是否大于或等于我们期望的值</li><li id="41c5" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeLessThan</code> —检查值是否小于我们的期望值</li><li id="1676" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeLessThanOrEqual</code> —检查值是否小于或等于我们期望的值</li><li id="ee57" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBe</code> —使用<code class="fe mv mw mx mm b">Object.is</code>比较数值，检查数值是否相同</li><li id="8e97" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toEqual</code> —递归检查两个对象的每个字段，看它们是否相同</li><li id="d826" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toBeCloseTo</code> —检查浮点值是否相等。</li><li id="1c5a" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toMatch</code> —检查字符串是否与给定的正则表达式匹配</li><li id="9918" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toContain</code> —检查数组是否有给定值</li><li id="761a" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">toThrow</code> —检查是否抛出异常</li></ul><p id="cb63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的是<code class="fe mv mw mx mm b">expect</code>方法的完整列表<a class="ae kf" href="https://jestjs.io/docs/en/expect" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a66f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将它们添加到<code class="fe mv mw mx mm b">example.test.js</code>中，我们可以如下使用其中一些:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fcc9" class="mq lf it mm b gy mr ms l mt mu">test('but there is a "foo" in foobar', () =&gt; {<br/>    expect('foobar').toMatch(/foo/);<br/>});</span><span id="4cfd" class="mq lf it mm b gy my ms l mt mu">test(<br/>    'deep copies an object and returns an object with the same properties and values',<br/>    () =&gt; {<br/>        const obj = {<br/>            foo: {<br/>                bar: {<br/>                    bar: 1<br/>                },<br/>                a: 2<br/>            }<br/>        };<br/>        expect(deepCopy(obj)).toEqual(obj);<br/>    }<br/>);</span></pre><p id="ee3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用<code class="fe mv mw mx mm b">toMatch</code>匹配器来检查<code class="fe mv mw mx mm b">'foobar'</code>在第一次测试中是否有<code class="fe mv mw mx mm b">'foo'</code>子串。</p><p id="b13a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二个测试中，我们运行之前添加的<code class="fe mv mw mx mm b">deepCopy</code>函数，并测试它是否真的用<code class="fe mv mw mx mm b">toEqual</code>匹配器递归地复制了一个对象的结构。</p><p id="520f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">toEqual</code>非常方便，因为它通过递归检查对象中的所有内容来检查深度相等，而不仅仅是检查引用相等。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/7bc4471a4f9eabb1226f33218e1728d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xZzNAcsq98opu2_k"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@noguidebook?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉结</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1ee9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为异步和HTTP请求代码编写测试</h1><p id="3281" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为HTTP测试编写测试需要一些思考。我们希望测试可以在任何有或没有互联网连接的地方进行。此外，测试不应该依赖于实时服务器的结果，因为它应该是自包含的。</p><p id="dc96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们必须模拟HTTP请求，而不是直接调用我们的代码。</p><p id="dd62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试我们在<code class="fe mv mw mx mm b">request.js</code>中的<code class="fe mv mw mx mm b">fetchJokes</code>函数，我们必须模拟这个函数。</p><p id="9872" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们在项目文件夹中创建一个<code class="fe mv mw mx mm b">__mocks__</code>文件夹，并在其中创建<code class="fe mv mw mx mm b">requests.js</code>。文件名应该总是与我们正在模仿的代码的文件名相匹配。</p><p id="d57d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样嘲笑它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e730" class="mq lf it mm b gy mr ms l mt mu">const fetchJokes = async () =&gt; {<br/>    const mockResponse = {<br/>        "type": "success",<br/>        "value": {<br/>            "id": 407,<br/>            "joke": "Chuck Norris originally wrote the first dictionary. The definition for each word is as follows - A swift roundhouse kick to the face.",<br/>            "categories": [</span><span id="5996" class="mq lf it mm b gy my ms l mt mu">]<br/>        }<br/>    };<br/>    return Promise.resolve(mockResponse);<br/>};<br/>module.exports = {<br/>    fetchJokes<br/>}</span></pre><p id="2a10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">真实和模拟的<code class="fe mv mw mx mm b">fetchJokes</code>函数都返回一个承诺。真实函数从<code class="fe mv mw mx mm b">fetch</code>函数返回一个承诺，而模拟函数直接调用<code class="fe mv mw mx mm b">Promise.resolve</code>。</p><p id="f407" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着真实的测试实际上会发出GET请求，模拟测试会解析出我们想要测试的响应。</p><p id="be2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mv mw mx mm b">example.test.js</code>中，我们添加:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="599a" class="mq lf it mm b gy mr ms l mt mu">jest.mock('./request');<br/>const { fetchJokes } = require('./request');</span></pre><p id="8e79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加到文件的顶部，并且:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fd46" class="mq lf it mm b gy mr ms l mt mu">test('jokes to be fetched', async () =&gt; {<br/>    const mockResponse = {<br/>        "type": "success",<br/>        "value": {<br/>            "id": 407,<br/>            "joke": "Chuck Norris originally wrote the first dictionary. The definition for each word is as follows - A swift roundhouse kick to the face.",<br/>            "categories": [</span><span id="71f5" class="mq lf it mm b gy my ms l mt mu">]<br/>        }<br/>    };<br/>    await expect(fetchJokes()).resolves.toEqual(mockResponse)<br/>});</span></pre><p id="d361" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">追根究底。</p><p id="170f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的测试只是调用了mock <code class="fe mv mw mx mm b">fetchJokes</code>函数，因为我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3afd" class="mq lf it mm b gy mr ms l mt mu">jest.mock('./request');</span></pre><p id="ab4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们仍然需要导入真实的，因为当测试运行时，真实的会被模拟的替换。</p><p id="ea22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">resolves</code>将解析从模拟<code class="fe mv mw mx mm b">fetchJokes</code>函数返回的承诺，而<code class="fe mv mw mx mm b">toEqual</code>将根据承诺的解析值检查响应的结构。</p><p id="5aea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在<code class="fe mv mw mx mm b">package.json</code>的<code class="fe mv mw mx mm b">scripts</code>部分，我们放入:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4835" class="mq lf it mm b gy mr ms l mt mu">"test": "jest"</span></pre><p id="1d4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以运行<code class="fe mv mw mx mm b">npm test</code>来运行测试。</p><p id="9848" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们运行<code class="fe mv mw mx mm b">npm test</code>时，我们应该得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1f08" class="mq lf it mm b gy mr ms l mt mu">PASS  ./example.test.js<br/>  √ adds 1 + 2 to equal 3 (2ms)<br/>  √ adds 1 + 2 is truthy<br/>  √ adds 1 + 2 to be defined (1ms)<br/>  √ identity(null) to be falsy<br/>  √ but there is a "foo" in foobar<br/>  √ deep copies an object and returns an object with the same properties and values (1ms)<br/>  √ jokes to be fetched (1ms)</span><span id="6059" class="mq lf it mm b gy my ms l mt mu">Test Suites: 1 passed, 1 total<br/>Tests:       7 passed, 7 total<br/>Snapshots:   0 total<br/>Time:        1.812s, estimated 2s<br/>Ran all test suites.</span></pre><p id="7bf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论我们何时以何种方式运行测试，它们都应该通过，因为它们彼此独立，不依赖于外部网络请求。</p><h1 id="1e11" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="6489" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们编写单元测试时，我们必须确保每个测试都是相互独立的，并且应该发出任何网络请求。</p><p id="a9e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jest使测试变得容易，它允许模仿像使HTTP请求变得容易的代码这样的东西。</p><p id="e647" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也很容易设置，并且有许多匹配器用于各种测试。</p></div></div>    
</body>
</html>