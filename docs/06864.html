<html>
<head>
<title>Experimenting with Podman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用波德曼做实验</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/experimenting-with-podman-e6cb24428bfd?source=collection_archive---------4-----------------------#2021-01-09">https://levelup.gitconnected.com/experimenting-with-podman-e6cb24428bfd?source=collection_archive---------4-----------------------#2021-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2830" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更安全、高度兼容的Docker替代方案？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3dca3854a8b8cf9fffc82e4471309505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ereQyFUlQ2cRew5KCxD57A.png"/></div></div></figure><p id="87e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在过去的十年里，<a class="ae lq" href="https://docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>通过将自动化集装箱化技术推向市场，让我们能够在一块裸机上运行比以往任何时候都更多的独立应用程序，彻底改变了我们的行业。所以我不认为Docker会很快消失，即使k8s最近宣布<a class="ae lq" href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/" rel="noopener ugc nofollow" target="_blank">反对Docker的运行时</a>。然而，事实是，从安全角度来看，以root用户身份运行应用程序或拥有具有广泛特权的容器是不可取的，这一直是安全社区对Docker的主要批评。</p><p id="3673" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，既然现在有了新的选择，为什么即使是有安全意识的人也不离开Docker呢？也许是因为一旦你完全投入到大规模部署的底层基础设施中，就很难再切换到另一个替代方案。从让您的团队熟悉一组新的命令行工具和重建容器映像，一直到处理一般的兼容性问题，都是需要关注的原因。所以你已经可以想象为什么Docker仍然如此受欢迎，尽管它有这个明显的安全缺陷。</p><p id="9bfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么《T4》对我来说是一个如此有趣的项目。乍一看，它不仅解决了Docker的基本安全缺陷，而且从用户的角度来看，它的工作方式与Docker非常相似。你可以把命令中的单词“docker”换成“podman ”,一切都像预期的那样工作，不需要学习新的标志。你也可以运行现有的docker图像或任何OCI兼容的图像。这简直好得令人难以置信。因此，最近，随着我永无止境的好奇心的激发，我决定尝试一下波德曼的基础知识，看看它是否会像宣传的那样成功。</p><blockquote class="lr"><p id="7761" class="ls lt it bd lu lv lw lx ly lz ma lp dk translated"><a class="ae lq" href="http://podman.io/" rel="noopener ugc nofollow" target="_blank"> Podman </a>是一款无后台、开源的Linux原生工具，旨在使用开放容器倡议(<a class="ae lq" href="https://www.opencontainers.org/" rel="noopener ugc nofollow" target="_blank">【OCI】</a>)<a class="ae lq" href="https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/#h.j2uq93kgxe0e" rel="noopener ugc nofollow" target="_blank">容器</a>和<a class="ae lq" href="https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/#h.dqlu6589ootw" rel="noopener ugc nofollow" target="_blank">容器映像</a>)轻松查找、运行、构建、共享和部署应用。Podman提供了一个命令行界面(CLI ),任何使用过Docker <a class="ae lq" href="https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/#h.6yt1ex5wfo3l" rel="noopener ugc nofollow" target="_blank">容器引擎</a>的人都很熟悉。大多数用户可以简单地将Docker别名为Podman(别名docker=podman)而没有任何问题。</p></blockquote><h2 id="bc4f" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">测试</h2><p id="da1c" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">由于我最近一直在探索一种方法来构建一个具有联系人和日历管理功能的健壮的邮件系统，以取代GSuite、Office365等，所以我决定使用与电子邮件服务相关的docker图像对Podman进行一个快速测试，这样我可以一举两得。在我的第一次测试中，我从NGINX和iRedMail开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/22f57ee6aa7533c872d110755c096145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XibLRlE8yG1Bu4B3bPWQqg.png"/></div></div></figure><p id="1e18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，在我们开始之前，让我们稍微谈一下安装。由于波德曼现在是20.10版Ubuntu官方库的一部分，你只需执行下面的命令，一切都完成了:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3267" class="mb mc it nb b gy nf ng l nh ni">sudo apt install podman</span></pre><p id="7859" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果你使用的是LTS版本，并且像我一样喜欢继续使用它，要在20.04上安装Podman，你需要做的是:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9815" class="mb mc it nb b gy nf ng l nh ni">echo 'deb <a class="ae lq" href="http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/" rel="noopener ugc nofollow" target="_blank">http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/</a> /' | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><span id="a6fd" class="mb mc it nb b gy nj ng l nh ni">curl -fsSL <a class="ae lq" href="https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/xUbuntu_20.04/Release.key" rel="noopener ugc nofollow" target="_blank">https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/xUbuntu_20.04/Release.key</a> | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/devel_kubic_libcontainers_stable.gpg &gt; /dev/null</span><span id="4333" class="mb mc it nb b gy nj ng l nh ni">sudo apt update<br/>sudo apt install podman</span></pre><p id="7234" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会注意到，与docker不同，您不再需要将您的用户添加到docker组来启动没有sudo的容器。这是因为Podman是无守护进程和无根的，所以你可以直接用你当前的用户运行容器，因为不需要额外的特权。</p><p id="9723" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，从文档的外观来看，我可以创建网络并以完全相同的方式启动Docker映像。因此，让我们尝试创建一个带有自定义子网的网络:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b541" class="mb mc it nb b gy nf ng l nh ni">hkdb@vm:~$ podman network create mailnet --subnet 172.20.0.0/24<br/>/home/hkdb/.config/cni/net.d/mailnet.conflist</span></pre><p id="6587" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查一下它是否达到了我想要的效果:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e04c" class="mb mc it nb b gy nf ng l nh ni">hkdb@vm:~$ podman network ls<br/>NAME     VERSION  PLUGINS<br/>mailnet  0.4.0    bridge,portmap,firewall,tuning,dnsname</span></pre><p id="668c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来不错！我们现在有了一个网络，为我们的容器自定义了一个子网。现在让我们在我们构建的网络中尝试一个简单的NGINX映像，将端口80和443发布给本地主机:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="dd49" class="mb mc it nb b gy nf ng l nh ni">hkdb@vm:~$ podman run -d --name nginx --net mailnet -p 80:80 -p 443:443 nginx<br/>Completed short name "nginx" with unqualified-search registries (origin: /etc/containers/registries.conf)<br/>Trying to pull docker.io/library/nginx:latest...<br/>Getting image source signatures<br/>Copying blob 2766c0bf2b07 done  <br/>Copying blob 6ec7b7d162b2 done  <br/>Copying blob cb420a90068e done  <br/>Copying blob e05167b6a99d done  <br/>Copying blob 70ac9d795e79 done  <br/>Copying config ae2feff98a done  <br/>Writing manifest to image destination<br/>Storing signatures<br/>d9d22f385757a86e14b1c8d2c4bfdba3717b595444b9b26db0a15299e8c2706a</span></pre><p id="0793" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查一下集装箱:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7b74" class="mb mc it nb b gy nf ng l nh ni">hkdb@vm:~$ podman ps<br/>CONTAINER ID  IMAGE                                                                                                      COMMAND               CREATED             STATUS                 PORTS                                     NAMES<br/>d9d22f385757  docker.io/library/nginx:latest                                                                             nginx -g daemon o...  About a minute ago  Up About a minute ago  0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp  nginx<br/>f573472abe40  quay.io/libpod/rootless-cni-infra@sha256:304742d5d221211df4ec672807a5842ff11e3729c50bc424ea0cea858f69d7b7  sleep infinity        About a minute ago  Up About a minute ago                                            rootless-cni-infra</span></pre><p id="4f14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意到有一个名为“无根cni-infra”的容器了吗？由于我们指定nginx容器发布端口80和443，所以podman自动启动这一功能，使“无根容器”能够访问本地主机。</p><p id="072c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">IP地址呢:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0718" class="mb mc it nb b gy nf ng l nh ni">hkdb@vm:~$ podman inspect nginx |grep IPAddress<br/>            "IPAddress": "",<br/>                    "IPAddress": "172.20.0.2",</span></pre><p id="0e22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来这个容器的IP是172.20.0.2，这意味着这个容器实际上运行在我们创建的网络中。那么，您可能会问，静态IP怎么样？嗯，不幸的是，这是维护人员目前正在处理的一个问题，但是看起来我们离看到这个补丁击中主分支并不是太远了。</p><p id="33d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，让我们继续测试更复杂的东西，通过使用预定义的持久存储启动iRedMail，并使用-rm标志，以便在完成后自动删除容器:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5bba" class="mb mc it nb b gy nf ng l nh ni">podman run --rm --name iredmail --env-file iredmail-docker.conf \<br/>   --hostname jasper.syndr.io --net mailnet \<br/>   -p 80:80 -p 443:443 -p 110:110 -p 995:995 \<br/>   -p 143:143 -p 993:993 -p 25:25 -p 465:465 -p 587:587 \<br/>   -v $HOME/data/backup:/var/vmail/backup \<br/>   -v $HOME/iredmail/data/mailboxes:/var/vmail/vmail1 \<br/>   -v $HOME/iredmail/data/mlmmj:/var/vmail/mlmmj \<br/>   -v $HOME/iredmail/data/mlmmj-archive:/var/vmail/mlmmj-archive \<br/>   -v $HOME/iredmail/data/imapsieve_copy:/var/vmail/imapsieve_copy \<br/>   -v $HOME/iredmail/data/custom:/opt/iredmail/custom \<br/>   -v $HOME/iredmail/data/ssl:/opt/iredmail/ssl \<br/>   -v $HOME/iredmail/data/mysql:/var/lib/mysql \<br/>   -v $HOME/iredmail/data/clamav:/var/lib/clamav \<br/>   -v $HOME/iredmail/data/sa_rules:/var/lib/spamassassin \<br/>   -v $HOME/iredmail/data/postfix_queue:/var/spool/postfix \<br/>   iredmail/mariadb:stable</span></pre><p id="6b08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">砰。iRedMail已经启动，我可以测试它，看看它是否适合我的需求。不幸的是，从这个测试中，我发现iRedMail不符合我的要求，但这超出了本主题的范围。</p><p id="5a9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，到目前为止，这只是一个基本的测试，需要更多的时间来彻底验证波德曼作为码头工人的替代者的工作情况。我还需要一点时间来给<a class="ae lq" href="https://github.com/containers/podman-compose" rel="noopener ugc nofollow" target="_blank">波德曼-作曲</a>和<a class="ae lq" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank">建造</a>(波德曼的“码头工人建造”)一个全面的尝试。此外，如前所述，仍有一些问题有待解决，如静态IP问题。我猜到了下一个Ubuntu LTS，它可能会更接近一个稳定的替代品？</p></div></div>    
</body>
</html>