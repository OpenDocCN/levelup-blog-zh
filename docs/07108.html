<html>
<head>
<title>Golang Generics: A New Proposal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang仿制药:一项新提议</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-generics-proposal-2021-4510b715b5d0?source=collection_archive---------14-----------------------#2021-01-25">https://levelup.gitconnected.com/golang-generics-proposal-2021-4510b715b5d0?source=collection_archive---------14-----------------------#2021-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6d46" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><div class=""><h2 id="ec85" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">对最近Golang增加泛型的提议草案的简短分析——包括什么，排除什么，以及它将如何影响语言。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4e1b1bbb5b524160dec74e81ed7ab3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85mN1gWmq7ieQ9qy3a5rPg.png"/></div></div></figure><p id="ee90" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">日前，<strong class="lc ja"> Golang </strong>中<strong class="lc ja">仿制药</strong>实现的新<a class="ae lw" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md" rel="noopener ugc nofollow" target="_blank">建议稿提交。这是对该草案的简要分析。如果你知道什么是<strong class="lc ja">泛型</strong>并且意识到Go中缺少它们的含义，你可以跳过第一部分，直接进入</a><a class="ae lw" href="#fe19" rel="noopener ugc nofollow">这里</a>。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="74fc" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">什么是“仿制药”，它们解决什么需求？</h1><p id="728a" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">很长一段时间以来，这种语言缺乏基于通用的、<strong class="lc ja">参数化类型</strong>而不是<strong class="lc ja">具体类型</strong>定义函数和其他实体的能力。因此，例如，寻找最小值和最大值的函数<code class="fe nb nc nd ne b">math.Min()</code>和<code class="fe nb nc nd ne b">math.Max()</code>只在<code class="fe nb nc nd ne b">float64</code>的标准库中定义。没有提供任何其他类型的最小值/最大值。即使一个人想创建自己的最小-最大包，为各种类型使用类似<code class="fe nb nc nd ne b">mymath.Min()</code>或<code class="fe nb nc nd ne b">mymath.Max()</code>的功能，他们也不能这样做。这种语言的当前结构不允许这样的代码:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="bd45" class="nj mf iq ne b gy nk nl l nm nn">var vi, ui <strong class="ne ja">int</strong><br/>var vi8, ui8 <strong class="ne ja">int8</strong><br/>	<br/>vi = <strong class="ne ja">min</strong>(102, ui)<br/>vi8 = <strong class="ne ja">min</strong>(ui8, 3)</span></pre><p id="accc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在第一个赋值中，函数<code class="fe nb nc nd ne b">Min()</code>与<code class="fe nb nc nd ne b">int</code>参数一起使用(至少一个；另一个是一个<strong class="lc ja">文字</strong>，转换后与之匹配)。该函数的结果也被赋给一个int类型的变量。在第二次赋值时，调用了一个同名的函数，但是这一次，它应该接受<code class="fe nb nc nd ne b">int8</code>参数并返回一个<code class="fe nb nc nd ne b">int8</code>结果。</p><p id="04f5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是我们怎样才能做到这一点呢？  <br/>一方面，Go要求明确、具体的自变量类型作为函数定义的一部分。这意味着单个函数的每个参数只能有一种类型。例如，下面的代码只能处理类型为<code class="fe nb nc nd ne b">int</code>的参数，并且总是返回该类型的结果:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="6d8b" class="nj mf iq ne b gy nk nl l nm nn">func Min(a, b <strong class="ne ja">int</strong>) <strong class="ne ja">int </strong>{   <br/>    if a &lt; b {     <br/>        return a   <br/>    }   <br/>    return b <br/>}</span></pre><p id="0c75" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">另一方面，语言不允许<a class="ae lw" href="https://en.wikipedia.org/wiki/Function_overloading" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja">函数重载</strong> </a>。这意味着，不能在同一个名称空间中编写几个名为<code class="fe nb nc nd ne b">Min()</code>的函数，它们的区别仅在于参数类型。所以，尝试这样的事情是完全不相关的:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="df3b" class="nj mf iq ne b gy nk nl l nm nn">func <strong class="ne ja">Min</strong>(a, b <strong class="ne ja">int</strong>) <strong class="ne ja">int </strong>{ ... }<br/>func <strong class="ne ja">Min</strong>(a, b <strong class="ne ja">int8</strong>) <strong class="ne ja">int8 </strong>{ ... }</span></pre><p id="42fc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这让我们只有两个选择。要么编写一组几乎相同的函数，它们共享完全相同的逻辑，只有类型<em class="no">和</em>名称不同，比如:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="1a77" class="nj mf iq ne b gy nk nl l nm nn">func <strong class="ne ja">MinInt</strong>(a, b <strong class="ne ja">int</strong>) <strong class="ne ja">int </strong>{ if a &lt; b { return a }; return b } <br/>func <strong class="ne ja">MinInt8</strong>(a, b <strong class="ne ja">int8</strong>) <strong class="ne ja">int8 </strong>{ if a &lt; b { return a }; return b }<br/>func <strong class="ne ja">MinInt16</strong>(a, b <strong class="ne ja">int16</strong>) <strong class="ne ja">int16 </strong>{ if a &lt; b { return a }; return b } </span></pre><p id="80f4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">—哪一个不是我们见过的最漂亮、最清晰、最安全、最优雅的代码；或者，尝试使用该语言当前的通配符<code class="fe nb nc nd ne b">interface{}</code>。另一个选项需要一些难看的代码来将参数转换成实际类型，可以是任何数值类型。更糟糕的是，它的<em class="no">调用者</em>也必须将结果转换为原始类型。<br/> <strong class="lc ja"> <em class="no">这实在是太荒谬了，以至于它不是一个真正的选项。</em> </strong></p><p id="ebe4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们真正想要的是一种优雅的方式，拥有“一枚戒指统治他们所有人”；类似于-</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="bd25" class="nj mf iq ne b gy nk nl l nm nn">func <strong class="ne ja">Min</strong>(a, b «<strong class="ne ja">SOMETYPE</strong>: any numeric type») «that very <strong class="ne ja">SOMETYPE</strong>» { <br/>    if a &lt; b { <br/>        return a <br/>    } <br/>    return b <br/>}</span></pre><p id="ca6e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这将允许我们进行任何形式的调用-</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="cbd7" class="nj mf iq ne b gy nk nl l nm nn">vi = <strong class="ne ja">Min</strong>(102, <strong class="ne ja">ui</strong>)<br/>vi8 = <strong class="ne ja">Min</strong>(<strong class="ne ja">ui8</strong>, 3)<br/>vi16 = <strong class="ne ja">Min</strong>(<strong class="ne ja">ui16</strong>, 0)</span></pre><p id="a630" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">简单。<br/>明朗。<br/>优雅。<br/> <strong class="lc ja">不可能</strong>。</p><p id="a839" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当处理更复杂的类型时，使用<strong class="lc ja">函数</strong>而不是<strong class="lc ja">操作符</strong>来访问，这种语言确实提供了某种灵活性。在这些情况下，使用<strong class="lc ja">接口</strong>允许函数以多态的方式工作。例如，一个函数<code class="fe nb nc nd ne b">f1()</code>可能将其参数定义为类型<code class="fe nb nc nd ne b">Averager</code>，其中<code class="fe nb nc nd ne b">Averager</code>被定义为一个<code class="fe nb nc nd ne b">interface</code>，它需要定义一个名为<code class="fe nb nc nd ne b">Average()</code>的函数。这样，<code class="fe nb nc nd ne b">f1()</code>就可以安全地在它上面调用<code class="fe nb nc nd ne b">Average()</code>，而不需要知道它的实际类型，相应的<code class="fe nb nc nd ne b">Average()</code>函数就会被调用。这是Go中<strong class="lc ja">多态性</strong>的标准实现。</p><p id="eacd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些类型的“最小公分母”是已经提到的类型<code class="fe nb nc nd ne b">interface{}</code>，它没有定义任何函数。因此，它可以被任何其他类型所取代——但出于同样的原因，它的用处要小得多。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="fe19" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">它是如何工作的？</h1><p id="1bda" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">新提案将上述关于使用“<code class="fe nb nc nd ne b">SOMETYPE</code>”的想法正式化。<strong class="lc ja">类型参数</strong>出现在函数名及其括号之间的方括号中。例如，可以编写这样一个函数:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="2277" class="nj mf iq ne b gy nk nl l nm nn">// Stringify accepts a slice of any type that <br/>// implements the Stringer interface:<br/>func Stringify<strong class="ne ja">[T Stringer]</strong>(s1, s2 []<strong class="ne ja">T</strong>) (ret []string) {<br/>  ...<br/>}</span></pre><p id="6bde" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这个函数<code class="fe nb nc nd ne b">Stringify()</code>接受一个类型参数<code class="fe nb nc nd ne b">T</code>；但是，并不是任何类型都可以作为<code class="fe nb nc nd ne b">T</code>的替代品。只有实现了<code class="fe nb nc nd ne b">Stringer</code>接口的类型才适合。然后，它得到两个参数，<code class="fe nb nc nd ne b">s1</code>和<code class="fe nb nc nd ne b">s2</code>，它们必须是为<code class="fe nb nc nd ne b">T</code>选择的相同类型。跟在类型参数后面的类型——例如，在那个例子中的<code class="fe nb nc nd ne b">Stringer</code>——是<code class="fe nb nc nd ne b">T</code>上的<strong class="lc ja">约束</strong>。如果没有应用约束，则提供新的关键字<code class="fe nb nc nd ne b">any</code>。</p><p id="9e5b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">也可以以参数形式定义复杂的<strong class="lc ja">类型</strong>。例如:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="b92c" class="nj mf iq ne b gy nk nl l nm nn">// Vector is a name for a slice of any element type.<br/>type Vector<strong class="ne ja">[T any]</strong> []T<br/>...<br/>var vi Vector<strong class="ne ja">[int]</strong> <br/>var vf Vector<strong class="ne ja">[float64]</strong></span></pre><blockquote class="np nq nr"><p id="f20b" class="la lb no lc b ld le ka lf lg lh kd li ns lk ll lm nt lo lp lq nu ls lt lu lv ij bi translated">有趣的是，在这里，就像在许多其他语法问题中一样，Go似乎有意地不同于c++及其表亲的常见形式。<em class="iq">尖括号</em>、<code class="fe nb nc nd ne b">&lt;T&gt;</code>——模板<strong class="lc ja">或<strong class="lc ja">仿制药</strong>无可置疑的传统“商标”——被弃用，取而代之的是<em class="iq">方括号</em>。这个提议解释了其中的原因(提示:对Go编译规则的限制)。<br/>不仅靠<em class="iq">形式</em>，还靠<em class="iq">概念</em>，围棋和那些语言有很大的不同，即使是选秀被接受。其他编译语言，如<strong class="lc ja"> C++ </strong>、<strong class="lc ja"> Java </strong>或<strong class="lc ja"> Rust </strong>，提供了极其强大的通用/模板工具，这些工具在通用设计和开发中发挥了重要作用。围棋，至少从选秀来看，还远远落后于他们；它的泛型只是少数边缘情况下的次要解决方案。</strong></p></blockquote><p id="ba2c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">编译语言的主要缺点是需要预先为每个平台准备二进制产品。另一方面，这种语言的优势在于它们能够生产出更高效的产品，无论是在内存占用方面还是在性能方面。其中一个关键因素是在编译时解析期间使用这些泛型的能力来改善运行时。<br/>然而，围棋并不打算走那条路；那么——<br/><strong class="lc ja"><em class="no">这个提议真的会让Golang更有效率吗？答案是——它可能会，但方式非常有限。<br/>那么，与当前形势相比，该提案的优势是什么？</em></strong></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="1df6" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">该草案的主要好处</h1><p id="6dbf" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">虽然本提案中对泛型的支持相对于其他语言来说非常有限，但它仍然为开发人员提供了几个重要的优势。</p><h2 id="f991" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">将错误从运行时转移到编译时</h2><p id="e664" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">在<strong class="lc ja">编译时</strong>发现错误和bug比在<strong class="lc ja">运行时</strong>发现错误和bug能让代码开发进展得更快。当然，运行时不一定是<em class="no">任何</em>运行；不一定是先<em class="no">后</em>运行；事实上，它可能首先发生在<em class="no">客户端的</em>运行中。原则上，精心制作的<strong class="lc ja">接口</strong>可能会大大降低这种风险。然而，许多Go函数都是使用通用接口作为参数编写的，只有在函数内部才会测试它们的动态类型，并且它们会被转换成适当的具体静态类型<strong class="lc ja"/>。首先，使用泛型可能会改变编码风格，使其更加准确。</p><h2 id="49b4" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">无函数多态</h2><p id="09b9" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">正如本文开头所展示的，接口类型的参数只适合通过多态函数或方法来访问。如果一个函数应该接受非具体类型的参数，并且不是通过<strong class="lc ja">函数</strong>而是通过<strong class="lc ja">操作符</strong>来访问它们，那就完全不同了。</p><p id="7899" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当前的Go语法只能通过在函数中转换成各种可接受的静态类型来实现这一点。然而，这种方法—</p><ol class=""><li id="aadb" class="of og iq lc b ld le lg lh lj oh ln oi lr oj lv ok ol om on bi translated">很麻烦，</li><li id="ad60" class="of og iq lc b ld oo lg op lj oq ln or lr os lv ok ol om on bi translated">违反<strong class="lc ja">OCP</strong>—<a class="ae lw" href="https://swarch.blog/the-five-principles-for-solid-software-design/" rel="noopener ugc nofollow" target="_blank">开/关原理</a>，</li><li id="d7a6" class="of og iq lc b ld oo lg op lj oq ln or lr os lv ok ol om on bi translated">导致性能损失，<em class="no">和</em></li><li id="da27" class="of og iq lc b ld oo lg op lj oq ln or lr os lv ok ol om on bi translated">将错误从编译时移到运行时。</li></ol><p id="f7e8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">另一个选择，正如用<code class="fe nb nc nd ne b">min()</code> / <code class="fe nb nc nd ne b">max()</code>函数所演示的，是编写许多看起来相似的函数，每个具体类型一个。原则上，使用泛型编写这两个函数应该可以解决所有这些问题。</p><h2 id="40d3" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">在多个多态参数之间实施约束</h2><p id="0077" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">Go函数可以接受某种接口类型的参数<code class="fe nb nc nd ne b">Some</code>。类似地，一个函数可能接受该接口类型的两个或多个参数。比如，像这样:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="8fb1" class="nj mf iq ne b gy nk nl l nm nn">func f1(a <strong class="ne ja">Some</strong>) { ... }<br/>func f2(a, b <strong class="ne ja">Some</strong>) { ... }</span></pre><p id="e9a0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在这种情况下，<code class="fe nb nc nd ne b">f1()</code>将为<code class="fe nb nc nd ne b">a</code>接受任何实现接口<code class="fe nb nc nd ne b">Some</code>的东西。如果<code class="fe nb nc nd ne b">Sometimes</code>和<code class="fe nb nc nd ne b">Somewhere</code>都实现了<code class="fe nb nc nd ne b">Some</code>，那么它们中的任何一个都可以正常工作。<code class="fe nb nc nd ne b">f2()</code>中的<code class="fe nb nc nd ne b">a</code>和<code class="fe nb nc nd ne b">b</code>也是如此。当然，也有可能<code class="fe nb nc nd ne b">a</code>是<code class="fe nb nc nd ne b">Sometimes</code>类型，而<code class="fe nb nc nd ne b">Somewhere</code> — <code class="fe nb nc nd ne b">f2()</code>类型的<code class="fe nb nc nd ne b">b</code>不强制它们具有相同的具体类型。<br/><em class="no"/><strong class="lc ja"><em class="no">不能</em> </strong> <em class="no">强制执行</em>。<br/>有时候真的无所谓。但是总有其他的情况。</p><p id="5462" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">使用新提出的泛型语法，可以定义<code class="fe nb nc nd ne b">f3()</code>，它接受实现<code class="fe nb nc nd ne b">Some</code>的同类型的两个参数<strong class="lc ja">:</strong></p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="4e1b" class="nj mf iq ne b gy nk nl l nm nn">func f3<strong class="ne ja">[T Some]</strong>(a, b <strong class="ne ja">T</strong>) { ... }</span></pre><p id="1279" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">用两个<code class="fe nb nc nd ne b">Sometimes</code>参数调用<code class="fe nb nc nd ne b">f3()</code>也可以，用两个<code class="fe nb nc nd ne b">Somewhere</code>参数调用也可以。然而，试图用一个<code class="fe nb nc nd ne b">Sometimes</code>参数和一个<code class="fe nb nc nd ne b">Somewhere</code>参数调用它会破坏编译。同样，不仅可以定义类型相同的参数，还可以定义任何其他基于类型的关系。例如，一个类型为<code class="fe nb nc nd ne b">T</code>的参数和另一个类型为<code class="fe nb nc nd ne b">[]T</code>的参数，等等。</p><h2 id="3d26" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">直接使用泛型类型</h2><p id="b7f7" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">通过接口类型参数获取多态类型的标准Go函数不能直接使用该参数的实际<em class="no">类型</em>。例如，它不能直接创建该类型的局部变量。(由于<strong class="lc ja">反射</strong>，可以出于某种目的间接引用变量的类型；这需要付出代码和性能的代价。)<br/>使用泛型提议，这可以轻松优雅地完成。</p><h2 id="6402" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">使用类型参数定义复杂结构</h2><p id="1b76" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">正如本文开头所展示的，新的提议不仅允许定义泛型函数，还允许定义泛型类型。例如，一个结构保存一些数字类型的两个片段(或者是两个相同的<code class="fe nb nc nd ne b">T</code>，或者是两个可能不同的类型，<code class="fe nb nc nd ne b">T</code>和<code class="fe nb nc nd ne b">S</code>)。使用这些泛型类型，很容易创建具体类型来定义其内部数据的特定类型，并像使用任何其他结构一样使用它们。</p><h2 id="1a42" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">通过直接访问内部元素改善性能和占用空间</h2><p id="c6cd" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">任何通过<code class="fe nb nc nd ne b">interface</code>对数据的访问都是间接地<strong class="lc ja">完成的</strong>:接口从不保存数据本身，而是保存一个指向实际数据的指针。因此，举例来说，一个通过接口持有的<code class="fe nb nc nd ne b">int8</code>，消耗的不仅仅是一个字节的内存。此外，对其值的任何访问都需要“双重访问”:首先是对接口地址的访问，然后是使用它持有的指针对数据本身地址的访问。</p><p id="ac5d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当处理一些这样的问题时，这可能不是一个关键的考虑因素。但是在这种情况下，例如，在一个非常大的切片中，消耗的内存和运行时间可能会急剧增加。再加上一个一直更新所有地址的<strong class="lc ja">垃圾收集器</strong>——这就成了一个真正的问题。根据该提议使用泛型将消除所有开销。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="9bbd" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">在某些实现下，该提议可能会改进什么？</h1><p id="d698" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">当前的草案提出了Go中泛型的<strong class="lc ja">语法</strong>。它没有定义其具体的<strong class="lc ja">实现</strong>。与C++这样的语言不同，Golang的首要目标是始终产生最有效的二进制产品。</p><p id="1a99" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，例如，C++中的<strong class="lc ja">函数模板</strong>是为它们的每个<strong class="lc ja">实例化</strong>单独编译的。假设我们有一个名为<code class="fe nb nc nd ne b">makePairs()</code>的C++函数模板，它接受两个不同泛型类型的向量<code class="fe nb nc nd ne b">vt</code>、<code class="fe nb nc nd ne b">vs</code>和<code class="fe nb nc nd ne b">S</code>，并返回一个向量对，这样第<em class="no">I</em>th对由第<code class="fe nb nc nd ne b">vt</code>个元素<em class="no"> i </em>和第<code class="fe nb nc nd ne b">vs</code>个元素<em class="no"> i </em>组成。如果这个函数被调用——至少一次——使用两个向量<code class="fe nb nc nd ne b">int</code> s，编译器将<em class="no">实例化</em>一个特定的函数。如果在其他地方使用两个向量<code class="fe nb nc nd ne b">double</code>调用该函数，那么编译器将为两个向量<code class="fe nb nc nd ne b">double</code>生成一个额外的<em class="no">实例</em>，如果另一段代码调用<code class="fe nb nc nd ne b">makePairs()</code>并将<code class="fe nb nc nd ne b">vt</code>作为<code class="fe nb nc nd ne b">int</code>并将<code class="fe nb nc nd ne b">vs</code>作为<code class="fe nb nc nd ne b">double</code>，将会创建第三个实例。在编译/链接时，每个调用将被链接到适当的实例，该实例是为这些参数量身定制的。由于不需要对实际类型进行运行时检查，并且编译器可以以最佳方式分别优化每个实例，因此通常会获得最佳性能(这里还涉及到<a class="ae lw" href="https://en.wikipedia.org/wiki/Code_bloat" rel="noopener ugc nofollow" target="_blank">代码膨胀</a>效果、<a class="ae lw" href="https://en.wikipedia.org/wiki/Inline_expansion" rel="noopener ugc nofollow" target="_blank">函数内联</a>和其他注意事项)。但是这是有代价的:任何曾经编译过重要C++项目的人都知道，它极其高效的产品是非常长的编译时间的结果。模板实例化是这种权衡的一部分。</p><p id="ad61" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在Go中，不仅最终二进制的<em class="no">效率很重要，编译过程</em>本身的<em class="no">效率也很重要。当这两者竞争时，Go的编译器会通过它们之间的某种妥协来解决它。出于这个原因，尽管草案没有明确定义泛型的实现，但它假设泛型将采取不同于多实例化的路径。</em></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="b7b5" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">这个提议不允许什么？</h1><h2 id="c59f" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">泛型类型之上的泛型函数</h2><p id="94d2" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">除了最小化<em class="no">二进制产品</em>的运行时间和占用空间，最小化<em class="no">编译过程</em>的时间，Go还努力最小化<em class="no">语言</em>本身。那就是:尽可能保持语法简单。即使以不太优雅的代码或避免复杂的能力为代价，Go也坚持这个原则。它的理念是，最好尽可能保持语法简单，即使完成一项任务需要更多的代码行，而这项任务本来可以用更少的复杂语法来编码。这是围棋被认为学习曲线相对较短的主要原因之一。事实上，这种方法是还没有泛型的主要原因。</p><p id="6133" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">例如，在C++中，可以有一个接受某种泛型类型<code class="fe nb nc nd ne b">T</code>的<strong class="lc ja">类模板</strong>，并向其添加一个接受某种其他泛型类型<code class="fe nb nc nd ne b">S</code>的<strong class="lc ja">成员函数模板</strong>(或者用Go的术语来说是“泛型方法】)。因此，具体的成员函数取决于<code class="fe nb nc nd ne b">T</code>和<code class="fe nb nc nd ne b">S</code>。这优雅地允许了广泛的用例。但是模板的巨大灵活性——像这种类模板和函数模板的组合——使得C++的模板对新手来说非常重要。</p><p id="32d2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">另一方面，Go忠于它的原则，禁止这种复杂的通用结构。目前的草案只允许“一维”的“泛型”:<br/> <em class="no">或者</em>一个只接受具体类型的泛型函数，<em class="no">或者</em>一个作用于泛型类型的函数，没有任何额外的类型参数。<br/>这种方法可能会产生一点麻烦的代码(例如，创建一个新的泛型类型，仅仅是为了将它发送给一个给定的函数)，但是它使语法更简单。</p><h2 id="8711" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">专门化</h2><p id="c7eb" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">这个提议不允许的另一个能力是为特定类型定义不同版本的通用代码——这被称为<a class="ae lw" href="https://en.wikipedia.org/wiki/Generic_programming#Template_specialization" rel="noopener ugc nofollow" target="_blank">专门化</a>。这种限制方法在一种甚至不允许简单的、基本的函数重载的语言环境中是有意义的:任何函数调用都必须映射到一个仅由其名称定义的特定函数。然而，消除专门化极大地限制了泛型的使用和优雅。</p><p id="bd78" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">回想一下本文开头的例子——函数<code class="fe nb nc nd ne b">math.Min()</code>和<code class="fe nb nc nd ne b">math.Max()</code>。目前，它们仅在<code class="fe nb nc nd ne b">float64</code>上定义。那么，将它们重写为泛型函数是很有诱惑力的，这样它们就可以为任何两个相同类型的数字参数工作。例如，类似这样的事情:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="ce5b" class="nj mf iq ne b gy nk nl l nm nn">// Assume that constraints.Ordered includes <br/>// all the types on which "less then" operator works <br/>func Min<strong class="ne ja">[T constraints.Ordered]</strong>(x, y <strong class="ne ja">T</strong>) <strong class="ne ja">T</strong> { <br/>  if x &lt; y { <br/>    return x <br/>  }<br/>  return y <br/>}</span></pre><p id="cc5a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">简单、优雅，适用于最小值概念适用的所有类型。<br/>显而易见的解决办法。<br/> <strong class="lc ja"> <em class="no">唉，果然不行！</em>T12】</strong></p><p id="5a58" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">显然，上述寻找最小值的简单逻辑可能适用于某些数值类型，但不适用于所有类型。因此，对两个<code class="fe nb nc nd ne b">float64</code>参数起作用的用于最小和最大计算的<a class="ae lw" href="https://github.com/golang/go/blob/682a1d2176b02337460aeede0ff9e49429525195/src/math/dim.go#L62" rel="noopener ugc nofollow" target="_blank">现有函数必须考虑与整数类型无关的<em class="no">特殊情况</em>。例如，在无穷大、<code class="fe nb nc nd ne b">NaN</code>的情况下，或者当</a><a class="ae lw" href="https://en.wikipedia.org/wiki/Signed_zero" rel="noopener ugc nofollow" target="_blank">比较+0.0和-0.0 </a>时会发生什么。因为不允许编写泛型函数的特例，所以不可能优雅地解决这个问题。</p><p id="9b49" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">解决这个问题的一个方法可能是用不同的名字编写几个函数<em class="no">——例如一个通用的<code class="fe nb nc nd ne b">MinInt()</code>用于所有整数类型，其他函数用于非整数类型。另一种方法可能是编写一个泛型<code class="fe nb nc nd ne b">Min()</code>，它在内部检查其参数的实际类型，并根据需要应用不同的计算。不是最高效最优雅的设计。此外，这种解决方案在设计上不是多态的(即，不是开放/关闭的)，并且会导致性能损失和繁琐的代码。</em></p><h2 id="99df" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">隐式接口— Duck类型</h2><p id="8354" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">一种现有的通用代码方法假设通用代码(函数或类型)可能接受的类型没有正式的限制。给定泛型类型<code class="fe nb nc nd ne b">T</code>的接口不是<strong class="lc ja">显式</strong>定义的，而是从逻辑中隐式<a class="ae lw" href="https://blog.ycshao.com/2017/12/16/effective-c-item-41-understand-implicit-interfaces-and-compile-time-polymorphism/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja"/></a>(也称为<a class="ae lw" href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank">Duck-Typing</a>——取自Python世界的术语)。也就是说，每当出现对泛型代码的调用时，编译器都会尝试使用所提供的参数及其类型来读取它。如果代码是为特定类型编译的——例如，<code class="fe nb nc nd ne b">int64</code>或<code class="fe nb nc nd ne b">MyAwesomeCar</code>——那就没问题。通用代码只有在每次特定调用后才有意义。此外:<em class="no">如果不仔细检查泛型实体的整个逻辑或实际尝试编译它，就不可能事先知道为给定类型调用一段泛型代码是否合法。</em> </p><p id="4345" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这种方法允许对这样的代码进行创造性的、多维度的使用，但是从软件工程的角度来看，这是非常糟糕的。为了知道用一个<code class="fe nb nc nd ne b">MyAwesomeCar</code>参数调用某个函数是否合法，必须首先尝试一下，看看编译是否通过；与可能的编译错误作斗争来理解问题并解决它们本身可能是非常困难的。如果人们已经知道<code class="fe nb nc nd ne b">MyAwesomeCar</code>确实可以使用通用函数，他们可能很难预测什么变化是好的，什么可能会破坏代码。</p><p id="39bf" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这就是为什么建议草案要求任何泛型代码从它接受的类型中显式定义所需的接口。草案将该定义称为通用类型的<strong class="lc ja">约束</strong>。定义可以用两种方法之一来完成。第一个是“开放的”:代码以通用的方式定义了一个接口——一组要实现的功能。任何类型都可以，只要它实现了接口。另一种方式是“封闭的”，用于支持非函数通用操作(如<code class="fe nb nc nd ne b">Min()</code>示例中的操作符<code class="fe nb nc nd ne b">&lt;</code>):接口使用最后一组允许的类型来定义约束。</p><h2 id="1f0a" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">元编程</h2><p id="f650" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">根据草案，一段泛型代码实际上是一些Go代码的样板，允许用具体类型替换一个或多个泛型类型。它故意不够先进，不允许使用泛型语法本身来定义逻辑。也就是说，不允许有<a class="ae lw" href="https://en.wikipedia.org/wiki/Template_metaprogramming" rel="noopener ugc nofollow" target="_blank">元编程</a>(使用泛型语法编写的逻辑，在编译期间实际“运行”)。根据Go的快速编译和语法简单的原则，这当然很有意义。</p><h2 id="f740" class="nj mf iq bd mg nv nw dn mk nx ny dp mo lj nz oa mq ln ob oc ms lr od oe mu iw bi translated">其他复杂性</h2><p id="bcc3" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">泛型编程的世界是广阔的、丰富的和复杂的，并且在不同的语言中允许许多额外的能力，例如:</p><ul class=""><li id="9e15" class="of og iq lc b ld le lg lh lj oh ln oi lr oj lv ot ol om on bi translated">以各种方式定义允许的类型及其相互关系；</li><li id="3c81" class="of og iq lc b ld oo lg op lj oq ln or lr os lv ot ol om on bi translated">定义泛型参数，不仅用于类型，也用于值；</li><li id="28b8" class="of og iq lc b ld oo lg op lj oq ln or lr os lv ot ol om on bi translated">接受各种数量的泛型参数的可变实体；</li><li id="4e81" class="of og iq lc b ld oo lg op lj oq ln or lr os lv ot ol om on bi translated">在其他通用实体中使用通用实体；</li></ul><p id="0fd0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些只是泛型代码在C++、Java或Rust等语言中允许的一些附加工具。忠于Go哲学的提议草案，有意避免了这样的指示，给泛型留下了一个相当简单的基本工具。此外，该提案是在清晰明确的假设下编写的，即实际编写的通用代码相对较少。这表明只有很少很少的库会用通用术语写成<em class="no"/>。根据这个预测，大多数围棋程序员将只需要处理<em class="no">调用</em>这样的通用代码。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="0cd8" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">摘要</h1><p id="8d70" class="pw-post-body-paragraph la lb iq lc b ld mw ka lf lg mx kd li lj my ll lm ln mz lp lq lr na lt lu lv ij bi translated">Golang中缺少泛型是一个有争议的问题，已经讨论了很长时间。这并不是第一次尝试在语言中加入这样的机制，但是到目前为止，没有一次尝试成功。目前的提案试图克服这些问题，并提出一个简单的基本机制。如果社会接受它，它成为语言的一部分，检查它的实际用法就容易多了。通过学习实际的解决方案和广大程序员在这个解决方案中发现的障碍，以后将有可能重新考虑向更深层次的泛型支持的相关变化。</p></div></div>    
</body>
</html>