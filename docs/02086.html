<html>
<head>
<title>Primitive vs Reference Types in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的基本类型与引用类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/primitive-vs-reference-types-javascript-10d3849f8742?source=collection_archive---------17-----------------------#2020-02-17">https://levelup.gitconnected.com/primitive-vs-reference-types-javascript-10d3849f8742?source=collection_archive---------17-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f9b13fc7d290e2bd5fadd1c043ec1a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuhzHpOGcuv1mR6VPoPcuQ.jpeg"/></div></div></figure><div class=""/><p id="42c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们谈论编程语言中的<strong class="kd jf">类型</strong>时，我们脑海中首先想到的是<em class="kz">字符串</em>、<em class="kz">布尔</em>、<em class="kz">数字等等。</em>这是一个可以称为“数据类型”的通用概念。在这里，我想简单地揭示一些Javascript的基本概念，这些概念很容易被忽视，因此会在任何应用程序中产生错误。</p><p id="8b9f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Javascript中，有两个类别，即<strong class="kd jf">原语</strong>和<strong class="kd jf">引用类型</strong>。例如，原语是直接在语言实现的最低层表示的。关于基元类型的另一个事实是它们是不可变的，重要的是不要将基元本身与被赋予基元值的变量混淆。例如:</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi la"><img src="../Images/498a609ffaa291f5afeb377cf02f8d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_WdvFSI7WQUe4GrDDhEKA.png"/></div></div></figure><p id="6af5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将<strong class="kd jf"> 5 </strong>的值存储在变量<strong class="kd jf">“a”</strong>中，该值将被存储在内存中，如果我们检索或尝试记录该变量，我们将访问该内存。对于第二个变量，我们将<strong class="kd jf"> "a" </strong>赋值给<strong class="kd jf"> "b" </strong>，这样就创建了一个副本，这意味着<strong class="kd jf"> "b </strong>保存了<strong class="kd jf"> 5 </strong>的值，但它并不指向变量<strong class="kd jf"> "a" </strong>，它将指向内存中创建的副本。因此，如果我们将<strong class="kd jf">“a</strong>”的值更改为<strong class="kd jf"> 15 </strong>，变量<strong class="kd jf">“b</strong>”仍然是<strong class="kd jf"> 5 </strong>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/1a8ecd51366fef4515f1d4729f75bb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*f5SDLOOckr6RTdprAe0-Lw.png"/></div></figure><p id="8b50" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们谈论<strong class="kd jf">引用类型</strong>时，它们可以保存不同类型的值，如数组、对象、函数等。由于引用类型的内容无法容纳在变量可用的固定内存量中，所以引用类型的内存值就是引用本身(内存地址)。例如:</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lg"><img src="../Images/05b7bc55e7554d4d9f597dc125e3cecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Enub6vVA5wTTbkVHSg6m2w.png"/></div></div></figure><p id="0b0b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们将一个对象赋给变量"<strong class="kd jf"> a </strong>"时，我们将值存储在内存中，但变量并不保存这个值，而是保存对它的引用。这是<strong class="kd jf">与<strong class="kd jf">原语</strong>的第一个</strong>差异，其中变量实际保存值。当我们创建一个变量“<strong class="kd jf"> b </strong>”并将值“<strong class="kd jf"> a </strong>”赋值时，我们复制了对该值的引用，这就是第二个差异，因为在<strong class="kd jf">原语</strong>中，该值被复制并存储在内存中。这是因为<strong class="kd jf">引用类型</strong>可以获得非常复杂的数据结构，为了避免它们创建许多副本并污染内存，最好的解决方案是复制引用。让我们看看代码:</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/9dd5acacd42ff7567f01719a01f4b539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*xpX04v-3UXL4d0fDU_bkkw.png"/></div></figure><p id="9909" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过创建一个数组并将该值赋给一个变量<strong class="kd jf"> array </strong>，我们将该值存储在内存中，并且只将引用附加到该变量上。当我们将<strong class="kd jf">数组</strong>赋给第二个变量<strong class="kd jf"> anotherArray </strong>时，我们创建了一个指向内存的引用副本，这就是为什么当我们记录两个变量时，我们会得到相同的结果<strong class="kd jf"> [1，2，3，4] </strong>。当我们通过执行<em class="kz"> array.push(5) </em>将数字<strong class="kd jf"> 5 </strong>添加到数组中时，我们正在改变存储在内存中的值，该值由变量<strong class="kd jf"> array </strong>中的引用点分配，并且因为<strong class="kd jf"> anotherArray </strong>已经将引用点复制到相同的值，所以当我们console.log这两个变量时，我们会得到相同的结果。</p><p id="7ebf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在是最后一个也是最令人兴奋的区别，也是最令人困惑的地方:</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/5e03960da91e6c9588286b987a9c35ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*CLLMAl_eXujK2LbjNsVTxQ.png"/></div></figure><p id="0f1c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们仍然保留前两个console.logs，只是为了理解这些变化。现在，如果我们将<strong class="kd jf"> ["a "，" b "，" c"] </strong>赋值给<strong class="kd jf">数组</strong>我们并没有改变一个现有的值，而是创建了一个新的对象(数组的类型为object，因为它是一个引用类型)，因此它创建了一个带有新引用的新值。这就是为什么<strong class="kd jf"> anotherArray </strong>没有改变，因为<strong class="kd jf"> array </strong>的原始值仍然在内存中，引用指向<strong class="kd jf"> anotherArray。</strong></p><p id="d419" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是最重要的区别，使用<em class="kz"> array.push </em>我们正在更新一个现有的对象，所以具有相同引用的两个变量都被更新了。但是在第二种方法中，我们只是创建了一个新值，所以<strong class="kd jf"> anotherArray </strong>保留了对主值的引用。</p><p id="4a79" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这是澄清，感谢您的阅读和更多文章去<a class="ae li" href="https://medium.com/@jhcxavier" rel="noopener">https://medium.com/@jhcxavier</a>。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="3847" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">最初发表于</em><a class="ae li" href="https://www.linkedin.com/pulse/primitive-vs-reference-types-javascript-jo%C3%A3o-henrique-xavier/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/joao-henrique-xavier/</a></p></div></div>    
</body>
</html>