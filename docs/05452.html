<html>
<head>
<title>Learning C++: Getters and Setters in Class Definitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:类定义中的Getters和Setters</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-getters-and-setters-in-class-definitions-c7c0469fb63c?source=collection_archive---------0-----------------------#2020-08-31">https://levelup.gitconnected.com/learning-c-getters-and-setters-in-class-definitions-c7c0469fb63c?source=collection_archive---------0-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/725d128b376c7b95066c915a91eef056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wx_ZVSTCoE7_WBWq"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@fatosi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法托斯Bytyqi </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2de5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在C++中对对象使用类的一个好处是你可以通过私有访问隐藏成员变量。但是，这样做就不可能从类定义之外访问这些变量或更改它们的值。这个问题的一个解决方案是在类接口中提供一组成员函数，称为getters和setters。我将在本文中介绍如何创建和使用getters和setters。</p><h1 id="2e97" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么类需要Getters和Setters</h1><p id="e411" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">设计C++类时的惯例是将成员变量设为私有，以控制对它们的访问。使用数据隐藏，您可以编写代码来检查进入类的数据，以确保在将数据赋给成员变量之前数据是有效的。</p><p id="7d01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果一个类存储一个人的年龄，通过将成员变量标记为private，您可以通过一个函数提供对该变量的访问，该函数首先检查以确保传入的数据是有效的年龄。如果没有，您可以指定一个默认值，或者要求用户再次输入数据。</p><p id="679e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有这种检查，为年龄输入的数据可以是编译器允许的该类型的任何合法值。因此，传递给整数变量的年龄可以是34，也可以是123，345，因为这两个值都是有效的整数值。数据验证函数可以阻止非法值进入对象并保持数据的完整性。</p><p id="1391" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为标记为private的成员变量无论如何都不能被访问，所以类还必须提供从对象中检索成员变量中存储的数据的方法，如果这是设计的一部分的话。这个功能对于维护数据完整性来说并不重要，但是它通常是一个实用的必需品。</p><p id="82e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过提供getter和setter成员函数作为类接口的一部分，我们的面向对象程序可以满足这些数据设置和数据检索的需要。</p><h1 id="99e8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建Setter函数</h1><p id="ede9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们从定义一个用于本文的简单的<code class="fe mh mi mj mk b">Person</code>类开始。这个类将有两个成员变量— <code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">age</code>。<code class="fe mh mi mj mk b">age</code>成员变量将需要一些数据验证，因为年龄不能小于0，应该有一个大约120的上限。</p><p id="5918" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从这个类的基本定义开始:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="242b" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>private:<br/>  string name;<br/>  int age;</span><span id="92d9" class="mt lf it mk b gy my mv l mw mx">public:<br/>  Person(string n, int a) {<br/>    name = n;<br/>    age = a;<br/>  }</span><span id="807a" class="mt lf it mk b gy my mv l mw mx">  void display() {<br/>    cout &lt;&lt; name &lt;&lt; ", " &lt;&lt; age &lt;&lt; endl;<br/>  }<br/>};</span></pre><p id="26ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们为这个类设计一个setter函数。该函数需要检查作为参数传入的年龄，以确保它大于或等于0且小于或等于120。我还将任意决定，如果输入的年龄无效，该函数将把年龄设置为0。</p><p id="3458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是<code class="fe mh mi mj mk b">setAge</code>函数的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d7d5" class="mt lf it mk b gy mu mv l mw mx">void setAge(int a) {<br/>  if ((a &gt;= 0) &amp;&amp; (a &lt;= 120)) {<br/>    age = a;<br/>  }<br/>  else {<br/>    age = 0;<br/>  }<br/>}</span></pre><p id="9b62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只需将这个定义添加到类定义中。下面是一个测试我们新的setter函数的简短程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1671" class="mt lf it mk b gy mu mv l mw mx">int main ()<br/>{<br/>  Person me("Jane Doe", 34);<br/>  me.display();<br/>  cout &lt;&lt; endl;<br/>  me.setAge(121);<br/>  me.display();<br/>  return 0;<br/>}</span></pre><p id="e913" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4f37" class="mt lf it mk b gy mu mv l mw mx">Jane Doe, 34<br/>Jane Doe, 0</span></pre><p id="7c44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经编写了这个setter函数，我们可以在其他地方重用它，比如在构造函数中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b890" class="mt lf it mk b gy mu mv l mw mx">Person(string n, int a) {<br/>  name = n;<br/>  setAge(a);<br/>}</span></pre><p id="1662" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要在构造函数中验证这个函数的数据。下面是检查新构造函数定义的测试程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3c2c" class="mt lf it mk b gy mu mv l mw mx">int main ()<br/>{<br/>  Person you("Bobby McGee", -1);<br/>  you.display();<br/>  return 0;<br/>}</span></pre><p id="f2aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6a93" class="mt lf it mk b gy mu mv l mw mx">Bobby McGee, 0</span></pre><p id="fbe7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过为name成员变量定义一个setter函数来总结一下<code class="fe mh mi mj mk b">Person</code>类的setter函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5ffe" class="mt lf it mk b gy mu mv l mw mx">void setName(string n) {<br/>  name = n;<br/>}</span></pre><p id="a0e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是全部了。出于一致性目的，我们也应该将该函数添加到我们的构造函数中，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="259f" class="mt lf it mk b gy mu mv l mw mx">Person(string n, int a) {<br/>  setName(n);<br/>  setAge(a);<br/>}</span></pre><p id="952e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我讨论完getter函数之后，我将展示完整的类定义。</p><h1 id="63e5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建Getter函数</h1><p id="ebab" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Getter函数更容易定义，因为它们只需要检索存储在类对象中的数据。下面是<code class="fe mh mi mj mk b">Person</code>类的getter函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3ba1" class="mt lf it mk b gy mu mv l mw mx">string getName() {<br/>  return name;<br/>}</span><span id="c41c" class="mt lf it mk b gy my mv l mw mx">int getAge() {<br/>  return age;<br/>}</span></pre><p id="2ea8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是完整的<code class="fe mh mi mj mk b">Person</code>类定义，包括所有的getter和setter函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9c85" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>private:<br/>  string name;<br/>  int age;</span><span id="3ed5" class="mt lf it mk b gy my mv l mw mx">public:<br/>  Person(string n, int a) {<br/>    setName(n);<br/>    setAge(a);<br/>  }</span><span id="2533" class="mt lf it mk b gy my mv l mw mx">  void display() {<br/>    cout &lt;&lt; name &lt;&lt; ", " &lt;&lt; age;<br/>  }</span><span id="5066" class="mt lf it mk b gy my mv l mw mx">  void setAge(int a) {<br/>    if ((a &gt;= 0) &amp;&amp; (a &lt;= 120)) {<br/>      age = a;<br/>    }<br/>    else {<br/>      age = 0;<br/>    }<br/>  }</span><span id="ab5a" class="mt lf it mk b gy my mv l mw mx">  void setName(string n) {<br/>    name = n;<br/>  }<br/> <br/>  string getName() {<br/>    return name;<br/>  }</span><span id="69e2" class="mt lf it mk b gy my mv l mw mx">  int getAge() {<br/>    return age;<br/>  }<br/>};</span></pre><h1 id="d46e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包扎</h1><p id="150f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Getter和setter函数是对类接口的重要补充。因为一个类的成员变量将被标记为私有的，你的类的用户将需要一些方法来检索和设置它们的值。Getter和setter函数以安全的方式提供了这种访问，因为setter函数可以用包含的数据验证代码来编写，以确保成员变量被设置为有效值。</p><p id="1d31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，有些情况下，您不想为类中的所有成员变量提供getter或setter函数，或者两者都提供。可以检索但不能设置的成员变量称为只读成员变量。这种成员变量的一个例子可能是在程序运行期间跟踪对象实例数量的静态类变量。该值应该是只读的，这样用户就不会意外地更改该值。</p><p id="331f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读本文，请发邮件至mmmcmillan1@att.net<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">给我，并提出意见和建议。如果你对我的在线编程课程感兴趣，请访问</a><a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank">https://learningcpp.teachable.com</a>。</p></div></div>    
</body>
</html>