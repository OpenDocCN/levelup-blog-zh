<html>
<head>
<title>Kotlin Design Patterns Made Easy | Creational Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林设计模式变得简单|创造模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kotlin-design-pattern-in-easy-way-creational-patterns-6d49d3809e03?source=collection_archive---------7-----------------------#2022-02-27">https://levelup.gitconnected.com/kotlin-design-pattern-in-easy-way-creational-patterns-6d49d3809e03?source=collection_archive---------7-----------------------#2022-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e3f381223531e15aad2651f752680db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiB3wfj46Zb5RgzaR8qhAg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://www.itl.cat/wallview/mRwJiR_education-wallpaper-hd-learning-backgrounds/" rel="noopener ugc nofollow" target="_blank">https://www . ITL . cat/wall view/mrw jir _ education-壁纸-高清-学习-背景/ </a></figcaption></figure><div class=""/><p id="10a8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提高编程语言总是具有挑战性的。你需要经验和技能来提高编程语言。学习数据结构及其设计模式是提高技能的许多方面中的一小部分。<br/>我有科特林的先验知识。然而，最近我又开始用Kotlin编码了。所以我决定学习Kotlin中的设计模式，它可以帮助我提高我的编码水平。我阅读了多篇文章并观看了教程，提出了下面给出的一些设计模式。<br/> <strong class="ki jk">注:</strong>本文不涉及设计模式的理论和优缺点。本文只讨论如何在实际的编码问题中使用这些设计模式。我试着列出几篇参考文章。欢迎在评论中添加更多内容。</p><h2 id="888b" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">介绍</h2><p id="d8f4" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">设计模式是解决一些常见问题的可重用代码。这是我的定义。如果你注意到这里，我们谈论的是可重用的代码，可以一次又一次地用来解决一个常见的问题。添加这段代码看起来像是编写额外的代码。然而，从长远来看，它减少了项目代码和由重复冗余代码引起的错误。</p><h2 id="acde" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">分类</h2><p id="d9a6" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">设计模式可以分为三个子类别。</p><ol class=""><li id="575b" class="md me jj ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Creational_pattern" rel="noopener ugc nofollow" target="_blank">创建模式</a>:如何创建类的对象</li><li id="d860" class="md me jj ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Structural_pattern" rel="noopener ugc nofollow" target="_blank">结构模式</a>:如何组合乐高建造一艘船(类比)</li><li id="505b" class="md me jj ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Behavioral_pattern" rel="noopener ugc nofollow" target="_blank">行为模式</a>:如何与对象沟通</li></ol><p id="b564" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mc">每个子类中都有大量的设计模式。我们不会一一介绍。在这篇文章中，我将尝试涵盖Kotlin中的几个主要创作模式。</em></p><h2 id="37e2" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">1.构建器模式</h2><p id="964a" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><strong class="ki jk">构建器模式</strong>是构建<strong class="ki jk">复杂对象</strong>的另一种方式。我们用一个给定的例子来理解。让我们建立一个汽车经销商软件。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8b95" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="mr ms mt mu gt mx my mz na aw nb bi"><span id="84ed" class="le lf jj my b gy nc nd l ne nf">Car{type='Ford', model='Focus', color='red', speed=0}<br/>Car{type='Toyota', model='Auris', color='blue', speed=0}<br/>Car{type='Volkswagen', model='Golf', color='green', speed=0}</span></pre><p id="ff38" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给出的例子是用Java编写的。在上面的例子中，有一个Car类，它公开了多种属性，如类型、型号、颜色和速度。如果我们想创建一辆默认速度(10)和颜色(“黑色”)的汽车呢？我们必须修改和添加多个<a class="ae jg" href="https://www.javatpoint.com/constructor-overloading-in-java" rel="noopener ugc nofollow" target="_blank">重载的构造函数</a>。这也被称为<a class="ae jg" href="http://www.javabyexamples.com/telescoping-constructor-in-java" rel="noopener ugc nofollow" target="_blank">伸缩构造器问题</a>。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1e85" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我们的工作代码有多个重载的构造函数。我们可以使用<strong class="ki jk">构建器模式</strong>来最小化这个问题。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="910c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您运行上面的代码，您将得到与构造函数重载代码相同的输出。这段代码可能看起来很冗长。然而，这段代码解决了多个问题，如<strong class="ki jk">不变性</strong>、<strong class="ki jk">可读性</strong>、<strong class="ki jk">易用性</strong>。</p><p id="055d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你可能会问，我以为这篇文章是从Kotlin的设计模式开始的。但是我在这里没有看到一行Kotlin代码。我的回答是请耐心等待。</p><p id="b154" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们必须用Kotlin写上面的代码。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5a70" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="mr ms mt mu gt mx my mz na aw nb bi"><span id="736c" class="le lf jj my b gy nc nd l ne nf">CarKt(type='Ford', model='Focus', color='red', speed=100)<br/>CarKt(type='Toyota', model='Auris', color='blue', speed=10)<br/>CarKt(type='Volkswagen', model='Golf', color='black', speed=10)</span></pre><p id="5848" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有几行代码和Kotlin 中的<a class="ae jg" href="https://kotlin-quick-reference.com/102a-R-constructors-default-values.html" rel="noopener ugc nofollow" target="_blank">默认值，才能处理构造函数重载。在本例中，您不需要在<strong class="ki jk">中创建一个构建器类。还可以使用命名值来避免传递给构造函数的参数的顺序。</strong></a></p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="54c9" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">2.单一模式</h2><p id="cf43" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Singleton模式确保在一个给定的应用程序中一个类只有一个实例。单体模式主要用于创建配置，如应用程序中的对象。我就不像构建器模式那样去详细解释了。此外，单例模式有许多变体。你可以在<a class="ae jg" href="https://howtodoinjava.com/design-patterns/creational/singleton-design-pattern-in-java/" rel="noopener ugc nofollow" target="_blank">singleton-design-pattern-in-Java/</a>阅读更多内容。下面是Java实现的示例代码</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9ff0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们正在检查一个LazySingleton应用程序的实例。上面的代码也在基于线程的应用程序中处理和工作。</p><p id="a1cc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你必须用Kotlin实现同样的代码。代码将如下所示</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ae1e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kotlin没有<strong class="ki jk">静态关键字</strong>。要创建一个静态方法，你需要创建一个<strong class="ki jk">伴随对象</strong>。要阅读更多关于<strong class="ki jk">伴随对象</strong>的信息，请参考<a class="ae jg" href="https://kotlinlang.org/docs/object-declarations.html#companion-objects" rel="noopener ugc nofollow" target="_blank">对象声明. html #伴随对象</a>。</p><p id="dfa0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建一个singleton对象，你不必像在Java中那样在Kotlin中遵循相同的模式。Kotlin为您提供了一种更简单的创建单例类的方法。它叫做<strong class="ki jk">对象类</strong>。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="00c3" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">3.工厂模式</h2><p id="73d6" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">工厂模式处理基于因素/条件的子类的创建。你可以认为一个工厂类是一个提供<strong class="ki jk">帮助器方法</strong>来基于参数生成和排列一个对象并返回一个<strong class="ki jk">具体子类对象</strong>的类。让我们来看看<strong class="ki jk"> CarFactory </strong>的Java实现。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="dde3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注:</strong>示例代码摘自<a class="ae jg" href="https://howtodoinjava.com/design-patterns/creational/implementing-factory-design-pattern-in-java/" rel="noopener ugc nofollow" target="_blank">implementing-factory-design-pattern-in-Java/</a></p><p id="941d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，你可以看到<strong class="ki jk"> CarFactory </strong>有一个帮助创建汽车的helper方法。工厂模式有更多的变化。您也可以使用<em class="mc">工厂模式作为构建器模式</em>的替代。在那里，您将使用工厂方法构建一个复杂的对象。</p><p id="627e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样的代码可以用Kotlin编写如下。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="8e9d" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">4.抽象工厂模式</h2><p id="350f" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">抽象工厂模式是工厂模式的另一个抽象层。抽象工厂模式允许代码基于一些外部配置或设置创建不同的工厂助手类。我就不细说了。你可以在这里阅读抽象工厂模式。</p><h2 id="e261" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="a660" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">正如我们所见，有许多模式和变化。每个模式对于不同的用例都是有用的。同时，很难在一篇文章中涵盖所有模式。所以我决定分成多篇文章。希望你喜欢这篇文章，并希望这将有助于你的日常编码。</p><p id="5f86" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">参考文献:</strong></p><ol class=""><li id="05b2" class="md me jj ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated"><a class="ae jg" href="https://howtodoinjava.com/gang-of-four-java-design-patterns/" rel="noopener ugc nofollow" target="_blank">https://howtodoinjava . com/gang-of-four-Java-design-patterns/</a></li><li id="a2ed" class="md me jj ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Software_design_pattern</a></li><li id="57f9" class="md me jj ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><a class="ae jg" href="https://www.baeldung.com/java-classes-objects" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-classes-objects</a></li><li id="ce8e" class="md me jj ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><a class="ae jg" href="https://www.javatpoint.com/constructor-overloading-in-java" rel="noopener ugc nofollow" target="_blank">https://www.javatpoint.com/constructor-overloading-in-java</a></li><li id="1234" class="md me jj ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><a class="ae jg" href="http://www.javabyexamples.com/telescoping-constructor-in-java" rel="noopener ugc nofollow" target="_blank">http://www . javaby examples . com/telescoping-constructor-in-Java</a></li><li id="b395" class="md me jj ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><a class="ae jg" href="https://kotlin-quick-reference.com/102a-R-constructors-default-values.html" rel="noopener ugc nofollow" target="_blank">https://kot Lin-quick-reference . com/102 a-R-constructors-default-values . html</a></li><li id="9d66" class="md me jj ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><a class="ae jg" href="https://kotlinlang.org/docs/object-declarations.html#companion-objects" rel="noopener ugc nofollow" target="_blank">https://kot linlang . org/docs/object-declarations . html # companion-objects</a></li></ol></div></div>    
</body>
</html>