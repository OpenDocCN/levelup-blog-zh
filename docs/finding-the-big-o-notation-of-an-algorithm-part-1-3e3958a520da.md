# 寻找算法的大 O 符号:第 1 部分

> 原文：<https://levelup.gitconnected.com/finding-the-big-o-notation-of-an-algorithm-part-1-3e3958a520da>

算法就像艺术；还应该用艺术的方式来分析它们。

*   一个算法需要多长时间来计算
*   运行该算法需要多少空间
*   算法所需的网络和数据传输
*   运行算法所需的功耗。

在基本层面上，我们将只关注时间和空间的复杂性

有两种方法常用于计算算法的时间和空间复杂度。即“频率法”和“无符号法”。

在本文中，我们将深入研究频率法。

![](img/76321ce2fcf4abbfdd903a30b4f42272.png)

来源:乔舒亚·厄尔经由[Unsplash.com](https://unsplash.com/photos/EjXX-vhMdLI)

# 什么是频率计数？

这基本上是执行相应语句的次数。在实现频率计数时，我遵循四条规则。

1.  当查看注释和声明时，我们的步骤数仍然为零。这是为什么呢？计算机从不执行注释。有些是为了提醒我们一些事情，或者把一些事情传达给下一个程序员。其次，不需要在算法阶段计算声明数。我们只在编程阶段考虑算法。

2.我们把 return 语句和赋值语句算作步骤数 1，just Return 语句只是返回一个值，而赋值语句是对称的，因此它仍然是 1。

3.高阶指数优先，低阶指数被忽略。我这么说是什么意思？

如果我有 5n + 7n + 3n + 3

我们将只考虑 5n 的高阶指数，而忽略所有其他的低阶指数。

4.最后，我们忽略所有步进乘数，得到 5n，忽略 5，得到 n，记为 O(n)。

让我们用一些例子来弄脏我们的手:

## 示例 1:

```
Algorithm Sum (A,n)
{
 s = 0;                       
 for(i = 0; i<n; i++)         
 {
   s = s + A[i];              
 }
   return s;                  
 }
```

上面我们有一个算法，将找到数组中所有数字的总和。

我们忽略这个声明，转到第一个语句 s=0。我们说过给赋值语句赋值 1。

```
s = 0;         1
```

接下来，我们转到 For 循环，在 For 循环中，我们将只查看 i < n，它将检查循环将执行多少次。

```
for (i = 0; i < n; i++)
```

如果 n = 3；那么 I 最初是 0。然后移到 1，然后移到 2，然后移到 3。停在 3 点！

i =0 且 0< 3

i = 1 且 1 < 3

i = 2 且 2 < 3

i = 3 且 3< 3

该条件被检查 n + 1 次，即 4 次。所以我们的 For 循环会执行 n+1 次。

现在我还有最后一条规则，我上面没有提到。循环中的每条语句都要执行 n 次。

```
s = s+A[i]                    n
}
 return;                      n
}
```

让我们合计一下我们的项目，以确定时间复杂性。

1 + n + 1 +n + n

3n +2

规则 3 我们只考虑高阶指数，也就是 3n。规则 4，忽略所有的步骤乘数。

我们只剩下(n)，也就是 O(n)。

## 示例 2:

```
Algorithm Add(A,B,n)
{
 for(i = 0; i < n; i ++)
 {
  for(j = 0; j<n; j++)
  {
    c[i,j] = A[i,j] + B[i,j]
  }
 }
}
```

我们知道外部 For 循环将执行 n+1 次。

```
for( i = 0; i<n; i ++)       n+1
```

然后我们在 for 循环中有语句

```
for(j = 0; j<n; j++)         n
{
 c[i,j] = A[i,j] + B[i,j];   n
}
```

循环中的语句执行 n 次

但是我们还没有准备好统计我们的总数。我们仍然需要计算内部 for 循环和内部 for 循环中的语句。

```
for(j = 0; j<n; j++)       n(n+1)
{
 c[i,j] = A[i,j] +B[i,j];  n(n)
```

现在我们可以把一切都加起来；

n+1 +n +1+n = 2n +n+2

规则 3 我们只考虑高阶指数，剩下 2n 个指数。

最后一条规则，我们忽略所有的步骤乘数。我们只剩下(n)了。哪个 0(n)。

# 示例 3

```
Algorithm Multiply(A,B,n)
{
  for(i = 0; i< n, i ++)
  {
    for(j=0; j<n ; j++)
    {
      c[i,j] = 0;
      for(k=0; k<n ; k++)
      {
         c[i,j] = c[i,j] + A[i,k] * B[k,j];
      }
    }
  }
}
```

我们从外部 For 循环开始，它将执行 n+1 次；

```
For(i = 0; i<n; i++)
```

那么我们知道一个循环中的所有语句将执行 n 次。下面的每个语句将执行 n 次。

```
for(j=0; i,n;i++)
{
  for(j=0;j<n;j++)
  {
    c[i,j] = 0
    for(k = 0; k<n,k++)
    {
       c[i,j] = c[i,j] + A[i,k] * B[k,j];
```

但是我们有 3 个内部循环，将执行 n+1 次。并且其中的所有语句都将执行 n 次。所以让我们合计一下总数。

n+1+n +1+n +n +1+n = 2n +2n +n+3

我们只考虑高阶多项式，我们只剩下；

2n

我们忽略步进乘数。我们只剩下(n)了。表示为大 O(n)。

# 空间复杂性

这是算法所需的内存。为了确定算法的空间复杂度，我们计算所有的变量。

示例 1

```
Algorithm Sum(A,n)
{
 s = 0
 for(i = 0; i < n; i ++)
 {
   s = s+ A[i]
 }
  return s;
```

变量；

s=只是一个正态变量，所以我们将步数指定为 1

i=也是一个正态变量，我们也将 1 指定为步数

A[]=是一个数组，有 n 个元素，所以我们指定 n 为步数。

算上我们，我们有 n + 2，我们只考虑高阶指数，所以我们剩下 n。

示例 2:

```
Algorithm Add(A,B,n)
{
  for(i=0;i<n;i++)
  {
    for(j=0;j<n;j++)
    {
      c[i,j] = A[i,j] + B[i,j]
    }
  }
}
```

变量:

a、B 和 C 是度量单位，因此如果 n=3，那么我们将得到 3*3。或者 n*n = n

A []= n

B [] n

n = 1

i = 1

j = 1

c [] = n

总结一切；n +n +n + 1+1+1 = 3n +3

我们只考虑高阶指数 3n。也就是大 O(n)。