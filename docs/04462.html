<html>
<head>
<title>Fruits, Vegetables and Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">水果、蔬菜和深度学习</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fruits-vegetables-and-deep-learning-c5814c59fcc9?source=collection_archive---------6-----------------------#2020-06-28">https://levelup.gitconnected.com/fruits-vegetables-and-deep-learning-c5814c59fcc9?source=collection_archive---------6-----------------------#2020-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0896" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用PyTorch卷积神经网络处理图像数据集</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b121199aea36e72e680f947e1742c922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*YAHQ9G7GDBGuPuF32GPpoA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">水果360数据集样本</figcaption></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="bbc1" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">免责声明:此作品是由</em> <a class="ae mc" href="https://jovian.ml/forum/u/aakashns/summary" rel="noopener ugc nofollow" target="_blank"> <em class="mb"> Aakash N S </em> </a> <em class="mb">用PyTorch完成的深度学习课程的最终项目，该课程在</em><a class="ae mc" href="https://jovian.ml/forum/c/pytorch-zero-to-gans/18" rel="noopener ugc nofollow" target="_blank"><em class="mb">jovian . ml</em></a><em class="mb">上举办，并在</em><a class="ae mc" href="https://www.freecodecamp.org/" rel="noopener ugc nofollow" target="_blank"><em class="mb">【freeCodeCamp.org</em></a><em class="mb"/><a class="ae mc" href="https://www.youtube.com/watch?v=vo_fUOk-IKk&amp;list=PLWKjhJtqVAbm3T2Eq1_KgloC7ogdXxdRa" rel="noopener ugc nofollow" target="_blank"><em class="mb">YouTube</em></a><em class="mb">频道上免费提供。</em></p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="7412" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.介绍</h1><p id="d808" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">如果你正在阅读这篇文章，那是因为你可能想知道，你如何用水果和蔬菜来学习深度学习呢？好吧，听起来很疯狂，现实世界中的物体分类是一个人类认为理所当然的琐碎问题。这是因为人类的大脑接受过这样的训练。</p><p id="7c4e" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">作为人类，我们喜欢对事物进行分类，你能想到的任何东西都可以被归类到一个类别或类中。在行业中，这是一个日常问题:零件、夹具、组件和货物的分类是日常工作的一部分。这就是为什么人类已经推出了机器学习(ML) [1]、神经网络(NN) [2]和深度学习(DL) [3]等技术，以及其他算法来自动化分类过程。</p><p id="a39a" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在这篇文章中，(1)讨论了<strong class="lh iu">卷积神经网络</strong> (CNN)的概念。(2)以PyTorch [4]为基础的代码编写了两种不同的CNN架构，其中第一种是作者提出的定制架构，第二种是所谓“ResNet”的标准架构[5]。(3)讨论了精度方面的结果。</p><p id="f267" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">本文的主要目的是说明如何建立一个用于图像检测和分类的CNN模型。出于这项工作的目的，实现了一个定制CNN，然后与一个ResNet CNN进行比较。</p><h2 id="5084" class="na me it bd mf nb nc dn mj nd ne dp mn lo nf ng mp ls nh ni mr lw nj nk mt nl bi translated">什么是卷积神经网络？</h2><p id="6231" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">卷积神经网络或深度学习架构是从人脑如何处理信息的灵感中发展而来的。CNN是一种在图像处理、图像识别和图像分类等领域提供良好结果的神经网络。这就是为什么根据这篇文章的标题，需要一个CNN模型的原因。</p><p id="89b4" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">深度学习应用在行业中应用广泛。CNN的一些应用包括人工智能(AI)系统，如机器人、虚拟助理、自动驾驶汽车等。</p><p id="456d" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">由于这一块的目的是分析图像分类，将使用“水果360数据集”[6]。该数据集可从Kaggle获得，它包含水果和蔬菜的图像，其主要属性如下:</p><p id="5830" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu">图像总数</strong> : 90483。</p><p id="01af" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu">训练集大小</strong> : 67692张图片(每张图片一个水果或蔬菜)。</p><p id="dd55" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu">测试集大小</strong> : 22688张图片(每张图片一个水果或蔬菜)。</p><p id="de98" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu">类别数量</strong> : 131(水果和蔬菜)。</p><p id="48c3" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu">图像尺寸</strong> : 100x100像素。</p><p id="c73e" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这篇文章中讨论的所有过程都可以在Jupyter笔记本中找到，在那里你可以在阅读本文的同时运行代码块。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="f127" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2.将数据集导入Jupyter环境</h1><p id="4b42" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">如果你点击了Jupyter笔记本的链接，你会发现一个“运行”的底部，这将允许你在三个不同的平台上运行笔记本。建议在<a class="ae mc" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>或<a class="ae mc" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Colab </a>上运行。该笔记本包括有关如何将数据集导入两个云中的说明。你只需要根据你工作的平台来运行代码块。</p><p id="ec64" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果您对本地运行感兴趣，您可以从这里的<a class="ae mc" href="https://www.kaggle.com/moltean/fruits" rel="noopener ugc nofollow" target="_blank">下载数据集</a>，您必须安装并导入到python文件的模块如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="74d7" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">根据您运行笔记本的位置和方式，您将必须声明数据集的路径，例如，如果您在Google Colab中运行，您将必须运行以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="8ced" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">3.数据处理—训练和验证数据集</h1><p id="a517" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">在构建真实世界的机器学习模型时，通常会将数据集分成3个部分:</p><ol class=""><li id="f79e" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma nt nu nv nw bi translated"><strong class="lh iu">训练集</strong>:用于训练模型，即使用梯度下降计算损失并调整模型的权重。</li><li id="227e" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma nt nu nv nw bi translated"><strong class="lh iu">验证集</strong>:用于训练时评估模型，调整超参数(学习率等)。)并挑选模型的最佳版本。</li><li id="90ee" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma nt nu nv nw bi translated"><strong class="lh iu">测试集</strong>:用于比较不同的模型，或不同类型的建模方法，并报告模型的最终精度。</li></ol><p id="030f" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">出于本文的目的，包含在<code class="fe oc od oe of b">Trining</code>目录中的所有图像都将被用作Trining数据集，对于作为验证数据集的<code class="fe oc od oe of b">Test</code>目录也是如此，它稍后将被用作测试集。</p><h2 id="af26" class="na me it bd mf nb nc dn mj nd ne dp mn lo nf ng mp ls nh ni mr lw nj nk mt nl bi translated">3.1数据转换</h2><p id="ed77" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated"><em class="mb">从训练数据集中加载图像时，随机数据扩充</em>将应用随机选择的变换。具体来说，每个图像将被填充10个像素，然后以50%的概率水平翻转图像。最后，随机旋转20度将适用。由于每次加载特定图像时都会随机和动态地应用变换，因此该模型在每个训练时期看到的图像略有不同，这使得它可以更好地进行归纳。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="12fa" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">设置数据扩充后，可以使用PyTorch提供的<code class="fe oc od oe of b">ImageFolder</code>模块将数据集加载为张量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ccdf" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">一旦数据以张量的形式出现，你就可以观察数据的样子了。在训练数据集的情况下，已经对每个图像应用了变换，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有变换的训练数据集中的图像。</figcaption></figure><p id="c6ef" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">同时，验证数据集保持其原始格式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有转换的验证数据集中的图像。</figcaption></figure><h2 id="d3b6" class="na me it bd mf nb nc dn mj nd ne dp mn lo nf ng mp ls nh ni mr lw nj nk mt nl bi translated">3.2数据加载器</h2><p id="e13a" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">既然数据已经被加载和转换，就差不多可以开始训练了，但是首先您必须定义什么叫做数据加载器。</p><p id="0834" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">通常，当你运行机器学习模型时，你会处理大量的数据。这些数据必须由计算机处理，而计算机的资源是有限的。机器不可能一次运行该数据集中包含的所有67692幅图像。因此，您需要数据加载器。</p><p id="fa38" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">幸运的是，PyTorch自带了相应的模块，您所要做的就是定义一个数据集(已经在上一节中定义了)和一个批处理大小。</p><p id="b89a" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">批量大小是每次要处理的数据量。如果您设置了一个大的批处理，您可能会耗尽内存，所以尝试根据您的数据设置一个合理的数字。这一次，这两批将有相同的大小，但你可以改变这些数字，如果你喜欢。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dd99" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">由于本研究将讨论和比较两种不同的CNN架构，因此有必要定义两个不同的批次:</p><ul class=""><li id="9812" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated"><code class="fe oc od oe of b">train_dl_custom</code>和<code class="fe oc od oe of b">valid_dl_custom</code>为定制CNN模式</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="728b" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated">resnet CNN型号的<code class="fe oc od oe of b">train_dl_resnet</code>和<code class="fe oc od oe of b">valid_dl_resnet</code></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="863f" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">注意<code class="fe oc od oe of b">shuffle=True</code>是为训练数据加载器设置的，因此每个时期生成的批次是不同的，这种随机化有助于概括和加速训练过程。</p><p id="295c" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">另一方面，由于验证数据加载器仅用于评估模型，因此不需要打乱图像。</p><p id="766f" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们来看看来自训练数据加载器的一些样本图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">定型Dataloader批处理示例。</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">验证数据加载器批处理示例。</figcaption></figure><p id="386f" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">注意<code class="fe oc od oe of b">train_dl_*</code>样本是如何应用数据扩充的。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="8c51" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak"> 4。使用GPU </strong></h1><p id="5065" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">随着模型和数据集大小的增加，您将需要使用GPU在合理的时间内训练您的模型。GPU包含数百个内核，这些内核针对在短时间内对浮点数执行昂贵的矩阵运算进行了优化，这使得它们非常适合训练具有许多层的CNN。</p><p id="4a74" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">你可以在<a class="ae mc" href="https://www.kaggle.com/kernels" rel="noopener ugc nofollow" target="_blank"> Kaggle内核</a>或者<a class="ae mc" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>上免费使用GPU。您可以使用<code class="fe oc od oe of b">torch.cuda.is_available</code>检查GPU是否可用以及所需的<a class="ae mc" href="https://developer.nvidia.com/cuda-zone" rel="noopener ugc nofollow" target="_blank"> NVIDIA CUDA </a>驱动程序是否已安装。</p><p id="aff2" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果GPU可用，您可以定义几个助手函数(<code class="fe oc od oe of b">get_default_device</code> &amp; <code class="fe oc od oe of b">to_device</code>)和一个助手类<code class="fe oc od oe of b">DeviceDataLoader</code>，根据需要将模型和数据移动到GPU。</p><p id="e87f" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><code class="fe oc od oe of b">DeviceDataLoader</code>类用于包装现有的数据加载器，并在访问批处理时将数据移动到所选设备。有趣的是，您不需要扩展现有的类来创建PyTorch数据加载器。所需要的只是一个检索数据批次的<code class="fe oc od oe of b">__iter__</code>方法和一个获取批次数量的<code class="fe oc od oe of b">__len__</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d8be" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">根据您运行该笔记本的位置，您的默认设备可能是CPU ( <code class="fe oc od oe of b">torch.device('cpu')</code>)或GPU ( <code class="fe oc od oe of b">torch.device('cuda')</code>)</p><p id="ac92" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，您可以使用<code class="fe oc od oe of b">DeviceDataLoader</code>包装训练和验证数据加载器，以便自动将数据批量传输到GPU(如果可用的话)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="fbfe" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5.定义模型</h1><p id="683a" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">如前所述，这项工作实现了CNN，这是一类人工神经网络，它使用卷积层来过滤数据以达到学习目的。这包括将输入数据(特征图)与卷积核(过滤器)相结合以形成变换图。</p><p id="5925" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">CNN的主要组件是输入层、隐藏层(可以从1到应用程序所需的层)和输出层。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c0b8fa9fe837f73b434ed423e336b368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*V_lnH58ZtxQyxXCqHYt6DQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">卷积神经网络——图片由Maurice Peemen 提供。</figcaption></figure><p id="234c" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">CNN和常规神经网络之间的主要区别在于，CNN层是以三维(宽度、高度和深度)排列的。隐藏层是卷积、池化、归一化和完全连接层的组合[7]。</p><p id="af93" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">换句话说，CNN是一种深度学习算法，能够使用图像作为输入，以各种方式检查它们以检测模式或对象，并作为输出获得区分彼此的能力。</p><p id="7b74" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在进入每个模型的细节之前，让我们为模型定义一个<code class="fe oc od oe of b">ImageClassificationBase</code>类和一个<code class="fe oc od oe of b">accuracy</code>函数。</p><ul class=""><li id="6c1d" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated"><code class="fe oc od oe of b">accuracy</code>函数将作为一种评估模型性能的方法。一种自然的方法是找到被正确预测的标签的百分比，即预测的准确性。</li><li id="b4e6" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated"><code class="fe oc od oe of b">ImageClassification</code>级将作为两种型号的训练器、验证和损失计算器。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="c4b2" class="na me it bd mf nb nc dn mj nd ne dp mn lo nf ng mp ls nh ni mr lw nj nk mt nl bi translated">5.1定制CNN模型</h2><p id="edfa" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">为该定制CNN模型考虑的架构将基于<em class="mb">剩余块</em>和<em class="mb">批量归一化</em>。这是为了能够实际比较定制CNN和ResNet模型的结果。</p><ul class=""><li id="d6ef" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated"><em class="mb">残差块</em>将原始输入添加回输出特征图，该输出特征图是通过将输入通过一个或多个卷积层而获得的[8]。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/70bf4f80ace2ec5e0a1e81e8e3a2f19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejMyiIreaBpwGbDNNLr8Fw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">常规块(左)和残差块(右)的区别，(<a class="ae mc" href="https://d2l.ai/_images/residual-block.svg" rel="noopener ugc nofollow" target="_blank">图像来源</a>)。</figcaption></figure><ul class=""><li id="d882" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated"><em class="mb">批量标准化</em>顾名思义，通过将卷积层的输入调整到相同的比例来进行标准化。这减少了神经网络的训练时间[9]。</li></ul><p id="47e0" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">要定义自定义CNN，您只需运行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="71cd" class="na me it bd mf nb nc dn mj nd ne dp mn lo nf ng mp ls nh ni mr lw nj nk mt nl bi translated">5.2.ResNet CNN模型</h2><p id="7b8a" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated"><em class="mb"> ResNet </em>代表残差神经网络，它是ImageNet数据集[5]中预训练的模型。你可以在<a class="ae mc" href="https://d2l.ai/chapter_convolutional-modern/resnet.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到关于这个架构如何工作的深入解释。</p><p id="21e3" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">PyTorch提供了resnet的5个版本的实现，分别包含5、34、50、101、152层[10]。出于这项工作的目的，resnet34将用于其<code class="fe oc od oe of b">pretrained</code>版本，其中最后一层将被修改以适应所使用的数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="bac3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">6.训练模型</h1><p id="03f7" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">在训练模型之前，让我们定义一个<code class="fe oc od oe of b">fit_one_cicle</code>函数，它将执行整个训练过程。该函数记录每个时期的验证损失和度量，并返回训练过程的历史。这对于调试和可视化训练过程非常有用。</p><p id="0fa4" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">像批量大小、最大学习率等配置。训练机器学习时需要预先挑选模型，并称为<strong class="lh iu"><em class="mb"/></strong>。</p><p id="7435" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">选择正确的超参数对于在合理的时间内训练准确的模型至关重要，并且是研究和实验的活跃领域。随意尝试不同的学习速度，看看它是如何影响训练过程的。</p><ul class=""><li id="9f21" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated"><strong class="lh iu">学习率调度</strong>:模型不使用固定的学习率，而是使用一个学习率调度器，它会在每一批训练后改变学习率。在训练过程中有许多改变学习率的策略，本研究中使用的一种是所谓的“<em class="mb">单周期学习率策略</em>”，它涉及从低学习率开始，在大约30%的时期内逐批逐渐增加到高学习率，然后在剩余时期内逐渐减少到非常低的值[11]。</li><li id="75ac" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated"><strong class="lh iu">权重衰减</strong>:这是另一种正则化技术，通过在损失函数中增加附加项来防止权重变得过大【12】。</li><li id="74b1" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated"><strong class="lh iu">渐变剪辑</strong>:该技术有助于将渐变值限制在一个小范围内，以防止由于大的渐变值而导致参数发生不希望的变化。[13].</li></ul><p id="64f6" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">另外，是时候定义另外两个有用的函数了:<code class="fe oc od oe of b">evaluate</code>和<code class="fe oc od oe of b">get_lr</code>:</p><ul class=""><li id="298e" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated"><code class="fe oc od oe of b">evaluate</code>功能将在每个时期评估训练模型。这将作为输出提供训练模型做得有多好或有多差。</li><li id="c03f" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated"><code class="fe oc od oe of b">get_lr</code>或“获得学习率”，将优化每个时代的学习率。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="88f5" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，是时候为训练过程定义超参数了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0ae7" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">请注意，选择的训练器优化器是<strong class="lh iu"> <em class="mb"> Adam优化器</em> </strong>、<strong class="lh iu"> <em class="mb"> </em> </strong>，它使用动量和自适应学习率等技术来加快训练速度[14]。</p><h2 id="66dd" class="na me it bd mf nb nc dn mj nd ne dp mn lo nf ng mp ls nh ni mr lw nj nk mt nl bi translated">6.1.训练自定义CNN模型</h2><p id="93e1" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">至此，除了一个小细节之外，定制模型的训练已经准备就绪。定制模型是基于期望的输入(3个图像通道)和特定的输出(图像上水果的类别)构建的。</p><p id="729a" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">需要指定模型的输入为<code class="fe oc od oe of b">3</code> <em class="mb">通道</em>，输出为<code class="fe oc od oe of b">131</code>类水果。</p><p id="eb44" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">一旦指定了这两个参数，只需将它们加载到CNN模型中，然后将模型移动到之前选择的设备(<code class="fe oc od oe of b">cpu</code>或<code class="fe oc od oe of b">cuda</code> GPU)中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ae04" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">既然模型已经加载到了所需的设备中，让我们检查输入和输出数据是否正确。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5b2b" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如前块所示，输入数据加载器的<code class="fe oc od oe of b">images.shape</code>为:</p><ul class=""><li id="0db7" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated">32 =批量大小</li><li id="d318" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">3 =图像通道(RGB)</li><li id="300b" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">100 x 100 =图像尺寸(宽度、高度)</li></ul><p id="0e4a" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">另一方面，CNN模型的输出显示:</p><ul class=""><li id="86ac" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated">32 =批量大小</li><li id="83c3" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">131 =水果类的数量</li></ul><p id="1442" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们来评估一下这个模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2bf8" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">注意，最初的评估结果非常糟糕。验证损失为4.875，而模型的准确率仅为1.72%。</p><p id="e740" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，您可以运行下面的块来执行自定义CNN模型的定型。</p><p id="1082" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">注意:考虑到培训过程可能需要几分钟</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="edd4" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">大约1小时20分钟后，您将获得培训的最终结果，该结果应该类似于以下内容:</p><ul class=""><li id="e9ab" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated">上次学习率:4e-9</li><li id="eb46" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">培训损失:0.0013</li><li id="4218" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">验证损失:0.0465</li><li id="277d" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">验证准确率:99.21%</li></ul><h2 id="ba75" class="na me it bd mf nb nc dn mj nd ne dp mn lo nf ng mp ls nh ni mr lw nj nk mt nl bi translated">6.2.训练ResNet CNN模型</h2><p id="e304" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">至此，ResNet CNN模型的训练一切就绪。</p><p id="6f59" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">与定制CNN模型类似，只需将它们加载到CNN模型中，然后将模型移动到之前选择的设备(cpu或cuda GPU)上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3603" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，让我们评估该模型，看看它的表现如何。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a283" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">注意，最初的评估结果非常糟糕。验证损失为4.8911，同时模型的准确率仅为1.25%，与定制的CNN模型初始值非常接近。</p><p id="e28f" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">首先，冻结ResNet层，并训练一些纪元。这只训练最后一层开始分类图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="06cb" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">训练最后一层几个纪元。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2d9d" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，解冻并多训练一些。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8f2f" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">大约30分钟后，您将获得培训的最终结果，看起来应该类似于以下内容:</p><ul class=""><li id="2d3c" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated">上次学习率:4e-9</li><li id="143c" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">培训损失:3.9102</li><li id="94f6" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">验证损失:3.9111</li><li id="cb03" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">验证准确率:92.45%</li></ul></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="43bd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">7.结果可视化</h1><p id="c516" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">现在是时候看看哪个模型表现更好了。</p><p id="1999" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">自定义模型训练所消耗的时间几乎是ResNet模型的3倍，但自定义模型的结果更好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">准确性—定制CNN模型。</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">准确性— ResNet CNN模型。</figcaption></figure><p id="40fc" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如上图所示，<strong class="lh iu">定制模型</strong>的精度达到了<strong class="lh iu"> 99.21% </strong>，而<strong class="lh iu"> ResNet模型</strong>的精度仅为<strong class="lh iu"> 92.45% </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">训练和验证损失-定制CNN模型。</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">训练和验证损失ResNet CNN模型。</figcaption></figure><p id="6ebf" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">另一件相当重要的事情是，定制模型很好地减少了训练和验证损失，而ResNet模型没有那么好。</p><p id="9141" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">最后，用于两种模型的学习率如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">学习率变化-定制CNN模型。</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">学习率变化——ResNet CNN模型。</figcaption></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="d94f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">8.使用训练好的模型进行预测</h1><p id="90ef" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">现在，您可以使用经过训练的模型通过验证数据集进行预测。由于两个模型都达到了90%以上的准确性，预测将是相似的。</p><p id="e7cd" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这是自定义模型的预测:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">自定义CNN训练模型预测。</figcaption></figure><p id="b95a" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这是ResNet模型的预测:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ResNet CNN训练模型预测。</figcaption></figure><h1 id="1fa2" class="md me it bd mf mg oj mi mj mk ok mm mn jz ol ka mp kc om kd mr kf on kg mt mu bi translated">9.未来的工作</h1><p id="a8c4" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">即使结果非常好，仍有一些机会领域需要关注:</p><ul class=""><li id="7e7b" class="no np it lh b li lj ll lm lo nq ls nr lw ns ma og nu nv nw bi translated">使用ResNet模型减少培训和验证损失。</li><li id="600b" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">减少定制模型训练所需的时间。</li><li id="47aa" class="no np it lh b li nx ll ny lo nz ls oa lw ob ma og nu nv nw bi translated">使用不同的数据集测试自定义模型以评估其性能。</li></ul></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="9ac0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">10.结论</h1><p id="02ef" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">在这篇文章中，提出了用于图像分类目的的两种不同的卷积神经网络(CNN)架构。作者提出的定制模型和PyTroch模块中包含的ResNet模型。</p><p id="65e5" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">结果表明，自定义模型，即使花费更长的训练时间，也比PyTorch模块中实现的ResNet模型显示出更好的结果。</p><p id="711d" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu">定制模型</strong>达到了<strong class="lh iu"> 99.21% </strong>的准确率，而<strong class="lh iu"> ResNet模型</strong>只达到了<strong class="lh iu"> 92.45%。</strong></p><p id="7f8e" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">与ResNet模型相比，自定义模型设法减少了培训和验证损失。</p><p id="4f6e" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">有完整代码的Jupyter笔记本可供读者在下面的链接中做进一步的修改。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="e50a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">11.承认</h1><p id="fc10" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">感谢<a class="ae mc" href="https://medium.com/@aakashns" rel="noopener"> Aakash N S </a>和<a class="ae mc" href="https://jovian.ml/forum/c/pytorch-zero-to-gans/18" rel="noopener ugc nofollow" target="_blank"> Jovian.ml </a>团队用PyTorch制作《深度学习》课程。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="7519" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">参考</h1><p id="80b7" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">[1]郝，K，“什么是机器学习？”, 2018.【在线】。可用:<a class="ae mc" href="https://www.technologyreview.com/2018/11/17/103781/what-is-machine-learning-we-drew-you-another-flowchart/." rel="noopener ugc nofollow" target="_blank">https://www . technology review . com/2018/11/17/103781/what-is-machine-learning-we-draw-you-another-flow trade/</a>。[2020年6月22日访问]。</p><p id="57cb" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[2] Hadesty，l .《被解释的:神经网络》，2017年。【在线】。可用:<a class="ae mc" href="http://news.mit.edu/2017/explained-neural-networks-deep-learning-0414." rel="noopener ugc nofollow" target="_blank">http://news . MIT . edu/2017/explained-neural-networks-deep-learning-0414</a>。[2020年6月22日访问]。</p><p id="88cd" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[3] Sharma，v .《深度学习——卷积神经网络导论》，2018年。【在线】。可用:<a class="ae mc" href="https://vinodsblog.com/2018/10/15/everything-you-need-to-know-about-convolutional-neural-networks/." rel="noopener ugc nofollow" target="_blank">https://vinodsblog . com/2018/10/15/everything-you-neural-networks/</a>。[2020年6月22日访问]。</p><p id="b950" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[4] PyTorch贡献者，“PyTorch文档”，2019年。【在线】。可用:【https://pytorch.org/docs/stable/index.html】T2。[2020年6月22日访问]。</p><p id="6f77" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[5]何等。艾尔。，“用于图像识别的深度残差学习”，2015。【在线】。可用:【https://arxiv.org/abs/1512.03385】T4。[于2020年4月15日获取]。</p><p id="94e7" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[6] Muresan，h .，Oltean，m .“使用深度学习从图像中识别水果”，2018年，载于<em class="mb"> Acta Univ. Sapientiae，Informatica </em>。第10卷，第1期，第26-42页。【在线】可用:<a class="ae mc" href="https://arxiv.org/abs/1712.00580" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1712.00580</a>。</p><p id="0c6b" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[7]英伟达公司。<em class="mb">《卷积神经网络(CNN)》</em>，2020。[在线]英伟达开发者。可用:<a class="ae mc" href="https://developer.nvidia.com/discover/convolutional-neural-network" rel="noopener ugc nofollow" target="_blank">https://developer . NVIDIA . com/discover/卷积神经网络</a>，【2020年6月22日访问】。</p><p id="5e20" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[8] Sahoo，S. <em class="mb">《剩余块ResNet的积木块》</em>，2018。[在线]走向数据科学。可用:<a class="ae mc" href="https://towardsdatascience.com/residual-blocks-building-blocks-of-resnet-fd90ca15d6ec" rel="noopener" target="_blank">https://towardsdatascience . com/residual-blocks-building-blocks-of-resnet-FD 90 ca 15d 6 EC</a>，【2020年6月22日访问】。</p><p id="baa2" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[9] Kumar，N. <em class="mb">《用Pytorch实现神经网络中的批量归一化和剔除》</em>，2019。[在线]走向数据科学。可用:<a class="ae mc" href="https://towardsdatascience.com/batch-normalization-and-dropout-in-neural-networks-explained-with-pytorch-47d7a8459bcd" rel="noopener" target="_blank">https://towards data science . com/batch-normalization-and-dropout-in-neural-networks-explained-with-py torch-47d 7a 8459 BCD</a>，【2020年6月22日获取】。</p><p id="c8e9" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">10 py torch文件。“RESNET”。[在线]可用:<a class="ae mc" href="https://pytorch.org/hub/pytorch_vision_resnet/" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/hub/pytorch_vision_resnet/</a>，【2020年6月22日获取】。</p><p id="e5f3" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[11]古格，s .<em class="mb">《1周期政策》</em>，2018年。[在线]可用:<a class="ae mc" href="https://sgugger.github.io/the-1cycle-policy.html" rel="noopener ugc nofollow" target="_blank">https://sgugger.github.io/the-1cycle-policy.html</a>，【2020年6月22日获取】。</p><p id="5a26" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[12] Vasani，d .，<em class="mb">《这东西叫重量衰减》</em>，2019。[在线]走向数据科学。可用:<a class="ae mc" href="https://towardsdatascience.com/this-thing-called-weight-decay-a7cd4bcfccab" rel="noopener" target="_blank">https://towards data science . com/this-thing-thing-called-weight-decay-a 7 CD 4 BCF cab</a>，【2020年6月22日访问】。</p><p id="812c" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[13] Wong，w .，<em class="mb">“什么是渐变裁剪？”</em>，2019。[在线]走向数据科学。可用:<a class="ae mc" href="https://towardsdatascience.com/what-is-gradient-clipping-b8e815cdfb48" rel="noopener" target="_blank">https://towards data science . com/what-is-gradient-clipping-b 8 e 815 cdfb 48</a>，【2020年6月22日获取】。</p><p id="3cf0" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">[14] Ruder，s .，<em class="mb">《梯度下降优化算法综述》</em>，2016。[在线]塞巴斯蒂安·鲁德，可在:<a class="ae mc" href="https://ruder.io/optimizing-gradient-descent/index.html" rel="noopener ugc nofollow" target="_blank">https://ruder.io/optimizing-gradient-descent/index.html</a>，【2020年6月22日访问】。</p></div></div>    
</body>
</html>