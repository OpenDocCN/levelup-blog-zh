<html>
<head>
<title>Currying in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Currying</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/currying-in-javascript-c0563b9b6c2c?source=collection_archive---------12-----------------------#2020-02-19">https://levelup.gitconnected.com/currying-in-javascript-c0563b9b6c2c?source=collection_archive---------12-----------------------#2020-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7ee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不，我不是在说食物😜</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b657560959ff1dd8e600fc4179a88e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75n_awLDr_0hcY7rqzORFw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.freepik.es/fotos/comida" rel="noopener ugc nofollow" target="_blank">rawpixel.com喜剧电影——www . free pik . es</a></figcaption></figure><p id="db31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，<strong class="jp ir">curry</strong>不仅仅是一个JavaScript概念。<strong class="jp ir">阿谀奉承</strong>是每个人在使用函数式编程时必须知道的概念！</p><p id="ea58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在理解curry之前，你必须对什么是纯函数有一个清晰的概念。</p><h2 id="714c" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">纯函数</h2><p id="5d00" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">纯函数可以简单地定义为一个函数，给定一个特定的输入，它将总是返回相同的输出。举个例子，</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="2a0d" class="lc ld iq mb b gy mf mg l mh mi">// ES5 syntax<br/>const multiplyByTwo = function(numberToMultiply) {<br/>  return numberToMultiply * 2;<br/>};</span><span id="f567" class="lc ld iq mb b gy mj mg l mh mi">// ES6 <a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">arrow function</a> expanded syntax<br/>const multiplyByTwo = (numberToMultiply) =&gt; {<br/>  return numberToMultiply * 2<br/>};</span><span id="acbf" class="lc ld iq mb b gy mj mg l mh mi">// ES6 reduced syntax (used when the function has just one line)<br/>const multiplyByTwo = (numberToMultiply) =&gt; numberToMultiply * 2;</span><span id="1d53" class="lc ld iq mb b gy mj mg l mh mi">console.log(multiplyByTwo(2)) // 4</span></pre><p id="7b91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，您可以任意多次调用multiplyByTwo()函数，并且您将始终获得相同的结果，无论您是在今天、明天还是在一年内调用该函数，它都会产生相同的结果。</p><p id="0e59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这仅仅是关于纯函数的一个基本解释。他们背后还有更多。更多信息请查看我之前关于纯函数的文章。</p><h2 id="6c93" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">回到奉承</h2><p id="9c1e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">简单来说，currying就是调用作为另一个函数的结果而产生的函数的动作。基本上是这样的，</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="8319" class="lc ld iq mb b gy mf mg l mh mi">const num = 1;</span><span id="b203" class="lc ld iq mb b gy mj mg l mh mi">console.log(add(1)); // (num2) =&gt; num1 + num2</span><span id="68d6" class="lc ld iq mb b gy mj mg l mh mi">console.log(add(1)(1)); // 2</span></pre><p id="3b39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能想知道<em class="mk">加</em>是做什么的？，或者为什么<em class="mk"> add(1)(1) </em>有两对括号而不是只有两个自变量？。这只是因为<em class="mk"> add </em>是一个返回函数的函数。所以我们调用add返回的函数。那叫<strong class="jp ir">阿谀奉承</strong>！</p><p id="f9ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Currying非常强大，因为它允许您用一个基本行为组合不同的函数，而无需重复代码。让我们看看我们的<em class="mk">添加</em>函数的定义和一个‘普通’添加函数的定义。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="77c0" class="lc ld iq mb b gy mf mg l mh mi">const normalAdd = (num1, num2) =&gt; num1 + num2;</span><span id="5e56" class="lc ld iq mb b gy mj mg l mh mi">const add = (num1) =&gt; (num2) =&gt; nun1+ num2;</span></pre><p id="cc15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在你可能会认为<em class="mk"> normalAdd </em>方法更清晰、更直接，但是我们的curried <em class="mk"> add </em>版本隐藏着一种力量！</p><p id="de97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用我们定制的<em class="mk"> add </em>函数，我们可以如下构建一个递增或递减函数，</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="fc5a" class="lc ld iq mb b gy mf mg l mh mi">const incrementByOne = add(1);</span><span id="3a80" class="lc ld iq mb b gy mj mg l mh mi">const decrementByOne = add(-1);</span><span id="d057" class="lc ld iq mb b gy mj mg l mh mi">console.log(incrementByOne(3)); // 4</span><span id="29ee" class="lc ld iq mb b gy mj mg l mh mi">console.log(decrementByOne(3)); // 2</span></pre><p id="68d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们能够使用之前创建的函数<em class="mk"> add创建2个新的特定函数。</em></p><p id="b9e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多亏了currying，我们可以用一个特定的实现来组合新的功能。当然，上面提到的例子非常简单，但是通过currying，你可以构建更复杂的函数。例如，React对<a class="ae lb" href="https://reactjs.org/docs/higher-order-components.html#___gatsby" rel="noopener ugc nofollow" target="_blank"> <em class="mk">高阶组件</em> </a>一直使用这种组合模式。</p><blockquote class="ml mm mn"><p id="b03d" class="jn jo mk jp b jq jr js jt ju jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj kk ij bi translated">高阶组件(HOC)是React中重用组件逻辑的一种高级技术。本质上，hoc不是React API的一部分。它们是从React的<strong class="jp ir">组成</strong>本质中显现出来的一种模式。</p></blockquote><p id="5a15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，React中的HOC是一个返回另一个函数的函数(就像我们的<em class="mk"> add </em>函数一样！)将一些属性添加到被传递到HOC中的函数。</p><h2 id="5772" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">结论</h2><p id="84e3" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Currying允许我们将简单的基本函数组合成更具体的函数。在您的应用程序中使用currying不仅可以创建可重用的代码，还可以开始习惯函数式编程的一些概念。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="9ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一本了解函数式编程的牛逼书:<a class="ae lb" href="https://www.amazon.com/-/es/gp/product/1661212565/ref=dbs_a_def_rwt_bibl_vppi_i0" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/-/es/gp/product/1661212565/ref = DBS _ a _ def _ rwt _ bibl _ vppi _ i0</a></p></div></div>    
</body>
</html>