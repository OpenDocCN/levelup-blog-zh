<html>
<head>
<title>Debounce from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始去抖</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/debounce-from-scratch-8616c8209b54?source=collection_archive---------1-----------------------#2022-04-30">https://levelup.gitconnected.com/debounce-from-scratch-8616c8209b54?source=collection_archive---------1-----------------------#2022-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1e4acf026eb2b3e4813f1a12ce5ffe7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRtZCSVuh_5dAlyJJz9ZvQ.jpeg"/></div></div></figure><p id="13a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几个JavaScript库都有自己的预烘焙去抖函数，允许你传递你的函数，一个延迟时间，然后你就可以开始比赛了。</p><p id="05c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我发现自己想知道更多关于这些去抖功能中的神奇之处。一旦发现了这种魔力，会有哪些常见的用例呢？这篇文章将深入探讨反跳的内部工作原理，然后在另一篇文章(不久的将来)中展开，在另一篇文章中，我将使用这个自制的反跳函数来限制搜索栏中的API调用，但稍后会详细介绍。</p><p id="38da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将回答这两个问题:</p><ul class=""><li id="b2fc" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">去抖应该做什么？</li><li id="8273" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我如何从头开始构建去抖？</li></ul><p id="ea99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您想要限制某个功能的执行次数时，去抖功能非常有用。我们经常发现自己处于这样的情况，我们有一个与频繁触发的事件相关联的功能(例如，滚动、onchange、按键)。如果为输入字段中的每一次按键事件或窗口中的每一次滚动事件执行一个函数，我们可能会发现自己调用函数数百次，从而使应用程序的效率荡然无存。</p><p id="405e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，去抖有效地限制了函数的过度执行，从而使我们的web应用程序更具性能。嗯，这是我们第一个问题的良好开端！我们来看第二个问题:我们如何让自己去抖？</p><p id="04af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我将声明一个名为“ourFunction”的函数，我们最终将去反跳(限制它的执行次数)，然后声明一个实际的去反跳函数的开始。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/250013f94012d2227cc48b58781296b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqvlBvAEmy34YihAknex-Q.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">函数去抖和一个去抖函数</figcaption></figure><p id="27a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">去抖功能将用于限制和延迟我们功能的执行。因此，我们可以从逻辑上得出结论，去抖需要这两个项目作为它的参数:延迟函数和延迟时间(以毫秒为单位)。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lt"><img src="../Images/9f95e8ef577792363f088b01dbf85745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OnHSYzGp5LLhcOPmVi15dw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">带参数的去抖功能</figcaption></figure><p id="e27a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将希望仅在延迟时间过后才执行传入的函数。为此，我们将使用内置的JavaScript <a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" rel="noopener ugc nofollow" target="_blank"> setTimeout </a>函数。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/f200b177b42b71ab270ae10c04f50540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Eax3tjrYk37CNkhKARs6g.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">在去抖中利用setTimeout</figcaption></figure><p id="093a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">setTimeout函数接收一个要执行的函数，并在执行传入的函数之前等待一段“延迟”时间...这听起来很像我们试图用去抖功能实现的目标。我们的去抖功能只是setTimeout的重现吗？</p><p id="2fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前……是的。虽然我们的反跳函数会延迟传入函数的执行，但它仍然会每次都调用它的fn参数。</p><p id="1a81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们倾向于仅调用fn一次去抖，并且这一次是在“延迟”时间量过去之后。为此，我们需要能够重置setTimeout。<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">封</a>来救援了！</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/a7fd426b57e29b7c80eee74dddf518f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOh_5i4eoM_bODZDBrP_nw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">利用一个结束</figcaption></figure><p id="7512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是怎么回事？！我们的去抖现在返回一个函数？</p><p id="8225" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，当调用去抖时，它应该接收一个要执行的函数(fn)和在函数执行之前应该经过的时间量(延迟)。然后去抖初始化变量“定时器”并返回一个匿名函数。在这个匿名函数中，去抖的魔力终于显现出来了。</p><p id="a4e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从返回函数的底部开始:</p><pre class="ll lm ln lo gt lx ly lz ma aw mb bi"><span id="3958" class="mc md iq ly b gy me mf l mg mh">timer = setTimeout(() =&gt; fn(), delay);</span></pre><p id="ef09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">timer变量被分配给setTimeout的函数调用，如前所述，它将在经过“延迟”时间后执行其第一个参数(匿名函数)。调用setTimeout的结果是返回该setTimeout的ID。因此，我们现在将这个setTimeout的ID存储在timer中。</p><p id="1a4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们向上看一行代码，我们会看到:</p><pre class="ll lm ln lo gt lx ly lz ma aw mb bi"><span id="db85" class="mc md iq ly b gy me mf l mg mh">clearTimeout(timer);</span></pre><p id="e271" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们去抖功能的实际去抖部分。假设我们已经调用了一次去抖函数，并启动了setTimeout来倒计时“延迟”时间。但是，让我们假设在第一个“延迟”时间过去之前，我们刚刚第二次调用了去抖函数…现在会发生什么呢？</p><p id="5408" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为“延迟”时间还没有过去，clearTimeout将清除原始的setTimeout，防止它调用作为参数接收的函数。但这怎么可能呢？(参见下面的代码注释)</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/e2eaf45bb46d17970a35f81930cac3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMCoaDcUmlMDpDKyC08aLA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">关闭的显著好处</figcaption></figure><p id="436c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以访问原始的setTimeout ID，因为它被分配给了timer。然而，定时器是在去抖返回语句之外声明的，因此“<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">关闭</a>来拯救！”</p><p id="244c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">去抖动已经发生。我们希望去抖的函数只有在去抖版本被调用并且“延迟”时间已经过去的情况下才会执行。如果“延迟”时间尚未过去，去抖将清除先前的setTimeout，并创建一个新的setTimeout，该setTimeout必须等到“延迟”时间过去后才能执行。</p><p id="d4c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步:启用一些参数的使用。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/83278383329df824608cd8cb37c127f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQySTsolHAH8HdA3idsyNA.png"/></div></div></figure><p id="e5cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我使用<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest参数</a>语法(第4行)访问所有可能传递给我的去反跳函数的去反跳版本的参数。然后这些参数被传递给第7行传入函数的函数调用，并使用<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">展开</a>语法展开。</p><p id="6080" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">压轴戏:这里有一个工作代码样本，你可以在chrome开发工具中试用，或者在任何你喜欢运行JavaScript的地方查看我们自制的去抖功能。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/a869c6aa8683299a5337dd0cd547c08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWvnlQ1l1cDd-fY5NPOQkw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">动态去抖</figcaption></figure><p id="a00b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有去抖函数(第1行)、myFunc(第9行):它将文本记录到控制台，还有一个去抖版本的myFunc，名为myDebouncedFunc(第10行)。这两个for循环将调用myFunc的非去抖版本和去抖版本。</p><p id="ed53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一个for循环中，myFunc被调用10次，然后执行10次。然而，在第二个for循环中，myDebouncedFunc被调用了10次，但只执行了一次！为胜利而去抖！</p><p id="4530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在Lodash等JavaScript库中找到的预烘焙版本的去抖非常有用。然而，花时间深入了解反跳的内部工作原理，无疑会让你对其应用的理解和欣赏有所增长。保持冷静，继续去抖！</p></div></div>    
</body>
</html>