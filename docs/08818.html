<html>
<head>
<title>Save Money on your Cloud Bandwidth with Compression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过压缩节省您的云带宽成本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/save-money-on-your-cloud-bandwidth-with-compression-7ea17d820bc5?source=collection_archive---------25-----------------------#2021-06-07">https://levelup.gitconnected.com/save-money-on-your-cloud-bandwidth-with-compression-7ea17d820bc5?source=collection_archive---------25-----------------------#2021-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/87168c9db891a389c92fe1603dae3178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9GOnb7foAlaLBK66.jpg"/></div></div></figure><div class=""/><div class=""><h2 id="b94f" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">使用简单的数据压缩技术为您节省一些钱，并为您的用户节省一些加载时间</h2></div><p id="2acf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您的APIs服务器使用纯文本(纯JSON、纯HTML、纯任何东西)进行通信，并且您使用对数据传输收费的云服务，那么下面的文章可能会为您节省超过60%的费用。我们将以JSON为例，但是大部分内容适用于任何类型的数据。</p><h1 id="3bf2" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">动机</h1><p id="157c" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">因此，最近，有人告诉我要快速编写一个python脚本，该脚本采用JSON并对其应用几种压缩和编码技术。然后，我被要求计算使用压缩到最小尺寸的技术的潜在节省。然后，我想我可以写一篇关于它的文章，并开发一个小的网络应用程序，为你做计算。那么，让我们开始吧。</p><h1 id="8bc4" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">JSON是什么？</h1><p id="f136" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">所以，JSON是JaveScript对象符号的缩写。它由键-值对组成(它只能是值/对象的数组)，其中值可以是任何值(int、float、string、bool、array、objects)。所以这是一种表示数据的方式，也是一种交流数据的方式。随着人们越来越多地在他们的API和应用程序中使用它，它已经成为一种标准。一个简单的例子:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/66e88357b08ebb657e6025c2b9368dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfKFNuhaoNBEqlnxdGkYhA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">JSON的一个例子</figcaption></figure><h1 id="a3ac" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">为什么要压缩？</h1><p id="2004" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">上面的JSON的大小是<strong class="kv jf"> 214字节</strong>。不太多，是吧？正确。这在我们现在的世界里基本不算什么。然而，想象一下，如果你每隔<strong class="kv jf"> 10秒向你的API或网站的5000个用户/客户</strong>发送一个类似的有效载荷(这是一个非常低的数字)；这将占<strong class="kv jf">258 GB/月</strong>。AWS为每GB (在第一个1 GB之后)向您收取0.09美元<strong class="kv jf"/><strong class="kv jf">。这相当于<strong class="kv jf">～23.24美元</strong>。</strong></p><p id="58f6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，想象一下，如果您的API中有5个其他端点同时加载了这个，这个数字将变成<strong class="kv jf"> ~$140 </strong>。<strong class="kv jf"> </strong>对于一个企业来说，这可能不算多，但是如果企业有更多的API和更多的负载来来回回，那么这个数字很容易变成数千美元。大多数API在它们的JSON有效负载中发送的信息比上面的例子更多。尽管如此，对于一个个人项目，或者一个非营利项目，你可能会尝试优化你在这些事情上的花费。</p><p id="a7cd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">以下是您可能希望这样做的场景(同样，不仅仅是JSON，而是所有内容):</p><ul class=""><li id="0335" class="mv mw je kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">节省一些数据传输费用。</li><li id="b95b" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">如果直接复制传输的数据，可以节省一些存储容量。</li><li id="78f5" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">您的用户使用移动设备，连接速度非常慢，您希望为他们节省资金或缩短应用程序的响应时间。</li><li id="84fd" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated"><strong class="kv jf">不是为了安全</strong>，但它们有时会增加一点安全性，因为数据在传输时是不可读的，尽管如果使用的技术是已知的，它可以很容易地被还原。</li><li id="2ebc" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">因为你可以！大多数浏览器都有对其中许多内容的原生支持，您不必处理前端实现的问题。</li></ul><h1 id="54f2" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">什么是编码和压缩？</h1><p id="eaf4" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated"><strong class="kv jf"> <em class="nj">编码</em> </strong>是根据编码系统/规范，将一些数据以不同的形式表示的一种方式。这里的目的是用简洁的方式表示<strong class="kv jf"> <em class="nj">值</em> </strong>。这意味着数据仍将以某种方式保持其结构。有些方法更喜欢模式，有些不喜欢(就像我们将要介绍的那些)。</p><p id="6137" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="nj">压缩</em> </strong>在某些方面是类似的，但是这里的主要目的是在最后有更小的<strong class="kv jf"> <em class="nj">数据</em> </strong>。与编码不同，它将数据视为一个整体(一组字节)，而不是单个的值。这导致数据失去了它的语义结构，因为它被当作字节来处理。</p><p id="c38c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于这两者来说，在传输过程中，您的数据将不再相同，它将采用一种不同的表示方式。此外，这意味着您需要为后端和前端添加支持，以便对这些内容进行压缩/编码和解压缩/解码。此外，执行这些操作的少量延迟开销可能会添加到您的流中。</p><p id="26d0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">幸运的是，很多浏览器和其他工具都支持这些东西，有时你不需要自己做所有的事情，即使你不得不做，这也是相当简单的。</p><h1 id="246e" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">使用的技术:</h1><p id="28d7" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">我不打算详细介绍每种方法，但在选择最适合您的方法时，有几件事情需要记住:</p><ul class=""><li id="e5d3" class="mv mw je kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">压缩率:有些技术比其他技术更能压缩数据</li><li id="66a7" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">编码/压缩时间:一些技术花费更多的时间来完成它们的工作，如果延迟对你很重要的话，你可能想深入分析一下。</li><li id="e32b" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">模式vs无模式:虽然我们在这里没有介绍，但是有些方法需要模式(预先知道数据的形状)，有些不需要。那些在前面两件事情上做得更好的人，因为他们已经在模式的每一端都有了很多硬编码的部分。</li><li id="f3bb" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">支持(安全性和可维护性):您可能希望选择符合当前标准(甚至是标准化的)的东西。拥有一个围绕该工具的活跃社区有助于发现漏洞和错误，从而修复它们。</li></ul><h2 id="f8dc" class="nk lq je bd lr nl nm dn lv nn no dp lz lc np nq mb lg nr ns md lk nt nu mf nv bi translated">编码/序列化:</h2><ul class=""><li id="853a" class="mv mw je kv b kw mh kz mi lc nw lg nx lk ny lo na nb nc nd bi translated">保持JSON不变(对后面的例子来说更多的是一个占位符)。</li><li id="6f61" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">缩小它(去掉空格、制表符和换行符)<br/>你可以这样做，不会给前端或后端带来额外的负担，从而节省一些带宽。</li><li id="e314" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">https://cbor.io/<br/><a class="ae nz" href="https://cbor.io/" rel="noopener ugc nofollow" target="_blank"/>CBOR(简明二进制对象表示法)</li><li id="bf5b" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">https://msgpack.org/index.html<a class="ae nz" href="https://msgpack.org/index.html" rel="noopener ugc nofollow" target="_blank">msg pack<br/></a></li></ul><h2 id="dd33" class="nk lq je bd lr nl nm dn lv nn no dp lz lc np nq mb lg nr ns md lk nt nu mf nv bi translated">压缩:</h2><ul class=""><li id="1e66" class="mv mw je kv b kw mh kz mi lc nw lg nx lk ny lo na nb nc nd bi translated">布罗特利——谷歌<br/><a class="ae nz" href="https://github.com/google/brotli" rel="noopener ugc nofollow" target="_blank">https://github.com/google/brotli</a></li><li id="ca63" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">zstd—https://facebook.github.io/zstd/脸书<br/>T11</li><li id="bdef" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">爽快——谷歌<br/><a class="ae nz" href="https://github.com/google/snappy" rel="noopener ugc nofollow" target="_blank">https://github.com/google/snappy</a></li><li id="4f10" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">zlib(gz)<br/><a class="ae nz" href="https://github.com/madler/zlib" rel="noopener ugc nofollow" target="_blank">https://github.com/madler/zlib</a></li></ul><h1 id="f957" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">真实世界的例子</h1><p id="7322" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">我在<strong class="kv jf"> </strong>上平均得到了大小为<strong class="kv jf"> ~6500字节</strong>的有效载荷。有<strong class="kv jf"> 2000个用户</strong>，他们每分钟请求<strong class="kv jf"> 20次</strong>。有<strong class="kv jf"> 4个端点</strong>服务相同大小的有效载荷。此外，我们使用的云服务每GB收费0.15美元。那么，每月要花多少钱呢？</p><p id="fb52" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe oa ob oc od b">6500 x 2000 * 20 * 4 * 0.15 * 30 * 24 * 60 / (1024³) = $6276.37</code></p><p id="02d4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">费用为6276.37美元。现在，我们想看看我们能节省多少。我们做了一个Python脚本，让<strong class="kv jf">获取一个JSON </strong>，<strong class="kv jf">序列化/编码它</strong>，然后<strong class="kv jf">压缩结果</strong>。这就是使用上述任何一种方法有多容易:</p><pre class="mn mo mp mq gt oe od of og aw oh bi"><span id="22d4" class="nk lq je od b gy oi oj l ok ol">import cbor2<br/>serialized_json_bytes = cbor2.dumps(json_bytes)</span><span id="df10" class="nk lq je od b gy om oj l ok ol">import brotli<br/>original_compressed_json = brotli.compress(json_bytes)<br/>#or<br/>serialized_compressed_json = brotli.compress(serialized_json_bytes)</span><span id="c822" class="nk lq je od b gy om oj l ok ol">final_length = len(serialized_json_bytes) # straightforward</span></pre><p id="4a3e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们运行了前面提到的所有技术，只关心大小(您可能也关心延迟——不是说它们很慢)。我们最终得到了以下结果:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/a040dcfb57c17b3fce590b9482caae7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZ3tFPDYZq4vHqt-jc28TA.png"/></div></div></figure><p id="ac16" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这张表上有几件事需要注意。首先，任何类型的压缩都应该节省一些带宽，尤其是如果你的有效载荷很大的话。其次，在这些候选人中，brotli似乎做得最好。第三，这是对你的数据传输账单的一个立即转换，<strong class="kv jf"> brotli节省</strong> <strong class="kv jf"> %23.59的大小，意味着节省%23.59的钱。这意味着我们的账单将降至1480美元(节省约4800美元)。</strong>值得一提的是，使用一种使用模式或学习数据的方法甚至可能减少到原来大小的10%<strong class="kv jf"/>。</p><h1 id="f906" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">我写了一个计算器</h1><p id="c4dc" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">所以，我用<strong class="kv jf"> <em class="nj"> streamlit </em> </strong>写了一个小的web应用程序，它用<strong class="kv jf"><em class="nj">【Python】、</em> </strong>执行所有前述的计算，对于其他语言/框架来说应该是一样直观的。</p><ul class=""><li id="4db1" class="mv mw je kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">你可以在这里试试app本身:<br/><a class="ae nz" href="https://json-savings.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://json-savings.herokuapp.com/</a></li><li id="9e05" class="mv mw je kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">您可以在这里对回购本身做出贡献(添加新技术或更好的可视化)也可以随意给它打个星:<br/>、https://github.com/saedx1/json_savings或https://share.streamlit.io/saedx1/json_savings/main/app.py<a class="ae nz" href="https://share.streamlit.io/saedx1/json_savings/main/app.py" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="ed05" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下面是使用计算器应用程序的前一个示例(JSON隐藏):</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/2eabf67d6ed20c38c57facd1624016bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmQAKeROVbBqKwB36pNSzg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">JSON储蓄网络计算器</figcaption></figure><p id="e68d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它显示了计算出的每月账单，你可以节省的金额，以及你选择的技术之间的全面比较。</p><h1 id="eb6d" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">就这样</h1></div></div>    
</body>
</html>