<html>
<head>
<title>Functional JavaScript — Benefits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript —优势</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-javascript-benefits-bdc61cc0925?source=collection_archive---------4-----------------------#2020-09-12">https://levelup.gitconnected.com/functional-javascript-benefits-bdc61cc0925?source=collection_archive---------4-----------------------#2020-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d97eeffe877736c7a5cb4fe4cc2cbb35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y28gPQGsn-RWMNR5"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@m_a_x_b?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克斯·伯麦</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b40d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解如何使用JavaScript中的函数式编程特性。</p><h1 id="cdb8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数式编程的好处</h1><p id="78f7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数式编程有各种好处。</p><p id="7a24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是它被JavaScript等编程语言采用的原因。</p><h1 id="2c4c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">纯函数</h1><p id="837d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数式编程的一个好处是我们在代码中定义纯函数。</p><p id="b2f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们向一个纯函数传递相同的输入，它会返回相同的输出。</p><p id="700c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8cec" class="mq lf it mm b gy mr ms l mt mu">const square = (value) =&gt; value ** 2;</span></pre><p id="1290" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到这个值，然后返回它的平方。</p><p id="073d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管外面发生什么，这一点都不会改变。</p><p id="dee9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好处是纯函数很容易测试。</p><p id="794d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在给它一些输入后检查输出。</p><p id="ff9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于它不依赖于外部的任何东西，我们可以很容易地检查它。</p><p id="6dd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写如下代码来检查返回值:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3dcc" class="mq lf it mm b gy mr ms l mt mu">square(2) === 4</span></pre><h1 id="0bf0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">合理代码</h1><p id="67d0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">阅读代码很容易，因为函数的代码都在函数内部。</p><p id="532b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="26d7" class="mq lf it mm b gy mr ms l mt mu">const square = (value) =&gt; value ** 2;</span></pre><p id="f5e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所做的就是对传入的数字求平方。</p><p id="d748" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">外面什么都没有，所以我们可以很容易地看着它。</p><h1 id="0b47" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">并行代码</h1><p id="3492" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">由于纯函数不依赖于函数外部的任何值，所以我们不必担心函数的值与外部的值同步。</p><p id="f10a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有全球价值观，那么我们可能必须这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="08fe" class="mq lf it mm b gy mr ms l mt mu">let global = "something"<br/>let foo = (input) =&gt; {<br/>  global = "somethingElse"<br/>}</span><span id="dfd0" class="mq lf it mm b gy mv ms l mt mu">let bar = () =&gt; {<br/>  if (global === "something") {<br/>    //...<br/>  }<br/>}</span></pre><p id="f7d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在做一些事情之前，我们必须检查变量<code class="fe mw mx my mm b">global</code>的值。</p><p id="2ed5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于纯函数，我们不必这样做，因为没有外部依赖。</p><h1 id="eaa8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可食用的</h1><p id="a6dd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于给定的输入，纯函数总是返回相同的输出。</p><p id="3a2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以很容易地缓存函数输出。</p><p id="cfd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是用输入作为键，输出作为值。</p><p id="5821" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从缓存中查找值。</p><p id="2703" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过缓存，我们可以提高代码的速度。</p><p id="05c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用一个对象保存一个缓存:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fa9f" class="mq lf it mm b gy mr ms l mt mu">const cache = {<br/>  1: 2,<br/>  3: 4,<br/>  //...<br/>}</span></pre><p id="f1eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过编写以下代码来检查缓存的值:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="663b" class="mq lf it mm b gy mr ms l mt mu">const value = cache.hasOwnProperty(input) ?<br/>  cache[input] :<br/>  cache[input] = longRunningFunction(input)</span></pre><p id="2888" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在运行<code class="fe mw mx my mm b">longRunningFunction</code>之前，我们检查缓存的值。</p><h1 id="7103" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">管道和可组合</h1><p id="1d3e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以很容易地合成纯函数。</p><p id="a37d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是将一个纯函数的返回值传递给另一个纯函数。</p><p id="8e3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bf60" class="mq lf it mm b gy mr ms l mt mu">const foo = (a) =&gt; {<br/>  return a * 2;<br/>}</span><span id="dc99" class="mq lf it mm b gy mv ms l mt mu">const bar = (b) =&gt; {<br/>  return b * 3;<br/>}</span></pre><p id="f5e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写以下内容来组合这些函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="565d" class="mq lf it mm b gy mr ms l mt mu">foo(bar(100));</span></pre><p id="8c37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它看起来像一个数学函数，它是一个数学函数。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/288e8de7a5948ea58ed6ba6c6efae499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zu6davoo7y7t6Pau"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c48f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="bf26" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数式编程有各种好处。</p><p id="eaef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以很容易地并行运行代码，因为我们不必同步代码。</p><p id="1a0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以很容易地组合函数。</p><p id="f5d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们也更容易阅读和测试。</p></div></div>    
</body>
</html>