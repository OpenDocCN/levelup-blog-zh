<html>
<head>
<title>Using compose destinations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用撰写目的地</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-compose-destinations-67aa2c0be7fc?source=collection_archive---------7-----------------------#2022-04-12">https://levelup.gitconnected.com/using-compose-destinations-67aa2c0be7fc?source=collection_archive---------7-----------------------#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="210d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">使用合成目的地</em></p><p id="299f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">文章在此:</em><a class="ae kp" href="https://flatteredwithflutter.com/using-compose-destinations%ef%bf%bc/" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://flattered with flutter . com/using-compose-destinations/</em></a></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kv kw l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用撰写目的地</figcaption></figure><p id="2965" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将简要介绍:</p><ol class=""><li id="76fd" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">撰写中的当前导航</li><li id="d007" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">使用撰写目的地</li><li id="a321" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">(可选)修改现有的测试用例</li></ol><blockquote class="lp lq lr"><p id="0de2" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">注意:本文假设读者了解Jetpack Compose</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lv"><img src="../Images/65b461038a4f3ba3e682125b59c713c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsA0GiqYFo8XVvSzFVgAtQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用撰写目的地</figcaption></figure><h1 id="12e4" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">撰写中的当前导航</h1><p id="02b1" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">我们从Jetpack组合中获得<a class="ae kp" href="https://developer.android.com/jetpack/compose/navigation" rel="noopener ugc nofollow" target="_blank">组合导航</a>。它提供了一个<a class="ae kp" href="https://developer.android.com/guide/navigation" rel="noopener ugc nofollow" target="_blank">导航组件</a>，允许您在不同的可组合组件之间导航。</p><p id="2200" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们使用代码示例来看看它的运行情况。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nf"><img src="../Images/a08caac01f3207390dbd15c16a16d5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Y5SI5C5ax2oHHP0ywpodQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">导航组件</figcaption></figure><ul class=""><li id="84ff" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">我们有可组合的<code class="fe nh ni nj nk b">NavigationComponent</code>。您可以假设这个文件包含我们应用程序中的所有路线。我们可以看到，这里有三条路线，分别是:<code class="fe nh ni nj nk b">Auth</code> <code class="fe nh ni nj nk b">Home</code>和<code class="fe nh ni nj nk b">AddTodo</code></li><li id="d2e6" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated">起始或第一条路线是<code class="fe nh ni nj nk b">Auth</code>，基于某种逻辑(在我们的例子中是中的<a class="ae kp" href="https://proandroiddev.com/google-signin-compose-a9afa67b7519" rel="noopener ugc nofollow" target="_blank">符号)，它在经过一个对象<code class="fe nh ni nj nk b">user</code>时重定向到<code class="fe nh ni nj nk b">Home</code></a></li><li id="9cfa" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated">我们所有的路线都需要一个导航控制器。<code class="fe nh ni nj nk b">NavController</code>是导航组件的核心API。它会跟踪应用程序中屏幕的堆栈以及每个屏幕的状态。</li><li id="fd47" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated">我们通过使用<code class="fe nh ni nj nk b">rememberNavController()</code>方法创建一个<code class="fe nh ni nj nk b">NavController</code>，并在我们的视图中传递它</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="4bbb" class="np md it nk b gy nq nr l ns nt">val navController = rememberNavController()</span></pre><h2 id="d294" class="np md it bd me nu nv dn mi nw nx dp mm kb ny nz mq kf oa ob mu kj oc od my oe bi translated">正在创建NavHost</h2><ul class=""><li id="b4bf" class="lb lc it js b jt na jx nb kb of kf og kj oh kn ng lh li lj bi translated">每个<code class="fe nh ni nj nk b">NavController</code>必须与一个<code class="fe nh ni nj nk b">NavHost</code>可组合相关联。<code class="fe nh ni nj nk b">NavHost</code>将<code class="fe nh ni nj nk b">NavController</code>与一个导航图链接起来，该导航图指定了您应该能够在其中导航的可组合目的地。</li><li id="697c" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated">为了将这一切联系起来，我们将上面的<code class="fe nh ni nj nk b">NavigationComponent</code>放在我们的主活动中</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oi"><img src="../Images/2ae04d7b5593e7b4330a0b52d4863d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6rClCdKYOmR1c_FfDYXgw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">主要活动</figcaption></figure><ul class=""><li id="c3ae" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">对于导航路线，我们使用<code class="fe nh ni nj nk b">navigate()</code>方法。<code class="fe nh ni nj nk b">navigate()</code>接受代表目的地路线的单个<code class="fe nh ni nj nk b">String</code>参数。</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="fa86" class="np md it nk b gy nq nr l ns nt">// Navigate to some screen<br/>navController.navigate("screen_route")</span><span id="530a" class="np md it nk b gy oj nr l ns nt">// Pop everything up to the "home" destination off the back stack before<br/>// navigating to the "friendslist" destination<br/>navController.navigate("friendslist") {<br/>    popUpTo("home")<br/>}<br/><br/>// Pop everything up to and including the "home" destination off<br/>// the back stack before navigating to the "friendslist" destination<br/>navController.navigate("friendslist") {<br/>    popUpTo("home") { inclusive = true }<br/>}</span></pre><h2 id="ee4f" class="np md it bd me nu nv dn mi nw nx dp mm kb ny nz mq kf oa ob mu kj oc od my oe bi translated">传递自定义参数</h2><ul class=""><li id="1db2" class="lb lc it js b jt na jx nb kb of kf og kj oh kn ng lh li lj bi translated">为了做到这一点，您将参数占位符添加到您的路线，类似于您如何<a class="ae kp" href="https://developer.android.com/guide/navigation/navigation-deep-link#implicit" rel="noopener ugc nofollow" target="_blank">将参数添加到深层链接</a></li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="882d" class="np md it nk b gy nq nr l ns nt">navController.navigate(Destinations.Home.replace("{user}",userJson))</span></pre><p id="adf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，所有参数都被解析为字符串。接下来，您应该从<code class="fe nh ni nj nk b">composable()</code>函数的lambda中可用的<code class="fe nh ni nj nk b">NavBackStackEntry</code>中提取<code class="fe nh ni nj nk b">NavArguments</code>。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="c5c9" class="np md it nk b gy nq nr l ns nt">composable(Destinations.Home) { backStackEntry -&gt;<br/>    val userJson = backStackEntry.arguments?.getString("user")</span><span id="2be9" class="np md it nk b gy oj nr l ns nt">    // DO YOUR PROCESSING AND CONVERT TO USER OBJECT<br/>    HomeView(navController, userModel = userObject!!)<br/>}</span></pre></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="11d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你还在读书，你可能已经意识到这是不是工作量太大了？我同意你的观点。有一些样板代码，特别是在传递自定义参数的情况下。<em class="ko">嗯，这个可以改进吗？是啊！！！</em></p><h1 id="3f6f" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">使用撰写目的地</h1><p id="8357" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">忘掉前一部分，重新开始。假设您需要在应用程序中实现导航。</p><blockquote class="lp lq lr"><p id="5ab6" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">介绍<a class="ae kp" href="https://github.com/raamcosta/compose-destinations" rel="noopener ugc nofollow" target="_blank">合成目的地</a>。根据文件</p></blockquote><p id="9ec9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">Compose Destination</strong>:KSP的一个库，处理注释并生成代码，使用官方的Jetpack Compose导航。它隐藏了复杂的、非类型安全的样板代码，否则您将不得不编写这些代码。大多数API要么与Jetpack组件相同，要么受其启发。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi or"><img src="../Images/4f39a82b76ba2d0ce28528dbf0b3467a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*owdq1scPQ9KhUZR5.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">撰写目的地</figcaption></figure><h2 id="6c90" class="np md it bd me nu nv dn mi nw nx dp mm kb ny nz mq kf oa ob mu kj oc od my oe bi translated">设置</h2><ul class=""><li id="eeda" class="lb lc it js b jt na jx nb kb of kf og kj oh kn ng lh li lj bi translated">在您的应用程序的<code class="fe nh ni nj nk b">build.gradle</code>中安装依赖项</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="d93f" class="np md it nk b gy nq nr l ns nt">ksp 'io.github.raamcosta.compose-destinations:ksp:1.4.2-beta'</span><span id="a316" class="np md it nk b gy oj nr l ns nt">implementation 'io.github.raamcosta.compose-destinations:core:1.4.2-beta'</span></pre><ul class=""><li id="613b" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">在<code class="fe nh ni nj nk b">build.gradle</code>的插件中添加以下内容</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="9927" class="np md it nk b gy nq nr l ns nt">plugins {<br/>    id 'com.google.devtools.ksp' version '1.6.10-1.0.2'<br/>}</span></pre><blockquote class="lp lq lr"><p id="d62c" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">注意:撰写目的地利用注释处理(使用KSP)来提高撰写导航的可用性。</p></blockquote><ul class=""><li id="a84c" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">包含一个kotlin块，它为您的<code class="fe nh ni nj nk b">build.gradle</code>中生成的代码定义了<code class="fe nh ni nj nk b">sourceSets</code></li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="cb30" class="np md it nk b gy nq nr l ns nt">kotlin {<br/>    sourceSets {<br/>        debug {<br/>            kotlin.srcDir("build/generated/ksp/debug/kotlin")<br/>        }<br/>        release {<br/>            kotlin.srcDir("build/generated/ksp/release/kotlin")<br/>        }<br/>    }<br/>}</span></pre><h2 id="3a69" class="np md it bd me nu nv dn mi nw nx dp mm kb ny nz mq kf oa ob mu kj oc od my oe bi translated">实施导航</h2><p id="59aa" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">所以您仍然有路线:<code class="fe nh ni nj nk b">Auth</code> <code class="fe nh ni nj nk b">Home</code>和<code class="fe nh ni nj nk b">AddTodo</code>现在让我们看看如何实现导航。您有现有的组件。让我们注释它们</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi os"><img src="../Images/6e256c95871f87dd3d7e17008baed8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDsWlflc4xJPGKc0_YXwZA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">撰写目标批注</figcaption></figure><ul class=""><li id="7cdf" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">我们使用来自<a class="ae kp" href="https://github.com/raamcosta/compose-destinations" rel="noopener ugc nofollow" target="_blank">合成目的地</a>的<code class="fe nh ni nj nk b">Destination</code>注释</li><li id="eab3" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated">我们用<code class="fe nh ni nj nk b">start = True</code>标记我们的AuthScreen，这意味着这个目的地是导航图的起始目的地</li><li id="2b4c" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated">接下来，我们将<code class="fe nh ni nj nk b">navController</code>的类型改为<code class="fe nh ni nj nk b">DestinationsNavigator</code></li></ul><blockquote class="lp lq lr"><p id="b812" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">DestinationsNavigator是NavController的包装接口。</p></blockquote><ul class=""><li id="eb29" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">对于其他屏幕，比如说AddTodo，我们简单地注释它。</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="c2c8" class="np md it nk b gy nq nr l ns nt">@Destination<br/>@Composable<br/>fun AddTodoView(navController: DestinationsNavigator) {}</span></pre><ul class=""><li id="b8f3" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">让我们运行下面生成所有目的地的命令</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="96fb" class="np md it nk b gy nq nr l ns nt">./gradlew clean build</span></pre><p id="9768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果结果是成功的，您应该在<code class="fe nh ni nj nk b">build/generated/ksp/debug/kotlin</code>中看到生成的代码</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/9d476032e8cd4f00c747fb5a5f01906c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*ctCumI3xUMtYzMePrreA9A.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用撰写目标生成的目标</figcaption></figure><h2 id="8c37" class="np md it bd me nu nv dn mi nw nx dp mm kb ny nz mq kf oa ob mu kj oc od my oe bi translated">使用NavHost</h2><p id="2093" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">如果你意识到了，我们不再需要<code class="fe nh ni nj nk b">NavigationComponent</code>类。</p><ul class=""><li id="04e5" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">剩下的最后一件事是在我们的<code class="fe nh ni nj nk b">MainActivity</code>中添加<code class="fe nh ni nj nk b">NavHost</code></li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="92ed" class="np md it nk b gy nq nr l ns nt">class MainActivity : ComponentActivity() {</span><span id="3ef6" class="np md it nk b gy oj nr l ns nt">override fun onCreate(savedInstanceState: Bundle?) {<br/>  super.onCreate(savedInstanceState)<br/>  setContent {<br/>      AppTheme {<br/>          DestinationsNavHost(navGraph = NavGraphs.root)<br/>      }<br/>  }<br/> }<br/>}</span></pre><ul class=""><li id="739b" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">我们的<code class="fe nh ni nj nk b">DestinationsNavHost</code>包括navGraph的目的地。它包括导航图生成文件中所有用<code class="fe nh ni nj nk b">Destination</code>标注的组件。</li><li id="af44" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated"><code class="fe nh ni nj nk b">NavGraphs</code>是一个生成的文件，描述您的导航图及其目的地。默认情况下，所有目的地都属于<code class="fe nh ni nj nk b">NavGraphs.root</code></li><li id="8596" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated">最后，对于导航到屏幕，我们仍然遵循相同的约定，但是现在我们将目的地(如<code class="fe nh ni nj nk b">AddTodoViewDestination</code>等)映射到每个视图。</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="508e" class="np md it nk b gy nq nr l ns nt">// Navigate to add view screen<br/>navController.navigate(<!-- -->AddTodoViewDestination<!-- -->)<br/><br/>// Pop everything up to and including the "auth" destination off<br/>// the back stack before navigating to the "Home" destination<br/>navController.navigate(<!-- -->HomeViewDestination<!-- -->) {<br/>    popUpTo(<!-- -->AuthScreenDestination.routeId<!-- -->) { inclusive = true }<br/>}</span></pre><h2 id="e2df" class="np md it bd me nu nv dn mi nw nx dp mm kb ny nz mq kf oa ob mu kj oc od my oe bi translated">传递自定义参数</h2><p id="59d3" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">这就是这变得有趣的原因。让我们看一个例子，例如，我们有一个Auth屏幕，我们需要将用户对象传递到我们的主屏幕。</p><ul class=""><li id="38b3" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">让我们创建一个<a class="ae kp" href="https://developer.android.com/guide/navigation/navigation-kotlin-dsl#custom-types" rel="noopener ugc nofollow" target="_blank"> Parcelable </a>类<code class="fe nh ni nj nk b">GoogleUserModel</code>这个类基本上包含用户从google 登录后的用户名和电子邮件。</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="d92a" class="np md it nk b gy nq nr l ns nt">@Parcelize<br/>data class GoogleUserModel(<br/>    val name: String?,<br/>    val email: String?<br/>) : Parcelable</span></pre><ul class=""><li id="7e9a" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">我们修改我们的<code class="fe nh ni nj nk b">Home</code>组件如下</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="3562" class="np md it nk b gy nq nr l ns nt">@Destination<br/>@Composable<br/>fun HomeView(<br/>    navController: DestinationsNavigator,<br/>    userModel: GoogleUserModel,<br/>) {}</span></pre><p id="1ab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将parcelable类<code class="fe nh ni nj nk b">GoogleUserModel</code>添加到参数中，接下来，我们再次需要运行我们的build命令来更新为<code class="fe nh ni nj nk b">HomeView</code>生成的目的地</p><ul class=""><li id="124b" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">在我们的<code class="fe nh ni nj nk b">AuthView</code>中，一旦我们从API获得所需的数据，我们就创建<code class="fe nh ni nj nk b">GoogleUserModel</code>并将其传递给<code class="fe nh ni nj nk b">HomeViewDestination</code></li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="fcdb" class="np md it nk b gy nq nr l ns nt">navController.navigate(<br/>    HomeViewDestination(<br/>        GoogleUserModel(<br/>            email = user.email,<br/>            name = user.name,<br/>        )<br/>    )<br/>) {<br/>    popUpTo(route = AuthScreenDestination.routeId) {<br/>        inclusive = true<br/>    }<br/>}</span></pre><p id="d64c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们导航到<code class="fe nh ni nj nk b">HomeView</code>之后，我们弹出路线，包括通过在弹出菜单中指定<code class="fe nh ni nj nk b">AuthScreenDestination</code>弹出的<code class="fe nh ni nj nk b">AuthView</code>。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="0e0a" class="mc md it bd me mf ou mh mi mj ov ml mm mn ow mp mq mr ox mt mu mv oy mx my mz bi translated">修改现有的测试用例</h1><p id="16b5" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">我们基于<code class="fe nh ni nj nk b">NavigationComponent</code>(当我们使用它的时候)创建了一些测试，但是因为我们不再拥有它，我们使用了<code class="fe nh ni nj nk b">DestinationsNavigator</code></p><ul class=""><li id="fdc3" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">由于<code class="fe nh ni nj nk b">DestinationsNavigator</code>是一个接口，我们创建了自己的<code class="fe nh ni nj nk b">DestinationsNavigatorImpl</code>类。</li><li id="68e4" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn ng lh li lj bi translated">我们的<strong class="js iu">destinations navigator impl</strong>只是从<strong class="js iu"> DestinationsNavigator </strong>类扩展而来，我们覆盖了<code class="fe nh ni nj nk b">DestinationsNavigator</code>的所有方法</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oz"><img src="../Images/397cd8d21d1c7d6d950eb97e8d657dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDJ09H4BtMynWLQ9je4mwQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">目的地导航入口</figcaption></figure><ul class=""><li id="9249" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">接下来，我们简单地用现有测试中的<code class="fe nh ni nj nk b">DestinationsNavigatorImpl</code>替换<code class="fe nh ni nj nk b"><a class="ae kp" href="https://developer.android.com/reference/kotlin/androidx/navigation/testing/TestNavHostController" rel="noopener ugc nofollow" target="_blank">TestNavHostController</a></code>，</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="834f" class="np md it nk b gy nq nr l ns nt">// PREVIOUS<br/>private lateinit var navController: TestNavHostController</span><span id="2827" class="np md it nk b gy oj nr l ns nt">// NOW<br/>private var navController = DestinationsNavigatorImpl()</span></pre><ul class=""><li id="4768" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn ng lh li lj bi translated">我们在测试中用<code class="fe nh ni nj nk b">DestinationsNavHost</code>代替了<code class="fe nh ni nj nk b">NavigationComponent</code></li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="0671" class="np md it nk b gy nq nr l ns nt">composeTestRule.setContent {<br/>    <br/>     // PREVIOUS <br/>     NavigationComponent()<br/>     <br/>     // NOW<br/>     DestinationsNavHost(navGraph = NavGraphs.root)<br/> }</span></pre><p id="2627" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这样…..</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/b0b4812104e13509067d20b809f9e350.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*dbMwiwVqs-RR1T-0.gif"/></div></figure><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="f439" class="np md it nk b gy nq nr l ns nt"><a class="ae kp" href="https://github.com/AseemWangoo/hands_on_kotlin" rel="noopener ugc nofollow" target="_blank">Source code</a></span></pre></div></div>    
</body>
</html>