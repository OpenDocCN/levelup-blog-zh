<html>
<head>
<title>Write fluent code in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin写流畅的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-fluent-code-in-kotlin-133647f2a869?source=collection_archive---------1-----------------------#2020-05-27">https://levelup.gitconnected.com/write-fluent-code-in-kotlin-133647f2a869?source=collection_archive---------1-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6c875c328599af633776828f19bc2f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T2gofYdQvOms-owd"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@mikeanywhere?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·刘易斯智慧媒体</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="088b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你有没有看过一段代码，心想“我不是在看代码，我是在看故事！”。流畅的代码读起来像散文；它讲述了作者试图达到的一个故事，读起来像简单的英语。代码只是流动；阅读几乎不费吹灰之力。就像优美的散文一样，流畅的代码需要努力去创造。当你阅读一段代码时，它只是自我阅读，作者代表你付出了努力来塑造它。</p><p id="fba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我赞同“让它工作，让它漂亮，让它快”的想法，漂亮代码的一个组成部分是它的流畅性。在编写和审查代码时，我经常发现自己频繁地使用一些“风格选择”来实现可读的代码。然而，一段代码的可读性是主观的，与其说是科学，不如说是艺术，因此您的收获可能会因您的偏好和环境中的约定而异。</p><p id="6c6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">免责声明:以下建议是我的观点，可能不是普遍接受的最佳实践。</em></p><h2 id="66bc" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">尽量少用注释</h2><p id="25d4" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">注释不是代码的一部分。它们被编译器忽略，只对编码人员存在。它们也是另一个维护点，随着代码的独立发展，它们可能会过时。</p><p id="682f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鲍勃大叔的《干净的代码》一书用“用代码解释你自己”这句话很好地总结了这一点。我们应该在代码本身中记录我们的意图，通过使用清晰的命名和下面提到的使代码可读的其他结构。如果我们认为代码需要一些解释，而不是写一个注释，尝试重构以将含义编码到代码本身中。</p><p id="0626" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回想一下你读过的最后一条评论。有用吗？准确吗？可以修改代码来包含这些信息吗？</p><p id="d93d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是有一个例外:如果我们正在编写一个其他人会使用的库，那么按照适当的约定向面向公众的API添加注释对于文档生成可能是有用的。</p><h2 id="0eb8" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">相反，使用异常来表示异常行为</h2><p id="2b74" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果我们想发出异常行为的信号，抛出一个<code class="fe ma mb mc md b">Exception</code>而不是返回一个错误值，原因如下:</p><ul class=""><li id="7ca2" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">异常行为不会被悄悄忽略，相反，它会传播到第一个错误处理程序，这通常是我们想要的</li><li id="daa8" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">调用者不需要“记住”检查错误场景，这意味着更少的错误处理样板文件</li><li id="305b" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">许多Kotlin标准库构造很好地处理了面向异常的信号(例如，<code class="fe ma mb mc md b">Result</code>，<code class="fe ma mb mc md b">Preconditions</code>)</li><li id="27ca" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">Kotlin不像Java那样强制声明/处理检查异常，所以Kotlin中不存在常见的样板文件。</li></ul><p id="2575" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于正常程序行为的信号，不要使用<code class="fe ma mb mc md b">Exceptions</code>。相反，我们有两个选择:</p><ul class=""><li id="f013" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">为了区分流程状态，使用密封的类，它与<code class="fe ma mb mc md b">when</code>结构配合得很好(下面将详细介绍)</li><li id="cfac" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">为了处理预期的失败(例如用户输入验证)，使用<code class="fe ma mb mc md b">null</code>返回值(例如，使用Kotlin的许多<code class="fe ma mb mc md b">toFooOrNull()</code>方法)</li></ul><h2 id="bded" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用require/check验证不应发生的条件</h2><p id="1ed9" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Kotlin有一套前提条件验证函数(在一个叫做<code class="fe ma mb mc md b">Preconditions.kt</code>的文件中)。不使用<code class="fe ma mb mc md b">if</code>条件，而是使用<code class="fe ma mb mc md b">require</code>或<code class="fe ma mb mc md b">check</code>来增加代码的含义并减少冗长。</p><ul class=""><li id="b551" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">如果我们正在检查一个输入或参数。这一扔<code class="fe ma mb mc md b">IllegalArgumentException</code>。</li><li id="b6eb" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ma mb mc md b">check</code>针对其他场景。这抛出了<code class="fe ma mb mc md b">IllegalStateException</code>。</li></ul><p id="d99f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们正在使用一个Kotlin可空对象或一个平台类型，并且不希望它在这一点上为空，那么使用<code class="fe ma mb mc md b">requireNotNull</code>或<code class="fe ma mb mc md b">checkNotNull</code>。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="fc60" class="na ld iq md b be nb nc l nd ne">require(arg.length &lt; 10) {<br/>    "message"<br/>}<br/><br/>val result = checkNotNull(bar(arg)) {<br/>    "message"<br/>}<br/><br/>/////////////// instead of ///////////////<br/><br/>if (arg.length &lt; 10) {<br/>    throw IllegalArgumentException("message")<br/>}<br/><br/>val result = bar(arg)<br/>    ?: throw IllegalStateException("message")</span></pre><h2 id="a45d" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用扩展功能添加含义并启用链接</h2><p id="d278" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果我们有一个需要注释的代码块，这个代码块应该变成一个方法，就像这样(但是继续读下去；还有更多):</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="cf44" class="na ld iq md b be nb nc l nd ne">val user = getUser(id)<br/>validate(user)<br/>activate(user)<br/><br/>private fun validate(user: User) { <br/>   // validate<br/>}<br/><br/>private fun activate(user: User) { <br/>   // activate<br/>}<br/><br/>/////////////// instead of ///////////////<br/><br/>val user = getUser(id)<br/><br/>/*<br/> * Validate user<br/> */<br/>// validate <br/><br/>/*<br/> * Activate user<br/> */<br/>// activate</span></pre><p id="930c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们创建像上面这样的方法时，我们已经封装了一些含义，但我们可以进一步使它更加流畅。流畅代码的很大一部分是设计<a class="ae kc" href="https://www.martinfowler.com/bliki/FluentInterface.html" rel="noopener ugc nofollow" target="_blank">流畅界面</a>，其中很大一部分是将相关操作链接在一起的能力。如果我们控制了<code class="fe ma mb mc md b">User</code>类，我们可以添加<code class="fe ma mb mc md b">validate</code>和<code class="fe ma mb mc md b">activate</code>作为方法，但是如果这两个方法只在这个类中有意义(或者如果我们不拥有<code class="fe ma mb mc md b">User</code>)，那么<a class="ae kc" href="https://kotlinlang.org/docs/reference/extensions.html#extension-functions" rel="noopener ugc nofollow" target="_blank">扩展函数</a>将会帮助我们。</p><p id="d921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其实是<a class="ae kc" href="https://kotlinlang.org/docs/reference/coding-conventions.html#using-extension-functions" rel="noopener ugc nofollow" target="_blank">推荐</a>尽量使用扩展！</p><blockquote class="nf ng nh"><p id="e639" class="kd ke lb kf b kg kh ki kj kk kl km kn ni kp kq kr nj kt ku kv nk kx ky kz la ij bi translated">大量使用扩展函数。每当你有一个主要作用于一个对象的函数时，考虑让它成为一个扩展函数，接受那个对象作为接收者。</p></blockquote><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="1a1f" class="na ld iq md b be nb nc l nd ne">private fun User.validate(): User { <br/>   // validate<br/>   return this<br/>}<br/><br/>private fun User.activate(): User { <br/>   // activate<br/>   return this<br/>}<br/><br/>...<br/><br/>val user = getUser(id)<br/>   .validate()<br/>   .activate()</span></pre><h2 id="cd6f" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">考虑使用或创建中缀函数来减少冗长</h2><p id="47c0" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Kotlin标准库中有许多中缀函数，它们用来减少嵌套括号。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="ec0b" class="na ld iq md b be nb nc l nd ne">val x = mapOf(1 to "a")<br/>val range = 1 until 10<br/>val loop = listOf(...) zip listOf(...)<br/><br/>/////////////// instead of ///////////////<br/><br/>val x = mapOf(1.to("a"))<br/>val range = 1.until(10)<br/>val loop = listOf(...).zip(listOf(...))</span></pre><p id="f89f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建自己的中缀函数，只有当函数满足以下标准时，我才会推荐它:</p><ul class=""><li id="2c43" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">没有副作用</li><li id="0640" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">简单的逻辑</li><li id="30ff" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">简称</li><li id="518e" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">用在可以少用括号的地方</li></ul><p id="2d76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一点很重要，给出了一个使用中缀函数的场景<em class="lb">而不是</em>:由于缺少括号，中缀函数可能不会以可读的方式链接。例如，如果我们在一个链中使用两个函数:</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="a0f8" class="na ld iq md b be nb nc l nd ne">private fun process(arg: String) = // some string<br/>private fun String.foo(x: String) = // some string<br/><br/>val bar = process("a")<br/>   .foo("b")<br/>   .min()</span></pre><p id="6c9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe ma mb mc md b">foo</code>是<code class="fe ma mb mc md b">infix</code>，使用它看起来会很奇怪，因为需要额外的括号来获得预期的行为。在这种情况下，由于它的使用方式，不使它成为中缀是可以的。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="e324" class="na ld iq md b be nb nc l nd ne">val bar = (process("a") foo "b").min()  // bad</span></pre><h2 id="087a" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用范围函数来减少冗长</h2><p id="a5d1" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated"><code class="fe ma mb mc md b">with</code>帮助创建一个与对象相关的逻辑部分。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="30c7" class="na ld iq md b be nb nc l nd ne">...some code...<br/>with(foo.id) {<br/>   LOGGER.info("id is $this")<br/>   doSomething()  // method of id<br/>   doSomethingElse(this)<br/>}<br/>...some code...<br/><br/>/////////////// instead of ///////////////<br/><br/>...some code...<br/>val id = foo.id<br/>LOGGER.info("id is $id")<br/>id.doSomething()<br/>doSomethingElse(id)<br/>...some code...k</span></pre><p id="e01c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc md b">apply</code>与只有setters的对象交互时会产生奇迹。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="f7f5" class="na ld iq md b be nb nc l nd ne">val foo = Foo().apply {<br/>   field1 = 1 <br/>   field2 = "a"<br/>}<br/><br/>/////////////// instead of ///////////////<br/><br/>val foo = Foo()<br/>foo.field1 = 1<br/>foo.field2 = "a"</span></pre><p id="bcfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc md b">also</code>可以让我们重用一个对象来添加额外的效果</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="5f86" class="na ld iq md b be nb nc l nd ne">requireNotNull(foo) {<br/>   "message with ${foo.id}"<br/>      .also { LOGGER.error(it) }<br/>}<br/><br/>/////////////// instead of ///////////////<br/><br/>requireNotNull(foo) {<br/>   val message = "message with ${foo.id}"<br/>   LOGGER.error(message)<br/>   message<br/>}<br/><br/>/////////////// or worse ///////////////<br/><br/>requireNotNull(foo) {<br/>   LOGGER.error("message with ${foo.id}")<br/>   "message with ${foo.id}"<br/>}</span></pre><p id="9c14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我写了一个对<a class="ae kc" href="https://medium.com/dont-code-me-on-that/kotlin-cheatsheet-scope-functions-let-run-apply-also-with-308c8e5533f4" rel="noopener">范围函数</a>的快速引用。</p><h2 id="a100" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">默认情况下省略类型信息</h2><p id="5f70" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Kotlin具有类型推断功能，IDE将类型信息显示为提示，因此我们几乎总是想省略用代码编写它，除非语法要求这样做。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="3284" class="na ld iq md b be nb nc l nd ne">val x = "a"<br/><br/>override fun foo() = 1<br/><br/>/////////////// instead of ///////////////<br/><br/>val x: String = "a"<br/><br/>override fun foo(): Int = 1</span></pre><p id="7e17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，在一些情况下，类型信息会很有用:</p><ul class=""><li id="3ed4" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">当一个函数或字段的返回类型过于复杂而无法一眼确定时，例如<code class="fe ma mb mc md b">Map&lt;Int, Map&lt;String, String&gt;&gt;</code></li><li id="8918" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">返回<a class="ae kc" href="https://kotlinlang.org/docs/reference/coding-conventions.html#platform-types" rel="noopener ugc nofollow" target="_blank">平台类型</a>时。</li></ul><h2 id="a2cb" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">如果函数有1个表达式，则使用表达式语法</h2><p id="1511" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">只要函数由一个表达式组成，不管它有多长，我们都应该优先使用表达式语法。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="4739" class="na ld iq md b be nb nc l nd ne">fun foo(id: Int) = getFoo(id)<br/>   .chain1()<br/>   .chain2()<br/>   .chain3()<br/>   .chain4 {<br/>      // some lambda<br/>   }<br/><br/>/////////////// instead of ///////////////<br/><br/>fun foo(id: Int): Bar {<br/>   return getFoo(id)<br/>      .chain1()<br/>      .chain2()<br/>      .chain3()<br/>      .chain4 {<br/>         // some lambda<br/>      }<br/>}</span></pre><p id="aaae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与范围函数结合使用效果很好。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="47d9" class="na ld iq md b be nb nc l nd ne">fun foo(arg: Int) = Foo().apply {<br/>   field1 = arg<br/>   field2 = "a"<br/>   field3 = true<br/>}<br/><br/>/////////////// instead of ///////////////<br/><br/>fun foo(arg: Int): Foo {<br/>   return Foo().apply {<br/>      field1 = arg<br/>      field2 = "a"<br/>      field3 = true<br/>   }<br/>}</span></pre><p id="748c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例外:当返回类型为<code class="fe ma mb mc md b">Unit</code>时，即使被调用的方法也返回<code class="fe ma mb mc md b">Unit</code>或<code class="fe ma mb mc md b">void</code>，也不要使用表达式语法。这使得一眼就能看出该函数不返回任何内容。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="8685" class="na ld iq md b be nb nc l nd ne">fun foo() {<br/>   barThatReturnsUnitOrVoid()<br/>}<br/><br/>/////////////// instead of ///////////////<br/><br/>fun foo() = barThatReturnsUnitOrVoid()</span></pre><h2 id="c95d" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用typealias或内联类为常见类型添加含义</h2><p id="b19d" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">有些类型是通用的或者是满嘴的(满眼？).我们可以使用<a class="ae kc" href="https://kotlinlang.org/docs/reference/type-aliases.html#type-aliases" rel="noopener ugc nofollow" target="_blank"> typealias </a>或<a class="ae kc" href="https://kotlinlang.org/docs/reference/inline-classes.html" rel="noopener ugc nofollow" target="_blank">内联类</a>来为难以理解的类型添加编码。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="60af" class="na ld iq md b be nb nc l nd ne">typealias CustomerId = Int<br/>typealias PurchaseId = String<br/>typealias StoreName = String<br/>typealias Report = Map&lt;CustomerId, Map&lt;PurchaseId, StoreName&gt;&gt;<br/><br/>fun(report: Report) = // ...<br/><br/>/////////////// instead of ///////////////<br/><br/>fun(report: Map&lt;Int, Map&lt;String, String&gt;&gt;) = // ...</span></pre><p id="d901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内联类是相似的，除了我们声明一个实际的类来包装原始类型。相对于typealias的好处是，<code class="fe ma mb mc md b">CustomerId</code> typealias接受任何<code class="fe ma mb mc md b">Int</code>，而<code class="fe ma mb mc md b">CustomerId</code>内联类将只接受其他<code class="fe ma mb mc md b">CustomerId</code>。</p><h2 id="f69b" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用精度标记来指定数值的精度</h2><p id="b23c" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Kotlin有<a class="ae kc" href="https://kotlinlang.org/docs/reference/basic-types.html#literal-constants" rel="noopener ugc nofollow" target="_blank">精度标签</a>来区分Double/Float和Int/Long。更喜欢用它们来指定类型。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="c5a9" class="na ld iq md b be nb nc l nd ne">val x = 1L<br/>val y = 1.2f<br/><br/>/////////////// instead of ///////////////<br/><br/>val x: Long = 1<br/>val y: Float = 1.2</span></pre><h2 id="3c67" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用下划线对数值进行可视化分组</h2><p id="6f69" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在文字中尽可能使用下划线。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="46b0" class="na ld iq md b be nb nc l nd ne">val x = 1_000_000<br/><br/>/////////////// instead of ///////////////<br/><br/>val x = 1000000</span></pre><h2 id="b7c0" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用字符串模板和原始字符串</h2><p id="29c4" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated"><a class="ae kc" href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates" rel="noopener ugc nofollow" target="_blank">字符串模板</a>(或字符串插值)在大多数情况下优先于串联、<code class="fe ma mb mc md b">String.format</code>或<code class="fe ma mb mc md b">MessageFormat</code>。<a class="ae kc" href="https://kotlinlang.org/docs/reference/basic-types.html#string-literals" rel="noopener ugc nofollow" target="_blank">原始字符串</a>在处理多行文本或含有大量特殊字符的文本时也很有用，否则这些字符需要转义。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="23ff" class="na ld iq md b be nb nc l nd ne">val x = "customer $id bought ${purchases.count()} items"<br/>val y = """He said "I'm tired""""<br/><br/>/////////////// instead of ///////////////<br/><br/>val x = "customer " + id + " bought " + purchases.count() + " items"<br/>val y = "He said \"I'm tired\""</span></pre><h2 id="2a36" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">如果为空，使用Elvis运算符返回</h2><p id="b43e" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">处理可空类型的一个常见场景是，如果需要空值，则返回某个值，在这种情况下，我们可以使用if-null-then-return模式。在这种情况下，elvis操作器很方便。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="6e90" class="na ld iq md b be nb nc l nd ne">val user = getUser() <br/>   ?: return 0<br/><br/>/////////////// instead of ///////////////<br/><br/>val user = getUser()<br/>if (user == null) {<br/>   return 0<br/>}</span></pre><p id="c1af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果<code class="fe ma mb mc md b">user</code>来自方法参数呢？没有<code class="fe ma mb mc md b">getUser()</code>附<code class="fe ma mb mc md b">?:</code>。为了保持一致性，我们仍然更喜欢使用<code class="fe ma mb mc md b">?:</code>而不是<code class="fe ma mb mc md b">if</code>。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="63b6" class="na ld iq md b be nb nc l nd ne">fun foo(user: User?): Int {<br/>   user ?: return 0<br/>   // ...<br/>}<br/><br/>/////////////// instead of ///////////////<br/><br/>fun foo(user: User?): Int {<br/>   if(user == null) {<br/>      return 0<br/>   }<br/>   // ...<br/>}</span></pre><h2 id="f871" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">正确使用流和序列</h2><p id="e12d" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">从Java过来，我们在转换集合的时候可能会习惯性的使用<code class="fe ma mb mc md b">.stream()</code>。如果我们这样做，我们实际上是在使用Java流API。相反，Kotlin将其流方法定义在<code class="fe ma mb mc md b">Iterable</code>上。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="d9f2" class="na ld iq md b be nb nc l nd ne">listOf(1).map { ... }<br/><br/>/////////////// instead of ///////////////<br/><br/>listOf(1).stream().map { ... }.collect(...)</span></pre><p id="1cb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">科特林的“流”方法是热切的，而Java的方法是懒惰的，所以等同于科特林的<code class="fe ma mb mc md b">Sequence</code>方法。对于处理大型集合或多步转换，使用<code class="fe ma mb mc md b">Sequence</code>方法将会带来<a class="ae kc" href="https://blog.kotlin-academy.com/effective-kotlin-use-sequence-for-bigger-collections-with-more-than-one-processing-step-649a15bb4bf" rel="noopener ugc nofollow" target="_blank">更好的性能</a>而不会牺牲太多的可读性。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="80be" class="na ld iq md b be nb nc l nd ne">listOf(1).asSequence()<br/>   .filter { ... }<br/>   .map { ... }<br/>   .maxBy { ... }<br/><br/>/////////////// instead of ///////////////<br/><br/>listOf(1)<br/>   .filter { ... }<br/>   .map { ... }<br/>   .maxBy { ... }</span></pre><h2 id="815d" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用面向方面的模式来附加副作用</h2><p id="a5d9" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我在这篇<a class="ae kc" href="https://medium.com/dont-code-me-on-that/aspect-oriented-programming-in-kotlin-95ff8598913" rel="noopener">文章</a>中阐述了更多，但是总的来说，这种模式让我们无需过多赘述就能添加副作用。举个简单的例子，如果我们有这样一个函数:</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="c725" class="na ld iq md b be nb nc l nd ne">fun getAddress(<br/>   customer: Customer<br/>): String {<br/>   return customer.address<br/>}</span></pre><p id="6a72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用该模式定义一个<code class="fe ma mb mc md b">cachedBy</code>函数并只修改一小部分代码来轻松添加缓存:</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="a418" class="na ld iq md b be nb nc l nd ne">fun getAddress(<br/>   customer: Customer<br/>): String = cachedBy(customer.id) {<br/>   customer.address<br/>}<br/><br/>/////////////// instead of ///////////////<br/><br/>fun getAddress(<br/>   customer: Customer<br/>): String {<br/>   val cachedValue = cache.get(customer.id)<br/>   if (cachedValue != null) {<br/>      return cachedValue<br/>   }<br/>   <br/>   val address = customer.address<br/>   cache.put(customer.id, address)<br/>   return address<br/>}</span></pre><h2 id="1f52" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用密封类来处理流程状态</h2><p id="4384" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我在这篇<a class="ae kc" href="https://medium.com/dont-code-me-on-that/handle-process-results-with-kotlin-sealed-classes-d9a9375b8e09" rel="noopener">文章</a>中阐述了更多，但是一般来说，密封类让我们减少了评估状态代码的冗长性，并且避免了维护额外的状态枚举。</p><h2 id="8acf" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">测试方法名称使用反斜线</h2><p id="3a0b" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果我们正在编写冗长的方法测试名称，使用反勾号使其更容易阅读通常是有用的。这将让我们使用空格和一些特殊字符。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="5141" class="na ld iq md b be nb nc l nd ne">fun `test foo - when foo increases by 3% - returns true`() { ... }<br/><br/>/////////////// instead of ///////////////<br/><br/>fun testFoo_whenFooIncreasesBy3Percent_returnsTrue() { ... }</span></pre><h2 id="99c8" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">更喜欢广度优先而不是深度优先的代码</h2><p id="00fc" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated"><em class="lb">这不是Kotlin特有的，但我们将探索Kotlin如何使它变得更容易。</em></p><p id="34db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">深度代码是有许多“层”的代码，或者对unfamiliar^方法的调用。这不是一个技术问题，而是一个认知问题。一般来说，我们的<a class="ae kc" href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two" rel="noopener ugc nofollow" target="_blank">工作记忆</a>有限，在阅读代码时，每次调用另一个不熟悉的方法都会给工作记忆增加更多的上下文，增加认知负荷。</p><p id="e30b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好用一个例子来解释。比方说我们有这些<code class="fe ma mb mc md b">fun</code>:</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="ac11" class="na ld iq md b be nb nc l nd ne">fun foo(): Foo {<br/>  val foo = getFoo()<br/>  return foo1(foo)<br/>}<br/><br/>private fun foo1(foo: Foo): Foo {<br/>   ...something with foo...<br/>   return foo2(foo)<br/>}<br/><br/>private fun foo2(foo: Foo): Foo {<br/>   ...something with foo...<br/>   return foo3(foo)<br/>}<br/><br/>private fun foo3(foo: Foo): Foo {<br/>   ...something with foo...<br/>   return foo<br/>}</span></pre><p id="3298" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们读取对<code class="fe ma mb mc md b">foo()</code>的调用时，我们看到对<code class="fe ma mb mc md b">foo1()</code>的调用。现在我们把<code class="fe ma mb mc md b">foo()</code>放到工作内存“栈”的后面，读取<code class="fe ma mb mc md b">foo1()</code>。如此往复，直到我们到达<code class="fe ma mb mc md b">foo3()</code>，然后我们开始往回走<code class="fe ma mb mc md b">foo()</code>。这意味着为了理解<code class="fe ma mb mc md b">foo()</code>，我们需要在我们的工作记忆中添加许多“条目”，每个条目都是被调用函数的上下文。</p><p id="7d33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将其与同等宽度的产品进行比较:</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="c7df" class="na ld iq md b be nb nc l nd ne">fun foo(): Foo = <br/>   getFoo()<br/>      .foo1()<br/>      .foo2()<br/>      .foo3()<br/><br/>private fun Foo.foo1(): Int {<br/>  ...something with this (which is foo)...<br/>   return this<br/>}<br/><br/>private fun Foo.foo2(): Foo {<br/>   ...something with this (which is foo)...<br/>   return this<br/>}<br/><br/>private fun Foo.foo3(): Foo {<br/>   ...something with this (which is foo)...<br/>   return this<br/>}</span></pre><p id="82bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用第二种方法，我们只需要在我们的“堆栈”中保存一个上下文，即<code class="fe ma mb mc md b">foo()</code>的上下文。每次另一个<code class="fe ma mb mc md b">fun</code>被调用时，它都返回到相同的上下文，所以我们不必“深入”了。</p><p id="2abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为另一个例子，这一行有许多嵌套层:</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="b07e" class="na ld iq md b be nb nc l nd ne">return Foo(<br/>   bar.doSomething(<br/>      getId(SomeEnum.ENUM_1),<br/>      "string"<br/>   )<br/>)</span></pre><p id="0c00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于一些扩展函数和作用域函数，这可以是“非嵌套的”,如下所示:</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="1f04" class="na ld iq md b be nb nc l nd ne">return SomeEnum.ENUM_1<br/>   .getId()<br/>   .let {<br/>      bar.doSomething(it, "string")<br/>   }.let {<br/>      Foo(it)<br/>   }</span></pre><p id="c62b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些例子被夸大了，这个经验法则并不适用于所有的场景。然而，在大多数情况下，广度优先的方法更容易阅读。这也可以在Java中实现，但是Kotlin使用了一些构造，比如扩展函数和作用域函数，使得这变得更加简单。</p><p id="eaac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，Kotlin提供了一些有助于“取消嵌套”的语法特性。当处理有许多层的代码时，考虑用构造来减少层数，并选择对我们的读者来说更可读的方法。</p><p id="eaf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> ^A关于“不熟悉的”方法的注释:这些方法不期望读者一眼就能认出来，因此它排除了大多数“内置”方法，如</em> <code class="fe ma mb mc md b"><em class="lb">String.split</em></code> <em class="lb">以及我们代码中常用的方法，这些方法可能很复杂，但读者可以立即理解。</em></p><h2 id="d969" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">隔离不流畅的代码</h2><p id="0eea" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">有时，无论我们如何努力，一段代码看起来仍然不可读，因为:</p><ul class=""><li id="ec3c" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">它有笨拙的操作或者使用笨拙的API，上面的建议都不能驯服它</li><li id="7fa9" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">有一些性能考虑决定了代码的结构</li><li id="019f" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">我们只是目前没有时间投资制作它</li></ul><p id="38c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时最好的做法是隔离代码，这样代码库的其他部分就不必直接与之交互。不管我们是使用一个独立的类还是一个单独的方法，都要花一些时间来精心制作可读且有意义的方法签名。</p><p id="e243" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">隔离代码通常还会使代码更具可测试性，这在底层代码可读性较差时至关重要，因为它是预期行为的活文档。</p><pre class="ms mt mu mv gt mw md mx bn my mz bi"><span id="2395" class="na ld iq md b be nb nc l nd ne">... some fluent code ...<br/>val fee = activateCustomerAndCalculateFee(<br/>   userId,<br/>   FeeType.SIMPLE,<br/>   DEFAULT_CUSTOMER_TYPE<br/>)<br/>... other fluent code ...<br/><br/>fun calculateFeeForCustomer(<br/>   userId: String,<br/>   feeType: FeeType,<br/>   customerType: Int<br/>): Double {<br/>   ... some complicated or not-so-readable code<br/>}</span></pre></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="fa1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总的来说，如果我们在编写代码的多种方法之间进退两难，我会使用这些经验法则来做出选择。选择以下选项:</p><ul class=""><li id="7ed4" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">让代码的意图变得清晰。未来——你会感谢你自己！</li><li id="9d02" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">优化略读。选择代码结构，使读者容易浏览到代码中的正确位置。</li><li id="0f74" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">不太冗长。写得越差，越不容易分心。</li></ul><p id="d82d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你已经到达终点了！这是一篇活的文章，随着我遇到更多的“风格选择”，它将会成长，所以请不时回来查看更新！</p><h2 id="9938" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">参考</h2><ul class=""><li id="ba2c" class="me mf iq kf b kg lv kk lw ko ns ks nt kw nu la mj mk ml mm bi translated"><a class="ae kc" href="https://tomharrisonjr.com/make-it-work-make-it-beautiful-make-it-fast-three-realities-df7255a8fa09" rel="noopener ugc nofollow" target="_blank">让它工作，让它美丽，让它快速</a></li><li id="6dbe" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">干净的代码:敏捷软件工艺手册</li></ul></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="7e08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">你可能喜欢的其他故事</strong></p><ul class=""><li id="db96" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/double-equality-in-kotlin-f99392cba0e4">探索科特林的双重平等</a></li><li id="e2c9" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/opinion-software-estimates-are-a-two-sided-relationship-6247108ace41">软件评估是一种双边关系</a></li><li id="aa39" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae kc" href="/dont-code-me-on-that/use-java-nullability-annotations-to-facilitate-conversion-to-kotlin-7196f0cee9e9" rel="noopener ugc nofollow" target="_blank">使用Java可空性注释来简化到Kotlin的转换</a></li><li id="88cf" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">我也写关于<a class="ae kc" href="https://medium.com/dont-code-me-on-that/tryhackme-writeups-and-ctf-logs-catalogue-f9814cdb698f" rel="noopener"> TryHackMe房间</a> (Pentesting)！</li></ul></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><div class="ms mt mu mv gt nv"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">编写面试问题</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">技术开发</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jw nv"/></div></div></a></div></div></div>    
</body>
</html>