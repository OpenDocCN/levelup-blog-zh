<html>
<head>
<title>Orchestrate Your Go Routines Using Channels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用频道编排您的围棋套路</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/orchestrate-your-go-routines-using-channels-c4b9f246cc4b?source=collection_archive---------10-----------------------#2020-12-02">https://levelup.gitconnected.com/orchestrate-your-go-routines-using-channels-c4b9f246cc4b?source=collection_archive---------10-----------------------#2020-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b837" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用通道在Go例程之间交流和传递信息来提升您的GoLang并发技能！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4aaa4784fa1498aeadb83ea98534750d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yiclBfBwbxUySsHS.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自<a class="ae le" href="http://www.cencultu.com.ar/evento/cierre-temporada-la-sinfonica-santafesina/" rel="noopener ugc nofollow" target="_blank">中央文化省</a></figcaption></figure><p id="2579" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi lf translated">Go 之所以出名，很大程度上是因为它干净高效地处理了并发性。我们可以使用Go例程在主程序的后台运行多个线程，从而大大提高效率。但是，我们如何在我们的围棋程序之间进行通信，或者在它们之间共享资源呢？我们准备好惊讶于Go中简单而强大的通道特性。</p><p id="962d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里没有历史课，让我们直接进入代码！</p><h2 id="a710" class="lo lp it bd lq lr ls dn lt lu lv dp lw kb lx ly lz kf ma mb mc kj md me mf mg bi translated">一个简单的渠道示例:</h2><p id="ea98" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">虽然通道极大地简化了并发编程，但是我们仍然需要小心我们如何建立对它们的理解。在下面的程序中，我们只执行四个操作。</p><p id="c6f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步是在第7行创建我们的通道。我们将该通道的输入定义为类型<code class="fe mm mn mo mp b">string</code>。接下来，我们在第9行到第11行创建一个匿名函数，我们获取字符串<code class="fe mm mn mo mp b">"ping"</code>并将它发送到通道 <code class="fe mm mn mo mp b">messages</code>。</p><blockquote class="mr ms mt"><p id="7ab7" class="jq jr mq js b jt ju jv jw jx jy jz ka mu kc kd ke mv kg kh ki mw kk kl km kn im bi translated">当使用通道时，您可以认为<code class="fe mm mn mo mp b">&lt;-</code>操作是根据箭头的方向从通道向或<strong class="js iu">发送信息。</strong></p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b04d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三步是从消息通道<strong class="js iu">向</strong>msg变量请求存储的字符串<code class="fe mm mn mo mp b">"ping"</code> <strong class="js iu">。最后一步是将消息打印到控制台。</strong></p><h2 id="539a" class="lo lp it bd lq lr ls dn lt lu lv dp lw kb lx ly lz kf ma mb mc kj md me mf mg bi translated">通道将等待发送信息:</h2><p id="9b57" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">例如，go中的通道被<em class="mq">阻塞</em>——假设我们同时执行两个Go例程。如果一个go程序通过通道向另一个请求信息，它将<em class="mq">阻止</em>执行，直到另一个go程序将信息传递到连接通道。</p><p id="2cdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过下面的代码，我们可以看到通道是如何阻塞的。使用我们在上一篇文章中学到的内容，<code class="fe mm mn mo mp b">sync.WaitGroup</code>将确保我们的go例程在退出主程序线程之前完成。</p><p id="be43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们在第13行初始化一个新的通道<code class="fe mm mn mo mp b">messages</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bc56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，在第一个匿名函数中，我们休眠一秒钟，然后在退出之前将字符串<code class="fe mm mn mo mp b">"Echo"</code> <strong class="js iu">发送到<code class="fe mm mn mo mp b">messages</code>通道</strong>。在下面第26行的匿名函数中，我们请求从<code class="fe mm mn mo mp b">messages</code>通道到<code class="fe mm mn mo mp b">msg</code>变量的输入<strong class="js iu">。这是一个<em class="mq">阻塞</em>操作，此功能不会继续，直到我们从<code class="fe mm mn mo mp b">messages</code>获得输出。</strong></p><p id="fd90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们运行上面的程序，我们将得到以下输出:</p><pre class="kp kq kr ks gt mz mp na nb aw nc bi"><span id="3826" class="lo lp it mp b gy nd ne l nf ng">Starting second anonymous function...<br/>Starting first anonymous function...<br/>Echo!<br/>Exiting first anonymous function<br/>I hear an Echo!<br/>Exiting second anonymous function</span></pre><p id="bf8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，注意我们的go例程是如何<em class="mq">不确定的</em>。您无法知道这些功能将按什么顺序开始或停止，但您知道当等待发送信息时，通道将会阻塞。在第一个<code class="fe mm mn mo mp b">Echo!</code>和结果打印语句<code class="fe mm mn mo mp b">I hear an Echo!</code>之间有第二个延迟，因为接收通道等待输出。</p><h2 id="4fcc" class="lo lp it bd lq lr ls dn lt lu lv dp lw kb lx ly lz kf ma mb mc kj md me mf mg bi translated">防止渠道出现死锁:</h2><p id="d109" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">如果通道在等待资源时阻塞，如果资源从未被发送会发生什么？这种情况会导致死锁，Go只会在运行时检测到死锁，而不会在编译时检测到死锁。让我们看一个例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b235" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在作为go例程执行的第一个匿名函数中，无论<code class="fe mm mn mo mp b">i</code>的值是什么，我们都向消息通道添加三次。当我们跳出这个循环时，我们关闭通道来通知我们已经完成了附加，以防止死锁。</p><p id="192b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第二个go例程中，我们从<code class="fe mm mn mo mp b">messages</code>通道获得<code class="fe mm mn mo mp b">msg</code>和<code class="fe mm mn mo mp b">open</code>。<code class="fe mm mn mo mp b">open</code>参数是一个布尔值，表示通道是否关闭。如果通道没有打开<code class="fe mm mn mo mp b">!open</code>，那么我们使用<code class="fe mm mn mo mp b">wg.Done()</code>跳出循环并退出我们的go程序。简单，但是有效！</p><p id="5fd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还可以利用Go的一些语法来简化第16行的第二个for循环。然后你甚至不需要检查通道是否关闭，Go会为你处理这些。</p><pre class="kp kq kr ks gt mz mp na nb aw nc bi"><span id="c791" class="lo lp it mp b gy nd ne l nf ng">for msg := range messages {<br/>    fmt.Println(msg)<br/>}</span></pre><p id="34a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以将<strong class="js iu">容量添加到您的频道</strong>中，如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="febd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使我们在第8行创建了一个容量为2的通道，我们也能够发送和接收总共三个字符串，因为通道像队列一样工作。只要频道中的项目不超过2个，您就在容量限制范围内，不会收到错误。</p><p id="c6d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，如果您的通道在时间限制上相互阻塞，您可以在Go中使用<code class="fe mm mn mo mp b">select</code>表达式来执行任何准备好的通道。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b4ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们有两个通道，它们在两个go例程中被无限追加。第一个go例程每秒追加到通道<code class="fe mm mn mo mp b">c1</code>中，而第二个go例程每两秒追加到通道<code class="fe mm mn mo mp b">c2</code>中。如果您只是试图从这些通道打印，<code class="fe mm mn mo mp b">c2</code>通道会阻塞，您将每两秒钟获得两个输出。</p><p id="5b73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，使用<code class="fe mm mn mo mp b">select</code>语句将不断地检查一个准备从中提取信息的通道。执行此语句将允许来自通道的信息流不受任何阻塞。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="4aed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通道提供了一种简单而强大的方式在你的围棋程序之间进行交流，甚至只是以一种更有意义的方式控制信息流。考虑死锁的风险是很重要的，因为它在Go的编译时不会被识别，但是跟踪一个通道何时应该打开或者增加通道的容量是一个很好的开始。</p><p id="1abd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你在这篇文章中学到了一些新东西。如果你看到了一些你想要进一步解释的东西，我鼓励你在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>