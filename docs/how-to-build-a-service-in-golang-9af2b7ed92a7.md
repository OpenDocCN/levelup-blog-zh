# 如何在 Golang 中构建服务

> 原文：<https://levelup.gitconnected.com/how-to-build-a-service-in-golang-9af2b7ed92a7>

![](img/843548e42abf725393b79ba689dcce25.png)

当我们开始研究 Go 时，我们发现了许多如何构建新的 web 服务器或完成特定任务的例子，然而，找到一种可以启动所有过程、保持并优雅地完成所有事情的服务结构可能是一种挑战。本文的目的是构建一个服务的基本结构。[完整代码可从 github](https://github.com/gbeletti/service-golang) 获得。

# 什么是服务？

在计算系统中，服务是执行特定任务以响应事件或请求的程序，例如:

*   HTTP 请求
*   来自消息代理的消息或流
*   时间事件(每小时、每 5 分钟等)

服务被设计成永远运行，就像所有好的东西最终都会消亡一样，它必须准备好在时机到来时稳健而明智地停止。

> 在服务停止之前，必须完成所有任务，关闭所有连接，并且没有运行任何 goroutines。

# 构建 web 服务器

例如，让我们创建一个响应 HTTP 请求的服务。首先，我们创建一个包含启动和关闭 web 服务器功能的包。

注意`Start()`函数创建了一个 goroutine 来接收和处理外部请求。这个包负责创建和完成这个 goroutine。

同时,`Shutdown()`函数异步且优雅地完成服务器，允许服务在等待所有请求完成时停止其他进程。

# 启动服务

现在我们可以回到最初的文件，例如`main.go`，我们从创建一个`start()`函数开始。在这里，我们必须启动服务正常工作所需的一切，比如打开数据库连接、监听来自消息代理的流事件、构建缓存等。

请注意，这里创建了一个带有 cancel 的上下文。目的是在这个函数中启动的所有进程共享相同的上下文，所以当函数`cancel()`被调用时，每个人都会得到通知，可以停止他们正在做的事情。此外，任何函数都不应该阻塞线程，每个内部进程都应该对自己的线程负责，就像上面的 web 服务器一样。

# 等待不可避免的事情

既然服务已经启动，我们不能让主线程死亡。我们可以创建一个频道，等待一个永远不会到来的消息。

上述代码将无限期运行，直到操作系统终止该进程。这种突然死亡对系统来说是危险的，可能会导致几个问题，比如在数据库上生成不一致的数据，或者保持与消息代理的连接打开。这就产生了一个不稳定的系统，很难找到错误。

我们必须为系统关闭做好准备，优雅而稳健地停止所有处理。所以让我们创建一个包`servicemanager`并创建一个函数`WaitShutdown`。

`signal.Notify`功能会将操作系统的所有结束信号发送到`sigc`通道。现在我们可以等待`s := <-sigc`的信号来阻塞主线程。

我们的`main.go`现在启动一切，等待操作系统说该关机了。

# 正在关闭服务

既然我们知道服务何时会终止，我们可以创建一个`shutdown()`函数来停止所有的内部进程。

使用命令`<-doneHTTP`，主线程将在终止服务之前等待所有请求完成。这里的问题是，操作系统不会永远等待，过一会儿就会终止一个进程，突然停止一切。因此，最好等待一段时间，如果超时就强制关机。

这个概念在服务中很常见，所以我们可以在我们的`servicemanager`包中创建一个新函数。

我们的`shutdown()`现在已经完成:

`cancel()`允许共享上下文的内部进程完成它们的杂务，警告它们服务正在关闭。同时，创建一个新的超时上下文来等待进程停止或时间用完。

我们的`main()`功能非常简单和简短:

# 结论

创建一个新的服务可能看起来很简单，但是理解它可能非常复杂，需要对并发性和并行性有很好的了解。这个例子的完整代码可以在 [github](https://github.com/gbeletti/service-golang) 找到。

希望这篇教程有用。如果您有建议或疑问，请在下面的部分留下评论。