# 支持多个发布者/订阅者客户端的消息队列

> 原文：<https://levelup.gitconnected.com/message-queue-supporting-multiple-publisher-subscriber-clients-7d72d2bd521c>

![](img/f1c96a7112be2ef0f8329c3d57bf9850.png)

来自 MSFT 的共享消息队列描述(参考文献 1)，图 1

消息队列是构建跨不同进程空间运行的微服务应用系统的一个非常重要的工具。它在任何两个支持异步处理的实体之间提供了一个非阻塞的通信方案，从而增加了并发性。作为我最近参与的一个物联网边缘项目的一部分，需要丰富由多个来源产生的数据。需要不同的浓缩方法，每一种方法都是通过特定但不同的过程完成的。本文描述了使用多输入多输出(MIMO)消息队列的问题场景，并详细概述了在多个发布者(或生产者)和订阅者(或消费者)之间多路传输消息的实现。

# 物联网边缘设备的数据丰富

随着物联网成为主流，产生数据的设备数量增加，大量处理预计将在“边缘”完成。这种想法导致了 Linux 基金会边缘联盟([https://www.lfedge.org/projects/](https://www.lfedge.org/projects/))的成立，该联盟至少有 9 个项目专注于物联网边缘。此外，边缘的物联网设备执行数据的提取和转换，这些数据被整合并可用于物联网设备层级中下一个更高软件层的处理。这种现象导致物联网边缘软件相当复杂，并收集数据和丰富数据。

![](img/a1ecd4c50b5d7d60ea31f5cca092a7f8.png)

来自 IBM 的物联网边缘设备参考架构(参考文献 2)，图 2

考虑图 2 所示的 IBM 通用边缘设备架构，设备中通常有多个传感器和致动器，它们是数据的发布者(也称为生产者)。这些数据正被“边缘分析服务”、“人工智能服务”、“边缘应用”等用户消费。这个数字可以按照生产者和消费者进行简化和可视化，如下图 3 所示。

![](img/f36c0f80a9481f6b09424de8657b60ce.png)

传感器作为发布者，功能模块作为订阅者，图 3

在这里，所有三个功能模块，如分析、人工智能/人工智能和应用程序都需要数据。数据可以形成单个激光器或被监控的任何其他组件。图 3 是一个简化图，因为物联网边缘设备可能会收集数百个传感器数据。这里需要注意的重要一点是，每个功能模块都需要来自每个生产者的数据，并且每个生产者都丰富了收集到的特定于该模块的数据。这样生成的数据可以被另一个模块重用，或者存储在数据库中以备将来使用。单个健壮的消息队列是最佳的，并且避免了 n×m(发布者×订阅者)连接的需要。了解了需求或要解决的问题后，在下一节中，让我们看看可用的工具和选项。

# 物联网边缘设备的消息队列选项

有许多开源消息队列(又名代理)，如 Apache Kafka、Apache Pulsar、Rabbit MQ 等，这些都是软件开发人员可以使用的工具。此外，云基础设施供应商提供消息队列实现，其中一些流行的是 AWS 的 SQS 和 Google Cloud Pub/Sub。Kafka、Pulsar 和 Rabbit-MQ 通常用于分布式系统设置中，其中生产者和消费者自己在大规模的微服务实现中实现。此外，消息队列服务本身可以扩展到非常高的数据速率，并作为微服务来实现。这些服务提供主题/分区和其他方案，并由像 zookeeper 这样的配置维护服务管理。在单节点设置的物联网边缘设备处不需要这种重型消息队列。此外，云服务也是这一特定物联网边缘应用的延伸。

可以在这种情况下使用的一个可能的开源实现是零消息队列([https://zeromq.org/](https://zeromq.org/))。MQTT(【https://mqtt.org/】T2)标准也是物联网环境中非常流行的消息队列协议，可以考虑用于上一节描述的用例。ZMQ [REF-3]是物联网边缘应用的一个好选择。然而，在本文中，我们将讨论一个使用链表的简单消息队列实现。Python 和 Go 中的示例框架实现提供了注释。在 Python 和 Go 中，分别使用 asyncio/await 和 goroutines 来开发并发性。

# 使用链表的消息队列

消息队列数据结构应该支持通过多个发布者(也称为生产者)接收多个输入，并且能够在许多订阅者(也称为消费者)连接到它时将生成的消息提供给多个输出。每个生成的消息都应该提供给在消息队列实体中注册的每个消费者。来自特定发布者的消息的顺序应该在所有消费者之间进行维护。

![](img/fe6239ebfb9a81da86e83ffee3c8318d.png)

使用链表实现的消息队列，图 4

如图 4 所示，消息队列使用一个带有添加指针、移除指针和每个消费者最后消费指针的单链表来实现。消息队列使用保持时间周期和垃圾收集器时间频率进行操作。如果在场的所有消费者都已消费了该消息，则已超过保留期的每条消息都有资格被移除。在垃圾收集器时间段的定期间隔，消息被清除。使用添加指针的每个发布者/生产者添加消息，以便维持关于生产者的顺序。每个订户/消费者可以独立地操作和被调度，并且可以消费消息。调度一个单独的垃圾收集器例程，该例程根据订阅者/使用者进程的保留时间和消耗来清理消息。

所描述的消息队列可以基于物联网边缘系统支持的编程语言、平台、操作系统、虚拟化和容器化特征以多种方式实现。本文介绍了两种方法，第一种使用基于 Python3 的 asyncio/await 模型，第二种使用 go 编程语言提供的 Go 例程和通道。

# 使用 Python 的 MIMO 消息队列

实现上一节描述的策略的一个可能的方法是使用一个通用的消息结构，它可以保存在一个单链表中。生产者可以添加消息，消费者可以删除消息。由于有多个生产者和消费者，为了使其并发，asyncio 与适当的锁一起使用。此外，每个消费者可能以不同的频率消费消息，因此需要维护每个消费者的跟踪器。所有这些都可以在 MessageQueue 类中捕获，该类可以提供给消费者和生产者。定义的通用接口可用于发送和接收消息。这里提供了一个示例实现，在同一个 git 存储库中还提供了一个使用示例。参考文献[5]有更多的细节。

# 使用 Go 的 MIMO 消息队列

在 Go 中，消息队列是使用容器/列表和通道实现的。并发是通过 go 例程实现的。消息节点结构和队列实现在这里。参考文献[6]有更详细的内容。

# 结论

使用上述技术可以实现简单的多输入多输出队列，该技术重量轻，并且可以用在具有非常小的资源占用面积的系统中。然而，我会推荐使用 ZMQ，因为可能会有新的需求和可伸缩性需求出现在任何小规模但快速增长的软件项目中。

# 参考

1.  [REF-1]异步消息传递初级读本[https://docs . Microsoft . com/en-us/previous-versions/MSP-n-p/dn 589781(v = pandp . 10)#使用消息队列发送和接收消息](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589781(v=pandp.10)#sending-and-receiving-messages-by-using-a-message-queue)
2.  物联网边缘设备参考架构【https://www.ibm.com/cloud/blog/architecting-at-the-edge 
3.  使用 Python ZeroMQ 的分布式任务[https://better programming . pub/create-zero-point-failure-Distributed-Tasks-with-Python-and-zero MQ-e2a 20941d 85b](https://betterprogramming.pub/create-zero-point-failure-distributed-tasks-with-python-and-zeromq-e2a20941d85b)
4.  ZMQ[https://zeromq.org/](https://zeromq.org/)
5.  https://github.com/nbasker/tools/tree/master/pymsgmuxer
6.  https://github.com/nbasker/tools/tree/master/gomsgmuxer