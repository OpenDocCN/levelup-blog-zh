<html>
<head>
<title>Design Patterns: Memento</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:纪念品</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-memento-3cfe8351ae6a?source=collection_archive---------7-----------------------#2022-03-07">https://levelup.gitconnected.com/design-patterns-memento-3cfe8351ae6a?source=collection_archive---------7-----------------------#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a2df4c0464b92e1c82957e6da3df8a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mSWMeY55p-ZVix2kls6NA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">纪念品设计模式。图片由<a class="ae kc" href="https://medium.com/@aaron.dezoysa" rel="noopener">作者</a>经由【Canva.com】T4</figcaption></figure><p id="2e78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">memento设计模式为我们提供了非常有用的功能，可以在需要时恢复到对象的先前状态。它由三个不同的角色组成，必须创建这三个角色才能正常工作。这三个角色是:</p><ol class=""><li id="6e39" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">Originator-</strong>Originator是将保存其状态以便我们稍后恢复的对象。</li><li id="3c20" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">看守- </strong>当需要这些动作时，该对象将保存并恢复发起者的状态。</li><li id="d836" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">Memento-</strong>Memento是看护者用来存储发起者状态的对象。当保存纪念品时，发起者将把他们的状态写入该纪念品，并且当状态被恢复时，从该纪念品中读取。</li></ol><h1 id="594d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">实现Memento设计模式</h1><p id="a1c6" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">假设我们有一个音乐应用程序，我们开始一首接一首地听歌。在某些时候，我们会听到一首美妙的歌曲，你觉得你需要再听一遍，因为它实在是太棒了！您无需再次搜索歌曲，而是单击“上一首曲目”按钮。为了做到这一点，我们将使用memento设计模式来实现程序，以便我们可以返回并再次播放那首歌曲。</p><p id="4ebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先让我们创建一个名为“NowPlaying”的类，它将承担本例中发起者的角色。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="17c2" class="nb lq iq mx b gy nc nd l ne nf">public class NowPlaying {</span><span id="2106" class="nb lq iq mx b gy ng nd l ne nf">private String currentSong;</span><span id="63a7" class="nb lq iq mx b gy ng nd l ne nf">public void play(String song) {<br/>      this.currentSong = song;<br/>   }</span><span id="6ef9" class="nb lq iq mx b gy ng nd l ne nf">private String getCurrentSong() {<br/>      return currentSong;<br/>   }</span><span id="ac90" class="nb lq iq mx b gy ng nd l ne nf">@Override<br/>   public String toString() {<br/>      return "Now playing: " + currentSong;<br/>   }</span><span id="6aca" class="nb lq iq mx b gy ng nd l ne nf">}</span></pre><p id="d87e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经准备好了，我们需要创建一个类作为纪念品。我们可以称之为‘now playing memento ’,我将它实现为一个内部类，这样就可以通过‘now playing’类来访问它。“NowPlaying”类现在看起来像这样:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5df7" class="nb lq iq mx b gy nc nd l ne nf">public class NowPlaying {</span><span id="d926" class="nb lq iq mx b gy ng nd l ne nf">   private String currentSong;</span><span id="a874" class="nb lq iq mx b gy ng nd l ne nf">   public void play(String song) {<br/>      this.currentSong = song;<br/>   }</span><span id="1c0a" class="nb lq iq mx b gy ng nd l ne nf">   private String getCurrentSong() {<br/>      return currentSong;<br/>   }</span><span id="2b7d" class="nb lq iq mx b gy ng nd l ne nf"> <strong class="mx ir">  public NowPlayingMemento save() {<br/>      return new NowPlayingMemento(getCurrentSong());<br/>   }</strong></span><span id="da26" class="nb lq iq mx b gy ng nd l ne nf"><strong class="mx ir">   public void previous(NowPlayingMemento nowPlayingMemento) {<br/>      this.currentSong = nowPlayingMemento.getSong();<br/>   }</strong></span><span id="f06b" class="nb lq iq mx b gy ng nd l ne nf">   @Override<br/>   public String toString() {<br/>      return "Now playing: " + currentSong;<br/>   }</span><span id="aa2d" class="nb lq iq mx b gy ng nd l ne nf">   <strong class="mx ir">static class NowPlayingMemento {</strong></span><span id="00e6" class="nb lq iq mx b gy ng nd l ne nf"><strong class="mx ir">      private String song;</strong></span><span id="74e8" class="nb lq iq mx b gy ng nd l ne nf"><strong class="mx ir">      public NowPlayingMemento(String song) {<br/>         this.song = song;<br/>      }</strong></span><span id="4fd1" class="nb lq iq mx b gy ng nd l ne nf"><strong class="mx ir">      private String getSong() {<br/>         return song;<br/>      }</strong></span><span id="34fd" class="nb lq iq mx b gy ng nd l ne nf"><strong class="mx ir">   }</strong></span><span id="32dd" class="nb lq iq mx b gy ng nd l ne nf">}</span></pre><p id="c8f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我强调了我添加的代码行，以便于理解。</p><p id="ef53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候创建这个类了，它将作为这个例子的看管者。我们将创建一个名为“PlayedHistory”的类，它将有一个堆栈来存储“NowPlayingMemento”的实例，用于逐个移动到以前播放的歌曲。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f728" class="nb lq iq mx b gy nc nd l ne nf">import java.util.Stack;</span><span id="874b" class="nb lq iq mx b gy ng nd l ne nf">public class PlayedHistory {</span><span id="fcb2" class="nb lq iq mx b gy ng nd l ne nf">   Stack&lt;NowPlaying.NowPlayingMemento&gt; history = new Stack&lt;&gt;();</span><span id="4ef9" class="nb lq iq mx b gy ng nd l ne nf">   public void save(NowPlaying nowPlaying) {<br/>      history.push(nowPlaying.save());<br/>   }</span><span id="6f4c" class="nb lq iq mx b gy ng nd l ne nf">   public void previous(NowPlaying nowPlaying) {<br/>      if(!history.isEmpty()) {<br/>         nowPlaying.previous(history.pop());<br/>      } else {<br/>         System.out.println("End of played history.");<br/>      }<br/>   }</span><span id="6db0" class="nb lq iq mx b gy ng nd l ne nf">}</span></pre><p id="2339" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在弹出最后一首保存的歌曲之前，我们使用了一个if条件来检查堆栈是否为空。现在让我们创建一个类来看看这个音乐播放器的运行情况。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b2ce" class="nb lq iq mx b gy nc nd l ne nf">public class Application {</span><span id="c449" class="nb lq iq mx b gy ng nd l ne nf">   public static void main(String[] args) {</span><span id="3776" class="nb lq iq mx b gy ng nd l ne nf">      PlayedHistory history = new PlayedHistory();</span><span id="793e" class="nb lq iq mx b gy ng nd l ne nf">      NowPlaying nowPlaying = new NowPlaying();</span><span id="23a2" class="nb lq iq mx b gy ng nd l ne nf">      nowPlaying.play("Sweet Child o' Mine");<br/>      history.save(nowPlaying);<br/>      System.out.println(nowPlaying);</span><span id="fe1b" class="nb lq iq mx b gy ng nd l ne nf">      nowPlaying.play("Back In Black");<br/>      history.save(nowPlaying);<br/>      System.out.println(nowPlaying);</span><span id="859a" class="nb lq iq mx b gy ng nd l ne nf">      nowPlaying.play("Disenchanted");<br/>      history.save(nowPlaying);<br/>      System.out.println(nowPlaying);</span><span id="b2a1" class="nb lq iq mx b gy ng nd l ne nf">      nowPlaying.play("Say Amen");<br/>      history.save(nowPlaying);<br/>      System.out.println(nowPlaying);</span><span id="0d37" class="nb lq iq mx b gy ng nd l ne nf">      nowPlaying.play("House of Wolves");<br/>      history.save(nowPlaying);<br/>      System.out.println(nowPlaying);</span><span id="8ca1" class="nb lq iq mx b gy ng nd l ne nf">      // Going back to previous songs<br/>      history.previous(nowPlaying);<br/>      System.out.println(nowPlaying);</span><span id="775b" class="nb lq iq mx b gy ng nd l ne nf">      history.previous(nowPlaying);<br/>      System.out.println(nowPlaying);</span><span id="0d28" class="nb lq iq mx b gy ng nd l ne nf">      history.previous(nowPlaying);<br/>      System.out.println(nowPlaying);</span><span id="d04a" class="nb lq iq mx b gy ng nd l ne nf">   }</span><span id="f7e1" class="nb lq iq mx b gy ng nd l ne nf">}</span></pre><p id="2a46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试应用程序，我们为“PlayedHistory”类和“NowPlaying”类各创建了一个实例。在每次调用<code class="fe nh ni nj mx b">play()</code>方法后，我们调用<code class="fe nh ni nj mx b">history.save()</code>将当前歌曲的纪念品保存到堆栈中。一旦我们播放完所有的歌曲，我们就一首接一首地回到之前播放的歌曲，并得到以下输出(请忽略我的音乐品味…)。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6734" class="nb lq iq mx b gy nc nd l ne nf">Now playing: Sweet Child o' Mine<br/>Now playing: Back In Black<br/>Now playing: Disenchanted<br/>Now playing: Say Amen<br/>Now playing: House of Wolves<br/>Now playing: House of Wolves<br/>Now playing: Say Amen<br/>Now playing: Disenchanted</span></pre><p id="5d1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会看到最后一首歌(狼之屋)放了两遍。这是因为我们在播放歌曲后立即将歌曲保存到堆栈中，所以我们将在返回之前看到最后一首歌曲的重播(大多数情况下音乐播放器都会这样)。</p><p id="edea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>这只是一个简单的音乐播放器，目的是提供一个如何使用这种设计模式的例子。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="4a82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章能为你提供一些关于纪念品设计模式的有用信息。感谢阅读！</p><h1 id="0de7" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">参考</h1><h2 id="65f3" class="nb lq iq bd lr nr ns dn lv nt nu dp lz ko nv nw md ks nx ny mh kw nz oa ml ob bi translated">录像</h2><p id="20b4" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated"><a class="ae kc" href="https://www.youtube.com/watch?v=Pwm-jrG2ZVA" rel="noopener ugc nofollow" target="_blank">用纪念品图案撤销更改|你必须知道的设计图案</a></p></div></div>    
</body>
</html>