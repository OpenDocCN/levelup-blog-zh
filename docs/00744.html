<html>
<head>
<title>Using Value Objects with Entity Framework Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实体框架核心使用值对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-value-objects-with-entity-framework-core-5cead49dbf9c?source=collection_archive---------0-----------------------#2019-07-16">https://levelup.gitconnected.com/using-value-objects-with-entity-framework-core-5cead49dbf9c?source=collection_archive---------0-----------------------#2019-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a90f160d8981fe26bde9dfff30acfc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cJuLkJqmreTSyHE4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@campaign_creators?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="83df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果让你在数据库中存储一个邮政地址，你会怎么做？可能是代表城市、州、邮政、国家和街道的几列。你完全可以这么做，但这看起来很奇怪，对吗？将所有这些属性作为参数传递给方法或其他对象将是一件苦差事。作为优秀的开发人员，您可能会倾向于创建一个用这些字段表示地址的对象:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="03d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">酷，现在我们可以开始在我们的应用程序代码中使用它了。但是，我们仍然有映射到领域层和从领域层映射的问题。请记住，如果我们要查询一个“Order”对象，该对象包含前面提到的所有字符串属性，那么我们需要创建一个映射来从域实体中提取这些属性，并将它们映射到我们新创建的“Address”对象，反之亦然。嘘！这是站不住脚的，没有人有时间这样做——我是一名开发人员，必须遵守我懒惰的天性。</p><p id="364e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我给大家介绍一个概念，叫做值对象。简而言之，它基本上是一个表示内聚复合概念的对象。听起来很熟悉，是吧？如果你做OOP已经有一段时间了，这应该是。无论如何，作为一个例子，考虑一个对象，如坐标2D。这个值对象有两个属性:“x”和“y”。很容易吗？很好。那么，这如何适应实体框架核心(EF核心)和整个地址的事情呢？我快到了。所以EF核心允许你在你的域实体中使用这些值对象。这意味着我们的“订单”类可以从:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="04ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收件人:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="8865" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最棒的是，EF内核可以自动为我们处理映射。但没那么快。只是没那么容易。抱歉:`(</p><p id="e3f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跟着我，你的时间会得到回报。我保证！</p><h1 id="2eca" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">创建我们的值对象基类</h1><p id="1940" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">为什么是基类？难道我们不能从上面的地址类中提取一段代码并使用它吗？你可以，但是这不仅会给你带来问题，还会给你团队中任何需要与之互动的人带来问题。让我解释一些任何值对象都必须遵守的简单规则:</p><ul class=""><li id="8a6a" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">他们没有身份。</li><li id="6055" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">它们必须是不可变的。</li></ul><p id="b014" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仔细阅读这些。记住它们。梦见他们..好吧，别这样。那么这对我们的“地址”对象意味着什么呢？好吧，让我们再来看看:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="d680" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">规则#1似乎在这里被检查；这个对象中没有身份属性，而且，以后我们也不会用实体框架(EF)来配置它。规则#2在这里没有被检查。解决这个问题最简单的方法是将public setter改为private。但是，让我们先来看看这个基类的实现。根据微软:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/implement-value-objects#value-object-implementation-in-c" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/standard/microservice-architecture/microservice-DDD-cqrs-patterns/implement-value-objects # value-object-implementation-in-c</a></figcaption></figure><p id="df32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个类只是实现了一些基本的东西，比如等式比较和EF所需的其他基础知识。最重要的是，它还将标记我们的派生类，这对我们很有用，您将在本文后面了解到。</p><h1 id="9539" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">从我们的基类派生对象</h1><p id="6658" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">现在我们有了一个基类，让我们将它应用于我们的“地址”类。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="5e2f" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">配置实体以使用值对象</h1><p id="aa6f" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">公平的警告，我使用流畅的API来配置我的域实体，我个人不容忍属性的使用(你知道你是谁)。现在，我已经说了，我们的“Address”类已经成形，让我们继续用我们的域实体来配置它。为此，我们将使用前面的“Order”类作为示例:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="4cd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候将我们的焦点转移到实体配置上了。这提醒了我。我喜欢使用类风格的配置，而不是在“DbContext”类中配置所有东西。但是，只要您觉得合适，就可以随意实现实体配置。因此，我们对“Order”类的配置如下所示:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="a0ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意这里的“OwnsOne”方法。这将告诉EF我们的“订单”实体想要使用一个值对象。然而，关于这种方法如何工作，它能做什么和不能做什么，有一些重要的事情需要引起你的注意。这是直接取自微软的“<a class="ae kc" href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/implement-value-objects#additional-details-on-owned-entity-types" rel="noopener ugc nofollow" target="_blank">实现值对象</a>”一字不差:</p><h2 id="71dd" class="my li iq bd lj mz na dn ln nb nc dp lr ko nd ne lv ks nf ng lz kw nh ni md nj bi translated">关于所有实体类型的其他详细信息</h2><ul class=""><li id="1caa" class="mk ml iq kf b kg mf kk mg ko nk ks nl kw nm la mp mq mr ms bi translated">当您使用OwnsOne fluent API将导航属性配置为特定类型时，会定义所拥有的类型。</li><li id="25f9" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">在我们的元数据模型中，所拥有类型的定义由以下几部分组成:所有者类型、导航属性和所拥有类型的CLR类型。</li><li id="6859" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">堆栈中拥有类型实例的标识(键)是拥有者类型的标识和拥有类型的定义的组合。</li></ul><h2 id="ef0d" class="my li iq bd lj mz na dn ln nb nc dp lr ko nd ne lv ks nf ng lz kw nh ni md nj bi translated">拥有的实体能力:</h2><ul class=""><li id="a7cd" class="mk ml iq kf b kg mf kk mg ko nk ks nl kw nm la mp mq mr ms bi translated">拥有的类型可以引用其他实体，无论是拥有的(嵌套拥有的类型)还是不拥有的(对其他实体的常规引用导航属性)。</li><li id="2bc9" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">您可以通过单独的导航属性将同一CLR类型映射为同一所有者实体中的不同所有者类型。</li><li id="2e1f" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">表拆分是按照约定设置的，但是您可以通过使用ToTable将所拥有的类型映射到不同的表来退出。</li><li id="bda3" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">在拥有的类型上自动执行急切加载，即不需要在查询上调用Include()。</li><li id="b5a2" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">从EF Core 2.1开始，可以配置属性[Owned]</li></ul><h2 id="1776" class="my li iq bd lj mz na dn ln nb nc dp lr ko nd ne lv ks nf ng lz kw nh ni md nj bi translated">自有实体限制:</h2><ul class=""><li id="3248" class="mk ml iq kf b kg mf kk mg ko nk ks nl kw nm la mp mq mr ms bi translated">您不能创建拥有类型的数据库集<t>(根据设计)。</t></li><li id="12b0" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">您不能调用模型构建器。拥有的类型上的实体<t>()(目前按设计)。</t></li><li id="9833" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">还没有拥有类型的集合(从EF Core 2.1开始，但是在2.2中将支持它们)。</li><li id="f3d3" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">不支持与所有者映射在同一表中的可选(即可为null)拥有的类型(即使用表拆分)。这是因为映射是针对每个属性进行的，我们没有针对整个空复数值a的单独标记。</li><li id="121f" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">不支持拥有类型的继承映射，但是您应该能够将相同继承层次结构的两个叶类型映射为不同的拥有类型。EF核心不会考虑它们属于同一层级的事实。</li></ul><h1 id="9361" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">数据库表中会出现什么</h1><p id="592a" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">这需要做很多工作，但是现在创建新的值对象并将它们绑定到您的域实体已经很简单了。但是，有关于如何配置实体的选项。如前所述，您可以选择不进行表拆分，这实际上是将我们的“Address”类的所有字段放入您设置名称的表中。例如，附加以下内容:</p><pre class="lb lc ld le gt nn no np nq aw nr bi"><span id="ac0a" class="my li iq no b gy ns nt l nu nv">.ToTable("OrderAddresses");</span></pre><p id="95b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法将在Order表和OrderAddresses表之间创建一对多关系。</p><p id="42bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一件需要注意的事情是EF强加给值对象的默认命名约定。还记得在保存地址值对象的“Order”类中我们的属性名是什么吗？</p><pre class="lb lc ld le gt nn no np nq aw nr bi"><span id="70e9" class="my li iq no b gy ns nt l nu nv">public Address Address { get; set; }</span></pre><p id="9f92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，实体将采用该属性的名称，并将其作为包含在该值对象中的属性名称的前缀。因此，Order表中的列将具有以下内容:</p><ul class=""><li id="3759" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">地址_街道</li><li id="49dd" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">地址_城市</li><li id="73c7" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">地址_州</li><li id="b405" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">地址_国家</li><li id="1f9c" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">地址_邮政编码</li></ul><p id="a608" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不喜欢吗？没问题，您可以通过fluent API覆盖此配置:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="bc11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打电话。属性()允许您使用实体中其他列上的普通配置选项。</p><p id="b983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用得着要求吗？</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="3ca5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想你已经找到窍门了。</p><h1 id="d52f" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结束了。</h1><p id="ce86" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我们在这里讨论了很多材料。我将链接到这方面的另一个部分，讨论在试图保存具有空值对象的实体时绕过可空问题的一个聪明的方法。在那之前。下次见！</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="feab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第二部分</strong> : <a class="ae kc" href="https://medium.com/@austin.davies0101/how-to-have-nullable-owned-types-in-entity-framework-core-84ed9f112878" rel="noopener">如何在实体框架核心中拥有可空的拥有类型</a></p></div></div>    
</body>
</html>