<html>
<head>
<title>Coding Probem: Palindrome Checking in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码问题:Golang中的回文检查</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coding-probem-palindrome-checking-in-golang-e8dcf4879567?source=collection_archive---------8-----------------------#2021-02-02">https://levelup.gitconnected.com/coding-probem-palindrome-checking-in-golang-e8dcf4879567?source=collection_archive---------8-----------------------#2021-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习三种解决方案，提高您的编码技能！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d137b25737f0215e9015da3f7c28eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nneG0ldCdMM0qORG.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自DeepDreamGenerator上的<a class="ae ky" href="https://deepdreamgenerator.com/u/peopleforc137" rel="noopener ugc nofollow" target="_blank">伊莎贝尔</a></figcaption></figure><p id="5954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">回文是一串向前读和向后读一样的字符。检查给定的字符串是否是回文是一个常见的编码面试问题，因此在您的编码工具带中有这个问题的解决方案是很有用的。下面是一个有趣的回文例子:</p><blockquote class="me"><p id="73ab" class="mf mg it bd mh mi mj mk ml mm mn lu dk translated">"我们几个人，难道不是在前进，前进到新的时代吗？"—苏格拉底·塞塔科斯</p></blockquote><p id="d828" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这篇文章中，我们将讨论著名的回文问题的三种解决方案。这将包括在使用我最喜欢的编程语言Golang的同时，分析它们不同的时间和空间复杂性！</p><p id="b61d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7ac9" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">字符串连接— O(N)时间，O(N)空间</h1><p id="12e6" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">常见的强力解决方案是以相反的顺序重新创建给定的字符串，然后比较这两个字符串，看它们是否相等。这些最初的解决方案实际上是编码问题的第一步，并向你的面试官表明你在跳到优化之前首先想到了基础。</p><p id="feab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先我们初始化一个名为<code class="fe nx ny nz oa b">reversedStr</code>的空字符串。然后我们将执行一个for循环，将索引<code class="fe nx ny nz oa b">i</code>初始化到数组末尾减一(长度为30的数组的最大索引为29)。当我们以相反的顺序将<code class="fe nx ny nz oa b">i</code>从字符串的末尾移动到开头时，我们将当前字符<code class="fe nx ny nz oa b">str[i]</code>与<code class="fe nx ny nz oa b">reversedStr</code>连接起来。</p><p id="7057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在Go中访问一个带索引的数组的元素会给你一个byte对象，所以你要先把它转换成string<code class="fe nx ny nz oa b">string(str[i])</code>。</p><p id="26ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们有另一个for循环，其中我们使用函数<code class="fe nx ny nz oa b">range()</code>让我们的索引<code class="fe nx ny nz oa b">i</code>遍历字符串<code class="fe nx ny nz oa b">str</code>的长度。当我们这样做时，我们比较每个字符if <code class="fe nx ny nz oa b">str</code>和<code class="fe nx ny nz oa b">reversedS</code>并检查它们是否相等。如果它们不在任何时间点，我们返回<code class="fe nx ny nz oa b">false</code>。如果我们遍历了整个字符串，并且所有的字符都相等，那么这个字符串实际上是一个回文，我们返回<code class="fe nx ny nz oa b">true</code>！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初你可能认为这个函数是O(N)时间的，但是要小心！字符串串联实际上是一个O(N)运算。对于<code class="fe nx ny nz oa b">str</code>的每个字符，我们将它与<code class="fe nx ny nz oa b">reversedStr</code>连接起来，这导致O(N)的时间复杂度。由于我们也将<code class="fe nx ny nz oa b">str</code>数组的长度存储在<code class="fe nx ny nz oa b">reversedStr</code>中，所以我们的空间复杂度将是O(N)。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="6b85" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">数组追加— O(N)时间，O(N)空间</h1><p id="77c2" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">继续，我们可以使用与第一次尝试非常相似的逻辑，同时改进我们的时间复杂度。我们可以追加到数组中，而不是连接一个字符串。使用编程语言Go，这一般是一个常数时间操作！</p><p id="1333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以首先我们初始化一个名为<code class="fe nx ny nz oa b">result</code>的空字节数组。然后我们逆序迭代<code class="fe nx ny nz oa b">str</code>(别忘了初始化<code class="fe nx ny nz oa b">i</code>到<code class="fe nx ny nz oa b">len(str)-1</code>！)并将每个字符追加到<code class="fe nx ny nz oa b">result</code>。</p><p id="c106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们简单地比较我们的初始参数<code class="fe nx ny nz oa b">str</code>和<code class="fe nx ny nz oa b">string(result)</code>来测试它是否是一个回文。简单！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e09e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在<code class="fe nx ny nz oa b">str</code>上只有一个for循环，而Go中的<code class="fe nx ny nz oa b">append()</code>操作是一个常数时间操作，所以我们得到的时间复杂度为O(N)。我们仍然存储一个长度为<code class="fe nx ny nz oa b">str</code>的数组，所以我们的空间复杂度也是O(N)。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="0e97" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">相反的索引— O(N)时间，O(1)空间</h1><p id="a878" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我们可以做得更好！让我们想一想。我们已经通过前两次尝试解决了这个问题，同时创建了以相反顺序构建的<code class="fe nx ny nz oa b">str</code>的额外数据结构。我们一定要这么做吗？回文的本质是什么？而是单词的反映是单词本身——更具体地说，字符串的第一个字符等于字符串的最后一个字符。字符串的第二个字符等于字符串的倒数第二个字符，依此类推…</p><p id="346b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，与其以相反的顺序构建字符串，为什么不直接检查字符串中是否存在回文的模式呢？我们可以通过在字符串的开头和结尾初始化两个索引，然后递增地检查字符串，确保字符串的左右两边相等！</p><p id="c2b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们只需要小心我们的索引。我们用<code class="fe nx ny nz oa b">i=0</code>开始一个for循环，并在整个字符串中递增。当我们这样做时，我们设置另一个变量<code class="fe nx ny nz oa b">j=len(str)-1-i</code>。所以当<code class="fe nx ny nz oa b">i</code>为0时，它是第一个索引，<code class="fe nx ny nz oa b">j</code>将是最后一个索引。当<code class="fe nx ny nz oa b">i</code>为1时，它将是第二个索引，而<code class="fe nx ny nz oa b">j</code>将是倒数第二个索引，依此类推。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="619b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错！你能看出其中的复杂性吗？我们有一个单独的for循环，它用常量时间操作遍历字符串。所以我们的运行时复杂度是O(N)。现在我们不存储任何数据结构，我们已经优化了我们的算法，使其具有恒定的空间复杂度O(1)。</p><p id="5c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要一个最终的优化，你可以在<code class="fe nx ny nz oa b">i &gt; (len(str)/2)+1</code>时终止for循环，因为我们只需要字符串的每一半相等。</p><p id="ca78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能想到其他的解决方法吗？</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="45ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助你理解一个常见的编码问题，同时也学习一些关于在Go中编程的技巧。如果你有任何其他的编码问题想要一个教程，或者如果你只是喜欢这篇文章，我鼓励你在下面留下评论！感谢阅读。</p></div></div>    
</body>
</html>