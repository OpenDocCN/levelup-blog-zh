<html>
<head>
<title>OOP best practices that are anti-patterns in (functional) JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(功能性)JavaScript中反模式的OOP最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oop-best-practices-that-are-anti-patterns-in-functional-javascript-61ee1af35452?source=collection_archive---------15-----------------------#2020-05-04">https://levelup.gitconnected.com/oop-best-practices-that-are-anti-patterns-in-functional-javascript-61ee1af35452?source=collection_archive---------15-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ef6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在面向对象编程(OOP)和设计模式中，什么被认为是好的实践，但在JavaScript中被认为是反模式(至少是JS的函数式编程(FP)风格)？</p><p id="4c21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是要点:</p><ul class=""><li id="acb6" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">优点:工厂模式</li><li id="90a5" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">坏处:构造函数</li><li id="6a1a" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><code class="fe lc ld le lf b">class Foo extends Bar</code>丑陋的</li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/1164beee87f7be01e575145e174d9946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWwbii6ig3GQOfhW0nwAMA.jpeg"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">看着这个湖有助于我理清思绪。</figcaption></figure><p id="c9e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于经典的OOP语言(Java、C#、PHP ),事情看起来非常相似。C#可能更好，但是我对它没有什么经验，所以我将使用Java作为参考点。然而，所有语言中的(反)模式都是一样的。</p><p id="553e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">免责声明:以上并不意味着遵循OOP范例和使用类的面向对象编程或语言是不好的。更多的是JavaScript使用了一种不同的范式，提供了更强的表现力，所以利用它是有好处的。</p><h1 id="9ac2" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">优点:工厂模式</h1><p id="9ecd" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">事实上，在OOP中有两种工厂模式:</p><ul class=""><li id="61ba" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae mz" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法模式</a></li><li id="1077" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae mz" href="https://en.wikipedia.org/wiki/Abstract_factory_pattern" rel="noopener ugc nofollow" target="_blank">抽象工厂模式</a></li></ul><p id="4272" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两者都有意义，因为它们是用一种特定的语言来解决问题的。这里最大的一个问题是:你想编码对象的创建，但还不知道它们的<code class="fe lc ld le lf b">class</code>。看看提供的Java代码示例，有多复杂，需要多少样板文件。</p><p id="a7af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JavaScript中，这些限制都不存在:没有对象类(稍后会详细介绍<code class="fe lc ld le lf b">class</code>关键字)，不需要检查接口等等。任何函数都可以返回一个对象，因此您可以:</p><pre class="lh li lj lk gt na lf nb nc aw nd bi"><span id="6abc" class="ne lx it lf b gy nf ng l nh ni">const createUser = ({ name }) =&gt; ({<br/>  name,<br/>  setName(name) {<br/>    this.name = name;<br/>    return this;<br/>  }<br/>});<br/> <br/>const joe = createUser({ name: 'Joe Doe' });</span></pre><p id="dddc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码是一个简单返回对象的工厂函数。不需要类、静态方法和多态。阅读带有ES2015语法的<a class="ae mz" href="https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1" rel="noopener">工厂函数，了解如何处理默认参数、类型推断和其他内容。</a></p><p id="4ec1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说:工厂模式在OOP语言中的广泛使用是有意义的，但在JavaScript中它只是一个返回对象文字的函数。太简单而不能称为设计模式；)</p><h1 id="1287" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">坏处:构造函数</h1><p id="b818" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">所以JavaScript有一个构造函数，应该使用<code class="fe lc ld le lf b">new</code>操作符调用来调用<em class="nj">:</em></p><pre class="lh li lj lk gt na lf nb nc aw nd bi"><span id="132d" class="ne lx it lf b gy nf ng l nh ni">function User(name) {<br/>  this.name = name;<br/>}<br/> <br/>const joe = new User('Joe Doe');<br/>console.log(joe instanceof User);</span></pre><p id="bb4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像Java一样，差不多。如果你忘记使用<code class="fe lc ld le lf b">new</code>，构造函数将被调用为常规函数，在这种情况下<code class="fe lc ld le lf b">this</code>将被绑定到全局对象(即浏览器中的<code class="fe lc ld le lf b">window</code>)。像名字这样的变量被添加到全局范围，整个结构就分崩离析了(双关语)。这是一个主要的陷阱，也是许多错误的原因。</p><p id="8a70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以探索构造函数的更多<a class="ae mz" href="https://css-tricks.com/understanding-javascript-constructors/" rel="noopener ugc nofollow" target="_blank">特征，但是我同意</a><a class="ae mz" href="https://github.com/getify" rel="noopener ugc nofollow" target="_blank"> Kyle Simpson </a>有比构造函数、原型黑客和类更好的解决方案，比如<a class="ae mz" href="https://stackoverflow.com/questions/29788181/kyle-simpsons-oloo-pattern-vs-prototype-design-pattern" rel="noopener ugc nofollow" target="_blank"> OLOO模式</a>。如果你真的需要有方法的对象，当然；)</p><p id="71d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">长话短说:避免使用<code class="fe lc ld le lf b">new</code>关键字和构造函数。因此，<code class="fe lc ld le lf b">instanceof</code>可能也没有必要。使用上面描述的更强大的工厂功能。正如道格拉斯·克洛克福特所说:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nk nl l"/></div></figure><blockquote class="nm"><p id="6f81" class="nn no it bd np nq nr ns nt nu nv kn dk translated">如果一个特性有时是危险的，并且有更好的选择，那么总是使用更好的选择</p></blockquote><p id="0f85" class="pw-post-body-paragraph jq jr it js b jt nx jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj ob kl km kn im bi translated">在OOP语言中也不鼓励使用<code class="fe lc ld le lf b">new</code>操作符，以避免与特定的类及其实现耦合。工厂模式更受青睐，它支持依赖注入，但这是另一篇文章的内容。</p><h1 id="acca" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><code class="fe lc ld le lf b">class Foo extends Bar</code>丑陋的</h1><p id="7ed8" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">ES2015在JavaScript中引入了<code class="fe lc ld le lf b">class</code>和<code class="fe lc ld le lf b">extends</code>关键字。不，这并不意味着JavaScript已经有了类——它仍然在使用原型链。基本上，它是一个语法糖在构造器模式上，在幕后做了一些魔术。</p><p id="9160" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，这里最坏的冒犯者是关键字<code class="fe lc ld le lf b">extends</code>，因为它<em class="nj">鼓励</em>为代码共享扩展类。这是错误的动机。在设计中应该用<code class="fe lc ld le lf b">extends</code>来表达“<em class="nj">是一个“</em>的关系，但现实中很少出现这样的情况。这是OOP中最高形式的耦合。</p><p id="5eab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">广泛使用<code class="fe lc ld le lf b">extends</code>会导致深度嵌套的类继承层次结构。起初看起来并不坏，但是相信我，我曾经在一个7层的系统中工作过，我们一直在这个树中修复代码。固定在一个级别会导致更高或更低几个级别的回归，导致螺旋式下降。那只是<a class="ae mz" href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3" rel="noopener">第七层地狱</a>一类的问题。</p><p id="8f56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种反模式的另一个常用名称是乔·阿姆斯特朗创造的“大猩猩/香蕉问题”:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b9e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，<code class="fe lc ld le lf b">class</code>可能是有用的。很长一段时间，使用类是创建React组件的建议。注意你总是有<code class="fe lc ld le lf b">extends React.Component</code>——在代码中没有很深的继承层次，对吗？对吗？！我觉得JS里的<a class="ae mz" href="https://medium.com/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf" rel="noopener">类关键字没有坏了</a>，但是它自带问题，就像<code class="fe lc ld le lf b">new</code>关键字一样。正如一个类比所暗示的那样——最好同时避开这两者。</p><h1 id="5df0" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">对象和类不是软件</h1><p id="e742" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">OOP爱好者通常倾向于关注类、对象、UML、图表——所有这些都很好，但不是核心。最重要的是:软件做什么。考虑到这一点，没有方法的对象是非常无用的，即使Java(过去)强迫你<a class="ae mz" href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" rel="noopener ugc nofollow" target="_blank">创建类来保存你的函数</a>——这是一个可怕的想法。</p><p id="6138" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于下一个JavaScript特性或项目，开始考虑如何用最简单的方式解决问题。尽量避免所有面向对象的仪式，把注意力集中在软件的功能上。</p></div></div>    
</body>
</html>