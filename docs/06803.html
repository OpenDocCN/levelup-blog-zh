<html>
<head>
<title>Advanced Profiling and Tracing MySQL Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级分析和跟踪MySQL查询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-profiling-and-tracing-mysql-queries-c0c95dc7db24?source=collection_archive---------4-----------------------#2021-01-03">https://levelup.gitconnected.com/advanced-profiling-and-tracing-mysql-queries-c0c95dc7db24?source=collection_archive---------4-----------------------#2021-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b3c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">探索处理未优化的MySQL查询的各种方法。</p><p id="7810" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很多时候，您希望分析正在执行的查询。这可能是由多种原因造成的。</p><ul class=""><li id="ae14" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">当前的执行是潜在的，我们需要优化。</li><li id="a0d8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">找出未使用的索引，或者确定索引是否可能在查询路径上。</li><li id="f950" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">来确定查询执行计划。</li><li id="0dcd" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">分析服务器上查询所用的时间。</li></ul></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="3bb4" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">慢速查询日志</h1><p id="5a16" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">如果您遇到行为不当或查询速度慢的问题，首先，应该将服务器设置为记录它们。如果不知道哪些查询真正占据了服务器，我们就永远无法优化它们。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/80b0fcdf6099cbcdfba30049f234a95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ky-hpVerrmjbDjlmVPZlOg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="bd li">显示全局变量，如“slow _ query %”</strong></figcaption></figure><p id="6b39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置一个特定的时间单位阈值，使日志噪音更小，占用的磁盘更少，<em class="mz">比如，记录超过10秒的请求</em> <em class="mz">(小心您的生产负载)</em>。一个示例日志查询如下所示。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi na"><img src="../Images/2b6375037309d47a1e606378dbae3047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AF_SG2I37GFD-bHCDIBmzQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">记录了一个慢速查询示例</figcaption></figure><p id="8191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">跟踪日志能告诉我们很多东西，</strong></p><ul class=""><li id="0b3a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">哪个进程正在调用慢速查询。<br/> <em class="mz">有时，恶意客户端会以间接方式阻止资源</em></li><li id="0b21" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">花了多长时间？<br/> <em class="mz">这不是估计值，而是帖子查询执行的真实数字。首先需要隔离非常耗时的查询。</em></li><li id="94a2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">它检查的行数和它返回的行数。<br/> <em class="mz">如果您正在检查许多行，但返回的很少，则可能需要一个索引。</em></li><li id="baba" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">通过网络发送的字节数。堵塞网络的查询需要从OLTP卸载到OLAP。</li><li id="6772" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">执行此查询的时间(在查询运行之前记录)。<br/> <em class="mz">时间线有助于以听觉为目的讨论问题。</em></li></ul><blockquote class="nb nc nd"><p id="b7cb" class="jn jo mz jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">小心</em> </strong> <em class="iq"> : </em></p><p id="c406" class="jn jo mz jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><em class="iq"> 1)服务器上的慢速查询日志默认不轮换。如果未选中，日志分区可能会阻塞磁盘。请相应地设置阈值。</em></p><p id="817a" class="jn jo mz jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated"><em class="iq"> 2)启用慢速查询日志会对性能产生一些影响，因此请确保进行监控。</em></p></blockquote></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="67a8" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">解释查询</h1><p id="f9af" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">现在我们已经隔离了一些查询，是时候解释它们的存在了。<br/>EXPLAIN关键字用于提供关于MySQL数据库如何执行查询的信息。</p><p id="6427" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与通常的结果集不同，MySQL随后会显示其语句执行计划，解释在执行语句时哪些进程以什么顺序发生，以及估计的成本。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nh"><img src="../Images/029427e7a964a5dbfeb1f9e3caf3558d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKsfANOENtViPgPIS9inkg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">注意:小心使用EXPLAIN和UPDATE查询。</figcaption></figure><p id="63d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释你所有的疑问是下一个最好的选择。您可以通过在<strong class="jp ir"> Extra </strong>列中查找<strong class="jp ir"> Using index </strong>来查看MySQL是否优化了您的查询以利用覆盖索引优化 的<a class="ae ni" href="https://www.burnison.ca/notes/fun-mysql-fact-of-the-day-got-it-covered" rel="noopener ugc nofollow" target="_blank"> <em class="mz">。如果您的查询没有使用index，您可能需要找出原因。</em></a></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nj"><img src="../Images/a598207f0bd3f4b15cc295fd414c6c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFrhAKCrCtzCJRAaDrlo0w.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">解释查询的输出(修订)</figcaption></figure><ul class=""><li id="dca3" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">对于子查询中的每个查询，尝试查看可以使用的可能键(索引)(<strong class="jp ir">possible _ keys</strong>)。这是MySQL告诉你它可以使用这个集合中的任何一个的方式。<strong class="jp ir">请注意MySQL一次只能使用一个索引</strong>。<em class="mz">不多，都知道</em>。您可以创建10个索引，但是根据它的启发式规则，它将只使用一个。</li><li id="38f7" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">您也可以强制MySQL使用索引，但并不总是推荐这样做。例如，你可能需要在Hibernate或其他ORM中编写本地查询来实现这一点。不方便。</li></ul><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nk"><img src="../Images/9e070efdf9980faf19f28d77aa605413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgYJnVNnqzOItQ2YtqbwNQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">ORM和Force索引查询不太适用。</figcaption></figure><ul class=""><li id="c308" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">键</strong>列定义了实际选择的指数。完全基于<a class="ae ni" href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> MySQL启发式</em> </a>。我们希望MySQL选择一个能够最好地覆盖where子句中最大列数的索引。</li><li id="26ab" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">需要注意的一点是，如果您刚刚创建了一个索引，MySQL查询优化器提示可能不会反映出来，您可能会感到困惑，为什么您刚刚创建的一个更合适的<strong class="jp ir"> <em class="mz">索引没有在MySQL解释输出中选择</em> </strong>。给它一些时间，启动一些查询，然后观察启发式更新。</li><li id="c07c" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">理解<strong class="jp ir">不相关子查询</strong>和<strong class="jp ir">相关/相关子查询之间的区别。</strong></li></ul><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nl"><img src="../Images/2a66e36f49af5604df4204e0464c689d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdqOQ2sPD0dnIe283ZP1qQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">不相关:MySQL根据每个外部查询为内部查询派生一个标量值。<strong class="bd li"> O(外)</strong></figcaption></figure><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nm"><img src="../Images/2ddc6c8fb579333e73494c3abac55042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCeozjvm8hmiXcOLvpvtXw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">从属:非标量。MySQL对outer_table中的每一行执行一次内部查询。<strong class="bd li"> O(外*内)</strong></figcaption></figure><ul class=""><li id="0eba" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">当您无法利用索引优化排序时，您应该尽量保持您的排序键尽可能小，尤其是小于<a class="ae ni" href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_length_for_sort_data" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">max _ length _ for _ sort _ data</strong></a>。</li><li id="d48e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如果你看到沉重的<a class="ae ni" href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html#order-by-filesort" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">文件排序</strong> </a>，为了排序效率，牺牲一些准确性。<em class="mz">SET SESSION max _ sort _ length = 32</em>会告诉MySQL只比较每个字段的前32个<em class="mz">字节，而不是整个字段。</em></li></ul><p id="7dc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果您有一个<em class="mz">ORDER BY campaign . date _ created，</em> <em class="mz"> campaign.name </em>，我们可能只想对活动名称的前<em class="mz"> 32 </em>字节进行排序，而不是使用默认的<em class="mz"> 1024 </em>字节。</p><ul class=""><li id="f9f5" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">点击阅读更多关于充分利用解释输出<a class="ae ni" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" rel="noopener ugc nofollow" target="_blank">的信息</a></li></ul></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="8079" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">查询跟踪器</h1><p id="9115" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">能够阅读解释查询的输出是一回事。然而，为了深入研究，您需要确切地了解MySQL将如何组织您的查询，以及这些潜在的索引能够或不能够涵盖哪些内容。</p><p id="5468" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优化器跟踪很冗长，会产生大量输出。你会得到这样的东西</p><ul class=""><li id="5b0e" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">表相关性</li><li id="60ae" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">潜在范围索引(重要)</li><li id="c201" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如何估计行数和成本</li><li id="ebf0" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">它将如何准备连接。</li><li id="598e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">它将如何执行连接。</li></ul><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nn"><img src="../Images/a34a42fb51f71579ac3dc8c9bf2477d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAo7Z39VdZlK18AT5wzTzw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">用法:启用查询跟踪。回应相当冗长。</figcaption></figure><p id="1566" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数情况下，我们在寻找关键的<strong class="jp ir">潜力_范围_指数</strong>。在这里，您可以看到MySQL在这个表上找到的每个索引所覆盖的所有列。</p><p id="c3f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于潜在的多列索引中的每一列，MySQL都会评估有用的部分。<em class="mz">(注意，这是指特定的查询，每个不同的查询的结果会有所不同)</em></p><p id="e279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，考虑下面的查询</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi no"><img src="../Images/e987c896d4ced99d4ef235d4221efe38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bImV2x035ZDC34SvrukiA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">一个带有“3”where部分的查询，最后一个并不平凡</figcaption></figure><p id="a4db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">where部分中的子句是:</p><ul class=""><li id="a139" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">创意_模板_id </strong></li><li id="f063" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir">状态</strong></li><li id="58d9" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir"> concat(内容标识，内容版本)</strong></li></ul><p id="c8ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们检查tracer输出，在所有索引中，MySQL告诉我们最后一个索引<strong class="jp ir">idx _ vcg _ creative _ template _ status _ id version</strong>将覆盖大多数键。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi np"><img src="../Images/4173171acd5ca4e6084ba44aa9af68ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-1qkAz_XKXWF9hBHJIX9A.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">最后一个可用的覆盖了大多数键，即使根据MySQL</figcaption></figure><p id="891f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi nq translated">这有什么帮助？</p><p id="bad4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是对索引实际上可用<strong class="jp ir">且索引确实如预期覆盖<strong class="jp ir">关键零件</strong>的确认。可以想象，对于非平凡的查询，这可能有助于简化流程，因为只使用一个索引。</strong></p><p id="786e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这不是最优的，那么查询的性能也会很差。</p><p id="4a9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:在上面的例子中，<strong class="jp ir">串联(a，b)！= index(a，b) </strong>。像<a class="ae ni" href="https://confluence.fkinternal.com/display/SKADOOSH/2020-10-22+%7C+DB+Queries+%7C+CM+%7C+Virtual+Column+and+Index+%7C+Content+API+Optimization" rel="noopener ugc nofollow" target="_blank">虚拟列</a>这样的东西在这里可以有所帮助。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="faff" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">查询计时分析</h1><p id="2de1" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">现在您已经找出了查询中的弱路径，您可能已经处理了一组优化的候选查询。你怎么知道哪个候选人要把它投入生产？</p><p id="5a41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">标准查询分析器</strong>是可用的，它将帮助您对服务器上查询执行的结果进行计时。然而，令人沮丧的是，大多数<em class="mz">开发人员不正确地测量查询执行时间</em>。</p><p id="50f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们包括开始传输的时间和要考虑的其他网络因素。例如，如果您正在使用GUI客户端并执行分析，则不能依赖GUI状态栏中报告的数字。参考这个。(<a class="ae ni" href="https://github.com/sequelpro/sequelpro/issues/264" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nz"><img src="../Images/729acc382c9607fbcc6698d1a43cd127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WLGnGcM_bM0Z20YzmaCCQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">你真正衡量的是什么？</figcaption></figure><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi oa"><img src="../Images/aa97aba280bbf7ab079a6cf63039412f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hB5V0V1tjqJp93SpClYdLA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">在服务器上启用查询计时分析的步骤(橙色窗口)</figcaption></figure><p id="eea4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们对一个名为<em class="mz"> campaign </em>的表进行如下查询，该表的主键超过了<em class="mz">300万行</em>。然而，唯一的非主索引位于名为<strong class="jp ir"> end_date的列上。</strong></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ob"><img src="../Images/5e1841e6e19b3c824d5aedbe169c6dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpYqaXtuRNev3MLM-KXCzQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">选择10行不同的查询模式</figcaption></figure><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi oc"><img src="../Images/9674419152e8307a7bab32810cfcdae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKsU59yjDSi82l7CdL0Tvw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">大约300万基数集上的查询计时结果</figcaption></figure><p id="e9ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分析器的结果是直观的。您可以看到，在第二次查询中查找索引会稍微慢一点<em class="mz"/>并导致<em class="mz">轻微的</em>损失。</p><p id="b923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以看到，没有索引加文件排序导致了巨大的<em class="mz"> 5700% </em>损失。通过这种方式，您可以很好地估计查询的执行情况。结果将直接转化为生产数据。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="6893" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">JDBC剖析</h1><p id="0b40" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">有时，在极少数情况下，一个查询在被隔离时可能执行得很好，但是在一系列的多个数据库调用中失败得很糟糕<em class="mz">(例如一个API向数据库发出10个调用)</em>。</p><p id="b6c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，您也可以在JDBC驱动程序上启用<strong class="jp ir">剖析</strong>。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi od"><img src="../Images/05e9539c4d3f02c8a12d45d4d6203502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFS0HxFgZv7yFn_7IGw4bA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">将<strong class="bd li"> profileSQL </strong>设置为true的MySQL JDBC驱动程序</figcaption></figure><p id="3b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，它将输出您可以用来</p><ul class=""><li id="eb6a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">分析发送给驱动程序的每个查询。</li><li id="fdc3" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">花费的时间</li><li id="a6f9" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">向驱动程序发出查询的速率。</li></ul><p id="f02d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它甚至捕获从JDBC池(如TomCat)发送的健康检查或验证查询。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi oe"><img src="../Images/2a8c0b4dcff0cb419bb5e2c6a7eee46c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzSd8TFYIWR4E3i6OvbqQw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">已配置的<strong class="bd li"> HEALTH_CHECK </strong>从连接池获取对驱动程序的调用。</figcaption></figure><p id="d4bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该日志对于检测ORM框架中是否有任何正在执行的<a class="ae ni" href="https://stackoverflow.com/questions/16577907/hibernate-onetomany-relationship-causes-infinite-loop-or-empty-entries-in-json" rel="noopener ugc nofollow" target="_blank">周期是至关重要的，例如当实体A有一个到多个B时，加载B，B一对一地加载A。<em class="mz">这发生在我们的生产设置中，导致一个查询停顿。</em></a></p><p id="9d31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果你不做分析(我们做了)，你永远不会知道为什么查询会挂起。</strong>然而，如果你做了侧写，你就会知道为什么你一直看到有多个电话打给司机。每个查询可能在孤立情况下表现良好。这种剖析将帮助您捕获代码库中的一个bug，您将看到cycle以及如何使用<a class="ae ni" href="https://stackoverflow.com/questions/37392733/difference-between-jsonignore-and-jsonbackreference-jsonmanagedreference" rel="noopener ugc nofollow" target="_blank"> JsonReference </a>来处理这个问题。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><p id="9abb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">探索各种方法深入到根本原因是一段相当长的旅程。<br/>总结一下。</p><pre class="mk ml mm mn gt of og oh oi aw oj bi"><span id="eeaf" class="ok lh iq og b gy ol om l on oo">- Log the Query first. How else do we know what to debug <br/>- EXPLAIN the Query and check the possible indexes, extra clauses<br/>- Trace out query execution to discover deeper structures in joins<br/>- Use MySQL profiles to log (various) query execution at the server<br/>- Use JDBC profiler and note for any cyclic / unnecessary queries.</span></pre><p id="7a8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你能做到这一步，谢谢你的时间。我希望这是有用的。我会在下一集里赶上你们。快乐侧写。</p><p id="2f62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献</strong></p><ul class=""><li id="99cc" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">阅读<a class="ae ni" href="https://learning.oreilly.com/library/view/high-performance-mysql/9781449332471/" rel="noopener ugc nofollow" target="_blank">高性能MySQL </a>它可能过时了，但内容很扎实</li><li id="265b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">关于MySQL内部的最好的博客之一是由Richard Burnison写的</li><li id="80a4" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">标准的MySQL文档在dev.mysql.com非常好</li></ul></div></div>    
</body>
</html>