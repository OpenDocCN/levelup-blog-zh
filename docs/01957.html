<html>
<head>
<title>JavaScript Type Checking with Flow — Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流的JavaScript类型检查—泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-type-checking-with-flow-generics-33f72476a1b9?source=collection_archive---------8-----------------------#2020-02-08">https://levelup.gitconnected.com/javascript-type-checking-with-flow-generics-33f72476a1b9?source=collection_archive---------8-----------------------#2020-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2f5047728e57cd012b92fbdff726c9a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OjLjlZbT6paNVF94"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">鲍里斯·斯莫克罗维奇在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ae19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Flow是一个由脸书开发的类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="c0e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解如何使用泛型类型使数据类型变得抽象，并允许代码重用。</p><h1 id="fee7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义泛型类型</h1><p id="6a5a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使类型在不同的实体中抽象，我们可以使用泛型类型从实体中抽象出类型。</p><p id="9eb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用泛型类型编写一个函数，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f40b" class="mq lf it mm b gy mr ms l mt mu">function foo&lt;T&gt;(obj: T): T {<br/>  return obj;<br/>}</span></pre><p id="dec5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mv mw mx mm b">&lt;T&gt;</code>来表示<code class="fe mv mw mx mm b">foo</code>是一个通用函数。<code class="fe mv mw mx mm b">T</code>是被引用时的通用类型标记。</p><p id="5550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了利用泛型类型，我们必须对它进行注释。否则，Flow不会知道它可以接受泛型类型。</p><p id="3283" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们想要在类型别名中泛型类型时，我们必须在类型别名中注释类型。</p><p id="4d25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="de6a" class="mq lf it mm b gy mr ms l mt mu">type Foo = {<br/>  func&lt;T&gt;(T): T<br/>}</span></pre><p id="b212" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="287d" class="mq lf it mm b gy mr ms l mt mu">type Foo = {<br/>  func&lt;T&gt;(T): T<br/>}</span><span id="ec2e" class="mq lf it mm b gy my ms l mt mu">function foo(value) {<br/>  return value;<br/>}</span><span id="22c6" class="mq lf it mm b gy my ms l mt mu">const f: Foo = { func: foo };</span></pre><p id="a7cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们没有给我们的<code class="fe mv mw mx mm b">foo</code>函数添加泛型类型标记。</p><p id="5a3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们用泛型类型注释了我们的<code class="fe mv mw mx mm b">foo</code>函数，它应该可以工作了:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="11d9" class="mq lf it mm b gy mr ms l mt mu">type Foo = {<br/>  func&lt;T&gt;(T): T<br/>}</span><span id="a11a" class="mq lf it mm b gy my ms l mt mu">function foo&lt;T&gt;(value: T): T {<br/>  return value;<br/>}</span><span id="643b" class="mq lf it mm b gy my ms l mt mu">const f: Foo = { func: foo };</span></pre><h1 id="3949" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">句法</h1><h2 id="d66e" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">通用函数</h2><p id="a96c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以定义一个通用函数如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cd1c" class="mq lf it mm b gy mr ms l mt mu">function foo&lt;T&gt;(param: T): T {<br/><br/>}<br/><br/>function&lt;T&gt;(param: T): T {<br/><br/>}</span></pre><p id="c589" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以用泛型定义函数类型，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c58e" class="mq lf it mm b gy mr ms l mt mu">&lt;T&gt;(param: T) =&gt; T</span></pre><p id="c68d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用带有变量和参数的通用函数类型，如:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="df35" class="mq lf it mm b gy mr ms l mt mu">let foo: &lt;T&gt;(param: T) =&gt; T = function(param: T): T {</span><span id="bd58" class="mq lf it mm b gy my ms l mt mu">}</span><span id="472b" class="mq lf it mm b gy my ms l mt mu">function bar(callback: &lt;T&gt;(param: T) =&gt; T) {<br/>  <br/>}</span></pre><h2 id="ff53" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">通用类</h2><p id="2cd1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了创建泛型类，我们可以在字段、方法参数和方法的返回类型中插入类型占位符。</p><p id="73c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下定义一个泛型类:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9945" class="mq lf it mm b gy mr ms l mt mu">class Foo&lt;T&gt; {<br/>  prop: T;</span><span id="bd10" class="mq lf it mm b gy my ms l mt mu">  constructor(param: T) {<br/>    this.prop = param;<br/>  }</span><span id="944d" class="mq lf it mm b gy my ms l mt mu">  bar(): T {<br/>    return this.prop;<br/>  }<br/>}</span></pre><h2 id="1d7f" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">键入别名</h2><p id="56ea" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">泛型类型也可以添加到类型别名中。例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a997" class="mq lf it mm b gy mr ms l mt mu">type Foo&lt;T&gt; = {<br/>  a: T,<br/>  v: T,<br/>};</span></pre><h2 id="9f67" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">接口</h2><p id="47ca" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">同样，我们可以用泛型定义接口，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e7c6" class="mq lf it mm b gy mr ms l mt mu">interface Foo&lt;T&gt; {<br/>  a: T,<br/>  b: T,<br/>}</span></pre><h1 id="9cfc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">传入类型参数</h1><p id="2e14" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于函数，我们可以按如下方式传入类型参数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3cbc" class="mq lf it mm b gy mr ms l mt mu">function foo&lt;T&gt;(param: T): T {  <br/>  return param;<br/>}</span><span id="41f9" class="mq lf it mm b gy my ms l mt mu">foo&lt;number&gt;(1);</span></pre><p id="7fe0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以将类型参数传递给类。当我们实例化一个类时，我们可以如下传入一个类型参数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7893" class="mq lf it mm b gy mr ms l mt mu">class Foo&lt;T&gt; {}<br/>const c = new Foo&lt;number&gt;();</span></pre><p id="43ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">流泛型的一个方便的特性是我们不必自己添加所有的类型。我们可以用一个<code class="fe mv mw mx mm b">_</code>代替一个类型，让Flow为我们推断类型。</p><p id="fd47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="07cb" class="mq lf it mm b gy mr ms l mt mu">class Foo&lt;T, U, V&gt;{}<br/>const c = new Foo&lt;_, number, _&gt;()</span></pre><p id="6252" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让Flow推断出<code class="fe mv mw mx mm b">T</code>和<code class="fe mv mw mx mm b">V</code>的类型。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/b40c040ed10d827217a94c45d98ed6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sXfRAnwdoDns4FOk"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">西蒙·雷伊在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b28f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">行为</h1><p id="d4ff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">泛型是类型的变量。我们可以在代码中用它们代替任何数据类型注释。</p><p id="8d81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以给它们起任何我们喜欢的名字，所以我们可以这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1f07" class="mq lf it mm b gy mr ms l mt mu">function foo&lt;Type1, Type2, Type3&gt;(one: Type1, two: Type2, three: Type3) {<br/>  <br/>}</span></pre><p id="abd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Flow跟踪用泛型类型注释的变量和参数的值，所以我们可以给它赋值一些意想不到的东西。</p><p id="c27e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们编写如下代码，我们会得到一个错误:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b7f1" class="mq lf it mm b gy mr ms l mt mu">function foo&lt;T&gt;(value: T): T {  <br/>  return "foo";<br/>}</span></pre><p id="b522" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们不知道如果<code class="fe mv mw mx mm b">T</code>是一个字符串，我们总是可以在调用<code class="fe mv mw mx mm b">foo</code>时返回一个字符串。</p><p id="be67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，Flow跟踪我们通过泛型传递的值的类型，以便我们以后可以使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5a91" class="mq lf it mm b gy mr ms l mt mu">function foo&lt;T&gt;(value: T): T {<br/>  return value;<br/>}</span><span id="bdfb" class="mq lf it mm b gy my ms l mt mu">let one: 1 = foo(1);</span></pre><p id="aadf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们没有为它传递任何泛型类型参数来标识类型为<code class="fe mv mw mx mm b">1</code>。将<code class="fe mv mw mx mm b">1</code>改为<code class="fe mv mw mx mm b">number</code>也可以:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4621" class="mq lf it mm b gy mr ms l mt mu">let one: number = foo(1);</span></pre><p id="ded1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们省略了泛型函数中的泛型类型参数，Flow将允许我们传入任何内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9ef1" class="mq lf it mm b gy mr ms l mt mu">function logBar&lt;T&gt;(obj: T): T {<br/>  if (obj &amp;&amp; obj.bar) {<br/>    console.log(obj.bar);<br/>  }<br/>  return obj;<br/>}</span><span id="9830" class="mq lf it mm b gy my ms l mt mu">logBar({ foo: 'foo', bar: 'bar' });  <br/>logBar({ bar: 'bar' });</span></pre><p id="532b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过为类型参数指定限制来限制可以传入的内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7c32" class="mq lf it mm b gy mr ms l mt mu">function logBar&lt;T: { bar: string }&gt;(obj: T): T {<br/>  if (obj &amp;&amp; obj.bar) {<br/>    console.log(obj.bar);<br/>  }<br/>  return obj;<br/>}</span><span id="4a13" class="mq lf it mm b gy my ms l mt mu">logBar({ foo: 'foo', bar: 'bar' });  <br/>logBar({ bar: 'bar' });</span></pre><p id="0a4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加上<code class="fe mv mw mx mm b">{ bar: string }</code>之后，那么我们知道传入的任何东西都必须有string <code class="fe mv mw mx mm b">bar</code>属性。</p><p id="7502" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以对原始值做同样的事情:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="36f1" class="mq lf it mm b gy mr ms l mt mu">function foo&lt;T: number&gt;(obj: T): T {<br/>  return obj;<br/>}</span><span id="0070" class="mq lf it mm b gy my ms l mt mu">foo(1);</span></pre><p id="ab43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们尝试传入任何其他类型的数据，都会失败，所以</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c61b" class="mq lf it mm b gy mr ms l mt mu">foo('2');</span></pre><p id="e28d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会给我们一个错误。</p><p id="91a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">泛型允许我们返回比我们在类型参数中指定的更具体的类型。例如，如果我们有一个字符串函数，它返回传入的值:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8253" class="mq lf it mm b gy mr ms l mt mu">function foo&lt;T: string&gt;(val: T): T {<br/>  return val;<br/>}</span><span id="eba5" class="mq lf it mm b gy my ms l mt mu">let f: 'foo' = foo('foo');</span></pre><p id="0241" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以把函数返回值作为类型，而不是把它赋给一个字符串变量。</p><h1 id="7926" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参数化泛型</h1><p id="f714" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以向泛型传递类型，就像向函数传递参数一样。我们可以用类型别名、函数、接口和类来做到这一点。这称为参数化泛型。</p><p id="4a20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建一个参数化泛型类型别名，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="18b6" class="mq lf it mm b gy mr ms l mt mu">type Foo&lt;T&gt; = {<br/>  prop: T,<br/>}</span><span id="42b9" class="mq lf it mm b gy my ms l mt mu">let item: Foo&lt;string&gt; = {<br/>  prop: "value"<br/>};</span></pre><p id="6591" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以对类做同样的事情:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a2f0" class="mq lf it mm b gy mr ms l mt mu">class Foo&lt;T&gt; {<br/>  value: T;<br/>  constructor(value: T) {<br/>    this.value = value;<br/>  }<br/>}</span><span id="fdd1" class="mq lf it mm b gy my ms l mt mu">let foo: Foo&lt;string&gt; = new Foo('foo');</span></pre><p id="60fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于接口，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="52c1" class="mq lf it mm b gy mr ms l mt mu">interface Foo&lt;T&gt; {<br/>  prop: T,<br/>}</span><span id="d46d" class="mq lf it mm b gy my ms l mt mu">class Item {<br/>  prop: string;<br/>}</span><span id="15fb" class="mq lf it mm b gy my ms l mt mu">(Item.prototype: Foo&lt;string&gt;);</span></pre><h1 id="dd1e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参数化泛型的默认类型</h1><p id="2afd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以向参数化泛型添加默认值。例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d54d" class="mq lf it mm b gy mr ms l mt mu">type Item&lt;T: string = 'foo'&gt; = {<br/>  prop: T,<br/>};</span><span id="2051" class="mq lf it mm b gy my ms l mt mu">let foo: Item&lt;&gt; = { prop: 'foo' };</span></pre><p id="e8d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有指定类型，那么假定<code class="fe mv mw mx mm b">prop</code>具有<code class="fe mv mw mx mm b">'foo'</code>类型。</p><p id="caea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着如果我们将类型参数留空，那么<code class="fe mv mw mx mm b">prop</code>的任何其他值都将不起作用。大概是这样的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fb43" class="mq lf it mm b gy mr ms l mt mu">let foo: Item&lt;&gt; = { prop: 'bar' };</span></pre><p id="33d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不会被接受。</p><h1 id="d500" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">方差符号</h1><p id="e580" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当转换泛型类型时，我们可以使用<code class="fe mv mw mx mm b">+</code>符号来允许比赋值类型更广泛的类型。例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5634" class="mq lf it mm b gy mr ms l mt mu">type Foo&lt;+T&gt; = T;</span><span id="6be5" class="mq lf it mm b gy my ms l mt mu">let x: Foo&lt;string&gt; = 'foo';<br/>(x: Foo&lt;number| string&gt;);</span></pre><p id="7c09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，我们可以将<code class="fe mv mw mx mm b">x</code>从类型<code class="fe mv mw mx mm b">Foo&lt;string&gt;</code>转换为类型<code class="fe mv mw mx mm b">Foo&lt;number| string&gt;</code>，并在通用类型<code class="fe mv mw mx mm b">Foo</code>上添加<code class="fe mv mw mx mm b">+</code>符号。</p><p id="f4d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用泛型，我们可以通过用泛型类型标记替换它们来从代码中抽象出类型。我们可以在任何有类型注释的地方使用它们。此外，它可以处理任何流结构，如接口、类型别名、类、变量和参数。</p></div></div>    
</body>
</html>