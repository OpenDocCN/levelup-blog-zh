<html>
<head>
<title>My Journey to Learning Data Structures from Scratch — Stacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我从零开始学习数据结构的旅程—堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-journey-to-learning-data-structures-from-scratch-stacks-1179494fd8f2?source=collection_archive---------3-----------------------#2020-12-01">https://levelup.gitconnected.com/my-journey-to-learning-data-structures-from-scratch-stacks-1179494fd8f2?source=collection_archive---------3-----------------------#2020-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1d24" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是#100DaysOfDSA —堆栈数据结构的第1天</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/854f8db9f3d065342bbea7d0e2638f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvo7eCYWQEjcXXy1AYAu2A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://cdn.programiz.com/sites/tutorial2program/files/stack.png" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="0eff" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Stacks就是单词“stack”的字面意思——一堆东西或一堆东西放在另一堆的上面。那么，你将如何得到处于最底层的东西呢？你将不得不删除所有上述元素，然后访问它，对不对？堆栈数据结构也是如此。放在堆里最后的东西将首先被访问。它被称为<strong class="lf ir">a L</strong>ast-<strong class="lf ir">I</strong>n-<strong class="lf ir">F</strong>first-<strong class="lf ir">O</strong>ut属性。比如MS word <em class="lz">(假设)</em>上的撤销/重做操作，任何代码中的函数调用都是在后端实现stack的很多地方的一部分。</p><p id="5401" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">用于处理这种数据结构的常见操作有—</p><ul class=""><li id="699d" class="ma mb iq lf b lg lh lj lk lm mc lq md lu me ly mf mg mh mi bi translated"><strong class="lf ir"> Push </strong> —在堆栈中插入元素的别名。</li><li id="ddce" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly mf mg mh mi bi translated"><strong class="lf ir"> Pop </strong> —从堆栈中删除元素的别名。</li><li id="5aeb" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly mf mg mh mi bi translated"><strong class="lf ir"> Peek </strong> —从堆栈中获取最顶层元素的别名。</li><li id="2bd1" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly mf mg mh mi bi translated"><strong class="lf ir"> isEmpty </strong> —检查堆栈是否为空。</li><li id="2b00" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly mf mg mh mi bi translated"><strong class="lf ir">大小</strong> —返回堆栈的大小(元素的数量)。</li></ul><p id="1169" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们举个例子，直观地理解所有上述操作的工作原理—</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/244110e0202a257e1f57cc13f628e5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-trOahnhacA7VM0dszgr2A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">堆栈操作的图示视图</figcaption></figure><p id="94d4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">栈可以实现为数组、链表、字符串等，任何你可以实现并控制LIFO属性的东西，本质上都是一个栈。</p><p id="6ef4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因为，我将用Python写所有练习题代码。所以列表别名是，</p><ul class=""><li id="9e11" class="ma mb iq lf b lg lh lj lk lm mc lq md lu me ly mf mg mh mi bi translated"><strong class="lf ir">推</strong> == L.append()</li><li id="6375" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly mf mg mh mi bi translated"><strong class="lf ir"> Pop </strong> == L.pop()</li><li id="0ffa" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly mf mg mh mi bi translated"><strong class="lf ir"> isEmpty </strong> == len(L)==0</li><li id="a029" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly mf mg mh mi bi translated"><strong class="lf ir"> Peek </strong> == L[-1]</li><li id="4921" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly mf mg mh mi bi translated"><strong class="lf ir">尺寸</strong> ==长度(L)</li></ul><p id="4781" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">上面提到的所有操作的时间复杂度都是O(1 ),因为所有的运动只发生在一侧端。</p><p id="4c14" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因此，必须作为实现一部分的一些边缘情况是检查<strong class="lf ir">下溢</strong>和<strong class="lf ir">上溢</strong>问题。下溢是指在栈已经为空的情况下试图弹出或访问。当你试图插入一个已经满了的栈时，就会发生溢出。溢出相对不太可能发生，因为大多数库实现已经将动态分配作为包的一部分实现了。但是，如果你自己编写堆栈类，那么要小心。</p><blockquote class="mp"><p id="f1a6" class="mq mr iq bd ms mt mu mv mw mx my ly dk translated">当使用单链表表示堆栈时，在头部而不是尾部执行所有的操作，以避免任何类型的链表遍历，并保持O(1)复杂度。如果你不知道什么是链表，那么现在忽略它。我们将在未来的博客中再次看到它。</p></blockquote><h2 id="ff89" class="mz na iq bd nb nc nd dn ne nf ng dp nh lm ni nj nk lq nl nm nn lu no np nq nr bi translated">要记住的要点</h2><ol class=""><li id="9f8e" class="ma mb iq lf b lg ns lj nt lm nu lq nv lu nw ly nx mg mh mi bi translated">自然界中最早的<strong class="lf ir"> L </strong> ast <strong class="lf ir"> I </strong> n <strong class="lf ir"> F </strong>最早的<strong class="lf ir"> O </strong> ut。</li><li id="4aab" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly nx mg mh mi bi translated">处理<strong class="lf ir">下溢和上溢。</strong></li><li id="9749" class="ma mb iq lf b lg mj lj mk lm ml lq mm lu mn ly nx mg mh mi bi translated">总是<strong class="lf ir">删除</strong>用于<strong class="lf ir">空间管理的链表实现中的悬空节点。</strong></li></ol><h1 id="174a" class="ny na iq bd nb nz oa ob ne oc od oe nh jw of jx nk jz og ka nn kc oh kd nq oi bi translated">练习题</h1><p id="2d83" class="pw-post-body-paragraph ld le iq lf b lg ns jr li lj nt ju ll lm oj lo lp lq ok ls lt lu ol lw lx ly ij bi translated">请启动并克隆我的GitHub存储库—“<a class="ae kv" href="https://github.com/prakhar21/Learning-Data-Structures-from-Scratch" rel="noopener ugc nofollow" target="_blank">从头开始学习数据结构</a>”，以便在我下次更新存储库时得到通知。</p><div class="om on gp gr oo op"><a href="https://github.com/prakhar21/Learning-Data-Structures-from-Scratch" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">prak har 21/从头开始学习数据结构</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">从零开始学习数据结构#100DaysOfDSA GitHub是5000多万开发人员的家园，他们共同努力…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd kp op"/></div></div></a></div><p id="593a" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="lz"> P.S .截至目前，我已经加了2道练习题。在接下来的3天里，我会做一些与堆栈相关的问题，并在GitHub库中更新它们，作为博客的一部分，我会发布问题陈述。</em></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><blockquote class="mp"><p id="555e" class="mq mr iq bd ms mt mu mv mw mx my ly dk translated">另外，如果你也像我一样对机器学习/自然语言处理等领域感兴趣。请务必在我的YT频道查看详细的<a class="ae kv" href="https://www.youtube.com/channel/UCoz8NrwgL7U9535VNc0mRPA/" rel="noopener ugc nofollow" target="_blank">研究论文演练。</a></p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="4b2d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">干杯！</p></div></div>    
</body>
</html>