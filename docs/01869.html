<html>
<head>
<title>Introduction to JavaScript Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript继承简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-javascript-inheritance-fbb195022fab?source=collection_archive---------17-----------------------#2020-02-03">https://levelup.gitconnected.com/introduction-to-javascript-inheritance-fbb195022fab?source=collection_archive---------17-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/105fadb43e0b746182e50c45cb796301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JnWoA47zJES69075"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@thutra0803?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tra Nguyen </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="335c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种面向对象的语言。然而，它与许多其他面向对象语言的不同之处在于，它使用基于原型的继承，而不是基于类的继承。</p><p id="b571" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于原型的继承意味着对象从它的原型继承项目。原型只是另一个对象，可以被其他对象继承。</p><p id="303f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与基于类的继承不同，因为类是创建新对象的模板。类可以从其他类继承，以重用它所继承的类的代码。</p><h1 id="a6cf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">继承的旧语法</h1><h2 id="9e9f" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">构造函数</h2><p id="d027" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在ES6之前，我们只有构造函数作为创建新对象的模板，这些对象是构造函数的实例。</p><p id="4b30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下定义一个构造函数:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="b2f1" class="mc lf it my b gy nc nd l ne nf">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span></pre><p id="8c24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过编写以下代码来创建一个新的<code class="fe ng nh ni my b">Person</code>实例:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="cda8" class="mc lf it my b gy nc nd l ne nf">let person = new Person('Joe', 10);</span></pre><p id="2a84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要从构造函数中的其他构造函数继承项目，我们必须用<code class="fe ng nh ni my b">call</code>方法调用我们想要继承的父构造函数，然后将我们的构造函数原型的<code class="fe ng nh ni my b">constructor</code>属性设置为我们想要继承的父构造函数。</p><p id="6754" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想让一个<code class="fe ng nh ni my b">Employee</code>构造函数继承<code class="fe ng nh ni my b">Person</code>构造函数的属性，我们可以写:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="dda8" class="mc lf it my b gy nc nd l ne nf">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span><span id="7715" class="mc lf it my b gy nj nd l ne nf">function Employee(name, age, title) {<br/>  this.title = title;<br/>  Person.call(this, name, age);<br/>  this.__proto__.constructor = Person;<br/>}</span><span id="0acd" class="mc lf it my b gy nj nd l ne nf">let employee = new Employee('Joe', 20, 'waiter');<br/>console.log(employee);</span></pre><p id="e040" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni my b">call</code>方法获取我们想要设置的<code class="fe ng nh ni my b">this</code>的值，其余的是我们传递给调用<code class="fe ng nh ni my b">call</code>方法的函数的参数。</p><p id="13e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们查看有原型的<code class="fe ng nh ni my b">employee</code>对象的<code class="fe ng nh ni my b">__proto__</code>属性，我们应该得到它的<code class="fe ng nh ni my b">__proto__.constructor</code>应该是我们设置的<code class="fe ng nh ni my b">Person</code>构造函数。</p><p id="1077" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni my b">employee</code>对象的属性和值应该是我们调用<code class="fe ng nh ni my b">Employee</code>构造函数时传递给它的内容。</p><h2 id="de2d" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">Object.create()</h2><p id="b825" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated"><code class="fe ng nh ni my b">Object.create()</code>方法是我们创建对象时从原型继承的另一种方式。</p><p id="7a6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用的参数是我们希望从它返回的对象继承的原型对象。</p><p id="e78f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用<code class="fe ng nh ni my b">Object.create</code>创建一个带有原型的对象，如下所示:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7d0d" class="mc lf it my b gy nc nd l ne nf">const person = {<br/>  name: 'Joe',<br/>  age: 20<br/>}</span><span id="623e" class="mc lf it my b gy nj nd l ne nf">let employee = Object.create(person);<br/>employee.title = 'waiter';</span><span id="c03b" class="mc lf it my b gy nj nd l ne nf">console.log(employee);</span></pre><p id="ac8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们看一下<code class="fe ng nh ni my b">employee</code>对象，我们将会看到<code class="fe ng nh ni my b">__proto__</code>属性将会为<code class="fe ng nh ni my b">age</code>和<code class="fe ng nh ni my b">name</code>属性设置值。</p><h2 id="a67f" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">直接设置__proto__属性</h2><p id="f99b" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">从ES6开始，官方就支持直接设置<code class="fe ng nh ni my b">__proto__</code>属性，这是一种在Firefox之前在各种浏览器中设置对象原型的非正式方式。</p><p id="c4c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以直接将一个对象设置为<code class="fe ng nh ni my b">__proto__</code>属性，编写如下代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="339b" class="mc lf it my b gy nc nd l ne nf">const person = {<br/>  name: 'Joe',<br/>  age: 20<br/>}</span><span id="0c83" class="mc lf it my b gy nj nd l ne nf">let employee = {<br/>  title: 'waiter'<br/>};</span><span id="a590" class="mc lf it my b gy nj nd l ne nf">employee.__proto__ = person;<br/>console.log(employee);</span></pre><p id="2d1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到属性和值的确切结构，就像我们用<code class="fe ng nh ni my b">Object.create()</code>方法创建一个对象时所做的那样。</p><p id="ad1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须小心的一件事是，如果我们不想改变一个对象的原型，我们不想意外地设置它。如果我们使用JavaScript对象作为地图，这可能会发生。在ES6中，我们可以使用<code class="fe ng nh ni my b">Map</code>对象来实现这个目的。</p><h2 id="596d" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">对象.定义属性</h2><p id="34b4" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们也可以使用<code class="fe ng nh ni my b">defineProperty</code>方法来设置一个对象的原型。例如，我们可以写:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4bfc" class="mc lf it my b gy nc nd l ne nf">const person = {<br/>  name: 'Joe',<br/>  age: 20<br/>}</span><span id="d382" class="mc lf it my b gy nj nd l ne nf">let employee = {<br/>  title: 'waiter'<br/>};</span><span id="5d9d" class="mc lf it my b gy nj nd l ne nf">Object.defineProperty(employee, '__proto__', {<br/>  value: person<br/>});<br/>console.log(employee.__proto__);</span></pre><p id="67c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们记录<code class="fe ng nh ni my b">employee.__proto__</code>的值时，我们得到了<code class="fe ng nh ni my b">person</code>对象。</p><p id="65cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，原型位于<code class="fe ng nh ni my b">defineProperty</code>方法调用的第三个参数的<code class="fe ng nh ni my b">value</code>属性中。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/c3b2ef4bf5ec6693b36b7b2f1e493d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NuO-M8dxwHcgyvFW"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Chiara Daneluzzi 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="0836" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">新的类语法</h1><p id="fd04" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">随着ES6的发布，引入了新的类语法。表面上，看起来我们有基于类的继承，但在表面下，它和以前完全一样。</p><p id="f80f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类语法与构造函数相同。举个例子，</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="3d1c" class="mc lf it my b gy nc nd l ne nf">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span></pre><p id="1784" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以下内容相同:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="a7cd" class="mc lf it my b gy nc nd l ne nf">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>}</span></pre><p id="f30e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写以下代码来实例化这两者:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="75f5" class="mc lf it my b gy nc nd l ne nf">const person = new Person('Joe', 10);</span></pre><p id="33bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们检查它的属性时，我们得到相同的对象。</p><p id="7170" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类语法还创建了一种清晰方便的继承方式，看起来像传统的基于类的继承。</p><p id="0869" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建一个超类，子类可以用<code class="fe ng nh ni my b">extends</code>关键字继承它。例如，我们可以写:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="b6ed" class="mc lf it my b gy nc nd l ne nf">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>}</span><span id="27ab" class="mc lf it my b gy nj nd l ne nf">class Employee extends Person {<br/>  constructor(name, age, title) {<br/>    super(name, age);<br/>    this.title = title;<br/>  }<br/>}</span><span id="5fcd" class="mc lf it my b gy nj nd l ne nf">const employee = new Employee('Joe', 20, 'waiter');</span></pre><p id="3e0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe ng nh ni my b">extends</code>关键字来表示<code class="fe ng nh ni my b">Employee</code>继承自哪个类。我们只能继承一个阶级。</p><p id="dd65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用<code class="fe ng nh ni my b">super</code>方法来调用父构造函数并设置其属性。在这种情况下，调用<code class="fe ng nh ni my b">super</code>将调用<code class="fe ng nh ni my b">Person</code>类中的<code class="fe ng nh ni my b">constructor</code>方法。</p><p id="23a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni my b">this</code>指它在各个阶层里面的阶层。</p><p id="476f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这和我们之前做的完全一样:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="a369" class="mc lf it my b gy nc nd l ne nf">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span><span id="ff96" class="mc lf it my b gy nj nd l ne nf">function Employee(name, age, title) {<br/>  this.title = title;<br/>  Person.call(this, name, age);<br/>  this.__proto__.constructor = Person;<br/>}</span><span id="68cf" class="mc lf it my b gy nj nd l ne nf">let employee = new Employee('Joe', 20, 'waiter');<br/>console.log(employee);</span></pre><p id="d812" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的问题是，当我们检查<code class="fe ng nh ni my b">employee</code>对象时，我们得到的是<code class="fe ng nh ni my b">__proto__.constructor</code>属性显示的是<code class="fe ng nh ni my b">class</code>而不是<code class="fe ng nh ni my b">function</code>。</p><p id="0701" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类语法使得继承比以前更加清晰。从一开始，JavaScript中的原型继承模型就非常需要语法糖。</p><p id="48d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，有了类语法，我们不必再调用父构造函数对象上的<code class="fe ng nh ni my b">call</code>方法并设置<code class="fe ng nh ni my b">this.__proto__.constructor</code>。</p><p id="1778" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比使用<code class="fe ng nh ni my b">Object.create()</code>或者直接设置<code class="fe ng nh ni my b">__proto__</code>属性要好。设置<code class="fe ng nh ni my b">__proto__</code>属性有它的问题，比如不小心设置了错误的原型。</p></div></div>    
</body>
</html>