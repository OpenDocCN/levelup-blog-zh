<html>
<head>
<title>Data structures— Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构—链表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/data-structures-linked-lists-a3cfb0b728ac?source=collection_archive---------18-----------------------#2020-06-18">https://levelup.gitconnected.com/data-structures-linked-lists-a3cfb0b728ac?source=collection_archive---------18-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3fc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">链表的介绍和这种数据结构的一些常用方法。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/0fd5e82b7953567fd70c93dd91f14699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m11VTAK3YJgRemmfBI_2uw.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">来源:<a class="ae ll" href="https://www.programmingsimplified.com/c/data-structures/c-program-implement-linked-list" rel="noopener ugc nofollow" target="_blank">https://www . programming simplified . com/c/data-structures/c-program-implement-linked-list</a></figcaption></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="1dc6" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">什么是链表？</strong></h1><p id="a394" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">单链表是节点的集合，其中每个节点存储两条信息，一些值和指向下一个节点的指针。有双向链表，其中的节点包含指向下一个和上一个节点的指针。在单链表中，有一个头节点或根节点，链表就从这里开始。在双向链表中，有一个头尾节点。单向链表中最后一个节点的next指针将为空。</p><h1 id="e76e" class="lm ln it bd lo lp mp lr ls lt mq lv lw lx mr lz ma mb ms md me mf mt mh mi mj bi translated">链表和数组有什么不同？</h1><p id="0488" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">链表和数组的最大区别在于内存。</p><blockquote class="mu mv mw"><p id="a8f6" class="jq jr mx js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">下面的解释将是对你的计算机内存分配方式的过度简化！</p></blockquote><p id="203a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建数组时，计算机必须分配内存来存储数组中的元素。特别是对于一个数组，你的计算机将总是寻找连续的内存空间。以包含以下元素的数组为例:<code class="fe nb nc nd ne b">['A','B','C',D',E']</code>。您的计算机可能以这种方式存储这些元素:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nf"><img src="../Images/57a1b72b09e7f21e4e7e6d3d13011cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZimY6VRf2vJOXLA69xQ4Q.png"/></div></div></figure><p id="39d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个方块可以被认为是你计算机中的一个内存地址。请注意，元素存储在连续的内存地址中。数组没有存储在上面的4个空方块中，因为它正好需要5个空内存地址。如果我们不断向数组中添加元素，并且没有连续的空内存槽，计算机将复制并移动整个数组来寻找更多的空间。这一过程可能非常繁重，想象一下，如果要处理包含超过1，000，000个元素的数组，您的计算机将需要找到1，000，000个连续的内存插槽！</p><p id="902b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是链表的魅力所在。对于单链表中的每个节点，我们需要两个内存槽，一个用于值，另一个指向链表中的下一个节点。现在，因为我们的节点有一个指向下一个节点的指针，所以节点不需要保存在连续的内存槽中。如果我们把初始数组转换成一个链表，它可以像这样存储:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nf"><img src="../Images/cd21261efcf1936a715e1645a15d4d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIP07BWF2dyE-74n1zfBGg.png"/></div></div></figure><p id="8490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的值存储在一个内存地址中，有一个指针包含下一个节点的内存地址，因此有了箭头。有了链表，我们的节点不必连续存储！</p><h1 id="3a4c" class="lm ln it bd lo lp mp lr ls lt mq lv lw lx mr lz ma mb ms md me mf mt mh mi mj bi translated">如何创建一个链表</h1><p id="9c3e" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我们必须以某种方式创建这些节点来存储一个值和一个指向下一个节点的指针。在JavaScript中做到这一点的一个好方法是使用类。我们将创建一个节点类和一个链表类。</p><pre class="kw kx ky kz gt ng ne nh ni aw nj bi"><span id="a8e1" class="nk ln it ne b gy nl nm l nn no">class Node{<br/>    constructor(val,next=null){<br/>        this.val = val<br/>        this.next = next<br/>    }<br/>}</span><span id="119c" class="nk ln it ne b gy np nm l nn no">class LinkedList {    <br/>    constructor(r=null){        <br/>        this.root = r        <br/>        this.size =0    <br/>    }<br/>}</span></pre><p id="01fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了自己的类，让我们给<code class="fe nb nc nd ne b">LinkedList </code>类添加一些方法。首先，我们将创建一个向链表添加节点的方法。通常，当我们向链表中添加节点时，我们会将它们添加到链表的前面或头部。这允许我们在O(1)时间执行这个插入。</p><p id="2bf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">添加节点:</strong></p><pre class="kw kx ky kz gt ng ne nh ni aw nj bi"><span id="cb3c" class="nk ln it ne b gy nl nm l nn no">add(node){        <br/>    if (this.root === null){            <br/>        this.root = node        <br/>    } else {            <br/>        node.next = this.root            <br/>        this.root = node        <br/>    }        <br/>    this.size++    <br/>}</span></pre><p id="bd75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码在链表的前面添加了一个节点。我们首先检查是否已经有一个节点，如果有，更新新节点和前一个头的指针。如果不是，将新节点设置为链表的头部。</p><p id="e293" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">寻找节点:</strong></p><p id="8139" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了找到一个具有特定值的节点，我们必须从链表的头部开始遍历它。</p><pre class="kw kx ky kz gt ng ne nh ni aw nj bi"><span id="5403" class="nk ln it ne b gy nl nm l nn no">find(value){        <br/>    let thisNode = this.root        <br/>    let position = 1        <br/>    while (thisNode !== null){            <br/>        if (thisNode.value === value){                <br/>            return position            <br/>        } else {                <br/>            thisNode = thisNode.next                <br/>            position ++            <br/>        }        <br/>    }        <br/>    return false    <br/>}</span></pre><p id="d96c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用while循环遍历整个链表，直到找到我们的值，否则返回false，因为没有找到值。变量<code class="fe nb nc nd ne b">thisNode</code>用于跟踪当前节点，我们通过访问<code class="fe nb nc nd ne b">thisNode.next</code>来更新节点。这是一个O(n)运算，因为它依赖于链表的长度。</p><p id="4211" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">删除节点:</strong></p><p id="e9dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从链表中移除一个节点有点棘手。我们不仅需要跟踪当前节点来遍历链表，还需要跟踪前一个节点。这是因为一旦我们找到想要的节点，我们必须更新前一个节点的指针，这样我们就不会丢失链表的其余部分。</p><pre class="kw kx ky kz gt ng ne nh ni aw nj bi"><span id="1c35" class="nk ln it ne b gy nl nm l nn no">delete(value){        <br/>    let thisNode = this.root        <br/>    let prevNode = null        <br/>    let position = 1         <br/>    while (thisNode !== null){            <br/>        if (thisNode.value === value){                <br/>            if (prevNode === null){                    <br/>                this.root = thisNode.next                    <br/>                thisNode.next = null                    <br/>                return position                <br/>               }                <br/>            prevNode.next = thisNode.next                <br/>            thisNode.next = null                <br/>            return position             <br/>         } else {                <br/>              prevNode = thisNode                <br/>              thisNode = thisNode.next                <br/>              position++            <br/>         }        <br/>      }         <br/>    return false    <br/>}</span></pre><p id="c783" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">在位置:</strong>插入节点</p><p id="043a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在特定位置插入节点的过程类似于删除节点。我们必须跟踪当前和先前的节点，但不是删除它，而是通过更新先前节点和当前节点的指针来添加节点。</p><pre class="kw kx ky kz gt ng ne nh ni aw nj bi"><span id="2f64" class="nk ln it ne b gy nl nm l nn no">insertBeforeAtPosition(nodeToInsert,insertPosition){        <br/>    let thisNode = this.root        <br/>    let prevNode = null        <br/>    let position = 1         <br/>    while (thisNode !== null){            <br/>        if (insertPosition === position){                <br/>            nodeToInsert.next = thisNode                <br/>            prevNode.next = nodeToInsert                <br/>            this.size++                <br/>            return             <br/>         } else {                <br/>            prevNode = thisNode                <br/>            thisNode = thisNode.next                <br/>            position++            <br/>            }        <br/>    }        <br/>    return false    <br/>}</span></pre><h1 id="e743" class="lm ln it bd lo lp mp lr ls lt mq lv lw lx mr lz ma mb ms md me mf mt mh mi mj bi translated">包扎</h1><p id="eb56" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">还有很多关于链表的信息，但是希望我能给你一些基础，让你开始学习这种数据结构的更复杂的方面。例如，尝试编码如何反转一个链表！</p></div></div>    
</body>
</html>