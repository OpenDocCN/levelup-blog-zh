<html>
<head>
<title>Understanding Local Scope in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的局部范围</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-fundamentals-local-scope-5841690ea6aa?source=collection_archive---------4-----------------------#2019-07-07">https://levelup.gitconnected.com/javascript-fundamentals-local-scope-5841690ea6aa?source=collection_archive---------4-----------------------#2019-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="143b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">JavaScript基础知识</em>系列作用域、提升、闭包</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ea230d23cb3ec7402046f955b31fb83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oCcxSjAM1SK-wuAM"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7e10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lc" href="https://medium.com/@smeyradvrn/javascript-fundamentals-global-scope-71ba5e48dbae" rel="noopener"> <strong class="jp ir"> <em class="kl">在我之前的文章</em> </strong> </a>中，我们深入探讨了全球范围。如果您感到不安全，或者想快速浏览一下，我鼓励您先阅读它，因为在本文中我们将提到全局范围。</p><p id="216d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您曾经编写过JavaScript代码，您可能已经通过使用函数创建了局部作用域。通过在函数中创建一个变量，你创建了一个局部范围，而不是全局范围。</p><blockquote class="ld le lf"><p id="85a6" class="jn jo kl jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">在函数内部创建变量时会出现局部作用域。通过这样做，变量的可见性和可访问性只允许在该函数中使用。</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lj"><img src="../Images/84c2f890b552930f805982d391ff4611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kTeSUP0V2UIgOmavp-TDg.png"/></div></div></figure><p id="bf02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在黄色框中创建的任何变量都是局部变量，就像蓝色框中的任何变量都是全局变量一样。为了超级容易理解，蓝框代表全局范围，而黄框代表局部范围。</p><p id="9b43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，要理解一个局部变量/范围是不可能通过一个图像和一个描述来实现的。让我们看看另一张图片。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lk"><img src="../Images/a53c01eb1fa80262f08732781bc1a6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NydrUTYskUaM1y8HQVenNw.png"/></div></div></figure><p id="5700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">局部变量不同于全局变量，理解起来更复杂。这个演示展示了本地作用域的基本行为/概念。如果你创建不同的函数，你基本上为每个函数创建了不同的作用域。为了理解基本行为，我们可以使用控制台，查看不同范围内变量的错误和可访问性。</p><pre class="kn ko kp kq gt ll lm ln lo aw lp bi"><span id="6a48" class="lq lr iq lm b gy ls lt l lu lv">var <strong class="lm ir">globalOne</strong>=16;</span><span id="b70f" class="lq lr iq lm b gy lw lt l lu lv">function testingScope(){<br/>  var <strong class="lm ir">localOne</strong>=12;<br/>  console.log(<strong class="lm ir">localOne</strong>); // 12<br/>  console.log(<strong class="lm ir">globalOne</strong>); // 16<br/>}</span><span id="79f8" class="lq lr iq lm b gy lw lt l lu lv">testingScope() // 12 and 16</span><span id="13b1" class="lq lr iq lm b gy lw lt l lu lv">console.log(<strong class="lm ir">localOne</strong>); // Uncaught ReferenceError: localOne is not defined</span><span id="ab73" class="lq lr iq lm b gy lw lt l lu lv">console.log(<strong class="lm ir">globalOne</strong>); // 16</span></pre><p id="ebed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们的变量<code class="fe lx ly lz lm b">globalOne</code> <strong class="jp ir"> </strong>是一个全局变量，我们可以在任何地方访问它。但是<code class="fe lx ly lz lm b">localOne</code> <strong class="jp ir"> </strong>变量只能在其作用域内访问。这就是为什么如果我们调用<code class="fe lx ly lz lm b">testingScope</code>函数，我们可以在控制台中看到这两个变量。</p><p id="8801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在全局范围内，我们只能访问全局变量，这些变量存储在<code class="fe lx ly lz lm b">window</code>对象中。与全局变量不同，局部变量是不可访问的，一旦其作用域结束就会被销毁。当函数被调用时，它们留在内存中，一旦函数完成，它们就消失了。这就是为什么只有在执行它们的功能时才能访问它们。这是全局变量和局部变量的主要区别之一。</p><h1 id="bfee" class="ma lr iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">功能范围和块范围的区别</strong></h1><p id="abc3" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">到目前为止，我们已经看到了局部范围，但实际上，我不是很清楚。在现实中，局部作用域可以分为两个作用域:函数作用域和块作用域。在ES6之前，JavaScript只有函数作用域，这是我到目前为止一直在解释的。</p><p id="4112" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">当变量在函数内部定义时，函数作用域出现。</em></p><p id="e902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这么简单。另一方面，块范围是ES6引入的，略有不同。您可以使用块作用域创建函数作用域的子集。</p><p id="082c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在 <code class="fe lx ly lz lm b"><strong class="jp ir"><em class="kl">{}</em></strong></code>之间使用blocks <em class="kl">任何东西，那么<code class="fe lx ly lz lm b">if</code>、<code class="fe lx ly lz lm b">switch</code>、<code class="fe lx ly lz lm b">for</code>、<code class="fe lx ly lz lm b">while</code>只有用<code class="fe lx ly lz lm b"><strong class="jp ir"><em class="kl">let</em></strong></code> <strong class="jp ir"> <em class="kl">和</em> </strong> <code class="fe lx ly lz lm b"><strong class="jp ir"><em class="kl">const</em></strong></code>定义一个变量才能使用block作用域。这是一个很长的描述，我认为如果我在控制台中显示它，我可以解释得更好。</em></p><pre class="kn ko kp kq gt ll lm ln lo aw lp bi"><span id="d4b6" class="lq lr iq lm b gy ls lt l lu lv">if(‘anything returning true’){<br/>  let <strong class="lm ir">localVariable</strong>=12;<br/>  var <strong class="lm ir">otherLocalVariable</strong>=10;<br/>  console.log(<strong class="lm ir">localVariable</strong>); // 12<br/>  console.log(<strong class="lm ir">otherLocalVariable</strong>); // 10<br/>}</span><span id="deb3" class="lq lr iq lm b gy lw lt l lu lv">console.log(<strong class="lm ir">localVariable</strong>) // Uncaught ReferenceError: localVariable is not defined</span><span id="43ae" class="lq lr iq lm b gy lw lt l lu lv">console.log(<strong class="lm ir">otherLocalVariable</strong>) // 10</span></pre><p id="323b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看到他们的行为了吗？用<code class="fe lx ly lz lm b"><strong class="jp ir">let</strong></code>定义的<code class="fe lx ly lz lm b">localVariable</code>，仅在块内可见。用<code class="fe lx ly lz lm b"><strong class="jp ir">var</strong></code>定义的<code class="fe lx ly lz lm b">otherLocalVariable</code>，在程序块外可见。不同的行为是因为<code class="fe lx ly lz lm b">var</code>、<code class="fe lx ly lz lm b">let</code>、<code class="fe lx ly lz lm b">const</code>的不同。因此，了解它们之间的差异对于理解块范围非常重要。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nc"><img src="../Images/96d3e4fec4be459c952384b846b4463b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILpUdflpCK38UTesUHphxg.png"/></div></div></figure><h1 id="647c" class="ma lr iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">可变阴影</strong></h1><p id="463a" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">如果你要在一个函数中重新赋值一个变量，有一个概念你应该知道:变量隐藏。</p><p id="f3d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JavaScript中，当您先在全局范围内定义变量，然后在局部范围内定义变量时，局部变量优先。只有当它们共享相同的名称时，才会出现阴影。在全局范围内，变量保留它的初始值，但是在局部范围内，它的值会临时更改为您重新分配的值。让我们看一个例子:</p><pre class="kn ko kp kq gt ll lm ln lo aw lp bi"><span id="8a3d" class="lq lr iq lm b gy ls lt l lu lv">let <strong class="lm ir">simpleVariable</strong>=’global scope’</span><span id="34a9" class="lq lr iq lm b gy lw lt l lu lv">function testingVariableShadowing(){<br/>  <strong class="lm ir">simpleVariable</strong>=’local scope’; // reassignment<br/>  console.log(simpleVariable);<br/>}</span><span id="28b5" class="lq lr iq lm b gy lw lt l lu lv">testingVariableShadowing(); // local scope</span><span id="2b63" class="lq lr iq lm b gy lw lt l lu lv">console.log(simpleVariable); // global scope</span></pre><p id="1be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在全局作用域中，<code class="fe lx ly lz lm b"><strong class="jp ir">simpleVariable</strong></code> <strong class="jp ir">的</strong>值仍然是全局作用域，而在函数作用域中被调用时，它变成了局部作用域。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="ceca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想阅读更多关于JavaScript基础的内容，请阅读学习JavaScript基础系列。</p><ol class=""><li id="c87b" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated"><a class="ae lc" href="https://medium.com/swlh/javascript-fundamentals-global-scope-71ba5e48dbae?source=post_page---------------------------" rel="noopener">全局范围</a></li><li id="278f" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated"><a class="ae lc" href="https://medium.com/@smeyradvrn/javascript-fundamentals-local-scope-5841690ea6aa?source=post_page---------------------------" rel="noopener">局部范围</a></li><li id="db10" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated"><a class="ae lc" href="https://medium.com/@smeyradvrn/learn-javascript-fundamentals-scope-context-execution-context-9fe8673b3164?source=post_page---------------------------" rel="noopener">范围、上下文、执行上下文</a></li></ol></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="55f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码快乐！！！</p></div></div>    
</body>
</html>