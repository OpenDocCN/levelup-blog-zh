# 围棋界面的实用方面

> 原文：<https://levelup.gitconnected.com/practical-aspects-of-interfaces-in-go-53a088b9b361>

![](img/47fa390373307ccba46eeabd9533c4ed.png)

Josue Michel 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

关于 Go 中的接口有很多很好的讨论，其中一些是我的，但是我想提交一篇关于实践方面的更抽象的文章。为此，我们首先需要讨论编程语言中接口的概念。

## 编程中的接口是什么？

从概念上讲，接口就是抽象地定义应该由某个东西实现的特定行为集。一门语言可能会完全忽略这个概念，或者用接口、协议、鸭类型或其他机制来实现这个概念。

考虑一个发票系统，要生成一张发票，你只需要知道一个项目的价格和它是否需要纳税。一种方法是定义一个*可开票* *接口*，描述两个行为，价格和应税，任何你想添加到发票上的项目，一辆汽车，一个香蕉，一只鸭子，只需要*实现* *可开票*。从概念上讲，这可以在运行时完成，在运行时动态地询问项目的兼容性，或者在编译时完成，在编译时编译器必须能够确定项目实现了接口。两个众所周知的具体例子是 Java 中的 *Iterable* 接口，由集合实现以提供统一的内容访问，或者 Go 中的 *Stringer* 接口，由任何想要提供字符串表示的对象实现。

## Go 中的接口有什么值得注意的

Go 提供了在编译时强制执行的接口。如果你在代码中指出某个东西需要*可调用*，那么只有当这个东西实际上实现了*可调用*接口时，代码才会被编译。有很多方法可以破坏这一点，但是相信这种说法通常是没问题的。

> 关于 Go 的实现值得注意的是，它不需要像 Java 那样将项目显式标记为实现 Invoiceable，而是在编译时查询项目。

## 赞成的意见

Go 方法的优点是接口的存在与应用它的项目是分离的。被询问的物品需要事先不知道该接口。您可以在您的代码*中定义*可调用*，并从第三方代码中测试一些东西，如果该项目实现了*可调用*的行为，代码将会正确编译并运行。这是一种非常灵活的方法，仍然可以在编译时执行。*

## 骗局

Go 的分离方法对于维护代码来说也是有问题的。考虑这样一个场景，第三方将他们的*价格*方法全局重命名为*项目价格*。编译器将获得并报告他们的*项*不再是*可调用的*，然而，无论你在哪里使用他们代码的接口，都会到处报告。它可能会非常强大和分散，使得隔离问题变得非常棘手。

对于这个问题，有一个可以采用的程序修复方法，即在一个逻辑集中的位置显式地执行以下操作:

```
var (
   _ Invoiceable = (*honda.Vehicle)(nil)
   _ Invoiceable = (*chevy.Truck)(nil)
   _ Invoiceable = (*autozone.Part)(nil)
)
```

这不是魔术，它只是创建一个中心位置，编译器将在这里询问第三方项目是否符合可调用接口。虽然您仍然会收到所有零散的编译器投诉，但现在您会从某个地方收到一个主要投诉，它会立即提示您问题的本质。