<html>
<head>
<title>Using TypeScript infer Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专家一样使用TypeScript推断</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-typescript-infer-like-a-pro-f30ab8ab41c7?source=collection_archive---------0-----------------------#2022-08-16">https://levelup.gitconnected.com/using-typescript-infer-like-a-pro-f30ab8ab41c7?source=collection_archive---------0-----------------------#2022-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d99ae7840ef35f45a92a4de5d9fdaf20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBqCtQb4pF9wMRsmJWCDzA.jpeg"/></div></div></figure><p id="95f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">欢迎来到<strong class="kd iu">掌握打字稿</strong>系列。本系列将以动画的形式介绍TypeScript的核心知识和技术。让我们一起学习吧！以前的文章如下:</p><ul class=""><li id="1de8" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener"><strong class="kd iu">TypeScript泛型中的K，T，V是什么？</strong> </a></li><li id="257c" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://javascript.plainenglish.io/using-typescript-mapped-types-like-a-pro-be10aef5511a" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">使用TypeScript像Pro一样映射类型</strong> </a></li><li id="3b5a" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://javascript.plainenglish.io/use-typescript-conditional-types-like-a-pro-7baea0ad05c5" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">使用TypeScript条件类型像亲</strong> </a></li><li id="b03a" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac" rel="noopener"> <strong class="kd iu">使用TypeScript模板字面类型像亲</strong> </a></li><li id="f23a" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://javascript.plainenglish.io/15-utility-types-that-every-typescript-developer-should-know-6cf121d4047c" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">打字稿可视化:15种最常用的实用类型</strong> </a></li></ul><p id="cd5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道如何获取<strong class="kd iu"> T0 </strong>数组类型中元素的类型和<strong class="kd iu"> T1 </strong>函数类型中返回值的类型吗？给自己几秒钟考虑一下。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="601b" class="lx ly it lt b gy lz ma l mb mc">type T0 = string[];<br/>type T1 = () =&gt; string;</span></pre><p id="7110" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用TypeScript — <strong class="kd iu">条件类型</strong>和<strong class="kd iu">推断</strong>提供的类型模式匹配技术来完成前面的需求。</p><p id="194e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">条件类型允许我们检测两个类型之间的关系，通过条件类型，我们可以确定两个类型是否兼容。<strong class="kd iu"> Infer用于声明类型变量，以存储模式匹配期间捕获的类型。</strong></p><p id="f413" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看如何捕获T0数组类型中的元素类型:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="82fe" class="lx ly it lt b gy lz ma l mb mc">type UnpackedArray&lt;T&gt; = T extends (infer U)[] ? U : T<br/>type U0 = UnpackedArray&lt;T0&gt; <em class="md">// string</em></span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b0bfda7c93bbbef901c472684118b651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QYosoPtbYDB4-DHe3LdEQ.jpeg"/></div></div></figure><p id="e3b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，<code class="fe me mf mg lt b">T extends (infer U)[] ? U : T</code>是条件类型的语法，extends子句<strong class="kd iu">中的<code class="fe me mf mg lt b">infer U</code>引入了一个新的类型变量U来存储推断的类型</strong>。</p><p id="3a3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更好地理解，让我们演示一下UnpackedArray实用程序类型的执行流程。</p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/14dcc7314abe501231e240a25556c5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6oVhepFr5msy4rDnyGZL3g.gif"/></div></div></figure><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/636a19b3aefac0da4a8357bb9fb29d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mki-531FqeSL6R5dhWbhCA.jpeg"/></div></div></figure><p id="47ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">需要注意的是，infer只能在条件类型的extends子句中使用，infer声明的类型变量只能在条件类型的true分支中使用。</strong></p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="76e0" class="lx ly it lt b gy lz ma l mb mc">type Wrong1&lt;T extends (infer U)[]&gt; = T[0] <em class="md">// Error</em><br/>type Wrong2&lt;T&gt; = (infer U)[] extends T ? U : T <em class="md">// Error</em><br/>type Wrong3&lt;T&gt; = T extends (infer U)[] ? T : U <em class="md">// Error</em></span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fd6fb79947e64614eca62244102bcf43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCmZyfK87mEcC_ptmCkosQ.jpeg"/></div></div></figure><p id="bf0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">了解了这些知识之后，让我们看看如何获得T1函数类型的返回类型:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="c69e" class="lx ly it lt b gy lz ma l mb mc">type UnpackedFn&lt;T&gt; = T extends (...args: any[]) =&gt; infer U ? U : T;<br/><br/>type U1 = UnpackedFn&lt;T1&gt;; <em class="md">// string</em></span></pre><p id="4249" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看了UnpackedFn实用程序类型的实现之后，是不是看起来很简单？<strong class="kd iu">谈到函数重载场景，TypeScript会使用最后一次调用签名进行类型推断。</strong></p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/736a493e17cdeaf354a69b20408eb4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lz2fwMi7ewywvkUqfihXKA.gif"/></div></div></figure><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/434c863e2b94145416c7fb919a269f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKBjBp7jZxE-SaVW-0o8lQ.jpeg"/></div></div></figure><p id="412c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您不熟悉TypeScript的条件类型，可以阅读本文。</p><div class="mi mj gp gr mk ml"><a href="https://javascript.plainenglish.io/use-typescript-conditional-types-like-a-pro-7baea0ad05c5" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">像专家一样使用TypeScript条件类型</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">用动画解释。掌握TypeScript条件类型并理解TypeScript的内置实用工具如何类型化…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jz ml"/></div></div></a></div><p id="0a8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的文章中，我们介绍了条件链接，它允许我们实现更强大的解包实用程序类型。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="9f1d" class="lx ly it lt b gy lz ma l mb mc">type Unpacked&lt;T&gt; =<br/>    T extends (infer U)[] ? U :<br/>    T extends (...args: any[]) =&gt; infer U ? U :<br/>    T extends Promise&lt;infer U&gt; ? U :<br/>    T;<br/><br/>type T0 = Unpacked&lt;string&gt;;  <em class="md">// string</em><br/>type T1 = Unpacked&lt;string[]&gt;;  <em class="md">// string</em><br/>type T2 = Unpacked&lt;() =&gt; string&gt;;  <em class="md">// string</em><br/>type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;;  <em class="md">// string</em><br/>type T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;;  <em class="md">// Promise&lt;string&gt;</em><br/>type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;;  <em class="md">// string</em></span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c70f205f5856bf79cbc46139e0851821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oaZYXNhOsAKMKkIulFa-Tg.jpeg"/></div></div></figure><p id="8a19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，解包的实用程序类型利用条件类型和条件链来轻松推断数组类型中元素的类型、函数类型的返回值的类型以及承诺类型的返回值的类型。</p><p id="e2ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实上，使用条件类型和推断，我们还可以推断出对象类型中键的类型。接下来，我们举一个具体的例子:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="227c" class="lx ly it lt b gy lz ma l mb mc">type User = {<br/>  id: number;<br/>  name: string;<br/>}<br/><br/>type PropertyType&lt;T&gt; =  T extends { id: infer U, name: infer R } ? [U, R] : T</span><span id="0b51" class="lx ly it lt b gy na ma l mb mc">type U3 = PropertyType&lt;User&gt; <em class="md">// [number, string]</em></span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/0a1aa943fd300e31877bcecacc1cd9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KMdWfFlRiu3X2rDulKBJNg.gif"/></div></div></figure><p id="d8bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在PropertyType实用程序类型中，我们使用infer来声明两个类型变量U和R，它们分别表示对象类型中id和name属性的类型。如果类型匹配，我们将id和name属性的类型作为一个元组返回。</p><p id="8877" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">现在问题来了，如果在PropertyType实用程序类型中只声明了一个类型变量U，会有什么结果？</strong>下面我们来验证一下。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e9a6" class="lx ly it lt b gy lz ma l mb mc">type PropertyType&lt;T&gt; =  T extends { id: infer U, name: infer U } ? U : T<br/><br/>type U4 = PropertyType&lt;User&gt; <em class="md">// string | number</em></span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/e46c5117d1b06bdc25889814e2139370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cIpYsHmPh2zhmODEUvmqMg.gif"/></div></div></figure><p id="68c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的代码可以看出，U4类型返回字符串和数字类型的并集。为什么会返回这样的结果？<strong class="kd iu">这是因为如果在协变位置有多个相同类型变量的候选，最终类型将被推断为联合类型。</strong></p><p id="a702" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，在逆变位置，如果同一个类型变量有多个候选，最终的类型将被推断为交集类型。让我们再次验证这一点:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="a26f" class="lx ly it lt b gy lz ma l mb mc">type Bar&lt;T&gt; = T extends { a: (x: infer U) =&gt; void, b: (x: infer U) =&gt; void } ? U : never;<br/><br/>type U5 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: number) =&gt; void }&gt;;  <em class="md">// string &amp; number</em></span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/8065da10a0f9a57c3d36cbe6d07cb05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aR9BMh4fax6NbQp4SbroiQ.gif"/></div></div></figure><p id="e464" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，U5类型返回一个由字符串和数字类型组成的交集类型，即最终类型是never类型。</p><p id="6dd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">最后，让我介绍一个在TypeScript 4.7中引入的与infer相关的新特性，它使infer类型推断更加简洁。</strong>在介绍与infer相关的新特性之前，我们先来看一个例子:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="9409" class="lx ly it lt b gy lz ma l mb mc">type FirstIfString&lt;T&gt; = T extends [infer S, ...unknown[]]<br/>  ? S extends string<br/>    ? S<br/>    : never<br/>  : never;</span></pre><p id="9556" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，<strong class="kd iu"> FirstIfString </strong>实用程序类型使用TypeScript的条件类型、条件链和infer类型推断。在第一个条件类型中，我们确定类型参数T的实际类型是否为非空元组类型，并在模式匹配期间使用infer声明类型变量S以存储捕获的元组类型的第一个元素的类型。</p><p id="fdba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第二个条件类型中，我们继续判断类型变量S是否是字符串类型的子类型，如果满足条件则返回类型变量S对应的类型，否则条件类型的所有假分支都将返回never类型。</p><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在介绍了<strong class="kd iu"> FirstIfString </strong>实用程序类型的功能后，让我们验证一下它的功能。</p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/147871901d34f405545abfc4b2f2214b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RonzeqpKk1zFRl5ajjjlA.jpeg"/></div></div></figure><p id="acb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的结果可以看出，<strong class="kd iu"> FirstIfString </strong>实用程序类型工作正常。现在问题来了，既然实用程序类型内部使用了两个条件类型，我们能使用一个条件类型来实现相同的功能吗？<strong class="kd iu"> TypeScript 4.7允许我们向infer类型添加可选的extends子句，以指定对类型变量的显式约束。</strong></p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5994" class="lx ly it lt b gy lz ma l mb mc">type FirstIfString&lt;T&gt; =<br/>    T extends [infer S extends string, ...unknown[]]<br/>        ? S<br/>        : never;</span></pre><p id="46db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相比之前的代码，是不是感觉干净了很多？看完这篇文章，相信你已经明白了条件类型的用途和推断。那么你能理解<strong class="kd iu"> UnionToIntersection </strong>实用程序类型的具体实现吗？</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="100d" class="lx ly it lt b gy lz ma l mb mc">type UnionToIntersection&lt;U&gt; = (<br/>  U extends any ? (arg: U) =&gt; void : never<br/>) extends (arg: infer R) =&gt; void<br/>  ? R<br/>  : never</span></pre><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/211e3ee2897e3296c818c13fa3618ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TbpmyDoLEWxqyJznbCeLA.jpeg"/></div></div></figure><p id="6bdf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢学习动画形式的TypeScript，可以在<a class="ae li" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或者<a class="ae li" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，了解更多关于TS和JS的内容！</p><h1 id="3554" class="nb ly it bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">资源</h1><div class="mi mj gp gr mk"><div role="button" tabindex="0" class="ab bv gv cb fp ny nz bn oa jz ex"><div class="ob l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw oc od fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l oc od fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----f30ab8ab41c7--------------------------------" rel="noopener follow" target="_top">字节优先</a></p></div></div><div class="og oh gw l"><h2 class="bd iu tr kz fp ts fr fs mr fu fw is bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tt au tu tv tw qb tx an eh ei ty tz ua el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----f30ab8ab41c7--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="ub l fo"><span class="bd b dl z dk">46 stories</span></div></div></div><div class="ot dh ou fp ab ov fo di"><div class="di ol bv om on"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di ol bv oo op oq"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div><div class="di bv or os oq"><div class="dh l"><img alt="" class="dh" src="../Images/3bcc671d9b1ca5776fec258eed5450d4.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*_U9uNpcZaTLX4u4B"/></div></div></div></div></div><div class="mi mj gp gr mk ml"><a href="https://github.com/microsoft/TypeScript/pull/21496" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">ahejsberg Pull Request # 21496 Microsoft/TypeScript在条件类型中进行类型推理</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">这个PR引入了在条件类型(#21316)中使用类型推断的能力，为…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="oz l mw mx my mu mz jz ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://javascript.plainenglish.io/use-typescript-conditional-types-like-a-pro-7baea0ad05c5" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">像专家一样使用TypeScript条件类型</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">用动画解释。掌握TypeScript条件类型并理解TypeScript的内置实用工具如何类型化…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jz ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#extends-constraints-on-infer-type-variables" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">发布TypeScript 4.7</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">今天，我们很高兴地宣布TypeScript 4.7的可用性！如果您还不熟悉TypeScript，它是一个…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">devblogs.microsoft.com</p></div></div><div class="mu l"><div class="pa l mw mx my mu mz jz ml"/></div></div></a></div></div></div>    
</body>
</html>