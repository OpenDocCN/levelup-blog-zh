<html>
<head>
<title>100 C++ Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">100个C++面试问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/100-c-interview-questions-e7b9b90e373e?source=collection_archive---------0-----------------------#2021-06-06">https://levelup.gitconnected.com/100-c-interview-questions-e7b9b90e373e?source=collection_archive---------0-----------------------#2021-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="ffcb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.OOP是什么？</h1><p id="88a8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">OOP代表面向对象编程。OOP是一种依赖于类和对象概念的编程范式。它用于将软件程序构建成简单的可重用代码蓝图(通常称为类)，这些代码蓝图用于创建对象的单个实例。</p><p id="8d0a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">C是一种过程化的语言，而C++是一种面向对象的语言，因为它有类并且可以利用多态性。</p><h1 id="c028" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.什么是课？</h1><p id="b6e0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">类是反映实体属性和动作的蓝图。从技术上讲，定义一个类就是设计一个用户定义的数据类型。下面是一个简单的C++示例类。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8420" class="ma jr it lw b gy mb mc l md me">class Window {</span><span id="b5a2" class="ma jr it lw b gy mf mc l md me">public:<br/>     Window();<br/>     ~Window();</span><span id="4247" class="ma jr it lw b gy mf mc l md me">};</span></pre><h1 id="ba2f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">3.什么是对象？</h1><p id="e6fe" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一个类的实例称为对象</p><p id="2806" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以像这样创建一个窗口对象:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="e5cf" class="ma jr it lw b gy mb mc l md me">Window window;</span></pre><p id="2688" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这是窗口类的一个实例，即一个窗口对象。</p><h1 id="2716" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">4.列出C++中支持的继承类型</h1><p id="31ed" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="kq iu">单一继承</strong> —派生类只继承一个基类。它允许继承自基类(也称为父类或超类)的特性的可重用性。</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/a0357226db18538ba0de7f344fe08fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*B2AytnzsjBeATetb5qtXAQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">单一遗传</figcaption></figure><p id="36b6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这里有一些伪代码，带有一个类<strong class="kq iu">基类</strong>和它的派生类<strong class="kq iu">派生类</strong>。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0683" class="ma jr it lw b gy mb mc l md me">class base_class {<br/>     // code<br/>};</span><span id="e335" class="ma jr it lw b gy mf mc l md me">class derived_class : <strong class="lw iu">&lt;access modifier&gt;</strong> base_class {<br/>     // code<br/>};</span><span id="d851" class="ma jr it lw b gy mf mc l md me">int main() {</span><span id="34fc" class="ma jr it lw b gy mf mc l md me">     base_class object1;</span><span id="3a80" class="ma jr it lw b gy mf mc l md me">     derived_class object2;</span><span id="8e46" class="ma jr it lw b gy mf mc l md me">}</span></pre><p id="6cf0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在显示<strong class="kq iu"> &lt;访问修饰符&gt; </strong>的地方，你可以使用<strong class="kq iu"> public </strong>、<strong class="kq iu"> private </strong>或<strong class="kq iu"> protected </strong>。</p><p id="ba19" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">多重继承</strong> —派生类有多个基类</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f996e55d877196f7d77edbd9889c6e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*RO8jPpFXwybb2H5m_7KpKw.png"/></div></figure><p id="dc5d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">以下是一些伪代码示例:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7b38" class="ma jr it lw b gy mb mc l md me">class base_class1 {<br/>     // code<br/>};</span><span id="e3ff" class="ma jr it lw b gy mf mc l md me">class base_class2 {<br/>     // code<br/>};</span><span id="73fb" class="ma jr it lw b gy mf mc l md me">class derived_class : <strong class="lw iu">&lt;access modifier&gt;</strong> base_class1, <strong class="lw iu">&lt;access modifier&gt;</strong> base_class2 {<br/>     // code<br/>};</span><span id="13d1" class="ma jr it lw b gy mf mc l md me">int main() {</span><span id="0097" class="ma jr it lw b gy mf mc l md me">derived_class object;</span><span id="5f96" class="ma jr it lw b gy mf mc l md me">}</span></pre><p id="4932" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">层次继承</strong> —从单个基类创建多个派生类时。</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/b382365791e6e3026426cfc990a28911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*rKHcno9eqdjVerqddc3kAg.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">分层继承</figcaption></figure><p id="84a2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">下面是一些伪代码来说明</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3295" class="ma jr it lw b gy mb mc l md me">class base_class {<br/>     // code<br/>};</span><span id="4f6f" class="ma jr it lw b gy mf mc l md me">class derived_class1 : <strong class="lw iu">&lt;access modifier&gt;</strong> base_class {<br/>     // code<br/>};</span><span id="8a1d" class="ma jr it lw b gy mf mc l md me">class derived_class2 : <strong class="lw iu">&lt;access modifier&gt;</strong> base_class {<br/>     // code<br/>};</span><span id="b8ea" class="ma jr it lw b gy mf mc l md me">class derived_class3 : <strong class="lw iu">&lt;access modifier&gt;</strong> base_class {<br/>     // code<br/>};</span><span id="f1a2" class="ma jr it lw b gy mf mc l md me">int main() {</span><span id="fc28" class="ma jr it lw b gy mf mc l md me">derived_class object;</span><span id="cde4" class="ma jr it lw b gy mf mc l md me">}</span></pre><p id="7aad" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">多级继承— </strong>当一个派生类是从另一个派生类创建的。例如，你可以说子类有一个父类和一个祖父类。</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c1a0a53e301ba075940750c2d21db536.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*7WBldVJYw1D-N_xObjse_Q.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">多层次继承</figcaption></figure><p id="c1e7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">下面是一个伪代码示例:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1978" class="ma jr it lw b gy mb mc l md me">class base_class {<br/>     // code<br/>};</span><span id="7015" class="ma jr it lw b gy mf mc l md me">class derived_class1 : <strong class="lw iu">&lt;access modifier&gt;</strong> base_class {<br/>     // code<br/>};</span><span id="aa5f" class="ma jr it lw b gy mf mc l md me">class derived_class2 : <strong class="lw iu">&lt;access modifier&gt;</strong> derived_class1 {<br/>     // code<br/>};</span><span id="be39" class="ma jr it lw b gy mf mc l md me">int main() {</span><span id="b710" class="ma jr it lw b gy mf mc l md me">derived_class2 object;</span><span id="00c1" class="ma jr it lw b gy mf mc l md me">}</span></pre><p id="af99" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">混合遗传— </strong>这是一种以上遗传类型的结合。这有时也被称为<strong class="kq iu">多路径</strong> <strong class="kq iu">继承</strong>。</p><p id="a1d7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">下面显示了一个示例，但这不是唯一可能的配置。</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/2aa3016c5c389e06d3988c6981785629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*cIzR9Nkf1CogfepdIoKyHQ.png"/></div></figure><h1 id="518d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">5.受保护访问说明符的作用是什么？</h1><p id="fdc6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">类成员被声明为<strong class="kq iu"> protected </strong>可以被类的成员函数和友元(类或函数)使用。此外，它们可以由从类派生的类使用。</p><h1 id="5ef6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">6。什么是封装？</h1><p id="b58c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将数据和作用于数据的功能绑定在一个实体(类)中的过程</p><h1 id="c68b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">7.什么是抽象？</h1><p id="5364" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">抽象是指隐藏内部实现，只展示必要的细节。</p><h1 id="3619" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">8.什么是内联函数？</h1><p id="36d5" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">内联函数是对编译器的一种建议，建议将该函数视为一个宏。这比正常调用函数要快。编译器会在编译时将函数的内容粘贴到执行指令中，而不是在运行时使用子例程。</p><p id="9072" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">示例:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f6f4" class="ma jr it lw b gy mb mc l md me">Class A {<br/>public:<br/>     inline int add(int a, int b) { return (a + b); }</span><span id="70ec" class="ma jr it lw b gy mf mc l md me">};</span></pre><p id="73c5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">或者</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6104" class="ma jr it lw b gy mb mc l md me">Class A {<br/>public: <br/>     int add(int a, int b);</span><span id="eb6b" class="ma jr it lw b gy mf mc l md me">};</span><span id="60cb" class="ma jr it lw b gy mf mc l md me">inline int A::add(int a, int b) { return (a + b); }</span></pre><h1 id="5032" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">9.什么是存储类？</h1><p id="8921" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">定义变量和/或函数的范围和寿命。这些说明符位于它们所修改的类型之前。这些是C++存储类:</p><ul class=""><li id="1038" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll mx my mz na bi translated">汽车</li><li id="3c30" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">注册</li><li id="1b76" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">静电</li><li id="9ec7" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">走读生</li><li id="f42f" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">易变的</li></ul><p id="544b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">自动存储类</strong></p><p id="85ef" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">自动存储类是所有局部变量的默认存储类。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6d32" class="ma jr it lw b gy mb mc l md me">void myFunction() {<br/>int a;<br/>auto int b;<br/>}</span></pre><p id="3921" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这两个变量具有相同的存储类。Auto只能在函数中使用，即。局部变量。</p><p id="05c2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">寄存器存储类</strong></p><p id="9463" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">用于定义应该在寄存器而不是RAM中定义的局部变量。这意味着变量的最大大小等于寄存器大小(通常是一个字)，并且不能应用一元' &amp; '运算符(因为它没有内存位置)</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="ef6c" class="ma jr it lw b gy mb mc l md me">{<br/>     register int miles;<br/>}</span></pre><p id="a258" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">应该只用于需要快速访问的变量，如计数器。<strong class="kq iu">寄存器</strong>是给编译器的一个<em class="ng">建议</em>，并不保证变量会存储在寄存器中。</p><p id="bfb6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">静态存储类</strong></p><p id="0dbf" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">静态</strong>存储类指示编译器在程序的生命周期中保持一个局部变量的存在，而不是在每次进入和离开范围时创建和销毁它。因此，将局部变量设为静态允许它们在函数调用之间保持它们的值。</p><p id="85a8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">静态修饰符也可以应用于全局变量。当这样做时，它会导致该变量的范围被限制在声明它的文件中。</p><p id="3e0e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">外部存储类</strong></p><p id="62b7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">extern存储类用于提供对所有程序文件可见的全局变量的引用。当使用extern时，变量不能被初始化，因为它所做的只是将变量名指向一个先前定义的存储位置。</p><p id="013e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当你有多个文件并且你定义了一个全局变量或函数，这个变量或函数也将在其他文件中使用，那么extern将在另一个文件中使用以给出引用或函数。</p><p id="af11" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">第一个文件:main.cpp</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="bab3" class="ma jr it lw b gy mb mc l md me">#include &lt;iostream&gt;<br/>int count ;<br/>extern void write_extern();<br/> <br/>main() {<br/>   count = 5;<br/>   write_extern();<br/>}</span></pre><p id="ce07" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">第二个文件:support.cpp</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="742e" class="ma jr it lw b gy mb mc l md me">#include &lt;iostream&gt;<br/><br/>extern int count;<br/><br/>void write_extern(void) {<br/>   std::cout &lt;&lt; "Count is " &lt;&lt; count &lt;&lt; std::endl;<br/>}</span></pre><p id="1198" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">可变存储类</strong></p><p id="bd44" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">可变说明符只适用于类对象。它允许对象的成员覆盖常量成员函数。也就是说，可变成员可以被常量成员函数修改。</p><p id="07d7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">可变存储类说明符仅用于类数据成员，以使其可修改，即使该成员是声明为const的对象的一部分。不能将可变说明符与声明为static、const或引用成员的名称一起使用。</p><p id="27a7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在下面的<strong class="kq iu">示例中</strong></p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="30dd" class="ma jr it lw b gy mb mc l md me">class A<br/>{<br/>   public:<br/>   A() : x(4), y(5) { };<br/>   mutable int x;<br/>   int y;<br/>};<br/><br/>int main()<br/>{<br/>   const A var2;<br/>   var2.x = 345;<br/>   // var2.y = 2345;<br/>}</span></pre><p id="86ba" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">编译器不允许var2.y = 2345赋值，因为var2已被声明为const。编译器将允许赋值var2.x = 345，因为A::x已被声明为可变的。</p><h1 id="761d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">10.什么是虚函数？</h1><p id="cb46" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">C++虚函数是您在派生类中重新定义的基类成员函数。它是使用虚拟关键字声明的。</p><p id="d8c3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">它用来告诉编译器对函数执行动态链接或后期绑定。</p><p id="d244" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">有必要使用单个指针来引用不同类的所有对象。因此，我们创建了指向基类的指针，该指针引用了所有的派生类对象，但是，当基类指针包含派生类对象的地址时，总是执行基类函数。这个问题只能使用“虚拟”功能解决。</p><p id="8426" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当函数成为虚拟函数时，C++根据基类指针指向的对象类型来决定在运行时调用哪个函数。</p><p id="fd66" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">虚函数的规则</p><ul class=""><li id="e852" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll mx my mz na bi translated">虚函数必须是某个类的成员</li><li id="8788" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">虚函数不能是静态成员</li><li id="d746" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">它们是通过对象指针来访问的</li><li id="0cf1" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">他们可以是另一个阶层的朋友</li><li id="c176" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">即使不使用虚函数，也必须在基类中定义它。</li><li id="3d29" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">基类和所有派生类的虚函数的原型必须相同。如果两个函数同名但原型不同，C++会认为它们是重载函数</li><li id="b63a" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">我们不能有虚构造函数，但是我们可以有虚析构函数</li></ul><h1 id="3fc7" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">11.什么是纯虚函数？</h1><p id="ac24" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">纯虚函数不执行任何任务，它只是一个占位符。这是一个什么都不做的函数。包含纯虚函数的类不能用来声明它自己的对象，这样的类被称为抽象基类。</p><p id="f353" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">基类的主要目标是为派生类提供特征，并创建用于实现运行时多态性的基指针。</p><p id="72d8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">纯虚函数可以定义为:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="da01" class="ma jr it lw b gy mb mc l md me">virtual void display()= 0;</span></pre><p id="1610" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">让我们看一个简单的例子:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8776" class="ma jr it lw b gy mb mc l md me">using namespace std;<br/>class Base {<br/>public:<br/>     virtual void show() = 0;</span><span id="c3cd" class="ma jr it lw b gy mf mc l md me">};</span><span id="3a26" class="ma jr it lw b gy mf mc l md me">class Derived : public Base {<br/>public: <br/>     void show() {<br/>          std::cout &lt;&lt; "Derived class is derived from the base class" &lt;&lt; std::endl;</span><span id="3442" class="ma jr it lw b gy mf mc l md me">     }</span><span id="65a0" class="ma jr it lw b gy mf mc l md me">};</span></pre><h1 id="9d19" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">12.引用和指针有什么区别？</h1><p id="e9f5" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">引用和指针都可以用来在一个函数内部改变另一个函数的局部变量。当大对象作为参数传递给函数或从函数返回时，它们都可以用来保存大对象的副本，从而提高效率。尽管有以上相似之处，引用和指针之间还是有以下不同之处。</p><p id="825a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">引用没有指针强大。</p><ol class=""><li id="6d33" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll nh my mz na bi translated">引用一旦创建，以后就不能引用另一个对象；它不能被重新拔插。这通常是通过指针来实现的。</li><li id="a36e" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll nh my mz na bi translated">引用不能为空，指针经常被设置为空，以表明它们没有指向任何有效的东西。</li><li id="a6f6" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll nh my mz na bi translated">引用在声明时必须初始化。指针没有这种限制。</li></ol><p id="bb6a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">由于上述限制，C++中的引用不能用于实现链表、树等数据结构。在Java中，引用没有上述限制，可以用来实现所有的数据结构。引用在Java中更强大，这是Java不需要指针的主要原因。</p><p id="2c4b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">参考更安全、更易于使用:</p><ol class=""><li id="6ab8" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll nh my mz na bi translated">更安全:由于引用必须初始化，所以类似于通配符指针的通配符引用不太可能存在。仍然有可能存在不指向有效位置的引用。</li><li id="46bc" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll nh my mz na bi translated">更容易使用:引用不需要解引用操作符来访问值。它们可以像普通变量一样使用。需要&amp; operator。</li></ol><h1 id="8687" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">13.什么是多态性？</h1><p id="01ee" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">多态这个词的意思是“多种形式”。</p><p id="5633" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">C++中有两种类型的多态性:</p><ul class=""><li id="f784" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll mx my mz na bi translated">编译时多态性</li><li id="0fc7" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">运行时多态性</li></ul><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/1797a063662212cf64f0dcc3d91397ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kQw4ZoGCH0zzCQyvctsiA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">[1]</figcaption></figure><p id="660d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">为了在C++中拥有运行时多态性，需要三样东西</p><ol class=""><li id="1130" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll nh my mz na bi translated">基类和派生类</li><li id="4732" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll nh my mz na bi translated">基类和派生类中具有相同名称的函数，这样就可以执行所谓的覆盖的<strong class="kq iu">函数</strong></li><li id="4ce4" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll nh my mz na bi translated">指向或引用派生类的对象的基类类型的指针或引用。</li></ol><h1 id="8664" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">14.这个指针是什么？</h1><p id="1613" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">this指针作为隐藏参数传递给所有非静态成员函数调用，并作为所有非静态函数体内的局部变量。这个指针是一个常量指针，保存当前对象的内存地址。该指针在静态成员函数中不可用，因为静态成员函数可以在没有任何对象(带有类名)的情况下被调用</p><h1 id="a6c0" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">15.什么是VTABLE和VPTR？</h1><p id="1e60" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">vtable是一个函数指针表。它是按类维护的。VPTR是指向vtable的指针。它是按对象维护的。编译器在两个地方添加了额外的代码来维护和使用vtable和vptr。</p><ol class=""><li id="b17e" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll nh my mz na bi translated">每个构造函数中的代码。这段代码设置正在创建的对象的vptr。这段代码将vptr设置为指向类的vtable。</li><li id="97b4" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll nh my mz na bi translated">多态函数代码失败。无论在哪里进行多态调用，编译器都会插入代码，首先使用基类指针或引用查找vptr。(在上面的例子中，由于指向的引用对象是派生类型，所以访问派生类的vptr)一旦获取了vptr，就可以访问派生类的vtable。使用vtable，访问并调用派生类函数show()的地址。</li></ol><h1 id="f545" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">16.区分浅层拷贝和深层拷贝</h1><p id="3669" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一般来说，如果一个对象的变量是动态分配的，那么就需要进行深度复制来创建该对象的副本。</p><p id="4409" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">浅抄:</strong></p><p id="fc52" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在浅层复制中，通过简单地复制原始对象的所有变量的数据来创建对象。如果对象的任何变量都没有在内存的堆部分定义，那么这样做很好。如果有些变量是从堆段动态分配内存的，那么被复制的对象变量也将引用相同的内存位置。</p><p id="b2d3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这将产生歧义和运行时错误悬空指针。因为两个对象都将引用同一个内存位置，所以一个对象所做的更改也会反映到另一个对象中。因为我们想要创建对象的副本，所以浅拷贝不能满足这个目的。</p><p id="3902" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">注意:C++编译器隐式创建一个复制构造函数并重载赋值运算符，以便在编译时执行浅层复制。</p><p id="aff6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">深度复制:</strong></p><p id="b559" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在深度复制中，对象是通过复制所有变量的数据来创建的，它还为对象分配具有相同值的相似内存资源。为了执行深度复制，我们需要显式地定义复制构造函数，并在需要时分配动态内存。此外，还需要为其他构造函数中的变量动态分配内存。</p><h1 id="e9c4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> 17。什么是C++中的抽象类？</strong></h1><p id="18db" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">至少有一个纯虚函数的类。我们不能实例化一个抽象类</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7fe0" class="ma jr it lw b gy mb mc l md me">class abstractClass {</span><span id="a277" class="ma jr it lw b gy mf mc l md me">public: </span><span id="4f5b" class="ma jr it lw b gy mf mc l md me">     virtual void show() = 0;<br/>};</span></pre><h1 id="7316" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">18.静态成员关键字对类成员变量有什么作用？</h1><p id="9572" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">静态变量确实存在，尽管没有创建相应类的对象。静态成员变量在为各自的类创建的所有对象之间共享一个公共内存。可以使用类名本身引用静态成员变量。</p><h1 id="5f81" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">19.命名可用于在C++中存储宽字符的数据类型</h1><p id="2a21" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">wchar_t</p><h1 id="1097" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">20.用来访问类成员的操作符是什么？</h1><p id="608f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">点(。)和箭头(-&gt;)</p><h1 id="4a06" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">21.什么是函数重载？</h1><p id="462d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用唯一的参数列表定义多个同名函数。</p><h1 id="9571" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">22.什么是运算符重载？</h1><p id="6845" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">针对类对象为现有操作员定义新作业。您将在类定义中重载一个运算符。</p><p id="0d30" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">示例:重载+运算符以将两个帐户对象相加。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8c1e" class="ma jr it lw b gy mb mc l md me">class Account {</span><span id="652f" class="ma jr it lw b gy mf mc l md me">    Account operator+(const Account&amp; account) {<br/>        Account newAccount;<br/>        newAccount.users = this-&gt;users + account.users;<br/>        newAccount.profit = this-&gt;profit + account.profit;<br/>    }</span><span id="816f" class="ma jr it lw b gy mf mc l md me">};</span></pre><h1 id="c8f9" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">23.在C++中我们有字符串原始数据类型吗？</h1><p id="d373" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不，它是来自STL(标准模板库)的一个类</p><h1 id="02fa" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">24.命名C++中的默认标准流。</h1><p id="af19" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">cin，cout，cerr和木屐</p><p id="96e2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">使用cout: </strong>使用cout打印调试输出</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="ae66" class="ma jr it lw b gy mb mc l md me">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="99db" class="ma jr it lw b gy mf mc l md me">int main() {<br/>     cout &lt;&lt; "hello world!" &lt;&lt; endl;<br/>     return 0;<br/>}</span></pre><p id="c27a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">使用cin </strong>:使用cin从用户那里获得控制台输入</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8b52" class="ma jr it lw b gy mb mc l md me">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="cb66" class="ma jr it lw b gy mf mc l md me">int main() {<br/>     int input = 0;<br/>     cout &lt;&lt; "Enter a number: " &lt;&lt; endl;<br/>     cin &gt;&gt; input;<br/>     return 0;<br/>}</span></pre><p id="ebdf" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">使用cerr </strong>:初学C++的程序员使用cout来显示错误，使用标准输出来调试他们的程序，但是使用cerr来显示错误总是一个好的做法。</p><p id="37f8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这是因为您可以稍后更改错误流，将错误写入文件，而不是将错误流显示在屏幕上。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1e6e" class="ma jr it lw b gy mb mc l md me">#include &lt;iostream&gt;<br/>#include &lt;fstream&gt;<br/>using namespace std;</span><span id="5330" class="ma jr it lw b gy mf mc l md me">int main() {</span><span id="3175" class="ma jr it lw b gy mf mc l md me">     char filename[] = "data.txt";<br/>     if stream infile(fileName);</span><span id="0c0d" class="ma jr it lw b gy mf mc l md me">     if(infile)<br/>          cout &lt;&lt; infile.rdbuf();<br/>     else<br/>          cerr &lt;&lt; "Error while opening the file " &lt;&lt; fileName &lt;&lt; endl;</span><span id="9b5a" class="ma jr it lw b gy mf mc l md me">     return 0;</span><span id="8bf0" class="ma jr it lw b gy mf mc l md me">}</span></pre><p id="5836" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">使用clog </strong> : clog和cerr都与stderr相关联，但它与cerr的不同之处在于，clog中的流是缓冲的，不会自动与cout绑定。</p><p id="9f86" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">缓冲输出比无缓冲输出更有效。在缓冲输出的情况下，所有的输出都保存在一个变量中，并一次性写入磁盘。对于无缓冲输出，我们必须不断写入磁盘。</p><p id="38f4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于严重错误，缓冲输出不是首选。在系统崩溃的情况下，可能会出现这样一种情况，即输出仍然在缓冲区中，没有写入磁盘，并且无法检索错误消息。我们不能在系统崩溃的情况下丢失错误数据，所以我们继续将关键错误写入磁盘，即使这样会更慢。</p><p id="e428" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">clog通常用于日志记录。对于非关键事件日志记录，效率更重要，因此clog比cerr更受欢迎。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8ba4" class="ma jr it lw b gy mb mc l md me">#include &lt;iostream&gt;<br/>#include &lt;fstream&gt;<br/>using namespace std;</span><span id="b18b" class="ma jr it lw b gy mf mc l md me">int main() {<br/>     char fileName[] = "data.txt";<br/>     ifstream infile(fileName);</span><span id="4e03" class="ma jr it lw b gy mf mc l md me">     if(infile) <br/>          cout &lt;&lt; infile.rdbuf();<br/>     else<br/>          clog &lt;&lt; "Error while opening the file " &lt;&lt; fileName &lt;&lt; endl;<br/>     return 0;</span><span id="8287" class="ma jr it lw b gy mf mc l md me">}</span></pre><p id="65bb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这将打印控制台，类似于如果您使用cout，但它会更有效。</p><p id="380b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果您希望clog和stream操作符写入文件而不是控制台，您需要将输出重定向到文件。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="19b0" class="ma jr it lw b gy mb mc l md me">#include &lt;iostream&gt;<br/>#include &lt;fstream&gt;</span><span id="5bba" class="ma jr it lw b gy mf mc l md me">int main() {<br/>    std::ofstream out("test.txt");<br/>   <br/>    // get the rdbuf of clog<br/>    // we need it to reset the value before exiting<br/>    auto old_rdbuf = std::clog.rdbuf();</span><span id="c1d9" class="ma jr it lw b gy mf mc l md me">    // set the rdbuf of clog<br/>    std::clog.rdbuf(out.rdbuf());</span><span id="33a9" class="ma jr it lw b gy mf mc l md me">    // write to clog<br/>    // The output should go to test.txt<br/>    std::clog &lt;&lt; "Test test test/n";</span><span id="6b9f" class="ma jr it lw b gy mf mc l md me">    // reset the rdbuf of clog<br/>    std::clog.rdbuf(old_rdbuf);</span><span id="20a8" class="ma jr it lw b gy mf mc l md me">     return 0;</span><span id="f156" class="ma jr it lw b gy mf mc l md me">}</span></pre><h1 id="712d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">25.多态性的利弊是什么？</h1><p id="69ca" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="kq iu">优点:</strong></p><ul class=""><li id="8940" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll mx my mz na bi translated">它帮助程序员在编写、测试和实现之后重用代码和类。它们可以以多种方式重用。</li><li id="701f" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">单个变量名可以用来存储多种数据类型的变量(float、double、long、int等)</li><li id="950c" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">多态性有助于减少不同功能之间的耦合</li></ul><p id="51f3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">缺点:</strong></p><ul class=""><li id="ebba" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll mx my mz na bi translated">多态性的缺点之一是开发人员发现很难在代码中实现多态性。</li><li id="8c96" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">运行时多态性会导致性能问题，因为机器需要决定调用哪个方法或变量，所以它基本上会降低性能，因为决策是在运行时做出的。</li><li id="63ea" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">多态性降低了程序的可读性。人们需要识别程序的运行时行为来识别实际的执行时间。</li></ul><h1 id="6057" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">26.什么是名称空间？</h1><p id="aab7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">名称空间是一个声明性区域，它为其中的标识符(类型、函数、变量等的名称)提供了一个范围。命名空间用于将代码组织到逻辑组中，并防止可能发生的名称冲突，尤其是当您的代码库包含多个库时。</p><p id="c72e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">命名空间范围内的所有标识符彼此可见，没有限定。命名空间之外的标识符可以通过使用每个标识符的完全限定名来访问成员，例如</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0409" class="ma jr it lw b gy mb mc l md me">std::vector&lt;std::string&gt; vec;</span></pre><p id="491b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">或者通过对单个标识符的“使用声明”</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="a9ba" class="ma jr it lw b gy mb mc l md me">using std::string</span></pre><p id="b8b7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">或者对名称空间中的所有标识符使用“using指令”</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2890" class="ma jr it lw b gy mb mc l md me">using namespace std;</span></pre><p id="97e5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">头文件中的代码应该始终使用完全限定的命名空间名称。(不要在头文件中使用名称空间std，而是在需要时使用std::来代替)</p><p id="ddf6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">下面的示例显示了命名空间声明以及命名空间之外的代码访问其成员的三种方式。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="a2b5" class="ma jr it lw b gy mb mc l md me">namespace MyNameSpace {<br/>     class MyClass {<br/>     public:<br/>          void doSomething();<br/>     };</span><span id="ef11" class="ma jr it lw b gy mf mc l md me">     void Func(MyClass) {}<br/>}</span></pre><p id="d67d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">使用完全限定名</p><p id="e9cb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">(记住在头文件中始终使用完全限定名)</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="80ce" class="ma jr it lw b gy mb mc l md me">MyNameSpace::MyClass object;<br/>object.doSomething();<br/>MyNameSpace::Func(object);</span></pre><p id="c145" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">使用using声明将一个标识符带入范围:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1ca7" class="ma jr it lw b gy mb mc l md me">using MyNameSpace::MyClass;</span><span id="b33b" class="ma jr it lw b gy mf mc l md me">MyClass object;<br/>object.doSomething();<br/>Func(object);</span></pre><h1 id="038b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">27.结构和类的区别是什么？</h1><p id="7a50" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="kq iu">结构— </strong></p><ul class=""><li id="a47b" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll mx my mz na bi translated">默认情况下，该结构的成员是公共的</li><li id="701b" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">当从类/结构派生结构时，基类/结构的默认访问说明符是公共的。</li></ul><p id="3f47" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">类— </strong></p><ul class=""><li id="3f4d" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll mx my mz na bi translated">默认情况下，该类的成员是私有的</li><li id="0bd7" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated">当派生类时，默认访问说明符是私有的</li></ul><h1 id="5766" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> 28。C++中有哪些不同的数据类型？</strong></h1><p id="3a90" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面给出了C++中的4种数据类型。</p><ul class=""><li id="37cb" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll mx my mz na bi translated"><strong class="kq iu">原始数据类型</strong>(基本数据类型)——如char、short、int、float、long、double bool等。</li><li id="8787" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="kq iu">派生的数据类型</strong> —如数组、指针等。</li><li id="44e4" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="kq iu">枚举</strong> —例如枚举</li><li id="c8f3" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="kq iu">用户定义的数据类型</strong>——如结构、类等。</li></ul><h1 id="637e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">奖金1。解释volatile关键字的用途</h1><p id="4700" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">volatile关键字用于告诉编译器该值可能会随时改变，而编译器在附近找到的代码不会采取任何行动。实际上，这种情况主要发生在三种情况下。</p><ol class=""><li id="2a0a" class="ms mt it kq b kr lm kv ln kz mu ld mv lh mw ll nh my mz na bi translated">存储器映射外设寄存器</li><li id="2f25" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll nh my mz na bi translated">由中断服务程序修改的全局变量</li><li id="c002" class="ms mt it kq b kr nb kv nc kz nd ld ne lh nf ll nh my mz na bi translated">多线程应用程序中多个任务访问的全局变量。</li></ol><p id="234a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以像这样声明一个可变变量:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="ae93" class="ma jr it lw b gy mb mc l md me">volatile uint16_t x;</span></pre><p id="fe7a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">或者像这样:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c788" class="ma jr it lw b gy mb mc l md me">uint16_t volatile x;</span></pre><p id="5cae" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">将volatile关键字放在数据类型之前还是之后并不重要。</p><p id="a244" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">以下是指向可变变量的指针:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="ac85" class="ma jr it lw b gy mb mc l md me">volatile uint8_t * p_reg;<br/>// OR<br/>uint8_t volatile * p_reg;</span></pre><p id="a120" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你甚至可以有一个指向可变变量的可变指针:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="393d" class="ma jr it lw b gy mb mc l md me">uint16_t * volatile * volatile p_y;</span></pre><h1 id="60ae" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><p id="4ff7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[1]<a class="ae nn" href="https://www.interviewbit.com/cpp-interview-questions/" rel="noopener ugc nofollow" target="_blank">https://www.interviewbit.com/cpp-interview-questions/</a></p></div></div>    
</body>
</html>