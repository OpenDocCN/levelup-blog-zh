<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Clean Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践——干净的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-clean-code-f1730db3441d?source=collection_archive---------16-----------------------#2020-04-27">https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-clean-code-f1730db3441d?source=collection_archive---------16-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d4aac5dd40de5e831fa783fae45c8d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ym4NIe0OHJogYilS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@cdc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">疾控中心</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="a982" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="13d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些保持JavaScript代码整洁易读的方法，这样修改代码就变得轻而易举了。</p><h1 id="2122" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">保持代码有条理</h1><p id="75d4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的JavaScript代码应该组织得很好，这样它们就很容易理解。组织良好的代码不要重复任何东西。</p><p id="c256" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">里面的函数和类都只做一件事，仅此而已。它们基本上是相互独立的，它们只向外部世界公开需要的东西，这是避免紧密耦合的最低要求。</p><p id="e9a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们从一开始就干净利落地组织事情，这很容易做到。例如，我们可以编写以下代码来保持整洁:</p><p id="f810" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">fruit.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7ecf" class="mt lf it mk b gy mu mv l mw mx">export class Fruit {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span></pre><p id="5b0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">person.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5747" class="mt lf it mk b gy mu mv l mw mx">export class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span></pre><p id="23af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">index.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b904" class="mt lf it mk b gy mu mv l mw mx">import { Fruit } from "./fruit";<br/>import { Person } from "./person";<br/>const sentence = `${new Person("foo").name} likes ${new Fruit("apple").name}`;<br/>console.log(sentence);</span></pre><p id="3d63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有3个模块。前2、<code class="fe mh mi mj mk b">person.js</code>和<code class="fe mh mi mj mk b">fruit.js</code>都有一个类。</p><p id="640b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们每个人都有一个类，而这个类只代表一件事。<code class="fe mh mi mj mk b">Person</code>类代表一个人，<code class="fe mh mi mj mk b">Fruit</code>类代表一种水果。</p><p id="bbc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">index.js</code>中，我们将它们都导入，并在字符串中引用它们。</p><p id="fd85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按照我们组织代码的方式，这些类不会相互引用。每个类只做一件事，我们只在必要的时候引用这些类。</p><h1 id="2791" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要写聪明的代码</h1><p id="3fb5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">聪明的代码是不好的，因为它们通常难以阅读，即使它们通常更短。</p><p id="e11a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单的解决方案比巧妙的代码更易于维护。聪明但难读的代码不好，因为它们很难理解。</p><p id="07b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面的代码是一个聪明但难以阅读的代码的例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6aba" class="mt lf it mk b gy mu mv l mw mx">const foo = bar ? bar ? qux ? 0 : 1 : 2 : 3;</span></pre><p id="9cbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在一行中使用了一系列嵌套的三元运算符，这比直接写出每个<code class="fe mh mi mj mk b">if</code>语句要短，但很难读懂。</p><p id="6e99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很多人可能不明白它在做什么。他们必须在脑子里写出括号，这样他们才能知道每个三元运算的开始和结束。</p><p id="16e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该像那样使用嵌套的三元运算符。相反，我们应该编写use <code class="fe mh mi mj mk b">if</code>语句，或者只使用三元运算符来为一个条件返回这样或那样的结果。</p><p id="c1fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调试比编程更难，我们经常要重新访问旧代码进行调试和更改。因此，我们不应该通过编写难以阅读的聪明代码来使我们的工作变得更加困难。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/4b7c215f2443850c7e704fd19faeca11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BPra8qlaWunKybDR"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@wildfernstudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Charis Gegelman </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="6e0d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">以易于测试的方式拆分代码</h1><p id="aaed" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的代码应该以一种易于测试的方式来组织。这意味着它们应该向外部公开，以便可以用单元测试对它们进行测试。</p><p id="0e66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还应该致力于编写纯函数。对于给定的一组输入，纯函数总是返回相同的输出。这意味着它们很容易被测试。</p><p id="87cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数中的副作用应该被最小化，这样我们在测试时就不必检查函数之外的代码的正确性。</p><p id="4144" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写如下代码和测试:</p><p id="8b2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">math.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fb22" class="mt lf it mk b gy mu mv l mw mx">const add = (a, b) =&gt; a + b;<br/>const subtract = (a, b) =&gt; a - b;<br/>module.exports = { add, subtract };</span></pre><p id="8bfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">math.test.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4dfa" class="mt lf it mk b gy mu mv l mw mx">const { add, subtract } = require('./math');</span><span id="a279" class="mt lf it mk b gy mz mv l mw mx">test('adds 1 + 2 to equal 3', () =&gt; {<br/>  expect(add(1, 2)).toBe(3);<br/>});</span><span id="7e2b" class="mt lf it mk b gy mz mv l mw mx">test('adds 1 - 2 to equal -1', () =&gt; {<br/>  expect(subtract(1, 2)).toBe(-1);<br/>});</span></pre><p id="c78c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mh mi mj mk b">math.js</code>和我们想要测试的函数。它们都是纯函数，所以对于给定的一组输入，它们总是返回相同的输出。</p><p id="2b81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">math.test.js</code>中，我们用Jest运行2个测试来测试我们从<code class="fe mh mi mj mk b">math.js</code>模块导入的2个函数。</p><p id="fe77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用了<code class="fe mh mi mj mk b">add</code>和<code class="fe mh mi mj mk b">subtract</code>来测试它们，并用Jests内置的<code class="fe mh mi mj mk b">expect</code>和<code class="fe mh mi mj mk b">toBe</code>方法检查它们的值。</p><p id="81d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望以这种方式组织我们的代码，这样我们就可以轻松地公开它们进行测试。</p><p id="4c8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它们没有副作用，因此可以自行测试，而无需检查外部代码的结果。</p><h1 id="1b5f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9363" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">代码组织对于编写健壮的JavaScript很重要，因为很难破坏干净的代码。它们不应该紧密耦合。还有，副作用要尽可能的消除，以便于测试和推理。</p><p id="4772" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，聪明的代码应该避免，因为它们通常难以阅读。</p></div></div>    
</body>
</html>