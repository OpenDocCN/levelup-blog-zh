<html>
<head>
<title>A verstatile Git utility that reduces the pain of resolving merge conflicts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个减少解决合并冲突的痛苦的可测试的Git实用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-verstatile-git-utility-that-reduces-the-pain-of-resolving-merge-conflicts-340289e75bd1?source=collection_archive---------2-----------------------#2022-06-18">https://levelup.gitconnected.com/a-verstatile-git-utility-that-reduces-the-pain-of-resolving-merge-conflicts-340289e75bd1?source=collection_archive---------2-----------------------#2022-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6a3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">软件开发人员每天都在使用版本控制，Git是最常用的工具。事实上，对Git的掌握已经成为业内人士的必备培训。然而，我发现许多计算机科学学生(尤其是我学校的学生)缺乏这种基本技能，因为他们的课程没有让他们接触到行业级的软件协作，即使有各种项目要求他们在小组中编写代码。</p><p id="7f2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我观察到的最大的Git错误之一是，许多学生抱怨在不同的Git分支上工作是困难和耗时的。他们害怕将提交合并在一起，因为他们经常遇到难以解决的合并冲突。如果他们真的需要合并分支，他们通常会使用一种“笨拙”且不太可持续的方法，即强制合并，然后手动修复代码冲突，最后进行<code class="fe kl km kn ko b">fix merge conflict</code>提交。这是非常低效的，并且通常不是一个愉快的过程。另一个问题是，团队中的其他每个人都必须尝试与合并的分支合并，这样他们就会重复这个循环。</p><p id="1378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想介绍的是一个强大的Git实用程序，它经常被这些学生忽略。它被称为Git rebase。</p><blockquote class="kp kq kr"><p id="53f0" class="jn jo ks jp b jq jr js jt ju jv jw jx kt jz ka kb ku kd ke kf kv kh ki kj kk ij bi translated">掌握Git rebase是释放版本控制真正潜力的关键。</p></blockquote><p id="2489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Git rebase能够做很多奇妙的事情。但我相信它的核心功能是能够倒带一组提交，根据程序员的喜好对每个提交进行更改，然后将它们放回一起。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="4f1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明Git rebase是如何工作的，我将用一个例子来展示它。</p><p id="1f66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您正在为react应用程序构建一个新的“蓝色按钮”。您通过从<code class="fe kl km kn ko b">main</code>分支创建一个名为<code class="fe kl km kn ko b">blue-button</code>的新Git分支来开始您的工作。在构建该特性几天后，您对<code class="fe kl km kn ko b">blue-button</code>进行了新的提交。在那几天里，从事该项目的其他人创建了其他新特性，并将这些特性合并到<code class="fe kl km kn ko b">main</code>分支。意识到您的<code class="fe kl km kn ko b">blue-button</code>分支现在位于<code class="fe kl km kn ko b">main</code>分支之后，您想要同步<code class="fe kl km kn ko b">blue-button</code>和<code class="fe kl km kn ko b">main</code>之间的变化。如果你尝试做一个<code class="fe kl km kn ko b">git merge</code>，你可能会遇到冲突，因为你可能修改了其他人也修改过的代码库的某些部分。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/cd25d14d9126210047c30b7d18ad7d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBActfVciVpwE-NPWKRWOw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">插图1(作者的作品)</figcaption></figure><p id="71c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以你不用Git merge，而是使用Git rebase。在<code class="fe kl km kn ko b">blue-button</code>分支中，您调用针对<code class="fe kl km kn ko b">main</code>的Git rebase。</p><pre class="le lf lg lh gt lt ko lu lv aw lw bi"><span id="2d1b" class="lx ly iq ko b gy lz ma l mb mc">git rebase -i main</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi md"><img src="../Images/abe9f3f13ee5759cbfa873461a7484c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NURMakXyNP9fM4TKfLpPQQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">截图1(作者作品)</figcaption></figure><p id="e1e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是交互式rebase控制台，每个提交都有许多可用的选项。因为你想保留所有新的<code class="fe kl km kn ko b">blue-button</code>提交，你可以<em class="ks">选择</em>所有的提交。这也是每次提交的默认选项。</p><p id="ce6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个过程的开始，Git rebase会临时“提升”你在<code class="fe kl km kn ko b">blue-button</code>中的所有新提交，以对抗<code class="fe kl km kn ko b">blue-button</code>和<code class="fe kl km kn ko b">main</code>之间的最后一个公共提交，并将它们放在一个临时堆栈中。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/9ccb09e4e8c10d60a16a468aff44c56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZlhyhqDbKnwD1J8WoEwtYQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">插图2(作者的作品)</figcaption></figure><p id="4151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，Git rebase复制其他人创建的所有新的<code class="fe kl km kn ko b">main</code>提交，并将它们粘贴到<code class="fe kl km kn ko b">blue-button</code>上。所以现在<code class="fe kl km kn ko b">blue-button</code>和<code class="fe kl km kn ko b">main</code>共享一个<em class="ks">相同的提交历史</em>。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/370c82658021e268855c6801a8458dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bc8TTyXv4x9K9MV1J7Z8fQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">插图3(作者的作品)</figcaption></figure><p id="cde4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，您要求Git将临时堆栈中的所有提交重新存储到<code class="fe kl km kn ko b">pick</code>中，以便将它们一个接一个地回放到<code class="fe kl km kn ko b">blue-button</code>中。这意味着，每个这样的提交都将在分支上重新创建，从而产生全新的提交。您可能会注意到重放的提交有新的<em class="ks">提交sha </em>标记。但是现在<code class="fe kl km kn ko b">blue-button</code>分支不再位于<code class="fe kl km kn ko b">main</code>分支之后，因此后续的合并不会导致任何冲突。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/e633b5b81cb84a1933972de43a49b8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQf5fwH2CVZjriZxOPjf8g.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">插图4(作者的作品)</figcaption></figure><p id="a961" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果简单而优雅，因为不需要创建额外的<code class="fe kl km kn ko b">merge</code>提交。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/26a3a32a6a86081498cc5db5fc087670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVyQHttQJzjSOYT_A-uQYg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">插图5(作者的作品)</figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="5502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果你仔细观察，你可能会开始怀疑，如果新的<code class="fe kl km kn ko b">main</code>提交确实对代码做了一些修改，新的<code class="fe kl km kn ko b">blue-button</code>提交也做了，合并冲突仍然应该被观察到。没错！当新的<code class="fe kl km kn ko b">blue-button</code>提交被重放到分支上时，将会看到这样的冲突。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/3a59cc15f1f3a931074371ac31d49ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npo0fCqWjwuCbQcXip1kxg.png"/></div></div></figure><p id="8e12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，当在某个<code class="fe kl km kn ko b">blue-button</code>提交上观察到冲突时。Git rebase过程暂停，Git会要求您在继续之前解决冲突。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi me"><img src="../Images/783bb0524d352e901acf28cac2061e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwJQAH-8Cd3OSkaq6M-tYg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">截图2(作者作品)</figcaption></figure><p id="d0a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将不得不进入那些特定的代码片段来修复问题(如果您和您的团队遵循良好的软件工程实践，希望不需要太多的努力)。</p><p id="cf28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">冲突解决后，您可以要求Git继续rebase过程。</p><pre class="le lf lg lh gt lt ko lu lv aw lw bi"><span id="1acd" class="lx ly iq ko b gy lz ma l mb mc">git rebase --continue</span></pre><p id="79b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原始提交被修改，并被重新创建为一个新提交，该新提交现在与来自<code class="fe kl km kn ko b">main</code>的新提交没有冲突。这里的结果也很漂亮，因为您不需要进行任何意外的<code class="fe kl km kn ko b">fix merge conflict</code>提交。</p><p id="54be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，如果您认为rebase过程出错了，您可以告诉Git rebase完全中止它。</p><pre class="le lf lg lh gt lt ko lu lv aw lw bi"><span id="cc51" class="lx ly iq ko b gy lz ma l mb mc">git rebase --abort</span></pre><p id="5b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后您的<code class="fe kl km kn ko b">blue-button</code>分支将恢复到Git rebase之前的状态。</p><blockquote class="kp kq kr"><p id="15f9" class="jn jo ks jp b jq jr js jt ju jv jw jx kt jz ka kb ku kd ke kf kv kh ki kj kk ij bi translated">P <!-- --> ro提示:您可以在冲突解决暂停期间运行<code class="fe kl km kn ko b">git status</code>来检查您在提交历史中的位置。它还会给你一些关于下一步做什么的选项。</p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="c9aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你学会了如何使用Git rebase，你可能很快就会发现它不仅仅是一个保持分支同步的工具(就像我刚刚展示的)。它允许你更好地控制每一次提交，比如修改提交消息(<code class="fe kl km kn ko b">reword</code>)和完全删除提交(<code class="fe kl km kn ko b">drop</code>)。您还可以为特定的提交计划暂停重放过程(<code class="fe kl km kn ko b">break</code>)，这样您就可以检查提交历史中该点的代码基础。</p><p id="f052" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Git rebase是我解决版本化代码库问题的首选解决方案。例如，我经常提交到<code class="fe kl km kn ko b">main</code>分支上，但后来才意识到提交应该是在一个新的分支上。因此，我将从那里创建一个新的分支，然后签出到<code class="fe kl km kn ko b">main</code>分支，并根据之前的提交对其进行重新设置。在交互式rebase控制台中，我将<code class="fe kl km kn ko b">drop</code>该特定提交，将其从<code class="fe kl km kn ko b">main</code>分支的提交历史中删除。我知道在这种情况下你可以只做一个<code class="fe kl km kn ko b">git reset --hard &lt;previous commit sha&gt;</code>，但是我只是想说明Git rebase也可以实现相同的提交删除功能。</p><p id="dcec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，Git rebase是一个功能强大的工具，在您的软件工程工具箱中拥有它肯定会让您受益。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="740a" class="mf ly iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">分级编码</h1><p id="5e60" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae nh" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>。<br/>跟随:<a class="ae nh" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae nh" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae nh" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="jp ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae nh" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>