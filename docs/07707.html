<html>
<head>
<title>A Brief Introduction to F# for Object Oriented Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象开发人员的F#简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-brief-introduction-to-f-for-object-oriented-developers-e3ff71e665d9?source=collection_archive---------18-----------------------#2021-03-06">https://levelup.gitconnected.com/a-brief-introduction-to-f-for-object-oriented-developers-e3ff71e665d9?source=collection_archive---------18-----------------------#2021-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ee26d9b63c40c42aab40de6ae5f3b962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZC74-ZMSc16QteYG"/></div></div></figure><p id="b3ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近我一直在学习如何用F#写代码。没听说过的，F#是微软的/。NET对功能优先编程语言的回答。我的动机是学习一种函数式编程语言，这种语言将使科学计算和数据分析的编码更具表现力、更简洁、更易维护，同时还能无缝地适应。我已经知道并喜爱的. NET生态系统。F#完全符合这个要求。</p><h1 id="0940" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么是函数式编程？</h1><p id="24bf" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对于一个面向对象的程序员来说，函数式编程的思想一开始可能有点陌生。我们习惯于这样的应用程序，其中所有的东西都是一个对象，应用程序通过改变这些对象的状态(突变)来工作。相比之下，函数式程序由值和函数组成，应用程序通过将这些函数应用于值来产生新的值。</p><p id="abe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这听起来可能类似于面向对象风格的方法，但是有两个关键的区别:</p><ol class=""><li id="e78a" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">值不能被修改(据说它们是不可变的)。相反，操作创建并返回新值。</li><li id="9875" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">函数应该是纯的，这意味着给定的输入总是产生相同的输出。这与类方法相反，在类方法中，类的某些内部状态可能会对方法的输出产生影响。</li></ol><p id="fe12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在一个代码示例中来看看这一点，在这个示例中，我们希望按照一个给定的系数来提高雇员的工资:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0d09" class="mw kx iq ms b gy mx my l mz na">// C# Object Oriented Example<br/>public class Employee<br/>{<br/> public string Name { get; set; }<br/> public float Salary { get; set; }<br/>}</span><span id="c13d" class="mw kx iq ms b gy nb my l mz na">public class SalaryRaiser<br/>{<br/> public float Factor { get; set; }<br/> <br/> public void RaiseSalary(Employee employee)<br/> {<br/>        // function not pure - depends on Factor, which isn't a parameter<br/>  var raise = employee.Salary * Factor;<br/>  <br/>        // employee object is mutated directly<br/>  employee.Salary += raise;<br/> }<br/>}</span><span id="133e" class="mw kx iq ms b gy nb my l mz na">var employee = new Employee { Name = "Bob", Salary = 12345.67F };<br/>var raiser = new SalaryRaiser { Factor = 0.05F };<br/>raiser.RaiseSalary(employee);</span><span id="41eb" class="mw kx iq ms b gy nb my l mz na">// F# Functional Example<br/>type Employee = { Name: string; Salary: float }</span><span id="897e" class="mw kx iq ms b gy nb my l mz na">let factor = 0.05<br/>let calculateSalary employee factor =<br/>    // function is pure - factor is now a parameter<br/>    let raise = employee.Salary * factor</span><span id="419c" class="mw kx iq ms b gy nb my l mz na">// new employee record returned<br/>    { employee with  Salary = employee.Salary + raise }</span><span id="5fda" class="mw kx iq ms b gy nb my l mz na">let employee = { Name = "Bob"; Salary = 12345.67 }<br/>let updatedEmployee = calculateSalary employee factor</span></pre><p id="9454" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些功能特性(不变性和纯函数)的主要好处是，它们使您的代码更易于维护和测试，因为您可以确保值不会被意外地改变(也称为副作用)，并且对于给定的输入，给定的函数将始终表现相同。</p><h1 id="7321" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">F#中的数据类型</h1><p id="aca2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在F#中，数据类型是静态的和强类型的，这意味着它们是在编译时确定的，给定值不能改变它的类型。这对于C#程序员来说是很熟悉的。但是，有些细微的差异可能需要一些时间来适应:</p><ul class=""><li id="468c" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nc mf mg mh bi translated">F#有一个强大的类型推断系统，这意味着你几乎不需要显式地声明类型是什么——它是从上下文中推断出来的</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1eb9" class="mw kx iq ms b gy mx my l mz na">// C#<br/>public int AddInt(int a, int b)<br/>{<br/>    return a + b;<br/>}</span><span id="b181" class="mw kx iq ms b gy nb my l mz na">var value = AddInt(1, 2)</span><span id="20ec" class="mw kx iq ms b gy nb my l mz na">// F#<br/>let addInt x y = x + y</span><span id="17d7" class="mw kx iq ms b gy nb my l mz na">let value = addInt 1 2</span></pre><ul class=""><li id="7259" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nc mf mg mh bi translated">F#需要类型之间的显式转换</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="595a" class="mw kx iq ms b gy mx my l mz na">// C#<br/>public float AddFloat(float a, float b)<br/>{<br/>    return a + b;<br/>}</span><span id="aa1b" class="mw kx iq ms b gy nb my l mz na">int a = 1;<br/>int b = 2;</span><span id="c1cc" class="mw kx iq ms b gy nb my l mz na">var value = AddFloat(a, b); // ints are implicitly converted to floats</span><span id="bfa2" class="mw kx iq ms b gy nb my l mz na">// F#<br/>let addFloat (a:float) (b:float) = a + b // for the purpose of the example, explictly state the a and b must be floats</span><span id="ce94" class="mw kx iq ms b gy nb my l mz na">let value = addFloat 1 2 // will throw exception since 1 and 2 are ints</span><span id="580a" class="mw kx iq ms b gy nb my l mz na">// instead<br/>let a = float 1<br/>let b = float 2</span><span id="657b" class="mw kx iq ms b gy nb my l mz na">let value = addFloat a b</span></pre><p id="e401" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除此之外，F#包含了你在C#和许多其他语言中习惯的所有原始数据类型。</p><h1 id="3ad9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">收集</h1><h2 id="ed7c" class="mw kx iq bd ky nd ne dn lc nf ng dp lg kj nh ni lk kn nj nk lo kr nl nm ls nn bi translated">列表</h2><p id="53c2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">F#中的列表类似于C#中的列表，除了(因为它们是不可变的)像Add/Remove这样的方法不存在。相反，要执行等效操作，必须从现有列表创建新列表。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c425" class="mw kx iq ms b gy mx my l mz na">// 1. Declare a list<br/>let list = [1;2;3] // creates a list with the elements 1, 2 and 3</span><span id="9c70" class="mw kx iq ms b gy nb my l mz na">// 2. Declare a list using range syntax<br/>let list = [1..5] // create a list with the element 1, 2, 3, 4, and 5</span><span id="ce00" class="mw kx iq ms b gy nb my l mz na">// 3. Add an element to the start of a list<br/>let list = [1;2;3]<br/>let list2 = 4::list // create a list [4;1;2;3]</span><span id="4c19" class="mw kx iq ms b gy nb my l mz na">// 4. Remove elements from the list<br/>let list = [1;2;3]<br/>let list2 = list.[0..1] // returns a list containing the elements between index 0 and 1. Equivalent to removing the index 3</span></pre><h2 id="a038" class="mw kx iq bd ky nd ne dn lc nf ng dp lg kj nh ni lk kn nj nk lo kr nl nm ls nn bi translated">顺序</h2><p id="fcdb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">序列类似于列表，只是它们是延迟求值的，这意味着元素值直到需要时才加载到内存中。这对于处理非常大的序列非常有用。一个相当长的列表必须将所有元素同时存储在内存中，甚至可能会使你的电脑崩溃！</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9b8c" class="mw kx iq ms b gy mx my l mz na">// large list<br/>// WARNING: may crash your pc<br/>let list = [1..1000000] // create a list containing 1 million elements</span><span id="0a38" class="mw kx iq ms b gy nb my l mz na">// large sequence<br/>let sequence = seq {1..1000000}</span></pre><h2 id="5a01" class="mw kx iq bd ky nd ne dn lc nf ng dp lg kj nh ni lk kn nj nk lo kr nl nm ls nn bi translated">元组</h2><p id="fd5b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们之前看到的集合必须包含所有具有相同数据类型的数据(即一个int列表)。元组不同之处在于它包含多个值，每个值具有不同的数据类型。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="f949" class="mw kx iq ms b gy mx my l mz na">// 1. declare a tuple<br/>let myTuple = (1, "hello")</span><span id="bd4b" class="mw kx iq ms b gy nb my l mz na">// 2. destructure a tuple<br/>let myTuple = (1, "hello")<br/>let (num, str) = myTuple // assigns num the value 1, and str the value "hello"</span></pre><h2 id="2356" class="mw kx iq bd ky nd ne dn lc nf ng dp lg kj nh ni lk kn nj nk lo kr nl nm ls nn bi translated">记录</h2><p id="6d28" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">记录将数据分组到不同的对象中，类似于类。记录甚至可以有方法。然而，与F#中的大多数东西一样，记录是不可变的，因此“编辑”记录需要从现有记录创建一个新记录。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0323" class="mw kx iq ms b gy mx my l mz na">// 1. Declare a record type with a method<br/>type Person = {<br/>    Name: string; <br/>    Age: int;<br/>} with member this.IsAdult = this.Age &gt;= 18</span><span id="1d85" class="mw kx iq ms b gy nb my l mz na">// 2. Create a record<br/>// Note that we don't need to tell the compiler that this is a Person record<br/>// It can infer it from the fields we provide<br/>let sam = { Name = "Sam"; Age = 27 }</span><span id="dfa2" class="mw kx iq ms b gy nb my l mz na">// 3. Create a record based on an existing one<br/>let olderSam = { sam with Age = 28 }</span></pre><h2 id="d7b4" class="mw kx iq bd ky nd ne dn lc nf ng dp lg kj nh ni lk kn nj nk lo kr nl nm ls nn bi translated">受歧视的工会</h2><p id="c1c2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有区别的联合是F#中的一个强大特性，可能很多程序员都不熟悉——我当然不熟悉！有区别的联合允许值是许多命名事例中的一个，每个事例都有潜在的不同类型和值。这大概说明了</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ed76" class="mw kx iq ms b gy mx my l mz na">// 1. Basic discriminated union<br/>// this declares a Status type, that can have the value Active or Inactive<br/>type Status = Active | Inactive<br/>let myStatus = Status.Active</span><span id="0029" class="mw kx iq ms b gy nb my l mz na">// 2. A more complex example<br/>type Shape = <br/>    | Rectangle of width:float * length:float // takes a tuple of two floats<br/>    | Circle of radius:float // takes a float</span><span id="0779" class="mw kx iq ms b gy nb my l mz na">// both have the Shape type<br/>let cir = Circle 5.<br/>let rect = Rectangle(5., 6.)</span></pre><h1 id="ef47" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">模式匹配</h1><p id="982c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">模式匹配在F#中非常常见，是一种基于匹配输入值控制应用程序流的方法。这可以比作使用if..else语句以这种方式，if语句确实存在于F#中，但是模式匹配更加惯用(希望你会同意，更加强大)。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="a17c" class="mw kx iq ms b gy mx my l mz na">// 1. Pattern matching a discriminated union<br/>type Status = Active | Inactive</span><span id="389a" class="mw kx iq ms b gy nb my l mz na">// return true if Active, return false if inactive<br/>let isActive status = <br/>    match status with<br/>    | Active -&gt; true<br/>    | Inactive -&gt; false</span><span id="f00d" class="mw kx iq ms b gy nb my l mz na">// 2. Pattern matching to handle errors<br/>type Result =<br/>    | Error of string<br/>    | Data of int</span><span id="b65c" class="mw kx iq ms b gy nb my l mz na">// handle printing data or error cases to the console<br/>let handle result = <br/>    match result with<br/>    | Data data -&gt; printfn "My result: %i" data<br/>    | Error error -&gt; printfn "An error ocurred: %s" error</span><span id="8231" class="mw kx iq ms b gy nb my l mz na">3. Pattern matching tuple values<br/>let matchPoint point = <br/>    match point with<br/>    | (0, 0) -&gt; printfn "This is the origin"<br/>    | (x, 0) -&gt; printfn "X is %i, while Y is 0" x<br/>    | (0, y) -&gt; printfn "Y is %i, while X is 0" y<br/>    | _ -&gt; printfn "Both values are non-zero" // _ is a catch all case</span></pre><h1 id="2705" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">一些功能概念</h1><h2 id="c0a2" class="mw kx iq bd ky nd ne dn lc nf ng dp lg kj nh ni lk kn nj nk lo kr nl nm ls nn bi translated">固化和局部应用</h2><p id="50d7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个纯函数只能有一个输入和一个输出，对于F#中的函数也是如此。然而，我们已经看到了一些带有多个参数的函数。例如:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d22c" class="mw kx iq ms b gy mx my l mz na">let addInt x y = x + y</span><span id="f259" class="mw kx iq ms b gy nb my l mz na">addInt 5 6 // evaluates to 11</span></pre><p id="1c4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在幕后，F#实际上是把这个声明分成两个独立的函数，每个函数只有一个参数。大致如下的东西:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c7af" class="mw kx iq ms b gy mx my l mz na">let addInt x  =     <br/>    let subFunction y = x + y<br/>    subFunction</span><span id="7335" class="mw kx iq ms b gy nb my l mz na">let intermediate = addInt 5 // evaluates to a function that adds five to its parameter</span><span id="d414" class="mw kx iq ms b gy nb my l mz na">intermediate 6 // evaluates to 11</span></pre><p id="0594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将一个多参数函数拆分成一个单参数函数管道的过程称为currying。这固然很好，但对我们有什么实际好处呢？有趣的结果之一是部分应用。</p><p id="a503" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到C#中的加法函数。它有两个参数，你只能用两个参数调用它。用一个参数调用它只会导致编译器错误。</p><p id="961f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果我们在F#中只使用一个参数调用addInt函数，就会发生一些有趣的事情。它返回一个函数，其中包含了我们的第一个参数！这就是所谓的部分应用，对于创建可重用的代码片段来说，这是一个非常有用的概念。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6346" class="mw kx iq ms b gy mx my l mz na">let addInt x y = x + y</span><span id="94b6" class="mw kx iq ms b gy nb my l mz na">let add5 = addInt 5 // partially apply addInt to create a new function that adds 5 to the input</span><span id="376b" class="mw kx iq ms b gy nb my l mz na">add5 6 // evaluates to 11<br/>add5 7 //evaluates to 12</span></pre><h2 id="e279" class="mw kx iq bd ky nd ne dn lc nf ng dp lg kj nh ni lk kn nj nk lo kr nl nm ls nn bi translated">平静的</h2><p id="4ea2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">管道是一种特殊类型的运算符，允许您将参数放在函数之前。例如:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="40fd" class="mw kx iq ms b gy mx my l mz na">let addInt x y = x + y<br/>let add5 = 5 |&gt; addInt // pipe 5 into the addInt function</span></pre><p id="a4e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的用途可能看起来不是很明显，但是它对于创建函数管道非常有用，在管道中，一个函数的输出直接输入到另一个函数的输入中。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="958f" class="mw kx iq ms b gy mx my l mz na">[1; 2; 3] // create a list<br/>|&gt; List.map (fun x -&gt; x + 1) // add 1 to each element of the list<br/>|&gt; List.filter (fun x -&gt; x &gt; 2) // only return elements that have a value greater than 2 (returns [3; 4])</span></pre><p id="5968" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，上面以<code class="fe no np nq ms b">fun</code>为前缀的表达式只是lambda表达式(或匿名函数),就像你在许多其他语言中看到的一样。</p><h2 id="f618" class="mw kx iq bd ky nd ne dn lc nf ng dp lg kj nh ni lk kn nj nk lo kr nl nm ls nn bi translated">作文</h2><p id="d13e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">组合是将多个功能连接在一起以创建一个新功能的行为。乍一看，这似乎与管道非常相似，但它有细微的不同:管道必须以一个值开始，并立即被求值以给出输出；函数组合将多个函数连接在一起，并返回新的函数(即，在此阶段不计算任何内容)。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="193b" class="mw kx iq ms b gy mx my l mz na">// Example comparing piping and composition</span><span id="9429" class="mw kx iq ms b gy nb my l mz na">let add5 = (+) 5<br/>let double = (*) 2</span><span id="6b8e" class="mw kx iq ms b gy nb my l mz na">// piping<br/>5<br/>|&gt; add5<br/>|&gt; double // evaluates to 20</span><span id="9d80" class="mw kx iq ms b gy nb my l mz na">// composition<br/>let add5ThenDouble = add5 &gt;&gt; double // compose into a new function</span><span id="1978" class="mw kx iq ms b gy nb my l mz na">add5ThenDouble 5 // evaluates to 20</span></pre><h1 id="03c6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="8248" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这是我对面向对象程序员的F#的简要介绍。我所涉及的主题绝非详尽无遗，但希望它足以激起您对F#和函数式编程的兴趣。</p><p id="187e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更多的资源<a class="ae nr" href="https://fsharpforfunandprofit.com/" rel="noopener ugc nofollow" target="_blank"> F#为了乐趣和利益</a>是一个优秀的网站，它将帮助你更深入地学习这门语言。</p><p id="edc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发布的大部分内容都是关于全栈的。NET和Vue web开发(很快可能会有更多的F#内容！).为了确保你不会错过任何帖子，请关注这个博客并<a class="ae nr" href="https://samwalpole.com" rel="noopener ugc nofollow" target="_blank">订阅我的简讯</a>。如果你觉得这篇文章有帮助，请喜欢它并分享它。你也可以在<a class="ae nr" href="https://twitter.com/dr_sam_walpole" rel="noopener ugc nofollow" target="_blank">推特</a>上找到我。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="5093" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nz">原载于</em><a class="ae nr" href="https://samwalpole.com/a-brief-introduction-to-f-for-object-oriented-developers" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://samwalpole.com</em></a><em class="nz">。</em></p></div></div>    
</body>
</html>