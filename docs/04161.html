<html>
<head>
<title>How To Write Unit Tests with React-Testing-Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用反应测试库编写单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-unit-tests-with-react-testing-library-d9624fd2b707?source=collection_archive---------3-----------------------#2020-06-12">https://levelup.gitconnected.com/how-to-write-unit-tests-with-react-testing-library-d9624fd2b707?source=collection_archive---------3-----------------------#2020-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用testing-library/react v10进行简单的隔离测试。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/62241561c8963237745d0ca41f31007d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CJiehYwYKQnll9ZC"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@cdc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">疾控中心</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="657b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，您开发了一个React应用程序，但是您仍然对其功能和可预测性没有100%的信心。</p><p id="1414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者你实现了一个华丽的功能，但随后bug已经开始出现。你不知道可能是什么原因。很沮丧，对吧？</p><p id="6ecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种情况是单元测试重要的原因。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="4197" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">设置我们的应用程序</h1><p id="3a76" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">我想在Countries应用程序上演示单元测试，你可以<a class="ae lb" href="https://github.com/Dromediansk/countries-app-blog/tree/testing" rel="noopener ugc nofollow" target="_blank">从GitHub </a>中克隆它，然后一起编码。</p><p id="e3e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了获得相同的结果，我建议您使用以下依赖版本(或更新版本):</p><ul class=""><li id="866e" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">反应— 16.13.1</li><li id="6a23" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">反应脚本— 3.4.1</li></ul><p id="4de0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者如果你想完全从头开始开发这个应用程序，你可以从阅读下面的文章开始:</p><div class="na nb gp gr nc nd"><a href="https://medium.com/better-programming/some-best-practices-for-building-a-react-app-with-hooks-d6157494f5c1" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">用钩子构建React应用程序的一些最佳实践</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">从头开始构建应用程序时，要记住一些方便的提示</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kv nd"/></div></div></a></div><h2 id="ca48" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">安装RTL</h2><p id="5294" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">首先，我们需要安装React-testing-library (RTL)和jest-dom，以便使用<a class="ae lb" href="https://github.com/testing-library/jest-dom" rel="noopener ugc nofollow" target="_blank">自定义jest匹配器</a>:</p><pre class="km kn ko kp gt oe of og oh aw oi bi"><span id="1bfd" class="ns lk iq of b gy oj ok l ol om">npm install --save-dev @testing-library/react <!-- -->@testing-library/jest-dom</span></pre><p id="ce1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实际使用定制匹配器，我们需要导入它们。在<code class="fe on oo op of b">src</code>文件夹中，我们新建一个文件<code class="fe on oo op of b">setupTests.js</code>:</p><pre class="km kn ko kp gt oe of og oh aw oi bi"><span id="a9f1" class="ns lk iq of b gy oj ok l ol om">import "@testing-library/jest-dom/extend-expect";</span></pre><p id="4a67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个安装文件将在每个测试文件中运行一次。你可以在<a class="ae lb" href="https://jestjs.io/docs/en/configuration.html#setupfiles-array" rel="noopener ugc nofollow" target="_blank"> jest文档</a>中读到更多。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="4152" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">快照测试</h1><p id="309d" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">每当您希望确保您的UI或代码不会意外更改时，快照测试非常有用。</p><p id="ccc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快照测试的工作原理是，它将组件与生成的蓝图(快照)进行比较。如果它们不匹配，测试将失败。</p><p id="cb33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，让我们有一个简单的组件<code class="fe on oo op of b">CountryCard.js</code>，里面没有任何逻辑:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">CountryCard.js</figcaption></figure><p id="a453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe on oo op of b">CountryCard</code>文件夹中，我们创建一个新文件<code class="fe on oo op of b">CountryCard.test.js</code>，并编写我们的第一个测试:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><ul class=""><li id="4e7e" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">在运行任何测试之前，我们需要定义一个具有所需属性的国家对象，在我们的例子中是<code class="fe on oo op of b">stubbedCountry</code>。属性值应该具有与预期相同的属性类型。</li><li id="33d3" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">在第15行，我们用<code class="fe on oo op of b">render()</code>渲染我们的组件，并将stubbed props传递给组件。</li><li id="2f71" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">我们期望匹配快照(如果第一次运行，将会生成快照)。</li></ul><h2 id="0176" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">真正的好处是什么？</h2><p id="eeec" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">基于这个例子，看起来快照测试不是很有用，对吗？我们模仿道具，传递给组件，然后期望它总是匹配。为什么他们不应该，无论如何？</p><p id="7795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事情是这样的，<code class="fe on oo op of b">CountryCard</code>期望只有一个道具，它将显示内容。这个组件没有其他可能的版本。</p><p id="03ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，快照测试只有在以下情况下才有意义:</p><ul class=""><li id="6f7e" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">由于道具不同，组件的内容也在变化。在这种情况下，我们可以为组件的所有可能版本编写一个快照测试。</li><li id="0508" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">我们希望在开发过程中识别组件的变化。</li></ul><h1 id="f839" class="lj lk iq bd ll lm os lo lp lq ot ls lt lu ou lw lx ly ov ma mb mc ow me mf mg bi translated">测试表格</h1><p id="7c24" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">开发web应用程序时，表单是最重要的主题之一，让表单可预测是至关重要的。</p><p id="8418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe on oo op of b">AdvancedFilter.js</code>由基本输入组成，其值由上层组件传递。此外，事件处理程序作为prop — <code class="fe on oo op of b">handleChangeValue</code>传递给组件。</p><p id="df72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们应该在这里测试什么呢？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="d7ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，单元测试应该尽可能地隔离。重要的是测试组件的行为并得到预期的结果。</p><p id="732a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是我们想要测试的内容:</p><ol class=""><li id="b71d" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk ox ms mt mu bi translated">基于给定的属性，它应该显示相应的输入值</li><li id="c364" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk ox ms mt mu bi translated">当用户开始输入时，它应该调用一个事件处理程序并显示更新后的值</li></ol><p id="6f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这才有资格入住两次测试！让我们测试第一种情况:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><ul class=""><li id="2238" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">我们可以在<code class="fe on oo op of b">describe</code>块中分组多个测试(从第5行开始)。</li><li id="dd27" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">在测试开始时创建模拟的功能和道具是一个很好的实践。在我们的例子中，我们需要模仿所需的道具<code class="fe on oo op of b">searchValue</code>和<code class="fe on oo op of b">handleChangeValue</code>。</li><li id="48d6" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">在测试中，我们首先需要用适当的道具来呈现我们测试的组件。在RTL我们使用<code class="fe on oo op of b">render()</code>功能。</li><li id="8ab9" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">使用对象析构，我们可以提取我们将要使用的方法——比如选择器方法<code class="fe on oo op of b">getByTestId</code>。</li><li id="e73a" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">最后，我们(最初)期望输入值是空字符串。在<code class="fe on oo op of b">expect</code>中，我们需要传递一些选择器，例如通过文本、标签文本、测试id等。您可以在RTL 的<a class="ae lb" href="https://testing-library.com/docs/dom-testing-library/api-queries" rel="noopener ugc nofollow" target="_blank">查询中了解所有可用选项。</a></li></ul><h2 id="a204" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">模拟事件</h2><p id="12b3" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">当然，在表单中测试初始值是不够的。我们可以使用RTL的<code class="fe on oo op of b">fireEvent</code>来模拟用户行为:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="6199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个测试中发生了几件事:</p><ul class=""><li id="2ffc" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">我们首先定义新更新的<code class="fe on oo op of b">searchValue</code> prop，当用户在输入中写东西时，它将被传递给组件(第5行)。</li><li id="9092" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">我们用初始值来呈现组件。</li><li id="d587" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">onChange事件可以根据<a class="ae lb" href="https://testing-library.com/docs/dom-testing-library/api-events" rel="noopener ugc nofollow" target="_blank"> RTL文档</a>用<code class="fe on oo op of b">fireEvent.change</code>模拟。当我们对组件进行更新时，不要忘记将它包装到<code class="fe on oo op of b">act()</code>块中。</li><li id="0c50" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">更改输入的值后，我们需要模拟r <a class="ae lb" href="https://testing-library.com/docs/marko-testing-library/api#rerender" rel="noopener ugc nofollow" target="_blank"> e-rendering同一个组件用不同的道具</a>(第19行)。</li><li id="dd7c" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">在断言中，我们检查输入的值以及被调用的事件处理程序。</li></ul><p id="e054" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>请记住，我们没有测试事件处理程序本身。这必须在定义组件的地方完成——在我们的例子中是在<code class="fe on oo op of b">CountriesContainer.js</code>中。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="f4cc" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">测试获取服务</h1><p id="b824" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">在我们的应用中，我们使用一个定制的钩子来获取国家，但是在通常的场景中，你会有一些调用服务:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="47e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取数据通常被嘲笑，我们应该隔离测试我们服务的行为。</p><h2 id="a240" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">1.状态代码为200的场景</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><ul class=""><li id="a28f" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">重要的是在开始时模拟fetch，在这里我们用给定的状态和数据返回一个承诺(第17–25行)。</li><li id="11ea" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">断言结果。</li></ul><h2 id="68fe" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">2.状态代码为500的场景</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><ul class=""><li id="d22c" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">与前面的测试类似，我们需要模拟状态为500的fetch。</li><li id="ff72" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">我们期望数据不存在</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="74b2" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">测试提取的数据</h1><p id="f373" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">真正的魔力发生在<code class="fe on oo op of b">CountriesContainer</code>中，我们获取数据，声明表单的事件处理程序，并显示国家。我认为这个组件是最重要的测试。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="6a20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是我们实际需要检查的内容:</p><ol class=""><li id="db1c" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk ox ms mt mu bi translated">获取数据时是否显示加载微调器？</li><li id="9b3e" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk ox ms mt mu bi translated">提取后数据是否显示在视图中？</li><li id="08fd" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk ox ms mt mu bi translated">如果数据提取不成功，是否显示错误通知？</li><li id="a4e2" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk ox ms mt mu bi translated">国家是否按输入值过滤？</li></ol><h2 id="a4c5" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">测试准备</h2><p id="d5e9" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">首先，我们实际上需要模拟定制钩子来获取数据和数据本身。在<code class="fe on oo op of b">CountriesContainer.test.js</code>我们可以这样做:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><ul class=""><li id="9798" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">我们可以使用<a class="ae lb" href="https://jestjs.io/docs/en/manual-mocks" rel="noopener ugc nofollow" target="_blank"> Jest manual mocks </a>(第6行)模仿任何模块。</li><li id="93e7" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><code class="fe on oo op of b">stubbedCountries</code>是(模拟)提取后将显示的数据。</li></ul><p id="ff53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们深入编写测试本身！</p><h2 id="a29b" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">1.检查装载旋转器</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="d8e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，我们首先需要模拟数据获取。因为我们使用自定义钩子来实现这个目的，所以我们必须模拟函数的返回值(第2–6行)。</p><p id="edd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您直接使用Axios或fetchAPI，您需要模拟这些模块。检查RTL 的<a class="ae lb" href="https://testing-library.com/docs/dom-testing-library/api-async" rel="noopener ugc nofollow" target="_blank">异步公用程序。</a></p><p id="08c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们可以渲染组件，并期望显示加载微调器。</p><h2 id="7692" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">2.正在显示检查数据</h2><p id="7db5" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这其实很简单。我们模拟钩子的返回值，其中已经存在数据。</p><p id="d848" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以查询标签，它们在子组件中。有时候是必然的。例如，通过<code class="fe on oo op of b">data-testid</code>选择国家卡:</p><pre class="km kn ko kp gt oe of og oh aw oi bi"><span id="6c4d" class="ns lk iq of b gy oj ok l ol om">// CountryCard.js</span><span id="ba04" class="ns lk iq of b gy oy ok l ol om">&lt;div className="country-card" <strong class="of ir">data-testid={`${country.name}-card`}</strong>&gt;<br/>...</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="23f9" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">3.检查错误通知</h2><p id="64e4" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这里我们只是改变钩子的返回值并检查错误信息是否存在:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="5bb5" class="ns lk iq bd ll nt nu dn lp nv nw dp lt jy nx ny lx kc nz oa mb kg ob oc mf od bi translated">4.检查过滤国家</h2><p id="3556" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">在获取数据之后，我们需要在输入上模拟onChange事件。我将演示如何根据国家名称进行过滤，但是可以随意添加更多的测试。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="7a23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在模拟在姓名输入中键入“Slov ”,预计视图中将只显示斯洛伐克国家。在这个测试中，我们还覆盖了组件中声明的事件处理程序。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="ecc1" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">接下来去哪里</h1><p id="64c9" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">您可以在<a class="ae lb" href="https://github.com/Dromediansk/countries-app-blog/tree/unit-testing" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中检查所有测试。</p><p id="8f48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这几个测试例子，我们几乎涵盖了单元测试的核心。我鼓励你写更多的测试。这是一个需要练习的话题，所以你可以决定<em class="oz">实际测试什么</em>。</p><p id="a6fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对学习自动化/E2E测试感兴趣，我写了一篇关于如何用Cypress编写测试的指南:</p><div class="na nb gp gr nc nd"><a href="https://medium.com/better-programming/react-testing-get-started-with-cypress-io-a19b6eb6332a" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">React测试:Cypress.io入门</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">用最少的努力编写有意义的端到端测试</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="pa l no np nq nm nr kv nd"/></div></div></a></div></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="c98d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>