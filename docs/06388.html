<html>
<head>
<title>Getting Started With Scala Cats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala Cats入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-scala-cats-c7ae7ef73050?source=collection_archive---------8-----------------------#2020-11-20">https://levelup.gitconnected.com/getting-started-with-scala-cats-c7ae7ef73050?source=collection_archive---------8-----------------------#2020-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/882298f105f68977b3e5a8fa4484072c.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/0*dyxCbdFSrEZi8eTW.png"/></div></div></figure><h1 id="f9f1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="f1e2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这篇文章是关于Scala猫的。它是一个为Scala编程语言中的函数式编程提供抽象的库。这个名字是单词<em class="lu">类别</em>的有趣缩写。</p><p id="2157" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">Cats是一个轻量级、模块化、可扩展的函数式编程库。</p><p id="862e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">Cats包含各种各样的函数式编程工具，并允许开发人员选择所需的工具。这些工具中的大多数都是以类型类的形式交付的，我们可以将其应用于现有的Scala类型。</p><h1 id="fc42" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是类型类？</h1><p id="61d1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">类型类是起源于Haskell的一种编程模式。它们允许我们用新的功能扩展现有的库，而不使用传统的继承，也不改变原始的库源代码。</p><p id="11dd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">类型类模式有三个重要的组成部分:类型类本身、特定类型的实例和使用类型类的方法。</p><h1 id="5c9d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是类型类？</h1><p id="996a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">类型类是一个接口或API，表示我们想要实现的一些功能。在Scala中，一个类型类由至少有一个类型参数的trait来表示。</p><p id="bea9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">例如，我们可以如下表示一般的“序列化为JSON”行为:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c745" class="mj jz iq mf b gy mk ml l mm mn">// Define a very simple JSON AST<br/>sealed trait Json<br/>final case class JsObject(get: Map[String, Json]) extends Json<br/>final case class JsString(get: String) extends Json<br/>final case class JsNumber(get: Double) extends Json<br/>final case object JsNull extends Json</span><span id="b3dd" class="mj jz iq mf b gy mo ml l mm mn">// The "serialize to JSON" behaviour is encoded in this trait<br/>trait JsonWriter[A] {<br/>  def write(value: A): Json<br/>}</span></pre><h1 id="e48a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是类型类实例？</h1><p id="a875" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">type类的实例为我们关心的特定类型提供了type类的实现，这些类型可以包括来自Scala标准库的类型和来自我们的域模型的类型。</p><p id="0204" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在Scala中，我们通过创建类型类的具体实现来定义实例，并用<em class="lu">隐式</em>关键字来标记它们:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="226b" class="mj jz iq mf b gy mk ml l mm mn">final case class Person(name: String, email: String)</span><span id="6a94" class="mj jz iq mf b gy mo ml l mm mn">object JsonWriterInstances {<br/>  implicit val stringWriter: JsonWriter[String] = new JsonWriter[String] {<br/>    def write(value: String): Json = JsString(value)<br/>  }<br/>  implicit val personWriter: JsonWriter[Person] = new JsonWriter[Person] {<br/>    def write(value: Person): Json =<br/>      JsObject(Map(<br/>        "name" -&gt; JsString(value.name),<br/>        "email" -&gt; JsString(value.email)<br/>      ))<br/>  }<br/>}</span></pre><h1 id="5e2d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">如何使用类型类？</h1><p id="0741" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">类型类用途是需要类型类实例才能工作的任何功能。在Scala中，这意味着任何接受类型类实例作为隐式参数的方法。</p><p id="b7be" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">Cats提供了使类型类更容易使用的工具，你有时会在其他库中看到这些模式。</p><p id="07b0" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">有两种方法:接口对象和接口语法。</p><h1 id="b8c1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是接口对象？</h1><p id="270e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">创建使用类型类的接口的最简单方法是将方法放在singleton对象中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7b1d" class="mj jz iq mf b gy mk ml l mm mn">object Json {<br/>  def toJson[A](value: A)(implicit w: JsonWriter[A]): Json = w.write(value)<br/>}</span></pre><p id="98ee" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">为了使用这个对象，我们导入我们关心的任何类型类实例，并调用相关的方法:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3858" class="mj jz iq mf b gy mk ml l mm mn">import JsonWriterInstances._<br/>Json.toJson(Person("Dave", "dave@example.com"))</span></pre><p id="5824" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">编译器发现我们调用的<em class="lu"> toJson </em>方法没有提供隐式参数。它试图通过搜索相关类型的类型类实例并将其插入调用位置来解决这一问题:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="92ea" class="mj jz iq mf b gy mk ml l mm mn">Json.toJson(Person("Dave", "dave@example.com"))(personWriter)</span></pre><h1 id="4dbd" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是接口语法？</h1><p id="c587" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们也可以使用扩展方法，用接口方法扩展现有的类型。Cats将此称为类型类的“语法”:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="86f4" class="mj jz iq mf b gy mk ml l mm mn">object JsonSyntax {<br/>  implicit class JsonWriterOps[A](value: A) {<br/>    def toJson(implicit w: JsonWriter[A]): Json = w.write(value)<br/>  }<br/>}</span></pre><p id="18c5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们通过将接口语法与所需类型的实例一起导入来使用接口语法:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a460" class="mj jz iq mf b gy mk ml l mm mn">import JsonWriterInstances._<br/>import JsonSyntax._<br/>Person("Dave", "dave@example.com").toJson</span></pre><p id="65bb" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">同样，编译器搜索隐式参数的候选项，并为我们填充它们:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1d7b" class="mj jz iq mf b gy mk ml l mm mn">Person("Dave", "dave@example.com").toJson(personWriter)</span></pre><h1 id="c165" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是隐含？</h1><p id="9e8e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在Scala中使用类型类意味着使用隐式值和隐式参数。为了有效地做到这一点，我们需要知道一些规则。</p><p id="b248" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">Scala中任何标记为隐式的定义都必须放在对象或特征内部，而不是放在顶层。</p><p id="221d" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在上面的例子中，我们将类型类实例打包在一个名为<em class="lu"> JsonWriterInstances </em>的对象中。我们同样可以将它们放在<em class="lu"> JsonWriter </em>的一个伴随对象中。在Scala中，将实例放在type类的伙伴对象中有着特殊的意义，因为它被称为隐式作用域。</p><h1 id="8393" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是隐式范围？</h1><p id="0363" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如我们在上面看到的，编译器根据类型搜索候选类型类实例。</p><p id="ea0e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">例如，在下面的表达式中，它将查找类型为<em class="lu">JSON writer[字符串] </em>的实例:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6d43" class="mj jz iq mf b gy mk ml l mm mn">Json.toJson("A string!")</span></pre><p id="e25e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">编译器搜索候选实例的地方称为隐式范围。隐式作用域适用于调用点，也就是我们调用带有隐式参数的方法的地方。</p><h1 id="55d0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h1><p id="2bbb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本文中，我们首先看了一下类型类。</p><p id="2584" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们看到了组成类型类的组件:</p><ul class=""><li id="ed73" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated">一个特征，也就是类型类。</li><li id="5fc2" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">类型类实例，它们是隐式值。</li><li id="f6a9" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">使用隐式参数的类型类用法。</li></ul></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="a267" class="jy jz iq bd ka kb nk kd ke kf nl kh ki kj nm kl km kn nn kp kq kr no kt ku kv bi translated">类似文章-</h1><p id="b655" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你也可以看看我在<em class="lu"> Scala Cats </em>系列上的其他文章</p><ul class=""><li id="ca03" class="mp mq iq ky b kz lv ld lw lh mr ll ms lp mt lt mu mv mw mx bi translated"><a class="ae np" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-semigroups-732ef2432042">潜入标量猫—半群</a></li><li id="743b" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae np" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-monoids-82e744b9e518">潜入Scala猫——幺半群</a></li><li id="6e86" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae np" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-functors-c957285d7009">深入Scala猫——函子</a></li><li id="408a" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae np" rel="noopener ugc nofollow" target="_blank" href="/functors-in-functional-programming-dfaba4cfb2ed">函数编程中的函子</a></li></ul></div></div>    
</body>
</html>