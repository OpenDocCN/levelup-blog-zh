<html>
<head>
<title>Go slices, maps, pitfalls — and generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go切片、地图、陷阱和泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-slices-maps-pitfalls-and-generics-f7ced963ced?source=collection_archive---------3-----------------------#2020-01-18">https://levelup.gitconnected.com/go-slices-maps-pitfalls-and-generics-f7ced963ced?source=collection_archive---------3-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/688b2c831169b1b8699478717dbdd14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*4GHWhfp0QJZh3MysgphcIw.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">不要落入切片陷阱</figcaption></figure><div class=""/><p id="7cb5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不记得具体是怎么回事了——可能是我的Twitter feed或我过于混乱的收件箱里的东西——但我最近看到了<a class="la lb ep" href="https://medium.com/u/2b8679c5a2b0?source=post_page-----f7ced963ced--------------------------------" rel="noopener" target="_blank"> Paolo Gallina </a>写的这篇文章关于使用指向切片的指针。</p><p id="ceea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我很喜欢Go，但是它也有一些缺点，会给程序员设置陷阱，这是一个很大而且很危险的缺点。看看Paolo的文章，和/或下面围棋场上的<a class="ae kz" href="https://play.golang.org/p/tPt7A761yTa" rel="noopener ugc nofollow" target="_blank">代码</a>，明白我的意思。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ec83" class="ll lm je lh b gy ln lo l lp lq">func main() {<br/>    slice:= []string{"a","a"}<br/>    func(slice []string){<br/>        slice[0]="b";<br/>        slice[1]="b";<br/>    }(slice)<br/>    fmt.Print(slice)</span><span id="09ab" class="ll lm je lh b gy lr lo l lp lq">    slice = []string{"a","a"} <br/>    func(slice []string){<br/>        slice = append(slice, "a")<br/>        slice[0]="b";<br/>        slice[1]="b"; <br/>    }(slice)<br/>    fmt.Print(slice)<br/>}</span></pre><p id="2969" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所料，这段代码在第一次函数调用后打印出<code class="fe ls lt lu lh b">[b,b]</code>。如果你了解你的切片，你就不会对第二个函数的输出是<code class="fe ls lt lu lh b">[a, a]</code>感到惊讶。不太直观！</p><p id="ecce" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要有效地使用切片，您必须知道:</p><ul class=""><li id="9930" class="lv lw je kd b ke kf ki kj km lx kq ly ku lz ky ma mb mc md bi translated">切片被实现为包含指针的结构</li><li id="e117" class="lv lw je kd b ke me ki mf km mg kq mh ku mi ky ma mb mc md bi translated">指针值可以改变。</li></ul><h1 id="7e30" class="mj lm je bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">更好的方法？归还切片</h1><p id="f291" class="pw-post-body-paragraph kb kc je kd b ke ng kg kh ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky im bi translated">Paolo建议使用一个指向切片的指针，这是一个完全可以接受的问题解决方案，尽管我想提出一个我认为稍微好一点的方法:<em class="nl">如果你正在编写一个将切片作为参数的函数，将切片作为返回值</em>。您可以将此作为一般准则，或者仅在函数可能追加到切片时使用它，此时可能会出现问题。</p><p id="213c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我改编了Paolo的例子(你可以在这里的Go Playground】找到它<a class="ae kz" href="https://play.golang.org/p/fY6KPIzxkTA" rel="noopener ugc nofollow" target="_blank">)。</a></p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="3fcf" class="ll lm je lh b gy ln lo l lp lq">func main() {<br/>    slice:= []string{"a","a"}<br/> <br/>    slice = func(slice []string) []string{<br/>        slice= append(slice, "a")<br/>        slice[0]="b";<br/>        slice[1]="b"; <br/>        return slice<br/>    }(slice)</span><span id="d92c" class="ll lm je lh b gy lr lo l lp lq">    fmt.Print(slice) <br/>}</span></pre><p id="034c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我更喜欢这一点，因为这绝对清楚地表明你将获得<code class="fe ls lt lu lh b">slice</code>的更新版本。它避免了额外的指针——我通常热衷于避免不必要的指针，因为它们会增加认知开销，并涉及<a class="ae kz" href="https://medium.com/@philpearl/bad-go-slices-of-pointers-ed3c06b8bb41" rel="noopener">额外的分配</a>和后续的垃圾收集，这会影响性能。</p><h1 id="2e96" class="mj lm je bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">地图呢？</h1><p id="77b2" class="pw-post-body-paragraph kb kc je kd b ke ng kg kh ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky im bi translated">在许多方面，地图和切片看起来(表面上)很相似，因为使用了方括号<code class="fe ls lt lu lh b">[</code>和<code class="fe ls lt lu lh b">]</code>，并且在两种情况下通常使用<code class="fe ls lt lu lh b">make</code>来分配它们。实际上，底层的实现非常不同。就本文的目的而言，我最感兴趣的区别是地图被实现为指针。</p><p id="0fa3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从<a class="ae kz" href="https://groups.google.com/forum/#!msg/golang-nuts/SjuhSYDITm4/jnrp7rRxDQAJ" rel="noopener ugc nofollow" target="_blank">这条线索</a>到<a class="la lb ep" href="https://medium.com/u/df2718043abd?source=post_page-----f7ced963ced--------------------------------" rel="noopener" target="_blank">伊恩·兰斯·泰勒</a>写道</p><blockquote class="nm nn no"><p id="d208" class="kb kc nl kd b ke kf kg kh ki kj kk kl np kn ko kp nq kr ks kt nr kv kw kx ky im bi translated">在很早的时候，我们现在称之为map<br/>的东西是作为指针写的，所以你写了*map[int]int。当我们意识到没有人不写“地图”而写“地图”的时候，我们就离开了<br/>。</p></blockquote><p id="0a68" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果不是戴夫·切尼<a class="la lb ep" href="https://medium.com/u/b702737d9239?source=post_page-----f7ced963ced--------------------------------" rel="noopener" target="_blank">的</a><a class="ae kz" href="https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，我永远也不会找到这个启发性的引用，你应该深入了解更多关于地图是如何实现的。</p><p id="c9ee" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑到地图已经是一个指针了，就没必要担心用指针指向地图，万一它在你脚下变了。</p><h1 id="0d9b" class="mj lm je bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">泛型和这一切有什么关系？</h1><p id="c2de" class="pw-post-body-paragraph kb kc je kd b ke ng kg kh ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky im bi translated">想象一下，切片不是Go语言的基础部分，而是一个带有类似<code class="fe ls lt lu lh b">append()</code>的方法的常规结构。作为一名Go程序员，你会看到<a class="ae kz" href="https://blog.golang.org/go-slices-usage-and-internals" rel="noopener ugc nofollow" target="_blank">结构，以及它的指针、长度和容量字段值</a>，你不需要非常有经验就能意识到当你调用一个方法时，所有这些字段值可能会改变。因此，你不太可能落入陷阱。</p><p id="341c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时你可能会想“也许我应该在代码中直接使用切片头来增加透明度”，但这真的不值得。你不想这么做的一个重要原因是(缺少)泛型。切片和映射的好处在于，Golang允许您使用它们来存储任何类型的数据，而您手工生成的手工切片头结构需要为该指针指定一种类型。然后你将需要一套不同的方法来存储你想要的不同类型的数据。很快就会变得很无趣。</p><h1 id="0329" class="mj lm je bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">(重新)学会喜欢切片</h1><p id="ddf7" class="pw-post-body-paragraph kb kc je kd b ke ng kg kh ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky im bi translated">我仍然希望Go不需要人们理解切片的底层实现。如果有一些微妙的视觉线索，比如使用不同的括号类型，来帮助我们区分我们谈论的是切片、数组还是映射，我可能会感觉更好。</p><p id="23f0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我<em class="nl">可能</em>会接受泛型的概念:-)</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="abb4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，你可能也会喜欢这篇关于Go   <em class="nl">中</em> <a class="ae kz" href="https://medium.com/@lizrice/variables-and-functions-in-go-oh-my-18b71297657?source=friends_link&amp;sk=492253deb2265879c2131e25a84e846a" rel="noopener"> <em class="nl">变量和函数的文章。</em></a></p></div></div>    
</body>
</html>