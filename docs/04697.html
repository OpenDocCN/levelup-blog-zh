<html>
<head>
<title>Common Vue Problems — Emit Event from Parent to Child, Watcher Variables, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的Vue问题—从父节点向子节点发出事件、观察器变量等等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/common-vue-problems-emit-event-from-parent-to-child-watcher-variables-and-more-88e9775f7ca5?source=collection_archive---------1-----------------------#2020-07-10">https://levelup.gitconnected.com/common-vue-problems-emit-event-from-parent-to-child-watcher-variables-and-more-88e9775f7ca5?source=collection_archive---------1-----------------------#2020-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/707d26232256e90e948b8d4c403b2f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9jNmvJuuNgSexYGi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">劳尔·popadineți在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9a93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Vue.js让开发前端应用变得简单。然而，我们仍有可能遇到问题。</p><p id="0df2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看一些常见的问题，并看看如何解决它们。</p><h1 id="9c7c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">访问观察器中的变量</h1><p id="f331" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以像使用其他方法一样访问观察器中的变量。</p><p id="c319" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="14f1" class="mq lf it mm b gy mr ms l mt mu">watch: {<br/>  dates: { <br/>    handler(date) {    <br/>      if (date.start) {<br/>        this.params.from = new Date(date.start).toString()<br/>      }<br/>      if (date.end) {<br/>        this.params.to = nbew Date(date.end).toString()<br/>      }<br/>    },<br/>    deep: true<br/>  }<br/>}</span></pre><p id="68b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在我们的观察器中得到<code class="fe mv mw mx mm b">dates</code>对象的值，我们可以用它做一些事情。</p><p id="ecef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">deep</code>设置为<code class="fe mv mw mx mm b">true</code>意味着我们观察一个物体的所有属性。</p><h1 id="7163" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">以编程方式创建Vue.js插槽</h1><p id="2c4e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">没有记录在案的以编程方式创建插槽的方法。</p><p id="9438" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们可以使用render函数来创建具有slot属性的元素。</p><p id="7760" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="287b" class="mq lf it mm b gy mr ms l mt mu">Vue.component('parent', {<br/>  render (createElement) {<br/>    return createElement('child', [<br/>      createElement('h1', { slot: 'parent' }, 'parent slot'),<br/>      createElement('p', { slot: 'default' }, 'default slot')<br/>    ])<br/>  }<br/>})</span></pre><p id="ca4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过写来使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5227" class="mq lf it mm b gy mr ms l mt mu">Vue.component('child', {<br/>  template: '&lt;div&gt;&lt;slot name="parent-slot" /&gt;&lt;slot /&gt;&lt;/div&gt;'<br/>})</span></pre><p id="54d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mv mw mx mm b">createElement</code>创建元素，它可以包含<code class="fe mv mw mx mm b">slot</code>属性来创建命名的和默认的槽。</p><h1 id="2ce6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">获取密钥属性的值</h1><p id="b4e4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们无法获取子元素中key prop的值。</p><p id="6f5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们不得不叫它别的东西。</p><p id="59a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">key</code>是一个特殊的道具，Vue使用它来跟踪用<code class="fe mv mw mx mm b">v-for</code>渲染的组件和元素。</p><h1 id="ca3d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在Vue组件中下载pdf</h1><p id="8e02" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要在Vue组件中下载PDF，我们可以在<code class="fe mv mw mx mm b">Blob</code>构造函数中获得响应。</p><p id="a8e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以创建一个不可见的下载链接，然后通过编程点击它进行下载。</p><p id="dfc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c0d9" class="mq lf it mm b gy mr ms l mt mu">downloadFile() {<br/>  this.$http.get('pdf/url', {responseType: 'arraybuffer'})<br/>    .then(response =&gt; {<br/>      let blob = new Blob([response.data], { type: 'application/pdf' })<br/>      let link = document.createElement('a')<br/>      link.href = window.URL.createObjectURL(blob)<br/>      link.download = 'test.pdf'<br/>      link.click()<br/>    })<br/>}</span></pre><p id="d676" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">this.$http</code>是Axios HTTP客户端。</p><p id="10cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">responseType</code>被设置为<code class="fe mv mw mx mm b">'arraybuffer'</code>，这样我们就可以将其作为二进制文件下载。</p><p id="c786" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将<code class="fe mv mw mx mm b">response.data</code>放入数组中的<code class="fe mv mw mx mm b">Blob</code>构造函数，并将mime类型设置为<code class="fe mv mw mx mm b">'application/pdf'</code>。</p><p id="6dbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mv mw mx mm b">createObjectURL</code>创建链接来下载创建的blob。</p><p id="ef31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将<code class="fe mv mw mx mm b">link</code>的<code class="fe mv mw mx mm b">download</code>属性设置为文件名。</p><p id="135f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们调用<code class="fe mv mw mx mm b">click</code>点击链接来下载文件。</p><h1 id="bbd8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Vue中可选的父元素</h1><p id="b228" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">is</code>属性来动态设置元素的标签。</p><p id="f63e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f95c" class="mq lf it mm b gy mr ms l mt mu">&lt;a :href="link" :is="link ? 'a' : 'p'"&gt;text&lt;/a&gt;</span></pre><p id="27d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有<code class="fe mv mw mx mm b">link</code>字段。如果是<code class="fe mv mw mx mm b">true</code>，那么返回<code class="fe mv mw mx mm b">'a'</code>将其设置为一个<code class="fe mv mw mx mm b">a</code>元素。</p><p id="163d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们将它设置为一个<code class="fe mv mw mx mm b">p</code>元素。</p><p id="2120" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mv mw mx mm b">link</code>是真的，我们就这么做。</p><h1 id="4b7d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从父节点向子节点发出事件</h1><p id="b3e1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mv mw mx mm b">$emit</code>方法从父组件向子组件发出一个事件。</p><p id="9d34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，没有明显的方法将事件从父节点发送到子节点。</p><p id="cb2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们仍然可以这样做。</p><p id="332a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建一个新的<code class="fe mv mw mx mm b">Vue</code>实例，创建一个事件总线，然后将<code class="fe mv mw mx mm b">Vue</code>实例传递给孩子来监听它。</p><p id="a30e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4b23" class="mq lf it mm b gy mr ms l mt mu">export default {<br/>  components: {<br/>    Child<br/>  },<br/>  data() {<br/>    return {<br/>      bus: new Vue(),<br/>      data: []<br/>    }<br/>  },<br/>  methods: {<br/>    loadMore() {<br/>      this.bus.$emit('loadMore', {<br/>        data: this.data<br/>      });<br/>    }<br/>  }<br/>}</span></pre><p id="b260" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在<code class="fe mv mw mx mm b">bus</code>字段中有了<code class="fe mv mw mx mm b">Vue</code>实例。</p><p id="b8a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以发出<code class="fe mv mw mx mm b">loadMore</code>事件来发送监听来自<code class="fe mv mw mx mm b">bus</code>事件的事件。</p><p id="eedf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的父模板中，我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a454" class="mq lf it mm b gy mr ms l mt mu">&lt;child :bus="bus"&gt;&lt;/child&gt;</span></pre><p id="a77f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<code class="fe mv mw mx mm b">bus</code>字段传递给<code class="fe mv mw mx mm b">child</code>组件。</p><p id="44c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mv mw mx mm b">child</code>的<code class="fe mv mw mx mm b">created</code>钩子中，我们可以通过编写来监听<code class="fe mv mw mx mm b">loadMore</code>事件:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="80f6" class="mq lf it mm b gy mr ms l mt mu">created() {<br/>  this.bus.$on('loadMore', (args) =&gt; {<br/>    // do something with args.data<br/>  });<br/>}</span></pre><p id="79a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">args</code>我们传入第二个参数<code class="fe mv mw mx mm b">$emit</code>的对象。</p><p id="9138" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当组件加载<code class="fe mv mw mx mm b">$on</code>时，它会监听来自<code class="fe mv mw mx mm b">this.bus</code>的<code class="fe mv mw mx mm b">loadMore</code>事件。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/86defa3b3aae783909857d55e1f50ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u-Irzc_oni1Z0Rlg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@memoreno?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马丁·莫雷诺</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="8da6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="d06d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用渲染函数以编程方式创建插槽。</p><p id="bb00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要将事件从父传递到子，我们可以将Vue实例传递给子，从父发出事件，并使用传递给子的Vue实例来监听它。</p></div></div>    
</body>
</html>