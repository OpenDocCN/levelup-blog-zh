<html>
<head>
<title>Python: Why None is NOT Nothing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:为什么无不是无</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-why-none-is-not-nothing-bb3de55dd471?source=collection_archive---------6-----------------------#2022-05-11">https://levelup.gitconnected.com/python-why-none-is-not-nothing-bb3de55dd471?source=collection_archive---------6-----------------------#2022-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f53cc3234364ff8e0fe81838962eccfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgQ3NbK86XCUlDLZHRtcaQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片由space.com拍摄</figcaption></figure><div class=""/><div class=""><h2 id="2e6f" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">以及没有它该如何生活</h2></div><p id="efaa" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这次我们来谈谈Python中著名的<strong class="kw jg"> None </strong>，它的各种形状和使用模式。让我们设法找到没有它也能四处走动的方法。</p><p id="8930" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在我的职业生涯中，我花了几年时间在函数式编程领域。你知道，这种严格意义上的东西。后来，当我回到Python时，我注意到他们同时引入了类型注释，这多酷啊？在某个时间点上，我开始深入挖掘，以便发现我是否能够在Python中应用一些FP概念。</p><p id="d60d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">从零开始，我什么也没找到。这就是这个故事的全部内容。-)</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="32b2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是我最喜欢的Python函数:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="80f3" class="mg mh jf mc b gy mi mj l mk ml">def magic_function():<br/>    # mysterious things happening here<br/>    print("Pure magic!")</span></pre><p id="c677" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">乍一看，它看起来像一个没有输入也不返回任何内容的函数，因为它没有return语句。现在让我们试试奇怪的东西:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b204" class="mg mh jf mc b gy mi mj l mk ml">&gt;&gt;&gt; magic = magic_function()<br/>Pure magic!</span></pre><p id="284a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">不出所料，该函数会打印到stdout，但有趣的是，我们将magic_function()的结果赋给了magic变量。这怎么可能呢？我们如何给一个变量赋值“nothing”(这是函数应该返回的值)？为什么我们没有得到一个错误？</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="401f" class="mg mh jf mc b gy mi mj l mk ml">&gt;&gt;&gt; magic.__class__<br/>&lt;class 'NoneType'&gt;</span><span id="d1e6" class="mg mh jf mc b gy mm mj l mk ml">&gt;&gt;&gt; magic is None<br/>True</span><span id="bc5b" class="mg mh jf mc b gy mm mj l mk ml">&gt;&gt;&gt; None.__class__<br/>&lt;class 'NoneType'&gt;</span></pre><p id="f267" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">自然，博学的Pythonista知道每个(！)没有显式return语句的函数隐式返回<strong class="kw jg"> None </strong>(除非抛出异常)——这就是我们赋给‘magic’的东西。因此，magic变成了一个“非类型类”的变量——magic等同于None。</p><p id="9fcb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果一个东西有一个身份，即使它被称为<strong class="kw jg">无</strong>，它也不能是无，对吗？反过来，如果一个函数真的什么都不能返回(这实际上已经是一个矛盾了)，那么它怎么能被赋给一个变量呢？一个人怎么能把什么都不分配给什么呢？</p><p id="a4d5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">好的，<strong class="kw jg"> None </strong>是一个“真实”类型的“真实”实例。似乎是“无不是无”的第一个证据，对吗？</p><p id="8c6b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">多亏了类型注释，我们可以让函数签名更吸引人:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b313" class="mg mh jf mc b gy mi mj l mk ml">def magic_function() -&gt; None:<br/>    ....</span></pre><p id="59f7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">magic_function()的用户现在立即知道，她不能期望该函数返回任何有意义的内容。闻起来像是《老友记》里的“空”东西:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0148" class="mg mh jf mc b gy mi mj l mk ml">void magic_function(void) {<br/>    ....<br/>}</span></pre><p id="abc9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">像这样的结构不应该被称为“函数”，这就是为什么它们被命名为“过程”。</p><p id="7de7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">不幸的是，这并不是全部事实，因为Python中的<strong class="kw jg"> None </strong>似乎对每种类型都是有效值。我们可以很容易地证明，通过重新编写我们的魔术函数，只在每月的第一天返回一些魔术:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="099c" class="mg mh jf mc b gy mi mj l mk ml">from datetime import datetime<br/>from typing import Optional</span><span id="7521" class="mg mh jf mc b gy mm mj l mk ml">def maybe_magic_function() -&gt; Optional[str]:<br/>    return "magic" if datetime.now().day == 1 else None</span></pre><p id="9546" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这里我们定义函数<strong class="kw jg">可选地</strong>返回字符串。但是也允许返回<strong class="kw jg"> None </strong>。作为一个快速的旁注，在打字之前。可选介绍你必须写:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c47c" class="mg mh jf mc b gy mi mj l mk ml">from typing import Union</span><span id="2aa5" class="mg mh jf mc b gy mm mj l mk ml">def maybe_magic_function() -&gt; Union[str, None]:<br/>    ....</span></pre><p id="74e7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">从3.10版开始，您甚至可以写得更简洁:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c4ea" class="mg mh jf mc b gy mi mj l mk ml">def maybe_magic_function() -&gt; str | None:<br/>    ....</span></pre><p id="8f60" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这三种变体都是等价的，它们中的每一种都会让静态类型的棋手如<a class="ae mn" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kw jg">【mypy】</strong></a>非常高兴。就我个人而言，我更倾向于有这样的怪癖。我来解释一下原因。</p><p id="0fea" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg"> None </strong>作为返回值常用来表示不同的事物:</p><ol class=""><li id="4a9c" class="mo mp jf kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">函数返回<strong class="kw jg"> None </strong>或一个由<strong class="kw jg">可选【Any】</strong>表示的具体值- &gt;</li><li id="9473" class="mo mp jf kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">函数返回<strong class="kw jg"> None </strong>表示失败- &gt;由<strong class="kw jg">可选【任何】</strong>表示</li><li id="f03e" class="mo mp jf kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">函数返回<strong class="kw jg"> None </strong>表示没有返回值- &gt;由<strong class="kw jg"> None </strong>表示</li></ol><p id="f849" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在任何一种情况下，返回<strong class="kw jg"> None </strong>只不过是一种约定。从“无”中不可能得出任何明确的意图。正因为如此，你经常会发现无数的<strong class="kw jg">“如果某样东西不存在”</strong>瀑布(又名末日金字塔)。想想你在职业生涯中写了多少行代码来检查这些不符合常规的东西(参见<a class="ae mn" href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/" rel="noopener ugc nofollow" target="_blank">十亿美元的错误</a>)。</p><p id="c53b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">还有另一个微妙之处。我们已经发现，没有一个对象有标识，甚至有类型(NoneType类)。现在，当注释变量和函数时，我们使用类型，对吗？</p><p id="06fd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">比如:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7689" class="mg mh jf mc b gy mi mj l mk ml">def magic(i: int) -&gt; Union[str, None]:<br/>    ...</span></pre><p id="2915" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">“str”是一个类型，“int”是一个类型，但<strong class="kw jg"> None </strong>是一个“class NoneType”类型的对象。我们是在混合类型和对象吗？</p><p id="966d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">有趣的是，我们不被允许写:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c198" class="mg mh jf mc b gy mi mj l mk ml">&gt;&gt;&gt; def maybe_magic_function(i: int) -&gt; Union[str, NoneType]:<br/>    ...<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>NameError: name 'NoneType' is not defined</span><span id="a575" class="mg mh jf mc b gy mm mj l mk ml">&gt;&gt;&gt; type(None)<br/>&lt;class 'NoneType'&gt;</span><span id="748a" class="mg mh jf mc b gy mm mj l mk ml">&gt;&gt;&gt; type(int)<br/>&lt;class 'type'&gt;</span></pre><p id="05b6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们不能使用NoneType，正如Python所说:“名称‘NoneType’未定义”。如果<strong class="kw jg"> NoneType </strong>未定义，但是调用type(None)导致&lt;类‘NoneType’&gt;，那么它告诉我们关于<strong class="kw jg"> None </strong>的什么信息？是否意味着None是一个未定义类型的对象？如果一个东西的类型没有定义，它怎么会是对象呢？永无止境的问题…</p><p id="110b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">你看，有很多围绕着<strong class="kw jg">的神话没有</strong> …请随意深入挖掘:-)</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="6ff9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">无论如何，为了不弄乱所有这些特性，我怎样才能使返回值明确地表示像缺席(即没有)或失败(不同种类)这样的概念呢？我们怎样才能把None从我们的词汇中删除，以支持更明确的东西呢？</p><h2 id="16fa" class="mg mh jf bd nc nd ne dn nf ng nh dp ni ld nj nk nl lh nm nn no ll np nq nr ns bi translated">拯救的类型</h2><p id="2125" class="pw-post-body-paragraph ku kv jf kw b kx nt kg kz la nu kj lc ld nv lf lg lh nw lj lk ll nx ln lo lp ij bi translated">正如我们所知，Python的类型系统是动态的，并由duck-typing的概念实现(一个对象拥有的方法比具体类型更重要)。Python中的每个对象都有一个类型，由解释器自动推断出来。随着类型注释和静态类型检查器的引入，添加类型信息给我们一种处理静态类型语言的(虚拟)印象，至少在IDE中是这样。</p><p id="4e47" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">那么，我们如何利用这些优势呢？</p><p id="26f7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">代表缺席</strong></p><p id="f1f2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们可以用一个叫做<strong class="kw jg">的专用类型来表示缺勤，可能是</strong>，它有两个子类型。<strong class="kw jg">只是</strong>包装了一个具体的值，而<strong class="kw jg">什么都没有</strong>代表不存在。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="aeb8" class="mg mh jf mc b gy mi mj l mk ml">class Maybe(abc.ABC):<br/>    @abc.abstractmethod<br/>    def get_or_else(self, fallback):<br/>        ...</span><span id="4438" class="mg mh jf mc b gy mm mj l mk ml">class Just(Maybe):<br/>    """Represents a concrete value."""<br/>    def __init__(self, value):<br/>        self.value = value<br/>    def get_or_else(self, fallback):<br/>        return self.value</span><span id="1340" class="mg mh jf mc b gy mm mj l mk ml">class Nothing(Maybe):<br/>    """Represents Nothing"""<br/>    def get_or_else(self, fallback):<br/>        return fallback</span><span id="81e4" class="mg mh jf mc b gy mm mj l mk ml"><br/>def magic_function() -&gt; Maybe:<br/>    return Just("magic") if datetime.now().day == 1 else Nothing()</span></pre><p id="55bd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我把a型叫做<strong class="kw jg">也许是</strong>，这不仅仅是巧合。不可否认，这可能是著名的Maybe monad有史以来最幼稚和不完整的实现:-)。只是现在不要关心术语“单子”，我们在这里学习代表缺席的概念:-)。</p><p id="57c4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">通过用<strong class="kw jg">也许是</strong>作为结果类型来注释我们的magic_function()，就没有不确定性的空间了。结果类型要么是<strong class="kw jg">只是</strong>要么是<strong class="kw jg">没有，</strong>完全停止<strong class="kw jg">。</strong></p><p id="8c15" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">使用结构化模式匹配(Python ≥ 3.10)，你可以很容易地从一个<strong class="kw jg"> Just </strong>中解开封装的值，并相应地处理<strong class="kw jg"> Nothing </strong>的情况。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="464e" class="mg mh jf mc b gy mi mj l mk ml">match magic_function():<br/>    case Just(value=magic):<br/>       print(f"{magic=}")<br/>    case Nothing():<br/>       print("no magic")</span></pre><p id="2912" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">或者，使用Python &lt; 3.10中的<strong class="kw jg"> get_or_else() </strong>方法。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7930" class="mg mh jf mc b gy mi mj l mk ml">result = magic_function()<br/>print(result.get_or_else("no magic")</span></pre><p id="9b4d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">关于Maybe monad还有很多内容要讲，但这远远超出了本文的范围。出于好奇，让我参考一下<a class="ae mn" href="https://returns.readthedocs.io/en/latest/pages/maybe.html#" rel="noopener ugc nofollow" target="_blank"><strong class="kw jg">returns</strong>package</a>，它提供了一个成熟的、完全带类型注释的实现。</p><p id="ce39" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">代表“未定义”</strong></p><p id="ae31" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">下一个有趣的场景是数学意义上的函数，这些函数只是根据它们的输入集进行了部分定义。我们都知道像被零除、负数的平方根等函数。</p><p id="958d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">考虑一个计算特定日期的日期名称的函数:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="13ad" class="mg mh jf mc b gy mi mj l mk ml">from datetime import datetime</span><span id="a2f5" class="mg mh jf mc b gy mm mj l mk ml">def dayname(year, month, day):<br/>    return datetime(year, month, day).strftime("%A")</span><span id="d22a" class="mg mh jf mc b gy mm mj l mk ml">&gt;&gt;&gt; dayname(2022, 11, 31)<br/>Traceback (most recent call last):<br/>  ...<br/>ValueError: day is out of range for month</span></pre><p id="bcce" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在编程语言中，我们通常以异常结束，因为不可能以有意义的方式表示“未定义”，至少在Python中没有。</p><p id="2180" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们也可以在这里使用Maybe。要么计算返回一个具体的值，否则我们可以认为它是未定义的。作为一个有益的副作用，我们正在摆脱那些讨厌的运行时异常。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d3aa" class="mg mh jf mc b gy mi mj l mk ml">def dayname(year, month, day) -&gt; Maybe:<br/>    try:<br/>        return Just(datetime(year, month, day).strftime("%A"))<br/>    except ValueError:<br/>        return Nothing()</span></pre><p id="066f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们甚至可以为自己编写一个方便的装饰器，这样我们就不必用错误处理代码来污染我们的函数:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b541" class="mg mh jf mc b gy mi mj l mk ml">def maybe_undefined(func) -&gt; Callable[..., Maybe]:<br/>    @functools.wraps(func)<br/>    def wrapper(*args, **kwargs) -&gt; Maybe:<br/>        try:<br/>            return Just(func(*args, **kwargs))<br/>        except Exception:<br/>            return Nothing()<br/>    return wrapper</span></pre><p id="bf31" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">有了这些，当我们事先知道函数对于某些输入值是未定义的时，我们可以很好地修饰函数。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9a09" class="mg mh jf mc b gy mi mj l mk ml">@maybe_undefined<br/>def dayname(year, month, day):<br/>    return datetime(year, month, day).strftime("%A")</span></pre><p id="b36c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">代表故障</strong></p><p id="5a76" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">同样，我们使用一个小的类层次来表示成功和失败，我们称之为<strong class="kw jg">结果</strong>。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9f83" class="mg mh jf mc b gy mi mj l mk ml">class Result(abc.ABC):<br/>    @abc.abstractmethod<br/>    def get(self):<br/>        ...<br/>    @abc.abstractmethod<br/>    def get_or_else(self, fallback):<br/>        ...</span><span id="230b" class="mg mh jf mc b gy mm mj l mk ml">class Success(Result):<br/>    """Represents success."""<br/>    def __init__(self, value):<br/>        self.value = value<br/>    def get(self):<br/>        return self.value<br/>    def get_or_else(self, fallback):<br/>        return self.value</span><span id="f6d0" class="mg mh jf mc b gy mm mj l mk ml">class Failure(Result):<br/>    """Represents failure"""<br/>    def __init__(self, error):<br/>        self.error = error<br/>    def get(self):<br/>        raise self.error<br/>    def get_or_else(self, fallback):<br/>        return fallback</span><span id="da13" class="mg mh jf mc b gy mm mj l mk ml"><br/>def throws(func) -&gt; Callable[..., Result]:<br/>    @functools.wraps(func)<br/>    def wrapper(*args, **kwargs) -&gt; Result:<br/>        try:<br/>            return Success(func(*args, **kwargs))<br/>        except Exception as ex:<br/>            return Failure(ex)<br/>    return wrapper<br/></span><span id="3864" class="mg mh jf mc b gy mm mj l mk ml">@throws<br/>def dayname(year, month, day):<br/>    return datetime(year, month, day).strftime("%A")</span></pre><p id="a9be" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">结果</strong>现在封装了失败案例的异常。感觉如何？如果计算成功，您将获得一个<strong class="kw jg">成功</strong>对象，否则将获得一个<strong class="kw jg">失败</strong>对象。这一次，<strong class="kw jg">失败</strong>对象也包含补充信息，该补充信息本身是一个异常对象。</p><p id="d9db" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这意味着解包一个<strong class="kw jg">故障</strong>仍然会导致一个异常:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fc49" class="mg mh jf mc b gy mi mj l mk ml">&gt;&gt;&gt; dayname(2021, 10, 10).get()<br/>'Sunday'<br/>&gt;&gt;&gt; dayname(2021, 10, 32).get()<br/>Traceback (most recent call last):<br/>  ...<br/>ValueError: day is out of range for month</span></pre><p id="da62" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们可以通过使用get_or_else()…来避免这种情况</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="875f" class="mg mh jf mc b gy mi mj l mk ml">&gt;&gt;&gt; dayname(2021, 10, 32).get_or_else('Invalid date entered')<br/>'Invalid date entered'<br/>&gt;&gt;&gt; dayname(2021, 10, 10).get_or_else('Invalid date entered')<br/>'Sunday'</span></pre><p id="e223" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">还是再次模式匹配…</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1a8a" class="mg mh jf mc b gy mi mj l mk ml">match dayname(2021, 10, 32):<br/>    case Success(value=day):<br/>       print(f"{day=}")<br/>    case Failure(error=failure):<br/>       print(f"{failure=}")</span></pre><p id="3a10" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">再次，看一下<a class="ae mn" href="https://returns.readthedocs.io/en/latest/pages/result.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kw jg">返回</strong>包</a>，它对<strong class="kw jg">结果</strong>有更好的实现。</p><p id="30a3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">顺便说一句:还有一种类型叫做<strong class="kw jg">或者</strong>，它有两个子类型，通常叫做<strong class="kw jg">左</strong>和<strong class="kw jg">右</strong>。它与结果非常相似，不同之处在于右边的<strong class="kw jg">代表计算的快乐路径(如成功),而左边的<strong class="kw jg">代表不快乐的路径——这不一定是例外情况。</strong></strong></p><h2 id="6431" class="mg mh jf bd nc nd ne dn nf ng nh dp ni ld nj nk nl lh nm nn no ll np nq nr ns bi translated">现在怎么办？也许，结果也是？</h2><p id="ce51" class="pw-post-body-paragraph ku kv jf kw b kx nt kg kz la nu kj lc ld nv lf lg lh nw lj lk ll nx ln lo lp ij bi translated">让我总结一下:</p><p id="a1d9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">也许</strong>是用来表示一个函数是否返回一个具体的值。作为一个类比，考虑对于某些输入值未定义的数学函数。(BTW:在Scala中，Maybe被称为Option with Some(value)or None(！)作为具体的子类型)</p><p id="be8c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">结果</strong>通常用于“具体化”异常，并以定义的方式处理它们。例外是有史以来发明的最糟糕、最具破坏性的副作用。如果处理不当，它们会给你带来极大的混乱。所以，去避开他们吧！</p><p id="3d3a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">或者</strong>更适合用来表示有两种可能输出的操作，一种比另一种更“快乐”。你也可以认为这是结果的概括。</p><h2 id="9347" class="mg mh jf bd nc nd ne dn nf ng nh dp ni ld nj nk nl lh nm nn no ll np nq nr ns bi translated">结论</h2><p id="477a" class="pw-post-body-paragraph ku kv jf kw b kx nt kg kz la nu kj lc ld nv lf lg lh nw lj lk ll nx ln lo lp ij bi translated">最后一个问题:在所有给出的例子中，你是否发现了一个<strong class="kw jg"> None </strong>的例子？你没有！所以是的，Python里有没有<strong class="kw jg"> None </strong>的生命！</p><p id="8e90" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">使用具体的类型来表示计算的具体结果，我们能够摆脱<strong class="kw jg"> None </strong>并且我们甚至能够使异常显式化，因此程序的自然控制流保持不变。</p><p id="3edb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">就这样，我把你自己的实验留给你！</p><p id="3b50" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">查看我关于<a class="ae mn" href="https://medium.com/@cini01/python-the-unacceptable-except-fd633c85c3ae" rel="noopener">单元素管道和面向铁路的编程</a>的后续故事</p><p id="3565" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">参考文献</strong></p><ul class=""><li id="7b33" class="mo mp jf kw b kx ky la lb ld mq lh mr ll ms lp ny mu mv mw bi translated">https://returns.readthedocs.io/en/latest/返回—<a class="ae mn" href="https://returns.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"/></li><li id="2cde" class="mo mp jf kw b kx mx la my ld mz lh na ll nb lp ny mu mv mw bi translated">mypy—<a class="ae mn" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank">http://mypy-lang.org/</a></li></ul></div></div>    
</body>
</html>