<html>
<head>
<title>SCOAT — A Smart Coverage Automation Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SCOAT——智能覆盖自动化框架</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scoat-a-smart-coverage-automation-framework-a907d268932?source=collection_archive---------30-----------------------#2021-06-29">https://levelup.gitconnected.com/scoat-a-smart-coverage-automation-framework-a907d268932?source=collection_archive---------30-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6294" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个开发工具，以智能方式实现测试自动化覆盖。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1d02b598d4da60283850d82b1cdbdbb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neSRM8GhS41SdmAHDsgtrQ.jpeg"/></div></div></figure><p id="b1fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您有一个包含500个案例的自动化列表，它将覆盖您的应用程序的所有组件，但是您必须对前100个案例进行优先级排序。而且，它应该仍然像500个自动化案例一样有效。你是做什么的？(求老板现实一点？:p)。听着，获得合理的时间来自动化所有的500本该是最好的方法，但是这个世界并不公平，不是吗？</p><p id="61d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧。我就不那么戏剧化了，直奔主题。</p><p id="cf7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选择自动化测试的一种方法是了解产品中使用最多的是什么。因为最终，我们编写自动化是为了向用户交付尽可能少错误的产品。对于任何产品来说，20%的功能被80%的客户使用或多或少是正确的。因此，首先自动化并在产品的这一部分早期捕捉缺陷不是很聪明吗？在这一部分中捕获的每一个错误都会阻止80%的人使用该产品。很划算，对吧？带着这个明确的目标，我在HackerEarth开发了SCOAT，我希望越来越多的人将使用这个框架以更智能的方式实现更好的质量。</p><h1 id="31f9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">SCOAT是什么？</h1><p id="56c1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">SCOAT是由“<strong class="kt ir">S</strong>mart<strong class="kt ir">CO</strong>verage<strong class="kt ir">A</strong>automation<strong class="kt ir">T</strong>ESTs”缩写而成。它是一个工具，用来帮助任何质量保证团队以比传统方法更有效的方式实现产品的自动化覆盖。</p><p id="79c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SCOAT关注的一个重要问题是，在开发测试自动化计划时，大多数QA团队可能都忽略了这个问题:“我们的客户使用我们优先考虑自动化的特性吗？”</p><p id="374c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是SCOAT的基本功能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/b15e309118c9ab8083f0d3fad790cb18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-niS7D66W9S1dvrFlLZJA.png"/></div></div></figure><h1 id="61db" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">实施SCOAT</h1><p id="5ff2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">SCOAT是用Python语言编写的。任何具有python编程(或任何其他等效程序)、正则表达式、数据库和/或AWS服务基础知识的开发人员或SDET都可以为他们的产品开发它。</p><h1 id="a1ce" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">下面我们来详细了解一下SCOAT组件！</h1><h2 id="6239" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">SCOAT刮刀</h2><p id="7f4d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><em class="ln"> Scrapper会负责获取数据。</em></p><p id="ea9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">选择数据源:</strong>实现这个框架最重要的事情是找到一个拥有足够多用户正在进行的网络调用数据的数据源。然后数据可以被清理，并以SCOAT理解的方式建模。在HackerEarth，我们使用Amazon redshift，它存储了任何用户进行的每个网络呼叫的条目。我们有redash，可以让我们查询所需的信息。有一个名为requestlog的表，它存储了我们产品中发生的每个网络调用的详细信息。</p><p id="162b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们举一个redash表requestlog列的基本例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0f66602f99f71155202107643191a7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*kapujE5MJHHPAyNrKscvJA.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">示例表模式:requestlog表</figcaption></figure><p id="9050" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">准备来自上述数据源的查询:</strong>因为我们将继续使用redash，所以我们可以使用SQL查询，它将给出下面的结果。在上表中，我的查询可以简单到如下所示:</p><p id="f7f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1)实际客户点击的URL</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d3b6" class="mm lp iq ne b gy ni nj l nk nl">select path_info from requestlog where &lt;conditon for actual users&gt;</span></pre><p id="a4b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2)用户点击的URL，这些URL是专门为测试自动化而创建的</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a001" class="mm lp iq ne b gy ni nj l nk nl">select path_info from requestlog where &lt;conditon for test users&gt;</span></pre><p id="9932" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将为我们提供两个不同表的数据，我们将在组件SCOAT数据存储中注意到这两个表。</p><h2 id="f561" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">SCOAT解析器</h2><p id="75ed" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><em class="ln">解析器将从SCOAT scrapper获取数据，重新格式化并转换成组件。</em></p><p id="06d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第n级深度格式化:</strong></p><p id="4cec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从SCOAT scrapper接收的查询结果集将包含用户点击的每个URL的大量具体细节。我们需要清理并重新格式化这些URL，以便它们可以归入特定的组件类别。</p><p id="cd61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用第n层深度来格式化URL，我们将把每个匹配模式"<em class="ln">/recruiter/question-report/</em>* "的记录转换为<em class="ln">/recruiter/question-report/</em>。这意味着我们使用了第二层深度，并在那里停下来把它当作一个组件。为了更好地理解它，请看下面的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e551f2a943845719c216533a929470ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*-hPJ3ItAXBY9X5qg7O_WLA.png"/></div></figure><p id="b7e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对所有记录使用这种方法，SCOAT解析器将生成格式化组件及其计数的映射(组件在所有记录中的出现)。</p><h2 id="75ef" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">SCOAT数据存储</h2><p id="c503" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><em class="ln"> Datastore是存储计算所需的各种数据的模块，也存储dynomoDB表中的fina scoat输出。</em></p><p id="a6da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次运行SCOAT时，格式化组件的映射及其出现次数都存储在两个dynomoDB表中。最终计算的细节将存储在第三个dynamoDB表中。</p><p id="d375" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">表1 automation_covered_urls </strong>:自动化组件列表。这是一个单独的条目，每次运行时都会进行更新和调整，以保持自动化组件的列表是最新的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/d8ab85746b93c15c693f20bc84695072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZTuCZxVn60Y8uTQHUztsg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><em class="no">样表模式:</em><strong class="bd lq">automation _ covered _ URLs</strong></figcaption></figure><p id="c5c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">表2 prod _ usage _ URLs</strong>:prod用户常用组件列表。这是一个单独的条目，每次运行时都会进行更新和调整，以保持所用组件的列表是最新的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c28899fa149d209e47ad74ea52c2365a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*fayzFzB9ZISDg-ud0Xzhmw.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><em class="no">样表模式:</em> <strong class="bd lq"> prod_usage_urls </strong></figcaption></figure><p id="308b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">表3 smart_coverage_data : </strong>每个运行细节的最终SCOAT输出。每次运行时，都会在该表中添加一个新条目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/451960a5041d007edd424b3393ec2e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMSCmoOx0Hiu29i4QmHsig.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">样表模式:<strong class="bd lq"> smart_coverage_data </strong></figcaption></figure><p id="54a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在每次运行时，URL的增量将被添加到上面的表中，以便它们总是被更新，以具有自从我们开始使用SCOAT以来的历史数据。</p><h2 id="7582" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">SCOAT分析仪</h2><p id="3398" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">分析器是一个模块，它实际上为应该自动化的组件计算覆盖率和建议。</p><p id="d352" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦数据存储在dynomoDB表中，SCOAT analyzer将使用这些数据并计算所需的覆盖率细节。这将存储在一个名为<strong class="kt ir"> smart_coverage_data </strong>的单独的<strong class="kt ir"> dynamoDB表</strong>中。该表将包含以下详细信息:</p><ol class=""><li id="9130" class="nr ns iq kt b ku kv kx ky la nt le nu li nv lm nw nx ny nz bi translated">计算中使用数据的持续时间(例如，<em class="ln">2021–03–01 _至_ 2021–04–01</em>)</li><li id="505e" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">自动绘制元件图并计数</li><li id="7d66" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">使用的组件和计数图</li><li id="665c" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">覆盖率百分比</li><li id="29d0" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">用户使用但未自动化的组件</li><li id="0807" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">用户不再使用的自动化组件</li></ol><p id="d6eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用这些数据，QA团队将优先考虑SCOAT推荐的自动化组件。通过这种方式，我们确保自动化人们更频繁使用的领域。</p><p id="26ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这本质上是一个python项目，几乎可以在任何机器上实现和运行。您可以使用Amazon EC2机器并在那里查看项目。我们使用AWS CodeBuild来运行SCOAT，因为它不需要我们维护机器。</p><h1 id="934f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">SCOAT模块示例</h1><p id="7fdf" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">从redash获取数据、解析数据、分析数据并生成scoat数据的最终python模块如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="acf0" class="mm lp iq ne b gy ni nj l nk nl"><em class="ln">scoat.py</em></span><span id="61b6" class="mm lp iq ne b gy of nj l nk nl">import scoat_data_store<br/>import scoat_scrapper<br/>import scoat_parser<br/>import run_scoat</span><span id="b74d" class="mm lp iq ne b gy of nj l nk nl">def refresh_and_run_scoat(start_date, end_date):</span><span id="8021" class="mm lp iq ne b gy of nj l nk nl">build_id = “{}_to_{}”.format(start_date, end_date)<br/>    redash_data = scoat_scrapper.get_data(start_date, end_date)<br/>    formatted_data = scoat_parser(redash_data)<br/>    scoat_data_store.update_dynamodb_tables(<br/>                     redash_data,<br/>                     start_date,<br/>                     end_date)<br/>    coverage_data = run_scoat.run_smart_coverage()<br/>    run_scoat.send_slack_digest(coverage_data, start_date, end_date)<br/>    run_scoat.update_dynamo_db_tables(scoat_coverage_data, build_id)</span></pre><p id="e4f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:以上每个导入的模块(<em class="ln"> scoat_data_store.py，scoat_scrapper.py等</em>)都有不止一个方法。以上只是伪级实现的一个例子。</p><p id="35f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我已经在Amazon CodeBuild中实现了SCOAT。这也可以在任何机器上进行。</p><p id="11e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，无论有没有AWS CodeBuild，都可以安排这个运行。该命令将是<em class="ln">" python scoat . py&lt;to _ date&gt;&lt;from _ date&gt;"</em></p><p id="fd1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经安排AWS代码构建项目每15天运行一次。这意味着查询最近15天的数据，并且prod_used_urls和automation_covered_urls的相应表每15天更新一次。然后从这些最新的表数据中生成覆盖结果和建议。</p><p id="4d24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果有人以任何创新的方式解决了覆盖自动化问题，请分享！</p><p id="d5da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编码快乐！</p></div></div>    
</body>
</html>