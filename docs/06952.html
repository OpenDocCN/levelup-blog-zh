<html>
<head>
<title>Creating bug🕷free React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建bug🕷free反应应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-bug-free-react-apps-41466ec6ceec?source=collection_archive---------6-----------------------#2021-01-13">https://levelup.gitconnected.com/creating-bug-free-react-apps-41466ec6ceec?source=collection_archive---------6-----------------------#2021-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="45cf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个好的策略可以消除几类错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ecc3e52c948b886fe166b2c53848e962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sfwf9NSROeTUNZQG6wGZOA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/nennieinszweidrei-10084616/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4517960" rel="noopener ugc nofollow" target="_blank">安妮特·梅尔</a>从<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4517960" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</figcaption></figure><p id="6632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据弗雷德里克·布鲁克斯的论文<em class="ls">神话中的人月</em>，我同意开发者是乐观主义者。我们大多数人都倾向于关注某个功能的幸福之路，在热重装、VSCode和Chrome开发工具的温暖中工作，相信API总是工作，并假设如果有任何错误，QA会发现它。但愿如此。</p><p id="54c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将尝试介绍一些实用的步骤，我们可以采取这些步骤来消除大型JavaScript应用程序中的某些类型的错误。有些可能看起来简单明了，有些有点过度设计，或者有争议，但这些都是来自经验，而不仅仅是猜测。</p><h1 id="6f2f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">🕷不正确的函数参数</h1><p id="b757" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">JavaScript是一种动态类型语言，在函数调用方面非常宽容。无论函数是如何定义的，你都可以调用一个没有参数或者有额外参数的函数。在一个小范围内，错误的使用可能看起来不是一个大问题，但是随着应用程序的增长，它的可重用功能和组件也会增长。随着时间的推移，调用带有不正确参数(对象而不是数组等)、没有参数、参数顺序错误的函数的可能性会增加。再多的单元测试也无法真正捕捉到所有这些，因为有些测试只会在运行时出现。</p><h2 id="0f2e" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:使用TypeScript</h2><p id="c058" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在我看来，TypeScript最大的好处在于它能够自我记录代码和意图，并且它与VSCode的集成非常棒。即使没有特定的类型，TypeScript也会通过类型和签名推断提供足够的保护。但是有一个警告:在将静态类型应用于动态类型语言(如JavaScript)时，肯定会有一些冲突。需要有一个有效的类型脚本策略。以下文章可能会有所帮助:</p><div class="nc nd gp gr ne nf"><a href="https://rajeshnaroth.medium.com/how-i-learned-to-stop-worrying-and-love-typescript-ccda0f96801a" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">我是如何学会停止担忧并爱上打字稿的</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">对于反应开发者来说，这并没有你想象的那么难</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">rajeshnaroth.medium.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt kp nf"/></div></div></a></div><h1 id="8aa0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">🕷 JavaScript坏的部分</h1><p id="ffb3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">JavaScript是一种多范式语言，添加了OOP结构作为语法糖。“this”是一个有缺陷且令人困惑的关键字，构造函数和<em class="ls">新的</em>关键字也是如此。正确理解原型以及它们如何在类的构造中工作需要付出努力。没有完全理解的特性将导致有缺陷的不合格代码。</p><h2 id="5406" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:选择使用JavaScript的精简版本</h2><p id="75d8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这里有一篇文章可以帮助你采用一种精简的JavaScript风格:</p><div class="nc nd gp gr ne nf"><a href="https://medium.com/swlh/trimming-javascript-for-better-dx-f043a9b01591" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">微调JavaScript以获得更好的DX</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在UI开发中拥抱极简主义</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt kp nf"/></div></div></a></div><h1 id="ca70" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">🕷意外突变</h1><p id="0bb3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">命令式代码(while，for，if/else)充斥着可变状态，因此成为了bug的温床。</p><h2 id="8d91" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:使用不可变状态</h2><p id="ba78" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对于简单的数据类型，使用<strong class="ky ir"> <em class="ls"> const。</em> </strong> <em class="ls">让</em>应该是个例外，千万别用<em class="ls"> var </em>。这篇文章应该对此有更清晰的阐述:</p><div class="nc nd gp gr ne nf"><a href="https://rajeshnaroth.medium.com/es6-let-vs-const-304ee34114ef" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">ES6 — let vs const</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">目前公认的最佳实践是永远不要使用var。从const开始，如果你必须重新分配变量…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">rajeshnaroth.medium.com</p></div></div><div class="no l"><div class="nv l nq nr ns no nt kp nf"/></div></div></a></div><p id="d224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数组和对象</strong></p><p id="3b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数组和对象即使被定义为一个<strong class="ky ir">常量</strong>也可以变异。Object.freeze()不能处理嵌套的JSON对象。TypeScript来拯救我们:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="fdf2" class="mq lu iq nx b gy ob oc l od oe">// Arrays</span><span id="5cbc" class="mq lu iq nx b gy of oc l od oe">const list: ReadonlyArray&lt;number&gt; = [ 1, 2, 3];<br/>// list[2] = 10; // is not allowed</span><span id="1c64" class="mq lu iq nx b gy of oc l od oe">// Objects</span><span id="0166" class="mq lu iq nx b gy of oc l od oe">interface IPoint {<br/>  x: number;<br/>  y: number;<br/>}</span><span id="b90e" class="mq lu iq nx b gy of oc l od oe">const point: Readonly&lt;IPoint&gt; = { x: 3, y: 4 };<br/>// point.x = 10; // is not possible</span></pre><p id="4e78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试试这里:<a class="ae kv" href="https://codesandbox.io/s/immutable-state-ujsc3?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/immutable-state-ujsc3?file=/src/App.tsx </a></p><h2 id="9fbf" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:尽可能使用纯函数。</h2><p id="16a7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">养成尽可能编写纯函数的习惯。纯函数没有状态突变，非常容易进行单元测试。</p><h2 id="3bfc" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:写小函数。</h2><p id="f0da" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">大型函数是一种代码味道:它们做得太多了，甚至当它们自身之外没有突变时，它们可能会跟踪一大组容易出现意外错误的状态变量。通过练习，你将能够弄清楚如何将一个大的功能分成“做一件事”的更小的单元。尽可能保持小函数的纯净。</p><h2 id="a2f3" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:停止使用类</h2><p id="3759" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">停止使用类组件。在我们HPE的团队中，我们最近用零类组件完成了两个大型应用程序。太棒了，我们什么都没错过。</p><p id="11bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OOP与函数式编程超出了本文的范围。就我个人而言，在编写了数据和函数之间界限清晰的代码之后，很难再回到什么都是类的OOP。也许这篇文章会改变你的想法。</p><div class="nc nd gp gr ne nf"><a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">再见，面向对象编程</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">我已经用面向对象语言编程几十年了。我用的第一个OO语言是C++然后是Smalltalk…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="og l nq nr ns no nt kp nf"/></div></div></a></div><h2 id="52cd" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:避免命令性循环</h2><p id="e779" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">函数式编程工具，如map、filter、reduce、compose等，都是经过时间考验的结构，我们可以用它们来代替命令式迭代。因此，最小化或完全消除while、for、forEach等的使用，将对抑制这类错误大有帮助。我不记得上次在JavaScript中使用while或for循环是什么时候了。这里有一篇文章更深入地探讨了这个话题。</p><div class="nc nd gp gr ne nf"><a href="https://rajeshnaroth.medium.com/writing-resilient-unbreakable-code-using-functional-patterns-bcd63d28ac1e" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">使用功能模式编写有弹性的、牢不可破的代码</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">应用程序的质量取决于其单元的质量</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">rajeshnaroth.medium.com</p></div></div><div class="no l"><div class="oh l nq nr ns no nt kp nf"/></div></div></a></div><h1 id="3e31" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">🕷可怕的“无法读取未定义的属性”</h1><p id="b214" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当您试图访问一个尚未初始化的对象的属性时，例如，当一个api没有返回视图所期望的内容时，就会发生这种情况。因此，我们被建议写这样令人厌恶的:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="f389" class="mq lu iq nx b gy ob oc l od oe">const firstName = model &amp;&amp; model.address &amp;&amp; model.address.name || model.address.name.first || "";</span></pre><p id="3c00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我们使用来自库的抽象，如<a class="ae kv" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>或<a class="ae kv" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> ramda </a>。</p><h2 id="7316" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:使用？。可选链运算符-默认情况下</h2><p id="8d83" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在我看来，在所有新的JavaScript特性中，可选的链接操作符是我的首选。它通过简化错误检查表达式来降低代码密度。前面的示例现在变成了:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="4ff0" class="mq lu iq nx b gy ob oc l od oe">const firstName =  model?.address?.name?.first || "";</span></pre><p id="86c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的UI团队如此虔诚地遵循这一点，它成为了代码评审期间被调用的主要事情之一。尽管很少，我们甚至使用可选的链接进行流控制:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="1230" class="mq lu iq nx b gy ob oc l od oe">if (onClose) {<br/>  onClose();<br/>}<br/>// can be substituted with:<br/>onClose?.();</span></pre><p id="72a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击此处了解有关可选链接的更多信息:</p><div class="nc nd gp gr ne nf"><a href="https://rajeshnaroth.medium.com/javascript-optional-chaining-bb0a3344e5cc" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">JavaScript可选链接？。</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">它搔着巨大的痒处</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">rajeshnaroth.medium.com</p></div></div></div></a></div><h2 id="b96c" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:使用函数参数默认值。</h2><p id="9b2c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">除非您的逻辑明确需要一个null/undefined值，否则没有理由不初始化任何状态。使用const可以帮助您减轻这种情况，const定义总是被初始化。但是，向函数传递一个未定义的值并不会被自动阻止。<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" rel="noopener ugc nofollow" target="_blank">功能参数默认值</a>在用未定义的值调用时将替换提供的默认值。</p><h1 id="8038" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">🕷运行时数据错误</h1><p id="9aca" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">REST仍然是大量web应用程序事实上的API协议。REST响应通常是复杂JSON结构的数组，它们会随着时间的推移而演变——UI和REST API不同步的风险总是存在。直接在React视图中使用API结果是非常常见的，我们大多数人甚至都不会对此多想。然而，在工作过一些大型企业应用程序之后，我开始意识到许多错误都是因为这个原因而发生的。API数据是可信的，但应该总是被验证。将视图直接与API响应紧密耦合是有风险的。</p><h2 id="bc92" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:将视图与API隔离开来</h2><p id="cb6f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">创建一个模型<strong class="ky ir">接口</strong>(使用TypeScript)来表示<strong class="ky ir">视图。与API数据不同，它包含的信息刚好够视图绑定到——一个简单的JSON对象，通常很少嵌套。创建一个模型<strong class="ky ir">适配器</strong>，一个转换API数据的纯转换函数。</strong></p><p id="a1b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个<a class="ae kv" href="https://codesandbox.io/s/react-model-adapters-1-sg33j" rel="noopener ugc nofollow" target="_blank"> codesandbox </a> React例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们显示了一组地址。API返回:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="8891" class="mq lu iq nx b gy ob oc l od oe">[<br/>   {<br/>      "id":0,<br/>      "firstName":"Mathilde",<br/>      "lastName":"Wilderman",<br/>      "street":"697 Hudson Stream",<br/>      "city":"Lake Ayanaport",<br/>      "state":"North Dakota",<br/>      "zipcode":"80363-3093",<br/>      "status":"unread"<br/>   },<br/>   {<br/>      "id":1,<br/>      "firstName":"Anjali",<br/>      "lastName":"Renner",<br/>      "street":"204 Myra Keys",<br/>      "city":"East Amparo",<br/>      "state":"Massachusetts",<br/>      "zipcode":"66131",<br/>      "status":"marked"<br/>   }<br/>]</span></pre><p id="e0a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像这样直接在视图中使用这些值是很诱人的:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="1929" class="mq lu iq nx b gy ob oc l od oe">      &lt;div &gt;<br/>        &lt;span&gt; Status: {status === "marked" ? "marked" : "unread"}&lt;/span&gt;<br/>        &lt;div&gt;<br/>          &lt;div className="name"&gt;{`$firstName $lastName`}&lt;/div&gt;<br/>          &lt;div className="street"&gt;{street}&lt;/div&gt;<br/>          &lt;div className="street"&gt;{city}&lt;/div&gt;<br/>          &lt;div className="street"&gt;<br/>            {state} {zipcode}<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;</span></pre><p id="9f12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是正如您所看到的，api以多种格式返回一些属性，比如邮政编码。名称和状态字段也需要修改。在视图中填充所有的逻辑会造成混乱，并且对单元测试不友好。请考虑改用此转换函数。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="b8f4" class="mq lu iq nx b gy ob oc l od oe">const <strong class="nx ir">toSimpleZip</strong> = (zipcode: string) =&gt; (zipcode?.split("-") || [])?.[0] || "n/a";</span><span id="d6c2" class="mq lu iq nx b gy of oc l od oe">const <strong class="nx ir">getIcon</strong> = (status: string) =&gt; {<br/>  const DEFAULT = "email";<br/>  const statusMap: object = {<br/>    unread: "mark_email_unread",<br/>    marked: "mark_email_read",<br/>    read: DEFAULT<br/>  };<br/>  return statusMap[`${status}`] || DEFAULT;<br/>};</span><span id="43cc" class="mq lu iq nx b gy of oc l od oe">const <strong class="nx ir">apiToModel</strong> = (address) =&gt; ({<br/>  name: getFullName(address.firstName, address.lastName),<br/>  street: address.street || "",<br/>  city: address.city || "",<br/>  state: address.state || "",<br/>  statusIcon: getIcon(address.status),<br/>  zipcode: toSimpleZip(address.zipcode)<br/>});</span></pre><p id="aa95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建这样的适配器有一定的好处:</p><ul class=""><li id="3e34" class="ok ol iq ky b kz la lc ld lf om lj on ln oo lr op oq or os bi translated">视图现在很简单，<a class="ae kv" href="https://codesandbox.io/s/react-model-adapters-1-sg33j?file=/src/address/__tests__/Address.test.tsx" rel="noopener ugc nofollow" target="_blank">可以很容易地进行单元测试</a>。</li><li id="7168" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">如果API无法提供回退值，适配器可以提供回退值。UI中不再有难看的“未定义”或“空”字符串。</li><li id="61de" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">适配器及其相关的转换功能<a class="ae kv" href="https://codesandbox.io/s/react-model-adapters-1-sg33j?file=/src/address/__tests__/adapter.tests.ts" rel="noopener ugc nofollow" target="_blank">可以针对正负条件进行简单的单元测试</a>。</li><li id="2085" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">对API提供什么和视图需要什么有一个清晰的定义，会导致清晰的类型接口。这导致代码自我文档化。</li></ul><h2 id="25a5" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提示:将表单与API隔离开来</h2><p id="d711" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">UI最耗时也是最困难的部分之一是编写好的表单。许多错误源于表单模型和与之交互的API之间的不匹配。表单不一定要模拟API数据的确切形状，当API嵌套时，表单的模型通常是平面的。因此，使用适配器将数据转换成表单有助于减少大量错误。我已经在另一篇关于Formik的博客中讨论过这个问题。</p><div class="nc nd gp gr ne nf"><a href="https://rajeshnaroth.medium.com/formik-forms-and-api-integration-7ebaa029d658" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">Formik表单和API集成</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在表单和API之间使用数据转换器</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">rajeshnaroth.medium.com</p></div></div><div class="no l"><div class="oy l nq nr ns no nt kp nf"/></div></div></a></div><h1 id="1030" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">试验</h1><p id="c9ec" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个话题已经被反复讨论了几十年，但是由于许多合理的原因，测试在许多项目中处于次要地位，成为技术债务。随着软件的老化和所有权的变更，测试变得更加重要。详细讨论超出了本文的范围，但是我们在团队中遵循以下原则:</p><ul class=""><li id="669b" class="ok ol iq ky b kz la lc ld lf om lj on ln oo lr op oq or os bi translated">尽可能写纯函数，它们容易测试。</li><li id="2671" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">如果一个逻辑可以通过移动到它自己的函数中来进行单元测试，那么它就应该是单元测试的。</li><li id="19c3" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">单元测试应该有正面和负面的测试用例。如果适用，应提供空检查和默认行为。</li><li id="ce1e" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">为不能进行单元测试的部分编写验收测试。</li><li id="7b2b" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">使用代码覆盖工具来揭示缺失的测试区域。</li></ul></div><div class="ab cl oz pa hu pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="ij ik il im in"><p id="1aa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这些提示对你有用。在你的团队中有没有帮助你减少bug密度的约定？请在评论中让我知道。</p></div></div>    
</body>
</html>