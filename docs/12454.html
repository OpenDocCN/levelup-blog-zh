<html>
<head>
<title>Benchmark: How to use C# Parallel.ForEachAsync for 3x faster bulk file downloading time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基准:如何使用C#并行？ForEachAsync将批量文件下载速度提高了3倍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/benchmark-how-to-use-c-parallel-foreachasync-for-3x-faster-bulk-file-downloading-time-5c847297688f?source=collection_archive---------6-----------------------#2022-06-12">https://levelup.gitconnected.com/benchmark-how-to-use-c-parallel-foreachasync-for-3x-faster-bulk-file-downloading-time-5c847297688f?source=collection_archive---------6-----------------------#2022-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/749bd5aa13ff00b636bec80210d0003a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*xO434v0nTkWhcUDd4p6Z7w.png"/></div></figure><p id="f6a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最近我在做一个<a class="ae ks" href="https://github.com/stewartcelani/autodesk-construction-cloud-backup" rel="noopener ugc nofollow" target="_blank">项目，通过<a class="ae ks" href="https://forge.autodesk.com/developer/documentation" rel="noopener ugc nofollow" target="_blank">Autodesk BIM 360/建筑云API </a>备份文件</a>。</p><p id="c818" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我最初的原型花了12个小时备份了大约100 GB(11，737个文件夹中的40，230个文件)，这并不好。由于向客户添加数据的速度很快，在1到2年内，备份将需要24小时以上。</p><p id="c1be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在程序重写(包括将文件下载逻辑从同步foreach循环移到并行循环)之后。对于ForEachAsync循环，我能够将夜间备份时间缩短到3小时。</p><p id="418a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想量化一下4倍的性能提升有多少是由于重写与并行。ForEachAsync loop在令人敬畏的Benchmark.NET<a class="ae ks" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank">进行了两次基准测试。</a></p><p id="e928" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第一个是包含300 MB(30个文件夹中的136个文件)的小项目:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ff5c" class="lc ld iq ky b gy le lf l lg lh">BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19044.1645 (21H2)<br/>Intel Core i7-5820K CPU 3.30GHz (Broadwell), 1 CPU, 12 logical and 6 physical cores<br/>.NET SDK=6.0.202<br/>[Host]     : .NET 6.0.4 (6.0.422.16404), X64 RyuJIT<br/>Job-KSORIT : .NET 6.0.4 (6.0.422.16404), X64 RyuJIT<br/><br/>IterationCount=3 LaunchCount=1 WarmupCount=1<br/><br/>|          Method |    Mean |   Error | StdDev |<br/>|---------------- |--------:|--------:|-------:|<br/>|    ParallelLoop | 123.2 s | 61.06 s | 3.35 s |<br/>| SynchronousLoop | 299.8 s | 74.74 s | 4.10 s |</span></pre><p id="a80b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二个是一个包含26gb(973个文件夹中的10，653个文件)的大型项目:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="48e4" class="lc ld iq ky b gy le lf l lg lh">BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19044.1706 (21H2)<br/>Intel Core i7-5820K CPU 3.30GHz (Broadwell), 1 CPU, 12 logical and 6 physical cores<br/>.NET SDK=6.0.202<br/>[Host]     : .NET 6.0.4 (6.0.422.16404), X64 RyuJIT<br/>Job-QIVIZX : .NET 6.0.4 (6.0.422.16404), X64 RyuJIT<br/><br/>IterationCount=3  LaunchCount=1  RunStrategy=Monitoring  <br/>WarmupCount=0<br/><br/>|          Method |     Mean |    Error |   StdDev |<br/>|---------------- |---------:|---------:|---------:|<br/>|    ParallelLoop |  98.83 m |  12.97 m |  0.711 m |<br/>| SynchronousLoop | 300.62 m | 368.38 m | 20.192 m |</span></pre><p id="39f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以平行的改进。ForEachAsync大概是3倍。</p><p id="cdcd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我很想运行更多的benchmark 2迭代来减少错误和stddev，但是运行了一天，结果与benchmark 1和100 GB备份的每夜真实性能相匹配。</p><p id="8ae5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，在上面的基准测试中，26 GB备份需要100分钟，这比每天晚上备份的速度要慢得多。</p><p id="d961" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">实际基准跑步者:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="029c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第49行的SynchronousLoop任务完成了您所期望的任务，foreach循环遍历IEnumerable文件，并将每个文件传递给DownloadFile方法:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">第20–22行包含实际的文件下载</figcaption></figure><p id="263e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">文件下载逻辑封装在一个<a class="ae ks" href="https://github.com/App-vNext/Polly" rel="noopener ugc nofollow" target="_blank"> Polly </a> AsyncRetryPolicy中，基本上只有3行(20–22)。</p><p id="b2eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">SynchronousLoop和ParallelLoop都使用上述方法下载文件。</p><p id="18fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基准测试的第44行上的ParallelLoop的“DownloadContentsRecursively”调用使用了下面结合了Parallel的方法。ForEachAsync:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">配置。默认情况下，MaxDegreeOfParallelism = 8</figcaption></figure><p id="4862" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如您在第14行看到的，与同步循环调用的是同一个DownloadFile方法。</p><p id="6c25" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当情况需要时，C#开发团队真的使得将并行性结合到我们的应用程序中变得非常简单。</p><p id="a721" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望你觉得有用！</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lo lj l"/></div></figure></div></div>    
</body>
</html>