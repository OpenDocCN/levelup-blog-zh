# 变得更懒，变得更有效率

> 原文：<https://levelup.gitconnected.com/be-more-lazy-become-more-productive-816c629a06c5>

![](img/223c237ea369e0b2bee9e2f586ba1c1f.png)

在这篇标题矛盾的文章中，我们将懒惰作为 Python 中函数式编程的一个核心方面来研究。我说的不是[吊床驱动开发](https://melreams.com/2017/05/rich-hickey-hammock-driven-development/)或者一些这样悠闲的有标题的范式，而是[懒评](https://en.wikipedia.org/wiki/Lazy_evaluation)。我们将看到懒惰评估如何通过重构一个小例子来提高可重用性和可组合性，从而提高您的工作效率，同时引入懒惰。

简单地说，惰性求值意味着直到需要表达式的结果时才会对其求值。对比一下*急切评估*，这是命令式编程的标准。在急切求值下，函数在被调用时会立即计算它们的结果(并执行它们的副作用)。例如，考虑这个名为`get_json`的 python 函数，它调用一个 web api 作为副作用，并将响应解析为 json:

现在，假设我们想要实现一个带有简单回退机制的重试策略。我们可以采取急切的方法并适应`get_json`:

这是可行的，但是这个解决方案有一个巨大的缺点:我们不能对其他类型的 HTTP 请求重用重试策略。或者替代地，但等价地:`get_json`违反了单一责任原则，因为它现在有三种责任:

*   调用 api
*   解析 json
*   再试

这使得它很难重复使用。让我们通过偷懒来解决它。为了保持一般性，我们将定义一个类型别名来模拟惰性值，这些惰性值产生时有或没有副作用。让我们称这个别名为`Effect`,因为它允许我们将副作用视为可以由我们的程序操纵的一级值，从而从“副作用”中取出“副作用”。

我们将使用这个别名来实现函数`retry`，它可以接受任何`Effect`，并使用之前相同的回退机制重试:

`retry`将(例如)HTTP 请求的结果视为可以操作的惰性值。我在这里使用术语*懒惰值*，因为它非常符合我们的主题，但实际上我可以说`retry`使用`get_json`作为高阶函数。通过将函数视为可以传递的惰性值，`retry`或多或少地实现了总的可重用性。

到目前为止一切顺利。现在让我们实现一个名为`run_async`的函数，它并行执行惰性值。显然，我们希望能够将`run_async`与`get_json`和`retry`一起使用:

(这实际上是行不通的，因为我们已经有了 lambdas，而且`multipocessing`不喜欢没有第三方库，但是请原谅我。)

这很好，但是你可能会反对我们把代码弄得一团糟。我同意。特别是我认为我们的“粘合”功能`get_json_with_retry`和`get_json_async_with_retry`笨拙得令人尴尬。在我看来，缺少的是将懒惰值粘合在一起的通用解决方案，这会使这些专用粘合函数变得多余。

为了实现这一点，我们将使用以下教条:

*   执行副作用的函数返回`Effect`实例。换句话说，它们不是直接执行计算或副作用，而是返回*一个结果(和/或副作用)的惰性描述，该描述可以与在* `*Effect*` *实例*上操作的函数相结合。
*   对`Effect`实例进行操作的函数返回新的`Effect`实例

使用这种方案，任何惰性结果都可以由对惰性结果进行操作的函数无限组合。的确，对懒惰结果进行操作的函数可以与它们自己进行组合！

因此，让我们通过把我们的懒惰提高到纨绔子弟的昏睡水平来最大化我们解决方案的可重用性。

![](img/980aa356897849d03dc116e881b9ac59.png)

让我们从重构`get_json`返回一个`Effect`开始。

相当直接。现在让我们对`retry`和`run_async`做同样的事情

有了这个，我们就可以用最少的努力，按照我们内心的愿望，组合出我们功能的任何变化:

首先，要意识到我们可以进一步重用`get_json_with_retry`和`get_json_async_with_retry`以及操作`Effect`实例的任何函数。此外，请注意*懒惰*(或高阶函数)使我们能够以这种程度的重用进行编程，并允许在这种高抽象级别上的组合性(最终在整个程序的级别上)。

当函数式程序员声称用函数式风格编程使你更有效率时，这就是原因:函数式编程(通常涉及懒惰评估)可以极大地提高可重用性和可组合性，这意味着你可以用更少的资源做更多的事情。所有这些优点都是我创作库 [pfun](http://pfun.rtfd.io) 的动机的一部分，这个库使得用函数式风格编写 Python 成为可能，在这个例子中没有所有的样板文件和仪式。

额外的好处是，函数式程序通常更容易预测，也更容易推理。此外，通过少量修改，我们在这里开发的模式可以扩展到完全类型安全的[依赖注入](https://pfun.dev/effectful_but_side_effect_free#the-module-pattern)和[错误处理](https://pfun.dev/effectful_but_side_effect_free#error-handling)。此外，静态类型检查变得更加有用，因为所有函数都必须返回值，即使它们仅仅产生副作用(在这种情况下，它们将返回`Effect[None]`)。

为了重构我们的例子，我们已经在某种程度上重新发明了一个通用的函数模式:神秘的 [IO](https://en.wikipedia.org/wiki/Monad_(functional_programming)#IO_monad_(Haskell)) 类型(在我们的例子中我们称之为`Effect`，我希望你在这一点上一点也不觉得神秘)。关于`IO`是什么和做什么有很多困惑，尤其是在 Haskell 和 Scala 程序员的函数式编程俱乐部之外。因此，你有时会听到`IO`被解释为:

*   执行副作用的函数返回`IO`
*   不产生副作用的函数不会产生副作用

虽然这个解释严格来说并不是不正确的，但它非常不充分，因为它没有提到任何关于懒惰的事情，而懒惰是`IO`的核心特征。基于这种天真的解释，您可能会尝试这样的事情:

这个`IO`实现只是简单地标记执行 IO 的函数的返回值，让调用者清楚地知道涉及到了副作用。这是否有用是[有些争议的问题](https://degoes.net/articles/no-effect-tracking)，*但是它没有带来我们在本文中讨论的任何函数式编程的好处，因为这个* `*IO*` *版本是热切的*。

总之:懒惰(或高阶函数)可以实现彻底的重用和组合，这两者都会让你更有效率。要开始使用 Python 进行函数式编程，请查阅 [pfun](https://pfun.dev) 文档，或者 [github 库](http://github.com/suned/pfun)。

*最初发布于*[*dev . to*](https://dev.to/suned/be-more-lazy-become-more-productive-2cnb)*。*