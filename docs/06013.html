<html>
<head>
<title>Functional Dynamic Programming — Scala Cats and Free Monad</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式动态编程——Scala猫和自由单子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-dynamic-programming-scala-cats-and-free-monad-b71c34c209?source=collection_archive---------8-----------------------#2020-10-19">https://levelup.gitconnected.com/functional-dynamic-programming-scala-cats-and-free-monad-b71c34c209?source=collection_archive---------8-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c2da07b0fad0c821e07f4038ec25fb83.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*RoUQK-i-vQoe5gVS7M4d9g.png"/></div></figure><p id="ef20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用自上而下的动态编程算法探索Scala Cats中的自由单子，看看FP中的概念是如何从数学中派生出来的。</p><p id="5fab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章:</p><ul class=""><li id="720c" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><strong class="jw ir"> <em class="lb">不涵盖</em> </strong> <em class="lb"> : </em>关于动态编程(DP)或者函数式编程(FP)或者Scala猫或者单子的基础知识。</li><li id="208d" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><strong class="jw ir"> <em class="lb">正在探索</em> </strong> <em class="lb"> : </em>使用记忆化和有状态计算解决DP问题的FP机制(自由单子包装的可变数组)</li><li id="0fcb" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><strong class="jw ir"> <em class="lb">也是</em> </strong>:是之前文章《<a class="ae lh" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-92e68efe808" rel="noopener">带Haskell的Functional DP</a>》和《<a class="ae lh" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-top-down-and-bottom-up-7ccade222337" rel="noopener">带Haskell自顶向下的Functional DP</a>》的后续，这两篇文章探讨了STArray和ST Monad的机制。我们尝试使用Cats库提供的免费单子做同样的事情。</li></ul><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi li"><img src="../Images/b74a9c711f276b231b7c019c600fcaf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IvMVzli3WE5vmMap"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@badgerblack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">考尔·克里斯詹</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e794" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">从范畴论到自由单子。</strong></p><p id="f193" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">范畴理论是一个庞大的课题，需要在毕业研究期间投入大量的时间和兴趣来发展对它的直觉。</p><p id="b5b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">哲学/数学指针可以在这里找到<a class="ae lh" href="https://plato.stanford.edu/entries/category-theory/" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir"><em class="lb"/></strong></a><strong class="jw ir"><em class="lb"/></strong>和<strong class="jw ir"><em class="lb"/></strong><a class="ae lh" href="https://www.math3ma.com/blog/what-is-category-theory-anyway" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir"><em class="lb">这里</em> </strong> </a>。例如，数学集合是所有集合的范畴。</p><p id="b689" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用几行文字来总结是不可能的，甚至很难在一个博客中涵盖，但是我们将尝试不涉及太多技术，只保留FP和代数元素。</p><ul class=""><li id="178a" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">一个类别可以被看作是一个对象的集合，这些对象之间有箭头(同方向指针一样)。</li></ul><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/1d9ce2606335c6b46177fd8304b30531.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*rcO4oGgnPlqDi0gPvuX9dA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lw">类别C </strong>具有对象C1、C2、C3之间的态射f和g</figcaption></figure><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="b56a" class="mc md iq ly b gy me mf l mg mh">f : C1 -&gt; C2 <br/>g : C2 -&gt; C3 <br/>f . g : C1 -&gt; C3 <br/>id : C1 -&gt; C1</span></pre><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/ae0c65b33e1bea8a3ec29f89f0be7c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*PfalCHNHEZJlOPNiPBzvsA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lw">范畴D </strong>具有对象D1、D2、D3之间的态射F(f)和G(g)</figcaption></figure><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="3a8b" class="mc md iq ly b gy me mf l mg mh">F (f): D1 -&gt; D2 <br/>F (g) : D2 -&gt; D3 <br/>F (g . f) : D1 -&gt; D3 <br/>id: D1 -&gt; D1  ... etc</span></pre><ul class=""><li id="81b8" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">函子是从一个类别<strong class="jw ir"> C </strong>的对象到另一个类别<strong class="jw ir"> D </strong>的映射，它保留了一些结构。</li></ul><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="e5d6" class="mc md iq ly b gy me mf l mg mh">F: C -&gt; D or <br/>F(C1) -&gt; D1<br/>F(C2) -&gt; D2 <br/>F(C3) -&gt; D3</span></pre><ul class=""><li id="2a5d" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">也可以读作“<strong class="jw ir"> <em class="lb">一个协变函子F : C - &gt; D把C中的对象和态射都发送给D中的对象和态射</em> </strong>”。</li><li id="7a7b" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">将类别C中的对象映射到同一类别C的函子是内函子。</li></ul><p id="467e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可以观察到各种数学定律和性质，如</p><ul class=""><li id="72f6" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">合成的结合律=&gt; f . (g . h) = (f . g)。具有三个态射f，g和h。</li><li id="8f37" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">态射的同一律=&gt; id: C1 -&gt; C1</li><li id="cb59" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">可能还有其他的，比如交换性等等。</li></ul><p id="2ca5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">类似地，像幺半群、单子、自然变换这样的概念可以通过围绕这些对象、它们的关系、性质和规律的变形进行更深入的研究而导出。</p><p id="6e31" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">自然转变</strong></p><p id="42a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们观察了类别C和D之间的函子F，以及它如何将C中的每个对象映射到D中的一个对象。</p><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="968a" class="mc md iq ly b gy me mf l mg mh"><strong class="ly ir">F</strong>: C -&gt; D</span></pre><p id="e8c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在想象另一个函子G，它类似地在C和D之间映射，就像</p><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="791a" class="mc md iq ly b gy me mf l mg mh"><strong class="ly ir">G</strong>: C -&gt; D </span></pre><p id="751b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">自然变换是从函子F到G的函数τ，也可以描述为</p><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="4112" class="mc md iq ly b gy me mf l mg mh">τ: F -&gt; G            </span></pre><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c2da07b0fad0c821e07f4038ec25fb83.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*RoUQK-i-vQoe5gVS7M4d9g.png"/></div></figure><p id="aa65" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用Scala例子描述上面的行话</p><ul class=""><li id="97a1" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">选项、列表、任一项等是从C到D的函子</li><li id="2569" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">τ，自然变换是两个函子之间的函数。</li><li id="6d1a" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">所以，一个自然的转化可以看做是这两个关系之间的关系(或者是两个箭头之间的一个箭头)。</li></ul><p id="a7d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">(注:</strong>以上对自然转化的定义仅仅是一种理解概念的尝试，但它并不是一个纯粹的定义，因为，在纯粹的意义上，我们将不得不根据C和D两个不同的范畴来思考，而且它还要稍微详细一些。)</p><p id="ff97" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">类似地，自由单子是范畴理论中的一个派生概念(或结构)，需要中级到高级的学科知识。</p><p id="49f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面用图表讨论的目的是为了从范畴理论中追溯一个自由单子的粗略旅程。</p><p id="3db6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">回到我们的DP问题，这里探讨的是解决<a class="ae lh" href="https://en.wikipedia.org/wiki/Derangement" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="lb">计数错位</em> </strong> </a>问题的自上而下的方法<a class="ae lh" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-92e68efe808" rel="noopener"><strong class="jw ir"><em class="lb"/></strong></a>。</p><p id="72a9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，来自博客“<a class="ae lh" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-top-down-and-bottom-up-7ccade222337" rel="noopener">功能性DP，Haskell自上而下</a>”的Haskell版本转载如下。Scala Cats版本紧随其后。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="26aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">总结一下，</p><ul class=""><li id="6d7b" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">它是在一元块<strong class="jw ir"> runSTArray </strong>中使用递归的自顶向下版本。</li><li id="5de1" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">使用-1初始化STArray来调用runSTArray，并为arr(1)和arr(2)设置基本用例。</li><li id="b3de" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">调用cdRecursive函数，该函数接受MArray的实例，如果arr(n) = -1，则在内部计算并变异STArray</li><li id="5ac3" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">对于数组索引I，如果arr(i) == -1，则cdRecursive使用以下公式递归计算并更新arr(i ),如下所示</li></ul><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="1ade" class="mc md iq ly b gy me mf l mg mh">arr(i) = (i-1) * ( arr(i-1) + arr(i-2) )</span></pre><p id="08bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下图解释了我们的突变在runSTArray中是如何安全的，并最终在Haskell中返回一个“纯”不可变数组。(虽然，在这里，我们对最终返回数组不感兴趣，我们只对arr(n)计算值部分感兴趣。)</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/5256712de544ac429036dfe35ad63d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*N1TdWl-KmBP6U4fiZi9hJQ.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">runSTArray中的安全突变</figcaption></figure><p id="1a86" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Scala猫免费单子版</strong></p><p id="a8d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就像Haskell有一个runSTArray一元计算，以一种包装安全的方式处理可变数组，我们可以为Scala数组创建基于Scala的一元包装器。</p><p id="de6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">什么是“自由单子”？</p><p id="3530" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于“自由”更详细的解释，typelevel.org关于自由单子的详细文档是<a class="ae lh" href="https://typelevel.org/cats/datatypes/freemonad.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="lb">此处</em> </strong> </a>。</p><p id="c385" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">总而言之，一个自由的单子</p><ul class=""><li id="78f5" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">是一种将有状态计算视为数据的方式。</li><li id="95cc" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">用于创建DSL</li><li id="a80d" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">是以堆栈安全的方式执行这些计算的一种方式</li></ul><p id="637d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“自由单子”的美丽和强大之处在于它能够定义我们自己的ADT，也就是导致DSL的代数和解释器</p><p id="3206" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“自由单子”可能不仅限于IO，还可以用于处理可变集合和数组。</p><p id="dfcb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是完整的Scala代码和解释。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="04f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一步一步解释。</p><p id="3d3e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">第一步:</strong>定义代数</p><ul class=""><li id="ea08" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">通过为抽象指令(put和get)创建ADT(代数数据类型),也称为AST(抽象语法树),表示计算，我们将使用它来创建程序。</li><li id="fef7" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">由于是ADT，我们将计算视为数据。</li><li id="fa0e" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">我们将为数组实现基于索引的get和set。</li></ul><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="3a1f" class="mc md iq ly b gy me mf l mg mh">sealed trait ArrayA[A]<br/>case class Put[T](idx: Int, value: T) extends ArrayA[Unit]<br/>case class Get[T](idx: Int) extends ArrayA[Option[T]]</span></pre><p id="f8be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">步骤2: </strong>创建DSL(领域特定语言)</p><ul class=""><li id="f782" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们的DSL包含了基于“域”的小数组存储的函数。</li><li id="1469" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">我们可以通过把(Free.lift) ArrayA[A]提升到Free[ArrayA，A]来创造包裹我们行为的自由单子</li></ul><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="f96c" class="mc md iq ly b gy me mf l mg mh">type ArrayStore[A] = Free[ArrayA, A]</span><span id="8348" class="mc md iq ly b gy mm mf l mg mh">// Put returns nothing (i.e. Unit).<br/>  def put[T](idx: Int, value: T): ArrayStore[Unit] =<br/>    Free.liftF[ArrayA, Unit](Put[T](idx, value))</span><span id="c1e6" class="mc md iq ly b gy mm mf l mg mh">// Get returns a T value.<br/>  def get[T](idx: Int): ArrayStore[Option[T]] =<br/>    Free.liftF[ArrayA, Option[T]](Get[T](idx))</span></pre><p id="242c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">步骤3: </strong>我们实际的程序monadic cdRecursive将使用上面创建的DSL，它有点类似于上面的Haskell版本</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4859" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">第四步:</strong>解释器用于执行我们的程序描述来执行它。<br/>解释器是一个<strong class="jw ir">自然变换</strong>，可以把F变换成G写成F[_] ~ &gt; G[_]的函数。</p><p id="2897" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">参考上面关于范畴理论和自然转化的小讨论。</p><p id="c364" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Cats库提供函数k</p><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="35d0" class="mc md iq ly b gy me mf l mg mh">cats.arrow.FunctionK</span></pre><p id="2bb4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它接受F[A]并返回G[A]</p><p id="c99e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种情况下，我们的解释器是一个自然转换ArrayA ~&gt; Id，其中Id是最简单的monad，即identity monad，它在cats中被定义为一个简单的类型容器。</p><p id="ef96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个使用可变数组的不纯版本。你可以写一个不可变的版本，但是数组数据结构并不合适，因为空间使用会降级得更快(因为对于每次迭代，不可变数组中没有共享的<strong class="jw ir">结构)。对于不可变版本，可以使用HashMap或其他基于树的数据结构，这些数据结构本身就是空间优化的。</strong></p><p id="5fe2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">鉴于这种方法为突变提供了足够的隔离，我们继续使用可变数组。</p><p id="4c8c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这段代码有缺陷，但它足以代表将突变视为数据的整体概念。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="32f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">第五步:</strong>最后，要执行我们的程序，只需使用解释器对程序进行foldMap，并提供“n”，其中n是我们要传递的整数，用于计算n项的排列，解释器也将使用n来创建n的数组用于记忆。</p><p id="9326" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Free.foldMap使用蹦床技术以堆栈安全的方式执行。</p><pre class="lj lk ll lm gt lx ly lz ma aw mb bi"><span id="6b22" class="mc md iq ly b gy me mf l mg mh">val result: Option[BigInt] = cdRecursive(n).foldMap(interpreter(n))<br/>println(result)</span></pre><p id="e4ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，总结一下</p><ul class=""><li id="97c3" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们已经看到了如何使用免费的单子来创建我们自己的DSL。</li><li id="f9fe" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">我们可以看到函数式编程是如何从数学概念中获得基础的。</li><li id="0456" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">为了从这种能力中获益，我们需要用纯粹可靠的函数和代数数据类型来表达我们的抽象。</li><li id="5d56" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">虽然一开始理解这个概念有点困难，但如果我们遵循数学中的直觉链，它有助于产生可读和可测试的代码，甚至更重要的是，<strong class="jw ir">一个可以被推理的代码或应用。</strong></li></ul></div></div>    
</body>
</html>