<html>
<head>
<title>Transaction Isolation Levels in MS SQL: Ultimate Guide for Backend Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MS SQL中的事务隔离级别:后端开发人员终极指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/transaction-isolation-levels-in-ms-sql-guide-for-backend-developers-6a5998e34f6c?source=collection_archive---------0-----------------------#2021-08-01">https://levelup.gitconnected.com/transaction-isolation-levels-in-ms-sql-guide-for-backend-developers-6a5998e34f6c?source=collection_archive---------0-----------------------#2021-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3c8594c01b2b4a8ede6ffef256dbeb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6zJhSa6efSJAzZNH"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@naipo_de?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> naipo.de </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f133" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择正确的事务隔离级别是关系数据库设计和开发过程中的一个重要部分，因为它消除了大量的并发问题。</p><p id="661f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将重点关注那些使用锁来解决并发问题的事务隔离级别，比如未提交读、提交读、可重复读和可序列化。</p><p id="c790" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="#4808" rel="noopener ugc nofollow">共享(S) vs排他(x)锁</a> <br/> <a class="ae kf" href="#2a4a" rel="noopener ugc nofollow">读未提交</a> <br/> ∘ <a class="ae kf" href="#8261" rel="noopener ugc nofollow">脏读问题</a> <br/> ∘ <a class="ae kf" href="#673c" rel="noopener ugc nofollow">读未提交vs NOLOCK表提示</a> <br/> ∘ <a class="ae kf" href="#ac08" rel="noopener ugc nofollow">什么时候使用读未提交？</a> <br/> <a class="ae kf" href="#7fdb" rel="noopener ugc nofollow">读提交</a> <br/> ∘ <a class="ae kf" href="#f296" rel="noopener ugc nofollow">读提交如何解决脏读问题？</a> <br/> ∘ <a class="ae kf" href="#8955" rel="noopener ugc nofollow">不可重复读取问题</a> <br/> ∘ <a class="ae kf" href="#b494" rel="noopener ugc nofollow">丢失更新问题</a> <br/> <a class="ae kf" href="#21d4" rel="noopener ugc nofollow">可重复读取</a> <br/> ∘ <a class="ae kf" href="#db97" rel="noopener ugc nofollow">可重复读取如何解决不可重复读取问题？</a> <br/> ∘ <a class="ae kf" href="#6eef" rel="noopener ugc nofollow">可重复读取如何解决更新丢失问题？</a> <br/> ∘ <a class="ae kf" href="#5ba2" rel="noopener ugc nofollow">幻影读取问题</a> <br/> <a class="ae kf" href="#647c" rel="noopener ugc nofollow">可序列化</a> <br/> ∘ <a class="ae kf" href="#4333" rel="noopener ugc nofollow">可序列化如何解决幻影问题？</a> <br/> <a class="ae kf" href="#ba66" rel="noopener ugc nofollow">总结</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="4808" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">共享锁与独占锁</h1><p id="9d71" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">理解关键的区别，至少是共享锁(S)和排他锁(X)之间的区别，对于理解事务隔离级别是很重要的。</p><ul class=""><li id="8e07" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">读操作(SELECT)获取资源(行、键、表、页等)上的共享锁。)在读取数据之前。</li><li id="9d2e" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">数据修改操作(插入、更新、删除)会在修改数据之前获取独占锁。</li><li id="3d49" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">即使资源已经有另一个共享锁，也可以为该资源获取共享锁。一个资源可以有任意多的共享锁，因为并行读取是一种安全的操作。</li><li id="21b2" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">只有当资源还没有共享锁或排他锁时，才能为其获取排他锁，以确保一次只有一个事务可以修改数据。</li><li id="b3d7" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">如果无法获取共享锁或独占锁，事务将一直等到锁被释放(不适用于shapshot隔离级别)。</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="2a4a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">未提交读取</h1><p id="5357" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">顾名思义，这种事务隔离级别允许一个事务读取已被另一个事务修改但尚未提交的数据。</p><p id="aa6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Read uncommitted是MS SQL Server中最低的隔离级别，可以导致所有可能类型的并发现象:</p><ul class=""><li id="3101" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">脏读</li><li id="3cab" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">丢失的更新</li><li id="2ded" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">不可重复读取</li><li id="d93b" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">幻像读取</li></ul><h2 id="8261" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">脏读问题</h2><p id="626c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">让我们举一个例子，说明为什么脏读问题会发生在未提交读隔离级别。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1eb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个并发现象的经典例子，称为<strong class="ki iu">脏读</strong> —第二个事务读取第一个事务没有提交的数据。</p><p id="3dfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个事务更新了行，因此它在正在更新的行上放置了一个排他锁(X)。</p><blockquote class="nu nv nw"><p id="24bd" class="kg kh nx ki b kj kk kl km kn ko kp kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">无论事务隔离级别如何，事务总是获得它所修改的数据的独占锁，并持有该锁，直到事务结束。</p></blockquote><p id="a3df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个事务在执行SELECT语句之前不获取共享锁(<strong class="ki iu">在read uncommitted隔离级别</strong>根本不获取共享锁)，所以没有什么可以阻止第二个事务读取第一个事务最终将回滚的数据。</p><h2 id="673c" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">未提交读vs NOLOCK表提示</h2><p id="41df" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">事务隔离级别规则适用于事务中的所有操作。例如，如前所述，如果读隔离级别设置为read uncommitted，则该事务中的SELECT查询都不会获取它们正在访问的资源的共享锁。</p><p id="8530" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NOLOCK表提示可用于特定的查询。当使用NOLOCK提示查询数据时，不会获取共享锁。换句话说，NOLOCK表提示提供了为特定查询而不是为整个事务设置read uncommitted隔离级别的能力。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="31c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个事务以默认的已提交读级别运行，但是内部select查询忽略事务隔离级别，并且由于NOLOCK表提示，就像设置了未提交读级别一样运行。</p><h2 id="ac08" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">何时使用未提交读取？</h2><p id="366c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">对事务使用read uncommitted隔离级别或对SELECT查询使用NOLOCK表提示是查询不太可能更改的数据或在创建后实际上从不更改的静态数据的好选择。</p><p id="8f18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">读取未提交的隔离级别或NOLOCK提示不需要共享锁，这提高了查询数据时的性能。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="7fdb" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">已提交读取</h1><p id="e835" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">读取提交级别隔离是MS SQL server中的默认隔离。提交读取解决了脏读问题，但这些问题仍然会发生:</p><ul class=""><li id="9ba9" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">丢失的更新</li><li id="844a" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">不可重复读取</li><li id="a641" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">幻像读取</li></ul><h2 id="f296" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">Read Committed如何解决脏读问题？</h2><p id="c9a5" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当事务在read committed隔离级别执行时，每个SELECT查询都必须获取它所访问的资源上的共享锁。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6d56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，即使没有显式设置，这两个事务都在读提交级别运行。</p><p id="b28d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了理解为什么脏读不再是问题，让我们一步一步地分析当两个事务同时执行时会发生什么:</p><ul class=""><li id="35c2" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">第一个事务在运行UPDATE语句之前获得一个排他锁(X ),并一直持有该锁，直到事务结束。</li><li id="3314" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务试图获取与第一个事务已经获取了独占锁(X)的记录相同的共享锁(S)。</li><li id="8400" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务必须等待第一个事务完成执行并释放排他锁，因为不能在已经有排他锁的记录上获取共享锁。</li><li id="dfb1" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">当第一个事务完成时，第二个事务继续执行并从表中读取一个非脏值。</li></ul><h2 id="8955" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">不可重复读取问题</h2><p id="8e67" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在提交读隔离级别(以及未提交读隔离级别)，可能会出现不可重复的读问题。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4377" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两个事务都使用读提交隔离级别。尽管第一个事务中的两个选择查询是相同的，但它们将检索不同的或不可重复的值。</p><p id="fca1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在读提交事务中，共享锁是在执行选择查询之前获得的，这与读未提交事务相反。</p><p id="4f6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在read committed事务中，不可重复的读取仍然是可能的，因为一旦SELECT查询执行完成，就会释放<strong class="ki iu">共享锁。在提交读隔离级别中，直到事务结束，共享锁才会被持有。</strong></p><ul class=""><li id="99b3" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">第一个事务在运行第一个SELECT查询之前获取表行的共享锁，并在读取数据后释放锁。</li><li id="935a" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务获得一个排它锁(X ),并更新表中的该行。第二个事务可以这样做，因为第一个事务已经释放了共享锁。</li><li id="c82c" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务结束并释放独占锁。</li><li id="cb21" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第一个事务再次获取共享锁以执行第二个SELECT查询，并从表中读取新值。</li></ul><h2 id="b494" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">更新丢失问题</h2><p id="2124" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在提交读取(和未提交读取)事务隔离级别中可能发生的另一个问题是更新丢失。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a7d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，第一个事务会自动覆盖第二个事务的结果。如果执行任何交易之前的初始价格是500，那么在两个交易都执行之后，价格应该是3500。但是，最终价格是1500。第二次交易的价值2000丢失。</p><p id="e624" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更新丢失问题的根本原因与不可重复读取的原因相同:一旦SELECT查询完成，共享锁就会被释放。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="21d4" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">可重复读</h1><p id="4d21" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">可重复读取级别隔离可防止脏读取、不可重复读取和更新丢失问题。唯一可能出现的问题是幻像读取。</p><h2 id="db97" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">可重复读取如何解决不可重复读取的问题？</h2><p id="e2d9" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">为事务设置可重复读取隔离级别可确保该事务中所有相同的查询返回相同的数据。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2c83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不可重复读取问题不会发生在可重复读取隔离级别，因为事务持有共享锁，直到事务结束。</p><p id="8f2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">整个过程看起来是这样的:</p><ul class=""><li id="6729" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">第一个事务开始，在执行第一个SELECT查询之前获取一个共享锁，并从表中检索值。</li><li id="6959" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务开始并试图获取该行上的独占锁，但必须等到第一个事务释放共享锁。</li><li id="20d2" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第一个事务执行第二个SELECT查询并获得与第一次相同的值，因为第二个事务不能更新它。</li><li id="eb80" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第一个事务结束并释放共享锁。</li><li id="e49d" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务可以获取排他锁并更新该行。</li></ul><h2 id="6eef" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">可重复读取如何解决更新丢失的问题？</h2><p id="3c86" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当事务隔离级别设置为可重复读取时，丢失更新的问题不再出现:</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a07c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">丢失更新的问题将不再出现，但会出现死锁问题，因为共享锁会一直保持到事务结束。</p><p id="63b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在的情况是这样的:</p><ul class=""><li id="4db6" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">第一个事务开始并获取该行的共享锁。</li><li id="1f89" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务开始并获取同一行的共享锁。</li><li id="f748" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务试图在更新行之前获取一个独占锁，但会等到第一个事务释放共享锁。</li><li id="346d" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第一个事务试图在更新行之前获取一个独占锁，但会等到第二个事务释放共享锁。</li><li id="12cd" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">MS SQL server终止了其中一个事务，并显示以下错误:<em class="nx">事务被另一个进程死锁在锁资源上，并已被选为死锁牺牲品。重新运行交易。</em></li><li id="4d12" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">获胜的交易成功并更新表中的值。</li></ul><p id="dd2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">死锁不可能100%避免。<strong class="ki iu">对于因死锁而中止的事务，后端逻辑必须有重试机制</strong>。一旦再次执行失败的事务，表中的最终值将是3500，这是预料中的。</p><h2 id="5ba2" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">幻像读取问题</h2><p id="8e28" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">幻像读取意味着在同一事务中执行的几个相同的SELECT查询返回不同数量的行。</p><p id="ad03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幻像读取问题类似于不可重复读取问题。但是，幻像读取意味着在表中插入或删除行，不可重复读取意味着更新表中的值而不改变行数。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a158" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是示例中发生的情况:</p><ul class=""><li id="10ed" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">第一个事务启动，获取与谓词匹配的行键上的共享锁(2行)，并读取这些行。</li><li id="6321" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务获取新行键的排他锁，并将该行插入到表中。</li><li id="f661" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第一个事务使用与第一次相同的谓词再次读取数据，并在结果中获得一个额外的行。</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="647c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">可序列化</h1><p id="4675" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这是最高的隔离级别，可以防止SQL Server中所有可能的并发现象，但另一方面，可序列化级别会降低性能并增加死锁的可能性。</p><h2 id="4333" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">Serializable如何解决幻影问题？</h2><p id="3a22" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">可序列化隔离级别强制带有范围谓词的查询获取范围锁，以避免幻像读取。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="da45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们分析一下当事务的隔离级别是可序列化时会发生什么:</p><ul class=""><li id="951c" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">在运行第一个SELECT查询之前，第一个事务启动并获取一个共享范围锁(RangeS-S)。共享范围锁不仅锁定现有记录，还锁定可能落入WHERE子句中指定的谓词范围内的记录(Id ≥2的所有记录)。</li><li id="29f1" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务试图为它将要插入的行键获取一个排他锁，但是它必须等到第一个事务释放共享范围锁，因为新的行ID (4)属于谓词范围(Id ≥2)。</li><li id="140f" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第一个事务第二次读取相同数量的行，并在事务结束时释放共享范围锁。</li><li id="28c7" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">第二个事务向表中插入一个新行并完成。</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="ba66" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><ul class=""><li id="73ac" class="mo mp it ki b kj mj kn mk kr ob kv oc kz od ld mt mu mv mw bi translated">事务的隔离级别越高，对并发问题的保护越好，但是性能越低。</li><li id="9739" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">Serializable是最高的隔离级别，它保护事务免受所有类型的并发现象的影响。</li><li id="df9b" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">可重复读取隔离级别不能保护事务免受幻像读取问题的影响。</li><li id="07e2" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">读提交事务隔离级别不能保护事务免受幻像读取、不可重复读取和更新丢失问题的影响。</li><li id="8dbd" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">未提交读取不能保护事务免受幻像读取、不可重复读取、更新丢失和脏读取问题的影响。</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="f135" class="nc lm it bd ln nd ne dn lr nf ng dp lv kr nh ni lz kv nj nk md kz nl nm mh nn bi translated">我的其他文章</h2><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">5种免费提高C#代码性能的方法</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">慢速代码是可选的。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov jz oh"/></div></div></a></div><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-mock-datetime-now-for-unit-testing-in-c-bf0438eab032"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">模仿日期时间的5种方法。现在用C#进行单元测试</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">各有利弊。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov jz oh"/></div></div></a></div><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/top-best-practices-for-writing-brilliant-unit-tests-3af3e9ddce79"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">编写优秀单元测试的最佳实践</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">这可以最大化你的单元测试套件的好处。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov jz oh"/></div></div></a></div></div></div>    
</body>
</html>