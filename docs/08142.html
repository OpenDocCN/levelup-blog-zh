<html>
<head>
<title>How To Build a Basic Blockchain in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中构建一个基础的区块链</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-basic-blockchain-in-go-c5745ea06456?source=collection_archive---------3-----------------------#2021-04-05">https://levelup.gitconnected.com/how-to-build-a-basic-blockchain-in-go-c5745ea06456?source=collection_archive---------3-----------------------#2021-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="262d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你会惊讶它是多么容易。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4ce9c163ed66e97c19bcaed41cacbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IBgcMf1YV2q9ozeO"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="https://images.unsplash.com/photo-1545987796-200677ee1011?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=2700&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="f3ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> B </span>锁链技术被一些人认为是自互联网以来最有影响力的发明。虽然公众将区块链解释为投机性加密货币的同义词，但区块链实际上在现代世界有着极其广泛的应用。事实上，<strong class="lb iu">加密货币只是区块链世界的一个小方面，</strong>许多生产中的解决方案都是由私人组织领导的——对于一项意味着去中心化的技术来说，这已经足够讽刺了。</p><p id="6cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<a class="ae ky" href="https://www.computerworld.com/article/3454336/walmart-launches-world-s-largest-blockchain-based-freight-and-payment-network.html" rel="noopener ugc nofollow" target="_blank">沃尔玛已经在使用区块链解决供应链管理问题</a>。将区块链与物联网(IoT)技术(如实时温度传感器)相结合，沃尔玛可以为自动开票、发货细节等创建智能合同。如果运输过程中出现错误，或者在任何时间点发现食品污染，<strong class="lb iu">可以通过自动区块链即时追溯事件。</strong></p><blockquote class="me mf mg"><p id="de9d" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated"><em class="it">整合了</em> <strong class="lb iu"> <em class="it">区块链</em> </strong> <em class="it">和</em> <strong class="lb iu"> <em class="it">物联网</em> </strong> <em class="it">解决方案，将沃尔玛的发票解决时间从七天大幅缩短至闪电般的</em> <strong class="lb iu"> <em class="it"> 2.2秒。</em> </strong></p></blockquote><p id="eef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着区块链技术的快速发展，我相信技术领域的专业人士越来越有必要至少了解区块链的基本知识及其技术影响——你永远不知道未来的机会会在哪里出现！</p><p id="1a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，实现自己的区块链实际上并不像听起来那么复杂。在本教程中，我们将使用2021年最流行的编程语言之一——GoLang来实现一个基本的区块链。</p><p id="6d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来建吧！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="a605" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">了解区块链</h1><p id="d226" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">区块链是少数几项名副其实的技术之一。我们可以把区块链想象成通过<em class="mh">散列</em>相互连接的信息块——一种从输入数据生成的加密固定输出。由于每个块都通过散列相互引用，所以不可能在不彻底改变链的其余部分的情况下改变链的任何部分。这给了区块链安全和透明的好处(如果你公开你的区块链)。</p><p id="6fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续说，<strong class="lb iu">区块链中的每个块可以包含几乎任何内容的数据。</strong>基本框架将包括每个区块过去交易的所有记录。比特币以类似的方式工作，这就是为什么你可以一直跟踪比特币交易，直到Satoshi的第一次加密货币交易。</p><p id="448a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万一事情还是模糊不清，<strong class="lb iu">我们来看一张图。</strong>下面我们用三个块来创建一个区块链。第一块是创世块。由于前面没有任何内容，因此前面的哈希字段为空。我们仍然使用时间戳属性和初始事务作为哈希算法的输入。这个算法会吐出一大串数字和字母，代表<strong class="lb iu"> genesis块的哈希值。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/88ec0dd198f5641898326776d8521534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diCl__CeOodnDXxCSlnVAQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用LucidChart做的</figcaption></figure><p id="f2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到数据块2，我们使用原始数据块的哈希作为数据块2之前哈希的值。<strong class="lb iu">该操作将genesis块与block 2链接起来！</strong>接下来，我们将时间戳、交易列表和之前的哈希值作为哈希算法的输入。该算法将给我们一个新的散列值来表示块2。</p><p id="2871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们继续重复这个过程<strong class="lb iu">直到我们想要的次数</strong>，除了块的有效性和存储区块链的能力(比特币的区块链约为330 GB)之外，没有任何限制。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5ecb" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">在Go中创建一个简单的区块链</h1><p id="6ea0" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">创建区块链的第一步是<strong class="lb iu">定义什么是块。</strong> Go让我们的生活变得容易创建自定义类型，我们可以用下面的代码定义<code class="fe nq nr ns nt b">Block</code>类型。这里的<code class="fe nq nr ns nt b">Block</code>结构有四个字段来匹配上面的图表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建Go版本的构造函数来<strong class="lb iu">创建新块。</strong>该函数的输入将采用一个字符串数组来表示事务，并采用一个字节数组来表示先前生成的块各自的先前哈希值。下一个要深入研究的是我们接下来要实现的<code class="fe nq nr ns nt b">NewHash()</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="44bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns nt b">NewHash()</code>函数将时间、事务列表和以前的散列作为输入参数，同时将一个字节数组返回给<strong class="lb iu">来表示新生成的散列值。</strong>在这个函数中，我们基本上只是将所有的输入混合到一个名为<code class="fe nq nr ns nt b">input</code>的单字节数组中。我们使用<code class="fe nq nr ns nt b">append()</code>函数通过将<code class="fe nq nr ns nt b">time</code>转换为以<code class="fe nq nr ns nt b">...</code>为后缀的<code class="fe nq nr ns nt b">string</code>来将<code class="fe nq nr ns nt b">time</code>参数附加到<code class="fe nq nr ns nt b">prevHash</code>，以便将<code class="fe nq nr ns nt b">time</code>切片附加到<code class="fe nq nr ns nt b">prevHash</code>切片。</p><p id="5d09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们循环遍历<code class="fe nq nr ns nt b">transactions</code>并将每个单独的<code class="fe nq nr ns nt b">transaction</code>添加到<code class="fe nq nr ns nt b">input</code>数据块中。有趣的语法<code class="fe nq nr ns nt b">string(rune(transaction))...</code>只是Go中把<code class="fe nq nr ns nt b">transactions</code>的每个元素转换成可以附加到<code class="fe nq nr ns nt b">input</code>的片段的一种方式。这是在输入垃圾，所以如果你真的想的话，就开始吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="473e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们使用Go中的<code class="fe nq nr ns nt b">crypto</code>包调用<code class="fe nq nr ns nt b">sha256.Sum256()</code>，并将<code class="fe nq nr ns nt b">input</code>作为其参数。这将为我们所有的数据输入提供一个新的散列表示。我们返回<code class="fe nq nr ns nt b">hash[:]</code>,返回时使用<code class="fe nq nr ns nt b">[:]</code>语法将<code class="fe nq nr ns nt b">hash</code>分割成适当的长度。很抱歉掩盖了细节，但我们在这里是为了建立一个区块链，而不是理解围棋的打字和切片方法。</p><p id="6954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们开始连接区块链所需要的一切。当然，我们希望在程序中看到某种输出，以便在打印时可以使用一些辅助方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了。现在剩下的就是创建新的事务、块和散列。我们可以在我们的main方法中这样做。我们定义了一个字符串数组来记录区块链中的事务。还要注意我们如何将一个空字节数组传递给<code class="fe nq nr ns nt b">NewBlock()</code>来生成我们的第一个块<code class="fe nq nr ns nt b">genesisBlock</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e6ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建新的块，我们将前一个块的哈希值连同其相应的事务历史一起传递给<code class="fe nq nr ns nt b">NewBlock()</code>。如果您想在一个地方看到整个程序，这里是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="bd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行这个程序，我们将得到以下输出:</p><pre class="kj kk kl km gt nw nt nx ny aw nz bi"><span id="327e" class="oa mt it nt b gy ob oc l od oe">$ go run example.go <br/>--- First Block ---<br/>        time: 2021-04-05 15:12:18.813294 -0600 MDT m=+0.000074939<br/>        prevHash: <br/>        Hash: 43ec51c50d2b9565f221155a29d8b72307247b08eaf6731cca<br/>        Transactions:<br/>                0: "Izzy sent Will 50 bitcoin"<br/>                1: "Will sent Izzy 30 bitcoin"<br/>--- Second Block ---<br/>        time: 2021-04-05 15:12:18.813477 -0600 MDT m=+0.000257244<br/>        prevHash: 43ec51c50d2b9565f221155a29d8b72307247b08eaf6731cca<br/>        Hash: fcce5323a35cb67b45fe75866582db00fd32baeb92aac448c7<br/>        Transactions:<br/>                0: "John sent Izzy 30 bitcoin"<br/>--- Third Block ---<br/>        time: 2021-04-05 15:12:18.813488 -0600 MDT m=+0.000269168<br/>        prevHash: fcce5323a35cb67b45fe75866582db00fd32baeb92aac448c7<br/>        Hash: fc1d3eee286970d85812b47c3a5bf016ae8c1de4f86b8ace972ffa<br/>        Transactions:<br/>                0: "Will sent Izzy 45 bitcoin"<br/>                1: "Izzy sent Will 10 bitcoin"</span></pre><blockquote class="me mf mg"><p id="8ed9" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">这很粗糙，但是这些是创建你自己的区块链的基础！如果您要更改任何块中的一条信息，那么您将获得结果散列的 <strong class="lb iu"> <em class="it">完全不同的值。</em> </strong> <em class="it">自己试试吧！</em></p></blockquote><p id="d32b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，如果你想要任何真正有用的东西，还有很多额外的工作要做。这个程序的下一步将包括我们的区块链的<strong class="lb iu">验证</strong>以及实际创建和验证事务的<strong class="lb iu">机制。</strong></p><p id="14fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，添加令牌化或加密货币行为比创建一个简单的区块链要困难得多。然而，随着区块链科技继续<strong class="lb iu">在全球范围内寻找新的使用案例，基本原理保持不变。</strong></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="82d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读这篇文章，并能够学到一些新的东西。很明显，这个例子中有太多东西需要补充，但是如果有什么东西引起了你的注意，或者如果你想在以后的文章中更详细地讨论这些主题，我鼓励你在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>