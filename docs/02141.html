<html>
<head>
<title>Why I advocate using JSX and TypeScript in Vue components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我提倡在Vue组件中使用JSX和类型脚本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-i-advocate-using-jsx-and-typescript-in-vue-components-e378bf9ee6e7?source=collection_archive---------0-----------------------#2020-02-21">https://levelup.gitconnected.com/why-i-advocate-using-jsx-and-typescript-in-vue-components-e378bf9ee6e7?source=collection_archive---------0-----------------------#2020-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="acd8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在开发了企业级应用程序之后</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fe5e49125f45c8c0d936e1a40b3a27ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iHPVZ5p4vwWyrAYR"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@beastydesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> beasty拍摄。</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="98af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，Vue包含一个模板语法。与JSX相比，它更接近传统的HTML，感觉更“自然”。但它继承了HTML的一个核心痛点:ab不可预测的API。事实上，没有简单的方法知道每个HTML标签支持什么属性。当然，除非是官方文件，但我们一会儿再谈。另一方面，JSX提供了一种确保严格属性类型的方法。</p><p id="4d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解这一点为什么如此重要，我们应该从“消费者”的角度来看一下可重用组件，消费者是指将使用我们构建的组件的人。</p><p id="3cd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许你正在嵌入一个外部UI库。或者，您即将采用由您组织的另一个团队构建的Vue组件。或者你从事个人兼职项目，几个月前开发了一些Vue组件，但已经忘记了它们是如何工作的。</p><p id="8bd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有情况的共同点是什么？此时，你就是这些组件的<strong class="ky ir">消费者</strong>。也就是说，它们是你的“黑匣子”。他们的逻辑被封装在远离你的地方。你几乎不知道它们是如何工作的。然而，你必须使用它们。你可以和他们交流的唯一方式是使用他们的公共API:提供道具和监听事件。</p><p id="1bad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象你即将开始使用某个组件“v-btn”。你知道这是某种按钮。你大胆地把它放进代码里，运行它，然后…什么也没发生。页面是空的。</p><p id="e64a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件为什么不工作？你该怎么办？您有两个选择来解决它:阅读源代码或阅读文档。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4bdb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">阅读文件</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/91d4f283c657d4b2a7b7c4f5fdc7aa9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rawJgHURQ2JKXqS0BouuQ.png"/></div></div></figure><p id="3bb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先说后者。除非你正在应用一个专业开发的UI库，否则很可能没有任何文档。</p><p id="d952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使文档确实存在，也没有人能保证它是正确的并且与源代码同步。俗话说:“谎言有三种:谎言、肮脏的谎言和代码文档”。不幸的是，源代码文档经常是不完整的或误导的。或者过时了。可悲的是，但大多数时候，文档是不可靠的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fb05" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">阅读源代码</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/1eb6ec3ca600bab6bebc1e5ee75e2e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tuu_oE-rHUxqfKKF"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="510b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多开发人员都认为代码是唯一可靠的事实来源。现在，我们<em class="mt">可以</em>跳到代码中，并弄清楚这一点。但这里有一个问题:阅读这些组件的源代码意味着它们对我们来说不再是<strong class="ky ir"/><strong class="ky ir">的黑匣子</strong>。我们必须投入时间和脑力去理解他们的内在逻辑和行为。但我们不是这些组件的作者。他们<strong class="ky ir">不是我们的责任</strong>。我们不能以任何方式改变他们，所以我们为什么要阅读他们的代码？</p><p id="11cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们是<em class="mt">消费者</em>。必须有一种方法来利用这些元素，而不必深入到它们的实现细节中。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="06bf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">PropTypes？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/9a06740e474eba2f434991f5edfd8c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Nh2LBQQWBZLe26h"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">乔恩·泰森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="dc5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多开发人员使用<strong class="ky ir"> PropTypes </strong>为他们的消费者生产更好的API。但是让我告诉你:propTypes几乎是<strong class="ky ir"/><strong class="ky ir">完全是</strong> <strong class="ky ir">无用的</strong>。他们带来的价值接近0。</p><p id="ae6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了说明这一点，让我们回到v-btn。这次我们将假设v-btn作者已经使用了PropTypes。作为消费者，您对该组件的实现一无所知，却将它添加到了您的模板中。你启动应用程序，打开浏览器，然后又看不到任何东西。这一页还是空白的。</p><p id="6df1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这一次，至少你会在浏览器控制台看到一些错误，礼貌地暗示你忘记提供道具了。这个<em class="mt">是</em>有帮助的。您知道该怎么做:只需向v-btn添加一个必需的属性，就可以了。</p><p id="3226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个<strong class="ky ir">在生产</strong>中是没有用的。最终用户不会让控制台一直开着。他们只会看到一个空页面(或者至少是未呈现的组件)。他们没有办法理解发生了什么。PropTypes不支持您将问题传达给最终用户。技术上来说，没有<strong class="ky ir">退路。</strong></p><p id="3d8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要陷入“默认值”的陷阱。<strong class="ky ir">默认值不是一个回退值</strong>。如果你可以默认一个属性，这意味着消费者的数据对你来说不是那么重要。换句话说，如果一个组件本身可以提供一个值，那么这个属性就不是必需的。</p><p id="f421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">propTypes的第二个问题是它没有减少长的<strong class="ky ir">反馈循环</strong>。当你添加一个组件到你的代码或者改变任何东西的时候，你必须运行整个应用程序，到达组件应该呈现的地方，然后验证它是否工作。这里有一个问题:这个过程可能会非常长。</p><p id="fe8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您处理一个包含成百上千个组件的大型、广泛的应用程序，会怎么样呢？或者，如果到达这个组件的路径是艰难和棘手的:点击五个按钮，然后提交一个表单，然后等待一个非常慢的服务器的响应，然后做这个，然后做那个…</p><p id="6687" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，你不得不浪费生命中的几分钟来运行应用程序，然后到达你的组件应该呈现的点，所有这些只是为了看到一个控制台错误的空白页面？然后在你意识到你只是拼错了专有名称之后，重复这个循环？然后再重复一次，因为道具需要的是字符串，而不是数字？如果你仔细想想，即使没有PropTypes，你也必须做同样的事情。他们没有带来太多的价值。</p><p id="7979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题的核心是<strong class="ky ir"> propTypes传达错误时已经太晚了</strong>——这就像在宇宙飞船已经发射后报告故障的火箭发动机一样。</p><p id="eb40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，有一种方法可以显著减少反馈循环，并确保最终用户永远不会因为消费者忘记提供正确的数据而面临组件故障。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b8a7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">还有另一种方法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/5afadb03761d497f322133fdd34ff443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GV7W8usl50nZXjbj"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@frankvex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗兰克·维西亚</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1b26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，你，作为这个消费者，会立即<strong class="ky ir">知道</strong>丢失的道具<strong class="ky ir"/>？第二，你在你的源代码中写&lt; v-btn / &gt;？如果你拒绝提供必要的数据，你的组件就不会被添加到源代码中？</p><p id="4e6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是黑魔法。这是TypeScript、ESLint和JSX的合作。而且非常简单:作为组件作者，您可以为组件的道具定义一个<strong class="ky ir">接口</strong>。另一方面，如果消费者以错误的方式使用组件，他们将立即收到类型检查错误。他们不必手动单击应用程序的一半，一直到组件。他们甚至不需要运行应用程序:IDE会在你输入组件的第一秒就通知你这个问题。最终用户不会仅仅因为组件不能编译而面对失败的组件。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cff9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">如何设置</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/8924c34909bdc35dbf82e8c68d0d0591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x8YSbM-_IWVXdK1x"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Todd Quackenbush 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bd06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将假设您有一个应用程序设置，其中包含TypeScript + ESLint + Vue。如果没有，vue-create-app是一个极好的起点。</p><p id="68cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们必须教TS尊重JSX语法。要做到这一点，我们必须调整Vue的类型和使用。tsx文件而不是. vue。</p><p id="f168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“vue-create-app”为TSX提供了默认的shim:“shims-tsx . d . ts”。只有一件事对我们来说是错误的:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="bc47" class="nc ma iq my b gy nd ne l nf ng">interface ElementAttributesProperty { $props: {} }</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">教学生正确的类型</figcaption></figure><p id="9efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以通过提供的泛型定义一个调整道具类型的父类。创建一个包含以下内容的文件“vue-ts-component.ts ”:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">应用适当类型超类</figcaption></figure><p id="0761" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们戴上“组件作者”的帽子，定义Vue组件。注意，我使用的是“vue-class-component”库，这是TypeScript Vue环境推荐的方法之一。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">ComponentB是一个简单的家伙:一个道具和渲染工具</figcaption></figure><p id="b138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没什么异常。我只定义了一个具有所需属性“名称”的组件并渲染它。神奇的事情开始了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">VueComponent和IComponentBProps</figcaption></figure><p id="444a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为ComponentB props定义了一个接口。它规定组件必须有一个字符串属性“名称”。我还把ComponentB的父类改为VueComponent而不是Vue。VueComponent是我们之前定义的超类。它应用泛型类型IComponentBProps作为Props的类型。Generic允许我们拥有许多组件，它们都是从Vue派生出来的，但是只有一个属性类型。</p><p id="0b39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！本质上，只有VueComponent <icomponentbprops>将静态类型的组件与常规组件分开。</icomponentbprops></p><p id="33b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们戴上“消费者”的帽子。我们将创建一个新的Vue组件ComponentA，它将ComponentB呈现为一个子组件。换句话说，ComponentA消耗ComponentB:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">盲目使用组件b</figcaption></figure><p id="68e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，您应该有一个类型错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/d38021e9dc058c43fa1b560780b2b098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rroICgPouM8RAimIKAkISQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">TS对我们大喊缺少所需的道具</figcaption></figure><p id="7fad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这完全有道理:我们的代码无法编译，因为ComponentB缺少关键数据。您可以在IDE中看到这个错误。不需要运行代码，打开浏览器，导航到渲染点。反馈循环就像“写代码——看反馈”一样短。</p><p id="44bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TS也为我们提供了帮助，并强调了预期的特性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/83482455fa272756b0b8762cc0ae7340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6qX8bl_D9cqz2mmgd95uw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">TS善意地强调了所需的道具</figcaption></figure><p id="1a5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它不仅检查属性是否存在，还检查类型的正确性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">如果道具的类型不对怎么办？</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/9f889a77461d9f06145f9c5d157a81bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JoVOiXbozIEWp7adN-I4Ew.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">TS冲我们吼:“名字必须是字符串，不能是数字！”</figcaption></figure><p id="91d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我得到一个错误，因为0不是一个字符串。一旦我提供了正确的属性，组件就可以编译了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">组件的正确用法b</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/943db94e48b3ac8beea8309527970d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WO2Zu2p55wofAf27TRIyhA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">TS报告没有问题，因为所有必需的道具都已提供且有效</figcaption></figure><p id="0e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不必检查组件的源代码或文档。它对我来说仍然是一个黑匣子，它应该是。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2c92" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="2515" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">JSX，连同TypeScript和林挺，给了开发人员一种不可思议的力量来更快更容易地交付更好的软件。反馈循环变得非常短，组件可以为它们的消费者提供更干净的API。</p><p id="9421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在寻找一个工作的例子，请随意检查这个项目。</p></div></div>    
</body>
</html>