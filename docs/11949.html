<html>
<head>
<title>Typescript Typeguards Are Weird</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿打字警卫很奇怪</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-typeguards-are-weird-723104df508d?source=collection_archive---------7-----------------------#2022-05-02">https://levelup.gitconnected.com/typescript-typeguards-are-weird-723104df508d?source=collection_archive---------7-----------------------#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b81075f0ea799476497dfe983bce31a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*SaaH4c1OHwfLlF9rtcxkNA.png"/></div></figure><p id="6e2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">引擎盖下的Typescript是Javascript，Javascript很诡异</strong>。Typescript的前提是通过使用在编译时而不是运行时捕获类型错误的类型系统，为Javascript带来一些健康。显式地编写类型而不使用类型强制几乎不需要额外的时间，但是给了我们在开发过程中拥有更好的工具的好处，也给了我们交付无bug软件的更好的确定性。</p><h1 id="68c7" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">打字稿箱</h1><p id="b05a" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">即使是Javascript的创始人Brendan Eich也后悔仓促进行类型强制，从而使它变得草率。如果您不熟悉术语“类型强制”,我想快速向您解释一下它的含义:</p><blockquote class="lv lw lx"><p id="f978" class="ju jv ly jw b jx jy jz ka kb kc kd ke lz kg kh ki ma kk kl km mb ko kp kq kr ij bi translated">Javascript中的类型强制允许进行隐式类型转换，这允许对不同类型的变量进行操作。注意，每个Javascript变量都有一个类型，即使它没有被明确指定。</p></blockquote><p id="7422" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于类型强制，类似这样的意外情况实际上会发生:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="70b1" class="ml kt iq mh b gy mm mn l mo mp">const nope = Array(10).join("nope" - 1) + " Batman!";</span><span id="659c" class="ml kt iq mh b gy mq mn l mo mp">console.log(nope); // --&gt; NaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!</span><span id="99db" class="ml kt iq mh b gy mq mn l mo mp">const a = [ 1, 2, 3 ];<br/>const b = [ 1, 2, 3 ];</span><span id="1e2f" class="ml kt iq mh b gy mq mn l mo mp">console.log(a + b); //-&gt; 1,2,31,2,3</span></pre><p id="4340" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这清楚地表明了我的观点，我们确实需要Typescript。老实说，Typescript是Javascript有史以来最好的东西，但是它仍然不能解决Javascript的所有问题，原因很简单:</p><p id="b339" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Typescript<strong class="jw ir">trans files</strong>到Javascript，这意味着Typescript代码永远不会被执行，但总是被转换成Javascript。一方面，这意味着我们在运行时无法访问Typescript类型，但另一方面，它允许轻松地从Javascript迁移到Typescript，因为它可以逐步完成。</p><h1 id="324d" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">类型of</h1><p id="e24f" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在面向对象的编程中，类型保护，如typeof或instanceof，用于确定变量的类型或类。这对于多态性(允许在运行时将具体的子类插入超类定义中)特别有用，可以构建类似工厂模式的东西，根据一些内部逻辑创建某个对象:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7404" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">抓住你了。这是第一次接球。你可能期望x的类型是小的，y的类型是大的，因为这是一种常见的OOP实践。有两件事需要知道:</p><ol class=""><li id="1cfd" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr my mz na nb bi translated">运行时没有Typescript。typeof()在运行时执行，因此无权访问Typescript类型定义。</li></ol><p id="d1ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2.Javascript中的类基本上只是构造函数和具有特定原型的对象的大量语法糖。</p><p id="163b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，如果在接口上使用typeof，输出仍然是“Object ”,因为接口不会转换为javascript中的任何内容。每个有接口类型的变量基本上都是原型对象。</p><h1 id="27a1" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">实例of</h1><p id="63c2" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">另一方面，Instanceof对我们来说确实非常有用，因为它实际上可以通过查看对象原型是否继承了指定对象定义的原型来确定具体的类。</p><p id="4453" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，<code class="fe nc nd ne mh b"><strong class="jw ir">p instanceof Person</strong></code>将查看<code class="fe nc nd ne mh b"><strong class="jw ir">p.prototype</strong></code>是否继承自<code class="fe nc nd ne mh b"><strong class="jw ir">Person.prototype</strong></code>。请注意，我故意使用了inherit这个词，因为一个对象原型与其所有的超/基原型是链接在一起的。</p><p id="bfff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，几乎所有的原型都继承自Object.prototype</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1790" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个例子中，我们可以看到x的原型按照这个顺序链接了小对象、基类和对象。因此，这些类的instanceof返回true，而Big的instanceof返回false。</p><p id="e576" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过一些Javascript魔术，我们可以手动将类Small的原型更改为Big.prototype。这样，使用Small构造函数创建的变量实例现在将成为Small、BaseClass、Object的实例，但也是Big的实例，因为Big和Small现在共享同一个原型。</p><p id="2e10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着只要原型相同，instanceof就会返回true。</p><h1 id="3db3" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">接口</h1><p id="0cc3" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这一小段是为了明确说明接口不能以有意义的方式与typeof或instanceof一起使用，因为当Typescript转换为Javascript时，接口被完全删除，因为它们只包含变量和类型定义。得出接口只存在于Typescript空间中，因此在运行时不存在的结论是没有用的，相反，typeof和instanceof是在运行时执行的。</p><h1 id="8d00" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="bf7f" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">Typescript很棒，但是由于它不存在于运行时中，我们仍然必须记住Javascript函数，即使类型是在Typescript中定义的，typeof和instanceof函数与Typescript没有任何关系。您已经了解到typeof对于检查一个对象是否继承自一个类不是很有用，但是instanceof在这种情况下会有所帮助。接口不应与typeof或instanceof一起使用。</p></div></div>    
</body>
</html>