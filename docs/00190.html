<html>
<head>
<title>Why is Software Development Difficult?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么软件开发很难？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-is-software-development-difficult-81a2a041d35e?source=collection_archive---------0-----------------------#2018-08-12">https://levelup.gitconnected.com/why-is-software-development-difficult-81a2a041d35e?source=collection_archive---------0-----------------------#2018-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fb60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">主要是关于隐含的假设</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ca1aedbdfdab974e6dcaf98be86279f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tvxc40JRyQkhMIeom_fk2w.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">办公室典型的一天</figcaption></figure><p id="b57c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">软件开发很难，原因有很多:</p><ol class=""><li id="0a98" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">硬件技术进步很快，使得越来越复杂的软件变得实用和受欢迎</li><li id="4317" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">新的(和新版本的)语言、库和框架正在快速产生</li><li id="3950" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">编程范例就像喇叭裤和裙摆一样来来去去</li><li id="d590" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">团队成员之间的协调和沟通随着应用程序规模的增加而增加</li><li id="6ec8" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">对功能的请求通常是不明确的</li></ol><p id="d843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没必要继续…这些都是每个开发人员都知道并担心的<em class="kl">明确的</em>问题，但我认为它们并不是故事的一半。最大的问题是任何应用程序中都有<em class="kl">隐含假设</em>。</p><h1 id="c012" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">“哦，我在编码时考虑了所有的可能性”</h1><p id="95ca" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我见过很多精心设计的解决方案，它们试图在所有条件下都保持稳定。但是，对于我们大多数人来说，广泛的类型系统、微调的访问控制、文档(！)，参数检查违背了YAGNI原则:你不会需要它。</p><p id="266e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些时候你会需要它。)，但你现在不需要它了。在竞争激烈的市场中开发新的应用程序时尤其如此。套用<a class="ae mt" href="https://en.wikipedia.org/wiki/Timur" rel="noopener ugc nofollow" target="_blank">坦麦能</a> : <em class="kl">迟到一万次不如准时十次</em>。</p><p id="f3da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是一个系统工程师或者一个流行语言或库的作者，你有一个更大的负担，因为你有更少的假设可以依赖。我们大多数人都没有承担起全部的责任，或者说这个责任被推给了其他人。</p><p id="eab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，如果你正在为一个医疗设备或火箭编写软件，那么即使是中等的故障率也可能是灾难性的，然而它们不可能被完全消除。阿波罗11号月球着陆器是技术成就的巅峰，在下降过程中发出了几个程序警报。</p><p id="ff88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">失败，十之八九，将是由于违反了项目团队所做的假设(或者，只是为了分散责任:营销团队)。然而，对于大多数应用程序来说，预测每一个可能的潜在失败并为其编码会导致过度工程化、错过最后期限和难以修改的代码。成本超过了收益，所以做出了隐含的假设，通常没有经过有意识的思考。</p><h1 id="e466" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">隐含的假设是所有糟糕估计的根源</h1><p id="a863" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">为什么？因为“隐式”意味着这些假设没有用代码行来表达，因此在评估时很容易被忽略。新特性通常会改变假设…有时是直接的，但也可能是你想都没想过要看的代码的副作用。</p><p id="3312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">隐含假设引起的混乱的一个主要例子是应用程序和系统安全性。有一个永无止境的代码安全补丁流假设太多。然而，我们大多数人都依赖他人代表我们进行尽职调查。如果您是NodeJS开发人员，您可能会依赖节点包管理器(npm)来告诉您模块是否通过了审计。审计靠谱吗？可能不完全是这样，但是考虑到依赖链可以有多深，你不可能通过目测代码来亲自担保每一个包。</p><h2 id="a4d1" class="mu lr iq bd ls mv mw dn lw mx my dp ma jy mz na me kc nb nc mi kg nd ne mm nf bi translated">隐含的假设很麻烦，然而…</h2><p id="65d0" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">假设越多，<strong class="jp ir">代码越简单</strong>。用JavaScript编码比用Java编码简单，因为你不必声明每一个被祝福的类型。因此，您希望您的测试足够广泛，能够捕获与数据类型假设和函数中缺少声明相关的错误(linters在这方面也有帮助)。</p><p id="f393" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有代码都应该用Java写吗？不会。如果你真的想要JavaScript中的数据类型，有各种方法可以让<a class="ae mt" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">在</a>上 <a class="ae mt" href="https://reactjs.org/docs/typechecking-with-proptypes.html" rel="noopener ugc nofollow" target="_blank">它们</a> <a class="ae mt" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">。当然，后果是您必须定义它们，从而生成更多的代码。如果开发的快速性是你的主要关注点，那么无论好处如何，一个扩展类型系统的代价可能太大了。</a></p><h1 id="1232" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">那么，有什么意义呢？</h1><p id="b33a" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">人们非常想要功能。他们还希望他们的软件没有错误并且安全，但是在大多数情况下，交付这种软件会非常昂贵和耗时，所以您首先交付特性，并加入各种隐含的假设，然后在这些假设被证明是错误的或发生变化时处理后果。隐含的假设可能会给你带来悲伤，但这通常是必须付出的代价。</p></div></div>    
</body>
</html>