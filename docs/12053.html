<html>
<head>
<title>Path-Based Routing in Render with Kong API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于路径的路由在Kong API网关中的实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/path-based-routing-in-render-with-kong-api-gateway-4ad84f13058f?source=collection_archive---------20-----------------------#2022-05-10">https://levelup.gitconnected.com/path-based-routing-in-render-with-kong-api-gateway-4ad84f13058f?source=collection_archive---------20-----------------------#2022-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0f51fb0036e09f5fbcf69e4fd597f86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuiXl3cI8SGcDLphkvAwDw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@mitchel3uo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米切尔罗</a>在<a class="ae jg" href="https://unsplash.com/s/photos/maze?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h2 id="aac1" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">咖啡店里的编码</h2><div class=""/><div class=""><h2 id="00ae" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">部署微服务进行渲染时，使用基于路径的路由作为利用API网关的解决方案。</h2></div><p id="f533" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您正在构建一个微服务支持的应用程序，一个关键的好处是将您的应用程序的关注点分离到各个微服务上，每个微服务都有自己的能力来扩展和封装不同的功能。前端——表面上是在用户浏览器中运行的单页应用程序——将需要访问组成web应用程序的微服务。每项服务都可以直接进入公共网络，但这增加了安全隐患。</p><p id="b259" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，API网关允许一个集中层来处理认证、流量监控或请求和响应转换等问题。API网关也是利用速率限制和缓存来提高应用程序的弹性和性能的好方法。</p><p id="ac1c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae jg" href="https://render.com/" rel="noopener ugc nofollow" target="_blank"> Render </a>是一个一站式商店，用于直接从现有的GitHub或GitLab repo部署基于微服务的web应用。虽然Render提供了许多资源来支持微服务和数据库，但一个不可配置的元素是API网关——类似于<a class="ae jg" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>或<a class="ae jg" href="https://docs.microsoft.com/en-us/azure/application-gateway/overview" rel="noopener ugc nofollow" target="_blank"> Azure应用网关</a>。尽管对API网关的访问不是一个带有Render的点击式附加组件，但仍然有可能安装并运行一个。</p><p id="5ccc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本帖中，我们将介绍如何为基于路径的路由设置渲染，以便我们可以在微服务前使用<a class="ae jg" href="https://konghq.com/kong/" rel="noopener ugc nofollow" target="_blank"> Kong Gateway </a>。让我们先简要概述一下我们的方法。</p><h1 id="c0d8" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">我们的小型项目概述</h1><p id="5b00" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">我们将使用Render部署两个简单的微服务后端。一个是Python Flask服务，另一个是基于Express构建的Node.js服务。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/f8acb9cf53db21202018eb4bb5c0b0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9N7_d0Msg83atGfY.png"/></div></div></figure><p id="513a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">预期的最终结果如图1所示。我们将部署两个私有服务和一个web服务Kong，它将接受请求并将其路由到这些私有服务。从客户的角度来看，他们似乎是在与单个应用程序进行交互。实际上，他们是在跨微服务生态系统请求资源。</p><h2 id="adc7" class="nf me jj bd mf ng nh dn mj ni nj dp mn lq nk nl mp lu nm nn mr ly no np mt jp bi translated">部署为私有服务的微服务</h2><p id="2155" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Render中主要有两种类型的服务部署:<a class="ae jg" href="https://render.com/docs/web-services" rel="noopener ugc nofollow" target="_blank"> web服务</a>和<a class="ae jg" href="https://render.com/docs/private-services" rel="noopener ugc nofollow" target="_blank">私有服务</a>。公共网络可以直接访问网络服务。另一方面，私有服务只能在渲染账户生态系统内的<em class="nq">私有云中使用。这是一件好事，因为它允许您更好地控制微服务生态系统内的安全性和访问。</em></p><p id="c85c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的两个微服务都将部署为私有服务。</p><h2 id="7ac8" class="nf me jj bd mf ng nh dn mj ni nj dp mn lq nk nl mp lu nm nn mr ly no np mt jp bi translated">部署为web服务的孔网关</h2><p id="6ce0" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Kong是一个高性能、开源的API网关，在当今世界上许多最大的web应用程序中都有使用。虽然API网关有许多选择，但Kong的突出之处在于它与云和应用程序无关，具有高度可配置性，而且最重要的是速度快。</p><p id="b29c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将把Kong Gateway部署为一个web服务，可通过公共web访问。Kong(只有Kong)可以访问我们的两个私有微服务，我们将对其进行配置，以进行适当的请求路由。</p><h1 id="9147" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">使用Render部署微服务</h1><p id="4071" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">让我们从设置和部署我们的两个微服务开始。</p><h2 id="2006" class="nf me jj bd mf ng nh dn mj ni nj dp mn lq nk nl mp lu nm nn mr ly no np mt jp bi translated">使用Python和Flask的“用户”微服务</h2><p id="f366" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Flask是一个低门槛的Python服务框架。我们只需要一个Python文件就可以让一个最小的API在Flask上运行。该服务的代码可从<a class="ae jg" href="https://github.com/alvinslee/render-flask-service" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。下面的代码片段创建了一个带有<code class="fe nr ns nt nu b">/users</code>端点的工作服务，它返回一个简单的JSON响应和状态代码:</p><pre class="nb nc nd ne gt nv nu nw nx aw ny bi"><span id="5d5a" class="nf me jj nu b gy nz oa l ob oc">from flask import Flask, jsonify</span><span id="7312" class="nf me jj nu b gy od oa l ob oc">app = Flask(__name__)</span><span id="9756" class="nf me jj nu b gy od oa l ob oc">@app.route("/users")</span><span id="ded1" class="nf me jj nu b gy od oa l ob oc">def root():<br/>    return jsonify({'userId': 42}), 200</span><span id="7997" class="nf me jj nu b gy od oa l ob oc">if __name__ == "__main__":<br/>    app.run(host='0.0.0.0')</span></pre><p id="80b9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">需要注意的一个重要细节是，为了让Render自动为您的服务公开正确的主机和端口，您必须<strong class="lj jt">确保将您的应用程序绑定到</strong> <code class="fe nr ns nt nu b"><strong class="lj jt">0.0.0.0</strong></code>和<strong class="lj jt">，而不是</strong> <code class="fe nr ns nt nu b">localhost</code>或<code class="fe nr ns nt nu b">127.0.0.1</code>。<code class="fe nr ns nt nu b">0.0.0.0</code>和<code class="fe nr ns nt nu b">127.0.0.1</code>的区别在于接受传入请求的范围。使用传统的回送地址<code class="fe nr ns nt nu b">127.0.0.1</code>，只允许来自同一台机器的请求。<code class="fe nr ns nt nu b">0.0.0.0</code>地址允许来自任何网络接口的请求和我们在这里需要的东西被Render拾取。</p><p id="3152" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要在Render中将它部署为私有服务，首先单击Render dashboard中的<strong class="lj jt"> New </strong>按钮，并使用Flask应用程序选择git repo。设置服务<strong class="lj jt">名称</strong>和<strong class="lj jt">开始</strong>T21命令。所有其他配置选项可以保留默认值。或者，您可以向您的存储库中添加一个<code class="fe nr ns nt nu b">render.yaml</code>文件，配置如何部署这个服务。不过，在我们的演示中，我们将浏览用户界面。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/8a4d46170c2ebb041c09759ef0b588c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IX3mi9KAgXT78UAh.png"/></div></div></figure><p id="c225" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Render提供免费层，一直到企业级托管服务。选择一个符合你需求的。选择您希望部署的分支，并设置构建和启动命令。通常对于Python应用程序，构建应用程序只需要将所有适当的依赖项都准备好。我们可以通过运行<code class="fe nr ns nt nu b">pip install -r requirements.txt</code>来实现。启动我们服务的命令是<code class="fe nr ns nt nu b">python app.py</code>。</p><p id="8445" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦您对您的选择感到满意，点击<strong class="lj jt">创建私人服务</strong>。几分钟后，您的服务将启动并运行！</p><p id="7551" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请注意您私人服务的内部服务地址:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/4c36dbc3a37b024d309c43bef6dac173.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/0*sf7LSVIsazaiGBVg.png"/></div></figure><p id="7919" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本例中，我们的服务地址是<a class="ae jg" href="http://users-service-1w3d:5000/" rel="noopener ugc nofollow" target="_blank">http://users-service-1w3d:5000</a>。请记住，这是一个私人服务，在我们的渲染帐户之外无法访问。</p><h2 id="8f26" class="nf me jj bd mf ng nh dn mj ni nj dp mn lq nk nl mp lu nm nn mr ly no np mt jp bi translated">Node.js和Express的“Widgets”微服务</h2><p id="678c" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">部署Node.js服务与部署Python服务几乎是一样的，尽管建立Node.js项目所需的代码更加复杂。我们构建了一个简单的“小部件服务”，端点在<code class="fe nr ns nt nu b">/widgets</code>。这项服务的代码可以从GitHub 获得。</p><p id="b1e4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将它部署为私有服务几乎与Python Flask服务一样。您将从渲染面板添加一个新的私有服务，并使用UI中的选项。构建和启动命令是需要密切关注的字段，以确保使用来自<code class="fe nr ns nt nu b">package.json</code>文件的正确脚本来正确构建和启动应用程序。对于这个服务，build命令需要安装所有的依赖项，然后构建分发包。这是通过依次使用两个命令来完成的，比如:<code class="fe nr ns nt nu b">npm install &amp;&amp; npm run build</code>。</p><p id="e4c7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">双&amp;符号意味着第一个命令必须在第二个命令开始之前成功完成。这也是如何在渲染表单中链接命令以在一个步骤中实现多个操作的示例。构建阶段完成后，我们可以使用<code class="fe nr ns nt nu b"> npm run start:prd</code>脚本启动服务。同样，记住将你的应用程序绑定到<code class="fe nr ns nt nu b">0.0.0.0</code>，以便Render自动知道如何在内部连接到它。该服务使用的端口和IP在<code class="fe nr ns nt nu b">src/constants.ts</code>文件中定义，当前设置为<code class="fe nr ns nt nu b">0.0.0.0:5001</code>。</p><h2 id="101f" class="nf me jj bd mf ng nh dn mj ni nj dp mn lq nk nl mp lu nm nn mr ly no np mt jp bi translated">设置孔网关</h2><p id="9906" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">我们将把Kong部署为一个web服务，并将其配置为基于请求路径路由到我们的上游私有服务。Kong通常与PostgreSQL之类的数据库一起设置，PostgreSQL保存网关的配置数据。不过，还有一个更简单的设置，Kong称之为“<a class="ae jg" href="https://docs.konghq.com/gateway/2.8.x/reference/db-less-and-declarative-config/" rel="noopener ugc nofollow" target="_blank">无数据库声明式配置</a>”在这种方法中，Kong不需要数据库，配置在服务启动时加载并存储在其内存中。</p><p id="20c4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是一个简单的配置文件(<code class="fe nr ns nt nu b">kong.yaml</code>)，它将Kong配置为路由到我们的私有服务。我们所有与孔有关的文件都可以在GitHub上找到。</p><pre class="nb nc nd ne gt nv nu nw nx aw ny bi"><span id="1d23" class="nf me jj nu b gy nz oa l ob oc">_format_version: "2.1"<br/>_transform: true</span><span id="8e4b" class="nf me jj nu b gy od oa l ob oc">services:<br/>- name: user-service<br/>  url: http://users-service-1w3d:5000<br/>  routes:<br/>  - name: user-routes<br/>    paths:<br/>    - /user-service<br/>- name: widget-service<br/>  url: http://widgets-service:5001<br/>  routes:<br/>  - name: widget-routes<br/>    paths:<br/>    - /widget-service</span></pre><p id="952e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">需要前两行来指导Kong使用正确的版本以及如何使用这个配置。</p><p id="cadf" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nr ns nt nu b">services</code>块详细描述了我们希望Kong将传入流量路由到的所有目的地，该路由基于在<code class="fe nr ns nt nu b">paths</code>块中为每个服务设置的路径。您可以在这里看到服务列表包含了两个部署来呈现的私有服务的URL。例如，我们的web服务(Kong)将监听对<code class="fe nr ns nt nu b">/user-service</code>路径的请求，然后将该请求转发给<code class="fe nr ns nt nu b"><a class="ae jg" href="http://users-service-1w3d:5000." rel="noopener ugc nofollow" target="_blank">http://users-service-1w3d:5000</a></code> <a class="ae jg" href="http://users-service-1w3d:5000." rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="e44c" class="nf me jj bd mf ng nh dn mj ni nj dp mn lq nk nl mp lu nm nn mr ly no np mt jp bi translated">将孔部署在码头集装箱中</h2><p id="09f8" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">用Render来部署Kong会和我们的两个微服务有一点不同。我们需要将其部署为web服务，并在配置过程中使用自定义Docker应用程序选项。</p><p id="77e5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面的Dockerfile文件将提供一个Kong的无DB实例，它将从名为<code class="fe nr ns nt nu b">kong.yaml</code>的文件中读取上面的静态配置。这将端口<code class="fe nr ns nt nu b">8000</code>设置为孔监听传入请求的端口。如果您使用<code class="fe nr ns nt nu b">EXPOSE 8000</code>，Render将自动从Docker映像中选取该端口以用于该服务。</p><pre class="nb nc nd ne gt nv nu nw nx aw ny bi"><span id="d2cc" class="nf me jj nu b gy nz oa l ob oc">FROM kong:2.7.1-alpine</span><span id="5de5" class="nf me jj nu b gy od oa l ob oc">COPY kong.yaml /config/kong.yaml</span><span id="8646" class="nf me jj nu b gy od oa l ob oc">USER root</span><span id="a0fc" class="nf me jj nu b gy od oa l ob oc">ENV KONG_PROXY_LISTEN 0.0.0.0:8000<br/>ENV KONG_DATABASE off<br/>ENV KONG_DECLARATIVE_CONFIG /config/kong.yaml<br/>ENV PORT 8000</span><span id="4726" class="nf me jj nu b gy od oa l ob oc">EXPOSE 8000</span><span id="6c72" class="nf me jj nu b gy od oa l ob oc">RUN kong start</span></pre><p id="2cf3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在将您的存储库与Kong Dockerfile文件和配置文件连接起来之后，请确保您选择了一个至少具有1GB RAM和1个CPU的层。Kong在共享CPU上利用有限的资源执行不稳定的操作。其余的默认配置可以保持不变。</p><p id="cbaa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">部署后，您的渲染仪表板应包含三个服务:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/4c3f3f3c93189635beb3cb64ad61b5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RtdtDnznH2FwrhFh.png"/></div></div></figure><p id="ebb5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦Kong成功部署，您可以使用<code class="fe nr ns nt nu b">curl</code>或<a class="ae jg" href="http://postman.io/" rel="noopener ugc nofollow" target="_blank"> Postman </a>来测试这个设置。发出以下请求，以确保分别正确路由到<strong class="lj jt">用户</strong>和<strong class="lj jt">小部件</strong>服务:</p><pre class="nb nc nd ne gt nv nu nw nx aw ny bi"><span id="7efe" class="nf me jj nu b gy nz oa l ob oc">curl https://kong-gateway-lh8i.onrender.com/widget-service/widgets/10 -i -H "kong-debug: 1"</span></pre><p id="09c0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">附加的<code class="fe nr ns nt nu b">kong-debug</code>头告诉Kong向响应头添加一些调试信息。我们可以使用该信息来验证成功的设置。您应该会在响应中看到如下内容:</p><pre class="nb nc nd ne gt nv nu nw nx aw ny bi"><span id="ecba" class="nf me jj nu b gy nz oa l ob oc">HTTP/2 200<br/>content-type: application/json; charset=utf-8<br/>kong-route-id: 8b2d449d-9589-5362-a2a1-3be5683a8f97<br/>kong-route-name: widget-routes<br/>kong-service-id: 6c8de697-474a-54cf-a59e-4ad086047749<br/>kong-service-name: widget-service<br/>via: kong/2.7.1<br/>x-kong-proxy-latency: 61<br/>x-kong-upstream-latency: 11<br/>x-powered-by: Express</span><span id="47ac" class="nf me jj nu b gy od oa l ob oc">{"widget":"10"}</span></pre><p id="a4e2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请注意以Kong为前缀的标头，这些标头详细描述了用于将请求路由到适当的上游服务的路由和服务。</p><p id="0094" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">类似地，您可以使用以下命令测试<strong class="lj jt">用户</strong>服务路由:</p><pre class="nb nc nd ne gt nv nu nw nx aw ny bi"><span id="9aa0" class="nf me jj nu b gy nz oa l ob oc">curl https://kong-gateway-lh8i.onrender.com/user-service/users -i -H "kong-debug: 1"</span></pre><h1 id="dd45" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">结论</h1><p id="9bdd" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">在本文中，我们探索了Render提供的云托管解决方案。具体来说，我们演示了如何将Kong Gateway部署为一个web服务，该服务处理到微服务的基于路径的路由，这些微服务被部署为私有服务。这种部署模式可以为微服务支持的应用程序的可伸缩和灵活的生产部署做好准备。</p></div></div>    
</body>
</html>