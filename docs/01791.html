<html>
<head>
<title>Advanced Special Characters and RegeEx Methods with JavaScript Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有JavaScript正则表达式的高级特殊字符和RegeEx方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-things-we-can-do-with-javascript-regular-expressions-abe8e34e8757?source=collection_archive---------14-----------------------#2020-01-29">https://levelup.gitconnected.com/more-things-we-can-do-with-javascript-regular-expressions-abe8e34e8757?source=collection_archive---------14-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fb33a5ffbce32e44c950d16d777f09c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6ctRLpJsUeVLxTo1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">帕特里克·布林克斯马在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ecd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正则表达式让我们可以轻松地操作字符串。它们是让我们以我们想象的任何方式匹配文本的模式。没有它，我们将很难搜索具有复杂模式的文本。根据正则表达式检查输入对于表单验证也很有用。在本文中，我们将研究正则表达式和JavaScript正则表达式方法中的高级特殊字符。</p><p id="98a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用如下文字定义JavaScript正则表达式:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="80a9" class="ln lo it lj b gy lp lq l lr ls">const re = /a/</span></pre><p id="4568" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以使用正则表达式构造函数，通过向<code class="fe lt lu lv lj b">RegExp</code>构造函数传递一个字符串来定义正则表达式对象，如下所示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="05a5" class="ln lo it lj b gy lp lq l lr ls">const re = new RegExp('a');</span></pre><h1 id="7a85" class="lw lo it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">更多特殊字符</h1><p id="2a97" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">我们可以使用更多的特殊字符来组成正则表达式:</p><h2 id="0234" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe lt lu lv lj b">[^xyz]</code></h2><p id="be46" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配不在括号中的任何字符，并首先显示。例如，如果我们有字符串<code class="fe lt lu lv lj b">xylophone</code>和模式<code class="fe lt lu lv lj b">[^xyz]</code>，那么它匹配<code class="fe lt lu lv lj b">l</code>，因为它是<code class="fe lt lu lv lj b">xylohphone</code>中第一个不是<code class="fe lt lu lv lj b">x</code>、<code class="fe lt lu lv lj b">y</code>或<code class="fe lt lu lv lj b">x</code>的字符。</p><h2 id="561f" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">[\b]</h2><p id="369a" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">此模式匹配一个退格字符。</p><h2 id="d392" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\b</h2><p id="4560" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">这个模式匹配一个单词边界。单词边界是字符串在单词字符和非单词字符之间的位置。</p><p id="1382" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有模式<code class="fe lt lu lv lj b">\babc</code>和字符串<code class="fe lt lu lv lj b">abc</code>，那么我们得到<code class="fe lt lu lv lj b">abc</code>作为匹配，因为我们在字符串的开头有<code class="fe lt lu lv lj b">\b</code>。</p><p id="f7bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有<code class="fe lt lu lv lj b">abc\b</code>，那么我们得到<code class="fe lt lu lv lj b">abc</code>作为<code class="fe lt lu lv lj b">abc 1</code>的匹配，因为<code class="fe lt lu lv lj b">\b</code>匹配字符串末尾的边界，因为我们在<code class="fe lt lu lv lj b">abc</code>之后有空格。</p><p id="1f4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lt lu lv lj b">abc\babc</code>不会匹配任何内容，因为在<code class="fe lt lu lv lj b">\b</code>之前和之后都有单词字符，所以没有单词边界，</p><h2 id="11d0" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\B</h2><p id="54d0" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配非单词边界。它匹配字符串的第一个字符之前、最后一个字符之后、两个单词字符之间、两个非单词字符之间或一个空字符串。</p><p id="c9f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有模式<code class="fe lt lu lv lj b">ab\B.</code>和字符串<code class="fe lt lu lv lj b">abc 1</code>，那么<code class="fe lt lu lv lj b">abc</code>将是匹配的。</p><h2 id="f8ea" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\cX</h2><p id="ae21" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">这个模式匹配一个字符串的控制字符，其中<code class="fe lt lu lv lj b">X</code>是A到z。</p><h2 id="c194" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\d</h2><p id="bad7" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配任何数字。和<code class="fe lt lu lv lj b">[0-9]</code>一样比如<code class="fe lt lu lv lj b">\d</code>匹配123中的1。</p><h2 id="5779" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\D</h2><p id="eafa" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">该模式匹配任何非数字字符。和<code class="fe lt lu lv lj b">[^0-9]</code>一样。例如，<code class="fe lt lu lv lj b">\D</code>匹配字符串<code class="fe lt lu lv lj b">abc123</code>中的<code class="fe lt lu lv lj b">a</code>。</p><h2 id="f4b3" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\f</h2><p id="a8c1" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配换页符。</p><h2 id="4214" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe lt lu lv lj b">\n</code></h2><p id="c0f8" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配换行符。</p><h2 id="c2bb" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\r</h2><p id="ba0b" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配回车符。</p><h2 id="c501" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\s</h2><p id="2527" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配一个空白字符。</p><h2 id="34bb" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\S</h2><p id="c82f" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配任何非空白字符。</p><h2 id="e7ce" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\t</h2><p id="ff72" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配制表符。</p><h2 id="07d9" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\v</h2><p id="c7f3" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配垂直制表符。</p><h2 id="2a6a" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\W</h2><p id="849a" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配任何非单词字符。和<code class="fe lt lu lv lj b">[^A-Za-z0-9_]</code>一样。例如，如果我们有一个字符串<code class="fe lt lu lv lj b">/.</code>，那么我们得到<code class="fe lt lu lv lj b">/</code>作为匹配。</p><h2 id="1cc8" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\n</h2><p id="27e7" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">如果<code class="fe lt lu lv lj b">n</code>是一个正整数，那么它是与<code class="fe lt lu lv lj b">n</code>捕获组匹配的最后一个子串的反向引用。</p><p id="c795" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个正则表达式<code class="fe lt lu lv lj b">a(_)b\1</code>和字符串<code class="fe lt lu lv lj b">a_b_c</code>，那么我们得到匹配<code class="fe lt lu lv lj b">a_b_</code>和<code class="fe lt lu lv lj b">_</code>，因为我们在两个子字符串中都有<code class="fe lt lu lv lj b">_</code>。</p><h2 id="0e06" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe lt lu lv lj b">\0</code></h2><p id="d12c" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配空字符。</p><h2 id="fd73" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\xhh</h2><p id="bf9d" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配代码为<code class="fe lt lu lv lj b">hh </code>的字符，其中<code class="fe lt lu lv lj b">hh</code>为两位十进制数字。例如，由于<code class="fe lt lu lv lj b">©</code>的十六进制代码是<code class="fe lt lu lv lj b">A9</code>，我们可以将其与模式<code class="fe lt lu lv lj b">\xA9</code>进行匹配。</p><h2 id="e1a1" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">\呃</h2><p id="d5c0" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">用代码<code class="fe lt lu lv lj b">hhhh</code>匹配字符，其中<code class="fe lt lu lv lj b">hhhh</code>是4个十六进制数字。</p><h2 id="2df8" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe lt lu lv lj b">\u{hhhh}</code></h2><p id="bca9" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">用Unicode值<code class="fe lt lu lv lj b">hhhh</code>匹配字符，其中<code class="fe lt lu lv lj b">hhhh</code>是4个十六进制数字。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/c721acf75e6a396fe71d3b704a35c092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vu9_OIZ2yslkS1EP"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@fideletty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Etty Fidele </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="6c5a" class="lw lo it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">正则表达式方法</h1><p id="ce85" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">JavaScript正则表达式对象有几个方法，可以让我们用正则表达式做各种事情，比如搜索字符串、测试字符串是否匹配某个模式、替换字符串等等。</p><p id="775f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法如下。</p><h2 id="87fe" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">高级管理人员</h2><p id="08c3" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated"><code class="fe lt lu lv lj b">exec</code>方法在字符串中搜索正则表达式的匹配项。如果没有匹配，它返回结果数组或<code class="fe lt lu lv lj b">null</code>。</p><p id="1b56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="699c" class="ln lo it lj b gy lp lq l lr ls">/[a-z0-9.]+@[a-z0-9.]+.[a-z]/.exec('<a class="ae kf" href="mailto:abc@abc.com" rel="noopener ugc nofollow" target="_blank">abc@abc.com</a>')</span></pre><p id="260f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3c75" class="ln lo it lj b gy lp lq l lr ls">["<a class="ae kf" href="mailto:abc@abc.com" rel="noopener ugc nofollow" target="_blank">abc@abc.com</a>", index: 0, input: "<a class="ae kf" href="mailto:abc@abc.com" rel="noopener ugc nofollow" target="_blank">abc@abc.com</a>", groups: undefined]</span></pre><p id="aaeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<code class="fe lt lu lv lj b">g</code>标志来搜索匹配的整个字符串。例如，我们可以写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5b27" class="ln lo it lj b gy lp lq l lr ls">/\d+/ig.exec('123')</span></pre><p id="94cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到123作为匹配。</p><h2 id="a836" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">试验</h2><p id="08b2" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated"><code class="fe lt lu lv lj b">test</code>方法搜索正则表达式和指定字符串之间的匹配。如果匹配，它返回<code class="fe lt lu lv lj b">true</code>，否则返回<code class="fe lt lu lv lj b">false</code>。</p><p id="b954" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如<code class="fe lt lu lv lj b"> /foo/.test(‘foo’)</code>返回<code class="fe lt lu lv lj b">true</code>，而<code class="fe lt lu lv lj b">/foo/.test(‘bar’)</code>返回<code class="fe lt lu lv lj b">false</code>。</p><h2 id="32bf" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">比赛</h2><p id="5dc5" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated"><code class="fe lt lu lv lj b">match</code>方法返回一个字符串与一个正则表达式的所有匹配。</p><p id="66c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6fba" class="ln lo it lj b gy lp lq l lr ls">'table tennis'.match(/[abc]/g)</span></pre><p id="9246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="da60" class="ln lo it lj b gy lp lq l lr ls">["a", "b"]</span></pre><p id="a02d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们有了<code class="fe lt lu lv lj b">g</code>标志来搜索整个字符串进行匹配。如果我们移除<code class="fe lt lu lv lj b">g</code>标志，那么我们只得到第一个匹配。例如，如果我们写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7ceb" class="ln lo it lj b gy lp lq l lr ls">'table tennis'.match(/[abc]/)</span></pre><p id="95ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f6e7" class="ln lo it lj b gy lp lq l lr ls">["a", index: 1, input: "table tennis", groups: undefined]</span></pre><h2 id="68bf" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe lt lu lv lj b"><strong class="ak">matchAll</strong></code></h2><p id="5a57" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated"><code class="fe lt lu lv lj b">matchAll</code>方法返回一个字符串与迭代器中正则表达式的所有匹配，这让我们可以用spread操作符或<code class="fe lt lu lv lj b">for...of</code>循环得到结果。</p><p id="0140" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8897" class="ln lo it lj b gy lp lq l lr ls">[...'table tennis'.matchAll(/[abc]/g)]</span></pre><p id="8911" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9a62" class="ln lo it lj b gy lp lq l lr ls">0: ["a", index: 1, input: "table tennis", groups: undefined]<br/>1: ["b", index: 2, input: "table tennis", groups: undefined]</span></pre><p id="0bd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们有了<code class="fe lt lu lv lj b">g</code>标志来搜索整个字符串进行匹配。如果我们移除<code class="fe lt lu lv lj b">g</code>标志，那么我们只得到第一个匹配。例如，如果我们写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7669" class="ln lo it lj b gy lp lq l lr ls">[...'table tennis'.matchAll(/[abc]/)]</span></pre><p id="3d03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7829" class="ln lo it lj b gy lp lq l lr ls">0: ["a", index: 1, input: "table tennis", groups: undefined]</span></pre><h2 id="580c" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">搜索</h2><p id="5570" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated"><code class="fe lt lu lv lj b">search</code>方法获取字符串匹配的索引。如果没有找到匹配，则返回-1。例如，我们可以写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="63da" class="ln lo it lj b gy lp lq l lr ls">'table tennis'.search(/[abc]/)</span></pre><p id="dd09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到1，因为我们有了作为第二个字符的<code class="fe lt lu lv lj b">'table tennis'</code>。</p><p id="0706" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果我们有:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e8f6" class="ln lo it lj b gy lp lq l lr ls">'table tennis'.search(/[xyz]/)</span></pre><p id="2cbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们返回-1，因为所有3个字母在<code class="fe lt lu lv lj b">'table tennis'</code>中都不存在。</p><h2 id="0f35" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">替换</h2><p id="1062" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">方法在一个字符串中寻找匹配，然后用我们指定的字符串替换匹配。</p><p id="8a24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="115a" class="ln lo it lj b gy lp lq l lr ls">'table tennis'.replace(/[abc]/, 'z')</span></pre><p id="1624" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="eeec" class="ln lo it lj b gy lp lq l lr ls">"tzble tennis"</span></pre><h2 id="8f92" class="ln lo it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">使分离</h2><p id="74e2" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">我们可以使用<code class="fe lt lu lv lj b">split</code>方法根据我们作为分隔符输入的模式来分割一个字符串。它返回一个字符串数组，这些字符串是根据正则表达式的匹配项从原始字符串中拆分出来的。</p><p id="8b06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="09ef" class="ln lo it lj b gy lp lq l lr ls">'a 1 b 22 c 3'.split(/\d+/)</span></pre><p id="7998" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8e59" class="ln lo it lj b gy lp lq l lr ls">["a ", " b ", " c ", ""]</span></pre><p id="980a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，有很多字符和它们的组合，我们可以用JavaScript正则表达式来搜索。它让我们非常容易地进行字符串验证和操作，因为我们不必拆分它们并检查它们。我们要做的就是用正则表达式对象来搜索它们。</p><p id="3e5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，通过复杂的模式来拆分和替换字符串也可以通过正则表达式对象以及它们各自的<code class="fe lt lu lv lj b">split</code>和<code class="fe lt lu lv lj b">replace</code>方法来简化。</p></div></div>    
</body>
</html>