<html>
<head>
<title>Testing asynchronous and synchronous React components with Jest and Enzyme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest和Enzyme测试异步和同步反应组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-asynchronous-and-synchronous-react-components-with-jest-and-enzyme-a979ab425aa1?source=collection_archive---------0-----------------------#2017-11-04">https://levelup.gitconnected.com/testing-asynchronous-and-synchronous-react-components-with-jest-and-enzyme-a979ab425aa1?source=collection_archive---------0-----------------------#2017-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/31fa526fe68d9c1abb47516b1c8f7ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXahIcYPQbUyqdOQe69Wgg.jpeg"/></div></div></figure><p id="946e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你构建前端应用程序时，单元测试仍然非常重要，尤其是当它们包含大量模块、组件、API调用等时。如果您计划对应用程序进行一些重构、改进或扩展某些功能，这一点尤其重要。如果我们有合适的单元测试，我们有很多优势，比如:</p><ul class=""><li id="1e49" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在开发阶段发现问题</li><li id="31d3" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">防止重构后的错误或负面影响</li><li id="59a4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">使调试更容易</li><li id="1332" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">自动化一些测试场景</li></ul><p id="9942" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，在使用<a class="ae lk" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a> JS的情况下，我们可以单独测试每个组件‘作为一个单元’脸书推出了一款非常强大的工具，用于测试React JS和普通Javascript应用，名为<a class="ae lk" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>。那么我们为什么要选择Jest，是什么让它如此强大呢？这是一个全功能的javascript测试解决方案，它:</p><ul class=""><li id="328b" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">与React JS组件配合良好</li><li id="1ea6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">是基于Jasmine的，所以你可以使用Jasmine断言</li><li id="aae4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">提供模拟和间谍的完整工具包</li><li id="ad22" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">使用计时器和异步代码</li><li id="1d1b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">作为npm命令行工具使用</li><li id="cbcc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">提供覆盖率指标</li></ul><p id="f0b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们将使用<a class="ae lk" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank">酶</a>。这是Airbnb为React JS创建的一个强大的测试工具，它提供了不同的方法来渲染React JS组件。为了更好地连接Jest和酶，我们可以使用<a class="ae lk" href="https://github.com/blainekasten/enzyme-matchers" rel="noopener ugc nofollow" target="_blank">酶匹配器</a>库，它为酶渲染组件提供类似Jasmine的断言。</p><p id="cf37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个故事中，我们考虑以下React组件的有用测试用例:</p><ul class=""><li id="af7c" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">无状态组件，接受属性并呈现HTML</li><li id="2a47" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">用AJAX调用呈现的异步有状态组件</li><li id="50fd" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">通过WebSockets实时更新其状态的组件</li></ul><p id="2f5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为代码基础，我们将从<a class="ae lk" href="https://medium.com/front-end-hacking/react-and-reflux-usage-in-real-time-applications-based-on-websockets-part-1-introduction-12fcc7cc3590" rel="noopener">之前的故事</a>中的代码开始，它使用React JS和Reflux来构建一个实时应用程序。</p><p id="9bf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们对代码进行以下更改，以创建我们所有的测试用例。您可以在同一个存储库中的<a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/tree/unit_tests" rel="noopener ugc nofollow" target="_blank">单元测试</a>分支中找到修改后的代码。</p><p id="7140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将更改服务器代码来处理http ajax请求。</p><p id="1ab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不仅仅是插座服务:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="fc7e" class="lu lv iq lq b gy lw lx l ly lz">socketServer.listen(3001, () =&gt; {<br/>    console.log('websocket server listening on *:3001');<br/>});</span></pre><p id="4419" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建一个http服务器，它也可以处理WebSockets。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="e89c" class="lu lv iq lq b gy lw lx l ly lz">//code for http server to listen for http request</span><span id="a860" class="lu lv iq lq b gy ma lx l ly lz">let app = http.createServer((request, response) =&gt; {<br/>    const uri = url.parse(request.url).pathname;<br/>    let data = {};<br/>   //header to allow CORS request</span><span id="2484" class="lu lv iq lq b gy ma lx l ly lz">    response.setHeader('Access-Control-Allow-Origin', '*');<br/>    response.setHeader('Access-Control-Request-Method', '*');<br/>    response.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');<br/>    response.setHeader('Access-Control-Allow-Headers', '*');<br/>    if (uri === '/info') {<br/>        response.writeHead(200, { "Content-Type" : "application/json" });<br/>        data = {message: 'This is ajax response'};<br/>    } else {<br/>        response.writeHead(401, { "Content-Type" : "application/json" });<br/>        data = {error: 'ACTION_NOT_SUPPORTED'};<br/>    }<br/>    response.end(JSON.stringify(data));<br/>}).listen(3001, () =&gt; {<br/>    console.log('Http server running at *:3001');<br/>});</span><span id="14aa" class="lu lv iq lq b gy ma lx l ly lz">let socketServer = io(app); //socket server</span><span id="6ce5" class="lu lv iq lq b gy ma lx l ly lz">socketServer.on('connection', (socket) =&gt; { //Websocket-related code goes here</span></pre><p id="29ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将创建一个与AJAX相关的异步组件，该组件使用从服务器获取的数据进行呈现(<a class="ae lk" href="http://localhost:3001/info'" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/info '</a>)。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="f0b7" class="lu lv iq lq b gy lw lx l ly lz">import React from 'react';</span><span id="17f6" class="lu lv iq lq b gy ma lx l ly lz">//async component using fetch to be rendered<br/>class Info extends React.Component {<br/>    constructor(props) {<br/>        super(props);<br/>        this.state = {<br/>            message: '',<br/>        }<br/>    }<br/>//async lifecycle method to wait for data</span><span id="3b63" class="lu lv iq lq b gy ma lx l ly lz">async componentDidMount() {<br/>        try {<br/>            const res = await fetch(this.props.infoUrl);<br/>            const data = await res.json();<br/>            this.setState({message: data.message});<br/>        }<br/>        catch(e) {<br/>            console.error('Error occured ' + e);<br/>        }<br/>    }<br/>    <br/>    render() {<br/>        return &lt;div className="list__info"&gt;{this.state.message}&lt;/div&gt;;<br/>    }</span><span id="0905" class="lu lv iq lq b gy ma lx l ly lz">}</span><span id="35b7" class="lu lv iq lq b gy ma lx l ly lz">export default Info;</span></pre><p id="fb2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在main.jsx中，我们将infoUrl作为属性传递:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="00e1" class="lu lv iq lq b gy lw lx l ly lz">const infoUrl = '<a class="ae lk" href="http://localhost:3001/info'" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/info'</a>;<br/>    ReactDOM.render(<br/>        &lt;List items={items} infoUrl={infoUrl} /&gt;,<br/>        document.getElementById('list')<br/>    );</span></pre><p id="d40e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以及列表组件<em class="mb">内渲染Info&lt;Info infoUrl = { this . props . infoUrl }/&gt;T3】</em></p><p id="361f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经准备好进行实际测试了。要轻松使用Jest命令行工具，您可以使用<strong class="ka ir"> npm install -g jest </strong>命令进行全局安装。另外，让我们安装以下主要软件包:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9532" class="lu lv iq lq b gy lw lx l ly lz">npm i --save-dev jest //jest itself<br/>npm i --save-dev enzyme enzyme-adapter-react-15 //enzyme and adapter<br/>npm i --save-dev enzyme-matchers //enzyme-matchers<br/>npm i --save-dev jest-enzyme //jest-enzyme assertions<br/>npm i --save-dev jsdom //jsdom virtual dom object</span><span id="3c89" class="lu lv iq lq b gy ma lx l ly lz">//additional packages to test async and sync react components<br/>npm i --save-dev react-test-renderer<br/>npm i --save-dev babel-preset-env<br/>npm i --save-dev babel-plugin-transform-runtime</span></pre><p id="43e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记将新插件添加到。babelrc文件。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="74b3" class="lu lv iq lq b gy lw lx l ly lz">{<br/>  "presets" : ["es2015", "react", "env"],<br/>  "plugins": [<br/>    ["transform-runtime", {<br/>      "polyfill": false,<br/>      "regenerator": true<br/>    }]<br/>  ]<br/>}</span></pre><p id="b15e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了模拟WebSocket连接，我们将选择github<a class="ae lk" href="https://github.com/thoov/mock-socket/" rel="noopener ugc nofollow" target="_blank">https://github.com/thoov/mock-socket/</a>上的模拟套接字库。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="2d16" class="lu lv iq lq b gy lw lx l ly lz">npm i --save-dev mock-socket</span></pre><p id="bfba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以从资源库的<a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/blob/unit_tests/client/package.json" rel="noopener ugc nofollow" target="_blank"> package.json </a>文件中获得所有依赖项。请注意，文件中添加了“测试”部分。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="4673" class="lu lv iq lq b gy lw lx l ly lz">"scripts": {<br/>    "dev": "webpack -d --watch",<br/>    "build": "webpack -p",<br/>    "test": "jest",<br/>    "start": "webpack-dev-server --open"<br/>  },</span></pre><p id="b2c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在编写单元测试之前，让我们配置测试环境。该配置由两个文件组成:</p><ul class=""><li id="b805" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/blob/unit_tests/client/jest.config.js" rel="noopener ugc nofollow" target="_blank"> jest.config.js </a>配置路径、根目录、设置脚本和其他环境<a class="ae lk" href="https://facebook.github.io/jest/docs/en/configuration.html" rel="noopener ugc nofollow" target="_blank">选项</a></li><li id="bbc5" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/blob/unit_tests/client/jestsetup.js" rel="noopener ugc nofollow" target="_blank"> jestsetup.js </a>定义了一个在测试套件运行之前实现的启动脚本。在我们的例子中，它将全局变量和函数复制到Jest的全局作用域，并将Enzyme配置为使用这个已安装的适配器进行渲染(在本例中是react-15适配器，因为我们使用react v15.6)</li></ul><p id="ce32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们开始实际的测试。第一个规范非常简单，不言自明。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="df07" class="lu lv iq lq b gy lw lx l ly lz">describe ('&lt;Item /&gt; component spec', () =&gt; {<br/>    <br/>    const dummyProps = {<br/>        id: 1, <br/>        name: 'Name',<br/>    }<br/>    const item = shallow(&lt;Item {...dummyProps} /&gt;);<br/>    it('should contain the name label', () =&gt; {<br/>        expect(item.find('.list__name').length).toEqual(1);<br/>    });<br/>    <br/>    it('should containt the &lt;Counter /&gt; child', () =&gt; {<br/>        expect(item.find(Counter).length).toEqual(1);<br/>    });<br/>    <br/>});</span></pre><p id="fb8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用最简单的<a class="ae lk" href="https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md" rel="noopener ugc nofollow" target="_blank">浅层</a>渲染功能。首先，测试呈现Item组件并检查它是否包含特定的选择器('。list _ _ name’)。第二个测试检查该项是否有Counter类型的子组件。</p><p id="5c20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的第一个<a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/blob/unit_tests/client/src/spec/Info_spec.jsx" rel="noopener ugc nofollow" target="_blank">异步规范</a>，我们需要做一些准备来模拟获取逻辑。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="2bc6" class="lu lv iq lq b gy lw lx l ly lz">const url = '/info';<br/>const message = 'message';<br/>const mockResponse = (status, statusText, response) =&gt; {<br/>        return new Response(response, {<br/>            status: status,<br/>            statusText: statusText,<br/>            headers: {<br/>                'Content-type': 'application/json'<br/>            }<br/>        });<br/>    };</span></pre><p id="fb0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MockResponse函数模拟http响应。我们可以用下面两行代码来创建一个完整的获取工作流:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="e09e" class="lu lv iq lq b gy lw lx l ly lz">const fakePromise = Promise.resolve(mockResponse(<br/>    200,<br/>    null,<br/>   JSON.stringify({message: message})<br/>));</span><span id="a006" class="lu lv iq lq b gy ma lx l ly lz">window.fetch = jest.fn().mockImplementationOnce(<br/>    () =&gt; {<br/>        return fakePromise<br/>     });</span></pre><p id="6078" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们将使用两种情况——第一种情况检查是否调用了正确的端点。我们将使用Jest的<a class="ae lk" href="https://facebook.github.io/jest/docs/en/tutorial-async.html" rel="noopener ugc nofollow" target="_blank">异步</a>测试功能。我们还将使用酶<a class="ae lk" href="https://github.com/airbnb/enzyme/blob/master/docs/api/mount.md" rel="noopener ugc nofollow" target="_blank">挂载</a>来调用所有的生命周期方法。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="c2ef" class="lu lv iq lq b gy lw lx l ly lz">it('should call /info endpoint on mount', async () =&gt; {<br/>        const fakePromise = Promise.resolve(mockResponse(<br/>            200,<br/>            null,<br/>            JSON.stringify({message: message})<br/>        ));<br/>        window.fetch = jest.fn().mockImplementationOnce(() =&gt; {<br/>            return fakePromise<br/>        });<br/>        expect.assertions(2);<br/>        const info = mount(&lt;Info infoUrl = {url} /&gt;);<br/>        await Promise.all([fakePromise]);<br/>        expect(window.fetch).toHaveBeenCalled();<br/>        expect(window.fetch.mock.calls[0][0]).toEqual(url);<br/>    });</span></pre><p id="01e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二种情况将测试收到的实际内容。这里，我们使用一个带有done回调的规范，并使用<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate" rel="noopener ugc nofollow" target="_blank"> setImmediate </a>来模拟异步工作流。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9ddc" class="lu lv iq lq b gy lw lx l ly lz">it('should display message retrieved with ajax request', <br/>    async (done) =&gt; {<br/>       const fakePromise = Promise.resolve(mockResponse(<br/>           200,<br/>           null,<br/>           JSON.stringify({message: message})<br/>        ));<br/>        window.fetch = jest.fn().mockImplementationOnce(() =&gt; {<br/>            return fakePromise<br/>        });<br/>        expect.assertions(2); //check if all assertions called<br/>        const info = mount(&lt;Info infoUrl = {url} /&gt;);<br/>        await Promise.all([fakePromise]);<br/>        setImmediate(() =&gt; {<br/>            try {<br/>                expect(info).toHaveState('message', message);<br/>                expect(info).toIncludeText(message);<br/>            } catch (e) {<br/>                done.fail(e);<br/>            }<br/>            done();<br/>        });<br/>    });</span></pre><p id="fb86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三种情况非常有趣——它测试依赖于WebSocket更新的<a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/blob/unit_tests/client/src/spec/Counter_spec.jsx" rel="noopener ugc nofollow" target="_blank">计数器</a>组件。对于这种情况，我们也需要一些准备。首先，我们为套接字消息和服务器逻辑定义模拟数据。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="2aae" class="lu lv iq lq b gy lw lx l ly lz">    const counterId = 1;<br/>    const updateMsg = {id: counterId, number: 10};<br/>    const enableMsg = {id: counterId, status: 'enabled'};<br/>    const disableMsg = {id: counterId, status: 'disabled'};<br/>    const counter = shallow(&lt;Counter id={counterId} /&gt;);<br/>    const mockServer = new mockSocket.Server('ws://localhost:3001');<br/>    mockServer.on('connection', () =&gt; {<br/>        mockServer.emit('connect');<br/>        mockServer.on('subscribe', (data, fn) =&gt; {<br/>            fn();<br/>        });<br/>    });</span></pre><p id="8ea2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，为了做到这一点，您需要从SocketIO对象导入模拟服务器和模拟socket.to-client功能。更多有用信息见<a class="ae lk" href="http://facebook.github.io/jest/docs/en/manual-mocks.html" rel="noopener ugc nofollow" target="_blank"> jest mock </a>文档。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="ec9c" class="lu lv iq lq b gy lw lx l ly lz">import * as mockSocket from 'mock-socket';<br/>jest.mock('socket.io-client', () =&gt; {<br/>    return mockSocket.SocketIO;<br/>});</span></pre><p id="7771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行我们的测试用例之前，我们需要初始化WebSocket连接(<a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/blob/unit_tests/client/src/stores/CounterStore.jsx" rel="noopener ugc nofollow" target="_blank"> Store </a>)并设置Jest使用<a class="ae lk" href="https://facebook.github.io/jest/docs/en/timer-mocks.html" rel="noopener ugc nofollow" target="_blank">假计时器</a>进行异步事件测试。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="36cc" class="lu lv iq lq b gy lw lx l ly lz">beforeEach(() =&gt; {</span><span id="30b8" class="lu lv iq lq b gy ma lx l ly lz">        //in this case Reflux store handles WS connection<br/>        Reflux.initStore(CounterStore);<br/>        CounterActions.init([counterId]);<br/>        jest.useFakeTimers();<br/>    });</span><span id="e59a" class="lu lv iq lq b gy ma lx l ly lz">afterEach(() =&gt; {<br/>        jest.useRealTimers(); //reset timers to real<br/>        jest.clearAllMocks(); //clear mock data<br/>    })</span></pre><p id="5402" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个典型的测试用例将检查我们是否用从WebSocket收到的消息更新了组件的状态。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9f77" class="lu lv iq lq b gy lw lx l ly lz">it('should update number value on websocket message', () =&gt; {<br/>        setTimeout(() =&gt; { //emulate async WS update<br/>            mockServer.emit('update', updateMsg);<br/>            counter.update();<br/>        }, 100);<br/>        jest.runOnlyPendingTimers(); //run timers<br/>        //verify that the state was changed</span><span id="ad12" class="lu lv iq lq b gy ma lx l ly lz">        expect(counter).toHaveState('number', updateMsg.number);<br/>    });</span></pre><p id="ce92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下情况检查组件的状态在状态更改消息后是否已更改:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="04ed" class="lu lv iq lq b gy lw lx l ly lz">it('should go disabled on disabled message', () =&gt; {<br/>        expect(counter).toHaveState('status', enableMsg.status);<br/>        setTimeout(() =&gt; {<br/>            mockServer.emit('status', disableMsg);<br/>            counter.update();<br/>        }, 100);<br/>        jest.runOnlyPendingTimers();<br/>        expect(counter).toHaveState('status', disableMsg.status);<br/>    });</span></pre><p id="8792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些几乎是这个例子的所有测试用例。你可以在我之前关于反应和回流的系列文章中阅读这个应用程序是如何构建的。</p><p id="55d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/" rel="noopener ugc nofollow" target="_blank">https://github.com/KilroggD/Reflux-ws/</a>找到工作代码</p><p id="6f55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae lk" href="https://github.com/KilroggD/Reflux-ws/tree/unit_tests" rel="noopener ugc nofollow" target="_blank">https://github.com/KilroggD/Reflux-ws/tree/unit_tests</a>有一个单元测试分支</p><p id="5a90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要测试它，您可以只拉repo，切换到unit_test分支，并运行npm install。然后转到客户端文件夹，运行<strong class="ka ir"> npm测试</strong>。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/73467dda0b6eb12334c28df38e660715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*twGjQmTHsa_EjO6yi0tv6Q.png"/></div></figure><p id="ebe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！测试愉快！=)</p></div></div>    
</body>
</html>