# 计时计算机登录持续时间

> 原文：<https://levelup.gitconnected.com/timing-computer-logon-durations-b59a45301b8d>

## 我的电脑登录需要多长时间？

![](img/bd5c1509bd314477cb04a1c5cfa643b0.png)

在工作中，我被要求计算电脑登录网络的时间。

我被要求在一天中的 6 个不同时间，在全国每个城市随机测试一台电脑。

幸运的是，我们使用的是 SCCM，所以我能够搜索给定网站的计算机，确保没有人登录，然后远程登录，并记录显示桌面所需的时间。

这显然花了很长时间，因为我必须继续查看计算机列表，直到找到一台没有人登录的计算机。

# 已经发明了轮子

我需要自动完成这项工作，因为我不可能坐在电脑前用秒表记录电脑登录的时间。

谷歌帮不上什么忙，因为大多数搜索结果都与电脑登录了多长时间有关，而不是登录过程花了多长时间。

我意识到这是一件好事，因为它给了我一个从零开始设计解决方案的机会，没有任何帮助，甚至没有重新发明轮子！

# 试图制定一个流程

## 日志文件

在输入用户名/密码后，当您点击“Enter”时，不会生成任何日志文件。这使得一切变得更加困难，因为我希望能够找到日志文件的最后写入时间的差异，该日志文件是在输入用户名/密码后按“Enter”键时生成的，而该文件是在桌面加载后生成的。

我发现了一个名为\ \ computer name \ C $ \ UserName \ Tracing \ Communicator-UCC API-0 . UCC API log 的日志文件，它在 Lync 加载后立即被写入，这大约与桌面完成加载的时间相同。

因此，找出台式机完成加载的时间是很容易的。

## 不得不满足于手动/自动混合工作

不仅在登录过程开始时没有生成日志文件，在 SCCM 也没有办法自动控制远程计算机。

自动控制远程计算机的最接近的方法是从命令行使用 CmRcViewer.exe。

这个命令的好处是，您可以自动弹出一系列计算机列表的远程控制窗口，但之后您必须手动浏览每一个窗口并输入您的凭据才能登录。

一旦输入凭证并按下“Enter”键，就必须使用 *Get-Date* 来记录登录“开始”时间。

我不得不满足于这种手动方式，因为使用 GUI 自动化工具进行自动化太复杂了，不值得付出努力。

## 安全性

我必须考虑的一个重要方面是安全性。最终结果将是一堆远程控制窗口，每一个都是一台离我几千公里远的计算机，任何人都可以登录我的帐户进行访问。

出于这个原因，我不得不知道如何在电脑完成登录后锁定、注销、重启或关闭电脑。唯一可行的选择是锁定计算机，因为我需要在登录过程完成后读取日志文件。

不幸的是，由于网络上的安全实现，我无法使用已经可用的命令。所以我写了一个使用*% windir % \ System32 \ rundll32 . exe user 32 . dll，LockWorkStation* 锁电脑的批处理文件。

该批处理文件将在登录开始前复制到计算机的启动文件夹中，并在登录完成后删除。

## 实际过程

一旦我解决了困难的部分，其他的事情就容易了。以下是我想出的流程:

*   阅读网站列表。
*   对于每个站点，从 Active Directory 获取计算机列表。
*   打乱 Active Directory 中的计算机列表，以便在下一步中，每次运行脚本时我们都可以获得不同的计算机。
*   遍历所有计算机，找到第一台没有人登录的计算机，并将其添加到列表中。
*   对于列表中的每台计算机:
*   复制批处理文件，以确保计算机在桌面加载后立即被锁定。
*   使用 CmRcViewer.exe cmd line 命令打开 SCCM 远程控制会话，并手动登录到计算机。
*   记录输入用户名/密码后按“Enter”键的时间，这是登录开始时间。这是通过在 Powershell ISE 中一启动登录就按回车键来完成的。
*   一旦计算机完成登录，批处理文件将运行以锁定计算机。
*   列表中的所有计算机完成登录后，对于每台计算机:
*   从电脑的启动文件夹中删除批处理文件。
*   获取\ \ computer name \ C $ \ Users \ nameofuserrunningthiscript \ Tracing \ Communicator-UCC API-0 . UCC API log 的上次修改时间。这是 Lync 在加载后立即生成的文件，通常在登录后立即生成。
*   记录登录持续时间，即 uccapilog 文件的最后修改日期与开始登录时注册的时间之间的差值。
*   重新启动计算机以强制注销(因为没有远程命令来注销计算机)。

# 整个代码