<html>
<head>
<title>Comparing Algorithm Performance Using Different Abstract Data Types and Programming Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用不同的抽象数据类型和编程语言比较算法性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/comparing-algorithm-performance-using-different-abstract-data-types-and-programming-languages-f3d2dba790f2?source=collection_archive---------17-----------------------#2020-06-30">https://levelup.gitconnected.com/comparing-algorithm-performance-using-different-abstract-data-types-and-programming-languages-f3d2dba790f2?source=collection_archive---------17-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1791d3099245ee1ba7f8ba80439d0e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhCzRbL3YllYYoZ5s9wb6A.jpeg"/></div></div></figure><p id="7a0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近看到了微软在采访软件开发人员和数据工程师时使用的以下编程练习，我很好奇使用不同的抽象数据类型和编程语言实现这样一个算法会有什么表现:</p><blockquote class="kz la lb"><p id="8f5a" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated">给定一个未排序的整数数组，求最长的连续元素序列的长度。例如，给定[100，4，200，1，3，2]，最长的连续元素序列是[1，2，3，4]。返回其长度:4。你的算法应该以O(n)复杂度运行。</p></blockquote><p id="f51b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">算法的初始实现符合复杂度本身，特别是当只使用六个整数时。我开始好奇，使用不同的编程语言和特定的抽象数据类型，算法的性能特征会如何变化，并且随着数据规模的增大而变化(不仅仅是6个整数元素！).在使用几种语言实现算法后，下面是使用Python 3.8、C++20、GCC v10.0.1、Rust 1.43.1和Java 14对越来越多的整数元素进行的测量…</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lg"><img src="../Images/e568ccf99efa29354830149cc9297896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFeZTMTBJxySxpX314T_kA.png"/></div></div></figure><p id="882f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该表包含在完全相同的主机(运行Ubuntu 20.04的System76 Oryx Pro笔记本电脑)上使用不同的抽象数据类型执行算法的时间(以秒为单位)，这些抽象数据类型包含越来越多的标准整数类型。在出现“<em class="lc"> nan </em>”的某些情况下，没有执行时间分析——在大多数情况下，已经很明显算法的实施是低效的。在其他情况下，由于算法无法在64GB内存的情况下执行，定时分析未能完成。在所有情况下，“<em class="lc"> nan </em>”表示特定实施无法满足规模要求。</p><p id="bb6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面的图片展示了每种编程语言中性能最好的抽象数据类型，最多可达1亿个元素(<em class="lc">注意:Python和Java没有超过这一点</em>)。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/05fe68d9808349ff63759c886161684a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GPjD4I8xBP312PDnEfHXg.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">图2:多种语言的最佳抽象数据类型</figcaption></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><blockquote class="kz la lb"><p id="2105" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">实用算法用例—地理空间和计算机视觉机器学习</strong></p></blockquote><p id="9f41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与此练习相关的一个常见用例是每天处理数十亿行移动位置数据<em class="lc">点</em>，这些点由纬度和经度值组成。识别这些<em class="lc">点的序列</em>并在规模和速度上使用适当的数据结构对于我们的一些分析是至关重要的。GDAL是我们使用的一个通用地理空间库，它绑定了上述语言，允许我们在地理空间分析中有更大的灵活性。</p><p id="e430" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计算机视觉人工智能机器学习(“AI/ML”)，特别是全运动视频(“FMV”)处理和机器学习推理是数据性能至关重要的另一个用例。这对于内存和CPU/GPU资源有限的嵌入式系统尤为重要。</p><blockquote class="kz la lb"><p id="030a" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">节省成本的时间复杂性</strong></p></blockquote><p id="0000" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">速度和效率之所以重要，有几个原因，不仅仅是获取A到B形式的数据或识别特定的模式。许多工作负载在云中运行，并利用分布式处理框架，因此使用大量昂贵的云资源最大限度地提高处理超大型数据集的效率意味着我们可以节省成本，同时仍能实现最佳性能结果。当每天处理数十亿行数据时，这些成本会在数周、数月和数年内显著增加。这意味着购买更少的保留实例(“RI”)，或者使用具有更少内存和CPU的较小实例。这不仅仅是“保持CPU的100%利用率”，因为任何人都可以将CPU与坏代码联系起来，而是更微妙的——这是关于保持CPU以最有效的方式被利用。</p><blockquote class="lx"><p id="1076" class="ly lz it bd ma mb mc md me mf mg ky dk translated">"为处理云中的大型数据集编写糟糕的代码意味着编写昂贵的代码."</p></blockquote><p id="579f" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">我是否提到过，我们将节俭作为公司的核心价值观，并通过为我们代表客户管理的数据湖和算法节省大量成本的方式，将这一价值观传递给我们的客户？</p><blockquote class="kz la lb"><p id="3817" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">基准准备</strong></p></blockquote><p id="ab1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了创建各种大小的数据结构，随机生成的整数被填充到特定于语言的类似数组的数据结构中。这导致了从10，000开始到1，000，000，000个整数值结束的对数增长数据集的创建。随机数生成和初始数据填充<em class="lc">不是</em>计时结果的一部分，因为目的不是测量每种语言的随机数生成实现。使用语言默认的整数表示，对于有选项的语言选择32位表示。</p><p id="b412" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在从类似数组的数据类型转换到另一种抽象类型(通常是散列的<em class="lc">集合</em>)的实验中，计时<em class="lc">被包含在</em>中，因为了解创建新数据类型的任何时间损失是否仍然有利于在一定规模上利用新数据结构的整体性能是很重要的。换句话说，为了随着时间的推移获得更好的性能，一个算法会愿意由于类型转换而招致初始性能损失吗？</p><p id="d32f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑到算法的简单性，我们做了各种可能的尝试来在各种语言之间一致地实现算法<em class="lc">。</em></p><p id="6637" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽可能使用默认编译器优化的<em class="lc">发布</em>与<em class="lc">调试</em>版本。</p><blockquote class="kz la lb"><p id="1ef0" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">详细调查结果</strong></p></blockquote><ul class=""><li id="257f" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">使用散列查找的<em class="lc">集合</em>抽象数据结构对于所有编程语言来说都是理想的。</li><li id="5886" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">Rust和C++20使用特定的<em class="lc">集合</em>抽象数据类型，在任何规模的元素上表现都是最好的。</li><li id="d573" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">该算法最明显、最差的实现是使用Python <em class="lc"> List </em>抽象数据类型。</li><li id="b7d9" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">当使用<em class="lc"> Set </em> up时，Python和Java的表现类似于C++和Rust直到Java和Python的内存和垃圾收集成为问题，导致内存不足(“OOM”)程序崩溃。</li><li id="7b64" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">显式控制内存，特别是使用指针和引用，对于保持内存恒定非常重要，从而允许算法扩展并包含更多数据。特别是对于C++20和Rust，当其他语言的程序崩溃时，内存利用率仍然很低。</li><li id="1964" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">C++20的<em class="lc">无序集</em>优于<em class="lc">有序集</em>容器。</li><li id="819d" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">C++20的全新的<em class="lc"> contains </em>方法没有明显的性能影响，尽管与维护多个迭代器相比，使用<em class="lc"> contains </em>的C++代码的可管理性得到了改善。</li><li id="3160" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">不可配置的原始数据类型内存大小，特别是整数类型，垃圾收集对Python很重要。我很少关注Python中原始数据类型的大小(或者说Python垃圾收集的大小)，但是这些类型和大小导致Python崩溃的程度比其他languages⁴.要小</li><li id="cd45" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">Python的Numpy数组数据结构在这个特定场景中表现不佳。对于特定的用例，Numpy数组是优秀的数据结构，但这不是其中之一。与Python的本地列表structure⁵.相比，Numpy查找特定值的速度至少慢4-5倍</li><li id="5b6d" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">我发现使用Python的原生<em class="lc">集合</em>和<em class="lc">冻结</em>集合抽象数据类型在性能上没有显著差异。</li><li id="d324" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">并不总是清楚关于OpenJDK 14 Java虚拟机发生了什么(“JVM")⁶”作为CPU核心将在算法的Java版本的执行期间的不同时间记录100%的利用率。对于Rust和C++，在程序执行期间，只有一个CPU内核得到了100%的利用。</li><li id="7ca5" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">用于执行Java实现的最大堆大小是52GB (Xmx52g)，在程序执行期间的某个时刻，程序仍然会由于内存不足而崩溃。</li></ul><p id="d8b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae na" href="https://gdal.org/" rel="noopener ugc nofollow" target="_blank">https://gdal.org/</a></p><p id="274a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae na" href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Set _(abstract _ data _ type)</a></p><p id="0fa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae na" href="https://en.cppreference.com/w/cpp/container/set/contains" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/container/set/contains</a></p><p id="2c73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">⁴<a class="ae na" href="https://stackoverflow.com/questions/10365624/sys-getsizeofint-returns-an-unreasonably-large-value" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/10365624/sys-getsizeofint-returns-an-unreasonly-large-value</a></p><p id="198e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">⁵<a class="ae na" href="https://stackoverflow.com/questions/13376970/for-huge-arrays-is-numpy-slower-than-list" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/13376970/</a></p><p id="de75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">https://openjdk.java.net/projects/jdk/14/<a class="ae na" href="https://openjdk.java.net/projects/jdk/14/" rel="noopener ugc nofollow" target="_blank">⁶</a></p></div></div>    
</body>
</html>