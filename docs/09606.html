<html>
<head>
<title>Running FastAPI and celery together in a single command</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在一个命令中同时运行FastAPI和celery</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/running-fastapi-and-celery-together-in-a-single-command-66afd9b15561?source=collection_archive---------0-----------------------#2021-08-26">https://levelup.gitconnected.com/running-fastapi-and-celery-together-in-a-single-command-66afd9b15561?source=collection_archive---------0-----------------------#2021-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/12a9d64a83e098041c4af12e53f8398c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWqs0zjmDXTHoJaKRP6krg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">FastAPI和芹菜</figcaption></figure><h1 id="632c" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">FastAPI和芹菜</h1><p id="4786" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">FastAPI是一个新的非常流行的开发python web APIs的框架。Celery可能是在web应用程序中运行长时间任务最常用的python库。FastAPI和Celery经常一起使用(<a class="ae ly" href="https://fastapi.tiangolo.com/tutorial/background-tasks/#caveat" rel="noopener ugc nofollow" target="_blank"> FastAPI文档</a>甚至推荐这样做),在数据科学和机器学习等领域，需要异步完成长时间运行的CPU任务的应用程序是库组合的理想选择。</p><h1 id="eda9" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">发展中的</h1><p id="a68b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">为了演示一个简单的应用程序，我们将从一个全新的python虚拟环境开始，并安装我们的库(我们假设Redis安装在这里的<em class="lz"> localhost </em>上，并且您已经用python 3.9或类似版本创建了一个虚拟环境):</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="daeb" class="mj kd iq mf b gy mk ml l mm mn">pip install fastapi celery[redis] uvicorn</span></pre><p id="82ac" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">现在让我们创建几个文件。第一个文件(<em class="lz"> tasks.py </em>)定义了我们的芹菜任务，而第二个文件<em class="lz"> main.py </em>定义了一个非常简单的FastAPI应用程序，它使用了我们刚刚创建的芹菜任务。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bbf0" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">开发此类应用程序时，开发人员通常会在不同的终端中启动两个进程:</p><ol class=""><li id="a988" class="mv mw iq lc b ld mo lh mp ll mx lp my lt mz lx na nb nc nd bi translated">API服务器(运行FastAPI应用程序)和</li><li id="e30a" class="mv mw iq lc b ld ne lh nf ll ng lp nh lt ni lx na nb nc nd bi translated">芹菜工人(运行芹菜任务)</li></ol><p id="31e2" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">虽然将这些过程分开在生产中很重要，但是在开发过程中，让这些过程在同一个过程中运行通常不是问题。在同一个过程中运行这两者可以简化开发流程，因为我们只需要一个命令和一个终端就可以开始开发。</p><h1 id="6749" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">解决办法</h1><p id="32e1" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们可以不使用这两个终端和命令，而是使用Celerys测试实用程序在后台线程中启动celery worker(注意，由于python线程的工作方式，CPU绑定的任务将阻塞API服务器，这显然不利于生产部署，但在开发期间应该不是问题，并且仍然比使用Celerys<em class="lz">task _ always _ eager</em>设置更接近“真实”设置)。</p><p id="a425" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">为此，我们将包装web服务器(我们在这里使用的是Uvicorn)命令:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3260" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">这看起来可能很奇怪，因为我们在这里使用了一些代码，但重要的部分是<em class="lz">celery . contrib . testing . worker . start _ worker</em>，它在后台启动celery worker。剩下的代码包装了Uvicorn cli命令，这样我们就可以像使用uvicon一样使用我们的新脚本。<em class="lz"> run.py </em>脚本将接受与<em class="lz">uvicon</em>命令相同的命令:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="983a" class="mj kd iq mf b gy mk ml l mm mn">python run.py --help</span></pre><p id="efc7" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">现在，我们可以像以前一样启动web服务器了:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d295" class="mj kd iq mf b gy mk ml l mm mn">python run.py main:app --reload</span></pre><p id="6d07" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">但是它不只是启动web服务器，还会在后台启动一个芹菜工作器。</p><p id="f496" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">访问<a class="ae ly" href="http://127.0.0.1:8000`" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8000 </a>将显示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="dfe3" class="mj kd iq mf b gy mk ml l mm mn">{"2+2":4}</span></pre><p id="f45f" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">结果在celery worker中计算，该worker运行在同一个进程的一个线程上！</p><h1 id="b686" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="18af" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">虽然完成这项工作以节省终端窗口似乎有些过分，但我确实认为尽可能简化新同事或贡献者的开发设置(尤其是如果他们经验不足的话)会带来巨大的不同。在许多情况下，使用一个命令来运行您的开发环境可能是值得的。</p></div></div>    
</body>
</html>