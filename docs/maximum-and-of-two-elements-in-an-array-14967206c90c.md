# 数组中两个元素的最大和

> 原文：<https://levelup.gitconnected.com/maximum-and-of-two-elements-in-an-array-14967206c90c>

![](img/5a7211954a204966c402ac6ed8a861e0.png)

位操作和按位运算符是编程面试中最难的问题。这篇文章讨论了一个有趣的位操作问题。这个问题是 Salesforce 问的。

# 问题:

给定一个数组，找出数组中任意一对元素生成的最大值和最小值。

示例:

```
Input : arr[] = {4, 8, 12, 16} 
Output : Maximum AND value = 8 Input : arr[] = {4, 8, 16, 2} 
Output : Maximum AND value = 0
```

(回想一下`&`是 C++中的按位 AND 运算符)。

# 解决方案 1:天真的方法

回忆逻辑 AND 运算符的真值表

> 当且仅当两位都是 1 时，两位的 AND 才是 1

整数上的逻辑 AND 运算符(C++中的`&`运算符)按位运算——它对两个数的每一对对应位执行 AND 运算。

让我们来看一个例子。考虑两个 8 位整数:`8 = 00001000`和`12 = 00001100`。两个整数的*最高有效位* *(MSB)* 都是零。因此，两者的和的 MSB 也为零。延伸到其他位，我们得到`8 & 12 = 8`。

计算数组中最大值和的朴素算法很简单——只需迭代数组中的每一对元素，更新运行的最大值和目前找到的值，就可以用不到 10 行 C++代码编写。下面是 naive 算法的实现:简单的双循环使这个算法的复杂度为 O(n)，其中 n 是数组中元素的个数。

您应该能够在几分钟内编写出这个简单的实现。当然，我们可以做得比这好得多，只要有一点点洞察力和一点点操作。

# 解决方案 2:使用 std::list

通过查看从*最高有效位(MSB)* 到*最低有效位(LSB)* 的各个位，您可以更好地了解问题。在任一位为 1 的数字出现在最终解中的机会更大(即作为 AND 运算符的参数)，而具有很多 0 位的数字出现的机会很小。举个例子就能说明这一点。让我们用三个 4 位数的二进制数:

1.  `4 = 0100`
2.  `9 = 1001`
3.  `13 = 1101`

这些数字的*最高有效位*分别是`0`、`1`、`1`。给定这些 msb，*数字 4 有可能出现在最终解中吗？*。原来这三个数中最大的和是`9 & 13 = 9`。试着用 4 作为 AND 的参数，你会得到一个更小的数字！(`4 & 9 = 0`，`4 & 13 = 4`)。请注意，数字 4 在最高有效位有一个零！

我们可以将这一观察总结为两条规则:

1.  如果有两个或两个以上的数字的 MSB 为 1，则该解的 MSB 为 1。我们可以忽略所有 MSB 为零的数字
2.  相反，只要 MSB 为 1 的数字少于两个，则该解的 MSB 为 0。我们必须考虑所有可能的解决方案。

这导致以下更有效的算法:

1.  将所有数字保存在一个`std::list`中
2.  对于每个数字中的每个位置(从 MSB 开始)，以该位置的一位计数该数字。
3.  如果`count`为 2 或更大，则从列表中删除该位置有 0 位的所有数字。
4.  如果`count`小于 2，则保留列表中的所有数字。

返回最终列表中数字的 AND，只要列表有两个元素。

下面是该算法的 C++实现:

该算法对整个数组迭代一次。它还对每个数字中的每个比特位置迭代一次。在每一次迭代中，它都执行恒定量的工作。因此，算法的运行时间是 O(mn)，其中 m 是一个数的位数，n 是数组元素的总数。给定 m << n (in our case, m = 32), the runtime is O(n).

Unfortunately, this algorithm maintains an extra O(n) memory in form of a std::list. It turns out that we can solve this problem with constant space with *位操作！*

# 解决方案 3:使用位操作

为了节省空间，我们仍然迭代从 MSB 到 LSB 的所有数字。然而，很少有额外的观察帮助我们消除列表:

1.  让我们假设我们算出结果的 MSB 是 1(即至少有两个数字的一个位设置在 MSB)。*这一个 MSB 可以存储在一个整数变量中。我们将一个结果的所有位累加到一个整数变量中，并在最后返回这个变量。*
2.  对于下一位，我们检查(a)是否至少有两个数字与 MSB 上的*结果*变量匹配，以及(b)是否有一个数字位于第二个最高有效位。

在这种情况下，我们将第二个最高有效位也设置为 1，以此类推！

使用有效的位操作可以在恒定的空间和时间*中完成上述两种检查:*

*   对于位置 *i，*将结果的第 I 位设置为 1: `pattern = result | (1 << i)`。
*   并将得到的数字与数组中的数字 n 进行比较，并将两个结果进行比较:`(pattern & n) == pattern`。

下面的清单显示了 MaxAnd 的有效实现，使用 O(n)空间和 O(n)时间。实现中还使用了*函数模板*，可以专门用于不同的整数类型，如`int32_t, int64_t`等。

# 测试

让我们使用 GUnit 测试来测试一些常见和不常见的输入数组:

1.  空数组
2.  单元素阵列
3.  任意两个元素的最大和为零的数组
4.  任意两个元素的最大和不为零的数组

*原载于 2021 年 2 月 15 日 https://cppcodingzen.com*[](https://cppcodingzen.com/?p=2859)**。**