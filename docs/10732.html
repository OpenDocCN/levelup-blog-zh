<html>
<head>
<title>Mutex Examples in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的互斥示例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mutex-examples-in-go-ad7c440461a4?source=collection_archive---------1-----------------------#2022-01-06">https://levelup.gitconnected.com/mutex-examples-in-go-ad7c440461a4?source=collection_archive---------1-----------------------#2022-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a6fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用示例更好地理解Go中的互斥体</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/590e815dc7c26565e39b05bf278afe29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2xHN3WRniCzL7BVv"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Muhammad Zaqy Al Fattah 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在围棋中，频道是奇妙的，你可以用它们在围棋程序之间进行交流。然而，为了方便起见，在某些情况下您可能想使用<code class="fe lv lw lx ly b">sync.Mutex</code>。</p><p id="4a60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些情况如下:</p><ul class=""><li id="cc88" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><strong class="lb iu">保护内部状态</strong></li><li id="3b37" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu">缓存问题</strong></li><li id="5ad7" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu">为了获得更好的性能</strong></li></ul><p id="5d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我将列举三个Go互斥的例子，希望它们能让你更好地理解Go互斥的实现。</p><h1 id="eb81" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">简单的柜台</h1><p id="5bbe" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在这个例子中，我们实现了一个可以安全并发使用的<strong class="lb iu">计数器</strong>。具体来说，我们使用五个goroutines将计数器递增100，000次。然后，我们打印最终计数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/56e62ccf8e2f1140e5e54d6cfb785fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*xQCqVN_LV3Zc5gNThDeOlQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Go中的互斥示例(计数器)</figcaption></figure><p id="e000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整的源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终结果应该是</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="d9a6" class="nr mo it ly b gy ns nt l nu nv">500000</span></pre><p id="95cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解释:</p><ul class=""><li id="82af" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Counter</code>是一个包含一个<code class="fe lv lw lx ly b">count</code>变量和一个<code class="fe lv lw lx ly b">Mutex</code> <strong class="lb iu"> <em class="nw"> </em> </strong>字段<strong class="lb iu"> <em class="nw">的结构。</em> </strong>前一个变量存储正在递增的值，后一个变量确保递增正确进行，没有<a class="ae ky" href="https://en.wikipedia.org/wiki/Race_condition#Data_race" rel="noopener ugc nofollow" target="_blank">数据竞争</a>问题。</li><li id="f94f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Inc</code>是一种将计数器加1的方法。在该方法中，<code class="fe lv lw lx ly b">c.count++</code>是<a class="ae ky" href="https://en.wikipedia.org/wiki/Critical_section" rel="noopener ugc nofollow" target="_blank">临界段</a>。mutex中的<code class="fe lv lw lx ly b">Lock</code>和<code class="fe lv lw lx ly b">Unlock</code>方法用于确保一次只有一个goroutine可以执行临界区的代码。</li><li id="f1d5" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">函数<code class="fe lv lw lx ly b">main</code>创建一个新的计数器并启动五个goroutines。goroutines将并发运行，每个将执行100，000次。<code class="fe lv lw lx ly b">waitgroup</code>用于在主函数返回之前等待所有goroutines完成。</li></ul><h1 id="27b6" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">乒乓球游戏</h1><p id="4129" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在这个例子中，程序使用两个goroutines来模拟两个玩家。每个球员击球十次。该程序使用互斥体来确保一次只有一个goroutine可以访问球并打印命中数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c3bafe149ddf67ab285db37c49f3ebcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*UCjttFDaf0q5KPkH4_VUwg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">围棋中的互斥示例(乒乓)</figcaption></figure><p id="6d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整的源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终结果应该是</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="9e4d" class="nr mo it ly b gy ns nt l nu nv">playerB 1<br/>playerA 2<br/>playerB 3<br/>playerA 8<br/>playerA 9   // notice here<br/>...<br/>playerB 18<br/>playerA 19<br/>playerB 20</span></pre><p id="0190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解释:</p><ul class=""><li id="a4ef" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Ball</code>类型是一个具有<code class="fe lv lw lx ly b">hit</code>字段和<code class="fe lv lw lx ly b">mutex</code>字段的结构。前者用于统计球被击中的次数，后者确保一次只有一个goroutine可以访问球。</li><li id="031d" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">b.hit++</code>是临界段。锁定和解锁方法确保只有一个goroutine可以执行临界区。</li><li id="7f4a" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">在main函数中，我们创建了一个球和一个等待组。然后我们创建两个goroutines。他们用球员的名字、球和等待组来调用球员函数。最后，我们为两个goroutines调用等待组的wait方法来完成。</li></ul><p id="97c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两名球员比赛击球。然而，我们不保证球以交替的顺序击中。</p><p id="7137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们可以使用一个通道来协调这两个角色。因为通道最适合下列情况</p><ul class=""><li id="50ba" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><strong class="lb iu">传递数据所有权</strong></li><li id="751c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu">分配工作单元</strong></li><li id="cccd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu">交流异步结果</strong></li></ul><p id="f409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是渠道版本的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="dbf6" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">最简单的缓存</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/9e0d9cf63523118e97f25e981ea68e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*Yd-NeCkXNglvDABd3hYhLQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Go中的互斥示例(简单缓存)</figcaption></figure><p id="15ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此缓存有以下方法；它们都受到互斥体的保护。</p><ul class=""><li id="26f0" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Set</code>:添加或更新缓存中的项目</li><li id="5226" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Get</code>:从缓存中获取一个项目。</li><li id="77b8" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Delete</code>:从缓存中删除一个项目。</li><li id="60cd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Keys</code>:获取缓存中的所有键</li><li id="44bd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Purge</code>:删除缓存中的所有项目</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="eb2b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">摘要</h1><p id="a252" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><strong class="lb iu">互斥</strong>和<strong class="lb iu">通道</strong>是两种不同的解决数据竞争问题的工具。互斥对资源的顺序访问。另一方面，通道是用于协调goroutines之间的计算。</p><p id="4033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用哪个？</p><p id="412b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">用最有表现力最简单的！</strong></p></div></div>    
</body>
</html>