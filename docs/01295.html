<html>
<head>
<title>A guide to `this` in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的“this”指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-this-in-javascript-a735bfb9e6a9?source=collection_archive---------2-----------------------#2019-12-12">https://levelup.gitconnected.com/a-guide-to-this-in-javascript-a735bfb9e6a9?source=collection_archive---------2-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/52bc2b4034952fe921cfd7398b42c0f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EpvOYcABpl0OEW6w"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0755" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键字<code class="fe le lf lg lh b">this</code>无疑是JavaScript中使用最广泛但又被误解的一个方面。我今天会努力改变这种情况。</p><p id="ebae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回到以前学习代词的学生时代。</p><blockquote class="li lj lk"><p id="660b" class="kg kh ll ki b kj kk kl km kn ko kp kq lm ks kt ku ln kw kx ky lo la lb lc ld im bi translated">菲尔普斯游得很快，因为他想赢得比赛。</p></blockquote><p id="2c31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意代词“他”的用法。这里我们不直接称呼菲尔普斯，而是用代词“他”来指代菲尔普斯。类似地，JavaScript使用<code class="fe le lf lg lh b">this</code>关键字来引用上下文<em class="ll">中的对象，即主题</em>。</p><p id="f2e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/b55846671ade2f0f2f05c305c91a7515.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*I8COcaUlgfUt9089fcv7gQ.png"/></div></figure><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="f2fa" class="ly lz it lh b gy ma mb l mc md">var car= {<br/>  make: "Lamborghini",<br/>  model: "Huracán",<br/>  fullName: function () {<br/>    console.log(this.make + " " + this.model);<br/>    console.log(car.make + " " + car.model);<br/>  }<br/>}<br/>car.fullName();</span></pre><p id="38ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个对象<code class="fe le lf lg lh b">car</code>，它有属性<code class="fe le lf lg lh b">make</code>、<code class="fe le lf lg lh b">model</code>和<code class="fe le lf lg lh b">fullName</code>。<code class="fe le lf lg lh b">fullName</code>的值是一个使用两种不同语法打印汽车全名的函数。</p><ul class=""><li id="61dd" class="me mf it ki b kj kk kn ko kr mg kv mh kz mi ld mj mk ml mm bi translated">使用<code class="fe le lf lg lh b">this</code> ( <code class="fe le lf lg lh b">this.make+ ” “ +this.model</code>)时，<code class="fe le lf lg lh b">this</code>指的是上下文中的对象<code class="fe le lf lg lh b">car</code>。因此<code class="fe le lf lg lh b">this.make</code>实际上是<code class="fe le lf lg lh b">car.make</code>，对于<code class="fe le lf lg lh b">this.model</code>也是如此。</li><li id="3271" class="me mf it ki b kj mn kn mo kr mp kv mq kz mr ld mj mk ml mm bi translated">使用点符号，我们可以访问对象的属性，<code class="fe le lf lg lh b">car.make</code>和<code class="fe le lf lg lh b">car.model</code>。</li></ul><h1 id="d7cb" class="ms lz it bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated"><code class="fe le lf lg lh b">`this` </code>是吗！</h1><p id="090b" class="pw-post-body-paragraph kg kh it ki b kj np kl km kn nq kp kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">现在我们已经了解了什么是<code class="fe le lf lg lh b">this</code>及其最基本的用法，让我们来看看一些经验法则，这样我们就能永远记住。</p><h2 id="1064" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated">JS ` <code class="fe le lf lg lh b">this</code>`关键字指的是它所属的对象</h2><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="380a" class="ly lz it lh b gy ma mb l mc md">var car = {<br/>  make: '....'<br/>  func: () =&gt; { console.log(this.make) }<br/>}</span></pre><p id="c33a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面代码片段中的<code class="fe le lf lg lh b">this</code>属于对象汽车。</p><h1 id="1d57" class="ms lz it bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">` this '根据用途取不同的值</h1><ol class=""><li id="f8ab" class="me mf it ki b kj np kn nq kr of kv og kz oh ld oi mk ml mm bi translated">在方法内部</li><li id="d17b" class="me mf it ki b kj mn kn mo kr mp kv mq kz mr ld oi mk ml mm bi translated">在函数内部</li><li id="fba9" class="me mf it ki b kj mn kn mo kr mp kv mq kz mr ld oi mk ml mm bi translated">单独的</li><li id="2361" class="me mf it ki b kj mn kn mo kr mp kv mq kz mr ld oi mk ml mm bi translated">在一次事件中</li><li id="0bbb" class="me mf it ki b kj mn kn mo kr mp kv mq kz mr ld oi mk ml mm bi translated"><code class="fe le lf lg lh b">call()</code>和<code class="fe le lf lg lh b">apply()</code></li></ol><h2 id="3b61" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated"><strong class="ak">在一个方法里面</strong></h2><p id="a2f2" class="pw-post-body-paragraph kg kh it ki b kj np kl km kn nq kp kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">当<code class="fe le lf lg lh b">this</code>在方法内部使用时，它指的是所有者对象。</p><p id="f52e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在对象内部定义的函数称为方法。让我们再次以汽车为例。</p><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="c12a" class="ly lz it lh b gy ma mb l mc md">var car= {<br/>  make: "Lamborghini",<br/>  model: "Huracán",<br/>  fullName: function () {<br/>    console.log(this.make+" " +this.model);<br/>    console.log(car.make+ " " +car.model);<br/>  }<br/>}<br/>car.fullName();</span></pre><p id="072a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fullName()</code>这里有一个方法。方法里面的<code class="fe le lf lg lh b">this</code>属于<code class="fe le lf lg lh b">car</code>。</p><h2 id="f5d4" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated"><strong class="ak">内部一个函数</strong></h2><p id="52bb" class="pw-post-body-paragraph kg kh it ki b kj np kl km kn nq kp kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated"><code class="fe le lf lg lh b">this</code>函数内部有点复杂。首先要理解的是函数也有属性，就像所有的对象都有属性一样。每当该函数被执行时，它就获得<code class="fe le lf lg lh b">this</code>属性，这是一个变量，包含调用它的对象的值。</p><blockquote class="oj"><p id="c6fd" class="ok ol it bd om on oo op oq or os ld dk translated">这实际上只是“先行对象”——调用对象——的快捷方式引用。—javascriptissexy.com</p></blockquote><p id="e1cd" class="pw-post-body-paragraph kg kh it ki b kj ot kl km kn ou kp kq kr ov kt ku kv ow kx ky kz ox lb lc ld im bi translated">如果函数没有被对象调用，那么函数内部的<code class="fe le lf lg lh b">this</code>属于全局对象，称为<code class="fe le lf lg lh b">window</code>。在这种情况下，<code class="fe le lf lg lh b">this</code>将引用全局范围中定义的值。为了更好地理解，让我们看一个例子:</p><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="f8b6" class="ly lz it lh b gy ma mb l mc md">var make= "Mclaren";<br/>var model= "720s"</span><span id="5914" class="ly lz it lh b gy oy mb l mc md">function fullName(){<!-- --> <br/>  console.log(this.make+ " " + this.model);<br/>}</span><span id="d9d8" class="ly lz it lh b gy oy mb l mc md">var car = {<br/>    make:"Lamborghini",<br/>    model:"<!-- -->Huracán<!-- -->",<br/>    fullName:function () {<br/>      console.log (this.make + " " + this.model);<br/>    }<br/>}<br/>    <br/>car.fullName(); // Lmborghini <!-- -->Huracán<br/>window.fullName(); // Mclaren 720S<br/>fullName(); // Mclaren 720S</span></pre><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/9aa9cd0227d87e1cd65d6d09b7d04207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usx0RhH5kSLS9mFtfblOiw.png"/></div></div></figure><p id="0c08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里<code class="fe le lf lg lh b">make</code>、<code class="fe le lf lg lh b">model</code>和<code class="fe le lf lg lh b">fullName</code>是全局定义的，而<code class="fe le lf lg lh b">car</code>对象也有一个<code class="fe le lf lg lh b">fullName</code>的实现。当被<code class="fe le lf lg lh b">car</code>对象调用时<code class="fe le lf lg lh b">this</code>引用了对象内部定义的属性。另一方面，其他两个函数调用是相同的，都返回全局定义的属性。</p><h2 id="4bda" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated"><strong class="ak">独自一人</strong></h2><p id="ae87" class="pw-post-body-paragraph kg kh it ki b kj np kl km kn nq kp kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">当单独使用且不在任何函数或对象中时，<code class="fe le lf lg lh b">this</code>指的是全局对象。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/cf4002b0b37e7f168fc630208d3ac0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*-IeJX_xMJHizD_-vmuE8Hg.png"/></div></figure><p id="0e33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的<code class="fe le lf lg lh b">this</code>是指<code class="fe le lf lg lh b">window</code>中的全局名称属性。</p><h2 id="9764" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated"><strong class="ak">在一个事件中</strong></h2><p id="c1df" class="pw-post-body-paragraph kg kh it ki b kj np kl km kn nq kp kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">事件可以是任何类型，但是为了简单明了，让我们来看一个点击事件。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/6edc57fcdc47ee3640f998f9c82705e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pRAi2m9wRKlZ8khe9zG8QA.jpeg"/></div></figure><p id="4e49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当单击一个按钮并引发一个事件时，它可以调用另一个函数来完成基于单击的特定任务。如果在该函数中使用了<code class="fe le lf lg lh b">this</code>，它将引用引发事件的元素。在DOM中，所有的元素都存储为对象。这就是为什么当一个事件被引发时，它引用那个元素，因为那个<em class="ll">网页元素实际上是DOM </em>中的一个对象。</p><p id="ff64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="0313" class="ly lz it lh b gy ma mb l mc md">&lt;button onclick="this.style.display='none'"&gt;<br/>  Remove Me!<br/>&lt;/button&gt;</span></pre><h2 id="f0cf" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated"><strong class="ak">调用()、应用()和绑定()</strong></h2><ul class=""><li id="fe6d" class="me mf it ki b kj np kn nq kr of kv og kz oh ld mj mk ml mm bi translated"><code class="fe le lf lg lh b">bind</code>:允许我们在方法上设置<code class="fe le lf lg lh b">this</code>值。</li><li id="03a6" class="me mf it ki b kj mn kn mo kr mp kv mq kz mr ld mj mk ml mm bi translated"><code class="fe le lf lg lh b">call</code>和<code class="fe le lf lg lh b">apply</code>:允许我们借用函数，并在函数调用时设置<code class="fe le lf lg lh b">this</code> <em class="ll"> </em>值。</li></ul><p id="c4df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">call</code>、<code class="fe le lf lg lh b">bind</code>和<code class="fe le lf lg lh b">apply</code>本身就是另一篇文章的主题。它们非常重要，在这里解释它们是不可能的，因为我们应该了解所有关于<code class="fe le lf lg lh b">this</code>的知识，才能知道这些功能的用法。</p><h1 id="542a" class="ms lz it bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">最棘手的部分</h1><p id="fd96" class="pw-post-body-paragraph kg kh it ki b kj np kl km kn nq kp kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated"><code class="fe le lf lg lh b">this</code>正确使用会使我们的工作更容易。但也有一些被误解的情况。</p><h2 id="9d35" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated">例1。</h2><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/4a4b15d3f347e2083907610a04c27387.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*ysZnAZ6svQW_NPW3Gc1quw.png"/></div></figure><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="2dcf" class="ly lz it lh b gy ma mb l mc md">var car = {<br/>  make:"Lamborghini",<br/>  model:"Huracán",<br/>  name:null,<br/>  fullName:function () {<br/>    this.name=this.make + " " + this.model;<br/>    console.log (this.name);<br/>  }<br/>}</span><span id="090d" class="ly lz it lh b gy oy mb l mc md">var anotherCar={<br/>  make:"Ferrari",<br/>  model:"Italia",<br/>  name:null<br/>}</span><span id="eb06" class="ly lz it lh b gy oy mb l mc md">anotherCar.name= car.fullName();</span></pre><p id="a7c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了一个意想不到的结果。我们从另一个对象借用了一个使用<code class="fe le lf lg lh b">this</code>的方法，但这里的问题是该方法只被分配给了<code class="fe le lf lg lh b">anotherCar</code>函数，但实际上是在<code class="fe le lf lg lh b">car</code>对象上调用的。这就是为什么我们得到的结果是兰博基尼而不是法拉利。</p><p id="3f6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，我们使用<code class="fe le lf lg lh b">call()</code>方法。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/334a5e60186b44aaa4c3e6e7f214cb45.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*50eb39NpwqSMHqu-sZtVYg.png"/></div></figure><p id="2129" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里<code class="fe le lf lg lh b">call()</code>方法调用了<code class="fe le lf lg lh b">anotherCar</code>对象上的<code class="fe le lf lg lh b">fullName()</code>，该对象原本没有<code class="fe le lf lg lh b">fullName()</code>功能。</p><p id="2854" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以看到，当我们记录<code class="fe le lf lg lh b">car.name</code>和<code class="fe le lf lg lh b">anotherCar.name</code>时，我们得到的是后者的结果，而不是前者，这意味着函数确实是在<code class="fe le lf lg lh b">anotherCar</code>而不是<code class="fe le lf lg lh b">car</code>上被调用的。</p><h2 id="708b" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated">例2。</h2><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/9ce72d6baa136ae1e9292e45d5310f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*uL7099sZfpz4AJbS6YQtdA.png"/></div></figure><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="31fc" class="ly lz it lh b gy ma mb l mc md">var cars=[<br/>{ make: "Mclaren", model: "720s"},{make: "Ferrari",model: "Italia"}<br/>]</span><span id="a686" class="ly lz it lh b gy oy mb l mc md">var car = {cars:[{make:"Lamborghini", model:"Huracán"}],<br/>fullName:function () {<br/>  console.log(this.cars[0].make + " " + this.cars[0].model);}<br/>}<br/>var vehicle=car.fullName;<br/>vehicle()</span></pre><p id="835b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段中，我们有一个名为cars的全局对象，在car对象中有一个同名的对象。然后将<code class="fe le lf lg lh b">fullName()</code>方法分配给随后被调用的车辆变量。该变量属于全局对象，因此<code class="fe le lf lg lh b">this</code>调用全局<code class="fe le lf lg lh b">cars</code>对象，而不是<code class="fe le lf lg lh b">cars</code>对象，因为上下文关系。</p><p id="a89e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，我们使用<code class="fe le lf lg lh b">.bind()</code>函数来解决这个问题。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pf"><img src="../Images/1b5374cfc0797ac63a58bba65f269930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wT4Nb922hM6ou7nMzEcc7A.png"/></div></div></figure><p id="1d4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">绑定帮助我们明确地设置<code class="fe le lf lg lh b">this</code>值，因此车辆变量明确地指向汽车对象而不是全局对象，所以这在<code class="fe le lf lg lh b">car</code>对象的上下文中。</p><h2 id="b1a0" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated">例3。</h2><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/f939a9726add880e2b912d5d5a7435c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*ycISi1MrVyWgKZqrFWtL9Q.png"/></div></figure><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="beaf" class="ly lz it lh b gy ma mb l mc md">var car = {<br/>  cars:[{make:"Lamborghini",model:"Huracán"},<br/>  { make: "Mclaren", model: "720s"},<br/>  {make: "Ferrari",model: "Italia"}],<br/>  fullName:function(){<br/>    this.cars.forEach(()=&gt;{<br/>      console.log (this.make  + " " + this.model);<br/>  })}<br/>}<br/>car.fullName();</span></pre><p id="94ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段中，<code class="fe le lf lg lh b">fullName()</code>方法调用一个函数，该函数使用<code class="fe le lf lg lh b">forEach</code>遍历cars数组。在<code class="fe le lf lg lh b">forEach</code>中有一个匿名函数，它丢失了上下文。JavaScript中函数内部的函数称为<code class="fe le lf lg lh b">closure</code>。<code class="fe le lf lg lh b">Closures</code>在JavaScript中非常重要且广泛使用。</p><p id="af79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里起作用的另一个重要概念是<code class="fe le lf lg lh b">scope</code>。函数内部的变量不能访问其<code class="fe le lf lg lh b">scope</code>外部的变量和属性。匿名函数内部的<code class="fe le lf lg lh b">this</code>无法访问它外部的<code class="fe le lf lg lh b">this</code>。所以<code class="fe le lf lg lh b">this</code>无处可去，只能指向全局对象。一旦这里，没有为<code class="fe le lf lg lh b">this</code>定义要访问的属性，所以<code class="fe le lf lg lh b">undefined</code>被打印。</p><p id="5f2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决上述问题的一个方法是，我们可以在匿名函数外部为<code class="fe le lf lg lh b">this</code>的值分配一个变量，然后在内部使用它。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/39be87f98ecc0a2aca9dc8e0ae846c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*nwjP1vQ6mMUVTY9TjFAChA.png"/></div></figure><p id="e389" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里,<code class="fe le lf lg lh b">self</code>变量包含了<code class="fe le lf lg lh b">this</code>的值，该值与内部函数一起使用，从而给出了输出。</p><h2 id="6770" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated">例4。</h2><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/9383328398b89a5183a514904bcf54b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*p497zO88n-hTzvXcZCh90w.png"/></div></figure><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="a2d1" class="ly lz it lh b gy ma mb l mc md">var car= {<br/>  make: "Lamborghini",<br/>  model: "Huracán",<br/>  fullName: function (cars) {<br/>    cars.forEach(function(vehicle){<br/>    console.log(vehicle +" "+ this.model);<br/>  })}<br/>}<br/>car.fullName(['lambo','ferrari','porsche']);</span></pre><p id="898d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个重新讨论过的例子，其中<code class="fe le lf lg lh b">this</code>是不可访问的，所以我们通过使用一个名为<code class="fe le lf lg lh b">self</code>的变量来保存它的值。</p><p id="7b18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用箭头函数以同样的方式解决这个问题:</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/39309ddadde3d545b35db6a5bfc57925.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*ckLk8nsM_tcH48a7sBgFpA.png"/></div></figure><p id="e24f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，在<code class="fe le lf lg lh b">forEach()</code>中使用一个箭头函数自动解决了这个问题，我们不必使用<code class="fe le lf lg lh b">bind</code>或将<code class="fe le lf lg lh b">this</code>的值赋给其他变量。这是因为箭头函数自动绑定它们的上下文，所以<code class="fe le lf lg lh b">this</code>实际上指的是原始上下文或原始对象。</p><h2 id="a2be" class="ly lz it bd mt nu nv dn mx nw nx dp nb kr ny nz nf kv oa ob nj kz oc od nn oe bi translated">例5。</h2><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/f1fdd43352bb8c2f5f2348ef65e10043.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*BJhpC6TAwqADiJy55o3pxQ.png"/></div></figure><pre class="lq lr ls lt gt lu lh lv lw aw lx bi"><span id="82a4" class="ly lz it lh b gy ma mb l mc md">var car = {<br/>  make: "Lamborghini",<br/>  model: "Huracán",<br/>  fullName: function () {<br/>    console.log(this.make +" "+ this.model);<br/>   }<br/>}<br/>var truck = {<br/>  make: "Tesla",<br/>  model: "Truck",<br/>  fullName: function (callback) {<br/>    console.log(this.make +" "+ this.model);<br/>    callback();<br/>  }<br/>}<br/>truck.fullName(car.fullName);</span></pre><p id="bf23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码由两个相同的对象组成，其中一个包含一个<strong class="ki iu">回调</strong>函数。<strong class="ki iu">回调</strong>函数是作为参数传递给另一个函数的函数，然后在外部函数中被调用以完成某种例程。</p><p id="1b2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，卡车对象的<code class="fe le lf lg lh b">fullName </code>方法由一个<strong class="ki iu">回调</strong>组成，该回调也在它的<strong class="ki iu">内部被调用。</strong>我们的车对象还是和以前一样。当我们使用回调(参数)作为汽车对象的<code class="fe le lf lg lh b">fullName</code>方法调用卡车的<code class="fe le lf lg lh b">fullName</code>方法时，我们得到的输出是<code class="fe le lf lg lh b">Tesla Truck</code>和<code class="fe le lf lg lh b">undefined undefined.</code></p><p id="b05e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在阅读了<code class="fe le lf lg lh b">this</code>之后，你们中的一些人可能已经预感到<code class="fe le lf lg lh b">car.fullName </code>会打印卡车物体的模型和构造，但是让你们失望的是，<code class="fe le lf lg lh b">this</code>又一次捉弄了我们。在这里，<code class="fe le lf lg lh b">car.fullName </code>作为一个参数被传递，实际上并没有被truck对象调用。回调调用car对象方法，但是请注意，该函数的实际调用位置是回调，回调将它绑定到全局对象。有点混乱，再读一遍！</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/b56d5755be55f173b9048d62115082a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*IdBUtNtj1dAfnlfpP0J4Cw.png"/></div></figure><p id="0c9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了清楚起见，我们打印了<code class="fe le lf lg lh b">this</code>本身。我们可以看到回调的<code class="fe le lf lg lh b">this</code>被赋予了全局作用域。所以为了得到结果，我们创建了全局属性<code class="fe le lf lg lh b">make</code>和<code class="fe le lf lg lh b">model</code>。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/5ece35188fc5efe8a1c7f53b9840b6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*btzkE_B7sWDmu3WE_rSPog.png"/></div></figure><p id="e232" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，使用全局<code class="fe le lf lg lh b">make</code>和<code class="fe le lf lg lh b">model</code>属性运行相同的代码，我们最终得到全局<code class="fe le lf lg lh b">this</code>的答案。这证明了<code class="fe le lf lg lh b">this</code>引用了全局对象。</p><p id="b2fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了得到我们想要的结果，<code class="fe le lf lg lh b">car.fullName</code>结果我们将再次使用<code class="fe le lf lg lh b">bind()</code>将car对象硬绑定到回调，这将使一切再次正确。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/d92909a9724c2c9e437b4833a8aae3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*-1yq1uBIO1PPQ7ZJEUXSiw.png"/></div></figure><h1 id="296a" class="ms lz it bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">解决了！</h1><p id="ab85" class="pw-post-body-paragraph kg kh it ki b kj np kl km kn nq kp kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">毫无疑问<code class="fe le lf lg lh b">this</code>非常有用，但也有它自己的陷阱。我希望我让你很容易理解。如果你想要更多像这样简化的内容，请关注我的Medium。如果你喜欢，请留下你的回答并分享。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi po"><img src="../Images/8fa3b0fe054a13c3766d159ba831adc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/1*puO9QPsENQ5ww1QKNuf6tw.gif"/></div></div></figure></div></div>    
</body>
</html>