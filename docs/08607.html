<html>
<head>
<title>How to Implement a Linked List in Java from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Java从头开始实现一个链表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-a-linked-list-in-java-from-scratch-9a4f6f9e51ce?source=collection_archive---------11-----------------------#2021-05-16">https://levelup.gitconnected.com/how-to-implement-a-linked-list-in-java-from-scratch-9a4f6f9e51ce?source=collection_archive---------11-----------------------#2021-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1066648ef703bd5ce0bbd7f2f5c0db6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GZRT1jjyFHuGTPfl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="517c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于没有接受过计算机科学方面的正式培训，我总是试图弥补我可能存在的知识缺口。</p><p id="2116" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中之一肯定是对数据结构的深入了解。在参加了加州大学圣地亚哥分校在Coursera 上提供的关于<a class="ae kf" href="https://www.coursera.org/learn/data-structures-optimizing-performance" rel="noopener ugc nofollow" target="_blank">数据结构和性能的课程后，我明白了解决这类问题的最好方法之一就是从头开始构建。</a></p><p id="ff66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我告诉你我是怎么做的，以及在这个过程中我学到了什么。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="112a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">但是…数据结构到底是什么？</h1><p id="abd9" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在开始变得更具体之前…什么是数据结构？</p><p id="1914" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">据<a class="ae kf" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="mo mp mq"><p id="ac87" class="kg kh mr ki b kj kk kl km kn ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated"><em class="it">在</em> <a class="ae kf" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank"> <em class="it">计算机科学</em> </a> <em class="it">中，一种</em> <strong class="ki iu"> <em class="it">数据结构</em> </strong> <em class="it">是一种数据组织、管理和存储格式，能够使</em><a class="ae kf" href="https://en.wikipedia.org/wiki/Algorithmic_efficiency" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a><em class="it">高效的访问和修改。更准确地说，数据结构是</em> <a class="ae kf" href="https://en.wikipedia.org/wiki/Data" rel="noopener ugc nofollow" target="_blank"> <em class="it">数据值</em> </a> <em class="it">以及它们之间的关系，以及可以应用于数据的函数或操作的集合。<br/> (…) <br/>数据结构是</em> <a class="ae kf" href="https://en.wikipedia.org/wiki/Abstract_data_type" rel="noopener ugc nofollow" target="_blank"> <em class="it">抽象数据类型</em> </a> <em class="it"> (ADT)的基础。ADT定义了数据类型的逻辑形式。数据结构实现了数据类型的物理形式。</em></p></blockquote><p id="0e46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，什么？</p><p id="0cf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不知道是不是只有我这样，但是每当我读到像这样的“抽象”定义时，我往往会感到非常困惑。</p><p id="a6d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在我看来，外行人对此的解释可以是，数据结构是允许我们更好、更有效地使用数据的<em class="mr">东西。</em></p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/865a42c519f86e4caa670a3ccbb65d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S56lmB8c4BzE4aZS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">苏珊·Q·尹在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9b55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在现实生活中想象一下。假设你有一堆<strong class="ki iu">的书</strong>(在这个类比中，就是<strong class="ki iu">的数据</strong>)。你可以把它们放在你的房间里，你仍然可以使用它们，但也许这不是最有效的方法。所以也许你可以想出<strong class="ki iu">的东西</strong>来帮你完成这个任务。也许你可以把它们作为<strong class="ki iu">堆</strong>放在你的桌子上，或者也许你可以把它们放在<strong class="ki iu">架子</strong>上，根据不同的标准排序。在我们的类比中，这些安排就是<strong class="ki iu">数据结构</strong>。</p><h1 id="fc2a" class="ll lm it bd ln lo na lq lr ls nb lu lv lw nc ly lz ma nd mc md me ne mg mh mi bi translated">什么是链表？</h1><p id="7ff0" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">回到编程世界，一个<strong class="ki iu">链表</strong>当然是一个<strong class="ki iu">数据结构</strong>。</p><p id="7fa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特别是，它是一个名为<strong class="ki iu">列表</strong>的<strong class="ki iu">抽象数据类型</strong>的实现。回到前面的解释，抽象数据类型类似于数据类型最终要做的事情的框架。</p><p id="4688" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，一个<strong class="ki iu">列表</strong>只是一组项目的枚举。想象一个购物清单:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/5ad24d2d565c741ca1e97b36ece24697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IBrjKagqaF3r6r89"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">亚历山大·席默克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="23d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它只是一个你想买的杂货的枚举，你可以在这个列表上执行基本的操作，比如:插入新的商品，删除你不再感兴趣的商品，或者寻找一个特定的商品(例如，确定你下一步要选什么)。</p><p id="841b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，当我们编程时，我们可以<strong class="ki iu">实现</strong>这个列表和它的方法，这取决于我们想对它做什么。在这种情况下，<strong class="ki iu">实现</strong>意味着，即使每个列表都会有大致相同的<strong class="ki iu">方法</strong>(操作)，它们背后的<strong class="ki iu">逻辑</strong>也会不同。</p><p id="0a04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<strong class="ki iu">链表</strong>中，我们列表中的项目在内存中可能很稀疏，但是我们会通过<strong class="ki iu">指针</strong>或<strong class="ki iu">引用</strong>建立它们之间的关系，从而将它们一起保存在列表中。</p><p id="c71a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以将列表中的每一项都视为一个<strong class="ki iu">节点</strong>，其中至少包含两条信息:</p><ul class=""><li id="3dba" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated"><strong class="ki iu">数据</strong>(物品信息本身)。</li><li id="509c" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">一个<strong class="ki iu">引用</strong>到另一个节点。</li></ul><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/79752f14fbffd9b13b280f93e55941e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xGcJhYcAkt_ihVaG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</figcaption></figure><p id="f1bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将给出类似于上图的结果。我们称之为<strong class="ki iu">单链表</strong>，因为每个节点只有对另一个节点的引用(在这种情况下，是对下一个节点的引用)。对于最后一个节点，没有下一个，所以引用将指向一个空对象。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/d0951809ea2c519b96c94c021a369604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fJBJnKwAWpF_ZFmX"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</figcaption></figure><p id="509a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前图所示，如果我们创建对每个<strong class="ki iu">下一个</strong>和<strong class="ki iu">上一个</strong>节点的引用，那么我们将拥有一个<strong class="ki iu">双向链表</strong>。</p><h1 id="cfe7" class="ll lm it bd ln lo na lq lr ls nb lu lv lw nc ly lz ma nd mc md me ne mg mh mi bi translated">如何开始:构造函数和第一个方法</h1><p id="f683" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">那么…我们需要什么来开始呢？</p><p id="aa59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要考虑让所有这些运行起来所需的<strong class="ki iu">类</strong>。当然，我们需要一个类来保存链表，所以我们可以为此创建一个类。然而，不要<strong class="ki iu">而不是</strong>调用这个类<em class="mr"> LinkedList </em>，因为这个实现已经在Java中存在了！(是的，我们学习是为了好玩)。</p><p id="7587" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我将实现一个<strong class="ki iu">双向链表</strong>，并且我将使用<strong class="ki iu">前哨节点</strong>。这些节点作为一种缓冲，确保我的列表中总是有两个节点，即使它是空的。这些节点是<strong class="ki iu">头</strong>(列表的第一个节点)和<strong class="ki iu">尾</strong>(列表的最后一个节点)，它们将始终为<strong class="ki iu">空</strong>。他们只会在帮助我们实现方面有用。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/80b527d74f3ed3dcd174c379d2574200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hklrd5O3t-jisbND"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</figcaption></figure><p id="4fc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们的链表类需要:</p><ul class=""><li id="fc97" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated">一个<strong class="ki iu">头</strong>。</li><li id="d3fb" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">一条<strong class="ki iu">尾巴</strong>。</li><li id="73bc" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated"><strong class="ki iu">尺寸</strong>。</li></ul><p id="9914" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以开始写这样的东西:</p><pre class="mw mx my mz gt nv nw nx ny aw nz bi"><span id="8e9c" class="oa lm it nw b gy ob oc l od oe">// AbstractList is the abstract data type in this case<br/>public class ImpLinkedList extends AbstractList {<br/>// E means that we are using Generics<br/>LLNode&lt;E&gt; head;<br/>LLNode&lt;E&gt; tail;<br/>public int size;</span><span id="157b" class="oa lm it nw b gy of oc l od oe">public ImpLinkedList() {<br/>    head = new LLNode&lt;E&gt;(null);<br/>    tail = new LLNode&lt;E&gt;(null);<br/>    size = 0;<br/>// when the list is empty, we only have head and tail. <br/>// So they will keep referencing each other<br/>    head.nextNode = tail;<br/>    tail.prevNode = head;<br/>}</span><span id="5bd9" class="oa lm it nw b gy of oc l od oe">// methods<br/>}</span></pre><p id="3fea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你注意第4行，两件有趣的事情正在发生:</p><ol class=""><li id="7c97" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld og nm nn no bi translated">我正在使用一个LLNode对象，但是什么是LLNode对象呢？</li><li id="b171" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld og nm nn no bi translated">该LLNode似乎正在处理<strong class="ki iu"> E </strong>类型的数据。这又是什么？</li></ol><p id="88e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，关于第一点:正如我们之前看到的，一个链表是由<strong class="ki iu">节点</strong>组成的。所以是的，我们必须为此创建一个类，是的，我把它叫做<strong class="ki iu"> LLNode </strong>。</p><p id="15b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于第2点:我们<strong class="ki iu">事先不知道</strong>我们将用链表处理什么类型的数据(字符串、整数、另一个对象？).当然，为我们想要处理的每种数据类型实现一个新的列表是没有意义的。<br/>在Java中，我们可以通过使用<a class="ae kf" href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">泛型</strong> </a>来处理这个问题。通过指定一个大写字母(查看前面的链接以了解约定)，我们可以确保我们的解决方案将处理任何数据类型，而无需事先知道它。</p><p id="d9a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道了所有这些，是时候创建<strong class="ki iu"> LLNode </strong>类了。它只需要具备:</p><ul class=""><li id="0bae" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated">数据。</li><li id="0606" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">对上一个节点的引用。</li><li id="3c5e" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">对下一个节点的引用。</li></ul><pre class="mw mx my mz gt nv nw nx ny aw nz bi"><span id="5a3e" class="oa lm it nw b gy ob oc l od oe">public class LLNode {<br/>// Generics again<br/>E data;<br/>LLNode&lt;E&gt; prevNode;<br/>LLNode&lt;E&gt; nextNode;<br/></span><span id="88a0" class="oa lm it nw b gy of oc l od oe">public LLNode(E e){<br/>    this.data = e;<br/>    this.prevNode = null;<br/>    this.nextNode = null;<br/>}<br/>}</span></pre><p id="e305" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！有了这个，我们就有了继续工作所需的所有基础。现在我们可以开始在我们的<strong class="ki iu"> ImpLinkedList </strong>类中实现我们需要的方法。下面是我如何实现<strong class="ki iu"> add </strong>方法的一个例子:</p><pre class="mw mx my mz gt nv nw nx ny aw nz bi"><span id="1578" class="oa lm it nw b gy ob oc l od oe">public class ImpLinkedList extends AbstractList {<br/>// constructors</span><span id="235f" class="oa lm it nw b gy of oc l od oe">public boolean add(E data) {<br/>	if (data != null) {<br/>		// create new node<br/>		LLNode&lt;E&gt; newNode = new LLNode&lt;E&gt;(data);<br/>		// change links<br/>		//	newNode -&gt; next (tail)<br/>		//			-&gt; prev (tail.prev)<br/>		newNode.nextNode = tail;<br/>		newNode.prevNode = tail.prevNode;<br/>		//	prev	-&gt; next (newNode)<br/>		tail.prevNode.nextNode = newNode;<br/>		//	tail	-&gt; prev (newNode)	<br/>		tail.prevNode = newNode;<br/>			<br/>		// increase size<br/>		size += 1;<br/>			<br/>		return true;<br/>	}<br/>	return false;<br/>}<br/>// other methods<br/>}</span></pre><p id="8509" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以实现其他典型方法，例如:</p><ul class=""><li id="a221" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated">get →给定一个(整数)索引，它从相应的节点返回数据。</li><li id="fb3a" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">添加→到特定位置。提供数据和索引，将元素添加到列表中的特定位置。</li><li id="b072" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">remove →给定一个索引，删除相应的节点。</li><li id="83ea" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">size →返回列表的大小。</li><li id="7691" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">set →给定一个索引，更新(修改)相应节点的数据。</li></ul><h1 id="372f" class="ll lm it bd ln lo na lq lr ls nb lu lv lw nc ly lz ma nd mc md me ne mg mh mi bi translated">我学到了什么</h1><p id="5e0c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">那么…如果已经有了链表的Java实现，为什么还要做这些呢？</p><p id="b904" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然在实际情况下，我更喜欢Java的内置解决方案，而不是我的，但我喜欢做这个练习，因为我可以学到很多东西:</p><ul class=""><li id="a414" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated">我没有受过非常正规的计算机科学教育，所以我学到了很多关于数据结构和它们应该做什么的知识。</li><li id="167d" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">我学会了抽象思考。我习惯于只处理相当实际的问题，所以暂时用更通用或抽象的方式思考是一个很好的练习。</li><li id="8988" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">我了解了仿制药。是的，我承认这个概念以前在我脑海里只是一个模糊的词。</li><li id="0a71" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">我提高了我的测试技能。我学到了很多关于我应该在我的代码中测试什么，什么时候测试等等。</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e1d3" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">链接和参考</h1><ul class=""><li id="04fa" class="ng nh it ki b kj mj kn mk kr oh kv oi kz oj ld nl nm nn no bi translated"><a class="ae kf" href="https://www.coursera.org/learn/data-structures-optimizing-performance" rel="noopener ugc nofollow" target="_blank">数据结构和性能—加州大学圣地亚哥分校Coursera的课程</a></li><li id="8ba5" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">维基百科上的数据结构</a></li><li id="cf59" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated"><a class="ae kf" href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" rel="noopener ugc nofollow" target="_blank">Oracle泛型的Java文档</a></li></ul></div></div>    
</body>
</html>