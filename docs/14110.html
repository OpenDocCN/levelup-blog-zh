<html>
<head>
<title>Template Type Deduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模板类型演绎</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/template-type-deduction-69330052f085?source=collection_archive---------26-----------------------#2022-11-01">https://levelup.gitconnected.com/template-type-deduction-69330052f085?source=collection_archive---------26-----------------------#2022-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="91cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">C++中的模板类型演绎</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a9e1e182f9e8a96ccb0e99644a0b105f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y6orlw0_iSPfrXrJ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄影师</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="93b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们谈到C++，<code class="fe ls lt lu lv b">auto</code>应该是一个引人注目的特性。尽管如此，要理解<code class="fe ls lt lu lv b">auto</code>的类型演绎，我们应该先看看<code class="fe ls lt lu lv b">template type deduction</code>。本帖内容借用了<a class="ae kv" href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/" rel="noopener ugc nofollow" target="_blank">有效现代C++ </a>中的<em class="lw">“第1项:理解模板类型演绎</em>”。</p><p id="bafe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当没有明确指定的模板参数时，会发生模板类型推导。下面是一个显示明确指定的模板参数的简单例子。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="9f76" class="mb mc iq lv b gy md me l mf mg">template&lt;typename T&gt;<br/>void f(const T&amp; param)</span><span id="a871" class="mb mc iq lv b gy mh me l mf mg">int x = 0; <br/>f&lt;double&gt;(x);</span></pre><p id="4418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解释更多关于模板类型推断的内容，我们将使用两个关键字，分别是<code class="fe ls lt lu lv b">T</code>和<code class="fe ls lt lu lv b">ParameterType</code>，如下所示</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="aea9" class="mb mc iq lv b gy md me l mf mg">template&lt;typename T&gt;<br/>void f(ParameterType param)</span></pre><ul class=""><li id="d629" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated"><code class="fe ls lt lu lv b">T</code>是模板参数的类型，而<code class="fe ls lt lu lv b">ParameterType</code>是函数参数的类型<code class="fe ls lt lu lv b">param</code></li><li id="1c88" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated"><code class="fe ls lt lu lv b">T</code>和<code class="fe ls lt lu lv b">ParameterType</code>可以是但不一定是相同的。</li></ul><p id="696b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用于调用下面的函数<code class="fe ls lt lu lv b">f(expr)</code></p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="73e9" class="mb mc iq lv b gy md me l mf mg">template&lt;typename T&gt;<br/>void f(const T&amp; param)</span><span id="afef" class="mb mc iq lv b gy mh me l mf mg">int x = 0;<br/>f(x);</span></pre><p id="0670" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">T</code>推导为<code class="fe ls lt lu lv b">int</code>，而<code class="fe ls lt lu lv b">ParameterType</code>推导为<code class="fe ls lt lu lv b">const int &amp;</code>。</p><p id="d5f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为<code class="fe ls lt lu lv b">T</code>推导类型，不仅取决于<code class="fe ls lt lu lv b">expr</code>的类型，还取决于<code class="fe ls lt lu lv b">ParameterType</code>的形式。</p><p id="affb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三种情况</p><ul class=""><li id="2707" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated"><code class="fe ls lt lu lv b">ParameterType</code>是指针或引用类型，但不是通用引用</li><li id="fc3c" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated"><code class="fe ls lt lu lv b">ParameterType</code>是通用参考</li><li id="9b4f" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated"><code class="fe ls lt lu lv b">ParameterType</code>既不是指针也不是参照物</li></ul><h1 id="8356" class="mw mc iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">ParameterType是指针或引用类型，但不是通用引用</h1><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="fcbb" class="mb mc iq lv b gy md me l mf mg">template&lt;typename T&gt;<br/>void f1(T&amp;) {<br/>  std::cout &lt;&lt; "T is ";<br/>  if (std::is_const_v&lt;T&gt;) {<br/>    std::cout &lt;&lt; "const ";<br/>  }<br/>  std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;<br/>}</span></pre><p id="fbdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果现在我们运行</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="6ad4" class="mb mc iq lv b gy md me l mf mg">int main() {<br/>  int x = 27;<br/>  const int cx = x;<br/>  const int&amp; rx = x;<br/>  f1(x);<br/>  f1(cx);<br/>  f1(rx);<br/>}</span></pre><p id="d446" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出将是</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="97c8" class="mb mc iq lv b gy md me l mf mg">T is i<br/>T is const i<br/>T is const i</span></pre><p id="ff3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在类型推导过程中，rx的引用性被忽略，这对于指针也是一样的。</p><p id="e1a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们为模板函数的参数显式地写下<code class="fe ls lt lu lv b">const</code>，让我们看看什么会被推导为</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="3ab3" class="mb mc iq lv b gy md me l mf mg">template &lt;typename T&gt;<br/>void f2(const T&amp;) {<br/> std::cout &lt;&lt; "T is ";<br/> if (std::is_const_v&lt;T&gt;) {<br/>   std::cout &lt;&lt; "const ";<br/> } <br/> std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;<br/>}</span></pre><p id="0c18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们使用<code class="fe ls lt lu lv b">f2</code>再次运行代码，输出将是</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="733d" class="mb mc iq lv b gy md me l mf mg">T is i<br/>T is i<br/>T is i</span></pre><p id="2768" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这三种情况，<code class="fe ls lt lu lv b">T</code>被推导为<code class="fe ls lt lu lv b">int</code>，换句话说，被调用的函数实际上是<code class="fe ls lt lu lv b">void f2(const int &amp;)</code></p><h1 id="ed42" class="mw mc iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">ParameterType是一个通用引用</h1><ul class=""><li id="2974" class="mi mj iq ky b kz nn lc no lf np lj nq ln nr lr mn mo mp mq bi translated">为了通用引用，我们可以使用完美转发来检查调用的是哪种类型的函数。<a class="ae kv" href="https://pinloon.medium.com/perfect-forwarding-647e1caaf879" rel="noopener">完美转发</a>请参考我之前的帖子</li><li id="8dfd" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">现在，让我们使用完美转发和一些函数重载来检查调用的是哪种类型的函数。</li></ul><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="d1b9" class="mb mc iq lv b gy md me l mf mg">void f(int&amp;) { std::cout &lt;&lt; "calling f(int &amp;)" &lt;&lt; std::endl; }</span><span id="d9ad" class="mb mc iq lv b gy mh me l mf mg">void f(const int&amp;) { <br/> std::cout &lt;&lt; "calling f(const int &amp;)" &lt;&lt; std::endl;<br/>}</span><span id="68d7" class="mb mc iq lv b gy mh me l mf mg">void f(int&amp;&amp;) { std::cout &lt;&lt; "calling f(int &amp;&amp;)" &lt;&lt; std::endl; }</span><span id="f201" class="mb mc iq lv b gy mh me l mf mg">template &lt;typename T&gt;<br/>void f3(T&amp;&amp; param) {<br/>  f(std::forward&lt;T&gt;(param));<br/>}</span></pre><p id="931b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们执行</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="0e3b" class="mb mc iq lv b gy md me l mf mg">int main() {<br/>  int x = 27; <br/>  const int cx = x; <br/>  const int&amp; rx = x; <br/>  f3(x);<br/>  f3(cx);<br/>  f3(rx);<br/>  f3(27);<br/>}</span></pre><p id="2f4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将获得以下输出</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="9cb5" class="mb mc iq lv b gy md me l mf mg">calling f(int &amp;)<br/>calling f(const int &amp;)<br/>calling f(const int &amp;)<br/>calling f(int &amp;&amp;)</span></pre><p id="e0ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保持左流和右流。</p><h1 id="8133" class="mw mc iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">ParameterType既不是指针也不是引用</h1><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="b81a" class="mb mc iq lv b gy md me l mf mg">template &lt;typename T&gt;<br/>void f4(T) {<br/>  std::cout &lt;&lt; "T is ";<br/>  if (std::is_const_v&lt;T&gt;) {<br/>   std::cout &lt;&lt; "const "; <br/>  }<br/>  std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;<br/>}</span></pre><p id="f233" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当通过值传递时，<code class="fe ls lt lu lv b">const</code>，<code class="fe ls lt lu lv b">volatile</code>和引用将被忽略。</p><p id="fd3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们使用<code class="fe ls lt lu lv b">f4</code>再次运行代码，输出将是</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="cdbd" class="mb mc iq lv b gy md me l mf mg">T is i<br/>T is i<br/>T is i</span></pre><p id="6233" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！代码可在<a class="ae kv" href="https://github.com/pllee4/blog-public/tree/master/posts/005/files" rel="noopener ugc nofollow" target="_blank">这里</a>获得。希望你现在能更好地理解模板类型演绎。</p></div></div>    
</body>
</html>