<html>
<head>
<title>3 Things You Don’t Know that JavaScript Objects can do</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript对象能做的3件你不知道的事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-things-you-dont-know-that-javascript-objects-can-do-e5ba4c161756?source=collection_archive---------15-----------------------#2020-04-08">https://levelup.gitconnected.com/3-things-you-dont-know-that-javascript-objects-can-do-e5ba4c161756?source=collection_archive---------15-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6891ba56d572b8ec7a693737d318c588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vtGjSHyuQ-ajY1Oi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dorner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·多纳</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="418a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了普通的对象属性赋值和遍历之外，我们还可以对JavaScript对象进行许多其他操作。</p><p id="e14e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何使用它们，包括访问内部属性、操作属性描述符和继承只读属性。</p><h1 id="afec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1.访问内部属性</h1><p id="1c71" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript对象具有不能以通常方式访问的内部插槽或属性。</p><p id="f6dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们的属性名用双方括号<code class="fe mh mi mj mk b">[[]]</code>括起来，在创建对象时可用。</p><p id="42b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们不能动态添加到现有对象中。</p><p id="7eee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它在某些内置的JavaScript对象中可用，它们按照ECMAScript规范的规定存储内部状态。</p><p id="6cf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种内部插槽，它们或者是操作对象的方法，或者是存储数据。</p><p id="ea57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下属性是插槽:</p><ul class=""><li id="1f84" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe mh mi mj mk b">[[Prototype]]</code> —一个对象的原型，可以是<code class="fe mh mi mj mk b">null</code>或一个对象</li><li id="7486" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe mh mi mj mk b">[[Extensible]]</code> —布尔型，存储对象是否可以添加属性</li><li id="55ac" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe mh mi mj mk b">[[PrivateFieldValues]]</code> —用于管理私有类字段</li></ul><h1 id="e147" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2.属性描述符</h1><p id="34fd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript对象中的每个属性都有一个属性描述符。它用于指定值，是可写的、可配置的还是可枚举的。</p><p id="bde2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">value</code>描述符是属性值。例如，如果我们有以下对象:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="73ea" class="nh lf it mk b gy ni nj l nk nl">let foo = {<br/>  a: 1<br/>}</span></pre><p id="20c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">a</code>的<code class="fe mh mi mj mk b">value </code>属性描述符就是<code class="fe mh mi mj mk b">1</code>。</p><p id="4b6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">writable</code>表示属性值是否可以改变。默认值是<code class="fe mh mi mj mk b">true</code>，这意味着属性是可写的。但是，我们可以用各种方法将其设置为不可写。</p><p id="b521" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">configurable</code>表示对象的属性是否可以删除，或者其属性描述符是否可以改变。默认值是<code class="fe mh mi mj mk b">true</code>，这意味着它是可配置的。</p><p id="e443" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">enumerable</code>表示可以被<code class="fe mh mi mj mk b">for...in</code>回路循环通过。它的默认值是<code class="fe mh mi mj mk b">true</code>，这意味着当我们用<code class="fe mh mi mj mk b">for...in</code>循环遍历它时，我们会看到它。</p><p id="f5fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在将属性键添加到返回的数组之前，<code class="fe mh mi mj mk b">Object.keys</code>方法还会检查<code class="fe mh mi mj mk b">enumerable</code>描述符。然而，<code class="fe mh mi mj mk b">Reflect.ownKeys</code>方法并不检查这个属性描述符，而是返回所有自己的属性键。</p><p id="feb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性描述符有另外的方法，<code class="fe mh mi mj mk b">get</code>和<code class="fe mh mi mj mk b">set</code>分别用于获取和设置值。</p><p id="ad28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用使用<code class="fe mh mi mj mk b">Object.defineProperty</code>方法设置的描述符创建新的属性，如下所示:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="e8bc" class="nh lf it mk b gy ni nj l nk nl">let foo = {<br/>  a: 1<br/>}</span><span id="d12d" class="nh lf it mk b gy nm nj l nk nl">Object.defineProperty(foo, 'b', {<br/>  value: 2,<br/>  writable: true,<br/>  enumerable: true,<br/>  configurable: true,<br/>});</span></pre><p id="1b07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mh mi mj mk b">foo</code>的新值是<code class="fe mh mi mj mk b">{a: 1, b: 2}</code>。</p><p id="5ee3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用<code class="fe mh mi mj mk b">defineProperty</code>来改变现有属性的描述符。例如，我们可以写:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="c096" class="nh lf it mk b gy ni nj l nk nl">let foo = {<br/>  a: 1<br/>}</span><span id="3062" class="nh lf it mk b gy nm nj l nk nl">Object.defineProperty(foo, 'a', {<br/>  value: 2,<br/>  writable: false,<br/>  enumerable: true,<br/>  configurable: true,<br/>});</span></pre><p id="751d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们试图给<code class="fe mh mi mj mk b">foo.a</code>赋值时，比如:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="0f8e" class="nh lf it mk b gy ni nj l nk nl">foo.a = 2;</span></pre><p id="0139" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果关闭了严格模式，浏览器将忽略，否则将抛出一个错误。</p><p id="a9b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<code class="fe mh mi mj mk b">defineProperty</code>将一个属性转换成一个getter，如下所示:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="1090" class="nh lf it mk b gy ni nj l nk nl">'use strict'<br/>let foo = {<br/>  a: 1<br/>}</span><span id="3a1d" class="nh lf it mk b gy nm nj l nk nl">Object.defineProperty(foo, 'b', {<br/>  get() {<br/>    return 1;<br/>  },<br/>});</span></pre><p id="2ec9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们写下:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="49d8" class="nh lf it mk b gy ni nj l nk nl">foo.b = 2;</span></pre><p id="29fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当严格模式打开时，我们会得到一个错误，因为<code class="fe mh mi mj mk b">b</code>属性是一个getter属性。不能将Getter属性重新分配给不同的值。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/6893a4a1e0dd2326e901b7f4227430f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nD7rnDQu5Kl0i9r1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@namroud?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Namroud Gorguis </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="e6ef" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.不能将继承的只读属性分配给</h1><p id="8981" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">不能为对象的继承只读属性赋值。这是有意义的，因为我们这样设置它，它是继承的，所以它应该传播到继承该属性的对象。</p><p id="f1e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">Object.create</code>创建一个从原型对象继承属性的对象，如下所示:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="fec0" class="nh lf it mk b gy ni nj l nk nl">const proto = Object.defineProperties({}, {<br/>  a: {<br/>    value: 1,<br/>    writable: false,<br/>  }<br/>});</span><span id="8a04" class="nh lf it mk b gy nm nj l nk nl">const foo = Object.create(proto);</span></pre><p id="353b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将<code class="fe mh mi mj mk b">proto.a</code>的<code class="fe mh mi mj mk b">writable</code>属性描述符设置为<code class="fe mh mi mj mk b">false</code>，这样我们就不能再给它赋值了。</p><p id="1251" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在最后一行用<code class="fe mh mi mj mk b">Object.create</code>方法创建一个从<code class="fe mh mi mj mk b">proto</code>继承的<code class="fe mh mi mj mk b">foo</code>对象。</p><p id="db41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们写下:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="06cc" class="nh lf it mk b gy ni nj l nk nl">foo.a = 2;</span></pre><p id="1595" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在严格模式下我们会得到一个错误，否则会被忽略。</p><h1 id="0d33" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="1b32" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用JavaScript对象做很多我们可能不知道的事情。</p><p id="88cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，一些JavaScript对象，如内置的浏览器对象，有内部的槽或属性，用双方括号括起来，保存内部状态，以后不能动态添加。</p><p id="9166" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript对象属性也有属性描述符，这让我们可以控制它们的值，以及它们是否可以被设置，或者它们的属性描述符是否可以改变，等等。</p><p id="07d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">defineProperty</code>改变一个属性的属性描述符。它还用于添加一个新属性及其属性描述符。</p><p id="54b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，继承的只读属性保持只读，这是有意义的，因为它是从父原型对象继承的。</p></div></div>    
</body>
</html>