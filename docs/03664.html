<html>
<head>
<title>JavaScript Best Practices — Arrow Functions and Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—箭头函数和构造函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-arrow-functions-and-constructors-7b219149cd22?source=collection_archive---------16-----------------------#2020-05-21">https://levelup.gitconnected.com/javascript-best-practices-arrow-functions-and-constructors-7b219149cd22?source=collection_archive---------16-----------------------#2020-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5e42e07e5cc6328a6c41c70fa2a5d0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z9UGRS-E5reVz3mU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">缺口缺口</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">缺口</a>处拍摄</figcaption></figure><p id="8025" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="5fc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究箭头函数的签名、间距，并记住在子类构造函数中调用<code class="fe le lf lg lh b">super</code>。</p><h1 id="02ab" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">箭头函数参数</h1><p id="00bc" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当我们定义箭头函数时，如果我们的函数只有一个参数，就不需要括号。</p><p id="3e74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来返回乘以2的结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3c39" class="mt lj it lh b gy mu mv l mw mx">const double = x =&gt; x * 2;</span></pre><p id="09ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们的<code class="fe le lf lg lh b">double</code>函数有一个参数<code class="fe le lf lg lh b">x</code>并返回乘以2的<code class="fe le lf lg lh b">x</code>。</p><p id="a4e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们没有在签名周围加上括号，因为如果arrow函数只有一个参数，就不需要括号。</p><p id="0d8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有一个参数的arrow函数的括号是可选的。我们可以把它放进去，如果我们认为它使阅读功能更清楚。例如，我们可以编写以下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3f88" class="mt lj it lh b gy mu mv l mw mx">const double = (x) =&gt; x * 2;</span></pre><p id="1091" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与我们在前面的例子中看到的是一样的。</p><p id="8f24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的arrow函数没有一个参数，那么括号是必需的。例如，我们可以编写以下函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="79b5" class="mt lj it lh b gy mu mv l mw mx">const foo = () =&gt; {};<br/>const add = (a, b) =&gt; a + b;</span></pre><p id="ab36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有没有参数的<code class="fe le lf lg lh b">foo</code>函数，所以函数签名必须用括号括起来，以表明它没有参数。</p><p id="018b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个例子是<code class="fe le lf lg lh b">add</code>函数，它有两个参数，所以我们需要用括号将<code class="fe le lf lg lh b">a</code>和<code class="fe le lf lg lh b">b</code>参数括起来。</p><h1 id="bcc8" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">箭头函数箭头前后的空格</h1><p id="adb1" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">箭头函数有一个粗箭头作为其函数定义的一部分。通常，我们在粗箭头的前后有一个空格字符。</p><p id="1b45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们通常将箭头函数定义如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4e43" class="mt lj it lh b gy mu mv l mw mx">const foo = () =&gt; {};</span></pre><p id="e1b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe le lf lg lh b">foo</code>函数，它在<code class="fe le lf lg lh b">=&gt;</code>粗箭头的前后都有一个空格字符。</p><p id="45eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种间距使我们的函数定义更加清晰，并且隔开的文本比没有间距的文本更容易阅读。</p><h1 id="d985" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">Remember to Call super()</code>在构造函数中</h1><p id="d4fe" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们在JavaScript中有一个类扩展了另一个类，那么我们必须记住调用<code class="fe le lf lg lh b">super</code>，这样我们在运行代码时就不会出错。</p><p id="d606" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6f38" class="mt lj it lh b gy mu mv l mw mx">class Animal {<br/>  constructor(type) {<br/>    this.type = type;<br/>  }<br/>}</span><span id="0ca3" class="mt lj it lh b gy my mv l mw mx">class Cat extends Animal {<br/>  constructor() {}<br/>}</span><span id="1e90" class="mt lj it lh b gy my mv l mw mx">const cat = new Cat();</span></pre><p id="0da3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们运行上面的代码时，我们会得到一个错误，告诉我们调用超级构造函数，类似于' un catch reference error:在访问' this '或从派生构造函数返回之前，必须调用派生类中的<code class="fe le lf lg lh b">super </code>构造函数'。</p><p id="f87a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好，因为我们不会忘记调用<code class="fe le lf lg lh b">Cat</code>中的<code class="fe le lf lg lh b">super</code>，因为代码不会运行。</p><p id="9587" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该通过编写以下代码来纠正这个错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8a3e" class="mt lj it lh b gy mu mv l mw mx">class Animal {<br/>  constructor(type) {<br/>    this.type = type;<br/>  }<br/>}</span><span id="86ae" class="mt lj it lh b gy my mv l mw mx">class Cat extends Animal {<br/>  constructor(type) {<br/>    super(type);<br/>  }<br/>}</span><span id="41ad" class="mt lj it lh b gy my mv l mw mx">const cat = new Cat();</span></pre><p id="ef93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe le lf lg lh b">Cat</code>类的构造函数中调用了<code class="fe le lf lg lh b">super</code>。</p><p id="df10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管JavaScript类只是构造函数的语法糖，但它确实能防止我们犯在我们有类语法之前容易犯的错误。</p><p id="3315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe le lf lg lh b">extends</code>关键字和<code class="fe le lf lg lh b">super</code>函数，而不是在父构造函数上调用<code class="fe le lf lg lh b">call</code>方法，而是使用<code class="fe le lf lg lh b">call</code>方法在子构造函数中调用父构造函数。</p><p id="7b71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，有错误检查来确保我们调用了<code class="fe le lf lg lh b">super</code>，从而防止我们走错方向。否则，代码不会运行。</p><p id="a2d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用旧的构造函数语法，没有办法判断我们是否做错了什么。忘记调用父构造函数不会给我们带来旧语法的任何错误。我们只会得到意想不到的行为。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/a404ef21017d336ec6f2354845d12d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qzdQbbTdSZTpxOZr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">劳拉·德维尔德在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3a9f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="b860" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们的箭头函数只有一个参数，箭头函数签名可能不需要括号。</p><p id="70ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，如果我们的arrow函数有多个参数或者没有参数，那么我们就需要括号。</p><p id="05c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们忘记在子类的构造函数中调用<code class="fe le lf lg lh b">super</code>，我们会得到一个错误，这样我们就不会忘记调用它，因为代码不会运行。</p><p id="c355" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是类语法的一大优点，因为它有内置的错误检查功能。</p></div></div>    
</body>
</html>