<html>
<head>
<title>Implementing the Transactional Outbox Pattern with Debezium in Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Quarkus中用Debezium实现事务发件箱模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-the-transactional-outbox-pattern-with-debezium-in-quarkus-f2680306951?source=collection_archive---------4-----------------------#2020-07-29">https://levelup.gitconnected.com/implementing-the-transactional-outbox-pattern-with-debezium-in-quarkus-f2680306951?source=collection_archive---------4-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/573783dca2f17327d39e2b9270e9fe2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLrVxTIBmUP7T_hZauPPcw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马太·亨利摄于StockSnap</figcaption></figure><p id="7d63" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi la translated">这是Quarkus、Kotlin和Debezium从头开始构建微服务系列的第二部分。</p><p id="7660" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<a class="ae lj" href="https://medium.com/@changeant/building-a-microservice-from-the-ground-up-with-quarkus-kotlin-and-debezium-83ae5c8a8bbc" rel="noopener">第一部分</a>中，我们在Quarkus中构建了一个简单的REST API来保存SMS消息。我们使用testcontainers在docker容器中运行服务，并确定一切按预期运行。</p><p id="f130" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这一部分中，我们将使用事务性发件箱模式在消息被持久化时生成事件。然后，我们可以异步处理消息，最终将SMS消息发送到最终用户的移动设备。</p><h2 id="2115" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kn lt lu lv kr lw lx ly kv lz ma mb mc bi translated">事务发件箱模式</h2><p id="ec37" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi la translated"><span class="l lb lc ld bm le lf lg lh li di">微服务中的一个常见模式是在实体发生变化时生成事件。这使得消费者可以得到任何变化的通知。然而，我们正在处理两个独立的事务:写入数据库和发布到消息代理。为了避免XA事务带来的复杂性，我们可以通过将事件写入发件箱表来实现原子事务，作为保存实体更改的同一事务的一部分。然后，两个持久化都被注册到同一个事务中，我们保证事件已经和实体一起保存到数据库中。</span></p><p id="ffdc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们有两种不同的方法来处理发件箱表中的事件。第一种方法包括轮询发件箱表，并在单独的进程中将条目转发给消息代理。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/eb3acaa3daca76f105e74bb9242600ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*qChoG6ozpVT7iw-VzDGYaA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图表1。轮询发件箱表</figcaption></figure><p id="5fc0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一种轮询方法是使用<a class="ae lj" href="https://microservices.io/patterns/data/transaction-log-tailing.html" rel="noopener ugc nofollow" target="_blank">事务日志跟踪</a>，也称为变更数据捕获(CDC)。在这里，我们可以跟踪数据库事务日志，并寻找新的发件箱条目。我们不轮询发件箱表，事实上，我们在条目创建后就删除它们，这样表就不会无限增长。Debezium连接器跟踪事务日志，并将新条目检索到发件箱表中。使用kafka connect，我们可以将条目转换为消息，并将其发送给kafka代理。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/b66256da4701c9752d53b206f432688d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*ofUlpWSQvFDKGq4rDxgjBw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图表2。跟踪事务日志</figcaption></figure><h2 id="983a" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kn lt lu lv kr lw lx ly kv lz ma mb mc bi translated">Debezium和卡夫卡连接</h2><p id="00f6" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi la translated">支持CDC需要使用Kafka Connect。Kafka Connect是一个构建连接器的框架，用于将数据移入和移出Kafka。Debezium为大多数主要数据库提供了源连接器。在这个项目中，我们将使用PostgreSQL连接器，它直接从WAL日志中读取数据。</p><p id="41a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Postgres需要一些初始设置来使用连接器(参见<a class="ae lj" href="https://debezium.io/documentation/reference/1.2/connectors/postgresql.html" rel="noopener ugc nofollow" target="_blank">文档</a>)。对于这个项目，我们将使用Debezium提供的postgres docker图像。我们还将使用Debezium Kafka连接器，它也可以作为docker图像使用。在Avro中有一个流事件的选项，但是对于这个服务，我们将坚持使用JSON。</p><h2 id="e058" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kn lt lu lv kr lw lx ly kv lz ma mb mc bi translated">在SMS服务中实现事件处理</h2><p id="855f" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">对于项目的这一部分，您可以克隆存储库(如果您在第一部分中没有这样做),并检出分支</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="18e1" class="lk ll iq mp b gy mt mu l mv mw">git clone <a class="ae lj" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:iainporter/sms-service.git<br/>git checkout part_two</span></pre><h2 id="0191" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kn lt lu lv kr lw lx ly kv lz ma mb mc bi translated">添加发件箱表格</h2><p id="d444" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">我们需要添加一个flyway迁移来创建发件箱表和processed_event表(稍后会详细介绍)</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1618" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要将记录插入发件箱表，我们需要实现ExportedEvent接口</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="01c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">消息有效负载被包装在一个事件中，并用事件类型“message_created”进行标记</p><p id="5119" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<a class="ae lj" href="https://docs.jboss.org/weld/reference/latest/en-US/html/events.html" rel="noopener ugc nofollow" target="_blank"> CDI事件</a>我们将它注入到SmsService中，并在创建新的SmsMessage时触发一个事件(第13行)</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="521b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它负责在发件箱表中创建新行。下一步是处理由Debezium连接器发送给kafka的消息。</p><p id="6e71" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Quarkus使用<a class="ae lj" href="https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.2/index.html" rel="noopener ugc nofollow" target="_blank"> SmallRye </a>反应式消息传递，我们可以通过添加依赖关系将它引入到项目中</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="53ee" class="lk ll iq mp b gy mt mu l mv mw">&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-kafka&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="bebd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们配置想要收听的频道，我们将其定义为“sms”</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="1b5e" class="lk ll iq mp b gy mt mu l mv mw">mp.messaging.incoming.sms.connector=smallrye-kafka<br/>mp.messaging.incoming.sms.topic=outbox.event.sms_message<br/>mp.messaging.incoming.sms.bootstrap.servers=kafka:9092<br/>mp.messaging.incoming.sms.group.id=sms-service</span></pre><p id="330c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">默认情况下，主题的名称与通道名称相同，但在这里我们将其覆盖以对应于发件箱事件将被发送到的主题(outbox.event.sms_message ),其中“sms_message”是SmsMessageCreatedEvent中aggregateType的名称。</p><p id="ca6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">消息消费者</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cfd9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通道名(第9行)对应于上面smallrye配置中的设置。我们提取kafka记录的相关部分并调用消息处理程序。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e2ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们所做的就是加载事件引用的相应的SmsMessage，并将其状态设置为DELIVERED(第11行)。在代码的下一次迭代中，我们将实现向提供商发送SMS的路由。但是现在我们有足够的地方来测试消息传递部分的工作。</p><p id="26a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意第4行，我们如何检查具有这个id的事件是否已经被处理，如果是，忽略这个事件。这满足了<a class="ae lj" href="https://www.cloudcomputingpatterns.org/at_least_once_delivery/" rel="noopener ugc nofollow" target="_blank">至少一次</a>交付模式。EventLog将保存eventId，如果它已经在数据库中，将捕获异常并忽略消息。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4401" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将所有这些放在一起，消息流如下所示</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/2636cc2f6e73974ce7b7c61563773dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXtrT8tERAn7OEpHC-DNPQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图表3。发送消息序列图</figcaption></figure><h2 id="dc1f" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kn lt lu lv kr lw lx ly kv lz ma mb mc bi translated">组件测试</h2><p id="2ac6" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">在第一部分中，我们看到了testcontainers在编写组件测试时是多么有用。使用testcontainers可以非常容易地调出所需的docker容器，这样我们就可以测试所有的依赖项是否按照预期的那样一起工作。首先，我们定义想要使用的容器。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="19b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将启动一个已经安装了Debezium插件的postgres容器、一个kafka容器、一个Debezium容器和一个Sms服务容器。一旦debezium容器启动，我们需要注册SMS连接器，它将跟踪事务日志，并将任何新的发件箱记录路由到kafka中已配置的主题。</p><p id="8353" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">连接器的配置</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dd37" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下代码将启动容器，注册sms连接器，然后在执行任何测试之前等待连接器注册</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a5d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在容器正在运行，连接器已经注册，我们可以测试向服务发送消息。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="115e" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kn lt lu lv kr lw lx ly kv lz ma mb mc bi translated">运行服务</h2><p id="7444" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">我们可以使用docker-compose来显示所有内容</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="b296" class="lk ll iq mp b gy mt mu l mv mw">mvn clean install<br/>cd sms-service<br/>docker-compose up -d</span></pre><p id="52c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们需要向Kafka connect注册连接器</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="ba2e" class="lk ll iq mp b gy mt mu l mv mw">curl 'localhost:8083/connectors/' -i -X POST -H "Accept:application/json" \<br/>-H "Content-Type:application/json" \<br/>-d '{"name": "sms-connector", "config": {"connector.class": "io.debezium.connector.postgresql.PostgresConnector", "database.hostname": "postgres-db", "database.port": "5432", "database.user": "postgres", "database.password": "postgres", "database.dbname" : "sms", "database.server.name": "smsdb1", "table.whitelist": "public.outboxevent", "transforms" : "outbox","transforms.outbox.type" : "io.debezium.transforms.outbox.EventRouter", "transforms.OutboxEventRouter.event.key": "aggregate_id", "transforms.outbox.table.fields.additional.placement": "type:header:eventType"}}'</span></pre><p id="f8b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">发送消息</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="8d44" class="lk ll iq mp b gy mt mu l mv mw">curl <a class="ae lj" href="http://localhost:8080/v1/sms/60a17509-4d25-449d-9a21-819f2'http://localhost:8080/v1/sms'" rel="noopener ugc nofollow" target="_blank">'http://localhost:8080/v1/sms'</a> -i -X POST \<br/>   -H 'Content-Type: application/json'  \<br/>   -d '{"text":"Foo Bar!", "fromNumber": "+1234567890", "toNumber": "+1234567891"}'</span></pre><p id="a92a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您应该会得到类似这样的结果</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="da38" class="lk ll iq mp b gy mt mu l mv mw">HTTP/1.1 202 Accepted<br/>Content-Length: 0<br/>Location: <a class="ae lj" href="http://localhost:8080/v1/sms/c75e551a-b11c-4703-bbe7-5c6bb38b001c" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/sms/c75e551a-b11c-4703-bbe7-5c6bb38b001c</a></span></pre><p id="34bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以使用位置头来获取消息细节</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="f61c" class="lk ll iq mp b gy mt mu l mv mw">curl <a class="ae lj" href="http://localhost:8080/v1/sms/c75e551a-b11c-4703-bbe7-5c6bb38b001c" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/sms/c75e551a-b11c-4703-bbe7-5c6bb38b001c</a></span></pre><p id="d826" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果应该与此类似</p><pre class="mj mk ml mm gt mo mp mq mr aw ms bi"><span id="5831" class="lk ll iq mp b gy mt mu l mv mw">{"createdAt":"2020-07-21T09:38:17.372071Z","fromNumber":"+1234567890","id":"c75e551a-b11c-4703-bbe7-5c6bb38b001c","status":"DELIVERED","text":"Foo Bar!","toNumber":"+1234567891","updatedAt":"2020-07-21T09:38:17.743689Z"}</span></pre><p id="e279" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是服务迭代开发的完成阶段。我们现在可以请求发送SMS消息。我们使用消息代理来保证消息传递到下一个处理阶段。目前，除了通过更新状态来表明消息已经被处理之外，我们没有做任何有用的事情。在下一阶段，我们将通过添加路由逻辑将sms消息发送给第三方SMS提供商来完成处理生命周期。</p><p id="5856" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文的代码库可从<a class="ae lj" href="https://github.com/iainporter/sms-service/tree/part_two" rel="noopener ugc nofollow" target="_blank">这里</a>获得</p><p id="9159" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该系列的其他部分包括:</p><ul class=""><li id="cfad" class="na nb iq ke b kf kg kj kk kn nc kr nd kv ne kz nf ng nh ni bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/building-a-microservice-from-the-ground-up-with-quarkus-kotlin-and-debezium-83ae5c8a8bbc">第一部分:构建框架并添加持久性</a></li><li id="5684" class="na nb iq ke b kf nj kj nk kn nl kr nm kv nn kz nf ng nh ni bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/building-a-resilient-microservice-with-quarkus-and-wiremock-de59b2a4fac7">第三部分:连接到第三方API并用Wiremock测试</a></li><li id="4dcc" class="na nb iq ke b kf nj kj nk kn nl kr nm kv nn kz nf ng nh ni bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/securing-a-microservice-in-quarkus-with-openid-connect-505204d1c9a9">第四部分:使用OpenID Connect保护服务</a></li><li id="e4d5" class="na nb iq ke b kf nj kj nk kn nl kr nm kv nn kz nf ng nh ni bi translated"><a class="ae lj" href="https://medium.com/@changeant/running-a-microservice-in-quarkus-on-graalvm-52d6b42a5840" rel="noopener">第五部分:使用GraalVM本机运行</a></li><li id="8fe9" class="na nb iq ke b kf nj kj nk kn nl kr nm kv nn kz nf ng nh ni bi translated"><a class="ae lj" href="https://medium.com/@changeant/containerizing-your-microservice-in-quarkus-with-jib-fae0f62bd57e" rel="noopener">第六部分:用Jib封装你的微服务</a></li><li id="d5b0" class="na nb iq ke b kf nj kj nk kn nl kr nm kv nn kz nf ng nh ni bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/building-a-ci-pipeline-for-a-microservice-in-quarkus-with-circleci-11e9b679423f">第七部分:使用CircleCI为微服务构建CI管道</a></li></ul></div></div>    
</body>
</html>