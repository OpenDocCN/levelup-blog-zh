<html>
<head>
<title>Updating Objects Partially in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中部分更新对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/updating-objects-partially-in-c-2621927d5865?source=collection_archive---------4-----------------------#2022-05-10">https://levelup.gitconnected.com/updating-objects-partially-in-c-2621927d5865?source=collection_archive---------4-----------------------#2022-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1d16770ef70a019903b0fb5a63a9831e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_GTwHoiMayXQi8aK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>拍照</figcaption></figure><p id="bb88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用反射写了自己的Update Partial机制，但是后来发现了JsonPatch。如果您正在使用Web APIs，并且还不知道JsonPatch，那么您必须阅读这篇文章。</p><p id="d02e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对反射和我们如何加速反射感兴趣，我建议你也阅读文章的第一部分，这也是理解部分更新对象的标准化方法的需要的一个很好的开端。</p><h1 id="e58e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">UpdatePartial</h1><p id="a329" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对我来说很明显，部分更新对象并不是某些对象所独有的，而是应该是通用的，这样它就可以被每个对象重用。这就是为什么我选择使用反射——在运行时动态地检索和设置对象的属性值，而不用对属性进行硬编码。但是因为众所周知反射很慢，所以我做了一个快速反射助手，它将一个<em class="me"> PropertyInfo </em>的<em class="me"> GetMethod </em>和<em class="me"> SetMethod </em>转换成一个委托，然后将它存储到一个静态类变量中。这意味着反射仅在第一次运行时较慢，而在下一次运行时几乎与没有反射的更新一样快，因为委托被缓存了。</p><h1 id="2381" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">履行</h1><p id="a481" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面显示的接口用于检索属性的get/set委托。注意，需要模式匹配开关来指定类型，因为在调用方法调用时，泛型类型必须是硬编码的。这也是这种方法的一大缺点，因为每当为某个对象实现<em class="me"> UpdatePartial </em>方法时，它的所有属性类型都必须在模式匹配开关中。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3781" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">静态类快速反射实现UpdatePartial方法，并使用IPropertyDelegateService创建包含所有属性更新的字典。</p><p id="dbfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<em class="me"> PropertyMode </em> (Include，Exclude)用于指定是更新字典中的条目，还是更新除字典中的属性之外的对象的所有属性。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="db6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是<em class="me"> UpdatePartial </em>方法的基础。要实际使用它，需要创建一个<em class="me">IPropertyDelegateService</em>的具体实现。原则上，所有必要的方法都已经在接口中实现，但是如果需要更新的对象具有特殊类型，则必须扩展模式匹配开关，如下所示，以包括类型(在本例中为<em class="me"> CustomClass </em>):</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4e2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在唯一剩下的是一个在静态变量中存储属性委托的类。因为从业务角度来看，这一切都是非常低级的，所以我创建了一个<em class="me"> CustomClassHelper </em>，它作为一个包装器来隐藏混乱的细节。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="d85f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">优点:</h1><ul class=""><li id="e526" class="ml mm iq kf b kg lz kk ma ko mn ks mo kw mp la mq mr ms mt bi translated">相当普通</li><li id="4577" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">几乎与不使用反射一样快</li></ul><h1 id="c10f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">缺点:</h1><ul class=""><li id="f2d9" class="ml mm iq kf b kg lz kk ma ko mn ks mo kw mp la mq mr ms mt bi translated">自定义类型必须扩展</li><li id="ce09" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">嵌套对象不能部分更新</li><li id="bde2" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">复杂的</li></ul><p id="68c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管我为自己能让这个庞然大物正常工作感到非常自豪，但我很快得出结论，有效而复杂的代码并不好，因为我的同事不深入研究就无法理解这个解决方案。到目前为止，对于几乎总是需要扩展的自定义类型模式匹配来说，它不是自解释的，也不是直观的。几个星期后，我收到一个请求，要求部分更新<em class="me"> CustomClass </em>中的对象，老实说，我不知道如何扩展这个东西来完成这个任务。我也不想过多地接触它，因为与此同时，我已经忘记了实现的细节，而我自己，这个东西的创造者，也很难理解它。</p><p id="9937" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很快我发现我必须扔掉它。它根本不可维护，与其花太多时间去适应它，不如寻找一个新的解决方案。这一次，它应该被标准化。一些我不必亲自去做的事。事实上，我很快就找到了有史以来最好的解决方案。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="cc14" class="lb lc iq bd ld le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly bi translated">JsonPatch</h1><p id="68c0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在REST中，PUT和PATCH的关键区别在于，PUT对一个对象进行完整的更新，这意味着一个对象的实例被一个新的实例完全替换。另一方面，补丁只指定了应该更新/添加/删除的对象的几个属性。这听起来和我以前实现的<em class="me"> UpdatePartial </em>非常相似，但是不同之处在于补丁是软件工程领域的一种标准化方法。</p><p id="18e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当通过json以restful方式进行部分更新时，json字符串应该如下所示:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3783867daa5222281604a66a603e7949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/0*jpwTIPZgiH6-ohAc.png"/></div></figure><h1 id="7a7e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">操作:</h1><ul class=""><li id="812f" class="ml mm iq kf b kg lz kk ma ko mn ks mo kw mp la mq mr ms mt bi translated">替换</li><li id="764e" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">增加</li><li id="f31d" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">去除</li><li id="c16a" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">复制</li><li id="d009" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">移动</li></ul><p id="4a77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该路径指定应该更新的属性。它的构建类似于文件路径，也有斜杠，通过斜杠可以指定嵌套对象的属性。</p><p id="22d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，您可以使用此路径替换列表中的第四个元素，如下所示:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/fab0f8e4c184af9ce2c335970fc20c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*_5co6nk07MB-kFcn.png"/></div></figure><p id="94df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，您可以深入嵌套对象，只更新属性，而不更改整个嵌套对象，如下所示:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e7b61e3121a1f0e17a7fc2c6aaf59bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/0*rzPBPRtees9Lgh-d.png"/></div></figure><p id="29ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你看，用PATCH做复杂的事情非常简单，但是你如何构造这些操作呢？自己动手会很乏味，但幸运的是，ASP.Net核心提供了开箱即用的解决方案。</p><h1 id="8ef3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JsonPatchDocument <t/></h1><p id="a5a6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><em class="me"> JsonPatchDocument </em>通过调用自身的方法(Replace、Add、Remove……)并向每个方法传递一个<em class="me">表达式&lt; Func &lt; CustomClass，TProp &gt; &gt; </em>和新值，让您非常方便地构建操作。最后，您可以简单地使用JsonConvert将其序列化为一个json字符串，看起来就像上面的图片之一。我编写了一个名为<em class="me"> Serialize </em>的扩展方法，它将旧的和修改后的<em class="me"> CustomClass </em>作为参数，构建<em class="me"> JsonPatchDocument </em>，并将序列化后的对象作为字符串返回，因为我必须向微服务发送restful补丁请求。这个微服务有一个补丁端点，它接收用于更新实体的<em class="me">JsonPatchDocument&lt;custom class&gt;</em>。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d43e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<em class="me"> UpdatePartial </em>相比，这要简单得多，因为我们不必担心自定义类型和实现助手服务。</p><p id="4323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实际进行部分更新，您可以使用<em class="me"> applyTo </em>方法，该方法获取一个对象并将存储在<em class="me"> JsonPatchDocument </em>中的所有操作应用于该对象。</p><pre class="mf mg mh mi gt no np nq nr aw ns bi"><span id="df80" class="nt lc iq np b gy nu nv l nw nx">patch.applyTo(customClassInstance);</span></pre><h1 id="9dab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">优点:</h1><ul class=""><li id="87f0" class="ml mm iq kf b kg lz kk ma ko mn ks mo kw mp la mq mr ms mt bi translated">简单的</li><li id="18d2" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">标准化的</li><li id="8378" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">一般的</li></ul><h1 id="5421" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">缺点:</h1><ul class=""><li id="1308" class="ml mm iq kf b kg lz kk ma ko mn ks mo kw mp la mq mr ms mt bi translated">没有人</li></ul><h1 id="6b9f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ad75" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过这次旅程，我不仅了解到JsonPatch非常棒，应该更频繁地使用，而且还了解到好的代码简单可靠。</p><p id="49cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从现在开始，每当我觉得自己在写复杂的代码时，我会看到一个危险信号，并寻找一种更简单的方法。大多数时候，你或我遇到的问题并不是唯一的，可能有人已经找到了解决方案，有时社区甚至已经同意将这些解决方案标准化。</p></div></div>    
</body>
</html>