<html>
<head>
<title>Scala journals — Currying: The tale of a code example no one actually ever used</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala journals——Currying:一个没有人真正使用过的代码示例的故事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-currying-the-tale-of-that-one-code-example-no-one-actually-ever-used-d36db58e345b?source=collection_archive---------6-----------------------#2020-08-15">https://levelup.gitconnected.com/scala-journals-currying-the-tale-of-that-one-code-example-no-one-actually-ever-used-d36db58e345b?source=collection_archive---------6-----------------------#2020-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f07ef82abbec0ccc62da370f580cf263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XSeRSTlAWBorw7T2uCBTg.jpeg"/></div></div></figure><p id="76fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，不可避免的是，有一天你会读到一些Scala代码，并且想知道:currying就像以一种过于复杂的方式传递更多的参数，或者我错过了什么？似乎是不必要的和复杂的，所以不可避免的问题来了:<strong class="kd iu"> <em class="kz">你为什么要这样做…？然后，你搜索currying示例，并冒险在线查看字符串concat示例，或者可能是整数加法。您遇到了如下几个例子，迫不及待地想在生产中使用这个新特性。所以……一个没有人真正使用过的代码示例的故事就像下面的片段一样，你在互联网上随处可见:</em></strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3b1f" class="lj lk it lf b gy ll lm l ln lo">def add(a: Int)(b: Int) = a + b<br/>def add4 = add(4) _<br/>add4(10) // 14</span></pre><p id="242c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你问自己<strong class="kd iu">为什么</strong>——很好。让我解释一下，因为这也困扰了我很长时间。</p><h1 id="8b7e" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么是currying？</h1><p id="8f2f" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">对于<strong class="kd iu">现在的</strong>，把奉承想象成在<strong class="kd iu">多个</strong> <strong class="kd iu">组中传递参数给一个函数。</strong></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="297c" class="lj lk it lf b gy ll lm l ln lo">// one group, three arguments, not currying!<br/>def add(one: Int, two: Int, three) = one + two + three </span><span id="a760" class="lj lk it lf b gy mr lm l ln lo">// three groups, one argument each - currying!<br/>def add(one: Int)(two: Int)(three: Int) = one + two + three </span></pre><p id="2eb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们暂时接受这个完全不真实的加法例子，让我们来谈谈函数签名。一旦我们有了一个更大的图景，我们将转移到现实生活中的例子。</p><p id="b155" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">柯里函数中的每个组都是一个函数本身，</strong>因此对于:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3ff1" class="lj lk it lf b gy ll lm l ln lo">def add(one: Int, two: Int)(three: Int) = one + two + three</span></pre><p id="ae81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…签名(*)看起来像这样:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4526" class="lj lk it lf b gy ll lm l ln lo">def add(one: Int, two: Int)(three: Int) = one + two + three<br/><strong class="lf iu">(Int, Int) =&gt; Int =&gt; Int</strong></span></pre><p id="8ff5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着我们可以将其分解为:</p><p id="fc47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数<code class="fe ms mt mu lf b">add</code>是一个需要两个函数来运行的函数:</p><ul class=""><li id="bd83" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">一个有签名的<code class="fe ms mt mu lf b">(Int, Int) =&gt; Int</code></li><li id="e34a" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">一个有签名的<code class="fe ms mt mu lf b">Int =&gt; Int</code></li></ul><p id="3b72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要为<code class="fe ms mt mu lf b">add</code>函数提供所有参数组来评估结果吗？当然，<strong class="kd iu">是的:</strong> <code class="fe ms mt mu lf b">add</code>不然就不行了。</p><p id="facd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是…我们需要一次提供所有的参数组吗？<strong class="kd iu">不！</strong></p><h1 id="5c40" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">分步解决</h1><p id="5774" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">所以我们不必一次提供所有组。从逻辑上来说，你应该让函数更好地重用它们，分解它们，简化它们。</p><p id="44f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那会是什么样子呢？让我们看看:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="327e" class="lj lk it lf b gy ll lm l ln lo">def add(one: Int)(two: Int) = one + two<br/><strong class="lf iu">compiler output</strong>:<br/>add: (one: Int)(two: Int)Int</span><span id="2095" class="lj lk it lf b gy mr lm l ln lo">def partiallyApplied = add(1) _ // passing only the first arg group<br/><strong class="lf iu">compiler output</strong>:<br/>partiallyApplied: Int =&gt; Int // will require the second arg group</span><span id="cab2" class="lj lk it lf b gy mr lm l ln lo">val fullyAppliedNow = partiallyApplied(5) // passing 2nd arg group<br/><strong class="lf iu">compiler output</strong>:<br/>6</span></pre><p id="68ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe ms mt mu lf b">add(1) _</code>中，快速注意上面的<strong class="kd iu">下划线</strong>。你可以把它想成“<strong class="kd iu">剩下的我以后给你</strong>”。编译器对此没有意见，所以它返回满足参数组初始列表所需的任何内容。</p><p id="b6fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是关于下划线的更多细节:在Scala中有函数和方法。作为一门完全支持函数式编程的语言，Scala中的函数是对象。Scala编译器允许在方法(<code class="fe ms mt mu lf b">def</code>)和对象(<code class="fe ms mt mu lf b">val</code>)之间转换。这叫做<strong class="kd iu">埃塔扩张。所以当你做_的时候，你把一个方法转换成一个函数，你<strong class="kd iu"> eta expend </strong>。</strong></p><h1 id="72bd" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">让我们谈谈现实生活</h1><p id="00e2" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">这一切都有道理，但正如没人用过的代码告诉我们的那样:没人会真的用currying做加法。事实上……奉承实际上并没有用那么多。有几个原因，但我觉得最主要的原因是它使得代码库很难推理。我可以看到在一个更加函数化的纯粹主义环境中curry会被更多的使用，但是到目前为止我只是偶尔看到它。</p><p id="eb9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经验法则是——如果你能创作它，你可能就能创作它。编译器是极限。但是请记住，谄媚会影响代码的可读性，如果过分，弊大于利。</p><p id="479e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有几个现实生活中的例子:</p><ul class=""><li id="7eb0" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">所有的<strong class="kd iu">隐式参数</strong>都需要修改。在使用期货的<a class="ae nj" href="https://github.com/leqoo/slick-lab2/blob/5e7b9b2aa2333e497a3c924f790879d29929e931/application/src/main/scala/Lab2_0.scala#L14" rel="noopener ugc nofollow" target="_blank">代码库中，你会经常看到这样的内容:</a></li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="feac" class="lj lk it lf b gy ll lm l ln lo">def update(name: String)(implicit ec: ExecutionContext) </span></pre><ul class=""><li id="91fa" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">修正<strong class="kd iu">棘手的争论</strong>。如果你需要在所有的函数中使用它，你可以使用它。一个很好的例子就是跟踪id，它允许我们在日志中关联请求。</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="be16" class="lj lk it lf b gy ll lm l ln lo">def handleRequest(tracingId: TracingId)(request: Request) = {<br/> handleWithTracingId(request, tracingId)<br/>}</span><span id="0721" class="lj lk it lf b gy mr lm l ln lo">def handleGetRequest  = handleRequest(generateRandomTraceingId) _</span><span id="b9ef" class="lj lk it lf b gy mr lm l ln lo">handleGetRequest(request)</span></pre><ul class=""><li id="2327" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">与上述相关，<strong class="kd iu">数据库连接</strong>也可能是一个棘手的问题..甚至<strong class="kd iu">配置</strong>！</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="aea5" class="lj lk it lf b gy ll lm l ln lo">def queryDbUsingConn(dbConn: DbConnection)(query: Query) = {<br/> dbConn.query(query)<br/>}</span><span id="bff8" class="lj lk it lf b gy mr lm l ln lo">val dbConn = new DatabaseConnection</span><span id="2e91" class="lj lk it lf b gy mr lm l ln lo">def queryDb = queryDbUsingConn(dbConn) _</span><span id="f5d8" class="lj lk it lf b gy mr lm l ln lo">queryDb(query) // no need to worry about db connection anymore while passing queries!</span></pre><ul class=""><li id="05ae" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">还有一个更复杂的例子——在更高的抽象层次上组合功能，这些功能依赖于用户在传入请求中提供的内容，而根本不需要引用传入请求。如果您curry，您将能够传递函数，而不会因为不属于它的细节而污染代码:</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="654a" class="lj lk it lf b gy ll lm l ln lo">case class IncomingRequest(name: String, settings: UserSettings)<br/>// above case class represents the incoming http request with some user details that we will know only once the request is in</span><span id="6a77" class="lj lk it lf b gy mr lm l ln lo">def update(service: SettingsService)(settings: UserSettings) = {<br/> val darkTheme = settings.isDarkTheme // data from http request<br/> service.saveDarkTheme <br/>}</span><span id="4cf5" class="lj lk it lf b gy mr lm l ln lo">// imagine below code is on a high level of abstraction, e.g. in a module trait. We don't want to pollute it with request handling related code so we just say "the rest coming later" and using _:</span><span id="ac65" class="lj lk it lf b gy mr lm l ln lo">val settingsService = new SettingsService<br/>def updateSettings = update(settingsService) _ </span><span id="fe9f" class="lj lk it lf b gy mr lm l ln lo">// updateSettings is now ready to be passed down to a responsible handler and to be filled in with the settings we will get from the user request once it comes in. Imagine in the below code we are in the request handling logics and have IncomingRequest already in scope.</span><span id="27f3" class="lj lk it lf b gy mr lm l ln lo">def sendNewSettingToDatabase = updateSettings(incomingReq.settings)</span></pre><h1 id="ba5f" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="a6b4" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">Currying是一个伟大的工具，可以减轻程序员的认知负担。它允许您在进行过程中，或者当参数组出现/变得可用时，向初始函数添加参数组。把我们不关心的细节抛在脑后，只关注对给定的类有意义的东西，这很好。作曲，作曲，作曲！如果使用太多，会使代码混乱，很难推理，所以要小心使用！我个人的观点是，9/10的情况下，你可以不去做。</p><p id="174c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">示例用法:</p><ul class=""><li id="4940" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">棘手的参数:数据库连接、配置、流id</li><li id="e9b2" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">隐式参数</li><li id="66d5" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">“推迟”传递尚不可用的参数(例如，传入http请求中的数据)</li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="7e55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(ETA扩展后的签名</p></div></div>    
</body>
</html>