<html>
<head>
<title>TypeScript — Validation with AJV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿—用AJV验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-validation-with-ajv-1b70a76dd678?source=collection_archive---------7-----------------------#2020-02-04">https://levelup.gitconnected.com/typescript-validation-with-ajv-1b70a76dd678?source=collection_archive---------7-----------------------#2020-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0476361de81304214a3a9dbbd425ee14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rl9fz0XU2IQ-k1IL"/></div></div></figure><p id="5ed2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们都遇到过需要验证用户提交的数据的情况，但是最简单、最可靠、最省事的验证方法是什么呢？</p><p id="6cf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是AJV(另一个JSON验证器)出现的地方！AJV可以使用JSON模式来验证对象，这也使它变得非常简单。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6fdd" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">有人说AJV吗？</h1><p id="dcd1" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">让我们创建一个简单的服务，该服务具有一个注入的AJV实例，该实例具有验证一些用户数据的功能。</p><p id="2770" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实例化AJV相对简单。构造函数接受一个可选的配置，出于这个简短指南的目的，我们将省略它。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e7e6" class="mp le iq ml b gy mq mr l ms mt">import * as Ajv from 'ajv'</span><span id="b786" class="mp le iq ml b gy mu mr l ms mt">const ajv = new Ajv()</span></pre><p id="4c05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想将它注入到您正在创建的自定义验证器类中，您可以使用<code class="fe mv mw mx ml b">Ajv</code>接口在构造函数中键入属性。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="42cb" class="mp le iq ml b gy mq mr l ms mt">import { Ajv } from 'ajv'</span><span id="983a" class="mp le iq ml b gy mu mr l ms mt">class Foo {<br/>  constructor(protected ajv: Ajv) {<br/>  }<br/>}</span></pre><p id="e36d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们要导入我们想要使用的模式，我们可以非常简单地导入JSON对象。在本文的后面，我们将探索一个简单的JSON模式。确保在您的<code class="fe mv mw mx ml b">tsconfig.json</code>中您首先启用了以下属性<code class="fe mv mw mx ml b">"resolveJsonModule": true</code>。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="5bfd" class="mp le iq ml b gy mq mr l ms mt">import * as requestSchema from '../foo/bar/requestSchema.json'</span></pre><p id="4375" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们准备创建一个基本函数，它将接受用户提交的数据和模式作为参数，并根据给定的模式验证数据。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3916" class="mp le iq ml b gy mq mr l ms mt">public validate(schema, data) {<br/>  return this.ajv.validate(schema, data)<br/>}</span></pre><p id="239c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AJV上公开的<code class="fe mv mw mx ml b">validate()</code>函数将返回一个布尔值，表明根据给定的模式，数据是否有效。如果数据验证失败，您可以调用公开的函数<code class="fe mv mw mx ml b">errorsText()</code>来获取验证数据时发生的错误的相关消息。</p><p id="9362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个基本的实现，当失败的验证发生时，我们如何处理它。如你所见，我们注入的<code class="fe mv mw mx ml b">ajv</code>对象上有错误。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="714c" class="mp le iq ml b gy mq mr l ms mt">public validate(schema, data) {<br/>  const isValid = this.ajv.validate(schema, data)</span><span id="45a8" class="mp le iq ml b gy mu mr l ms mt">  if (!isValid) {<br/>    const errorMessages = this.ajv.errorsText()<br/>    throw new <strong class="ml ir"><em class="my">Error</em></strong>(`Validation Error. ${errorMessages}`)<br/>  }</span><span id="4111" class="mp le iq ml b gy mu mr l ms mt">  return data<br/>}</span></pre><p id="12b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，公开的函数<code class="fe mv mw mx ml b">errorsText()</code>返回一个字符串，错误以逗号分隔。就我个人而言，我会创建一个自定义的命名错误，它接受错误消息作为参数，并在这里抛出命名错误，而不是一般错误，但这只是我的想法。</p><p id="d009" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:你也可以访问<code class="fe mv mw mx ml b">ajv</code>对象的<code class="fe mv mw mx ml b">errors</code>属性，它是一个错误对象的数组，包含了更多关于失败验证的信息。如果你愿意，你可以尝试一下。</p><h1 id="04ce" class="ld le iq bd lf lg mz li lj lk na lm ln lo nb lq lr ls nc lu lv lw nd ly lz ma bi translated"><strong class="ak">稍微高级一点的</strong></h1><p id="6245" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">让我们假设我们可能需要多次重用这个函数，并且我们希望返回一个特定的类型，那么我们如何轻松地完成这个任务呢？</p><p id="bc52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个字:<strong class="ka ir"> <em class="my">仿制药</em> </strong>！</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ba01" class="mp le iq ml b gy mq mr l ms mt">public validate&lt;T&gt;(schema: object, data: T): T {<br/>  const isValid = this.ajv.validate(schema, data)<br/><br/>  if (!isValid) {<br/>    const errorMessages = this.ajv.errorsText()<br/>    throw new <strong class="ml ir"><em class="my">Error</em></strong>(`Validation Error. ${errorMessages}`)<br/>  }<br/><br/>  return data<br/>}</span></pre><p id="8194" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以简单地允许<code class="fe mv mw mx ml b">T</code>的类型在这里被用作类型定义。该函数将返回输入的相同数据或抛出一个错误(在这种情况下，返回类型被认为是<code class="fe mv mw mx ml b">never</code>)。</p><p id="3fa9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终调用和利用这个函数变得非常容易。调用函数，其中<code class="fe mv mw mx ml b">SOME_TYPE</code>是我们期望用户数据符合的对象的类型定义。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="802a" class="mp le iq ml b gy mq mr l ms mt">import * as schema from '../some/schema.json'<br/>import * as userData from '../some/user/data.json'<br/><br/>const ajv = new Ajv()<br/>const foo = new Foo(ajv)<br/><br/>const validData: SOME_TYPE = foo.validate&lt;SOME_TYPE&gt;(schema, userData)</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/697d62a7542954c6333e2480c74e1536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FWvHfOwzcIQtKCTV"/></div></div></figure><h1 id="5fdb" class="ld le iq bd lf lg mz li lj lk na lm ln lo nb lq lr ls nc lu lv lw nd ly lz ma bi translated">你觉得这些模式怎么样？</h1><p id="2f1a" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">现在让我们进入事物的模式方面！考虑下面这个非常简单的对象，它包含一些我们可能需要的用户数据。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e8e2" class="mp le iq ml b gy mq mr l ms mt">{<br/>  "name": "John",<br/>  "age": 43,<br/>  "gender": "male",<br/>  "phoneNumber": "0728903254",<br/>  "internationalCode": "+27"<br/>}</span></pre><p id="6e73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，有一些关于一个叫约翰的绅士的简单数据。</p><p id="ee6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们假设传入的<code class="fe mv mw mx ml b">name</code>肯定应该是字符串。JSON模式如何定义这一点？</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a15f" class="mp le iq ml b gy mq mr l ms mt">{<br/>  "name": {<br/>    "$id": "#/properties/name",<br/>    "type": "string"<br/>  }<br/>}</span></pre><p id="6148" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">毫不费力且相对简洁。同样，如果我们假设提供的年龄也是一个数字，我们可以将类型定义为<code class="fe mv mw mx ml b">integer</code>。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d1b5" class="mp le iq ml b gy mq mr l ms mt">{<br/>  "age": {<br/>    "$id": "#/properties/age",<br/>    "type": "integer"<br/>  }<br/>}</span></pre><p id="cebc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，但是如果我们需要验证数据是否符合比基本类型更具体的模式呢？</p><p id="7e91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看上面的对象中的国际拨号代码或<code class="fe mv mw mx ml b">internationalCode</code>。</p><p id="1ffa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nf" href="https://www.internationalcitizens.com/international-calling-codes/" rel="noopener ugc nofollow" target="_blank">你可以在这里阅读更多关于国际拨号码的信息← </a></p><p id="6fa6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个属性，我们可能想要包含一些更加复杂的验证需求。也就是说，我们应该检查代码前面是否有一个<code class="fe mv mw mx ml b">+</code>,并且代码是一个1到4位数的数字。不要烦恼！模式已经覆盖了你！</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8efa" class="mp le iq ml b gy mq mr l ms mt">{<br/>  "internationalCode": {<br/>    "$id": "#/properties/internationalCode",<br/>    "type": "string",<br/>    "pattern": "^\\+[0-9]{1,4}$"<br/>  }<br/>}</span></pre><p id="73c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到，我们现在正在确保传入的请求符合指定的模式。有用！</p><p id="e558" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了便于练习，我们假设传入的请求可能只符合两种有效的性别，即男性和女性。我们可以引入一个枚举列表作为验证需求的一部分。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7252" class="mp le iq ml b gy mq mr l ms mt">{<br/>  "gender": {<br/>    "$id": "#/properties/gender",<br/>    "type": "string",<br/>    "enum": [<br/>      "male",<br/>      "female"<br/>    ]<br/>  }<br/>}</span></pre><p id="835f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的数据突然被更加彻底地验证，不仅验证了遗产的存在，还验证了遗产的内容！</p><p id="5cce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想让属性成为可选的或必需的，我们该怎么做呢？</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="fef9" class="mp le iq ml b gy mq mr l ms mt">{<br/>  "required": [<br/>    "name"<br/>  ]<br/>}</span></pre><p id="abf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<code class="fe mv mw mx ml b">name</code>属性将是必需的，其余的属性是可选的。如果<code class="fe mv mw mx ml b">name</code>属性不存在，验证器将返回一个错误消息，指出这个属性是必需的。</p><p id="b6b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在将所有这些片段组合成一个有效的模式，它实际上会是什么样子呢？</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="69ec" class="mp le iq ml b gy mq mr l ms mt">{<br/>  "required": [<br/>    "name"<br/>  ],<br/>  "properties": {<br/>    "name": {<br/>      "$id": "#/properties/name",<br/>      "type": "string"<br/>    },<br/>    "age": {<br/>      "$id": "#/properties/age",<br/>      "type": "integer"<br/>    },<br/>    "gender": {<br/>      "$id": "#/properties/gender",<br/>      "type": "string",<br/>      "enum": [<br/>        "male",<br/>        "female"<br/>      ]<br/>    },<br/>    "phoneNumber": {<br/>      "$id": "#/properties/phoneNumber",<br/>      "type": "string"<br/>    },<br/>    "internationalCode": {<br/>      "$id": "#/properties/internationalCode",<br/>      "type": "string",<br/>      "pattern": "^\\+[0-9]{1,3}$"<br/>    }<br/>  },<br/>  "$id": "http://example.org/root.json#",<br/>  "type": "object",<br/>  "definitions": {},<br/>  "$schema": "http://json-schema.org/draft-07/schema#"<br/>}</span></pre><p id="beb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">验证用户输入非常重要。AJV和JSON模式使得实现非常有效和简单的验证机制变得相当容易。我强烈推荐使用AJV。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/120f91c031cdfb228bb302fb41a5a45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XyHBqoIGpho9cxwG"/></div></div></figure><h1 id="0f14" class="ld le iq bd lf lg mz li lj lk na lm ln lo nb lq lr ls nc lu lv lw nd ly lz ma bi translated">有用的工具？</h1><p id="4de9" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">您可能认为创建一个模式可能会很棘手并且很乏味…这是错误的。这非常简单，几乎没有任何不便。有一个在线工具允许你输入一个普通的JSON对象，它会自动为你生成一个模式来验证这个对象。然后你可以随意调整它。</p><p id="d7d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，您可能不希望所有属性都是必需的。有些属性可能需要符合某种模式，甚至是枚举列表的一部分。</p><p id="628d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nf" href="https://techbrij.com/brijpad/#json" rel="noopener ugc nofollow" target="_blank"> BrijPad — JSON模式生成器</a> <br/> <a class="ae nf" href="https://www.liquid-technologies.com/online-json-to-schema-converter" rel="noopener ugc nofollow" target="_blank">免费在线JSON到JSON模式转换器</a></p><p id="7487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nf" href="https://json-schema.org/specification.html" rel="noopener ugc nofollow" target="_blank"> JSON模式</a> <br/> <a class="ae nf" href="https://code.tutsplus.com/tutorials/validating-data-with-json-schema-part-1--cms-25343" rel="noopener ugc nofollow" target="_blank">模式示例</a></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="24bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢你阅读这篇文章，我希望你学到了一些新的东西。如果你有任何意见，请随意写在下面的评论区！</p><p id="da7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再见了。</p></div></div>    
</body>
</html>