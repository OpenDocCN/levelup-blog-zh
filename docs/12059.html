<html>
<head>
<title>How Experienced Programmers Talk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有经验的程序员如何说话</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-experienced-programmers-talk-7e097b8516e1?source=collection_archive---------4-----------------------#2022-05-11">https://levelup.gitconnected.com/how-experienced-programmers-talk-7e097b8516e1?source=collection_archive---------4-----------------------#2022-05-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/bf056837c37dc5dbd2d2d84fdd40cee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lEgAepqMU70WfWg-"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated"><a class="ae kg" href="https://unsplash.com/@kobuagency?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> KOBU机构</a>在<a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ac70" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">昨天，我写了一篇关于<a class="ae kg" rel="noopener ugc nofollow" target="_blank" href="/how-programmers-should-communicate-4738fcec5ab8">程序员应该如何交流的高层次概述。</a></p><p id="70d8" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这方面，我设计了一个简单的1-2-3计划，关于如何做技术和面试演示。</p><p id="8aba" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">今天，我将详细介绍，并定义编程通信的最基本构件。</p><p id="ed36" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">因为细节是魔鬼所在。</p><h1 id="0bdd" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么这是必要的？</h1><p id="8fd9" class="pw-post-body-paragraph kh ki iu kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le in bi translated">我通过艰难的方式认识到这一点。</p><p id="92b9" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我职业生涯的早期，我的演讲充满了技术术语。如果我想描述一个简单的阶级关系，我会这样继续下去:</p><blockquote class="mi mj mk"><p id="9350" class="kh ki ml kj b kk kl km kn ko kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld le in bi translated">类A有两个方法:getConfiguration()和postMessage()。使用getConfiguration()，类B首先获得配置。然后它调用postMessage()，后者接受一个配置对象作为参数。</p></blockquote><p id="ee30" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是在我们两周一次的状态会议期间！</p><p id="2fb2" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">每个人都打哈欠。我老板以为我是实习生。实际上，我已经相当资深了，但是很少和真正的程序员一起参与协作设计。</p><p id="34fd" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我的任务主要包括从客户那里获取规格、设计功能和交付，没有中间阶段的协作、问答或白板。</p><p id="c3c5" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我很少交换任何重要的反馈。即使我这么做了，也是以电子邮件的形式，没有人在场对我怒目而视或纠正我的咆哮。</p><p id="0bb0" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是当我开始看到我的沟通中的差距时，我决定改进。下面是我学到的要点，你也可以从中受益。</p><h1 id="fdfa" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">#1:创造:</h1><p id="71ad" class="pw-post-body-paragraph kh ki iu kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le in bi translated">如果A类用除自身以外的部分/全部参数创建B类，你可以说A创建/定义并使用B。</p><p id="8bf5" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在现实世界中，它可能是以下内容的某种变体:</p><ul class=""><li id="4117" class="mp mq iu kj b kk kl ko kp ks mr kw ms la mt le mu mv mw mx bi translated">API客户端<strong class="kj iv">在打开HTTP会话之前创建一个配置对象</strong></li><li id="e150" class="mp mq iu kj b kk my ko mz ks na kw nb la nc le mu mv mw mx bi translated">支付对象<strong class="kj iv">在发起支付网关api调用之前创建支付方法(例如PayPal/visa)对象</strong></li><li id="d5e8" class="mp mq iu kj b kk my ko mz ks na kw nb la nc le mu mv mw mx bi translated">类工厂在将环境对象注入视图-模型层次结构之前创建它</li></ul><p id="73a4" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这内在地暗示了造物主A类也要对B类的毁灭负责。</p><p id="ca41" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">最流行的用法是使用名称<strong class="kj iv"> Factory ( </strong>上面的第三个例子<strong class="kj iv"> ) </strong>，但是你也可以使用其他的名称，这取决于你的项目。</p><h1 id="3641" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">#2:转换器/串行器/解串器:</h1><p id="7bc0" class="pw-post-body-paragraph kh ki iu kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le in bi translated">这些术语一般用于描述负责在业务对象和普通数据之间进行转换的实用程序类。它们大多是一些开源转换库的一部分。</p><blockquote class="nd"><p id="af5c" class="ne nf iu bd ng nh ni nj nk nl nm le dk translated">抽象减少了讨论中的技术术语密度，从而使团队的其他成员能够忍受</p></blockquote><p id="0571" class="pw-post-body-paragraph kh ki iu kj b kk nn km kn ko no kq kr ks np ku kv kw nq ky kz la nr lc ld le in bi translated">在这种情况下，你也可以用他们的真名来称呼他们。然而，当涉及到非程序员时，这样做可能会增加团队沟通的复杂性。</p><h2 id="e463" class="ns lg iu bd lh nt nu dn ll nv nw dp lp ks nx ny lt kw nz oa lx la ob oc mb od bi translated">示例:</h2><p id="c10c" class="pw-post-body-paragraph kh ki iu kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le in bi translated">您可以拥有一个带有格式参数(JSON/XML)的转换器类。它将字节数组数据转换成所需的业务对象，反之亦然。</p><p id="7277" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你如何描述它的工作？类似于:</p><ul class=""><li id="0bef" class="mp mq iu kj b kk kl ko kp ks mr kw ms la mt le mu mv mw mx bi translated">转换器<strong class="kj iv">解析</strong>JSON/XML数据(以产生业务对象)。</li><li id="cb3a" class="mp mq iu kj b kk my ko mz ks na kw nb la nc le mu mv mw mx bi translated">转换器<strong class="kj iv">产生一个流/序列化</strong>(转换成XML/JSON)</li></ul><p id="8c51" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为什么我们将转换器类称为<strong class="kj iv">转换器</strong>，而不是实际的类名(JSONConvertor)？因为这种抽象减少了讨论中的技术术语密度，从而使团队的其他成员，尤其是业务人员能够忍受。</p><h1 id="f5b7" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">#3:授权:</h1><p id="c3fb" class="pw-post-body-paragraph kh ki iu kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le in bi translated">当一个A类的对象被传递给B类供B类代码使用时，你可以说B委托给了A。</p><p id="699a" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在现实世界中，它可能是以下内容的某种变体:</p><ul class=""><li id="352e" class="mp mq iu kj b kk kl ko kp ks mr kw ms la mt le mu mv mw mx bi translated">视图/屏幕<strong class="kj iv">将UI事件委托给控制器对象。</strong></li><li id="83b8" class="mp mq iu kj b kk my ko mz ks na kw nb la nc le mu mv mw mx bi translated">每次收到订单时，主业务对象<strong class="kj iv">将委托给子业务对象</strong></li><li id="a891" class="mp mq iu kj b kk my ko mz ks na kw nb la nc le mu mv mw mx bi translated">每次检测到更改时，后台进程都会委托给数据库读取器和写入器</li></ul><p id="6604" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果委托是异步的，你想描述一个回调，你也可以说B在特定的点唤醒A。例如，当API调用返回错误时，URL加载器会唤醒视图模型类。</p><h1 id="268e" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">#4:缓存:</h1><p id="67ec" class="pw-post-body-paragraph kh ki iu kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le in bi translated">在我描述的所有案例中，这是最不常见的一类。</p><blockquote class="nd"><p id="9c63" class="ne nf iu bd ng nh ni nj nk nl nm le dk translated">大多数缓存器被错误地标识为实用程序类。</p></blockquote><p id="a584" class="pw-post-body-paragraph kh ki iu kj b kk nn km kn ko no kq kr ks np ku kv kw nq ky kz la nr lc ld le in bi translated">在大多数不负责任地进行类设计的代码库中，有一个症状非常普遍:它们都缓存(通常是不必要的)数据。</p><p id="aab7" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">因此，大多数这样的类除了在屏幕、模块或用户会话之间缓存数据之外没有其他任务。</p><p id="0a42" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我过去的大部分代码库中，我都是以一种非常随意的方式来描述它们，比如:</p><pre class="oe of og oh gu oi oj ok ol aw om bi"><span id="426c" class="ns lg iu oj b gz on oo l op oq">PaymentScreen gives data to the <strong class="oj iv">PaymentModule</strong> class, which stores the reference to the payment, and later hands it over to the OrderScreen class.</span></pre><p id="d45c" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">结果呢？每次提到<strong class="kj iv"> PaymentModule </strong>时，我的团队都觉得碰壁了。它需要一个更好的替代品。类似于:</p><pre class="oe of og oh gu oi oj ok ol aw om bi"><span id="c12f" class="ns lg iu oj b gz on oo l op oq">Payment screen data is cached until user goes the Order screen.</span></pre><p id="da71" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是为什么我们需要真实的类名来使讨论复杂化？</p><p id="e6ea" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">大多数编码人员将这样的类称为实用类，以淡化它们的重要性。</p><p id="b6bf" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是，最好尽早识别它们，并将它们标记为<strong class="kj iv">缓存器</strong>。更好的方法是，重构并将它们重命名为缓存器。</p><p id="f145" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这种方法有两个优点:</p><ul class=""><li id="b354" class="mp mq iu kj b kk kl ko kp ks mr kw ms la mt le mu mv mw mx bi translated">它宣布了他们的目的和在类设计中的位置(对团队中的新人非常有用)</li><li id="96d7" class="mp mq iu kj b kk my ko mz ks na kw nb la nc le mu mv mw mx bi translated">这迫使人们重新思考软件内存布局。我们将所有数据存储在哪里，为什么要这样做？我们这样做是多余的吗？反过来说，我们是否过早地使缓存失效，迫使API进行早期重取？</li></ul><h1 id="4c4b" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论:</h1><blockquote class="nd"><p id="8c6f" class="ne nf iu bd ng nh ni nj nk nl nm le dk translated">足够抽象的交流是走向技术领先的第一步。</p></blockquote><p id="05d1" class="pw-post-body-paragraph kh ki iu kj b kk nn km kn ko no kq kr ks np ku kv kw nq ky kz la nr lc ld le in bi translated">我刚才描述的大致类型只是一个开始。有了设计模式的经验和实践，您也可以提出自己的交流模式。</p><p id="90fb" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">要记住的关键是在你想要的/真实的代码设计之上添加抽象。</p><p id="5397" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">程序员抽象技术细节的能力反映了他/她的经验。</p><p id="40f2" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">通过不断验证和排练你与团队的理想语言交流，你不仅可以展示你的专业知识，还可以让其他人利用你的工作。</p><p id="dcd0" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">足够抽象的交流是走向技术领导的第一步。</p></div></div>    
</body>
</html>