<html>
<head>
<title>Design Patterns: Command Pattern in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:TypeScript中的命令模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-command-pattern-in-typescript-10b3162e3bee?source=collection_archive---------0-----------------------#2022-11-23">https://levelup.gitconnected.com/design-patterns-command-pattern-in-typescript-10b3162e3bee?source=collection_archive---------0-----------------------#2022-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将呼叫方和接收方解耦，消除不同接收方之间的差异。允许您轻松添加不同的命令来添加不同的功能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f022ba05d7ebc8eab1f044d81cf2484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*npcAC4GVJ0NqyLiQ"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">汉娜·乔舒亚在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎来到TypeScript 系列的<strong class="lb iu">设计模式，该系列介绍了一些使用TypeScript进行web开发时有用的设计模式。</strong></p><p id="bd39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前的文章如下:</p><ul class=""><li id="e7b6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-visitor-pattern-in-typescript-b80bd7cba155">打字稿中的访问者模式</a></li><li id="e4a5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.plainenglish.io/design-patterns-strategy-pattern-in-typescript-54eda9b40f09" rel="noopener ugc nofollow" target="_blank">打字稿中的策略模式</a></li><li id="474a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/p/e98ec08a9c14" rel="noopener">TypeScript中的单例模式</a></li><li id="870c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/design-patterns-builder-pattern-in-typescript-2defc304954a">类型脚本中的构建器模式</a></li><li id="c63a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.plainenglish.io/design-patterns-template-method-pattern-in-typescript-ce0c8b158985" rel="noopener ugc nofollow" target="_blank">打字稿中的模板方法模式</a></li><li id="ccb6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.plainenglish.io/design-patterns-chain-of-responsibility-pattern-in-typescript-dba6bdffe456" rel="noopener ugc nofollow" target="_blank">打字稿中的责任链模式</a></li></ul><div class="mj mk gp gr ml mm"><a href="https://medium.com/frontend-canteen/9-design-patterns-every-engineer-should-know-f2423d36d468" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">每个工程师都应该知道的9种设计模式</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">掌握这9种设计模式，写出更好的代码</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><p id="55b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计模式对于web开发人员来说非常重要，通过掌握它们我们可以写出更好的代码。在本文中，我将使用<strong class="lb iu"> TypeScript </strong>来介绍<strong class="lb iu">命令模式。</strong></p><p id="30a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS和macOS上，内置了<strong class="lb iu">快捷方式</strong>应用。有了这个程序，用户可以快速执行一个或多个任务。例如，快速发送消息、翻译文本、缩短URL和下载文件等任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/22da34aa9c67faa2cb28d3a1513b6f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HlQB_LegiLVoMDda1ywRbA.png"/></div></div></figure><p id="7dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们实现一个类似的应用程序。在下面的代码中，我们定义了一个<code class="fe nc nd ne nf b">Shortcuts</code>类，其中创建了<code class="fe nc nd ne nf b">openUrl</code>、<code class="fe nc nd ne nf b">shortenUrl</code>、<code class="fe nc nd ne nf b">sendMessage</code>等5个成员方法。</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="01e0" class="nk nl it nf b be nm nn l no np">class Shortcuts {<br/>  openUrl(url: string) {<br/>    console.log(`Open url: ${url}`);<br/>  }<br/>  shortenUrl(url: string) {<br/>    console.log(`Shorten url: ${url}`);<br/>  }<br/>  sendMessage(msg: string) {<br/>    console.log(`Send message: ${msg}`);<br/>  }<br/>  translateText(originText: string) {<br/>    console.log(`Translate text: ${originText}`);<br/>  }<br/>  downloadFile(fileUrl: string) {<br/>    console.log(`Download file: ${fileUrl}`);<br/>  }<br/>}</span></pre><p id="9590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nc nd ne nf b">Shortcuts</code>类，我们定义了一个<code class="fe nc nd ne nf b">UIEventHandler</code>类，它包含一个用于处理用户行为事件的<code class="fe nc nd ne nf b">handleAction</code>成员方法。</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="0495" class="nk nl it nf b be nm nn l no np">class UIEventHandler {<br/>  constructor(public shortcuts: Shortcuts) {}<br/><br/>  handleAction(action: ShortcutsMethods, arg: string) {<br/>    this.shortcuts[action](arg);<br/>  }<br/>}<br/><br/>// "openUrl" | "shortenUrl" | "sendMessage" | "translateText" | "downloadFile"<br/>type ShortcutsMethods = Methods&lt;Shortcuts&gt;;<br/><br/>type Methods&lt;T&gt; = {<br/>  [P in keyof T]: T[P] extends (...args: any) =&gt; void ? P : never;<br/>}[keyof T];</span></pre><p id="ac0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">handleAction</code>方法接收<code class="fe nc nd ne nf b">action</code>和<code class="fe nc nd ne nf b">arg</code> 2参数。<code class="fe nc nd ne nf b">action</code>参数的类型为<code class="fe nc nd ne nf b">ShortcutsMethods</code>，通过<code class="fe nc nd ne nf b">Methods</code>工具类型生成。此实用工具类型在内部使用TypeScript映射类型。如果您想了解更多关于映射类型的知识，我推荐您阅读这篇文章。</p><div class="mj mk gp gr ml mm"><a href="https://javascript.plainenglish.io/using-typescript-mapped-types-like-a-pro-be10aef5511a" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">像专业人员一样使用TypeScript映射类型</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">映射类型—用动画解释。掌握TypeScript映射类型并理解TypeScript的内置…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mv l"><div class="nq l mx my mz mv na ks mm"/></div></div></a></div><p id="ebcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe nc nd ne nf b">UIEventHandler</code>类，我们可以通过以下方式使用它:</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="dc13" class="nk nl it nf b be nm nn l no np">const shortcuts = new Shortcuts();<br/>const eventHandler = new UIEventHandler(shortcuts);<br/><br/>eventHandler.handleAction("openUrl", "https://medium.com/@bytefer");<br/>eventHandler.handleAction("sendMessage", "Hello Bytefer!");</span></pre><p id="7ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于前面的代码，似乎没有问题。但仔细分析后，你会发现以下问题:</p><ul class=""><li id="7cf7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在调用<code class="fe nc nd ne nf b">handleAction</code>方法时，我们需要保证<code class="fe nc nd ne nf b">action</code>名称与<code class="fe nc nd ne nf b">Shortcuts</code>类中方法的名称一致。</li><li id="327d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">随着函数的不断增加，<code class="fe nc nd ne nf b">Shortcuts</code>类中相应的方法也会越来越多。因此，我们需要不断地修改<code class="fe nc nd ne nf b">Shortcuts</code>类。</li></ul><p id="a7bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么应该如何处理上述问题呢？对于这个问题，我们可以使用<strong class="lb iu">命令模式</strong>。为了更好地理解下面的代码，我们先来看看相应的UML图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/8270161b4151bb5fa07c939ac37bed93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6UHL56-OXwO8UR4k2K2Sw.png"/></div></div></figure><p id="cb40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们可以将发送消息、翻译文本和缩短URL等任务包装成单独的命令。</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="c35f" class="nk nl it nf b be nm nn l no np">interface Command {<br/>  name: string;<br/>  execute(args: any): any;<br/>}</span></pre><p id="c2d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用<code class="fe nc nd ne nf b">interface</code>关键字来定义<code class="fe nc nd ne nf b">Command</code>类型。在<code class="fe nc nd ne nf b">Command</code>类型中，定义了一个<code class="fe nc nd ne nf b">execute</code>方法来封装每个命令需要执行的逻辑。使用<code class="fe nc nd ne nf b">Command</code>界面，让我们定义具体的命令。</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="3cba" class="nk nl it nf b be nm nn l no np">class OpenUrlCommand implements Command {<br/>  name = "openUrl";<br/>  execute(args: any) {<br/>    console.log(`Open url: ${args[0]}`);<br/>  }<br/>}<br/><br/>class SendMessageCommand implements Command {<br/>  name = "sendMessage";<br/>  execute(args: any) {<br/>    console.log(`Send message: ${args[0]}`);<br/>  }<br/>}</span></pre><p id="0980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们创建了<code class="fe nc nd ne nf b">OpenUrlCommand</code>和<code class="fe nc nd ne nf b">SendMessageCommand</code>类。今后，我们的命令将继续增加。为了便于管理不同的命令类，我们需要定义一个管理命令的类:</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="106f" class="nk nl it nf b be nm nn l no np">class CommandManager {<br/>  commands: Record&lt;string, Command&gt; = {};<br/><br/>  registerCommand(name: string, command: Command) {<br/>    this.commands[name] = command;<br/>  }<br/><br/>  executeCommand(command: string | Command, ...args: any) {<br/>    if (typeof command === "string") {<br/>      this.commands[command].execute(args);<br/>    } else {<br/>      command.execute(args);<br/>    }<br/>  }<br/>}</span></pre><p id="d157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nc nd ne nf b">CommandManager</code>类中，<code class="fe nc nd ne nf b">registerCommand</code>方法用于注册命令。而<code class="fe nc nd ne nf b">executeCommand</code>方法用于执行命令。有了<code class="fe nc nd ne nf b">CommandManager</code>类，让我们更新之前创建的<code class="fe nc nd ne nf b">UIEventHandler</code>类。</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="bd08" class="nk nl it nf b be nm nn l no np">class UIEventHandler {<br/>  constructor(public cmdManager: CommandManager) {}<br/>  handleAction(command: string | Command, arg: string) {<br/>    this.cmdManager.executeCommand(command, arg);<br/>  }<br/>}</span></pre><p id="925c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新完<code class="fe nc nd ne nf b">UIEventHandler</code>类后，让我们验证一下它的功能。</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="94f2" class="nk nl it nf b be nm nn l no np">const commandManager = new CommandManager();<br/>commandManager.registerCommand("openUrl", new OpenUrlCommand());<br/>commandManager.registerCommand("msg", new SendMessageCommand());<br/><br/>const eventHandler = new UIEventHandler(commandManager);<br/>eventHandler.handleAction("openUrl", "https://medium.com/@bytefer");<br/>eventHandler.handleAction("msg", "Hello Medium!");<br/>eventHandler.handleAction(new SendMessageCommand(), "Hello Bytefer!");</span></pre><p id="8f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们首先创建了<code class="fe nc nd ne nf b">CommandManager</code>对象，然后注册了2个命令。然后我们创建一个<code class="fe nc nd ne nf b">UIEventHandler</code>对象，并在该对象上使用<code class="fe nc nd ne nf b">handleAction</code>方法来执行注册的命令。上述代码成功执行后，控制台将输出以下信息:</p><pre class="kj kk kl km gt ng nf nh bn ni nj bi"><span id="f6c9" class="nk nl it nf b be nm nn l no np">Open url: https://medium.com/@bytefer<br/>Send message: Hello Medium!<br/>Send message: Hello Bytefer!</span></pre><p id="c92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在富文本编辑器和命令行应用程序的环境中，也经常使用命令模式。</strong>比如用于创建命令行应用的第三方库<a class="ae ky" href="https://github.com/cacjs/cac" rel="noopener ugc nofollow" target="_blank"> CAC </a>，内部也使用了command模式。有兴趣可以看一下<a class="ae ky" href="https://github.com/cacjs/cac/blob/master/src/Command.ts" rel="noopener ugc nofollow" target="_blank">对应的源代码</a>。</p><p id="8c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们总结一下命令模式的使用场景:</p><ul class=""><li id="cbac" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当需要抽象各种执行动作时，使用不同的参数来确定执行哪个动作。</li><li id="6d14" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">系统需要分离请求调用者和请求接收者，这样调用者和接收者就不会直接交互。请求的调用方不需要知道接收方的存在，也不需要知道接收方是谁，接收方也不需要关心什么时候被调用。</li></ul><p id="99ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，请随时给我留言。稍后我会继续介绍其他模式，如果你有兴趣，可以在<a class="ae ky" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或者<a class="ae ky" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="bbec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想学习打字稿，那么就不要错过<strong class="lb iu">掌握打字稿</strong>系列。</p><div class="mj mk gp gr ml mm"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">有了30+篇文章，学习TypeScript就不会迷茫了</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="nz l mx my mz mv na ks mm"/></div></div></a></div></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="1ef6" class="oa nl it bd ob oc od oe of og oh oi oj jz ok ka ol kc om kd on kf oo kg op oq bi translated">分级编码</h1><p id="12b9" class="pw-post-body-paragraph kz la it lb b lc or ju le lf os jx lh li ot lk ll lm ou lo lp lq ov ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="52fd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="1246" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">📰查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="38f5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="b09a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>