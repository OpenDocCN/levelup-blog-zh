<html>
<head>
<title>How to Trace Linux System Calls in Production with Minimal Impact on Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在对性能影响最小的情况下跟踪生产中的Linux系统调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-trace-linux-system-calls-in-production-with-minimal-impact-on-performance-56bcfbe09c4b?source=collection_archive---------23-----------------------#2021-01-11">https://levelup.gitconnected.com/how-to-trace-linux-system-calls-in-production-with-minimal-impact-on-performance-56bcfbe09c4b?source=collection_archive---------23-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">张文波</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2cd3444f22f55ee90ac439c7714cd87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*srtjYR9Ob0k8cx1f.jpg"/></div></div></figure><p id="3963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要动态跟踪Linux进程系统调用，您可能会首先考虑strace。strace使用简单，对于诸如“为什么软件不能在这台机器上运行？”这样的问题非常有效然而，如果您在生产环境中运行跟踪，strace不是一个好的选择。它引入了大量的开销。根据<a class="ae kx" href="http://vger.kernel.org/~acme/perf/linuxdev-br-2018-perf-trace-eBPF/#/4/2" rel="noopener ugc nofollow" target="_blank">红帽公司<strong class="jp ir">的高级软件工程师阿纳尔多·卡瓦略·德·梅洛进行的一项性能测试</strong></a>，使用strace追踪的流程运行速度慢了173倍，这对生产环境来说是灾难性的。</p><p id="4b7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，在生产环境中，有什么工具擅长跟踪系统调用吗？答案是肯定的。这篇博文介绍了perf和traceloop，这两个常用的命令行工具，可以帮助您在生产环境中跟踪系统调用。</p><h1 id="2771" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">perf，一个用于Linux的性能分析器</h1><p id="ce48" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">perf是一个强大的Linux分析工具，由Linux内核开发人员改进和升级。除了分析性能监控单元(PMU)硬件事件和内核事件等常见功能之外，perf还具有以下子组件:</p><ul class=""><li id="66fb" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">sched:分析调度程序动作和延迟。</li><li id="2414" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">时序图:根据工作负载可视化系统行为。</li><li id="26d9" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">c2c:检测虚假共享的可能性。Red Hat曾经在许多Linux应用程序上测试c2c原型，并发现了许多错误共享和热点缓存线的情况。</li><li id="2670" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">trace:跟踪开销可接受的系统调用。对于<code class="fe mp mq mr ms b">dd</code>命令中指定的工作负载，它的执行速度仅慢1.36倍。</li></ul><p id="3d51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看perf的一些常见用法。</p><ul class=""><li id="f6aa" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">要查看哪些命令进行了最多的系统调用:</li></ul><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="614f" class="mx kz iq ms b gy my mz l na nb">perf top -F 49 -e raw_syscalls:sys_enter --sort comm,dso --show-nr-samples</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/145d79992169bc1bf27447f1d47910ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0Truxvp5uYWTx_DB.jpg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">系统调用计数</figcaption></figure><p id="7819" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从输出中，您可以看到<code class="fe mp mq mr ms b">kube-apiserver</code>命令在采样期间有最多的系统调用。</p><ul class=""><li id="de88" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">查看延迟时间超过特定持续时间的系统调用。在以下示例中，该持续时间为200毫秒:</li></ul><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="67b0" class="mx kz iq ms b gy my mz l na nb">perf trace --duration 200</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/a16f540088d09cfc6ab66358a50af00c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*winOFlR0hZZYBUeu.jpg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">系统调用时间超过200毫秒</figcaption></figure><p id="fa97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从输出中，您可以看到进程名称、进程id(PID)、超过200毫秒的特定系统调用以及返回值。</p><ul class=""><li id="b456" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">要查看一段时间内有系统调用的进程及其开销摘要，请执行以下操作:</li></ul><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="edb3" class="mx kz iq ms b gy my mz l na nb">perf trace -p $PID  -s</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/de2537805355b2fdfaa874b224766ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*v6G_-jl7f2j1oyFR.jpg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">按进程列出的系统调用开销</figcaption></figure><p id="7610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从输出中，您可以看到每个系统调用的次数、错误的次数、总延迟、平均延迟等等。</p><ul class=""><li id="c963" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">要分析高延迟呼叫的堆栈信息，请执行以下操作:</li></ul><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="c75e" class="mx kz iq ms b gy my mz l na nb">perf trace record --call-graph dwarf -p $PID -- sleep 10</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a2f85966554458fb418d98279ae29646.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*dPlJhGZUVfDwjQ3j.jpg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">高延迟系统调用的堆栈信息</figcaption></figure><p id="8d44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跟踪一组任务。例如，两个BPF工具正在后台运行。要查看它们的系统调用信息，您可以将它们添加到一个<code class="fe mp mq mr ms b">perf_event</code> cgroup中，然后执行<code class="fe mp mq mr ms b">per trace</code>:</p><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="1f8d" class="mx kz iq ms b gy my mz l na nb">mkdir /sys/fs/cgroup/perf_event/bpftools/ echo 22542 &gt;&gt; /sys/fs/cgroup/perf_event/bpftools/tasks echo 20514 &gt;&gt; /sys/fs/cgroup/perf_event/bpftools/tasks perf trace -G bpftools -a -- sleep 10</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/60b7dabbf85055757053a98dca9c06df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d_O5f6PqydCFRKrt.jpg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">跟踪一组任务</figcaption></figure><p id="d1b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是perf的一些最常见的用法。如果你想了解更多(尤其是关于perf-trace)，请参见<a class="ae kx" href="https://man7.org/linux/man-pages/man1/perf-trace.1.html" rel="noopener ugc nofollow" target="_blank"> Linux手册页</a>。从手册页中，您将了解到perf-trace可以基于PID或线程id(tid)过滤任务，但是它不支持容器和Kubernetes (K8s)环境。别担心。接下来，我们将讨论一个工具，它可以很容易地跟踪容器中和使用cgroup v2的K8s环境中的系统调用。</p><h1 id="3613" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Traceloop，用于cgroup v2和K8s的性能分析器</h1><p id="4fd5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Traceloop为跟踪使用cgroup v2的容器或K8s环境中的Linux系统调用提供了更好的支持。你可能对traceloop不熟悉，但对BPF编译器集合(BCC)非常了解。(它的前端是用Python或者C++实现的。)在BCC的父项目IO Visor项目中，还有一个名为gobpf的项目，为BCC框架提供Golang绑定。基于gobpf，traceloop是针对容器和K8s环境开发的。下图显示了traceloop体系结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/31ffcc797ba011bd23cff2a511441e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*cvk6QiEQhjn1m3KG.jpg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated"><em class="nm"> traceloop架构</em></figcaption></figure><p id="2d36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将这个例子进一步简化为以下几个关键步骤。请注意，这些步骤是实施细节，而不是要执行的操作:</p><ol class=""><li id="75b1" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk nn mh mi mj bi translated"><code class="fe mp mq mr ms b">bpf helper</code>获取群组ID。基于群组ID而不是p ID和TID来过滤任务。</li><li id="d5a9" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">每个cgroup ID对应一个<a class="ae kx" href="https://ebpf.io/what-is-ebpf/#tail--function-calls" rel="noopener ugc nofollow" target="_blank"> bpf尾调用</a>，它可以调用并执行另一个eBPF程序，并替换执行上下文。Syscall事件通过bpf尾调用写入具有相同cgroup ID的perf环形缓冲区。</li><li id="b61b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">用户空间根据这个cgroup ID读取perf环形缓冲区。</li></ol><blockquote class="no np nq"><p id="27f0" class="jn jo nr jp b jq jr js jt ju jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注</em> </strong> <em class="iq"> : </em></p><p id="a02a" class="jn jo nr jp b jq jr js jt ju jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj kk ij bi translated"><em class="iq">目前只能通过执行</em> <code class="fe mp mq mr ms b"><em class="iq">bpf helper: bpf_get_current_cgroup_id</em></code> <em class="iq">获得cgroup ID，该ID仅在cgroup v2中可用。因此，在使用traceloop之前，请确保在您的环境中启用了</em><a class="ae kx" href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#basic-operations" rel="noopener ugc nofollow" target="_blank"><em class="iq">cgroup v2</em></a><em class="iq">。</em></p></blockquote><p id="bec9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在以下演示中(在CentOS 8 4.18内核上)，当traceloop退出时，系统调用信息被跟踪:</p><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="09e7" class="mx kz iq ms b gy my mz l na nb">sudo -E ./traceloop cgroups --dump-on-exit /sys/fs/cgroup/system.slice/sshd.service</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/42cd01bc8bc0db932a6ea4f2a3016faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/0*54uzbfDb_uCZcJZi.jpg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated"><em class="nm"> traceloop跟踪系统调用</em></figcaption></figure><p id="d2be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如结果所示，traceloop输出类似于strace或perf-trace的输出，除了基于cgroup的任务过滤。请注意，CentOS 8将cgroup v2直接挂载在<code class="fe mp mq mr ms b">/sys/fs/cgroup</code>路径上，而不是像Ubuntu那样挂载在<code class="fe mp mq mr ms b">/sys/fs/cgroup/unified</code>路径上。因此，在使用traceloop之前，应该运行<code class="fe mp mq mr ms b">mount -t cgroup2</code>来确定挂载信息。</p><p id="713f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">traceloop背后的团队已经将其与Inspektor Gadget项目集成，因此您可以使用kubectl在K8s平台上运行traceloop。查看<a class="ae kx" href="https://github.com/kinvolk/inspektor-gadget#how-to-use" rel="noopener ugc nofollow" target="_blank"> Inspektor小工具中的演示——如何使用</a>,如果你喜欢，可以自己尝试一下。</p><h1 id="49d5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">跟踪系统调用的基准测试</h1><p id="4f7b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们进行了一个sysbench测试，其中系统调用要么使用多个跟踪器(traceloop、strace和perf-trace)跟踪，要么不跟踪。基准测试结果如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/17de43107563202666d0ab16a0978cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/0*c6gj3b6zLo_hK3kF.jpg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated"><em class="nm">跟踪和未跟踪系统调用的Sysbench结果</em></figcaption></figure><p id="87c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如基准测试所示，strace导致了应用程序性能的最大下降。perf-trace导致的减少较小，traceloop导致的减少最小。</p><h1 id="ae88" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Linux评测器概述</h1><p id="8cfc" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">对于诸如“为什么软件不能在这台机器上运行”这样的问题，strace仍然是Linux中一个强大的系统调用跟踪器。但是要跟踪系统调用的延迟，基于BPF的性能跟踪是更好的选择。在使用cgroup v2的容器或K8s环境中，traceloop是最容易使用的。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="c7bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nr">原载于2020年12月24日</em><a class="ae kx" href="https://pingcap.com/blog/how-to-trace-linux-system-calls-in-production-with-minimal-impact-on-performance#perf-a-performance-profiler-for-linux" rel="noopener ugc nofollow" target="_blank"><em class="nr">www.pingcap.com</em></a><em class="nr"/></p></div></div>    
</body>
</html>