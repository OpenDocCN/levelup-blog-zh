<html>
<head>
<title>How to serialize and deserialize objects on iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS上序列化和反序列化对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-serialize-and-deserialize-objects-on-ios-a728b46e110f?source=collection_archive---------4-----------------------#2021-05-26">https://levelup.gitconnected.com/how-to-serialize-and-deserialize-objects-on-ios-a728b46e110f?source=collection_archive---------4-----------------------#2021-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d8f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">苹果喜欢用不同的方式命名一些东西，但是为序列化对象提供了很好的API</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c045b3cb38ccdc8fa2f2744cd6ee989a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pSIuSv2UQoK2qSwj.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">David Fekke的图片说明</figcaption></figure><p id="9ced" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="le">原发布于</em><a class="ae lf" href="https://fek.io/blog/how-to-serialize-and-deserialize-objects-on-i-os/" rel="noopener ugc nofollow" target="_blank"><em class="le">https://fek . io</em></a><em class="le">。</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="fe8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">苹果公司不仅思考方式不同，他们还喜欢给事物起不同的名字。在像Java和C#这样的语言中，如果你想在保证相同接口的对象之间共享一个契约，那就叫做‘接口’。在MacOS、iOS/iPadOS、watchOS和tvOS上，这被称为“协议”。就像你可以让一个类或结构符合一个接口一样，你也可以让一个Swift类或结构符合一个“协议”。</p><p id="acb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Objective-C中，如果你想扩展一个现有的类，那就叫做‘Category ’,但是在C#和Swift中它叫做<code class="fe li lj lk ll b">extension</code>。</p><p id="d8c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正在学习如何为苹果操作系统编程的开发人员可能对他们如何序列化和反序列化对象感到好奇。在MacOS和iOS上，这被称为“存档”和“取消存档”。</p><h1 id="6162" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">实施ns编码</h1><p id="e616" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">如果您有一个想要序列化或存档的类，您的类将需要实现“NSCoding”协议。NSCoding协议要求您的类中有一个名为<code class="fe li lj lk ll b">encode</code>的方法，以及一个<code class="fe li lj lk ll b">init</code>构造函数，该构造函数使用一个<code class="fe li lj lk ll b">coder</code>来解码存档的对象。</p><p id="7b6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看我定义的用于跟踪车辆的类。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp lh l"/></div></figure><p id="0a31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您正在使用Xcode，它有一个很好的特性，如果您正在向类中添加协议，它会提示开发人员创建任何缺少的方法。当我们将<code class="fe li lj lk ll b">NSObject</code>和<code class="fe li lj lk ll b">NSCoding</code>协议添加到我们的类中时，最终结果在我们的编辑器中将是这样的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp lh l"/></div></figure><p id="ae6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们实现这两个方法。对于<code class="fe li lj lk ll b">init?(coder: NSCoder)</code>,我们想让它成为一个方便的init，因为我们想让它在被解码后调用现有的<code class="fe li lj lk ll b">init</code>构造函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp lh l"/></div></figure><p id="55ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe li lj lk ll b">encode</code>方法，我们需要获取类的值，并使用传入该方法的编码器对它们进行编码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp lh l"/></div></figure><p id="1b24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过添加这两个方法，我们使我们的对象可序列化或可存档，这取决于您想要使用的术语。最终的类应该类似于下面的例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp lh l"/></div></figure><h1 id="563f" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">安全编码</h1><p id="24e3" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">对于归档和非归档类，苹果为他们不同的操作系统提供了以下类。</p><ul class=""><li id="8933" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">恩斯基达尔奇维尔</li><li id="158a" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">NSKeyedUnarchiver</li></ul><p id="eabf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从iOS 12开始，苹果弃用了这些类中用于执行存档的一些原始方法，并添加了支持“安全编码”的新方法。苹果提供了一个新的协议，如果你想支持“安全编码”，你的对象必须支持这个协议。</p><p id="9b13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个名为<code class="fe li lj lk ll b">NSSecureCoding</code>的新协议需要将一个名为“supportsSecureCoding”的布尔属性添加到您的类中。此标志可与存档和取消存档方法的参数一起使用，以实施“安全编码”。</p><p id="fff7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安全编码将使编码和解码能够防止对象替换攻击。如果发生对象替换攻击，被取消存档对象可能膨胀成可能允许攻击的对象。</p><p id="0843" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将<code class="fe li lj lk ll b">NSSecureCoding</code>协议添加到我们的类中。</p><pre class="kp kq kr ks gt ne ll nf ng aw nh bi"><span id="52dc" class="ni ln it ll b gy nj nk l nl nm">class Vehicle: NSObject, NSCoding, NSSecureCoding {<br/>    public static var supportsSecureCoding = true<br/>    <br/>    var make: String<br/>    var model: String<br/>    var tires: Int = 0<br/>...</span></pre><p id="5ee4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以创建这个<code class="fe li lj lk ll b">Vehicle</code>类的一个新实例，并归档到一个<code class="fe li lj lk ll b">Data</code>对象。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp lh l"/></div></figure><p id="297a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，我们可以看到<code class="fe li lj lk ll b">archivedData</code>函数有第二个参数叫做<code class="fe li lj lk ll b">requiringSecureCoding</code>。如果该函数无法归档对象，它也会抛出错误。</p><p id="9a10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">flatVehicle</code>对象属于<code class="fe li lj lk ll b">Data</code>类型，可以写入文件系统或其他持久存储。</p><p id="f04c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想对数据进行解归档，我们可以使用<code class="fe li lj lk ll b">NSKeyedUnarchiver</code>类。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp lh l"/></div></figure><h1 id="8c6d" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">一些其他的事情</h1><p id="48a2" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">并不是所有的类都不能使用<code class="fe li lj lk ll b">unarchivedObject(ofClass:from:</code>函数进行分类。如果您使用Swift <code class="fe li lj lk ll b">Dictionary</code>这样的数据类型，您将不得不使用另一个函数，比如<code class="fe li lj lk ll b">unarchiveTopLevelObjectWithData</code>函数，它没有指定特定的数据类型。</p><p id="f24d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，使用NSKeyedArchiver和NSKeyedUnarchiver类可以在MAC、iPhone、iPad和其他Apple设备上序列化和反序列化对象。使用这些实用程序时应小心谨慎，注意安全。</p></div></div>    
</body>
</html>