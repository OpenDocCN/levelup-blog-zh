<html>
<head>
<title>How To Deploy Apache Kafka With Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Kubernetes部署Apache Kafka</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-deploy-apache-kafka-with-kubernetes-9bd5caf7694f?source=collection_archive---------0-----------------------#2022-04-27">https://levelup.gitconnected.com/how-to-deploy-apache-kafka-with-kubernetes-9bd5caf7694f?source=collection_archive---------0-----------------------#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e0056b1d1e917aacc5d881c3dcbdb7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_4PifHGIWqCNhm43Fwl9A.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">克里斯蒂亚诺·菲尔马尼在<a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="26c5" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">咖啡店里的编码</h2><div class=""/><div class=""><h2 id="2842" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">在迁移到云之前，通过在本地部署Kubernetes开始使用Kafka。</h2></div><p id="9bbd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Kafka是大型微服务架构系统事实上的事件存储和分布式消息代理解决方案。Kubernetes是编排容器化服务的行业标准。对于许多组织来说，在Kubernetes上部署Kafka是一种省力的方法，符合他们的架构策略。</p><p id="1f29" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本帖中，我们将看看在Kubernetes上托管Kafka的吸引力，提供关于这两种应用程序的快速入门。最后，我们将通过一种与云无关的方法来配置Kubernetes，以部署Kafka及其兄弟服务。</p><h1 id="419c" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">技术入门</h1><p id="73fa" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">让我们先来快速回顾一下库伯涅茨和卡夫卡。</p><h2 id="b2a0" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">库伯内特斯</h2><p id="9bf2" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">谷歌在2003年开始开发Kubernetes (k8s)。当时，这个项目被称为<a class="ae jg" href="https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/" rel="noopener ugc nofollow" target="_blank">博格</a>。2014年，Google在Github 上发布了k8s作为<a class="ae jg" href="https://github.com/kubernetes/kubernetes" rel="noopener ugc nofollow" target="_blank">开源项目，k8s很快通过微软、红帽、Docker等挑选了合作伙伴。多年来，越来越多的努力使用Kubernetes，包括</a><a class="ae jg" href="https://github.blog/2017-08-16-kubernetes-at-github/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>本身和流行游戏<a class="ae jg" href="https://cloud.google.com/blog/products/containers-kubernetes/bringing-pokemon-go-to-life-on-google-cloud" rel="noopener ugc nofollow" target="_blank"> Pokémon GO </a>。在2022年，我们看到k8s在AI/ML领域的使用越来越多，并且越来越强调安全性。</p><p id="0ae1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将k8s引入云开发生命周期提供了几个关键优势:</p><ul class=""><li id="47c7" class="nl nm jj lj b lk ll ln lo lq nn lu no ly np mc nq nr ns nt bi translated">零停机部署</li><li id="20b2" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">可量测性</li><li id="360b" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">不变的基础设施</li><li id="6b96" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">自我修复系统</li></ul><p id="1026" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这些好处很多都来自于k8s中声明性配置的使用。为了改变基础设施的配置，必须销毁和重建资源，从而强制实现不变性。此外，如果k8s检测到资源偏离了声明的规范，它会尝试重新构建系统的状态以再次匹配该规范。</p><p id="1f10" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于开发人员来说，使用k8s意味着最终结束令人沮丧的午夜部署，在这种情况下，您必须放弃一切，直接手动扩展服务或修补生产环境。</p><h2 id="a81a" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">阿帕奇卡夫卡</h2><p id="67c0" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Kafka是一个开源的分布式流处理工具。Kafka允许多个“生产者”向“主题”添加消息(键值对)。这些消息在每个主题中作为一个队列排序。“消费者”订阅主题，并可以按照消息到达队列的顺序检索消息。</p><p id="af58" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Kafka托管在一个通常被称为“代理”的服务器上。不同地区可以有很多不同的卡夫卡经纪人。除了Kafka经纪人，另一个名为Zookeeper的服务使不同的经纪人保持同步，并帮助协调主题和消息。</p><p id="9dee" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Kafka的高明之处在于，它可以在分发的同时，以相对低廉的每MB成本，每秒处理数十万条消息。</p><p id="522e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">卡夫卡经常占据类似微服务架构的“中枢神经系统”的位置。消息在生产者和消费者之间传递，实际上，这是你的云中的服务。同一个服务既可以是Kafka中相同或不同主题的消息的消费者，也可以是其生产者。</p><p id="08f6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一个示例用例是在您的应用程序中创建新用户。用户服务发布关于“供应用户”主题的消息。电子邮件服务使用这条关于新用户的消息，然后向他们发送一封欢迎电子邮件。用户和电子邮件服务不必直接相互发送消息，但是它们各自的作业是异步执行的。</p><h1 id="28cb" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">用Kubernetes部署Kafka</h1><p id="63f5" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">对于我们的迷你项目演练，我们将使用Minikube以云中立的方式设置Kubernetes和Kafka，这允许我们在单台机器上运行整个k8s集群。我们安装了以下应用程序:</p><ul class=""><li id="aa0e" class="nl nm jj lj b lk ll ln lo lq nn lu no ly np mc nq nr ns nt bi translated"><a class="ae jg" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>版本v1.25.2</li><li id="8811" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated"><a class="ae jg" href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/" rel="noopener ugc nofollow" target="_blank"> Kubectl </a>客户端版本1.23.3</li></ul><h2 id="ef74" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">Minikube设置</h2><p id="582a" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">安装Minikube后，我们可以用minikube start命令启动它。然后，我们可以看到状态:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="b376" class="na me jj oe b gy oi oj l ok ol">$ minikube status</span><span id="b1c0" class="na me jj oe b gy om oj l ok ol">minikube</span><span id="985c" class="na me jj oe b gy om oj l ok ol">type: Control Plane<br/>host: Running<br/>kubelet: Running<br/>apiserver: Running<br/>kubeconfig: Configured</span></pre><p id="2946" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">设置Kubernetes在您选择的云提供商中运行的说明可以在每个提供商的文档中找到(例如，<a class="ae jg" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae jg" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> GCP </a>或<a class="ae jg" href="https://docs.microsoft.com/en-us/azure/aks/" rel="noopener ugc nofollow" target="_blank"> Azure </a>)，但是下面列出的YAML配置文件应该适用于所有提供商，对IP地址和相关字段稍作调整。</p><h2 id="e8cd" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">定义Kafka名称空间</h2><p id="9346" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">首先，我们使用一个名为<code class="fe on oo op oe b">00-namespace.yaml</code>的文件为部署所有Kafka资源定义一个名称空间:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="cc1a" class="na me jj oe b gy oi oj l ok ol">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: "kafka"<br/>  labels:<br/>    name: "kafka"</span></pre><p id="de71" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们使用<code class="fe on oo op oe b">kubectl apply -f 00-namespace.yaml</code>来应用这个文件。</p><p id="2c25" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以通过运行<code class="fe on oo op oe b">kubectl get namespaces</code>来测试名称空间是否创建正确，验证Kafka是Minikube中存在的名称空间。</p><h2 id="87fa" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">部署动物园管理员</h2><p id="b0e2" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">接下来，我们将Zookeeper部署到我们的k8s名称空间。我们用以下内容创建一个文件名<code class="fe on oo op oe b">01-zookeeper.yaml</code>:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="093d" class="na me jj oe b gy oi oj l ok ol">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: zookeeper-service<br/>  name: zookeeper-service<br/>  namespace: kafka<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>    - name: zookeeper-port<br/>      port: 2181<br/>      nodePort: 30181<br/>      targetPort: 2181<br/>  selector:<br/>    app: zookeeper<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: zookeeper<br/>  name: zookeeper<br/>  namespace: kafka<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: zookeeper<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: zookeeper<br/>    spec:<br/>      containers:<br/>        - image: wurstmeister/zookeeper<br/>          imagePullPolicy: IfNotPresent<br/>          name: zookeeper<br/>          ports:<br/>            - containerPort: 2181</span></pre><p id="385e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个YAML文件中创建了两个资源。第一个是名为<code class="fe on oo op oe b">zookeeper-service</code>的服务，它将使用在名为<code class="fe on oo op oe b">zookeeper</code>的第二个资源中创建的部署。部署使用<code class="fe on oo op oe b">wurstmeister/zookeeper</code> Docker映像作为实际的Zookeeper二进制文件。该服务在内部k8s网络的一个端口上公开该部署。在这种情况下，我们使用标准的Zookeeper端口<code class="fe on oo op oe b">2181</code>，Docker容器也公开了这个端口。</p><p id="43dd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们用下面的命令应用这个文件:<code class="fe on oo op oe b">kubectl apply -f 01-zookeeper.yaml</code>。</p><p id="e45b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以测试成功创建的服务，如下所示:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="5dee" class="na me jj oe b gy oi oj l ok ol">$ kubectl get services -n kafka<br/>NAME               TYPE      CLUSTER-IP     PORT(S)         AGE<br/>zookeeper-service  NodePort  10.100.69.243  2181:30181/TCP  3m4s</span></pre><p id="5fb5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们看到了Zookeeper的内部IP地址(<code class="fe on oo op oe b">10.100.69.243</code>)，我们需要告诉代理在哪里监听它。</p><h2 id="dba8" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">部署Kafka代理</h2><p id="5918" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">最后一步是部署Kafka代理。我们用下面的内容创建一个<code class="fe on oo op oe b">02-kafka.yaml</code>文件，我们用Zookeeper的上一步中的<code class="fe on oo op oe b">CLUSTER-IP</code>替换<code class="fe on oo op oe b">&lt;ZOOKEEPER-INTERNAL-IP&gt;</code>。如果不采取这一步骤，代理将无法部署。</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="b6e9" class="na me jj oe b gy oi oj l ok ol">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: kafka-broker<br/>  name: kafka-service<br/>  namespace: kafka<br/>spec:<br/>  ports:<br/>  - port: 9092<br/>  selector:<br/>    app: kafka-broker<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: kafka-broker<br/>  name: kafka-broker<br/>  namespace: kafka<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: kafka-broker<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: kafka-broker<br/>    spec:<br/>      hostname: kafka-broker<br/>      containers:<br/>      - env:<br/>        - name: KAFKA_BROKER_ID<br/>          value: "1"<br/>        - name: KAFKA_ZOOKEEPER_CONNECT<br/>          value: &lt;ZOOKEEPER-INTERNAL-IP&gt;:2181<br/>        - name: KAFKA_LISTENERS<br/>          value: PLAINTEXT://:9092<br/>        - name: KAFKA_ADVERTISED_LISTENERS<br/>          value: PLAINTEXT://kafka-broker:9092<br/>        image: wurstmeister/kafka<br/>        imagePullPolicy: IfNotPresent<br/>        name: kafka-broker<br/>        ports:<br/>        - containerPort: 9092</span></pre><p id="e9ea" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同样，我们为一个Kafka代理创建了两个资源——服务和部署。我们运行<code class="fe on oo op oe b">kubectl apply -f 02-kafka.yaml</code>。我们通过查看命名空间中的pod来验证这一点:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="fb90" class="na me jj oe b gy oi oj l ok ol">$ kubectl get pods -n kafka<br/>NAME                            READY   STATUS    RESTARTS   AGE<br/>kafka-broker-5c55f544d4-hrgnv   1/1     Running   0          48s<br/>zookeeper-55b668879d-xc8vd      1/1     Running   0          35m</span></pre><p id="275f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Kafka Broker pod可能需要一分钟才能从<code class="fe on oo op oe b">ContainerCreating</code>状态转换到<code class="fe on oo op oe b">Running</code>状态。</p><p id="95c9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意<code class="fe on oo op oe b">02-kafka.yaml</code>中的那一行，我们在那里为<code class="fe on oo op oe b">KAFKA_ADVERTISED_LISTENERS</code>提供了一个值。为了确保Zookeeper和Kafka可以使用这个主机名(<code class="fe on oo op oe b">kafka-broker)</code>)进行通信，我们需要在本地机器上的<code class="fe on oo op oe b">/etc/hosts</code>文件中添加以下条目:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="c4bc" class="na me jj oe b gy oi oj l ok ol">127.0.0.1 kafka-broker</span></pre><h2 id="cf29" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">测试卡夫卡主题</h2><p id="cd08" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">为了测试我们可以在Kafka中发送和检索来自一个主题的消息，我们需要为Kafka公开一个端口，使它可以从localhost访问。我们运行以下命令来公开端口:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="4627" class="na me jj oe b gy oi oj l ok ol">$ kubectl port-forward kafka-broker-5c55f544d4-hrgnv 9092 -n kafka<br/>Forwarding from 127.0.0.1:9092 -&gt; 9092<br/>Forwarding from [::1]:9092 -&gt; 9092</span></pre><p id="baf6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">上面的命令<code class="fe on oo op oe b">kafka-broker-5c55f544d4-hrgnv</code>引用了我们在<code class="fe on oo op oe b">kafka</code>名称空间中列出pod时看到的k8s pod。该命令使该pod的端口<code class="fe on oo op oe b">9092</code>在<code class="fe on oo op oe b">localhost:9092</code>时在Minikube k8s集群之外可用。</p><p id="9270" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了方便地从Kafka发送和检索消息，我们将使用名为<a class="ae jg" href="https://github.com/edenhill/kcat" rel="noopener ugc nofollow" target="_blank"> KCat </a>(以前的Kafkacat)的命令行工具。为了创建名为<code class="fe on oo op oe b">test</code>的消息和主题，我们运行以下命令:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="3264" class="na me jj oe b gy oi oj l ok ol">$ echo "hello world!" | kafkacat -P -b localhost:9092 -t test</span></pre><p id="8327" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该命令应该没有错误地执行，表明生产者在k8s中与Kafka通信良好。我们如何看到名为<code class="fe on oo op oe b">test</code>的队列中当前有哪些消息？我们运行以下命令:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="7fc4" class="na me jj oe b gy oi oj l ok ol">$ kafkacat -C -b localhost:9092 -t test</span><span id="119f" class="na me jj oe b gy om oj l ok ol">hello world!<br/>% Reached end of topic test [0] at offset 1</span></pre><p id="b2fa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们做到了！我们已经成功地用Kubernetes部署了Kafka！</p><h2 id="8c47" class="na me jj bd mf nb nc dn mj nd ne dp mn lq nf ng mp lu nh ni mr ly nj nk mt jp bi translated">后续步骤</h2><p id="584d" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Kafka是对实现实时、事件驱动的架构和系统感兴趣的组织的关键角色。使用Kubernetes部署Kafka是一个很好的开始，但是组织还需要弄清楚如何让Kafka与他们现有的API生态系统无缝、安全地工作。他们需要的是在API的整个生命周期中处理管理和安全的工具。</p><p id="6149" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在现有的提供商中，我遇到了Gravitee，这是一个领先的解决方案，特别专注于帮助组织管理、保护、治理和产品化他们的API生态系统，无论他们构建的是什么协议、服务或风格。Gravitee甚至有一个<a class="ae jg" href="https://docs.gravitee.io/apim/3.x/apim_publisherguide_introducing_kafka.html" rel="noopener ugc nofollow" target="_blank"> Kafka连接器</a>，它通过暴露端点来接收数据，端点将请求转换成消息，然后可以发布到Kafka主题。它还可以通过Websocket等网络友好协议将Kafka事件传输给消费者。</p><h1 id="1458" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">结论</h1><p id="7882" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">在本文中，我们讨论了Kafka如何通过作为一个中枢神经系统向许多不同的服务转发消息来帮助编排微服务架构。为了部署Kafka，我们研究了Kubernetes，这是一个强大的容器编排平台，您可以在本地运行(使用Minikube)或在云提供商的生产环境中运行。最后，我们演示了如何使用Minikube建立一个本地Kubernetes集群，部署Kafka，然后使用KCat验证成功的部署和配置。</p><p id="eb71" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">部署愉快！</p></div></div>    
</body>
</html>