<html>
<head>
<title>Design Patterns: Visitor Pattern in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:TypeScript中的访问者模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-visitor-pattern-in-typescript-b80bd7cba155?source=collection_archive---------4-----------------------#2022-12-06">https://levelup.gitconnected.com/design-patterns-visitor-pattern-in-typescript-b80bd7cba155?source=collection_archive---------4-----------------------#2022-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cafa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定义新的操作，而不事先改变数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/64ca5f33f50fb1cf49a70d1f9c5e8734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GSgXQGXsSbGelyJQ"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@meizhilang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅芝郎</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎来到TypeScript 系列的<strong class="lb iu">设计模式，该系列介绍了一些使用TypeScript进行web开发时有用的设计模式。</strong></p><div class="lv lw gp gr lx ly"><a href="https://medium.com/frontend-canteen/9-design-patterns-every-engineer-should-know-f2423d36d468" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">每个工程师都应该知道的9种设计模式</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">掌握这9种设计模式，写出更好的代码</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="55b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计模式对于web开发人员来说非常重要，通过掌握它们我们可以写出更好的代码。在本文中，我将使用<strong class="lb iu">类型脚本</strong>来介绍<strong class="lb iu">访问者模式。</strong></p><p id="fedd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能不熟悉访问者模式。但如果你学过<a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>，你应该用过<strong class="lb iu">@巴别塔/遍历</strong>。该库在内部使用访问者模式，允许您快速遍历由<strong class="lb iu"> @babel/parser </strong>生成的AST(抽象语法树)中的各个节点。访问者模式也是一种<strong class="lb iu">行为模式</strong>，我将在本文中介绍。</p><p id="680d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文本编辑场景中，与传统的富文本编辑器相比，块编辑器已经成为主流的文本编辑器。例如，您可能也使用过的concept是块编辑器的经典应用。<strong class="lb iu">使用块编辑器创建的内容由不同类型的块</strong>组成，如标题块、段落块、图像块、视频块、音频块和文件块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/92d51edabf3fa5f924fe786cf31b9e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgkPwaeoZs-WO325il4BTQ.jpeg"/></div></div></figure><p id="0898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么传统的富文本编辑器和块编辑器有什么区别呢？让我们看看它们是如何表示相同的页面内容的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/c66ba5a6f6a7e31cb8664b738e24ca94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IV1tdg5NLipPsOocDfBcPQ.jpeg"/></div></div></figure><blockquote class="mo mp mq"><p id="55fd" class="kz la mr lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated">注意:当然，大多数块编辑器也支持导出HTML或Markdown文本格式。</p></blockquote><p id="bb71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用TypeScript实现一个支持标题块、段落块和图像块的块编辑器。不同的块有不同的类型和数据，所以我们首先使用<code class="fe mv mw mx my b">interface</code>关键字定义一个<code class="fe mv mw mx my b">Block</code>接口:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="9905" class="nd ne it my b be nf ng l nh ni">interface Block {<br/>  type: string;<br/>  data: Record&lt;string, any&gt;;<br/>}</span></pre><p id="57a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们继续定义了3个接口<code class="fe mv mw mx my b">HeadBlockData</code>、<code class="fe mv mw mx my b">ParagraphBlockData</code>、<code class="fe mv mw mx my b">ImageBlockData</code>，用来表示不同块对应的数据结构。</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="c878" class="nd ne it my b be nf ng l nh ni">interface HeadBlockData {<br/>  text: string;<br/>  level: 1 | 2 | 3 | 4 | 5 | 6;<br/>}<br/><br/>interface ParagraphBlockData {<br/>  text: string;<br/>}<br/><br/>interface ImageBlockData {<br/>  url: string;<br/>  caption: string;<br/>}</span></pre><p id="d1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义<code class="fe mv mw mx my b">Block</code>相关接口后，我们可以创建不同类型的块:</p><ul class=""><li id="c588" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><code class="fe mv mw mx my b">HeadBlock</code>:对应HTML <strong class="lb iu"> h1~h6 </strong>元素；</li><li id="4a08" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe mv mw mx my b">ParagraphBlock</code>:对应HTML <strong class="lb iu"> p </strong>元素；</li><li id="00cb" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe mv mw mx my b">ImageBlock</code>:对应HTML <strong class="lb iu"> img </strong>元素。</li></ul><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="976e" class="nd ne it my b be nf ng l nh ni">class HeaderBlock implements Block {<br/>  type = "header";<br/>  constructor(public data: HeadBlockData) {}<br/>}<br/><br/>class ParagraphBlock implements Block {<br/>  type = "paragraph";<br/>  constructor(public data: ParagraphBlockData) {}<br/>}<br/><br/>class ImageBlock implements Block {<br/>  type = "image";<br/>  constructor(public data: ImageBlockData) {}<br/>}</span></pre><p id="1162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然上面只定义了3种不同类型的块，但是实际上可以根据实际需要定义其他类型的块。有了不同的块之后，让我们定义一个<code class="fe mv mw mx my b">BlockEditor</code>类:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="bf24" class="nd ne it my b be nf ng l nh ni">class BlockEditor {<br/>  blocks: Array&lt;Block&gt; = [];<br/><br/>  addBlock(block: Block) {<br/>    this.blocks.push(block);<br/>  }<br/><br/>  removeBlock(block: Block) {<br/>    const index = this.blocks.indexOf(block);<br/>    index !== -1 &amp;&amp; this.blocks.splice(index, 1);<br/>  }<br/>}</span></pre><p id="e9d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mv mw mx my b">BlockEditor</code>类中，我们定义了<code class="fe mv mw mx my b">addBlock</code>和<code class="fe mv mw mx my b">removeBlock</code>方法，用于添加和移除指定的块对象。现在让我们使用<code class="fe mv mw mx my b">addBlock</code>方法添加3种不同类型的<code class="fe mv mw mx my b">Block</code>:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="b0ce" class="nd ne it my b be nf ng l nh ni">const blockEditor = new BlockEditor();<br/><br/>blockEditor.addBlock(<br/>  new HeaderBlock({<br/>    text: "Hello Bytefer!",<br/>    level: 1,<br/>  })<br/>);<br/><br/>blockEditor.addBlock(<br/>  new ParagraphBlock({<br/>    text: "Learn Visitor Pattern!",<br/>  })<br/>);<br/><br/>blockEditor.addBlock(<br/>  new ImageBlock({<br/>    url: "https://miro.medium.com/fit/c/176/176/1*krjVh9VFhDEcMUif4Ewt-A.png",<br/>    caption: "bytefer-avatar",<br/>  })<br/>);</span></pre><p id="53e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功添加以上块后，我们再给<code class="fe mv mw mx my b">BlockEditor</code>类添加一个<code class="fe mv mw mx my b">outputHTML</code>方法，用于将块编辑器保存的块导出为<strong class="lb iu"> HTML </strong>文本。</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="1aef" class="nd ne it my b be nf ng l nh ni">class BlockEditor {<br/>  // Omit some code<br/>  outputHtml() {<br/>    let htmlStr = "";<br/>    this.blocks.forEach((block) =&gt; {<br/>      switch (block.type) {<br/>        case "header":<br/>          const { level, text } = block.data;<br/>          htmlStr += `&lt;h${level}&gt;${text}&lt;/h${level}&gt;`;<br/>          break;<br/>        case "paragraph":<br/>          htmlStr += `&lt;p&gt;${block.data.text}&lt;/p&gt;`;<br/>          break;<br/>        case "image":<br/>          const { url, caption } = block.data;<br/>          htmlStr += `&lt;img src="${url}" alt="${caption}" /&gt;`;<br/>          break;<br/>      }<br/>    });<br/>    return htmlStr;<br/>  }<br/>}</span></pre><p id="76cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">outputHtml</code>方法的实现非常简单，就是遍历blocks数组，然后根据数组中每个<code class="fe mv mw mx my b">block</code>对象的类型拼接不同的字符串。现在的问题是，如果我们想要支持导出<strong class="lb iu"> Markdown </strong>格式，我们应该怎么做？最简单的方法是在<code class="fe mv mw mx my b">BlockEditor</code>类中添加一个<code class="fe mv mw mx my b">outputMd</code>方法。但是如果你还想继续支持<strong class="lb iu"> PDF </strong>格式，就需要继续修改<code class="fe mv mw mx my b">BlockEditor</code>类，给它添加一个<code class="fe mv mw mx my b">outputPDF</code>方法。</p><p id="550c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个时候，相信你也意识到了问题。每次我们向<code class="fe mv mw mx my b">BlockEditor</code>类添加不同的导出格式，我们都需要不断地修改<code class="fe mv mw mx my b">BlockEditor</code>类。那么如何解决上述问题呢？解决方案之一是使用访问者模式。访问者模式主要由以下5个角色组成:</p><ul class=""><li id="8548" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><strong class="lb iu">访问者</strong>:抽象访问者，定义对元素的访问行为。</li><li id="4327" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">具体访问者</strong>:具体的访问者，定义了具体的访问行为。</li><li id="a4f9" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">元素</strong>:包含<code class="fe mv mw mx my b">accept</code>方法的抽象元素类，表示每个元素都可以被访问者访问。</li><li id="ae47" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> ConcreteElement </strong>:一个具体的元素类，定义了<code class="fe mv mw mx my b">accept</code>方法的具体实现。</li><li id="585f" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">ObjectStructure :内部包含一个元素集合，可以迭代这些元素以提供访问者访问。</li></ul><p id="9dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于块编辑器场景，<code class="fe mv mw mx my b">ObjectStructure</code>角色对应于<code class="fe mv mw mx my b">BlockEditor</code>类，<code class="fe mv mw mx my b">Element</code>角色对应于<code class="fe mv mw mx my b">Block</code>接口。当然，<code class="fe mv mw mx my b">ConcreteElement</code>角色对应的是具体的<code class="fe mv mw mx my b">Block</code>类。所以块编辑器的访问者，最终访问的数据是<code class="fe mv mw mx my b">BlockEditor</code>对象中的<code class="fe mv mw mx my b">blocks</code>数据。</p><p id="5f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解下面的代码，我们先来看看相应的UML图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4125e53fe77aca684c3219ba74bd851b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5QCJN_FltnJi3bD6.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/0f56a3f9c6d4c9fba1a45fecf66b5ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FFzruS37gFKqWX_c.png"/></div></div></figure><p id="c4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来定义一下<code class="fe mv mw mx my b">BlockVisitor</code>接口:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="3e14" class="nd ne it my b be nf ng l nh ni">interface BlockVisitor {<br/>  visitHeadBlock(block: HeaderBlock): void;<br/>  visitParagraphBlock(block: ParagraphBlock): void;<br/>  visitImageBlock(block: ImageBlock): void;<br/>}</span></pre><p id="8b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的接口中，我们定义了3种不同的方法，用于访问不同类型的块对象。现在我们有了<code class="fe mv mw mx my b">BlockVisitor</code>接口，让我们更新之前定义的<code class="fe mv mw mx my b">Block</code>接口:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="a36e" class="nd ne it my b be nf ng l nh ni">class HeaderBlock implements Block { <br/>  type = "header";<br/>  constructor(public data: HeadBlockData) {}<br/><br/>  accept(visitor: BlockVisitor) {<br/>    visitor.visitHeadBlock(this);<br/>  }<br/>}<br/><br/>class ParagraphBlock implements Block { <br/>  type = "paragraph";<br/>  constructor(public data: ParagraphBlockData) {}<br/><br/>  accept(visitor: BlockVisitor) {<br/>    visitor.visitParagraphBlock(this);<br/>  }<br/>}<br/><br/>class ImageBlock implements Block { <br/>  type = "image";<br/>  constructor(public data: ImageBlockData) {}<br/>  <br/>  accept(visitor: BlockVisitor) {<br/>    visitor.visitImageBlock(this);<br/>  }<br/>}</span></pre><p id="6e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，不同<code class="fe mv mw mx my b">Block</code>类的<code class="fe mv mw mx my b">accept</code>方法实现也很简单，即调用<code class="fe mv mw mx my b">visitor</code>对象的<code class="fe mv mw mx my b">visitXXX</code>方法来访问当前块对象。比如<code class="fe mv mw mx my b">ImageBlock</code>类中的<code class="fe mv mw mx my b">accept</code>方法就是调用<code class="fe mv mw mx my b">visitor.visitImageBlock</code>方法来访问当前的<code class="fe mv mw mx my b">ImageBlock</code>对象。</p><p id="6b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新了具体的块类后，就需要实现块编辑器导出HTML文本的功能。我们可以基于<code class="fe mv mw mx my b">BlockVisitor</code>接口实现一个HTML访问者— <strong class="lb iu"> HtmlVisitor </strong>:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="9368" class="nd ne it my b be nf ng l nh ni">class HtmlVisitor implements BlockVisitor {<br/>  htmlStr = "";<br/>  visitHeadBlock(block: HeaderBlock): void {<br/>    const { level, text } = block.data;<br/>    this.htmlStr += `&lt;h${level}&gt;${text}&lt;/h${level}&gt;`;<br/>  }<br/>  visitParagraphBlock(block: ParagraphBlock): void {<br/>    const { text } = block.data;<br/>    this.htmlStr += `&lt;p&gt;${text}&lt;/p&gt;`;<br/>  }<br/>  visitImageBlock(block: ImageBlock): void {<br/>    const { url, caption } = block.data;<br/>    this.htmlStr += `&lt;img src="${url}" alt="${caption}" /&gt;`;<br/>  }<br/>}</span></pre><p id="986b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mv mw mx my b">HtmlVisitor</code>类中，我们将之前<strong class="lb iu"> switch…case </strong>分支中的不同处理逻辑封装成不同的方法。对于前面提到的支持<strong class="lb iu"> Markdown </strong>格式文本导出的功能，我们只需要实现一个<strong class="lb iu"> Markdown visitor </strong> — <code class="fe mv mw mx my b">MarkdownVisitor</code>:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="bdf4" class="nd ne it my b be nf ng l nh ni">class MarkdownVisitor implements BlockVisitor {<br/>  mdStr = "";<br/>  visitHeadBlock(block: HeaderBlock): void {<br/>    const { level, text } = block.data;<br/>    this.mdStr += `${"#".repeat(level)} ${text}\r\n`;<br/>  }<br/>  visitParagraphBlock(block: ParagraphBlock): void {<br/>    const { text } = block.data;<br/>    this.mdStr += `${text}\r\n`;<br/>  }<br/>  visitImageBlock(block: ImageBlock): void {<br/>    const { url, caption } = block.data;<br/>    this.mdStr += `![${caption}](${url})`;<br/>  }<br/>}</span></pre><p id="1b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了<code class="fe mv mw mx my b">HtmlVisitor</code>和<code class="fe mv mw mx my b">MarkdownVisitor</code>类，块编辑器还需要最后一步来支持以HTML和Markdown格式导出文本。也就是说，我们还需要向<code class="fe mv mw mx my b">BlockEditor</code>类添加一个<code class="fe mv mw mx my b">accept</code>方法，用于迭代内部块数组并提供访问者访问。</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="f878" class="nd ne it my b be nf ng l nh ni">class BlockEditor {<br/>  blocks: Array&lt;Block&gt; = [];<br/>  // Omit some code<br/><br/>  accept(visitor: BlockVisitor) {<br/>    this.blocks.forEach((block) =&gt; {<br/>      block.accept(visitor);<br/>    });<br/>  }<br/>}</span></pre><p id="e9aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们验证一下<code class="fe mv mw mx my b">BlockEditor</code>导出HTML和Markdown格式文本的能力:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="87e4" class="nd ne it my b be nf ng l nh ni">const htmlVisitor = new HtmlVisitor();<br/>blockEditor.accept(htmlVisitor);<br/>console.log(htmlVisitor.htmlStr);<br/><br/>const mdVisitor = new MarkdownVisitor();<br/>blockEditor.accept(mdVisitor);<br/>console.log(mdVisitor.mdStr);</span></pre><p id="1aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功运行上述代码后，相应的输出如下:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="c434" class="nd ne it my b be nf ng l nh ni">&lt;h1&gt;Hello Bytefer!&lt;/h1&gt;&lt;p&gt;Learn Visitor Pattern!&lt;/p&gt;&lt;img src="https://miro.medium.com/fit/c/176/176/1*krjVh9VFhDEcMUif4Ewt-A.png" alt="bytefer-avatar" /&gt;<br/># Hello Bytefer!<br/>Learn Visitor Pattern!<br/>![bytefer-avatar](https://miro.medium.com/fit/c/176/176/1*krjVh9VFhDEcMUif4Ewt-A.png)</span></pre><p id="9b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后如果添加其他导出方法，只需要创建一个实现<code class="fe mv mw mx my b">BlockVisitor</code>接口的visitor类，然后通过<code class="fe mv mw mx my b">BlockEditor</code>对象的<code class="fe mv mw mx my b">accept</code>方法接收新添加的visitor对象。</p><p id="b640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们来比较一下不使用visitor模式导出HTML的功能和使用visitor模式的区别:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/430d69033b037c06188f9e9a7afc78ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPKqG2mj_X8vnJpQF5jzKA.jpeg"/></div></div></figure><p id="2159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数web开发人员应该熟悉Babel，它是一个JavaScript编译器。Babel项目为不同的功能提供了多个核心库:</p><ul class=""><li id="2577" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><strong class="lb iu">@ Babel/parser:</strong>Babel parser，用于解析JavaScript代码；</li><li id="b3f6" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">@ babel/traverse:</strong>Traverser，用于遍历解析器生成的AST对象；</li><li id="626d" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> @babel/generator: </strong>基于AST对象生成相应代码的代码生成器。</li></ul><p id="35ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先来看看<strong class="lb iu"> @babel/parser、@babel/traverse和@babel/generator </strong>的简单用法:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="9794" class="nd ne it my b be nf ng l nh ni">const parser = require("@babel/parser");<br/>const traverse = require("@babel/traverse").default;<br/>const generate = require("@babel/generator").default;<br/><br/>const code = `function square(n) {<br/>  return n * n;<br/>}`;<br/><br/>const ast = parser.parse(code);<br/><br/>traverse(ast, {<br/>  FunctionDeclaration(path) {<br/>    path.node.id.name = "Square";<br/>  },<br/>});<br/><br/>console.log(generate(ast).code);</span></pre><p id="6cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功运行上述代码后，相应的输出如下:</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="ee1d" class="nd ne it my b be nf ng l nh ni">function Square(n) {<br/>  return n * n;<br/>}</span></pre><p id="7afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，利用Babel提供的函数，我们可以很容易地将<code class="fe mv mw mx my b">square</code>函数的名称改为<code class="fe mv mw mx my b">Square</code>。其中，<code class="fe mv mw mx my b">traverse</code>方法用于遍历AST对象上的各个节点。</p><pre class="kj kk kl km gt mz my na bn nb nc bi"><span id="1031" class="nd ne it my b be nf ng l nh ni">- FunctionDeclaration:<br/>  - id:<br/>    - Identifier:<br/>      - name: square<br/>  - params [1]<br/>    - Identifier<br/>      - name: n<br/>  - body:<br/>    - BlockStatement<br/>      - body [1]<br/>        - ReturnStatement<br/>          - argument<br/>            - BinaryExpression<br/>              - operator: *<br/>              - left<br/>                - Identifier<br/>                  - name: n<br/>              - right<br/>                - Identifier<br/>                  - name: n</span></pre><p id="d2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:你可以使用<a class="ae ky" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank">astexplorer.net</a>在线工具来可视化AST对象。</p><p id="20ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果想了解Babel支持的所有AST节点类型，可以看一下这个<a class="ae ky" href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md" rel="noopener ugc nofollow" target="_blank"> AST规范</a>。此外，我们使用<strong class="lb iu"> VSCode </strong>提供的断点调试功能来查看在前面的示例中执行<code class="fe mv mw mx my b">FunctionDeclaration</code>方法时的调用堆栈:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/288c3d766fef61b53d6aed0e182c19ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BBl5xagNVDVrNSRc.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/12799c3f172d4947a1f88c647178fdbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WhBPrqjvn3U0sjpg.png"/></div></div></figure><p id="7a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察上面的调用栈，就能理解一般的执行流程。如果你对具体的执行过程感兴趣，可以看一下<a class="ae ky" href="https://github.com/babel/babel/tree/main/packages/babel-traverse" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> @babel/traverse </strong> </a>包的源代码。我用一张图来概括一下上面的过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/75446a776cec13c9fe6d227b4649769b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jbK3i8eXhKvDvpCOTkhsQ.jpeg"/></div></div></figure><p id="be82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问者设计模式可以将数据操作与数据结构分离开来。例如，在块编辑器中，<code class="fe mv mw mx my b">BlockEditor</code>类只负责管理不同的块，将导出HTML和Markdown格式文档的逻辑分离给独立访问者。</p><p id="392d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的好处是，以后要添加新的函数，只需要添加一个新的访问者，而不需要修改<code class="fe mv mw mx my b">BlockEditor</code>类。对于处理树结构(比如AST和组织树)的场景，您也可以考虑使用访问者设计模式。</p><p id="5ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，访客模式到此结束。我建议你基于我的代码实现不同的访问者或者扩展不同的块。如果您有任何问题，请随时给我留言。稍后我会继续介绍其他模式，如果你有兴趣，可以在<a class="ae ky" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或者<a class="ae ky" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="bbec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想学习打字稿，千万不要错过<strong class="lb iu">掌握打字稿</strong>系列。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">有了40+篇文章，学习TypeScript就不会迷茫了</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="oi l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>