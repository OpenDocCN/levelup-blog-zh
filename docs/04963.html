<html>
<head>
<title>Web Component Solutions: A Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件解决方案:比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/web-component-solutions-a-comparison-e2fa25c34730?source=collection_archive---------0-----------------------#2020-07-27">https://levelup.gitconnected.com/web-component-solutions-a-comparison-e2fa25c34730?source=collection_archive---------0-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/3285fe3f0be9ddac2ede53e113b21625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Yng0DRkD5sRpNu0M3QJjig.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">Web组件徽标</figcaption></figure><p id="1842" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“不要重复自己。”每个程序员在第一次学习编码时都有这个概念。任何时候你发现自己的代码在几个地方重复，是时候把代码抽象成一个类或函数了。但是这如何应用于用户界面呢？如何避免一遍又一遍的重写同一个HTML和CSS？</p><p id="f8f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您使用的是Angular这样的UI框架或React这样的UI库，答案很简单:构建一个组件。组件是HTML、CSS和JavaScript的一部分，以一种易于重用的方式组合在一起。</p><p id="6984" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果你没有使用Angular，React，Vue，或者其他什么最新最好的JavaScript框架呢？如果你写的是普通的HTML、CSS和JavaScript呢？或者，如果您想编写一个与框架无关的组件，并且可以在任何web应用程序中使用，而不管它是用什么语言编写的，该怎么办？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ce09" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Web组件</h1><p id="7223" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">输入<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> web组件</a>。Web组件允许您创建具有封装功能的自定义元素，这些元素可以在任何地方重用。它们是使用<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template" rel="noopener ugc nofollow" target="_blank">模板</a>和<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot" rel="noopener ugc nofollow" target="_blank">槽</a>创建的，并在<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">影子DOM </a>中定义，影子DOM将元素的样式和脚本与DOM的其余部分隔离开来，以避免冲突。</p><p id="efad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Web组件可以使用大多数主流浏览器提供的本机浏览器API来构建，也可以使用所谓的web组件库来创建:作为浏览器API之上的抽象的解决方案，有助于简化web组件的编写。</p><p id="c675" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将比较几种不同的web组件解决方案:native <a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> web组件</a>、<a class="ae mj" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank"> Svelte </a>、<a class="ae mj" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank"> Stencil </a>、<a class="ae mj" href="https://lit-element.polymer-project.org/" rel="noopener ugc nofollow" target="_blank"> LitELement </a>和<a class="ae mj" href="https://developer.salesforce.com/docs/component-library/documentation/lwc" rel="noopener ugc nofollow" target="_blank"> Lightning Web组件(LWC) </a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3ee3" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">标准</h1><p id="7e20" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在评估这些解决方案时，有一套明确的标准是很有帮助的。我们将研究每个解决方案，同时关注以下内容:</p><ul class=""><li id="fec0" class="mk ml it kd b ke kf ki kj km mm kq mn ku mo ky mp mq mr ms bi translated">发布年份</li><li id="9db4" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">流行</li><li id="5eea" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">许可证</li><li id="6775" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">语法风格(声明式与命令式)</li><li id="6695" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">需要编译器或运行时</li><li id="550d" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">浏览器支持</li><li id="ae64" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">测试策略</li><li id="d5df" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">文件质量</li><li id="d77f" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">相对束尺寸</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7a01" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">本机Web组件</h1><p id="ca30" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">让我们首先从<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank">本地web组件</a>开始——即使用浏览器API构建的web组件，没有额外的框架或库。</p><p id="6195" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Web组件于2011年首次推出。与每项新技术一样，web浏览器需要时间来跟上和实现新提出的API和标准，因此web组件需要一段时间来获得牵引力。今天，大多数evergreen浏览器都支持web组件。Chrome、Firefox、Edge和Opera都支持web组件。Safari提供部分支持。在Internet Explorer中，不支持web组件(惊喜，惊喜)。</p><p id="9b82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为这是我们正在谈论的本地web功能，所以文档非常好。你可以在MDN 上找到关于如何构建和实现web组件的规范和教程的<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank">资源。</a></p><p id="378e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用普通web组件的另一个好处是，你不需要引入另一个库、编译器、运行时或任何其他构建工具。Web组件只是工作(只要浏览器支持)。</p><p id="6f5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了缺乏完整的浏览器支持，原生web组件的一个缺点是它们是使用命令式风格编写的。换句话说，您必须告诉组件如何执行每个步骤，包括重新呈现或更新DOM中的内容。那些喜欢声明式编写React组件的人可能会对本地web组件感到失望。</p><p id="651d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了减轻这种痛苦，出现了许多web组件库来提供对本地浏览器API的抽象。这些库在创建新的web组件时提供了更好的开发人员体验，并且通常包括允许web组件在不支持开箱即用的浏览器中工作的polyfills。我们将在本文接下来的几节中考虑其中的一些web组件库。</p><p id="3818" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在这里找到一个本地web组件实现的<a class="ae mj" href="https://webcomponents.dev/edit/ssbYKxUnqWP2AdOWvV1O" rel="noopener ugc nofollow" target="_blank">示例</a>。该守则全文转载如下:</p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f582" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，通过扩展<code class="fe ne nf ng nh b">HTMLElement</code>类来定义一个定制的web组件。HTML和CSS在类体中内联定义，然后通过修改<code class="fe ne nf ng nh b">shadowRoot</code>的HTML内容插入到影子DOM中。因为代码是命令式编写的，所以可以看到定义了一个<code class="fe ne nf ng nh b">update</code>方法，用于在必要时处理DOM内容的更新。生命周期回调方法也可用于安装和拆卸，这可以在附加和移除<code class="fe ne nf ng nh b">connectedCallback</code>和<code class="fe ne nf ng nh b">disconnectedCallback</code>方法中的事件监听器时看到。最后，使用<code class="fe ne nf ng nh b">customElements.define</code>方法将组件注册到应用程序的其余部分，这允许您提供一个HTML标记名并将其链接到您的类。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b5c0" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">苗条的</h1><p id="bf9d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated"><a class="ae mj" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank"> Svelte </a>于2016年发布，作为一种简单优雅的web组件编写方式。它允许您以声明性的方式编写组件，并为您处理更新DOM的命令性的一步一步的指令。苗条的组件写在以<code class="fe ne nf ng nh b">.svelte</code>扩展名结尾的文件中，这是一种定制的文件类型，允许你在同一个文件中包含HTML、CSS和JavaScript。Svelte没有运行时，这意味着它在编译时将组件编译成浏览器可以理解的代码。这样做的好处是很少或没有增加应用包大小的开销。</p><p id="f827" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在撰写本文时，Svelte拥有来自NPM的65，043次每周下载，使其成为目前最受欢迎的web组件库之一。它的文档也很优秀，包括<a class="ae mj" href="https://svelte.dev/tutorial/basics" rel="noopener ugc nofollow" target="_blank">互动教程</a>，带你了解你想知道的一切。Svelte甚至自带动画工具！</p><p id="7a1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Svelte有一个不断增长的社区，这意味着有很多人学习Svelte，并创建第三方组件和插件供他人使用。你可以在这里找到<a class="ae mj" href="https://svelte-community.netlify.app/code/" rel="noopener ugc nofollow" target="_blank">苗条开源项目的列表</a>。</p><p id="d4ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管有这么多好处，苗条身材确实有一些需要克服的弱点，这在他们的<a class="ae mj" href="https://svelte.dev/faq" rel="noopener ugc nofollow" target="_blank">常见问题</a>中有所涉及。在你的IDE中用`. svelte `文件进行语法高亮显示仍然不是完美的。他们也没有提供推荐的测试策略——当前的方法是编译每个组件，然后使用您选择的测试库将其安装到DOM。另外，<a class="ae mj" href="https://github.com/sveltejs/svelte/issues/558" rel="noopener ugc nofollow" target="_blank"> Svelte并没有宣传它支持什么浏览器</a>。看来您需要自己解决这个问题，并提供您最终需要的任何polyfills，尤其是如果您计划支持IE11的话。</p><p id="d489" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在这里找到一个web组件实现的例子。该守则全文转载如下:</p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="63b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，所有的HTML、CSS和JavaScript都包含在同一个<code class="fe ne nf ng nh b">.svelte</code>文件中，看起来非常像普通的HTML，而不是JSX式的语法。元件标签名称在第一行定义。使用<code class="fe ne nf ng nh b">on:event-name</code>语法将事件处理程序附加到HTML元素上，并且当状态改变时，UI会反应性地更新——很好，而且是声明性的！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2420" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">蜡纸</h1><p id="e77e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated"><a class="ae mj" href="https://getstencil.com/" rel="noopener ugc nofollow" target="_blank"> Stencil </a>是UI/UX设计师常用的在线图形设计工具。2017年，<a class="ae mj" href="https://ionicframework.com/" rel="noopener ugc nofollow" target="_blank"> Ionic Framework </a>团队发布了面向开发者的工具<code class="fe ne nf ng nh b">@stencil/core</code>。像Svelte一样，Stencil只是一个编译器，所以不需要运行时。编译器创建浏览器可以理解的web组件，甚至根据需要包括polyfills，以便您的代码可以在所有主流浏览器中运行，包括IE11。</p><p id="d234" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">模板组件是用TypeScript编写的，这可能会让你兴奋，也可能会让你大倒胃口，这取决于你对在JavaScript中添加类型的看法。它们也是使用JSX和声明式风格编写的，所以感觉非常像在React中编写组件。</p><p id="9561" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Stencil目前显示NPM每周有25，568次下载，虽然不如Svelte受欢迎，但仍然是一个受欢迎的选择。Stencil吹嘘它被苹果、亚马逊和微软等公司使用，暗示它是一个久经考验的解决方案。<a class="ae mj" href="https://stenciljs.com/docs/introduction" rel="noopener ugc nofollow" target="_blank"> Stencil的文档</a>也非常优秀，甚至提供了如何将Stencil生成的组件整合到Angular、React或Vue应用程序中的说明。</p><p id="61e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了<a class="ae mj" href="https://stenciljs.com/docs/unit-testing" rel="noopener ugc nofollow" target="_blank">测试模板组件</a>，他们的文档推荐使用<code class="fe ne nf ng nh b">@stencil/core/testing</code>包中的Jest和模板测试工具方法。</p><p id="a79d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在这里找到一个<a class="ae mj" href="https://webcomponents.dev/edit/1beAhuWbhB2THaFGLI7q" rel="noopener ugc nofollow" target="_blank">模板web组件实现的例子。该守则全文转载如下:</a></p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5782" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">web元素是通过一个类定义的，但它不像本机web组件实现那样扩展任何基类。取而代之的是使用一个<code class="fe ne nf ng nh b">@Component</code>装饰器，它提供标签名、可以找到样式的位置，以及组件是否应该放在影子DOM中。组件状态使用<code class="fe ne nf ng nh b">@State</code>装饰器实现，HTML内容写在<code class="fe ne nf ng nh b">render</code>方法中。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0649" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">文学元素</h1><p id="9f10" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">接下来，让我们看看<a class="ae mj" href="https://lit-element.polymer-project.org/" rel="noopener ugc nofollow" target="_blank"> LitElement </a>，谷歌<a class="ae mj" href="https://www.polymer-project.org/" rel="noopener ugc nofollow" target="_blank">聚合物项目</a>的一个产品。LitElement于2018年发布，目前每周从NPM下载95，643次-对于一个只有两年历史的产品来说，这是一个令人印象深刻的统计数据-使其比Svelte和Stencil加起来使用得更广泛。</p><p id="6a06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">LitElement提供了许多我们之前讨论过的好处，比如使用声明性语法，向下编译到符合web组件标准的代码，以及在包括IE11在内的所有主流浏览器中工作。</p><p id="fd7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">LitElement是根据BSD-3-Clause许可证授权的，这是一个相当宽松的许可证(不要与BSD+Patents许可证混淆，BSD+Patents许可证引起了关于React 的<a class="ae mj" href="https://www.freecodecamp.org/news/facebook-just-changed-the-license-on-react-heres-a-2-minute-explanation-why-5878478913b2/" rel="noopener ugc nofollow" target="_blank">争议，直到脸书在2017年将React的许可证改为MIT许可证)。</a></p><p id="943a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样需要注意的是，与Svelte和Stencil不同，LitElement本身不是编译器。文档将LitElement描述为使用lit-html模板构建web组件的库(<a class="ae mj" href="https://lit-html.polymer-project.org/guide" rel="noopener ugc nofollow" target="_blank"> lit-html </a>是Polymer Project的另一个产品，用作html模板库)。所以为了使用LitElement创建的web组件，你首先需要用Babel和Rollup或者Webpack 编译它们。</p><p id="5ee4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于测试，LitElement文档推荐使用<a class="ae mj" href="https://open-wc.org/testing/testing.html" rel="noopener ugc nofollow" target="_blank"> Open WC测试库</a>，这是一个用于测试web组件的通用库。</p><p id="2a8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在这里找到一个LitElement web组件实现的例子。该守则全文转载如下:</p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1538" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的代码风格看起来像是本地web组件和模板组件的结合。定义了一个扩展基本<code class="fe ne nf ng nh b">LitElement</code>类的类。HTML内容在一个<code class="fe ne nf ng nh b">render</code>方法中提供，并被包装在一个由<code class="fe ne nf ng nh b">lit-html</code>包使用的模板文本中。使用<code class="fe ne nf ng nh b">@event-name</code>语法附加事件处理程序。最后，就像本地web组件一样，新组件通过<code class="fe ne nf ng nh b">customElements.define</code>方法注册。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5027" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">闪电网络组件(LWC)</h1><p id="916f" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">最后，让我们考虑闪电网络组件，或LWC。LWC是这个模块上的新成员，这是<a class="ae mj" href="https://www.salesforce.com/company/news-press/press-releases/2019/05/192915-e/" rel="noopener ugc nofollow" target="_blank"> Salesforce在2019年</a>开源的产品。作为较新的解决方案，LWC每周只有1383次来自NPM的下载，远远少于我们目前考虑的其他web组件解决方案。</p><p id="9df0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">LWC看起来与我们探索的其他解决方案相似，因为代码是以声明方式编写的。它还支持所有主流浏览器的最新版本，包括IE11。</p><p id="ef08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与其他库的一个不同之处是，LWC包括一个运行时，这意味着你有一个额外的脚本在页面上运行，以帮助你的应用程序工作，类似于你需要在浏览器中的React应用程序旁边包括React库。这意味着您的用户需要下载额外的代码，但是只有7kB，LWC运行时非常小。</p><p id="0a75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mj" href="https://lwc.dev/guide/introduction" rel="noopener ugc nofollow" target="_blank">他们的文档</a>提供了一些很好的解释，并明确说明了如何<a class="ae mj" href="https://lwc.dev/guide/test" rel="noopener ugc nofollow" target="_blank">测试你的LWC应用</a>，这非常有用。它们还包括一个关于可访问性的<a class="ae mj" href="https://lwc.dev/guide/accessibility" rel="noopener ugc nofollow" target="_blank">指南。</a>虽然不是必需的，但很高兴看到LWC开发团队重视可访问性，并认为值得在他们的文档中注明。总的来说，对于寻求稳定的web组件库的组织来说，LWC看起来是个不错的选择。随着时间的推移，看看采用率以及LWC是否能赶上其他web组件解决方案的普及程度将会很有趣。</p><p id="a1da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在这里找到一个LWC web组件实现的例子。该守则全文转载如下:</p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，HTML、CSS和JavaScript使用了三个独立的文件。这些文件在任何地方都不会显式地相互引用。取而代之的是，LWC有一个隐含的契约，即文件名相同但扩展名不同的文件被一起使用。HTML被包装在一个<code class="fe ne nf ng nh b">template</code>标签中，事件处理程序使用您在普通HTML中看到的全部小写的<code class="fe ne nf ng nh b">oneventname</code>语法编写。JavaScript定义了一个扩展<code class="fe ne nf ng nh b">LightningElement</code>的类，然后实现状态和任何方法。有趣的是，没有<code class="fe ne nf ng nh b">render</code>方法，因为HTML被神奇地链接到JavaScript。就像本地web组件和LitElement一样，LWC web组件然后使用文件底部的<code class="fe ne nf ng nh b">customElements.define</code>方法注册。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8963" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="7a8b" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">那么您应该使用哪种web组件解决方案呢？根据您组织的需求来评估这些解决方案是非常重要的。</p><p id="6f81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在比较这些web组件库时，<strong class="kd iu"> Svelte </strong>感觉现在更像是一个实验性的库，可能还没有为企业应用做好准备。Stencil、LitElement和LWC都将自己表现为更适合企业的解决方案，重点是跨浏览器支持和编写单元测试时推荐的测试策略。</p><p id="b2bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">LitElement 看起来是个不错的选择，除了年轻之外没有明显的缺点。</p><p id="3f8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Stencil </strong>似乎与LitElement不相上下，是一个很好的选择，尤其是如果你已经在使用Stencil进行设计或者喜欢使用TypeScript的话。</p><p id="6904" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，如果您正在使用或可能在未来使用Salesforce，<strong class="kd iu"> LWC </strong>是显而易见的选择，因为它可以轻松地与其他Salesforce工作流和框架集成，例如使用Lightning App Builder构建ui或使用Lightning Locker实现安全性。对于企业来说，LWC也是一个很好的选择，因为它是开源的，而且有大公司的支持。如果您喜欢成为新的web组件技术趋势的早期采用者，不喜欢JSX语法，或者喜欢将HTML、CSS和JavaScript代码保存在单独的文件中，您也可以考虑LWC。</p><p id="5b4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一点似乎很清楚:使用web组件库而不是原生浏览器API将提供更好的开发体验以及更健壮和跨浏览器友好的解决方案。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b537" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">最后一点</h1><p id="5a9d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在研究每一个解决方案时，我都尽可能不偏不倚，使用预先定义的标准来评估每一个解决方案。为了快速参考，我在下面附上了一张总结我的发现的图表。</p><p id="ed4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想探索更多的web组件解决方案，<a class="ae mj" href="https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component-april2020/" rel="noopener ugc nofollow" target="_blank">这篇博客文章</a>提供了对30个web组件实现的深入研究。</p><p id="1095" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fdca" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Web组件解决方案比较</h1><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/e908e084fe70287c9bc71b49239fa1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHJ9expjGrDOukS8deklQA.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">Web组件解决方案比较表</figcaption></figure><p id="0866" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">*捆绑包大小基准比较可以在这里找到:<a class="ae mj" href="https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component-april2020/" rel="noopener ugc nofollow" target="_blank">https://web components . dev/blog/all-The-ways-to-make-a-web-component-April 2020/</a></p></div></div>    
</body>
</html>