<html>
<head>
<title>Sessions with a React/Redux Frontend and Rails API Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有React/Redux前端和Rails API后端的会话</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sessions-with-a-react-redux-frontend-and-rails-api-backend-25b7b951b287?source=collection_archive---------1-----------------------#2020-10-23">https://levelup.gitconnected.com/sessions-with-a-react-redux-frontend-and-rails-api-backend-25b7b951b287?source=collection_archive---------1-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f0fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我最近的项目中，我开发了一个名为EduSource的应用程序，允许父母众包在线教育资源并组织它们(在<a class="ae kl" href="https://github.com/charlie763/edu-source" rel="noopener ugc nofollow" target="_blank"> github </a>或<a class="ae kl" href="https://edusource.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> live </a>上查看)。想想Pinterest的教育资源。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/920deae0fab28853d4c912dad6ebd71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_50rzb34MbXxCJhNJ-l2jA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">登录在主屏幕上得到提示</figcaption></figure><p id="dc1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我接受的一个更大的挑战是用解耦的前端/后端管理会话。如果一切都在Rails中，那么RAILS使会话变得非常容易处理，但是当您使用不同的系统来管理前端行为时，尤其是当前端和后端之间的交互是异步的时，就会变得稍微复杂一些。</p><p id="c4b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可悲的是，我无法找到一个明确的指南，涵盖所有你需要知道的事情，使这一工作。相反，我根据三个不同的来源整合了一个解决方案:</p><ol class=""><li id="1a56" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae kl" href="https://pragmaticstudio.com/tutorials/rails-session-cookies-for-api-authentication" rel="noopener ugc nofollow" target="_blank"> Mike Clark的概述</a>您想要的总体流程</li><li id="1c5a" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://dev.to/kahawaiikailana/rails-api-quickstart-guide-with-postgressql-and-jwt-tokens-3pnk" rel="noopener ugc nofollow" target="_blank"> Kailana Kahawaii关于使用Rails设置JSON Web令牌(JWT)的概述</a></li><li id="f2fb" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://www.jmfurlott.com/handling-user-session-react-context/" rel="noopener ugc nofollow" target="_blank"> JMFurlott关于使用JavaScript Cookies在React中存储和利用会话数据的指南</a></li></ol><p id="c5be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">！！警告！！—这是初学者的解决方案。我猜这不是最安全的解决方案。相反，它是一个适度安全的解决方案，我希望它对于刚刚学习如何实现安全会话的初学者来说更容易理解。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="d315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">步骤1:在Rails API后端设置JWT</em></p><p id="606d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，你需要安装JWT宝石。所以，在你的gem文件中放入<code class="fe ly lz ma mb b">gem “jwt”, “~&gt; 2.2” </code>，然后再放入<code class="fe ly lz ma mb b">bundle install</code>。</p><p id="ea1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，您需要生成并安全地存储SESSION_SECRET，这是一个加密的安全密钥，您将使用它来生成令牌。有多种方法可以生成并安全地存储该密钥。例如，上面引用的文章使用了JWT生成器网站和rails凭证。我使用Ruby的SecureRandom gem生成密钥，并使用dotenv gem将其存储在我的Rails环境中。首先设置您的存储环境很有帮助。将<code class="fe ly lz ma mb b">gem ‘dotenv-rails’</code>放入您的gemfile，<code class="fe ly lz ma mb b">bundle install</code>，然后在您的根目录下创建一个. env文件，并将<code class="fe ly lz ma mb b">.env</code>放入您的。gitignore文件(这样你就不会把你的秘钥上传到github)。现在，安装securerandom后，您可以运行</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="867c" class="mg mh iq mb b gy mi mj l mk ml">ruby -e “require ‘sysrandom/securerandom’; puts SecureRandom.hex(64)”</span></pre><p id="de0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从终端生成密钥。复制并粘贴此密钥，并将其保存在您的。env文件如下:</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="ad6f" class="mg mh iq mb b gy mi mj l mk ml">SESSION_SECRET = [insert the key you just generated]</span></pre><p id="bd44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剩下的，我公然从上面的文章中剽窃，减去交换掉函数<code class="fe ly lz ma mb b">jwt_key</code>的返回值，从。env文件而不是rails凭证。你可以把下面的代码放在你的<code class="fe ly lz ma mb b">ApplicationController</code>中，其他控制器可以继承，或者你可以创建一个助手模块。我做了前者。</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="f779" class="mg mh iq mb b gy mi mj l mk ml">def jwt_key<br/>  ENV[‘SESSION_SECRET’]<br/>end</span><span id="adde" class="mg mh iq mb b gy mm mj l mk ml">def issue_token(user)<br/>  JWT.encode({user_id: user.id}, jwt_key, ‘HS256’)<br/>end</span><span id="6193" class="mg mh iq mb b gy mm mj l mk ml">def decoded_token<br/>  begin<br/>    JWT.decode(token, jwt_key, true, { :algorithm =&gt; ‘HS256’ })<br/>  rescue JWT::DecodeError<br/>    [{error: “Invalid Token”}]<br/>  end<br/>end</span><span id="9f80" class="mg mh iq mb b gy mm mj l mk ml">def token<br/>  request.headers[‘Authorization’]<br/>end</span><span id="6c0a" class="mg mh iq mb b gy mm mj l mk ml">def user_id<br/>  decoded_token.first[‘user_id’]<br/>end</span><span id="717f" class="mg mh iq mb b gy mm mj l mk ml">def current_user<br/>  user ||= User.find_by(id: user_id)<br/>end</span><span id="3602" class="mg mh iq mb b gy mm mj l mk ml">def logged_in?<br/>  !!current_user<br/>end</span></pre><p id="726b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当创建一个用户时，您可以简单地调用<code class="fe ly lz ma mb b">issue_token</code>函数，当授权一个用户时，调用<code class="fe ly lz ma mb b">current_user</code>函数将返回一个非零值，只要有一个有效的令牌。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="2354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">步骤2:设置会话/用户存储</em></p><p id="6c20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大概有各种各样的方法可以做到这一点。我使用Redux并创建了一个<code class="fe ly lz ma mb b">usersReducer</code>来设置和处理用户数据模型的存储。我的代码假设对Redux的工作原理有一些了解，但是如果不使用Redux，也可以将这些数据保存在state中。重要的信息是我建立的商店具有以下数据结构:</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="94a9" class="mg mh iq mb b gy mi mj l mk ml">state = {<br/>  {…your other data models},<br/>  user: {<br/>    current: {},<br/>    valid: true,<br/>    authCompleted: false,<br/>    errors: {}<br/>  }</span></pre><p id="dbf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，<code class="fe ly lz ma mb b">user.current</code>将存储有效的用户对象，<code class="fe ly lz ma mb b">user.valid</code>表示对用户进行认证和授权的结果，<code class="fe ly lz ma mb b">user.authCompleted</code>告诉您是否已经进行了认证过程，以查看是否存在有效用户。我将<code class="fe ly lz ma mb b">user.valid</code>默认为<code class="fe ly lz ma mb b">true</code>,以避免意外重定向到登录屏幕。然而，可能有一个更好的解决方案，我怀疑默认设置<code class="fe ly lz ma mb b">user.valid</code>为<code class="fe ly lz ma mb b">false</code>会更安全，而不是像我一样，每当一个auth进程启动时就这样设置。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="bf8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">第三步:登录/注册您的用户</em></p><p id="081c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里就不一一赘述了。我就给个提纲吧。重要的是安装js-cookie包，导入该功能，用从Rails API后端返回的JWT值设置cookie，然后相应地更新您的存储。完成这项工作所需的一些代码如下:</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="afa7" class="mg mh iq mb b gy mi mj l mk ml">npm install js-cookie </span></pre><p id="dc39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从终端，以及:</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="27e2" class="mg mh iq mb b gy mi mj l mk ml">import * as Cookies from ‘js-cookie’</span></pre><p id="406a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在管理cookies的React文件的顶部。对我来说，这是一个管理所有与用户活动相关的派单的<code class="fe ly lz ma mb b">usersActions</code>文件。</p><p id="6e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向API后端发送获取请求后，如果用户数据有效，就设置cookie。我的会话控制器发回的JSON看起来像这样</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="d15b" class="mg mh iq mb b gy mi mj l mk ml">{<br/>  valid: true, <br/>  user: {id: 1, username: 'Charlie'}, <br/>  token: '[generated api token here]'<br/>}</span></pre><p id="bd23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我就可以用代码在我的一个<code class="fe ly lz ma mb b">userAcitons</code>函数中设置cookie了:</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="3523" class="mg mh iq mb b gy mi mj l mk ml">Cookies.remove('eduResourceSession')<br/>Cookies.set('eduResourceSession', jsonData.token, { expires: 14 })</span></pre><p id="31cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ly lz ma mb b">'eduResourceSession’</code>指的是被存储的cookie的名称，但这可以是任何东西，<code class="fe ly lz ma mb b">Cookies.set()</code>中的第二个参数将cookie的值设置为返回的令牌。</p><p id="c6a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是根据返回的内容更新您的商店/状态。如果用户有效，设置<code class="fe ly lz ma mb b">user.valid</code>为<code class="fe ly lz ma mb b">true</code>，设置<code class="fe ly lz ma mb b">user.current</code>为返回的用户数据。无论验证状态如何，将<code class="fe ly lz ma mb b">user.authCompleted</code>设置为<code class="fe ly lz ma mb b">true</code>。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="7e17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">步骤4:如果未授权，重定向用户登录</em></p><p id="9951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我的react应用程序中的用户相关组件，我将插入以下代码:</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="10c4" class="mg mh iq mb b gy mi mj l mk ml">componentDidMount(){<br/>  this.props.authUser()<br/>}</span></pre><p id="cba1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<code class="fe ly lz ma mb b">authUser()</code>是向API会话控制器发出获取请求的函数，该请求包括在<code class="fe ly lz ma mb b">Authorization</code>报头中的令牌，并且如果控制器返回有效用户，则将状态设置为<code class="fe ly lz ma mb b">user.valid = true</code>。</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="9c29" class="mg mh iq mb b gy mi mj l mk ml">function authUser(){<br/>  let token = Cookies.get("eduResourceSession")<br/>  return dispatch =&gt; {<br/>    dispatch({type: "START_AUTH"})<br/>    if (token){<br/>      const configObj = {<br/>        method: 'GET',<br/>        headers: {<br/>          'Content-Type': 'application/json',<br/>          Accept: 'application/json',<br/>          Authorization: token<br/>        },<br/>        credentials: 'include'<br/>      }<br/>      fetch(BASE_URL.concat('/authorize'), configObj)<br/>        .then(resp =&gt; resp.json())<br/>        .then(authResp =&gt; {<br/>          if (authResp.valid === "true"){<br/>            dispatch({type: "LOGIN_USER", user: authResp.user})<br/>          } else {<br/>            dispatch({type: "INVALID_USER", errors: {session: "Please login to continue"}})<br/>          }<br/>     })<br/>   } else {<br/>     dispatch({type: "INVALID_USER", errors: {session: "Please login to continue"}})<br/>   }<br/>  dispatch({type: "COMPLETE_AUTH"})<br/>}</span></pre><p id="36c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另请注意请求对象中的<code class="fe ly lz ma mb b">credentials: 'include'</code>。如果您从前端向后端发出跨来源请求，这在生产中变得很重要。</p><p id="dc42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这之后，我会在我的<code class="fe ly lz ma mb b">render()</code>函数的顶部放一些逻辑在任何我不想让用户在没有登录的情况下看到的组件中:</p><pre class="kn ko kp kq gt mc mb md me aw mf bi"><span id="f6cf" class="mg mh iq mb b gy mi mj l mk ml">if (this.props.user.valid){ <br/>  return &lt;Component/&gt;<br/>} else {<br/>  return &lt;Redirect to=’/login’/&gt;`<br/>}</span></pre><p id="df4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当状态改变时，组件重新呈现，因此当<code class="fe ly lz ma mb b">user.authCompleted </code>在授权过程中改变时，组件重新呈现并再次检查用户是否有效。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="33a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">步骤5:向后端API发出请求时授权用户</em></p><p id="6bc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是，每当您向后端发出请求，要求对用户进行授权时，就对用户进行授权。对于我的应用程序来说，这仅限于对专门绑定到用户数据模型的数据的POST、PATCH和GET请求。这一步的基本要点是，每当发出一个请求时，从cookies获取令牌，在authorization头中发送它，只有在令牌有效时，才从后端返回数据或向后端发送数据。该代码与步骤4中的代码非常相似，所以我在这里不再赘述。主要区别在于，这个逻辑决定了后端如何响应客户机请求，而不是向客户机呈现什么(如步骤4所述)。如果您发出POST或PATCH请求，auth逻辑也将由表单提交而不是<code class="fe ly lz ma mb b">componentDidMount</code>触发。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="3e35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太多了！我希望这有助于您理解使用React-Redux前端和Rails API后端的会话流。如果您有任何意见、问题或改进，请联系我们！</p></div></div>    
</body>
</html>