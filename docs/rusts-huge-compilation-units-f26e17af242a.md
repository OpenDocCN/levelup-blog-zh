# Rust 庞大的编译单元

> 原文：<https://levelup.gitconnected.com/rusts-huge-compilation-units-f26e17af242a>

布莱恩·安德森

![](img/225a40c9da3dcf66419aa81d20cc271a.png)

Rust 编程语言编译快软件慢。

在这个系列中，我们在 [TiKV](https://github.com/tikv/tikv) 的上下文中探索 Rust 的编译时间，TiKV 是 [TiDB](https://github.com/pingcap/tidb) 数据库背后的键值存储。

# 与 TiKV 的 Rust 编译时冒险:第 3 集

最近我们在探索 Rust 的设计是如何阻碍快速编译的。在[系列的前一篇文章](https://pingcap.com/blog/generics-and-compile-time-in-rust/)中，我们讨论了实现泛型所需的编译时权衡。

这次我们将讨论编译单元。

# 编译单元

一个*编译单元*是一种语言的编译器操作的基本工作单元。在 C 和 C++中，编译单元是一个源文件。在 Java 中，它是一个源文件。在 Rust 中，编译单元是一个*机箱*，由许多文件组成。

编译单元的大小会导致许多权衡。较大的编译单元比较小的编译单元需要更长的时间来分析、翻译和优化。通常，当对单个编译单元进行更改时，必须重新编译整个编译单元。

此外，更小的箱子改善了编译时间的感觉，如果不是总的编译时间的话，因为一个单独的改变可能会减少需要重新编译的项目。这有利于“部分重新编译”用例。由于各种因素，一个有更多箱子的项目可能在完全重新编译上做更多的工作，我将在这篇文章的最后总结这些因素。

铁锈箱不一定要很大，但有多种因素促使它们变大。第一个简单的问题是，将新模块添加到 Rust 项目与将新模块添加到新模块相比，相对复杂。除非对抽象边界给予特别的关注，否则新的 Rust 项目往往会变成一块巨石。

# 依赖图和未搅拌的意大利面条

在一个机箱中，对模块的相互依赖性没有基本的限制，尽管有一些语言特性允许在一个机箱中隐藏一些信息。让模块共存于同一个机箱中的最大优势和风险是它们可以*相互依赖*，两个模块都依赖于从另一个模块导出的名称。这里有一个类似于在 TiKV 中遇到的许多例子，其中`engine`导入(“使用”)`network::Message`，`network`导入`storage::Engine`。

```
mod storage {
  use network::Message; pub struct Engine; impl Engine {
    pub fn handle_message(&self, msg: Message) -> Result<()> { ... }
  }
}mod network {
  use storage::Engine; pub enum Message { ... } struct Server {
    engine: Engine,
  } impl Server {
    fn handle_message(&self, msg: Message) -> Result<()> {
      ... self.engine.handle_message(msg)?; ...
    }
  }
}
```

具有相互依赖性的模块对于降低认知复杂性非常有用，因为它们将代码分解成更小的单元。作为一个抽象的边界，尽管它们是欺骗性的:它们不是真正独立的，并且不能被简单地进一步简化成单独的箱子。

这是因为板条箱之间的*依赖关系必须形成一个有向无环图(DAG)*；它们不支持相互依赖。

Rust crates 之所以笨拙，主要是因为类型检查和架构复杂性的基本原因。如果板条箱允许相互依赖，那么它们将不再是独立的编译单元。

在准备这篇博客时，我问了一些人，他们是否能回忆起为什么 Rust crates 必须形成 DAG，而 [Graydon](https://github.com/graydon) 给出了一个典型的全面而权威的答案:

> *graydon:禁止跨机箱的定义之间的相互递归，允许一个明显确定的自下而上的构建时间表，而不需要做一些定点迭代或从定义中分离声明，并允许需要遍历完整定义的阶段，如类型检查，一次一个机箱地发生(允许*某种程度的增量/并行)。
> 
> *graydon:(一旦你知道你已经看到了一个递归类型中的所有循环，你就可以检查它的有限性，然后在任何装箱的变体处停止扩展它——即使它们穿过板条箱——并在那些装箱的边缘放置一个惰性/占位符定义；但是你要知道那些变种不会循环回来！)*
> 
> *格雷顿:(我不知道 rustc 是否还会做类似的事情)*
> 
> *graydon:高阶模块的周期性问题更严重，我在早期设计时花了很多时间研究这个问题。我见过的大多数系统都要求你在一组相互递归的定义周围画出某种边界，以便能够解决它们，所以板条箱看起来像是一个自然的单元。*
> 
> *graydon:然后还有版本控制的问题，我认为这在我的脑海中是相当沉重的(特别是在单调和 git 的经历之后):如果没有非循环的构造引用，许多版本控制问题实际上是没有意义的。就像如果一个 1.0 依赖于 B 1.0，而 B 1.0 又依赖于 B 2.0，你需要做一些奇怪的、不确定的事情，这些事情可能非常武断，很难向任何人解释，以便解决这些依赖性。*
> 
> graydon:还记得我们希望能够在早期进行热代码加载，这意味着就像版本解析、编译或链接一样，如果你必须加载或卸载的东西有一个自然的拓扑顺序，你就真的处于一个更简单的地方。你可以通过引用计数来决定一个板条箱是否仍然是活动的，不需要找出循环依赖并以随机的顺序破坏它们，等等。
> 
> *格雷顿:我不确定这些是否是最主要的问题。如果要我猜的话，我会说避免递归定义的单独编译和管理代码版本的问题。回想一下手册中的语言 crates 的基本原理:“编译和版本控制的单元”。这就是它们独立于模块而存在的原因。模块是递归的。板条箱，不是。因为与“编译和版本控制”有关的事情。*
> 
> *格雷顿:我无法对此进行简单的论证，因为我对模块系统还不够了解——完整的内容在德雷尔的论文*[](https://www.cs.cmu.edu/~rwh/theses/dreyer.pdf)**中有所阐述，并在这里以更短的* [*幻灯片形式进行了讨论*](http://macqueenfest.cs.uchicago.edu/slides/dreyer.pdf)*——但足以说明的是，递归模块使得通过两条路径看到“相同的”不透明类型成为可能，这两条路径可能被认为是相等的，但不容易确定是否如此， 我认为部分原因是模块提供的不透明性的混合，以及你必须部分地透过不透明性来解决递归的事实。 所以无论如何，我决定这可能是进入“研究”，我应该只是避免问题空间，去与非循环模块。**

*尽管受到基本约束的驱动，但 crates 的硬 daggishness 还是有用的，原因有很多:它加强了仔细的抽象，定义了并行编译的单元，定义了基本上合理的 codegen 单元，并极大地降低了语言和编译器的复杂性(即使编译器在未来可能会转向整个程序、需求驱动的编译)。*

*注意对*平行度*的强调。crate DAG 是 Rust 可以使用的最简单的编译时并行资源。如今，Cargo 将使用 DAG 自动将工作划分为并行编译任务。*

*因此，将 Rust 代码分解成形成*宽*的 DAG 的板条箱是非常可取的。*

*根据我的经验，虽然项目倾向于从一个单独的箱子开始，没有太多注意他们的内部依赖图，一旦编译时间成为问题，他们已经创建了一个意大利面条依赖图，很难重构为更小的箱子。*

*这种情况发生在 Servo 上，也是我在 TiKV 上的经历，在 TiKV 上，我曾多次尝试从主程序中提取各种模块，但都以失败告终，提交的顺序很长，解开了内部依赖关系。我怀疑避免有问题的整体是 Rust 开发人员从经验中学到的东西，但这是大型 Rust 项目中的重复现象。*

# *特质一致性和孤儿规则*

*Rust 的特征系统使得使用板条箱作为抽象边界变得更具挑战性，因为有一种叫做*孤儿规则*的东西。*

*特征是 Rust 中最常用的创建抽象的工具。它们很强大，但是像 Rust 的大部分能力一样，它也有一个权衡。*

*[孤儿规则](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/)帮助维护[特征一致性](https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence)，并确保 Rust 编译器永远不会遇到同一类型特征的两个实现。如果它遇到两个这样的实现，那么它需要解决冲突，同时确保结果是正确的。*

*本质上，孤儿规则说的是，对于任何`impl`，要么必须在当前机箱中定义*特征*，要么必须在当前机箱中定义*类型*。*

*这可以在 Rust 中的抽象之间创建一个紧密的耦合，阻止分解成板条箱——有时遵守 Rust 的一致性规则所需的仪式、样板文件和创造性的数量，同时还保持有原则的抽象边界，感觉不值得努力，所以它不会发生。*

*这导致大板条箱，增加了部分重建时间。*

*这个主题值得更多的例子和更有力的论证，但我现在对它没有热情。*

*Rust 的特征所基于的 Haskell 的类型类没有孤儿规则。我不知道这对 Haskell 实际上会造成多大的问题。在 Rust 设计的时候，它被认为有足够的问题来纠正。*

# *内部并行性*

*由于板条箱是编译流水线中的主要并行单元，理论上，我们希望拥有一个具有大致相同复杂度的板条箱的宽板条箱 DAG，这样编译器就可以一直使用所有的机器内核。但实际上，几乎总是存在瓶颈，只有一个编译器实例在运行，在一个机箱上工作。*

*所以除了`cargo`的并行机箱编译，`rustc`本身在单个机箱上是并行的。尽管它不是为并行而设计的，所以它的并行性是有限的，也是来之不易的。*

*今天，`rustc`中唯一真正的内部并行性是使用 [*codegen 单元*](https://doc.rust-lang.org/rustc/codegen-options/index.html) ，通过它`rustc`在翻译过程中自动将一个板条箱分成多个 LLVM 模块。通过这样做，它可以并行执行代码生成。与机箱一样，Rust codegen-unit 也是一个编译单元，但它是一个 LLVM 编译单元。*

*与 [*增量编译*](https://rust-lang.github.io/rustc-guide/queries/incremental-compilation.html) 相结合，可以避免重新翻译每次运行都没有改变的 codegen 单元，减少部分重建时间。不幸的是，codegen 单元和增量编译对编译时和运行时性能的影响很难预测:改善重建时间取决于`rustc`成功地将一个板条箱分成独立的单元，这些单元不太可能在发生变化时强迫彼此重新编译，人类应该如何编写代码来帮助`rustc`完成这项任务并不明显；并且任意地将一个箱子划分成代码单元会对内联造成任意的障碍，导致意外的去优化。*

*编译器的其余工作完全是串行的，尽管很快它应该[并行执行一些分析](https://internals.rust-lang.org/t/help-test-parallel-rustc/11503/14)。*

# *大与小板条箱*

*受编译单元大小影响的编译属性很大，我已经放弃了连贯地解释它们的尝试。以下是其中的一些。*

*   *编译单元并行性——如前所述，并行编译单元是微不足道的。*
*   *内联和优化—内联发生在编译单元级别，内联是开启优化的关键，因此较大的编译单元会得到更好的优化。这个故事是复杂的，虽然链接时间优化(LTO)。*
*   *优化复杂性—优化在代码大小方面往往具有超线性复杂性，因此较大的编译单元会非线性地增加编译时间。*
*   *下游单态化——泛型只有在被实例化后才会被翻译，所以即使所有的板条箱都是完全相同的大小以进行并行编译，它们的泛型类型直到板条箱图的后期才会被翻译。这可能会导致“最终”箱子与其他箱子相比具有不成比例的平移量。*
*   *泛型复制——泛型在实例化它们的板条箱中进行翻译，因此使用相同泛型的板条箱越多，意味着翻译时间越长。*
*   *链接时优化(LTO)——发布版本倾向于有一个最终的“链接时优化”步骤，在多个代码单元之间执行优化，这是非常昂贵的。*
*   *保存和恢复元数据— Rust 每次运行时都需要保存和加载关于每个机箱和每个依赖项的元数据，因此更多的机箱意味着更多的冗余加载。*
*   *并行“codegen 单元”——`rustc`可以自动将其 LLVM IR 拆分成多个编译单元，称为“codegen 单元”。它在这方面的有效程度很大程度上取决于一个机箱的内部依赖是如何组织的，以及编译器理解它们的能力。这会导致更快的部分重新编译，但代价是优化，因为失去了内联机会。*
*   *编译器内部并行性——部分`rustc`本身是并行的。内部并行有其自身不可预测的瓶颈以及与外部构建系统并行不可预测的交互。*

*不幸的是，由于所有这些变量，对于任何给定的项目来说，重构到更小的箱子里会有什么影响，这一点都不明显。由于并行性增加而带来的预期优势通常会被其他因素抹杀，如下游单态化、通用复制和 LTO。*

# *在下一集的 Rust 编译时冒险中*

*在本系列的下一集，我们将用一些更小的慢速编译花絮来结束对 Rust 慢速编译原因的探索。*

*然后也许我们会转移到一些新的东西上，比如加速铁锈建造的技术。*

*保持警惕，朋友们。*

# *谢谢*

*许多人为这个博客系列提供了帮助。特别感谢格雷顿·霍尔的反馈，以及凯文·翁的校对和编辑。*

**原载于 2020 年 6 月 22 日*[*【www.pingcap.com】*](https://pingcap.com/blog/rust-huge-compilation-units)*