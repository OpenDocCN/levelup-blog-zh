<html>
<head>
<title>How Merge Queues Made My Life Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并队列如何让我的生活更轻松</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-merge-queues-made-my-life-easier-1d8ea6384eca?source=collection_archive---------7-----------------------#2022-12-27">https://levelup.gitconnected.com/how-merge-queues-made-my-life-easier-1d8ea6384eca?source=collection_archive---------7-----------------------#2022-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b979" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们如何用Mergify和Merge queue自动化我们的开发过程？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d26c74de7537b573eeb5d1f3834a14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fo7SKY8FuDN2INhdvNetYQ.jpeg"/></div></div></figure><p id="4c13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你的团队正在用GitHub开发一个软件项目，那么当多个开发人员试图同时将拉请求合并到主分支时，你会感到很困难。如果你听起来很熟悉，这篇文章可能对你有帮助。</p><p id="a66a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TLDR——我创建了一个内置公关自动化和合并队列配置的GitHub repo。看一看！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="e1a1" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">我们的开发过程是如何工作的？</h2><p id="900e" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们是两个团队，由10名开发人员组成，从事同一个单一回购项目。我们的开发过程与此非常相似:分配到一个标签的每个开发人员创建一个新的特性分支，并在开发过程中添加一些提交。最后开发者做一个特色分支PR。该PR需要运行一些CI流程(测试、lint等)。此外，每个PR必须由另一个开发人员批准。当PR被批准并且CI检查通过时，该PR可以被合并到主分支中。</p><p id="7375" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看下面的开发流程图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/6428187805f97d90a88609fa6b42301e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUd0qMYtBuNsppvpOAl4yg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">旧的开发过程</figcaption></figure><h2 id="27d9" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">出了什么问题？</h2><p id="8308" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">当我们开始更快地交付并创建更多的PRs时，我们为主要分支机构创建了一个保护规则。此规则确保PRs在与主分支合并之前是最新的。</p><p id="8969" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">增加这条规则的原因是:</p><ol class=""><li id="d3ca" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">为了确保新代码在主测试中与当前代码一起被测试，为了避免在合并时中断测试，要求每个PR与主分支保持同步。这确保了被合并的代码尽可能是最新的，并最小化了当代码被合并时出现冲突或其他问题的风险。</li><li id="dcae" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">为了简化审核过程，当PRs是最新的时，审核者可以更容易地理解所提议的更改，并提供更准确的反馈。这有助于简化审核流程，提高效率。</li></ol><p id="ee2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总的来说，向GitHub分支添加保护规则，要求每个PR都是最新的，这有助于提高代码的质量和可靠性，并鼓励团队内部更好的协作和交流。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/6d2cc2086244f7a48920422f9780a2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7NoeHDXC7Vbhl-LrUbiJQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">分支保护规则的GitHub设置</figcaption></figure><p id="88e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这一规则可能会给开发人员带来新的问题，因为他们中的一些人可能会发现必须不断更新他们的PRs以保持最新是令人沮丧的。这可能导致士气下降，甚至可能阻碍合作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/b3d60d1c4f5300e0b025cf064703cb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdp4xWRSU2Qg3cPJQ6N9dA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">更新分支视图:(</figcaption></figure><h2 id="96bc" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">解决方案是什么？</h2><p id="26c8" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">为了解决这个问题，我们的开发人员之一，<a class="ae ln" href="https://www.linkedin.com/in/ophiryael/" rel="noopener ugc nofollow" target="_blank"> Ophir Yael </a>发现，为了避免“更新分支”问题，我们可以使用一个合并队列，特别是Mergify。Mergify 是一个在GitHub上自动合并拉请求(PRs)的工具。</p><h2 id="400c" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">什么是合并队列？</h2><p id="186a" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">合并队列是一些版本控制系统和GitHub用来管理分支合并过程的特性。当一个合并请求被发出时，来自一个分支的变更被添加到一个队列中，系统等待直到这些变更可以被安全地合并到主开发分支中。</p><p id="63be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">合并队列的目的是确保主分支不会中断。在我们的例子中，一次只执行一个合并，这有助于减少合并冲突和偏斜的风险。它还有助于确保合并后的代码是正确的，并且符合必要的质量标准。我们如何将合并队列集成到CI管道中？</p><p id="b246" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">建议的解决方案是当PR在GitHub上提交时，它被添加到Mergify管理的合并队列中。然后GitHub会自动检查PR是否有任何合并冲突或其他需要在PR合并前解决的问题。如果没有问题，一旦它变成Mergify将自动合并到主要发展分支的公共关系。如果有需要解决的问题，Mergify会通知PR作者或其他相关方，在问题解决之前不会合并PR。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/7692411fb9b413dc28eb9755b60eda5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNGvDxg-DvOdWtpSdVPx3g.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">新开发流程</figcaption></figure><h2 id="f150" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">如何开始？</h2><p id="8c9a" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在我们开始之前，我应该说Mergify有不同的<a class="ae ln" href="https://mergify.com/pricing" rel="noopener ugc nofollow" target="_blank">计划</a>，并且不是所有的特性都可以在免费计划中使用，但是我用免费计划创建了一个非常酷的例子。这个应用程序使用jest并配置GitHub操作来模拟CI流程，就像真实应用程序一样。</p><ol class=""><li id="5ea6" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">登录Mergify <a class="ae ln" href="https://dashboard.mergify.com/" rel="noopener ugc nofollow" target="_blank">仪表板</a>。</li><li id="a878" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">点击<code class="fe np nq nr ns b">Enable Mergify on a new account</code>或转到<a class="ae ln" href="https://github.com/apps/mergify/installations/new" rel="noopener ugc nofollow" target="_blank">https://github.com/apps/mergify/installations/new</a></li><li id="0965" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">GitHub现在会让你选择你想让Mergify访问的库。选择您喜欢的任何存储库，或者选择所有存储库。</li><li id="315d" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">您将被重定向到仪表板。</li></ol><p id="5dd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们创建一个简单的NodeJS应用程序。</p><ol class=""><li id="2dea" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">将您的存储库克隆到本地文件夹。</li><li id="7dba" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">运行<code class="fe np nq nr ns b">npm init -y</code>来初始化您的应用程序</li><li id="5ed0" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">跑<code class="fe np nq nr ns b">npm install -D jest</code></li><li id="d6eb" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">创建<code class="fe np nq nr ns b">__tests__</code>文件夹</li><li id="00e0" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">添加<code class="fe np nq nr ns b">__tests__/simple.test.js</code></li></ol><pre class="kg kh ki kj gt nt ns nu bn nv nw bi"><span id="ae86" class="nx lw iq ns b be ny nz l oa ob"><br/>describe("Filter function", () =&gt; {<br/>    test("it should filter by a search term (link)", () =&gt; {<br/>      expect(1+1).toBe(2);<br/>    });<br/>  });</span></pre><p id="413f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6.在package.json的脚本部分添加一个测试脚本，应该是这样的</p><pre class="kg kh ki kj gt nt ns nu bn nv nw bi"><span id="38a8" class="nx lw iq ns b be ny nz l oa ob"><br/><br/>{<br/>  "name": "merge-queue-example",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "jest"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "devDependencies": {<br/>    "jest": "^29.3.1"<br/>  }<br/>}</span></pre><p id="e0a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">7.让我们试着运行测试<code class="fe np nq nr ns b">npm test</code>结果应该显示测试通过。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/55ed82f8ca013a4b3bf9592b7ec4c835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bckU5Kq_PVGlMvl3hQrywQ.png"/></div></div></figure><p id="ede4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">8.让我们继续创建我们的GitHub工作流来创建CI流程，create <code class="fe np nq nr ns b">.github/workflows/node.js.yml</code>。</p><pre class="kg kh ki kj gt nt ns nu bn nv nw bi"><span id="efe0" class="nx lw iq ns b be ny nz l oa ob"># This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node<br/># For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs<br/><br/>name: Node.js CI<br/><br/>on:<br/>  push:<br/>    branches: [ "main" ]<br/>  pull_request:<br/>    branches: [ "main" ]<br/><br/>jobs:<br/>  build:<br/><br/>    runs-on: ubuntu-latest<br/><br/>    strategy:<br/>      matrix:<br/>        node-version: [14.x, 16.x, 18.x]<br/>        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/<br/><br/>    steps:<br/>    - uses: actions/checkout@v3<br/>    - name: Use Node.js ${{ matrix.node-version }}<br/>      uses: actions/setup-node@v3<br/>      with:<br/>        node-version: ${{ matrix.node-version }}<br/>        cache: 'npm'<br/>    - run: npm ci<br/>    - run: npm test</span></pre><p id="549f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不会深入讨论工作流配置，这是另一篇博文，但是一般来说，这个工作流在不同的Nodejs版本(14、16、18)上运行之前的测试。当对主要分支机构开立PR时。</p><p id="c912" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">9.在根目录中添加<code class="fe np nq nr ns b">.mergify.yml</code>。</p><pre class="kg kh ki kj gt nt ns nu bn nv nw bi"><span id="57bd" class="nx lw iq ns b be ny nz l oa ob">pull_request_rules:<br/>  - name: merge using the merge queue<br/>    conditions:<br/>      - base=main<br/>      - "#approved-reviews-by&gt;=1"<br/>      - check-success=build (14.x)<br/>      - check-success=build (16.x)<br/>      - check-success=build (18.x)<br/>    actions:<br/>      queue:<br/>        method: squash<br/>        name: default</span></pre><p id="8e02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe np nq nr ns b">pull_request_rules</code>属性是一个规则列表，它指定了在哪些条件下应该对拉请求采取特定的操作。每个规则都由一组条件和满足条件时要采取的操作组成。一般来说，这个规则增加了5个不同的条件<code class="fe np nq nr ns b">base=main</code>意味着这个规则将只受合并到主分支的PR的影响。<code class="fe np nq nr ns b">#approved-reviews-by&gt;=1</code>表示每个请购单在合并前至少需要一次审批。接下来的三个条件<code class="fe np nq nr ns b">check-success=build</code>意味着合并将一直等到CI过程成功。在我们的例子中，我们配置了一个工作流，在三个不同的NodeJS版本(14、16、18)上运行测试。</p><p id="9802" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">10.<code class="fe np nq nr ns b">actions</code>部分表示Mergify将在满足上述条件后执行哪些操作，在本例中，我们将合并方法改为squash并设置队列的名称(默认)。请看下面的截图，看看它在Github和Mergify dashboard上的样子</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/ac68036397e24ea2e0b823286877049d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkWl074qB-C5z1_cdFjc1w.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">Mergify仪表板队列部分</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/4b72c3d36fbb75ff28cf611448d032fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOOw0NbZvcIGv4ZjJYXHSg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">GitHub检查部分</figcaption></figure><p id="a0c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的例子可以在这个<a class="ae ln" href="https://github.com/haimrait/merge-queue-example" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p><h2 id="7094" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">结论</h2><p id="dca7" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">使用Mergify和合并队列是GitHub存储库中自动管理pull请求的一种有用方法。</p><p id="8c02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Mergify是一个工具，它监听存储库的拉请求时间线中的事件，并根据配置的规则采取行动。它可以用来自动化各种任务，比如标记、注释或合并拉请求。</p><p id="1f9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">合并队列是等待合并的拉请求列表。它可以用来管理拉请求合并的顺序，并确保某些拉请求优先于其他请求。</p><p id="eae5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Mergify和merge queue一起可以帮助简化代码审查过程，并减少维护人员的工作量。他们可以确保变更在准备好的时候得到及时的审查和合并，同时仍然允许维护人员控制过程。</p><p id="f2d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总的来说，使用Mergify和合并队列是自动管理拉请求和提高代码审查过程效率的有效方法。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="1639" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢<a class="ae ln" href="https://www.linkedin.com/in/ophiryael/" rel="noopener ugc nofollow" target="_blank"> Ophir Yael </a>对本文的帮助。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="eea4" class="of lw iq bd lx og oh oi ma oj ok ol md jw om jx mg jz on ka mj kc oo kd mm op bi translated">分级编码</h1><p id="11c1" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="a9da" class="my mz iq kt b ku kv kx ky la na le nb li nc lm oq ne nf ng bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="b709" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm oq ne nf ng bi translated">📰更多内容请查看<a class="ae ln" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="a0ce" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm oq ne nf ng bi translated">🔔关注我们:<a class="ae ln" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ln" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae ln" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="d1fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">🚀👉<a class="ae ln" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>