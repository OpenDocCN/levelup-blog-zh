<html>
<head>
<title>Flutter: state management and children updating a parent’s state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter:状态管理和子更新父状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-child-updating-parent-state-e68401eed36a?source=collection_archive---------0-----------------------#2020-07-08">https://levelup.gitconnected.com/flutter-child-updating-parent-state-e68401eed36a?source=collection_archive---------0-----------------------#2020-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/461ce4860f7a096724efd052db618b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3EBlJV_jcM3tDXRm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安德拉·里基茨在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="f32a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">故事</h1><p id="9370" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">颤振状态管理在某种程度上非常类似于ReactJS(对于熟悉它的人来说)。有几种不同类型的状态。让我们用<a class="ae kc" href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/ephemeral-vs-app" rel="noopener ugc nofollow" target="_blank">飘起的公文</a>开始对话。根据该文件，有两种不同类型的状态。</p><blockquote class="lz ma mb"><p id="cac5" class="lb lc mc ld b le md lg lh li me lk ll mf mg lo lp mh mi ls lt mj mk lw lx ly ij bi translated">第一个叫短命状态(绕口令给你？)或者我们把它叫做本地状态，另一个叫做应用状态。</p></blockquote><p id="e495" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">在本文中，我们将讨论应用程序状态。如果你没有阅读上面的链接，那么让我描述一下。这是应用程序启动所需的信息，也是模块的许多部分(如登录、购物车等)所需的信息。如果你来自Android世界，这是共享的偏好，在iOS中稍微复杂一点。</p><p id="ff92" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">几乎从应用程序的所有部分都可以轻松访问Android的共享偏好。另一方面，Flutter中的应用程序状态更加棘手。你需要在父和子之间有一个层次的交互，因为应用程序的状态是由最高级别的小部件保持的，并且它将被那个小部件的子部件操纵。</p><p id="c346" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">我知道你可能认为这很疯狂。我最终需要从父代传递给子代多少个对象。还有调试过程呢。Flutter为上述问题提供了一个名为“<a class="ae kc" href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple" rel="noopener ugc nofollow" target="_blank">简单应用状态管理</a>”的答案。请仔细阅读简单的(就像你是调查骗子政客的城堡系列中的凯特上尉)</p><p id="8ca7" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">然而，我们不会讨论政治家(也就是一个简单的应用程序状态管理)。让我们假设我们唯一的武器是一把小口径的踝枪，它可能无法在以后解决更大的问题。这对于简单的应用程序来说已经足够好了，例如当按钮被点击时改变数字的应用程序。这是一个想法！让我们从那个开始。</p><h1 id="00a2" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">让我们做一些代码</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/1eca3b5bc8c4cd415ba8ecd92da9f27d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OYiCPO5fEKj8-uX5zRVKg.jpeg"/></div></div></figure><p id="110a" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">上面的屏幕截图来自我们第一次创建一个Flutter项目时生成的代码。我不会把代码放在本文中，因为您可以自己生成它。让我们转到<strong class="ld ir"> _MyHomePageState </strong>类，您可以看到<strong class="ld ir"> FloatingActionButton </strong>小部件，它制作了一个中间带有添加图标的蓝色圆形按钮:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="aea2" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">如你所见，该数字保存在名为<strong class="ld ir"> _counter的状态中。</strong>我们将把<strong class="ld ir"> FloatingActionButton </strong>移出<strong class="ld ir"> _MyHomePageState </strong>类，并传递参数来更新<strong class="ld ir"> _counter </strong>状态。</p><ol class=""><li id="e372" class="ms mt iq ld b le md li me lm mu lq mv lu mw ly mx my mz na bi translated">使FloatingActionButton成为_MyHomePageState的子级</li></ol><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7ed1" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">重构之后，代码会如上所示。IDE会抱怨不存在的<strong class="ld ir"> _incrementCounter </strong>。让我们在调用<strong class="ld ir"> MyButton时将函数作为参数传递。</strong></p><p id="35cc" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">2.将incrementCounter作为参数传递给child</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="793f" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">让我们看看我们做了什么。我们在名为<strong class="ld ir"> updateCounter </strong>的<strong class="ld ir"> MyButton </strong>类中创建了一个新的类变量。该变量代表<strong class="ld ir"> _MyHomePageState </strong>类中的<strong class="ld ir"> incrementCounter </strong>。我们使用namespace参数将函数从父节点传递给子节点。当我们保存并刷新应用程序并单击浮动按钮时，它将始终显示10。如果你有兴趣，看看dart语言中的<a class="ae kc" href="https://dart.dev/guides/language/language-tour#optional-parameters" rel="noopener ugc nofollow" target="_blank">可选参数</a>的参数语法。</p><p id="fbda" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">3.将_counter state的值发送给子级以增量方式更改状态</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e321" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">我们在<strong class="ld ir"> MyButton </strong>类上创建了第二个可选参数，这样父类可以传递<strong class="ld ir"> _counter </strong>状态的当前值。就是它的值父状态的<strong class="ld ir"> _counter </strong>发送给子并操纵然后在<strong class="ld ir"> updateCounter </strong>中更新。</p><h1 id="fa5f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">下一步是什么？</h1><p id="62c2" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">原来如此。从子节点操纵父节点状态是最容易的。它适用于大多数场景，但是当应用程序越来越大时，您会将登录信息从最高的山峰传递到最深的海洋吗？那是以后的事了。</p><p id="8aca" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">感谢您的阅读。如果你有问题，请告诉我。</p><blockquote class="lz ma mb"><p id="3966" class="lb lc mc ld b le md lg lh li me lk ll mf mg lo lp mh mi ls lt mj mk lw lx ly ij bi translated">分享是关爱，像爱自己一样爱你的邻居。</p></blockquote></div></div>    
</body>
</html>