<html>
<head>
<title>Haskell Journey: Higher Order Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell之旅:高阶函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/haskell-journey-higher-order-functions-d8f033ec0a1d?source=collection_archive---------0-----------------------#2021-12-15">https://levelup.gitconnected.com/haskell-journey-higher-order-functions-d8f033ec0a1d?source=collection_archive---------0-----------------------#2021-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="434e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我的上一篇帖子以来，已经过去了很长时间😢但是我回来了，现在直接从马德里写信！🇪🇸</p><p id="f161" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面我们来看Haskell集锦系列的第四篇帖子！🚀在这一集里，我将向你们展示一些关于<em class="kl">高阶函数(HOF) </em>的东西！也许你已经知道这些人了——我已经在这篇<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/find-filter-map-and-reduce-put-to-action-e4f1a38e5607">上一篇</a>中写了一些关于的<em class="kl">——但是继续阅读并发现一些关于<em class="kl">功能</em>的新话题……</em></p><p id="5619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在学习中一直在使用的一些有用的链接:<br/> <strong class="jp ir"> (1) </strong>学习基于这些书的概念:<a class="ae km" href="https://www.casadocodigo.com.br/products/livro-haskell" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> Haskell </em>函数式编程简介</a> g和<a class="ae km" href="http://learnyouahaskell.com/chapters" rel="noopener ugc nofollow" target="_blank">为了极大的好处，学习一个<em class="kl"> Haskell </em>！</a>📚<br/> <strong class="jp ir"> (2) </strong>在这份<a class="ae km" href="https://www.notion.so/Haskell-29aac2ea56274d67bde03a529e8e4f09" rel="noopener ugc nofollow" target="_blank">意见</a>文件上做笔记📝<br/> <strong class="jp ir"> (3) </strong>在我的<a class="ae km" href="https://github.com/jennifertakagi/haskell-projects-study" rel="noopener ugc nofollow" target="_blank"> GitHub库</a> 🗃上编写一些练习</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/bf4bc60601fb347932cc1694f6afdd3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4GiwgpbJTd-gqyls"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae km" href="https://unsplash.com/@artem_kniaz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artem Kniaz </a>在<a class="ae km" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ba1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要记住的第一个概念是<strong class="jp ir"> " <em class="kl">函数被定义为一个可重用的块代码，可以在同一个程序</em> " </strong>中多次使用，在<em class="kl"> Haskell </em> <em class="kl">函数</em>中看起来是这样的:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/85797b361d899d2a20836d27a4d2b62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*WCefHy6LWPNTp234xDvk-A.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Haskell编码示例:使用“函数”。</figcaption></figure><p id="f42c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">函数</em>可以有一个额外的亮点:<strong class="jp ir"> <em class="kl">“它们可以将其他函数作为参数，也可以将其他函数作为它们的值返回”</em></strong><em class="kl"/>——也许现在看起来有点混乱，但希望在这篇文章结束时，你能真正理解这个概念。<br/>因此，我决定将主题分为4个部分，以便于理解编程中的这个重要角色。🙏</p><h1 id="2d08" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">希腊字母的第11个</h1><p id="3601" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我从来没有如此理解过<em class="kl"> Lambdas </em>，但是在对<em class="kl"> HOF </em>做了更多的研究之后，我发现了一个简单的方法来解释它:</p><blockquote class="mh mi mj"><p id="2a3d" class="jn jo kl jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">Lambas是只使用一次的函数，没有上下文—匿名函数—并且只用作值</p></blockquote><p id="a53c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把<strong class="jp ir"> <em class="kl">【函数sumTen】</em></strong>改写成<em class="kl"/>:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f41c617ea157c7e968013e59a3c3c7af.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*s0HL8V2q224WT1cebSiBqw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Haskell编码示例:使用“Lambda”。</figcaption></figure><p id="dec2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理解语法:<br/>(1)<strong class="jp ir"><em class="kl"/></strong>表示一个<em class="kl"> Lambda函数。</em> <br/> (2)接收一个<strong class="jp ir"><em class="kl">“x”</em></strong><em class="kl">参数</em>，增加<strong class="jp ir"><em class="kl">“10</em></strong>”。<br/> (3)通过向函数<em class="kl">发送一个<em class="kl">参数</em>、<strong class="jp ir">、<em class="kl"> "5 "，你可以看到我们刚刚声明并使用了函数</em>。</strong></em> 这个<em class="kl">λ</em>的回归就是<strong class="jp ir"><em class="kl">【15】。</em> </strong></p><h1 id="e2fa" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">高阶函数</h1><p id="c050" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我在这篇帖子的开头已经结束了对<em class="kl"> HOF </em>的特点的讨论，所以我在下面留下一个超级总结的定义和例子。</p><blockquote class="mh mi mj"><p id="ba4d" class="jn jo kl jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">高阶函数是以函数为参数或返回其他函数作为其值的函数。</p></blockquote><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f39b5e4249a5118b10b58891ad8c8214.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*Y4s3CY5Kbz0UYnNZpzbS3g.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Haskell编码示例:使用“HOF”。</figcaption></figure><p id="dc88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">深入举例:<br/>(1)<em class="kl">函数</em><strong class="jp ir"><em class="kl">【Hof】</em></strong>已经声明，并以另一个<em class="kl">函数</em>作为参数(<strong class="jp ir"><em class="kl">【fn】</em></strong>)。<br/><strong class="jp ir"><em class="kl">【Hof】</em></strong>体中的<strong class="jp ir"><em class="kl">【fn函数】</em> </strong>用一个<em class="kl">整数</em> <em class="kl">自变量</em>(<strong class="jp ir"><em class="kl">【20】</em></strong>)。<br/> (3)最后，<strong class="jp ir"><em class="kl">【Hof函数】</em> </strong>重复返回的<strong class="jp ir"><em class="kl">【fn函数】</em> </strong>值。<br/> (4)要使用<strong class="jp ir"><em class="kl">Hof函数</em> </strong>，我们调用它并发送<strong class="jp ir"><em class="kl">【sum ten函数】</em> </strong>，甚至发送一个<strong class="jp ir"> <em class="kl"> Lamba </em> </strong>函数——在两种情况下结果都是60。</p><p id="2d77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个有趣的观察结果是，Hindley-Milner类型表明，<strong class="jp ir">“<em class="kl">hof函数”接受一个函数fn，该函数接受并返回一个“Int”类型，“Hof函数”本身也返回一个“Int”。</em>T96】</strong></p><h1 id="7a7f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Currying</h1><p id="bc80" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">奇怪的是，<em class="kl"> Haskell的</em> <em class="kl">函数</em>只接受一个<em class="kl">参数</em>——官方说法是——然而，我们可以发送更多的参数……为了支持这一点，该语言使用了一种叫做Currying的技术。🤔</p><blockquote class="mh mi mj"><p id="2362" class="jn jo kl jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">Currying是一种技术，在这种技术中，函数接受乘法参数，然后返回函数的字符串求值——如果参数没有被传递，它将返回一个函数</p></blockquote><p id="deca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来很复杂，但是看看下面的代码:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/70f0dd21cfc6e9cc4a0ba6e0c7f5d816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*xePzbo8zl94uaQ7tWOqwbw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Haskell编码示例:使用“Currying”。</figcaption></figure><p id="3fa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(1)基本上声明了<strong class="jp ir"><em class="kl">【join words】</em></strong><em class="kl">函数</em>，将3个<em class="kl">字符串</em>以<em class="kl"> </em>为<em class="kl"> </em>参数连接起来，一起返回到一个<em class="kl">字符串</em>。<br/>(2)<strong class="jp ir"><em class="kl">【joinOneMoreWord】</em></strong><em class="kl">函数</em> <strong class="jp ir"> <em class="kl"> </em> </strong>已经声明接收一个<em class="kl">字符串</em>并返回一个。但这里重要的一点是，这个<em class="kl">函数</em>调用<strong class="jp ir"><em class="kl">【join words function】</em></strong>只传递2个<em class="kl">参数</em>，换句话说:留下一个空槽<em class="kl">参数</em>。<br/> (3)当执行<strong class="jp ir"><em class="kl">【joinOneMoreWord函数】</em> </strong>时，我们必须再发送一个<em class="kl">参数</em>——否则，将会产生一个错误。<br/> (4)类似<strong class="jp ir"> <em class="kl"> (joinWords(“你好”)(“世界”)(“！”)</em> </strong>正在这个<em class="kl">函数</em>内部发生，主<em class="kl">函数</em>的一个序列被生成到每个<em class="kl">参数</em>。</p><p id="77de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能知道<em class="kl">功能</em>为<strong class="jp ir"><em class="kl">“map，filter，foldl”。</em> </strong>这些函数有两个参数:<strong class="jp ir">一个<em class="kl">函数</em>和一个<em class="kl">列表</em> </strong>，所以它们是<strong class="jp ir"> <em class="kl">高阶函数</em> </strong>并使用<strong class="jp ir"> <em class="kl">处理</em> </strong>技术将这些<em class="kl">函数</em>应用到<em class="kl">列表</em>中的每一项</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/4164eb6a53cf5946952b191fd5e8bd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*b4Jhk8ClUVOGbxRawn6K3g.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Haskell编码示例:使用“过滤器”。</figcaption></figure><h1 id="7bba" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">作文</h1><p id="d6f2" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><em class="kl">组合</em>应用于<em class="kl">函数式编程</em>可以理解为<strong class="jp ir"><em class="kl"/></strong><em class="kl"/>或者更具体一点:</p><blockquote class="mh mi mj"><p id="6e04" class="jn jo kl jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">复合是一种组合函数并将当前函数的结果传递给下一个函数的技术——执行顺序是从右到左。</p></blockquote><p id="92f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用<strong class="jp ir"><em class="kl">" sum ten function "</em></strong>并声明一个新的<em class="kl">函数</em>名为<strong class="jp ir"> <em class="kl"> "double" </em> </strong>以在下面的代码中应用<em class="kl"> Haskell </em>中的<em class="kl">组合</em>:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mq"><img src="../Images/3095272b961234ed5ae484f7e8a6da4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*aa3qZZIgJ2mx01eadU2ZKA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Haskell编码示例:使用“复合”。</figcaption></figure><p id="70a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">追赶:<br/> (1)我们用<em class="kl">实参</em><strong class="jp ir"><em class="kl">【10】</em></strong>组成了<em class="kl">函数</em><strong class="jp ir"><em class="kl">【sun ten】</em></strong><strong class="jp ir"><em class="kl">【double】</em></strong>。正如你可以推导出在<em class="kl"> Haskell </em>中使用<em class="kl">组合</em>一样，你只需要语法<code class="fe mr ms mt mu b"><em class="kl">(fn1 . fn2 . fn3) arg</em></code>。<br/> (2)如前所述关于<em class="kl">构图的顺序</em>是从右到左。在这个例子中，首先，数字10乘以2，然后再加上10，结果是30。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="7b01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这篇文章能帮助你更多地了解任何语言中的HOF在JS中，我们总是使用map、filter、reduce等，但是我们经常不明白它们是如何在幕后工作的。<br/>感谢阅读，在下一篇文章中，我想介绍Haskell中类型的创建！再见，注意安全！🤟👩🏻‍💻👽</p></div></div>    
</body>
</html>