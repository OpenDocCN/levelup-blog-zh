<html>
<head>
<title>Five Ways to De-Duplicate Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">消除阵列重复的五种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/five-ways-to-de-duplicate-arrays-944dbff681dd?source=collection_archive---------12-----------------------#2022-12-12">https://levelup.gitconnected.com/five-ways-to-de-duplicate-arrays-944dbff681dd?source=collection_archive---------12-----------------------#2022-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f5ca" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">消除阵列重复的五种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/37b5aef0bed0a5f06f4e4e61057db407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ul7YTI9yPU0Sv8fERMeRaQ.jpeg"/></div></div></figure><p id="01d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能想知道，在互联网上有这么多重复数据消除方法的情况下，本文的意义何在。<br/>别急，本文只是简单、好玩、古老、实用的重复数据删除方法的节选，除了重复数据删除的实现，我还会和大家分享其他细节和扩展。<br/>你可能不明白为什么只有五个。<br/>当然，我还能举出更多的例子，但这有什么意义呢？工作中不需要那么多，认识一两个就行。即使是面试，能说出五个就足够了。所以，我们完全没有必要去记忆更多去强调的方法。</p><h2 id="eff2" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">方法1:设置</h2><p id="f18b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这种方法是我在日常开发中最喜欢使用的方法，因为，他的用法是所有重复数据删除中最简单的。我是一个懒惰的人。<br/>新<code class="fe ml mm mn mo b">Set </code>是ES6中引入的新类型。他和数组的区别在于，集合类型中的数据不能有重复值。当然，数组集合的一些方法是不能被调用的。<br/>用法:把数组转换成集合数据，然后再转换回来，完成去重，其实很简单。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="0c12" class="mt lo iq mo b be mu mv l mw mx">    const arr = [1,1,2,2,3,3,4,4,5,5];<br/>    const setData = Array.from(new Set(arr));<br/>    console.log(setData);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/b7610bd0a2a07faeaad6dbf244650f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*kBwQsg_Rr4wVWY2cKMuHpA.png"/></div></figure><p id="53d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是<code class="fe ml mm mn mo b">Set</code>反引用有一个缺点，它不能反引用引用类型的数据。例如，对象数组。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="6767" class="mt lo iq mo b be mu mv l mw mx">    const objArr = [{ age: 12 }, { age: 15 }, { age: 12 }];<br/>    const setObjData = Array.from(new Set(objArr));<br/>    console.log(setObjData);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/418b7c08f552e0ddc574e43e99870754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*REbyXLqOBl_D3jOdW3zcAQ.png"/></div></figure><p id="6d9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以如果你的数组充满了值类型数据(比如全字符串或者全数字)，那么使用Set进行去重一定是首选，会为你减少很多麻烦。</p><h2 id="5e9f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">方法2:最古老的方法，双重循环重复数据消除</h2><p id="29c0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在早期，在Set、map和filter出现之前，double for循环几乎是唯一的重复数据删除方法。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="1a16" class="mt lo iq mo b be mu mv l mw mx">    //Double-loop de-duplication<br/>    const handleRemoveRepeat = (arr) =&gt; {<br/>        for (let i = 0, len = arr.length; i &lt; len; i++) {<br/>            for (let j = i + 1; j &lt; len; j++) {<br/>                if (arr[i] === arr[j]) {<br/>                    arr.splice(j, 1);<br/>                    j--;<br/>                    len--;<br/>                }<br/>            }<br/>        }<br/>        return arr;<br/>    };<br/><br/>    const arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5];<br/>    console.log(handleRemoveRepeat(arr));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/62c5602acde494cd831b904c69384087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*wiQjDNqL3G73NjVg60Ruaw.png"/></div></figure><p id="ac86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有个有趣的点，也许你不太明白为什么我在我的for循环的初始表达式里声明了两件事:<code class="fe ml mm mn mo b">let i = 0</code>；<code class="fe ml mm mn mo b">len = arr.length</code>；</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/e7c7dff377a5e0483ae9531910464195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzqA1KNl2PFMPD174e-5Mw.png"/></div></div></figure><p id="9e2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">三个圈起来的表达式是for循环的三个表达式，分别是:初始表达式、判断表达式、自递增表达式。初始表达式在for循环开始时执行一次，不会再次执行，但判断表达式和自递增表达式会在每次循环时执行。</p><h2 id="9aa3" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">方法3:重复数据消除的索引</h2><p id="e00d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">indexOf方法确实比上面的double for循环简单。但这并不像重复数据删除的Set方法那么简单。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="03bf" class="mt lo iq mo b be mu mv l mw mx">    const handleRemoveRepeat = (arr) =&gt; {<br/>        let repeatArr = [];<br/>        for (let i = 0, len = arr.length; i &lt; len; i++)<br/>            if (repeatArr.indexOf(arr[i]) === -1) repeatArr.push(arr[i])<br/>        return repeatArr;<br/>    }<br/>    const arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5];<br/>    console.log(handleRemoveRepeat(arr));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/4db856fa87da41699f2134dfbefe1689.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*gTcTVWhICYd2VHKcTHKQEg.png"/></div></figure><p id="f581" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，这种方法有一个细节问题，您可能已经注意到上面的if和for没有括号；有；默认情况下，for和if都对下面的语句负责。不需要的时候就不需要多加一个{}。你可能认为这是不可读的，但这正是有趣的地方。这是一个工具方法，一个注定隐藏在utils中的方法，与业务逻辑无关，也不需要可读性。</p><h2 id="3749" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">方法4:包括重复数据消除</h2><p id="894a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">使用includes的去加重方法与indexOf并不十分相似，但基本上完全相同。唯一改变的是判断方法。</p><p id="c8c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确定包含的方法要简单得多。遍历数组，检查当前数组是否包含带有新数组的数组项，如果不包含，则追加元素。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="b656" class="mt lo iq mo b be mu mv l mw mx">    const handleRemoveRepeat = (arr) =&gt; {<br/>        let repeatArr = [];<br/>        for (let i = 0, len = arr.length; i &lt; len; i++)<br/>            if (!repeatArr.includes(arr[i])) repeatArr.push(arr[i])<br/>        return repeatArr;<br/>    }<br/>    const arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5];<br/>    console.log(handleRemoveRepeat(arr));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/704c9874a70f0d655dcbb61c46f6d7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*0i-sPwVWlfr2RawtPjWJIQ.png"/></div></figure><h2 id="8d63" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">5.过滤器重复数据删除</h2><p id="66e2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">最有趣的重复数据消除方法，使用过滤式重复数据消除。</p><p id="b0ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用带indexOf的过滤器进行重复数据消除的过程非常简单有趣。</p><pre class="kg kh ki kj gt mp mo mq bn mr ms bi"><span id="5e66" class="mt lo iq mo b be mu mv l mw mx">    const handleRemoveRepeat = (arr) =&gt; arr.filter((item, index) =&gt; arr.indexOf(item, 0) === index);</span></pre><p id="7f3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对，没了，就一行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/10ede3e00f229e442b4322e7379b044d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvihxTBEo_JS5ROyTDhRdA.png"/></div></div></figure></div></div>    
</body>
</html>