<html>
<head>
<title>JavaScript Best Practices — DOM Manipulation and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践— DOM操作和函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-dom-manipulation-and-functions-a932e9970ea7?source=collection_archive---------12-----------------------#2020-02-04">https://levelup.gitconnected.com/javascript-best-practices-dom-manipulation-and-functions-a932e9970ea7?source=collection_archive---------12-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e24de49496e71f1fa960c15a736e38a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1u5cFnFMDzrp6hDx"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@routessansfins?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Les routes sans fin(s) </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6852" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何其他编程语言一样，JavaScript有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript有很多棘手的部分，所以我们应该避免降低代码质量的事情。通过遵循最佳实践，我们可以创建优雅且易于管理的代码，任何人都可以轻松使用。</p><p id="6de2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究减少DOM操作、使用快捷表示法以及让函数执行单一任务的方法。</p><h1 id="bac3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免DOM操作</h1><p id="a000" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们的JavaScript中，如果我们想动态显示某些东西，我们应该避免操纵DOM。我们可以很容易地在CSS中放置大量样式代码，而不是直接用JavaScript操作它。</p><p id="5c6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们希望在提交时输入无效时显示红色边框，我们可以编写以下HTML代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ef78" class="mq lf it mm b gy mr ms l mt mu">&lt;form&gt;<br/>  &lt;input type='text' required&gt;<br/>  &lt;button type='submit'&gt;<br/>    Submit<br/>  &lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="54b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及以下JavaScript代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7165" class="mq lf it mm b gy mr ms l mt mu">const input = document.querySelector('input');<br/>const form = document.querySelector('form');</span><span id="1eca" class="mq lf it mm b gy mv ms l mt mu">form.onsubmit = (e) =&gt; {<br/>  e.preventDefault();<br/>}</span><span id="52db" class="mq lf it mm b gy mv ms l mt mu">input.oninvalid = () =&gt; {<br/>  input.style.borderColor = 'red';<br/>  input.style.borderStyle = 'solid';<br/>  input.style.borderWidth = '1px';<br/>}</span></pre><p id="9f03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，在我们分配给输入的<code class="fe mw mx my mm b">oninvalid</code>属性的事件处理程序中，我们用JavaScript设置了边框。</p><p id="83ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们可以通过创建一个类并在JavaScript中设置类名来实现CSS。</p><p id="f925" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们保留了相同的HTML代码，但添加了以下CSS代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e7b3" class="mq lf it mm b gy mr ms l mt mu">.invalid {<br/>  border: 1px solid red;<br/>}</span></pre><p id="1b42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在我们的JavaScript代码中，我们用以下内容替换我们之前的内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f205" class="mq lf it mm b gy mr ms l mt mu">const input = document.querySelector('input');<br/>const form = document.querySelector('form');</span><span id="247c" class="mq lf it mm b gy mv ms l mt mu">form.onsubmit = (e) =&gt; {<br/>  e.preventDefault();<br/>}</span><span id="9f69" class="mq lf it mm b gy mv ms l mt mu">input.oninvalid = () =&gt; {<br/>  input.className = 'invalid';<br/>}</span></pre><p id="aaaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，它以更短的方式做同样的事情。它需要更少的处理能力，因为它不动态设置样式。</p><p id="1407" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，现在我们有了一个可以在其他HTML元素中重用的类和样式，这样我们就不必重复代码了。</p><h1 id="3ad6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用快捷方式</h1><p id="2706" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，有许多快捷方式对于开发者来说仍然清晰易读。</p><p id="eee7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，当我们创建一个对象时，我们可以使用<code class="fe mw mx my mm b">Object</code>构造函数或者对象文字符号。</p><p id="9127" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mw mx my mm b">Object</code>构造函数，我们可以如下创建一个对象:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7601" class="mq lf it mm b gy mr ms l mt mu">let obj = new Object();<br/>obj.foo = '1';<br/>obj.bar = '2';<br/>obj.baz = function() {<br/>  console.log('baz');<br/>}</span></pre><p id="095d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以用对象文字符号写同样的东西:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8263" class="mq lf it mm b gy mr ms l mt mu">let obj = {<br/>  foo: '1',<br/>  bar: '2',<br/>  baz() {<br/>    console.log('baz');<br/>  }<br/>}</span></pre><p id="d892" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有相同的行数，但是我们必须在第一个例子的每一行中重复对象名。然而我们不必对对象字面量这样做。</p><p id="1a9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对象文字也提高了清晰度，所以我们可以用它代替<code class="fe mw mx my mm b">Object</code>构造函数来创建一个对象。它们都做同样的事情，但是我们不需要像用<code class="fe mw mx my mm b">Object</code>构造函数创建一个对象那样重复代码。</p><p id="588b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，不像下面这样定义数组:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0b13" class="mq lf it mm b gy mr ms l mt mu">let arr = new Array();<br/>arr[0] = 1;<br/>arr[1] = 2;<br/>arr[2] = 3;<br/>arr[3] = 4;<br/>arr[4] = 5;</span></pre><p id="bc7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用一种更简短的方式来定义它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="78c4" class="mq lf it mm b gy mr ms l mt mu">let arr = [1, 2, 3, 4, 5];</span></pre><p id="af6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，用数组文字定义它比用<code class="fe mw mx my mm b">Array</code>构造函数短得多。此外,<code class="fe mw mx my mm b">Array</code>构造函数令人困惑，因为它有两个签名。如果我们传入一个参数，那么我们得到的数组的长度由参数设定。否则，我们会得到一个数组，其中的参数是我们作为内容传入的。</p><p id="3964" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个方便的快捷方式是三元运算符，在这里我们可以有条件地给变量赋值。</p><p id="f1d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6c10" class="mq lf it mm b gy mr ms l mt mu">const x = 100;<br/>let foo;<br/>if (x === 100) {<br/>  foo = 'bar';<br/>} else {<br/>  foo = 'baz';<br/>}</span></pre><p id="96be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ef64" class="mq lf it mm b gy mr ms l mt mu">const x = 100;<br/>let foo = (x === 100) ? 'bar' : 'baz';</span></pre><p id="a9b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="066e" class="mq lf it mm b gy mr ms l mt mu">let foo;<br/>if (x === 100) {<br/>  foo = 'bar';<br/>} else {<br/>  foo = 'baz';<br/>}</span></pre><p id="446a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以下内容相同:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2765" class="mq lf it mm b gy mr ms l mt mu">let foo = (x === 100) ? 'bar' : 'baz';</span></pre><p id="771d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们都检查<code class="fe mw mx my mm b">x</code>是否是100，如果是，则将<code class="fe mw mx my mm b">'bar'</code>赋给<code class="fe mw mx my mm b">foo</code>，否则赋给<code class="fe mw mx my mm b">'baz'</code>。</p><p id="d7e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用三元运算符时，代码要短得多，但我们得到了相同的结果。它也不会增加代码的可读性。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/203134cbaced0c22d204d1e349b05803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6uiJxXi2rYCR4TKa"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥斯汀·迪斯特尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="df19" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">每个任务一个功能</h1><p id="d775" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通常，一个函数应该只做一件事。这使得每个函数都简短易读。</p><p id="96ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也使得重用它更容易，因为在每个函数中发生功能冲突的可能性更小。</p><p id="0b4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，为常见任务创建助手函数也是一个好主意。</p><p id="aa3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想在页面上动态创建一些元素。我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="60e3" class="mq lf it mm b gy mr ms l mt mu">const createPage = () =&gt; {<br/>  const items = ['foo', 'bar', 'baz'];<br/>  const ul = document.createElement('ul');<br/>  let li;<br/>  for (const item of items) {<br/>    li = document.createElement('li');<br/>    li.textContent = item;<br/>    ul.appendChild(li);<br/>  }<br/>  document.body.appendChild(ul);</span><span id="393a" class="mq lf it mm b gy mv ms l mt mu">  const googleLink = document.createElement('a');<br/>  googleLink.href = '<a class="ae kf" href="http://www.googole.com'" rel="noopener ugc nofollow" target="_blank">http://www.googole.com'</a>;<br/>  googleLink.textContent = 'Google';<br/>  document.body.appendChild(googleLink);</span><span id="6466" class="mq lf it mm b gy mv ms l mt mu">  const yahooLink = document.createElement('a');<br/>  yahooLink.href = '<a class="ae kf" href="http://www.yahoo.com'" rel="noopener ugc nofollow" target="_blank">http://www.yahoo.com'</a>;<br/>  yahooLink.textContent = 'Yahoo';<br/>  document.body.appendChild(yahooLink);<br/>}</span><span id="23ed" class="mq lf it mm b gy mv ms l mt mu">createPage();</span></pre><p id="bbde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cb3a" class="mq lf it mm b gy mr ms l mt mu">const createLink = (textContent, href) =&gt; {<br/>  const link = document.createElement('a');<br/>  link.href = href;<br/>  link.textContent = textContent;<br/>  return link;<br/>}</span><span id="4387" class="mq lf it mm b gy mv ms l mt mu">const createUl = (items) =&gt; {<br/>  const ul = document.createElement('ul');<br/>  let li;<br/>  for (const item of items) {<br/>    li = document.createElement('li');<br/>    li.textContent = item;<br/>    ul.appendChild(li);<br/>  }<br/>  return ul;<br/>}</span><span id="ebab" class="mq lf it mm b gy mv ms l mt mu">const items = ['foo', 'bar', 'baz'];<br/>const ul = createUl(items);<br/>const googleLink = createLink('Google', '<a class="ae kf" href="http://www.google.com'" rel="noopener ugc nofollow" target="_blank">http://www.google.com'</a>);<br/>const yahooLink = createLink('Google', '<a class="ae kf" href="http://www.yahoo.com'" rel="noopener ugc nofollow" target="_blank">http://www.yahoo.com'</a>);<br/>document.body.appendChild(ul);<br/>document.body.appendChild(googleLink);<br/>document.body.appendChild(yahooLink);</span></pre><p id="2980" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该用第二种方式来写，因为我们把代码分成函数，这些函数在给定相同输入的情况下总是返回相同的结果。</p><p id="999f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且，它们可以在任何地方被调用。因此，如果我们想要另一个链接，我们可以再次调用<code class="fe mw mx my mm b">createLink</code>。</p><p id="adb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还返回元素，所以我们可以将它附加到函数之外，这意味着我们可以动态地创建元素，而不用马上附加它们。</p><h1 id="8934" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="cf1f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们处理客户端JavaScript代码时，为了提高性能和降低代码复杂度，我们应该尽可能避免DOM操作。</p><p id="3717" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，许多JavaScript快捷方式都是有意义的，比如只要文字可用就使用文字，而不是构造函数。</p><p id="1251" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们应该将代码划分为多个函数，每个函数执行一项任务，以使代码易于阅读和维护。这也使得函数更容易重用，因为它们没有冲突的功能。</p></div></div>    
</body>
</html>