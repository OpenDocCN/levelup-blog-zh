<html>
<head>
<title>Typescript with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React挂钩的类型脚本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-with-react-hooks-918060d098d2?source=collection_archive---------0-----------------------#2019-01-15">https://levelup.gitconnected.com/typescript-with-react-hooks-918060d098d2?source=collection_archive---------0-----------------------#2019-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6ea964f0674e29d9b2e3c412148ade52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHnalHKo2UJi4J25keHV1w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">阿卜杜勒·瓦哈布从<a class="ae kf" href="https://thenounproject.com/" rel="noopener ugc nofollow" target="_blank">名词项目</a>勾手</figcaption></figure><p id="0942" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.udemy.com/typescript-with-react-hooks-and-context/" rel="noopener ugc nofollow" target="_blank"><em class="le">* *这是这里免费Udemy课程的一部分** </em> </a></p><p id="a1dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi lf translated"><span class="l lg lh li bm lj lk ll lm ln di">我</span>制作了一个<a class="ae kf" href="https://www.youtube.com/watch?v=1ZJrd1nHbWc&amp;list=PLiKs97d-BatHEeclprFtCaw8RcNOYXUqN" rel="noopener ugc nofollow" target="_blank"> youtube视频系列</a>并写了几篇<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/react-typescript-with-webpack-2fceebb8faf">帖子</a>关于如何用webpack建立一个React和typescript项目。当时无论是<a class="ae kf" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>还是<a class="ae kf" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>都不支持类型脚本。现在它们都有了，而且安装JS超集要容易得多，在16.7.0以上的React版本中有了一种新的编写组件的方式——React钩子。这是更新教程的绝佳时机。</p><p id="d523" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章将通过用<code class="fe lo lp lq lr b">create-react-app</code>建立一个TypeScript项目，并使用<a class="ae kf" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> useState </strong> </a>钩子来表示状态。本指南假设您对<a class="ae kf" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>、Javascript有所了解，并且在您的机器上安装了<a class="ae kf" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>。我们将做一个简单的没有风格的待办事项列表网站(我知道这很老套)。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ls"><img src="../Images/92b1045242cb36e96c229154a66bc8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KSyAAyU7cGXR-kqvOJjTA.png"/></div></div></figure><blockquote class="lx ly lz"><p id="93d5" class="kg kh le ki b kj kk kl km kn ko kp kq ma ks kt ku mb kw kx ky mc la lb lc ld im bi translated">如果你想知道本教程的主要内容，跳过解释，你可以只看要点。</p></blockquote></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="516f" class="mk ml it bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">设置</h1><ul class=""><li id="3e8b" class="ni nj it ki b kj nk kn nl kr nm kv nn kz no ld np nq nr ns bi translated">打开终端，使用以下命令安装create react应用程序:</li></ul><p id="55b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lo lp lq lr b">$ npm i create-react-app</code></p><ul class=""><li id="7d1f" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">完成后，使用以下命令创建一个项目:</li></ul><p id="c1ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lo lp lq lr b">$ npx create-react-app todo-app-ts</code></p><ul class=""><li id="70ce" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">这需要一段时间，但一旦完成，应该有一个名为<code class="fe lo lp lq lr b">todo-app-ts</code>的文件夹。将终端中的目录更改为该项目，并运行这些命令来安装typescript。</li></ul><p id="08ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lo lp lq lr b">$ npm i typescript @types/node @types/react @types/react-dom</code></p><p id="1982" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先我们安装TypeScript，然后安装Node、React和React-DOM的类型声明。稍后我会解释它们的意思。</p><p id="05d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会注意到一个'<em class="le"> tsconfig.json </em>'文件已经用typescript配置自动创建了。如果这个文件是用webpack创建的，则必须手动将它放在那里。</p><ul class=""><li id="d613" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">用您选择的文本编辑器/IDE打开项目(我使用<a class="ae kf" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>)。然后打开<code class="fe lo lp lq lr b">package.json</code>文件。您的<code class="fe lo lp lq lr b">react</code>和<code class="fe lo lp lq lr b">react-dom</code>版本应该在16.7.0以上，如果没有，请运行安装新版本。</li></ul><p id="cbf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lo lp lq lr b">$ npm i react@16.8.0-alpha.1 react-dom@16.8.0-alpha.1</code></p><ul class=""><li id="4246" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">打开src文件夹，将<strong class="ki iu"> index.js </strong>和<strong class="ki iu"> App.js </strong>重命名为<strong class="ki iu"> index.tsx </strong>和<strong class="ki iu"> App.tsx </strong></li><li id="03a7" class="ni nj it ki b kj nw kn nx kr ny kv nz kz oa ld np nq nr ns bi translated">要运行服务器，键入<code class="fe lo lp lq lr b">npm start</code>或<code class="fe lo lp lq lr b">yarn start</code>，您的浏览器将打开(如果已经打开，将显示一个新标签),屏幕如下:</li></ul><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/03a513820cf437cd11bf0cc814b6519e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfLM3shAv-giaLZ47lxVRg.png"/></div></div></figure><h1 id="f59e" class="mk ml it bd mm mn oc mp mq mr od mt mu mv oe mx my mz of nb nc nd og nf ng nh bi translated">创建待办事项列表</h1><p id="1b49" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">现在我不能把这个教程的所有功劳都揽下来，原文是由<a class="ae kf" href="https://scotch.io/@sarahjorgenson5" rel="noopener ugc nofollow" target="_blank"> Sarah Jorgenson </a>在Scotch.io <a class="ae kf" href="https://scotch.io/tutorials/build-a-react-to-do-app-with-react-hooks-no-class-components" rel="noopener ugc nofollow" target="_blank">这里</a>写的。我只是把它改得稍微简单一点，用打字稿写的。</p><ul class=""><li id="8654" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">导航到<code class="fe lo lp lq lr b">App.tsx</code>，删除所有代码，替换为:</li></ul><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7ba3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了第四行之外，代码看起来像普通的javascript，</p><p id="884d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lo lp lq lr b">function App(): JSX.Element {</code></p><p id="66a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">冒号后的代码告诉TypeScript该函数将返回什么数据类型。<code class="fe lo lp lq lr b">JSX.Element</code>不是本机TypeScript类型，它是从React类型声明文件导入的。如果你正在使用VSCode，你可以在<code class="fe lo lp lq lr b">JSX</code>或<code class="fe lo lp lq lr b">Element</code>上<code class="fe lo lp lq lr b">option + click</code>查看它来自哪里。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/eeb1279623117cb6c2db5d8a81e15d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HhoxF67Yr4xS5XXAGFyRpQ.gif"/></div></div></figure><p id="f8be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lo lp lq lr b">index.d.ts</code>中有很多东西，你不需要知道里面的每样东西都是做什么的，我只是觉得看看它来自哪里会有帮助。</p><ul class=""><li id="5391" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">删除你的<code class="fe lo lp lq lr b">App.tsx</code>文件中的第5行并用这个替换它。</li></ul><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="883a" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">同样在第1行导入片段:</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="3ad3" class="or ml it lr b gy os ot l ou ov">import React, { Fragment, useState } from ‘react’</span></pre><ul class=""><li id="421e" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">保存并返回您的浏览器，您应该会看到一个简单的表单和标题待办事项列表。</li></ul><p id="5f66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们添加第一个钩子。</p><ul class=""><li id="e9b4" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">在第4行<code class="fe lo lp lq lr b">const [value, setValue] = useState("")</code>下面添加此行，并从<code class="fe lo lp lq lr b">Fragment</code>旁边的第1行导入<code class="fe lo lp lq lr b">useState</code>。</li></ul><p id="be06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lo lp lq lr b">useState()</code>钩子将默认状态作为一个参数，并返回一个包含两个内容的数组，即状态和用于更新状态的函数。常见的是用<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">数组解构</a>给每个数组项一个变量，但本质上上面那行和写的一样；</p><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="863e" class="or ml it lr b gy os ot l ou ov">const valueState = useState("")<br/>const value = valueState[0]<br/>const setValue = valueState[1]</span></pre><p id="11ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你熟悉状态在React中是如何工作的，<code class="fe lo lp lq lr b">value</code>就像是类组件中的<code class="fe lo lp lq lr b">this.state</code>，而<code class="fe lo lp lq lr b">setValue</code>有点像<code class="fe lo lp lq lr b">setState</code></p><ul class=""><li id="5c1a" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">向input元素添加一些属性，如下所示</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="71c0" class="or ml it lr b gy os ot l ou ov">&lt;input <br/>  type="text" <br/>  value={value} <br/>  onChange={<em class="le">e</em> <em class="le">=&gt;</em> setValue(e.target.value)} <br/>  required <br/>/&gt;</span></pre><ul class=""><li id="7e67" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">保存并刷新浏览器。如果一切顺利，应该没什么变化。</li></ul><p id="08c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，新的输入属性对应于您刚刚创建的钩子，<code class="fe lo lp lq lr b">value</code>链接到值变量，<code class="fe lo lp lq lr b">onChange</code>具有<code class="fe lo lp lq lr b">setValue</code>函数，它传递输入到输入中的任何内容。如果您编写<code class="fe lo lp lq lr b">console.log(value)</code>并在输入中键入一些内容，您将会更好地理解正在发生的事情。</p><h2 id="1ea0" class="or ml it bd mm ow ox dn mq oy oz dp mu kr pa pb my kv pc pd nc kz pe pf ng pg bi translated">泛型类型</h2><ul class=""><li id="baa4" class="ni nj it ki b kj nk kn nl kr nm kv nn kz no ld np nq nr ns bi translated">因为这是一个TypeScript教程，所以让我们给钩子添加一个类型。</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="dd66" class="or ml it lr b gy os ot l ou ov"><em class="le">const</em> [value, setValue] = useState&lt;<em class="le">string</em>&gt;("");</span></pre><p id="7b43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解这是如何工作的以及为什么工作，让我们看看<code class="fe lo lp lq lr b">useState</code>函数的类型定义。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ph"><img src="../Images/71a64fc5e95d21fdf3e6cdc34b1792ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fa7E3qEFHWPeA52_ulgC7w.gif"/></div></div></figure><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="1f14" class="or ml it lr b gy os ot l ou ov"><em class="le">function</em> useState&lt;S&gt;(<em class="le">initialState</em>: S | (() <em class="le">=&gt;</em> S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];</span></pre><p id="f23a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的,<code class="fe lo lp lq lr b">useState</code>旁边有<code class="fe lo lp lq lr b">&lt;S&gt;</code>,每当你在typescript中看到<code class="fe lo lp lq lr b">&lt;&gt;</code>,这意味着函数(方法或接口)接受一种泛型。这意味着它接受任何类型。泛型通常有一个大写字母(在本例中是<code class="fe lo lp lq lr b">S</code>，但它可以是任何东西)。这意味着无论用户用什么类型来代替<code class="fe lo lp lq lr b">S</code>，那种类型都会使用它。<code class="fe lo lp lq lr b">S</code>这有点像争论。</p><p id="742f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Us键入<code class="fe lo lp lq lr b">useState&lt;string&gt;</code>使其成为使用状态的类型</p><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="7568" class="or ml it lr b gy os ot l ou ov">useState(<em class="le">initialState</em>: string | (() <em class="le">=&gt;</em> string)): [string, Dispatch&lt;SetStateAction&lt;string&gt;&gt;];</span></pre><p id="31dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着<code class="fe lo lp lq lr b">useState</code>函数接受一个字符串作为初始状态，或者<code class="fe lo lp lq lr b">|</code>函数返回一个字符串。useState函数返回一个包含字符串和这个<code class="fe lo lp lq lr b">Dispatch&lt;SetStateAction&lt;string&gt;&gt;</code>的数组，对于本教程，你不需要知道它的作用，所以我不会太担心它。</p><ul class=""><li id="c4b1" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">您的代码现在应该如下所示。</li></ul><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="e6db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们防止页面在提交时刷新，并显示我们的待办事项。</p><ul class=""><li id="4ce6" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">在第9行，让我们添加一个<code class="fe lo lp lq lr b">onSubmit</code>属性，它调用一个即将被编写的<code class="fe lo lp lq lr b">handleSubmit</code>函数<code class="fe lo lp lq lr b">&lt;form onSubmit={handleSubmit}&gt;</code></li><li id="a723" class="ni nj it ki b kj nw kn nx kr ny kv nz kz oa ld np nq nr ns bi translated">在return上面创建我们的<code class="fe lo lp lq lr b">handleSubmit</code>作为常量函数，如下所示:</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="d319" class="or ml it lr b gy os ot l ou ov">const handleSubmit = e =&gt; {<br/>  e.preventDefault()<br/>  setValue("")<br/>}</span></pre><p id="151e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会立即注意到你得到一个类似于<code class="fe lo lp lq lr b">Type error: Parameter 'e' implicitly has an 'any' type.</code>的错误，这是因为在默认的TypeScript中，你必须显式定义事件的类型。让我们暂时给<code class="fe lo lp lq lr b">e</code>一个显式类型的any <code class="fe lo lp lq lr b">(e: any)</code>这样应该可以解决这个问题。</p><p id="dfda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单介绍一下您新编写的函数将要做的事情:<code class="fe lo lp lq lr b">preventDefault</code>将在表单提交时停止刷新，而<code class="fe lo lp lq lr b">setValue("")</code>将把输入中的值转换成一个空字符串。随意注释掉某些行，看看它们有什么效果。</p><p id="11cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们给新函数添加一些类型。</p><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="4320" class="or ml it lr b gy os ot l ou ov">const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;): void =&gt; {<br/>  e.preventDefault()<br/>  setValue("")<br/>}</span></pre><p id="68a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的,<code class="fe lo lp lq lr b">React.FormEvent</code>是一个泛型，在这种情况下它接受<code class="fe lo lp lq lr b">HTMLFormElement</code>,但是它看起来比我们孤独的<code class="fe lo lp lq lr b">e</code>长了一点。</p><h2 id="cfe1" class="or ml it bd mm ow ox dn mq oy oz dp mu kr pa pb my kv pc pd nc kz pe pf ng pg bi translated">Typescript类型别名</h2><p id="6943" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">我们可以在TypeScript中使用关键字<code class="fe lo lp lq lr b">type</code>来移动<code class="fe lo lp lq lr b">e</code>的类型，就像变量一样。</p><ul class=""><li id="04d2" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">在<code class="fe lo lp lq lr b">function App()</code>上方写下以下内容</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="4c02" class="or ml it lr b gy os ot l ou ov">type FormElem = React.FormEvent&lt;HTMLFormElement&gt;</span></pre><ul class=""><li id="dabc" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">现在重写e，使这个<code class="fe lo lp lq lr b">e: FormElem</code>看起来更好。</li></ul><p id="b5db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能还注意到了箭头函数前的单词<code class="fe lo lp lq lr b">void</code>，这表示函数将返回void类型，这意味着它不会返回任何东西。</p><p id="3165" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们为待办事项列表创建一个存储位置。</p><ul class=""><li id="676d" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">在我们的第一个钩子下面添加以下内容</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="21a6" class="or ml it lr b gy os ot l ou ov"><em class="le">const</em> [todos, setTodos] = useState&lt;ITodo[]&gt;([]);</span></pre><p id="0120" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在保存此更改时，您应该会看到错误<code class="fe lo lp lq lr b">Type error: Cannot find name 'ITodo'</code>，这是有意义的，因为我们还没有创建它，现在让我们来创建它。</p><h2 id="39c0" class="or ml it bd mm ow ox dn mq oy oz dp mu kr pa pb my kv pc pd nc kz pe pf ng pg bi translated">类型脚本接口</h2><p id="62e6" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">就在我们的type <strong class="ki iu"> FormElem </strong>下面，让我们写下:</p><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="4024" class="or ml it lr b gy os ot l ou ov"><em class="le">interface</em> ITodo {<br/>  text: <em class="le">string</em>;<br/>  complete: <em class="le">boolean</em>;<br/>}</span></pre><p id="6173" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，<code class="fe lo lp lq lr b">ITodo</code>接口是一个带有类型<code class="fe lo lp lq lr b">string</code>的<strong class="ki iu">文本</strong>和类型<code class="fe lo lp lq lr b">boolean</code>的<strong class="ki iu">完成</strong>的对象。在接口名前加上<code class="fe lo lp lq lr b">I</code>是可选的，它通常用来表示一个变量是一个接口。</p><p id="0c85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你可能在想，我们可以把它写成类型别名。</p><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="01d3" class="or ml it lr b gy os ot l ou ov">type Todo = {text: string; complete: boolean;}</span></pre><p id="80a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那我们为什么没有呢？</p><h2 id="8003" class="or ml it bd mm ow ox dn mq oy oz dp mu kr pa pb my kv pc pd nc kz pe pf ng pg bi translated"><strong class="ak">接口和类型别名的区别</strong></h2><p id="4a4d" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">类型别名有利于引用其他类型，它们不会创建全新的类型。一个接口就是这么做的，我们的<code class="fe lo lp lq lr b">ITodo</code>是一个全新的类型，如果有错误，它将被引用。</p><p id="114a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">别名不能被扩展，我们不会在这里讨论这个，但是我们想做这样的事情</p><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="03df" class="or ml it lr b gy os ot l ou ov">// Works<br/><em class="le">interface</em> ITodo2 extends <em class="le">ITodo</em> {<br/>  tag: <em class="le">string<br/></em>}</span></pre><p id="af22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这在使用接口时有效，但不像这样；</p><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="4e73" class="or ml it lr b gy os ot l ou ov">// Does not work<br/>type =  ITodo2 extends ITodo {<br/> tag: string<br/>}</span></pre><p id="ebbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是使用接口的一个缺点是它不能真正用于不是对象的变量。因此，我们仍将使用类型别名。</p><p id="0801" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面你还会注意到<code class="fe lo lp lq lr b">ITodo</code>旁边有方括号<code class="fe lo lp lq lr b">[]</code>，这意味着我们的<code class="fe lo lp lq lr b">useState</code>正在等待ITodo的数组。这也可以写成一个通用的<code class="fe lo lp lq lr b">Array&lt;ITodo&gt;</code>你也可以这么做。</p><ul class=""><li id="a7ee" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">到目前为止，我们的代码应该是这样的:</li></ul><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b02c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们快到了。</p><ul class=""><li id="c485" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">在我们的handle下面创建一个新函数提交一个名为，<strong class="ki iu"> addTodo </strong>的函数</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="3379" class="or ml it lr b gy os ot l ou ov"><em class="le">const</em> addTodo = (<em class="le">text</em>: <em class="le">string</em>): <em class="le">void</em> <em class="le">=&gt;</em> {<br/>  <em class="le">const</em> newTodos: ITodo[] = [...todos, { text, complete: false }];<br/>  setTodos(newTodos);<br/>};</span></pre><p id="227e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它接受一个string类型的参数，并添加一个新的数组<code class="fe lo lp lq lr b">newTodos</code>,包含我们现有的todos数组和一个新的对象。然后用<code class="fe lo lp lq lr b">setTodos</code>函数将其传递给我们的todo状态。我希望这些都有意义。</p><ul class=""><li id="9491" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">在我们的<code class="fe lo lp lq lr b">handleSubmit</code>函数中添加这一新行<code class="fe lo lp lq lr b">addTodo(value)</code>，它将把我们的输入<code class="fe lo lp lq lr b">value</code>添加到我们的<code class="fe lo lp lq lr b">todos</code>状态。</li><li id="e216" class="ni nj it ki b kj nw kn nx kr ny kv nz kz oa ld np nq nr ns bi translated">在return上方添加一个<code class="fe lo lp lq lr b">console.log(todos)</code>，查看控制台中发生了什么。</li></ul><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pi"><img src="../Images/5ec3fab00994a13dc7c0dc3cc917c2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*geoIWDDkEaqxv7t6tW0Beg.gif"/></div></div></figure><p id="e8c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的新todo应该包含在您的<code class="fe lo lp lq lr b">todos</code>对象中。</p><p id="d18e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们显示这些待办事项。</p><ul class=""><li id="1a44" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">就在结束的<code class="fe lo lp lq lr b">&lt;/Fragment&gt;</code>标签之前，用下面的代码创建一个<code class="fe lo lp lq lr b">&lt;section&gt;</code>；</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="3ebb" class="or ml it lr b gy os ot l ou ov">&lt;section&gt;<br/>  {todos.map((todo: ITodo, index: number) =&gt; (<br/>    &lt;div&gt;{todo.text}&lt;/div&gt;<br/>  ))}<br/>&lt;/section&gt;</span></pre><p id="a972" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面是我们的todos数组的map方法，有一个回调函数和两个参数。类型为<strong class="ki iu"> ITodo、</strong>的数组中的todo项和类型为number的<strong class="ki iu">索引</strong>。</p><p id="f367" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当您在待办事项列表中键入一些内容并按回车键时，您应该会看到它出现在屏幕上。尼斯（法国城市名）👍</p><ul class=""><li id="113e" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">到目前为止，您的代码应该如下所示。</li></ul><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="ok ol l"/></div></figure><blockquote class="lx ly lz"><p id="1e0f" class="kg kh le ki b kj kk kl km kn ko kp kq ma ks kt ku mb kw kx ky mc la lb lc ld im bi translated">您会注意到上面的代码没有任何分号。我摆弄了一下<a class="ae kf" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>设置，决定<a class="ae kf" href="https://standardjs.com/rules.html#semicolons" rel="noopener ugc nofollow" target="_blank">不包括它们</a>。不要担心代码仍然会工作。</p></blockquote><h2 id="2a46" class="or ml it bd mm ow ox dn mq oy oz dp mu kr pa pb my kv pc pd nc kz pe pf ng pg bi translated">额外功能</h2><p id="df8d" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">在这一点上，我想教的大部分主题已经基本涵盖。这里的其余步骤都是可选的，但是欢迎您跟着做。</p><p id="43ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将添加通过点击一个标记为<strong class="ki iu"> x </strong>的按钮来删除我们的待办事项的功能，以及通过点击一个按钮来切换一个项目完成或未完成的功能，该按钮将在项目上放置一个线条样式。如果您对Javascript和React有一定的经验，我建议您在查看我的解决方案之前尝试自己实现这两个特性。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><ul class=""><li id="c087" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">让我们在我们的<strong class="ki iu"> addTodo </strong>下面创建一个<strong class="ki iu"> completeTodo </strong>函数</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="d0b1" class="or ml it lr b gy os ot l ou ov"><em class="le">const</em> completeTodo = (<em class="le">index</em>: <em class="le">number</em>): <em class="le">void</em> <em class="le">=&gt;</em> {<br/>  <em class="le">const</em> newTodos: ITodo[] = todos<br/>  newTodos[index].complete = !newTodos[index].complete<br/>  setTodos(newTodos)<br/>}</span></pre><p id="7614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数接受一个index参数，并创建一个Todos数组的克隆，名为，<strong class="ki iu"> newTodos，</strong>(这样我们就不会改变原来的todos)。然后，我们使用index定位todo对象中的<strong class="ki iu"> complete </strong>属性。然后我们用setTodos函数将其设置为新的todo数组。简单吧？</p><ul class=""><li id="3735" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">在我们的<strong class="ki iu"> todo.map </strong>的return语句中，用下面的代码在我们的div下面创建一个按钮；</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="32d1" class="or ml it lr b gy os ot l ou ov">&lt;button type='button' onClick={() <em class="le">=&gt;</em> completeTodo(index)}<br/>  {todo.complete ? 'Incomplete' : 'Complete'}<br/>&lt;/button&gt;</span></pre><p id="c741" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这创建了一个带有三进制操作符<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">的按钮，根据<strong class="ki iu"> todo.complete </strong>的内容决定显示什么文本。该按钮在被点击时运行<strong class="ki iu"> completeTodo </strong>函数，将迭代索引作为属性。</a></p><ul class=""><li id="40f9" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">现在将div和新按钮包装在一个<code class="fe lo lp lq lr b">&lt;div&gt;</code>中，并将<code class="fe lo lp lq lr b">key={index}</code>道具移动到父div中。</li><li id="56a1" class="ni nj it ki b kj nw kn nx kr ny kv nz kz oa ld np nq nr ns bi translated">此外，出于样式原因，将该属性添加到我们的父div <code class="fe lo lp lq lr b">style={{ display: 'flex'}}</code></li><li id="a861" class="ni nj it ki b kj nw kn nx kr ny kv nz kz oa ld np nq nr ns bi translated">然后在我们的div上用我们的<code class="fe lo lp lq lr b">{todo.text}</code>添加一个样式属性，如下所示:</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="b4db" class="or ml it lr b gy os ot l ou ov">style={{ textDecoration: todo.complete ? 'line-through' : '' }}</span></pre><p id="1552" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<strong class="ki iu"> todo.complete </strong>为真，这将为文本添加一个<code class="fe lo lp lq lr b">line-through</code>样式。</p><ul class=""><li id="06c3" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">要删除todo项目，请使用以下代码创建一个名为<strong class="ki iu"> removeTodo </strong>的函数。</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="5303" class="or ml it lr b gy os ot l ou ov"><em class="le">const</em> removeTodo = (<em class="le">index</em>: <em class="le">number</em>): <em class="le">void</em> <em class="le">=&gt;</em> {<br/>  <em class="le">const</em> newTodos: ITodo[] = todos<br/>  newTodos.splice(index, 1)<br/>  setTodos(newTodos)<br/>}</span></pre><p id="50e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与我们的completeTodo函数非常相似，只有一点小小的不同。该函数不是切换todo对象的complete属性，而是使用splice方法从数组中完全删除该对象，然后使用setTodos函数将其替换为现有的todos数组。</p><ul class=""><li id="9c00" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">在我们的完成/未完成按钮下面，让我们用下面的代码添加另一个按钮。</li></ul><pre class="lt lu lv lw gt on lr oo op aw oq bi"><span id="17b8" class="or ml it lr b gy os ot l ou ov">&lt;button onClick={() <em class="le">=&gt;</em> removeTodo(index)}&gt;x&lt;/button&gt;</span></pre><ul class=""><li id="dba4" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">完成上述操作后，您的代码应该类似于:</li></ul><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="cd88" class="ni nj it ki b kj kk kn ko kr nt kv nu kz nv ld np nq nr ns bi translated">你的应用程序应该是这样的:</li></ul><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pj"><img src="../Images/93dbab92fbf6bf5d6379af52e5b55900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zDxhK3cO3F-5LbISVPjThQ.gif"/></div></div></figure><h1 id="d23f" class="mk ml it bd mm mn oc mp mq mr od mt mu mv oe mx my mz of nb nc nd og nf ng nh bi">👏 🎉 👍</h1></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="479c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我真的希望你已经发现这是有用的，并没有太难跟随。计划是再写几篇关于打字稿和React更多特性的文章，比如<a class="ae kf" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">使用效果</a>、<a class="ae kf" href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html" rel="noopener ugc nofollow" target="_blank">备忘录</a>、悬念和<a class="ae kf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">背景</a>。</p><p id="a6cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有任何问题，请随时在本文中发表评论。如果不是快乐编码。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><figure class="lt lu lv lw gt ju gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi pk"><img src="../Images/b62413b7c7ec47e9b1212d1f624904d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szVYYV-196U4G4zx0_1gUg.png"/></div></a></figure><div class="pl pm gp gr pn po"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd iu gy z fp pt fr fs pu fu fw is bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">前48名React教程。课程由开发人员提交并投票，使您能够找到最佳反应…</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">gitconnected.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc jz po"/></div></div></a></div><div class="pl pm gp gr pn po"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd iu gy z fp pt fr fs pu fu fw is bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">前18名打字稿教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">gitconnected.com</p></div></div><div class="px l"><div class="qd l pz qa qb px qc jz po"/></div></div></a></div></div></div>    
</body>
</html>