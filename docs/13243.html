<html>
<head>
<title>Using AWS RDS Proxy on Lambda with a Shared Connection Pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过共享连接池在Lambda上使用AWS RDS代理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-aws-rds-proxy-with-lambda-with-a-shared-connection-pool-88407be71425?source=collection_archive---------0-----------------------#2022-08-19">https://levelup.gitconnected.com/using-aws-rds-proxy-with-lambda-with-a-shared-connection-pool-88407be71425?source=collection_archive---------0-----------------------#2022-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/be2cc91daf5dc4f8a990e03f95fe0729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Dcdw3aJIoq88OEnDl5pwA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">本杰明·雷曼在<a class="ae kf" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="24d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们考虑AWS中的数据库时，首先想到的解决方案是AWS RDS，尽管现在AWS提供了多个其他解决方案。但是由于这些新解决方案的许多限制，许多开发人员仍然选择RDS而不是其他解决方案，如Aurora和DynamoDB等。将这些解决方案相互比较需要自己的帖子，所以我现在不会这样做。</p><p id="ca9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RDS目前提供下列数据库引擎。</p><ul class=""><li id="4e82" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">关系型数据库</li><li id="9338" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">一种数据库系统</li><li id="980a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">MariaDB</li><li id="4207" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">神谕</li><li id="3b27" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">SQL Server</li></ul><p id="d97c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们开发连接到任何这些数据库引擎的应用程序时，最佳实践是使用连接池，而不是每次我们想要从数据库查询时都创建一个新的连接。许多ORM库默认这样做，以减少开发人员的开销。但是对于无服务器架构(AWS Lambda，Azure Functions等等)，这引入了一个新问题，<strong class="ki iu">我们不能使用无服务器架构的连接池</strong>。</p><h2 id="eea3" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">为什么不能用Lambda的连接池？</h2><p id="80b2" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">为了回答这个问题，我们需要深入了解Lambda在幕后是如何工作的。Lambda是一个小的应用程序代码，我们可以在没有任何服务器的情况下运行它。对于开发者来说，没有任何服务器是正确的，但是对于AWS来说，它们是在服务器上运行的。但这是从开发人员那里抽象出来的，所以我们不需要担心任何服务器，这是无服务器架构的主要吸引力。但是AWS是怎么做到的呢？下面是Lambda的生命周期。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/3017d6a68baf17e5d9edcf3a4121c106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-v_XmA4NR_7BSPaCf7msw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.linkedin.com/pulse/aws-lambda-constraint-shanmuga-ks/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/AWS-lambda-constraint-shanmuga-ks/</a></figcaption></figure><p id="02ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们创建一个Lambda函数时，我们首先打包代码(zip ),然后上传到AWS(S3)。一旦我们的Lambda代码需要执行，下面的步骤将按以下顺序完成。</p><ul class=""><li id="b5d6" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="ki iu">初始化函数</strong> —下载打包代码，添加依赖项，找到合适的服务器并初始化。</li><li id="fd9b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu">执行</strong>—lambda(我们编写的)内部的代码将被执行。</li><li id="3bc2" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu">就绪</strong> —一旦执行完成，它将进入就绪状态，等待下一次执行。</li><li id="d6ec" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu">丢弃</strong> — AWS将释放与Lambda函数相关的资源。如果该功能处于就绪状态大约15分钟没有任何执行，就会发生这种情况。</li></ul><p id="fa7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你应该有的问题是为什么AWS需要这个<strong class="ki iu">丢弃</strong>步骤。这就是AWS对Lambda收费的原因。AWS只对Lambda的执行时间收费，所以当我们的Lambda没有被调用时，将不收费。但是当我们的代码使用服务器资源时，AWS会产生费用。因此，每当AWS发现我们的Lambda不再被调用时，它就会执行这个<strong class="ki iu">丢弃</strong>步骤来释放服务器资源。</p><p id="d56e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道了lambda生命周期是如何工作的，让我们看看我们最初的问题，为什么我们不能将连接池用于Lambda？这有两个原因。</p><ul class=""><li id="ded5" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">首先是因为这个<strong class="ki iu">丢弃</strong>步骤。假设当lambda函数被调用时，我们初始化了一个新的连接池。如果Lambda在被丢弃之前被调用，我们可以重用相同的连接。一旦<strong class="ki iu">丢弃</strong>步骤完成，我们的连接池也将丢失。</li><li id="1f7b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">第二个是为每个lambda函数生成一个新的连接池。因此，当多个lambda函数并行执行时，我们将拥有多个连接池，这违背了使用连接池本身的目的。</li></ul><p id="a0ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于上述原因，我们不能在Lambda函数中使用连接池。这意味着我们不能在Lambda函数中使用RDS？幸运的是，答案是否定的，我们可以通过RDS代理将RDS与Lambda函数一起使用。</p><h2 id="f4d1" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">RDS代理</h2><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/c7d411bae79c21fd69e4e19e0dffdf36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGHtUWx0HW-_bVMfaF8fCw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://aws.amazon.com/rds/proxy/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/rds/proxy/</a></figcaption></figure><p id="c545" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RDS代理是AWS提供的一个解决方案，用于解决我们上面刚刚描述的场景，即如何在无服务器架构环境中管理数据库连接。它还有其他用途，但在这篇文章中，我们只讨论它如何解决我们的问题。在我们的问题中，将根据调用的Lambda函数的数量创建大量的数据库连接。RDS代理通过共享数据库连接解决了这个问题。下面是我们用Lambda函数配置RDS代理时的流程。</p><ul class=""><li id="43ae" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">Lambda将调用RDS代理，而不是直接调用RDS实例来获取数据库连接。</li><li id="88bb" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">基于连接池的可用性，一个连接将被返回给我们的Lambda函数。</li><li id="00e5" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">Lambda函数将使用此连接来连接到数据库。</li><li id="8d17" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">一旦函数调用完成，此连接将被删除并返回连接池。</li></ul><p id="f6c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，不是每个Lambda都有自己的连接，而是在RDS代理中有一个共享的连接池，它将管理到RDS实例的连接。因此，RDS和无服务器应用程序的问题现在有了适当的解决方案。</p><p id="1bdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，既然我们已经知道了为什么需要使用RDS代理，那么让我们在下一节开始实现。</p><h2 id="a354" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">设置VPC</h2><p id="b4f6" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">首先，我们需要设置一个VPC，以便创建一个RDS实例。(因为我们需要两个私有子网)</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="53d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用上述云形成模板，它将生成</p><ul class=""><li id="495d" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">两个公共子网</li><li id="f5a4" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">两个专用子网(将在其中创建RDS实例)</li><li id="01e7" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">两个互联网网关，因此私有子网资源可以与互联网通信</li></ul><p id="bfa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个cloudformation模板将有许多输出，但是我们接下来想要的是</p><ul class=""><li id="0728" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">子网导出导出</li><li id="dc39" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">子网扩展</li></ul><p id="b248" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保记住创建堆栈时提供的名称，因为下一步将会用到它。</p><h2 id="b014" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">设置RDS实例</h2><p id="ed45" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">现在，我们已经有了带有两个私有子网的VPC，我们可以继续在创建的VPC中创建一个RDS实例。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1195" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的模板中，有大量的输入参数。但是我们只需要用创建VPC堆栈时提供的名称填充<strong class="ki iu"> ParentVPCStack </strong>参数。</p><p id="b715" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的模板是用于创建MySQL实例的，但是你可以通过改变<strong class="ki iu">引擎版本</strong>参数<strong class="ki iu">将它用于RDS支持的任何数据库引擎。</strong></p><p id="7e68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦该模板成功运行，它将生成以下资源</p><ul class=""><li id="1822" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">专用子网中的RDS实例</li></ul><h2 id="e339" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">设置RDS代理</h2><p id="8075" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">现在我们可以继续创建我们的RDS代理。为了创建RDS代理，我们需要首先使用AWS secret manager创建一个秘密，在这里我们将RDS实例中使用的凭证传递给RDS代理。</p><p id="72dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">转到AWS Secrets并点击存储新的秘密</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/84f0dc8dfb1c10a376e0bc18eb913afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFklrtn45CWtFO3rRHkxDw.png"/></div></div></figure><p id="a594" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，为Amazon RDS数据库选择凭证，然后提供凭证。</p><p id="ad1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在数据库部分，选择正确的数据库。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5924c8f1facde2e5f9eb75b5f710b9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IODW3GByC0ZpTBpK_FowZQ.png"/></div></div></figure><p id="f9fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，提供机密名称和描述。确保记住下一步的秘密名称。</p><p id="6e02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">存储秘密后，我们可以运行下面的cloudformation模板来创建RDS代理。</p><p id="788e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于输入参数，提供以下内容</p><ul class=""><li id="4d93" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="ki iu">ParentVPCStack</strong>—VPC堆栈的名称</li><li id="4b6f" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu">ParentRDSStack</strong>—RDS堆栈的名称</li><li id="9945" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu"> SecretsManagerName </strong> —我们创建的秘密的名称</li></ul><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c310" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行模板后，下一步是将目标组与我们创建的RDS代理相关联。为此，请转到RDS -&gt;代理并选择目标组。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/e6d370391aac42561ee5bd339ef95e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCHKOjbpdfvCOmIout0PEQ.png"/></div></div></figure><p id="239d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点击编辑并选择正确的数据库。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/c32e14f5d4e7fe457958ab84514db96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJYbDtFPJMTXXvrugYNAUA.png"/></div></div></figure><p id="b03d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们必须使用RDS代理端点，而不是RDS实例端点。确保之后在Lambda代码中也进行更改。</p></div></div>    
</body>
</html>