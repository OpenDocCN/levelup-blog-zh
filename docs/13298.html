<html>
<head>
<title>A beginner’s guide to Monads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单子初学者指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-beginners-guide-to-monads-d0f1d958eb80?source=collection_archive---------4-----------------------#2022-08-24">https://levelup.gitconnected.com/a-beginners-guide-to-monads-d0f1d958eb80?source=collection_archive---------4-----------------------#2022-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4eb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单子提供了一种与封装在容器中的数据安全交互的方式。这是一个抽象且有时令人困惑的概念，但它是函数式语言的核心特性，有助于以惯用的方式处理错误和管理副作用。</p><p id="d261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文需要函数式编程的基础知识，最好是使用Haskell。我们将讨论以下主题:</p><ul class=""><li id="19f4" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">关于字体类别和种类的提示；</li><li id="3afb" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">函子、应用和单子数据类；</li><li id="7476" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">Haskell中的不确定性；</li><li id="ae1d" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在Haskell中管理输入和输出；</li><li id="c83b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">do</code>词块和单子的句法糖。</li></ul><h1 id="1eb3" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">基础</h1><p id="36cd" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">Haskell中的类型可以分为<em class="mg">种</em>。种类表示一个类型可以接受的参数。例如，<code class="fe kz la lb lc b">Int</code>的种类是<code class="fe kz la lb lc b">*</code>，这意味着没有更多的参数可以应用于它。<code class="fe kz la lb lc b">Maybe</code>可以特化为<code class="fe kz la lb lc b">Maybe t</code>用于某种类型的<code class="fe kz la lb lc b">t</code>，所以其种类为<code class="fe kz la lb lc b">* -&gt; *</code>。我们可以通过在GHCI中键入<code class="fe kz la lb lc b">:kind t</code>来检查类型<code class="fe kz la lb lc b">t</code>的种类。</p><p id="e859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">允许执行相似操作的类型可以组合在一起形成一个<em class="mg">类型类</em>。一个类型类由一个名称和一个签名列表来表征。它类似于数学中的一个代数结构:我们不用研究整数、矩阵或复数的集合，而是可以研究一般集合，在这些集合上定义了满足某些性质的一些运算。例如，Haskell有一个类型类<code class="fe kz la lb lc b">Ord</code>,用于标识可以订购的对象。对于在<code class="fe kz la lb lc b">Ord</code>类中的类型<code class="fe kz la lb lc b">t</code>，它需要实现一个函数来比较它的元素:<code class="fe kz la lb lc b">(&lt;=) :: t -&gt; t -&gt; bool</code>。我们可以认为任何实现这种函数的类型都属于<code class="fe kz la lb lc b">Ord</code>类，但是我们假设它的行为方式和我们期望的比较函数一样:它必须是自反的、反对称的和可传递的。预计它还将定义一个总订单。</p><h1 id="b9f3" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">函子</h1><p id="59fe" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">一个<em class="mg">仿函数</em>是一种类型，允许将一个函数应用到它所包含的元素，并得到它的输出，<em class="mg">封装了</em>。更准确地说，它是一种被赋予了功能<code class="fe kz la lb lc b">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>的类型。<code class="fe kz la lb lc b">fmap</code>的用途是将一个函数应用到仿函数中<code class="fe kz la lb lc b">a</code>类型的元素，并返回仿函数中函数的输出。那边关于它的更多:<a class="ae mh" href="https://hackage.haskell.org/package/base-4.16.2.0/docs/Prelude.html#t:Functor" rel="noopener ugc nofollow" target="_blank">https://hackage . haskell . org/package/base-4 . 16 . 2 . 0/docs/prelude . html # t:Functor</a>。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/ec922164c4385ae7c7a7dc37c44a3736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBaRlJMMLYIjhaFwjrG0nQ.png"/></div></div></figure><p id="68d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">Maybe</code>是Haskell中最常见的函子之一。它的<code class="fe kz la lb lc b">fmap</code>接受一个函数<code class="fe kz la lb lc b">g</code>和一个输入<code class="fe kz la lb lc b">x :: Maybe a</code>，如果<code class="fe kz la lb lc b">x = Just y</code>返回<code class="fe kz la lb lc b">Just (g y)</code>，如果<code class="fe kz la lb lc b">x = Nothing</code>返回<code class="fe kz la lb lc b">Nothing</code>。<code class="fe kz la lb lc b">fmap</code>有一个内嵌别名<code class="fe kz la lb lc b">&lt;$&gt;</code>。</p><p id="7acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果您试图从一个API获取一个<code class="fe kz la lb lc b">[Char]</code>并接收到一个您想要反转的<code class="fe kz la lb lc b">Maybe [Char]</code>，您可以使用带有内置<code class="fe kz la lb lc b">reverse :: [Char] -&gt; [Char]</code>的<code class="fe kz la lb lc b">fmap</code>，如下所示:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="634e" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">应用程序</h1><p id="9b3f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">当使用形式为<code class="fe kz la lb lc b">a -&gt; b</code>的签名操作函数时，仿函数非常有用。如果我们将<code class="fe kz la lb lc b">fmap</code>与带多个参数的函数一起使用，<code class="fe kz la lb lc b">fmap</code>将返回一个新函数，该函数包含在一个仿函数中:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fb87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<code class="fe kz la lb lc b">Applicative</code>类型类派上用场的地方。一个<em class="mg">应用</em>是一个被赋予了两个额外功能的函子:<code class="fe kz la lb lc b">pure</code>和<code class="fe kz la lb lc b">(&lt;*&gt;)</code>(后者是一个内嵌运算符，读作<em class="mg"> app </em>)。<code class="fe kz la lb lc b">pure</code>获取一个值并将其包装在应用程序中。例如，<code class="fe kz la lb lc b">Maybe</code>的<code class="fe kz la lb lc b">pure</code>实现(也是一个应用程序，也是一个单子，我们将在后面看到)简单地调用<code class="fe kz la lb lc b">Just</code>。<code class="fe kz la lb lc b">(&lt;*&gt;)</code>接受包装在应用程序中的函数<code class="fe kz la lb lc b">g :: a -&gt; b</code>和包装在应用程序中的类型为<code class="fe kz la lb lc b">b</code>的对象。它返回一个包装在应用程序中的类型为<code class="fe kz la lb lc b">c</code>的对象。<code class="fe kz la lb lc b">(&lt;*&gt;)</code>有签名<code class="fe kz la lb lc b">Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</code>。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mw"><img src="../Images/1b21c84f877ed3deb3c31d5cb27949ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCVcoPo5s6imX1oOb_uPhg.png"/></div></div></figure><p id="ec9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kz la lb lc b">Maybe</code>的情况下，如果<code class="fe kz la lb lc b">g = Just h</code>和<code class="fe kz la lb lc b">x = Just y</code>，<code class="fe kz la lb lc b">g &lt;*&gt; x</code>返回<code class="fe kz la lb lc b">Just h y</code>，否则返回<code class="fe kz la lb lc b">Nothing</code>。下面是我们如何计算两个<code class="fe kz la lb lc b">Maybe Int</code>的和<code class="fe kz la lb lc b">x</code>和<code class="fe kz la lb lc b">y</code>的方法，如果它们都是明确定义的，返回<code class="fe kz la lb lc b">Nothing</code>，如果其中一个是<code class="fe kz la lb lc b">Nothing</code>:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="5fe1" class="mx le iq bd lf my mz dn lj na nb dp ln jy nc nd lr kc ne nf lv kg ng nh lz ni bi translated">多一层抽象；不确定性</h2><p id="a2fb" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果我们考虑一个任意的函数<code class="fe kz la lb lc b">g :: a -&gt; b</code>，我们可以定义<code class="fe kz la lb lc b">g' = pure g</code>。<code class="fe kz la lb lc b">g'</code>的型号为<code class="fe kz la lb lc b">Applicative f =&gt; f (a -&gt; b)</code>。不需要关于<code class="fe kz la lb lc b">f</code>的信息，除了它是<code class="fe kz la lb lc b">Applicative</code>的一个实例。然后，我们可以使用<code class="fe kz la lb lc b">(&lt;*&gt;)</code>在任何特定应用程序提供的上下文中评估<code class="fe kz la lb lc b">g</code>。比如如果<code class="fe kz la lb lc b">g x = 2 * x</code>那么<code class="fe kz la lb lc b">g' &lt;*&gt; Just 1 = Just 2</code>和<code class="fe kz la lb lc b">g' &lt;*&gt; Nothing = Noting</code>。这种行为是由<code class="fe kz la lb lc b">Maybe</code>的<code class="fe kz la lb lc b">(&lt;*&gt;)</code>操作符的定义决定的:每个应用<code class="fe kz la lb lc b">f</code>都定义了当<code class="fe kz la lb lc b">app</code>产生一个围绕<code class="fe kz la lb lc b">f</code>的值时函数的特定行为方式。</p><p id="4acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了了解这是如何有用的，让我们看看另一个应用程序。</p><p id="da5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Haskell中的列表也是<code class="fe kz la lb lc b">Applicative</code>的实例。当一个列表被用作一个应用程序时，它代表一个不确定的赋值:<code class="fe kz la lb lc b">[1, 2, 3]</code>作为一个变量，它可以取值<code class="fe kz la lb lc b">1</code>、<code class="fe kz la lb lc b">2</code>或<code class="fe kz la lb lc b">3</code>。因此，如果我们将一个列表<code class="fe kz la lb lc b">xs :: [a]</code>T21到<code class="fe kz la lb lc b">h :: Applicative f =&gt; f (a -&gt; b)</code>中，我们将得到另一个列表<code class="fe kz la lb lc b">ys :: [b]</code>，其中包含在<code class="fe kz la lb lc b">xs</code>的每个值上评估的函数值。这与将<code class="fe kz la lb lc b">map</code>应用于展开的函数相同。</p><p id="372f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当我们使用带多个参数的函数时，事情变得更有趣了。例如，<code class="fe kz la lb lc b">pure (+) &lt;*&gt; [1, 2, 3] &lt;*&gt; [4, 5, 6]</code>计算出一个列表，其中包含将第一个列表中的元素添加到第二个列表中的元素时可以获得的所有值。更一般地说，如果<code class="fe kz la lb lc b">f :: a1 -&gt; ... -&gt; an</code>那么<code class="fe kz la lb lc b">pure f &lt;*&gt; [x11, ..., x1k] &lt;*&gt; ... &lt;*&gt; [xn1, ..., xnk]</code>包含应用<code class="fe kz la lb lc b">f y1 ... yn</code>获得的所有值，其中<code class="fe kz la lb lc b">y1 = x1p</code>用于某些<em class="mg"> p </em>，…，<code class="fe kz la lb lc b">yn = xnq</code>用于某些<em class="mg"> q </em>。</p><h1 id="946b" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">单子</h1><p id="219a" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">一个<em class="mg">单子</em>是一个被赋予了一个额外运算符的应用程序:<code class="fe kz la lb lc b">(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</code>，读作<em class="mg"> bind </em>。Bind接受封装在monad中的输入，monad是一个接受原始输入并给出封装输出的函数，它返回函数的封装输出。通过再次使用绑定操作符，封装的输出<code class="fe kz la lb lc b">x :: m b</code>可以依次传递给函数<code class="fe kz la lb lc b">f :: b -&gt; m c</code>:<code class="fe kz la lb lc b">(&gt;&gt;=)</code>的一个优点是它可以很容易地被链接。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nj"><img src="../Images/d8d7963e9fc429db28599628f6641d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwBhCGgV5ApjyC7AJjyGng.png"/></div></div></figure><p id="f626" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个简单的例子:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4b58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想对一个有理数应用三种运算。没有为所有的推理定义操作，所以它们返回一个<code class="fe kz la lb lc b">Fractional a =&gt; Maybe a</code>。我们不是将每个输出与<code class="fe kz la lb lc b">Nothing</code>或<code class="fe kz la lb lc b">Just x</code>匹配，而是使用<code class="fe kz la lb lc b">(&gt;&gt;=)</code>链接应用程序，如果结果定义良好，则返回<code class="fe kz la lb lc b">Just</code>，如果某处出现问题，则返回<code class="fe kz la lb lc b">Nothing</code>。</p><p id="8368" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单子有两个额外的方法，它们不是最小定义的一部分(也就是说，如果没有明确定义它们，它们的定义是从最小定义中推断出来的):<code class="fe kz la lb lc b">(&gt;&gt;)</code>和<code class="fe kz la lb lc b">return</code>。Return充当<code class="fe kz la lb lc b">pure</code>:它将其输入封装到一个单子中。在其默认定义中，<code class="fe kz la lb lc b">return</code>等于<code class="fe kz la lb lc b">pure</code>。<code class="fe kz la lb lc b">(&gt;&gt;)</code>的签名是<code class="fe kz la lb lc b">Monad m =&gt; m a -&gt; m b -&gt; m b</code>。它取两个封装的值<code class="fe kz la lb lc b">x :: m a</code>和<code class="fe kz la lb lc b">y :: m b</code>并在评估<code class="fe kz la lb lc b">x</code>后返回<code class="fe kz la lb lc b">y</code>。其默认实现如果<code class="fe kz la lb lc b">m &gt;&gt; k = m &gt;&gt;= (\_ -&gt; k)</code>。这可能看起来很混乱，你可能不明白为什么我们会需要这样的函数，但是一旦你读了下一节就会明白了。</p><h2 id="72e2" class="mx le iq bd lf my mz dn lj na nb dp ln jy nc nd lr kc ne nf lv kg ng nh lz ni bi translated">应用:输入/输出</h2><p id="7120" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">管理输入和输出(I/O)从根本上来说是无功能的:其行为依赖于来自文件的输入或写入文件的函数是不确定的。然而，在一元类型的帮助下，我们可以使不纯的行为显化。出于这个原因，Haskell包含了几个允许以安全的方式操作I/O的特性。</p><p id="2701" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们使用<code class="fe kz la lb lc b">Maybe</code>来封装可能没有定义的对象一样，我们使用类型<code class="fe kz la lb lc b">IO</code>来封装为I/O而来的对象。例如，我们可以使用函数<code class="fe kz la lb lc b">putStrLn :: String -&gt; IO ()</code>在终端中打印一行。使用<code class="fe kz la lb lc b">(&gt;&gt;)</code>，我们可以通过如下方式链接对<code class="fe kz la lb lc b">putStrLn</code>的调用来打印多个内容:<code class="fe kz la lb lc b">putStrLn "hello" &gt;&gt; putStrLn "what's your" &gt;&gt; putStrLn "name?"</code>:前两个调用的结果被丢弃(反正我们也不需要)，但文本仍然被打印出来。</p><p id="61d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">I/O函数的另一个有用的例子是<code class="fe kz la lb lc b">getLine :: IO String</code>。如果我们想打印<code class="fe kz la lb lc b">getLine</code>的结果，即终端中写入的行，我们可以使用<code class="fe kz la lb lc b">&gt;&gt;=</code>将封装的字符串发送到<code class="fe kz la lb lc b">putStrLn</code>。如果我们想要将任何函数<code class="fe kz la lb lc b">f :: String -&gt; a</code>应用到终端输入，我们可以使用<code class="fe kz la lb lc b">&gt;&gt;=</code>将封装的字符串发送到一个函数中，该函数封装了<code class="fe kz la lb lc b">f</code>应用到其输入的结果，即<code class="fe kz la lb lc b">\x -&gt; return $ f x</code>。<code class="fe kz la lb lc b">getLine &gt;&gt;= (\x -&gt; return $ f x)</code>的结果是类型<code class="fe kz la lb lc b">IO a</code>，并且可以通过<em class="mg">绑定</em>到另一个函数<code class="fe kz la lb lc b">g :: a -&gt; IO b</code>。</p><p id="23f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这些属性，我们可以要求用户输入他的名字，然后输入他的姓，输出他的全名。</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f6a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很美，不是吗？我们一起来分解一下。</p><ul class=""><li id="dc31" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">我们从在终端中写消息开始。与这个表达式的结果无关，所以我们简单地丢弃它，并移到<code class="fe kz la lb lc b">&gt;&gt;</code>的右边。</li><li id="9a77" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们读了一个<code class="fe kz la lb lc b">IO String</code>。</li><li id="8586" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们将由<code class="fe kz la lb lc b">IO String</code>(用户输入的字符串)封装的值传递给一个lambda函数。该值被绑定到名称<code class="fe kz la lb lc b">forename</code>。</li><li id="fc26" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们打印一些文本，丢弃结果，继续前进。</li><li id="40c8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们读取另一个<code class="fe kz la lb lc b">IO String</code>，并将底层字符串传递给一个lambda函数。用户输入的字符串被绑定到名称<code class="fe kz la lb lc b">surname</code>。</li><li id="6c22" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe kz la lb lc b">forename</code>和<code class="fe kz la lb lc b">surname</code>是两个字符串:我们可以把它们连接起来，得到全称。我们返回全名，封装的(因为这是<code class="fe kz la lb lc b">&gt;&gt;=</code>的类型需求)。</li><li id="fb7a" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们通过使用<code class="fe kz la lb lc b">&gt;&gt;=</code>将底层值传递给<code class="fe kz la lb lc b">putStrLn</code>来打印封装的全名。</li></ul><p id="261d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！</p><p id="3b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，这看起来真的很酷，但这肯定不是执行如此简单操作的合理方式。这激发了本文的最后一节，在这里我们将引入一些语法糖，使所有这些看起来更好。</p><h1 id="e953" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">Do符号</h1><p id="f6f6" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><code class="fe kz la lb lc b">do</code>块是具有以下形式的块:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">do</code>-在某种意义上，块允许在Haskell程序中编写命令性代码。</p><p id="a3ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个接一个地编写多个指令就像用<code class="fe kz la lb lc b">&gt;&gt;</code>把它们链接起来一样。例如，我们可以打印多行，如下所示:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="cb77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">do</code>模块的另一个特征是<code class="fe kz la lb lc b">&lt;-</code>操作符，称为<em class="mg">去糖</em>操作符。左边是一个名字，右边是一个返回单子的表达式。比如我们可能会写<code class="fe kz la lb lc b">typed &lt;- getLine</code>。<code class="fe kz la lb lc b">typed</code>的类型将会是<code class="fe kz la lb lc b">String</code>。我们可以通过定义以下内容来构造去糖运算符:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="89d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1bff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们评估<code class="fe kz la lb lc b">g</code>的结果<code class="fe kz la lb lc b">m x</code>并将<code class="fe kz la lb lc b">x</code>绑定到块的其余部分。</p><p id="0431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kz la lb lc b">do</code>-符号，下面是我们如何重新编写程序来读取用户的名和姓并打印出他的全名:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1da9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哪个看起来更令人愉快…</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="26eb" class="ld le iq bd lf lg nr li lj lk ns lm ln lo nt lq lr ls nu lu lv lw nv ly lz ma bi translated">分级编码</h1><p id="b7b3" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="43bb" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="c624" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">📰查看<a class="ae mh" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="e7f0" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">🔔关注我们:<a class="ae mh" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae mh" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mh" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="755b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae mh" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>