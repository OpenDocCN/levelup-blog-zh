# 如何分割熊猫的数据帧

> 原文：<https://levelup.gitconnected.com/how-to-slice-a-dataframe-in-pandas-884bd8b298a6>

![](img/07c70ffe60b084f5e8e3f38f8a44f7bb.png)

如何分割熊猫的数据帧

在 Pandas 中，数据通常以行和列的形式排列。数据帧是索引和类型化的二维数据结构。在 Pandas 中，您可以使用一种称为数据帧切片的技术从大型或小型数据集中提取您需要的数据。

在本指南中，我们将使用 Numpy 为我们创建一个数据集，然后使用 Pandas 对数据帧进行切片。

![](img/59f9ede3a7b426da700be8f7e2457dfb.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上 [Nery 黑山](https://unsplash.com/@neryfabiola_?utm_source=medium&utm_medium=referral)拍摄的照片

# 使用 NumPy 创建数据集

在分割数据帧之前，我们首先需要创建一个二维数据数组。二维数组是垂直和水平的表示形式，例如包含行和列的表格。我们将使用另一个流行的 Python 库 NumPy 及其 arrange()和 shape()函数来创建我们的表。

```
import numPy as npimport pandas as pddf = pd.DataFrame(np.arange(20).reshape(5,4), columns=[“A”, “B”, “C”, “D”])This line tells NumPy to create a list of integers from 0 to 19 values in the “shape” of 5 rows x 4 columns and to label the columns A through D.print(df)
```

输出:

```
**A B C D**0 0 1 2 31 4 5 6 72 8 9 10 113 12 13 14 154 16 17 18 19
```

现在我们有了数据集，我们可以用多种方式对它进行切片。

**注意**:Pandas data frame 语法采用操作符中的第一组索引进行行切片，第二组索引进行列切片。以下是一般规则:

```
df.loc[row slicing, column slicing]
```

**或**

```
 df.iloc[startrow:endrow, startcolumn:endcolumn]
```

当使用标签或整数对数据进行索引时，最好的方法通常是使用 **loc** 函数。

当数据仅使用整数进行索引时，最好的方法通常是使用 **iloc** 函数。

现在我们有了数据集和提取数据的方法，让我们通过一些例子来看看 Pandas 数据帧切片是如何工作的。

# 按标签分割行和列

以下是如何使用 loc 函数按标签对行和列进行切片的示例:

```
df.loc[:, “B”:”D”]
```

这一行使用切片操作符按标签获取 DataFrame 项。第一片 **[:]** 表示返回所有行。第二个片段指定只返回列 **B、C、**和 **D** 。结果如下所示。

输出:

```
**B C D**0 1 2 31 5 6 72 9 10 113 13 14 154 17 18 19
```

# 按索引位置对行和列进行切片

以下是如何使用 **iloc** 属性按索引位置对行和列进行切片的示例，重点是行切片:

```
df.iloc[0:2, :]
```

使用 iloc 函数，您可以在对列和行进行切片时指定范围甚至步骤。

在这种情况下，第一个片**【0:2】**只请求数据帧的第 0 到第 1 行。当在 Pandas 中按索引位置切片时，开始索引包括在输出中，但是停止索引超出了您想要选择的行一步。因此，切片返回第 0 行和第 1 行，但不返回第 2 行。

第二个片段 **[:]** 表示所有列都是必需的。结果如下所示。

输出:

```
**A B C D**0 0 1 2 31 4 5 6 7
```

# 使用 iloc 属性对列进行切片

以下是如何使用 **iloc** 属性进行切片的另一个示例，重点是列切片:

```
df.iloc[:, 1:3]
```

在这种情况下，第一个运算符[:]要求返回所有行。

第二个操作符**【1:3】**只产生列 **B** 和 **C** 。这是因为我们的数据帧包含列 **A** (索引 0)到列 **D** (索引 3)。回想一下，当通过索引对数据帧进行切片时，我们指定了超出我们想要的一列的停止边界。在这种情况下，我们告诉 pandas 从索引 1 **(B)** 到索引 3 **(D)** 的列进行切片，但不包括索引 3 **(D)** 。这将只返回索引为 1 和 2 的列。结果如下所示。

输出:

```
**B C**0 1 21 5 62 9 103 13 144 17 18
```

# 使用 iloc 属性对特定行和列进行切片

下一个示例显示了如何使用 **iloc** 属性对一组特定的行和列进行切片:

```
df.iloc[1:2, 1:3]
```

第一个操作员**【1:2】**只请求第 1 行到第 2 行。这仅产生 1 行，因为您实际上是告诉 pandas 从索引 1 开始并选择索引 2，但是排除 2，因为它是最后一个索引。

第二个操作符**【1:3】**只生成了列 **B** 到 **C** 。记住我们的数据帧有列 **A** (索引 0)到列 **D** (索引 3)。我们得到这些结果是因为我们告诉 pandas 从索引 1 到 3 的列中切片，排除索引 3。这将只生成索引为 1 和 2 的列。结果如下所示。

```
Output:B C1 5 6
```

# 使用 iloc 属性对特定行和列进行切片的替代方法

最后，如何使用 **iloc** 属性分割一组特定的行和列的另一个示例:

```
df.iloc[:2, :2]
```

第一个操作符 **[:2]** 需要从行开始到第二行**(即第 0 行和第 1 行)**的数据。第二个运算符 **[:2]** 需要从列开始到第 2 列**(即 A 和 B)** 的数据。输出如下所示。

```
Output:A B0 0 11 4 5
```

谢谢大家，好好享受吧！