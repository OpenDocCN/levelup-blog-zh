<html>
<head>
<title>NET Core Wrapper for SC2 API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SC2 API的. NET核心包装器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/net-core-wrapper-for-sc2-api-e0c0346e895b?source=collection_archive---------5-----------------------#2020-08-30">https://levelup.gitconnected.com/net-core-wrapper-for-sc2-api-e0c0346e895b?source=collection_archive---------5-----------------------#2020-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/66cf8e1b4fee6aa4695f5e00cf8b1043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6EGVB03KGP3PJLSd.jpg"/></div></div></figure><p id="e934" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本文假设您正在开发。NET核心，并打算使用NydusNetwork。我尝试在文章中预先载入一般适用的知识，这样它就可以为其他包装器的用户提供价值。</em></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="f7f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">星际争霸2的API包含了相当多的消息。它们都被包装在消息中，所以这是您将发送的唯一消息——客户端将用包含所有可能响应的消息进行响应。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/d44351a6df2ee9fde8add5a58c85cbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsP4ZADhKevVP2repasGbA.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><em class="ln">请求</em>发送到客户端的基本流程。作者图解。</figcaption></figure><p id="87aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该图展示了一个简单代理请求消息流。这些是创建一个正常运行的机器人的唯一必要的<em class="kw">请求</em>(在<em class="kw">实时</em>模式中甚至可以省略该步骤)——但是理解所有类型是有益的；</p><ul class=""><li id="11c7" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated"><strong class="ka ir"> CreateGame </strong> <br/>设置一个新游戏，相当于在常规游戏中创建一个大厅。该消息只能在<em class="kw">启动</em>状态或<em class="kw">结束</em>状态下发送。<br/> - <em class="kw">禁用迷雾，</em>如果关闭将允许你的机器人看到一切(没有战争迷雾)。<br/> - <em class="kw">实时，</em>告诉客户端不要等待StepRequest来推进游戏。<br/> - <em class="kw">玩家设置，</em>每个玩家的种族和‘类型’(AI或暴雪AI)列表。<br/> - <em class="kw">本地地图，</em>游戏地图路径玩<strong class="ka ir">或</strong> <br/> - <em class="kw">战场地图名称，</em>SC2官方地图名称</li><li id="0f14" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir"> JoinGame </strong> <br/>开始你主持的游戏或加入另一个主持人。此消息包含您的<a class="ae mc" href="https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L564" rel="noopener ugc nofollow" target="_blank"> <em class="kw">界面选项</em> </a>，您可以在其中告诉客户您的代理需要什么信息。被称为<em class="kw"> raw </em>的是游戏状态的一个表示，作为一个可见单元、方块等的列表。这对计算机来说很容易解释。这相当于能够一次看到整个地图——这是人类组件永远做不到的。另一种选择是<em class="kw">特征层</em>——通过多种颜色编码的<em class="kw">图像</em>表示的游戏状态，更接近人类可用的信息(用于机器学习)。</li><li id="8048" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir">离开游戏</strong> <br/>离开比赛的空消息。</li><li id="9646" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir">快速保存</strong> <br/>快速保存的空消息。</li><li id="30c0" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir">快速加载</strong> <br/>清空加载之前快速保存的信息。</li><li id="f702" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir">退出</strong> <br/>关闭客户端的空消息(优雅地)。适用于所有州。</li><li id="a8c0" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">观察者可以应用的动作(非玩家)。</li><li id="c6d7" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir">步骤</strong> <br/>要求客户端用x <em class="kw">步骤推进游戏模拟。</em>默认情况下，客户端会在推进游戏前等待这条消息，除非是在<em class="kw">实时</em>中玩，这可以在<em class="kw">创建游戏中配置。</em></li><li id="8241" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">查询 <br/>请求关于路径、可用能力和建筑布局的信息。</li><li id="95d7" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir"> SaveReplay </strong> <br/>将游戏保存为重播——可以在<em class="kw">游戏内</em>或在<em class="kw">结束</em>状态下完成。</li><li id="73fc" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir"> ReplayInfo </strong> <br/>加载关于重播的元数据。</li><li id="0d03" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">可用地图获取可用地图列表。如果您的客户端从未下载过地图，此列表可以为空。<a class="ae mc" href="https://github.com/Blizzard/s2client-proto#downloads" rel="noopener ugc nofollow" target="_blank">手动下载</a>或者在你想要的地图上用普通客户端创建游戏强制下载。</li><li id="18e0" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir">保存地图</strong> <br/>将地图数据保存到本地路径。</li><li id="1ab5" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir"> MapCommand </strong> <br/>手动执行一个map触发器。</li><li id="dd15" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir"> Ping </strong> <br/>嗯……令人惊讶的不是一个真正的Ping消息。客户端以游戏版本、数据版本、数据构建版本和基础构建版本进行响应。</li><li id="3175" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated"><strong class="ka ir"> Debug <br/> </strong>执行一个<em class="kw"> DebugCommand </em>的列表，它允许你在屏幕上绘图或者通过繁殖单位、杀死单位、更新它们的值等操作游戏。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="dfee" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">安装API包装程序</h1><p id="c4f6" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated"><em class="kw">使用API包装器可以帮你省去很多麻烦——很多！本节假设您正在编写。NET核心，并希望使用NydusNetwork作为您的API包装器，但您可以在其他语言中找到许多替代品</em> <a class="ae mc" href="https://wiki.sc2ai.net/Main_Page" rel="noopener ugc nofollow" target="_blank"> <em class="kw">这里</em> </a> <em class="kw">。你也可以从头开始写你自己的，在这种情况下，这个指南可能会有用；</em></p><div class="ng nh gp gr ni nj"><a rel="noopener  ugc nofollow" target="_blank" href="/guide-to-starcraft-ii-proto-api-264811da8a50"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">星际争霸2原型API指南</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">官方星际争霸2 API介绍——一个请求/响应消息系统，允许你建立自己的AI…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jw nj"/></div></div></a></div><p id="8cbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NydusNetwork是一个用。NET Core，它是作为Abathur框架的一部分创建的，但被编写为一个独立的组件，可以独立于Abathur使用。如果你打算选择完整的框架体验，我推荐克隆SC2Abathur。</p><p id="3579" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，要在没有Abathur的情况下继续，只需使用nuget包管理器安装它，并开始在您的定制bot中使用它。当Abathur封装NydusNetwork时，我假设您选择了这种方法。</p><pre class="lf lg lh li gt ny nz oa ob aw oc bi"><span id="03d5" class="od me iq nz b gy oe of l og oh">Install-Package NydusNetwork</span></pre><p id="4607" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">通过软件包管理器控制台</em>安装NydusNetwork</p><pre class="lf lg lh li gt ny nz oa ob aw oc bi"><span id="3e04" class="od me iq nz b gy oe of l og oh">dotnet add package NydusNetwork</span></pre><p id="37f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">通过dotnet CLI安装NydusNetwork】</em></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="649b" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">使用NydusNetwork</h1><p id="cdfb" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">正在导入<em class="kw">nydusneweb。模型</em>让你可以访问官方星际争霸2 API支持的所有消息类型。NydusNetwork最基本的用法是简单地使用<em class="kw"> SendRequest(Request r) </em>向客户端发送原始消息。</p><pre class="lf lg lh li gt ny nz oa ob aw oc bi"><span id="7692" class="od me iq nz b gy oe of l og oh">using NydusNetwork;<br/><br/>namespace AdequateSource<br/>{<br/>  class Example<br/>  {<br/>    void QuitGame(GameClient client)<br/>      =&gt; client.QuitRequest();<br/>  }<br/>}</span></pre><p id="4dbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上所有的API包装器都会给你这个直接的客户端原始接口，但是NydusNetwork比瘦API包装器多了一些额外的特性。</p><h2 id="3d1f" class="od me iq bd mf oi oj dn mj ok ol dp mn kj om on mr kn oo op mv kr oq or mz os bi translated">人手不足</h2><p id="6fcc" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">其中最基本的是空请求的缩写。API包含了相当多的空请求消息，所以它允许我们稍微清理一下代码。</p><pre class="lf lg lh li gt ny nz oa ob aw oc bi"><span id="be1d" class="od me iq nz b gy oe of l og oh">using NydusNetwork;<br/><br/>namespace AdequateSource<br/>{<br/>  class Example<br/>  {<br/>    void QuitGame(GameClient client)<br/>      =&gt; client.QuitRequest();<br/>  }<br/>}</span></pre><h2 id="bc3e" class="od me iq bd mf oi oj dn mj ok ol dp mn kj om on mr kn oo op mv kr oq or mz os bi translated">完成游戏初始化</h2><p id="3835" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">NydusNetwork也有助于游戏创作。初始化方法将根据提供的设置连接到客户端，如果客户端应用程序没有运行，则启动该方法。确认连接后，只需调用<em class="kw"> CreateGameRequest() </em>和<em class="kw"> JoinGameRequest() </em>即可启动并运行。这些方法也支持本地多人游戏(bot vs bot)。</p><pre class="lf lg lh li gt ny nz oa ob aw oc bi"><span id="fd90" class="od me iq nz b gy oe of l og oh">using NydusNetwork;<br/>using NydusNetwork.API.Protocol;<br/>using NydusNetwork.Model;<br/>using System.Collections.ObjectModel;<br/><br/>namespace AdequateSource<br/>{<br/>  class Example<br/>  {<br/>    void Initilize() {<br/>      var client = new GameClient(<br/>        new GameSettings<br/>        {<br/>          FolderPath = @"C:\Program Files (x86)\StarCraft II",<br/>          ConnectionAddress = "127.0 0.1",<br/>          ConnectionServerPort = 8165,<br/>          ConnectionClientPort = 8170,<br/>          MultiplayerSharedPort = 8175,<br/>          InterfaceOptions = new InterfaceOptions {<br/>            Raw = true, Score = true<br/>          },<br/>          Fullscreen = false,<br/>          ClientWindowWidth = 1024,<br/>          ClientWindowHeight = 768,<br/>          GameMap = "Cloud Kingdom LE",<br/>          Realtime = false,<br/>          DisableFog = false,<br/>          ParticipantRace = Race.Random,<br/>          Opponents = new Collection&lt;PlayerSetup&gt; {<br/>            new PlayerSetup {<br/>              Type = PlayerType.Computer,<br/>              Race = Race.Random,<br/>              Difficulty = Difficulty.VeryEasy<br/>            }<br/>          }<br/>        }<br/>      );<br/>      client.Initialize(asHost: true);<br/>      client.CreateGameRequest();<br/>      client.JoinGameRequest();<br/>    }<br/>  }<br/>}</span></pre><h2 id="5950" class="od me iq bd mf oi oj dn mj ok ol dp mn kj om on mr kn oo op mv kr oq or mz os bi translated">得到回应</h2><p id="c36f" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">支持从客户端获取响应的两种方式。最简单的是<em class="kw"> TryWait{Type}Request </em>，其中阻塞执行流，直到请求被接收或失败。此方法支持可选的超时。</p><p id="b317" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二种方法是注册一个监听特定响应类型的处理程序。每次收到该类型的响应时都会调用该处理程序，直到您注销该处理程序。这就是<em class="kw">try wait { Type }请求</em>在后台实现的方式。</p><pre class="lf lg lh li gt ny nz oa ob aw oc bi"><span id="10cf" class="od me iq nz b gy oe of l og oh">using NydusNetwork;<br/>using NydusNetwork.API.Protocol;<br/>using System;<br/><br/>namespace AdequateSource<br/>{<br/>  class Example<br/>  {<br/>    void Ping(GameClient client) {<br/>      if (client.TryWaitPingRequest(out var r, wait: 3000))<br/>        Console.WriteLine(r.Ping.GameVersion);<br/>    }<br/><br/>    void ListenForPing(GameClient client)<br/>    {<br/>      var action = new Action&lt;Response&gt;(r =&gt; {<br/>        Console.WriteLine($"Heard ping! {r.Ping.GameVersion}");<br/>      });<br/>      client.RegisterHandler(Response.ResponseOneofCase.Ping, action);<br/>    }<br/>  }<br/>}</span></pre><h1 id="91a3" class="md me iq bd mf mg ot mi mj mk ou mm mn mo ov mq mr ms ow mu mv mw ox my mz na bi translated">为什么是经手人？</h1><p id="30c5" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">客户端不是一个整洁的小rest API，当你调用它的时候它会回答，它是一个web socket，当你高兴的时候它会回答你。有些请求不会立即得到客户的答复。例如，<em class="kw"> StepRequest </em>一旦客户端从游戏中的每个人那里收到，就会得到响应——这在单人游戏中意味着立即，但在多人游戏中可以是任何时候。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/f93745590428c8faf8340ac1bcb2b480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hx2wvF1lOfRdwgF3sb6mjg.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">web套接字流的临时图表。作者图解。</figcaption></figure><p id="f126" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着<em class="kw">请求</em>可能不会以相同的顺序接收<em class="kw">响应</em>。然而，客户端会确保按顺序处理相同类型的请求，因此例如<em class="kw">动作请求</em>将总是按顺序处理(或者可以替换游戏)。注意，同一个单元的多个动作将<em class="kw">覆盖</em>它的动作。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="d5b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于2020年8月30日https://adequatesource.com</em><a class="ae mc" href="https://adequatesource.com/nydusnetwork/" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a><em class="kw">。</em></p></div></div>    
</body>
</html>