<html>
<head>
<title>Notification Services in Android O and Above</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android O及以上版本中的通知服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/showing-notifications-is-one-of-the-very-crucial-feature-to-add-in-an-android-app-4b7ada5bdba7?source=collection_archive---------6-----------------------#2020-04-20">https://levelup.gitconnected.com/showing-notifications-is-one-of-the-very-crucial-feature-to-add-in-an-android-app-4b7ada5bdba7?source=collection_archive---------6-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ac45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显示通知是添加到android应用程序中的非常重要的功能之一。作为开发人员，我们有责任及时向用户提供相关信息。我们也要记住，我们的用户不会对通知感到厌烦。系统UI上的一位Android工程师给出了如下引用:</p><blockquote class="kl km kn"><p id="cc21" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">“不要惹恼用户。尊重他们。赋予他们力量。取悦他们。</p><p id="6e09" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">把他们和他们关心的人联系起来。"</p><p id="ed42" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">~克里斯托弗·雷恩博士</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/57bebb57b790df2fffc62def26fe620b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1NK01rRPWifcdR5dnKR7w.jpeg"/></div></div></figure><p id="0f82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的目标是Android O和更高版本，为了做到这一点，我们需要知道以下三件事来发送通知。</p><ol class=""><li id="1e2a" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><a class="ae ln" href="https://developer.android.com/reference/android/app/NotificationChannel" rel="noopener ugc nofollow" target="_blank">通知渠道</a></li><li id="8573" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated">通知生成器</li><li id="b53c" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated">通知管理器</li></ol><h1 id="76c3" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">通知渠道</h1><p id="f058" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">通知通道需要一个id、名称和描述，我们将把它们定义为“私有静态最终字符串”。</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="2cd2" class="nb lu iq mx b gy nc nd l ne nf">public static final String <em class="ko">CHANNEL_ID </em>= "channel123";<br/>public static final String <em class="ko">CHANNEL_NAME </em>= "my notification";<br/>public static final String <em class="ko">CHANNEL_DESCRIPTION </em>= "Test";</span></pre><p id="a291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，为了创建我们的通道，我们将使用NotificationChannel类创建一个新的NotificationChannel对象(channel)，并将通道id、名称和重要性传递给构造函数。然后，我们将在通道对象上调用setDescription方法来设置通道描述。</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="87c7" class="nb lu iq mx b gy nc nd l ne nf">NotificationChannel <strong class="mx ir">channel</strong> = new NotificationChannel(<br/>                <strong class="mx ir"><em class="ko">CHANNEL_ID</em></strong>,<br/>                <strong class="mx ir"><em class="ko">CHANNEL_NAME</em></strong>,<br/>                NotificationManager.<em class="ko">IMPORTANCE_DEFAULT<br/>        </em>);<br/><strong class="mx ir">channel</strong>.setDescription(<em class="ko">CHANNEL_DESCRIPTION</em>);</span></pre><h1 id="3cbd" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">通知生成器</h1><p id="fee1" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们将使用NotificationCompat。生成器类来创建我们的通知生成器对象(mBuilder)。现在，我们将把上下文和通道id传递给构造函数。然后，我们还将几个方法链接到我们的构造函数上，以添加更多信息，如setSmallIcon以添加图标(很可能是一个<a class="ae ln" href="https://medium.com/@pypriyank/vector-assets-powerful-way-to-create-icons-and-menu-items-in-android-c28b469a7c9b" rel="noopener">矢量drawable </a>资产)，setContentTitle以添加通知的标题，setContentText以给出通知的正文，最重要的是，我们必须添加setPriority方法来分配我们要传递给用户的通知的优先级。设置优先级允许android设置给用户的警告类型。</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="f94f" class="nb lu iq mx b gy nc nd l ne nf">NotificationCompat.Builder <strong class="mx ir">mBuilder</strong> =<br/>        new NotificationCompat.Builder(this, <strong class="mx ir"><em class="ko">CHANNEL_ID</em></strong>)<br/>            .<strong class="mx ir">setSmallIcon</strong>(R.drawable.<em class="ko">ic_fiber_new_black_24dp</em>)<br/>            .<strong class="mx ir">setContentTitle</strong>("Hello, attention!")<br/>            .<strong class="mx ir">setContentText</strong>("Here's the notification you were looking for!")<br/>            .<strong class="mx ir">setPriority</strong>(NotificationCompat.<em class="ko">PRIORITY_DEFAULT</em>);</span></pre><h1 id="70ff" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">通知管理器</h1><p id="1a7b" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">通知管理器对象用于创建通道并通知用户。它分两部分完成，首先是创建我们的通知通道对象，为此我们使用NotificationManager对象和用户setSystemService(notification Manager . class)来创建对象(比如manager)。然后，我们将在manager对象上调用createNotificationChannel方法，并将Channel对象传递给它。</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="2332" class="nb lu iq mx b gy nc nd l ne nf">NotificationManager <strong class="mx ir">manager</strong> = getSystemService(NotificationManager.class);<br/><strong class="mx ir">manager</strong>.createNotificationChannel(<strong class="mx ir">channel</strong>);</span></pre><p id="e63b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，我们通过使用NotifyManagerCompat类来通知用户，并通过调用NotifyManagerCompat类(<strong class="jp ir"> mNotificationManager </strong>)上的"方法来创建<strong class="jp ir">对象</strong>。对于mNotificationManager对象，我们使用id为<strong class="jp ir">的</strong>和作为参数的<strong class="jp ir"> mBuilder.build() </strong>调用notify方法来发送通知。</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="b18a" class="nb lu iq mx b gy nc nd l ne nf">NotificationManagerCompat <strong class="mx ir">mNotificationManager</strong> = NotificationManagerCompat.<strong class="mx ir"><em class="ko">from</em></strong>(this);<br/>mNotificationManager.<strong class="mx ir">notify</strong>(1, <strong class="mx ir">mBuilder</strong>.build());</span></pre><h1 id="7f7f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">点击按钮时发送通知</h1><p id="0b34" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">为简单起见，我们将从点击按钮时显示通知开始。因此，在我们的布局中，我们将向activity_main.xml添加一个按钮。</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="b06b" class="nb lu iq mx b gy nc nd l ne nf">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".MainActivity"&gt;<br/><br/>    &lt;Button<br/>        android:id="@+id/btn_notify"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="@string/notify_me"<br/>        app:layout_constraintBottom_toBottomOf="parent"<br/>        app:layout_constraintEnd_toEndOf="parent"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/>&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span></pre><p id="37a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到，我们已经为按钮添加了一个id，这样我们就可以调用java代码并在其上设置OnClickListener。</p><p id="67ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们的代码在实现了所有关于概念之后的样子:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="493a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的小程序已经准备好测试了。因此，当我们运行我们的应用程序并点击我们放置的按钮时，您将听到一个警告音和一个通知弹出。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ni"><img src="../Images/8c090b491a2d29a574c6402be4961e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zm-rM-8gQc9FuNZbec-r3Q.png"/></div></div></figure><p id="5420" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在用户点击按钮后立即显示通知并不是一个非常实际的用例，所以接下来我们将看到如何设置一个剩余部分，以便在一定时间后显示通知，并且即使我们的应用程序关闭也必须通知。</p><h1 id="a828" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">显示剩余器械包的通知</h1><p id="47d2" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在一定时间后显示通知和即使我们的应用程序关闭也显示通知是我们将要添加的两个附加功能。首先，让我们看看如何显示通知，即使我们的应用程序是关闭的。因此，我们将使用<strong class="jp ir">广播接收器</strong>来接收。我们将创建一个扩展BroadcastReciever的单独的类，并将在该类中构建我们的通知。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="de0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在我们的android manifest中，我们将广播接收器添加到ReminderBroadcast类中。</p><p id="dacc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在AndroidManifest.xml文件的<application>中添加以下内容:</application></p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="9a38" class="nb lu iq mx b gy nc nd l ne nf">&lt;receiver android:name=".ReminderBroadcast" /&gt;</span></pre><p id="1ceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，要在按钮单击一定时间后发送通知，我们将首先创建意向对象和待定内容:</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="b0f1" class="nb lu iq mx b gy nc nd l ne nf">Intent intent = <br/>          new Intent(MainActivity.this, ReminderBroadcast.class);<br/>PendingIntent pendingIntent = PendingIntent<br/>          .<em class="ko">getBroadcast</em>(MainActivity.this, 0, intent, 0);</span></pre><p id="b01b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将使用AlarmManager类来设置通知的触发器，在我们的示例中，我们花费了10毫秒，但是当然，您可以根据需要任意取值，或者您可以很容易地从user中获取值。</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="cdf9" class="nb lu iq mx b gy nc nd l ne nf">AlarmManager alarmManager = (AlarmManager) getSystemService(<em class="ko">ALARM_SERVICE</em>);<br/><br/>long currentTime = System.<em class="ko">currentTimeMillis</em>();<br/>long timeInterval = 1000 * 10;        // = 10 seconds //<br/><br/>alarmManager.set(AlarmManager.<em class="ko">RTC_WAKEUP</em>, currentTime + timeInterval, pendingIntent);</span></pre><p id="754a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的应用程序可以运行了，这是我们的MainActivity.java的样子:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="006c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在每当用户点击按钮，通知将在十秒钟后弹出。使用这个概念，你可以为你自己的android应用程序创建通知。但是一定要明智地使用这些特性。</p></div></div>    
</body>
</html>