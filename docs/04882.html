<html>
<head>
<title>Why Dependency Injection Is a Good Thing for Us, the Programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么依赖注入对我们程序员来说是一件好事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-dependency-injection-is-a-good-thing-for-us-the-programmers-4bfcae3b485f?source=collection_archive---------12-----------------------#2020-07-21">https://levelup.gitconnected.com/why-dependency-injection-is-a-good-thing-for-us-the-programmers-4bfcae3b485f?source=collection_archive---------12-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a79" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这都是关于松散耦合的。让我们休息一会儿，我会解释这一切。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a70613a4a112b33e573c4113980d6438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r8VGaNQ91JdGcryD"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Christophe Hautier 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="e602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些例子是用Kotlin 编写的，但是没有利用它特殊的语法功能，以便每个程序员都能理解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的咖啡机不在咖啡站呢？如果相反，有一个空的空间，每次我们想喝咖啡，我们都必须从头开始建造机器。</p><p id="dc50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在软件中，一切都比现实运行速度快一百万倍，所以编写这样的代码是合理的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="52ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但问题是，在现实中，没有一台咖啡机可以用空的构造器来构建。虽然结构性能可能不是一个因素，但使用咖啡机时涉及的结构复杂性肯定会:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="c8db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能从代码中看出程序员在休息时间做什么吗？仅仅因为一个程序员没能造出咖啡机，她就应该不喝咖啡工作吗？在喝咖啡之前，怎么可能和所有这些人交谈呢？所有这些现在都是穷人<code class="fe me mf mg mh b">programmer</code>关心的问题，她只想喝她的咖啡。</p><h2 id="cbf7" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">但是你可以把它全部转移到另一个负责创建咖啡机的类中，对吗？</h2><p id="54f2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">好主意。这正是<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂设计模式</a>的意义所在。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="19b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它清理了代码，但是迟早它将不得不再次改变。这是因为我们这些程序员被宠坏了:我们喜欢品尝来自不同机器的咖啡，而这些机器不一定是在同一个工厂制造的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="7236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<strong class="lb iu">工厂推迟了建造复杂性</strong>但并没有使其消失。</p><h2 id="daf0" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">好的。那么你的建议是什么？</h2><p id="f3c2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在现实生活中，工具的构造和使用是两个相互分离的不同过程。人类总是利用这一点。想想吧。史前人类在准备刺猛犸象之前造出了他的矛吗？</p><p id="3350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们程序员休息的时候不需要忙着咖啡机的搭建。她当然不需要从工厂带新机器来。咖啡机只是程序员用来快速煮咖啡的工具，这样她就可以回到真正的工作:写代码！</p><h2 id="11b3" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">不错的理论。依赖注入与此有什么关系？</h2><p id="72ea" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">依赖注入是一种架构方法，其中类的构造代码和它们的使用被系统地分离。<strong class="lb iu">如何？</strong>有几种技巧，但其中之一是<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a><strong class="lb iu">构式依存倒置。</strong>这意味着<code class="fe me mf mg mh b">CoffeeMachine</code>结构不应该与使用它的<code class="fe me mf mg mh b">Programmer</code>紧密耦合<strong class="lb iu"> </strong>。相反:<code class="fe me mf mg mh b">Programmer</code>的建造，毫无疑问，应该依靠<code class="fe me mf mg mh b">CoffeeMachine</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><h2 id="4636" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">但是这不就是把咖啡机构造移到了容纳程序员的类吗？</h2><p id="f3e0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">不一定。以一个希望持有一个<code class="fe me mf mg mh b">Programmer</code>的<code class="fe me mf mg mh b">SoftwareCompanyX</code>为例:通过再次遵循<strong class="lb iu">依赖反转原则</strong>，我们将仅仅使<code class="fe me mf mg mh b">SoftwareCompanyX</code>的结构依赖于<code class="fe me mf mg mh b">Programmer</code>，而不是将<code class="fe me mf mg mh b">Programmer</code>的结构与<code class="fe me mf mg mh b">SoftwareCompanyX</code>紧密耦合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="32b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很棒，因为<code class="fe me mf mg mh b">Programmer</code>可以轻松地移动到另一个<code class="fe me mf mg mh b">SoftwareCompany</code>并在那里休息。她所需要的只是有人给她提供一份<code class="fe me mf mg mh b">CoffeeMachine</code>的推荐信，她就可以重操旧业了！</p><h2 id="95c2" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">你在开玩笑吗？最终，有人将不得不建造一切</h2><p id="3b32" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">没错。这个人将是<strong class="lb iu">唯一一个需要处理一个特定类簇的构造细节的人。这也将是他的单一责任。这个组合的根在大多数依赖注入框架中被称为<code class="fe me mf mg mh b">Module</code>。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="821d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<code class="fe me mf mg mh b">SoftwareCompanyModule</code>负责连接所有东西，只对外公开<code class="fe me mf mg mh b">SoftwareCompany</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><h2 id="ddec" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">有意思。那么我为什么需要依赖注入框架呢？</h2><p id="c2e6" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">仍然有一些问题需要答案:</p><ul class=""><li id="4aac" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">谁应该实例化一个模块？</li><li id="3d5d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如果一个模块依赖于其他模块怎么办？</li><li id="5112" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如何在几个地方共享同一个对象实例？</li><li id="9f03" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">单元测试呢？</li></ul><p id="0077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入框架有助于应对这些挑战，因此您可以专注于自己领域的挑战，而不是重新发明轮子。</p><p id="4b0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">咖啡休息时间已经结束了。谢谢你的倾听，我希望你学到了新的东西。我很想听听你的想法，并回答你可能有的关于这个话题的问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f421" class="nu mj it bd mk nv nw nx mn ny nz oa mq jz ob ka mt kc oc kd mw kf od kg mz oe bi translated">分级编码</h1><p id="0579" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">感谢您成为我们社区的一员！<a class="ae ky" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae ky" href="https://skilled.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="of og gp gr oh oi"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">编写面试问题</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">掌握编码面试的过程</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">技术开发</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>