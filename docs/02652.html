<html>
<head>
<title>Establish a WebRTC Connection: Video Call with WebRTC Step 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立WebRTC连接:使用WebRTC进行视频通话步骤3</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/establishing-the-webrtc-connection-videochat-with-javascript-step-3-48d4ae0e9ea4?source=collection_archive---------0-----------------------#2020-03-28">https://levelup.gitconnected.com/establishing-the-webrtc-connection-videochat-with-javascript-step-3-48d4ae0e9ea4?source=collection_archive---------0-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/812c78ae710091a7e150c75a216fce43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tppDJaUmidep9yNTg6kQRg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约翰·巴克利在<a class="ae kf" href="https://unsplash.com/s/photos/connection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2512" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">WebRTC (Web实时通信)是一个开源项目，允许您在浏览器之间创建对等连接。这种连接可以用于不同的目的，一个主要的目的是高质量和高性能的视频通话。本文是我们使用WebRTC创建这种视频聊天的系列文章的第三篇。你可以在那里找到前两篇文章:</p><ul class=""><li id="b108" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/data-stream-from-your-webcam-and-microphone-videochat-with-javascript-step-1-29895b70808b">第一步:来自网络摄像头和麦克风的数据流</a></li><li id="661c" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/set-up-a-connection-over-websocket-videochat-with-javascript-step-2-f78c307c4fd3">第二步:通过WebSocket建立连接</a></li></ul><p id="4749" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一篇文章中，我们在浏览器中访问了来自用户网络摄像头和麦克风的视频和音频流。第二，我们通过WebSocket实现了两个客户端的通信。我们将把这个例子用于信令过程。</p><p id="34b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将实际开始视频聊天。</p><h1 id="2fed" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">信令服务器</h1><p id="4b90" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">为了建立对等连接，对等体首先必须交换它们想要共享的媒体类型，告诉彼此它们何时想要开始或停止通信，并且它们必须在网络中找到彼此。这是信号传递过程。</p><p id="df9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">信号不是WebRTC规范的一部分。这意味着您必须自己负责交换建立和控制连接所需的消息。这也意味着你可以自由地使用任何你想要的交流机制。理论上你可以使用电子邮件，但是一个合理的解决方案是使用WebSocket。这就是为什么我们在前一篇文章中构建了一个WebSocket服务器，现在我们将对其进行一些调整以适应信号传输。</p><p id="a387" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">信令机制不需要知道任何关于正在交换的消息的信息。我们简化了之前创建的WebSocket服务器。要获得在Node上运行的帮助，请阅读本文<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/set-up-a-connection-over-websocket-videochat-with-javascript-step-2-f78c307c4fd3"/>。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e9d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们跟踪所有连接的客户。当客户端发送消息时，该消息被广播给每个人。这不是最终版本，但足以建立WebRTC连接。在下一篇文章中，我们将对其进行改进，允许用户找到他们想要聊天的人，并且只与她交流。</p><h1 id="654b" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">连接提议和回答</h1><p id="08e5" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">必须通过信令机制交换三种类型的消息:</p><ul class=""><li id="6f32" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">媒体数据:您想要共享哪种类型的媒体(仅音频或视频)，有哪些限制(例如质量)。</li><li id="c358" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">会话控制数据:打开和关闭通信。</li><li id="948f" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">网络数据:用户需要获得彼此的IP地址和端口，并检查他们是否可以建立对等连接。</li></ul><p id="a8eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们的用户叫做Alice和Bob。Alice必须首先创建连接提议并将其发送给Bob:</p><h2 id="92ba" class="nb lt it bd lu nc nd dn ly ne nf dp mc kr ng nh mg kv ni nj mk kz nk nl mo nm bi translated">提供</h2><p id="1803" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">1.如果还没有使用Bob的通信通道，Alice应该加入一个(我们使用运行在端口1337上的WebSocket服务器)。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="c449" class="nb lt it no b gy ns nt l nu nv">const signaling = new WebSocket('ws://127.0.0.1:1337');</span></pre><p id="2636" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.Alice在她的浏览器中创建了一个<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection" rel="noopener ugc nofollow" target="_blank"> RTCPeerConnection </a>对象。它是一个JavaScript接口，是WebRTC API的一部分，表示本地浏览器和远程对等点之间的连接。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="8bf6" class="nb lt it no b gy ns nt l nu nv">const peerConnection = new RTCPeerConnection({<br/>  iceServers: [{ urls: 'stun:stun.test.com:19000' }],<br/>});</span></pre><p id="f5a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传递给构造函数的参数包含ICE代理所需的服务器URL。更多关于这个稍后或<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/webrtc-the-ice-framework-stun-and-turn-servers-10b2972483bb">这里</a>。</p><p id="7d67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.Alice将她想要通过连接共享的音轨(音频和视频)添加到她的RTCPeerConnection对象中。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="7258" class="nb lt it no b gy ns nt l nu nv">const stream = await navigator.mediaDevices.getUserMedia({<br/>  audio: true,<br/>  video: true,<br/>});</span><span id="249e" class="nb lt it no b gy nw nt l nu nv">stream.getTracks().forEach(track =&gt; peerConnection.addTrack(<br/>  track,<br/>  stream,<br/>));</span></pre><p id="5845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.爱丽丝创造了一个<a class="ae kf" href="https://en.wikipedia.org/wiki/Session_Description_Protocol" rel="noopener ugc nofollow" target="_blank"> SDP </a>要约。SDP代表会话描述协议。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="de63" class="nb lt it no b gy ns nt l nu nv">const offer = await peerConnection.createOffer();</span></pre><p id="5291" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是用于描述通信参数的格式。它包含媒体描述和网络信息，看起来像这样。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="89ec" class="nb lt it no b gy ns nt l nu nv">   v=0<br/>   o=alice 123456789 123456789 IN IP4 some-host.com<br/>   s=-<br/>   c=IN IP4 some-host.com<br/>   t=0 0<br/>   <!-- -->m=audio 49170 RTP/AVP 0<br/>   a=rtpmap:0 PCMU/8000<br/>   <!-- -->m=audio 49170 RTP/AVP 31<br/>   a=rtpmap:31 H261/90000<br/>   <!-- -->m=audio 49170 RTP/AVP 32<br/>   a=rtpmap:32 MPV/90000</span></pre><p id="6dc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5.Alice通过调用<em class="nx"> setLocalDescription()将连接的本地描述设置为这个SDP。</em></p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="06b1" class="nb lt it no b gy ns nt l nu nv">await peerConnection.setLocalDescription(offer);</span></pre><p id="6403" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">6.Alice通过信令服务器将这个提议发送给Bob。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="fb31" class="nb lt it no b gy ns nt l nu nv">signaling.send(JSON.stringify({<br/>  message_type: MESSAGE_TYPE.SDP,<br/>  content: offer,<br/>}));</span></pre><h2 id="b5c3" class="nb lt it bd lu nc nd dn ly ne nf dp mc kr ng nh mg kv ni nj mk kz nk nl mo nm bi translated">回答</h2><p id="7d4b" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">Bob还必须连接到信令服务器，并且必须已经创建了RTCPeerConnection对象。在Alice向Bob发送报价后，Bob必须执行以下操作:</p><p id="b44f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1.Bob接收到Alice的提议，并将其设置为调用<em class="nx"> setRemoteDescription() </em>的RTCPeerConnection对象中的远程描述。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="5f20" class="nb lt it no b gy ns nt l nu nv">await peerConnection.setRemoteDescription(offerFromAlice);</span></pre><p id="cefb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.Bob创建了一个SDP答案，其中包含与Alice发送的SDP报价相同的信息。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="0494" class="nb lt it no b gy ns nt l nu nv">const answer = await peerConnection.createAnswer();</span></pre><p id="ee02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.Bob通过调用<em class="nx"> setLocalDescription()将连接的本地描述设置为这个SDP。</em></p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="f411" class="nb lt it no b gy ns nt l nu nv">await peerConnection.setLocalDescription(answerFromBob);</span></pre><p id="8115" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.Bob通过信令机制将这个答案发送给Alice。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="c8b6" class="nb lt it no b gy ns nt l nu nv">signaling.send(JSON.stringify({<br/>  message_type: MESSAGE_TYPE.SDP,<br/>  content: answerFromBob,<br/>}));</span></pre><p id="bb82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在回到爱丽丝。她接收Bob的回答，并在调用<em class="nx"> setRemoteDescription() </em>的RTCPeerConnection对象中将其设置为远程描述。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="0316" class="nb lt it no b gy ns nt l nu nv">await peerConnection.setRemoteDescription(answerFromBob);</span></pre><p id="f901" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Alice和Bob现在已经交换了媒体数据，并通知对方他们想要开始视频聊天。如果可能的话，他们现在必须共享网络信息以建立直接连接。这并不像听起来那么简单，但幸运的是ICE框架正在为我们做这件事。</p><h1 id="c07d" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">ICE候选人</h1><p id="96df" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">由于历史上IP地址的缺乏(只有大约40亿个IPv4地址可用)，用户通常隐藏在NAT(网络地址转换)网关之后。ICE(交互式连接建立)框架允许对等体发现并传送其公共IP地址。这多亏了STUN服务器，我们在RTCPeerConnection对象中给定了URL作为参数。由于对等体的网络配置，直接连接可能是不可能的，在这种情况下，连接将必须通过中继服务器或TURN服务器进行。服务器也必须作为参数提供给RTCPeerConnection。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="25de" class="nb lt it no b gy ns nt l nu nv">const peerConnection = new RTCPeerConnection({<br/>  iceServers: [<br/>    { urls: 'stun:stun.test.com:19000' },<br/>    { urls: 'turn:turn:19001' },<br/>  ],<br/>});</span></pre><p id="947d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ICE代理为我们负责这种探索和决策，检查直接连接的可能性，如果不能，则通过TURN服务器(如果已提供)建立连接。</p><p id="9b98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Alice和Bob只需监听RTCPeerConnection的事件<em class="nx"> icecandidate </em>。每次发现候选冰时都会触发该事件。然后他们应该把他们的候选人发给对方。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="efa0" class="nb lt it no b gy ns nt l nu nv">peerConnection.onicecandidate = (iceEvent) =&gt; {<br/>  signaling.send(JSON.stringify({<br/>    message_type: MESSAGE_TYPE.CANDIDATE,<br/>    content: iceEvent.candidate,<br/>  }));<br/>};</span></pre><p id="88d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当接收到对方的候选时，Alice和Bob应该将其传递给他们的RTCPeerConnection对象的ice代理。</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="86e6" class="nb lt it no b gy ns nt l nu nv">await peerConnection.addIceCandidate(content);</span></pre><p id="de65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ICE代理将负责协商并完成连接。如果你想知道更多关于NATs和ICE的细节，你可以看看<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/webrtc-the-ice-framework-stun-and-turn-servers-10b2972483bb">这篇文章</a>。</p><p id="fb72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">建立连接后，磁道数据开始通过连接进行交换。您可以实现<em class="nx"> ontrack </em>事件处理程序来显示它们:</p><pre class="mv mw mx my gt nn no np nq aw nr bi"><span id="1e7a" class="nb lt it no b gy ns nt l nu nv">peerConnection.ontrack = (event) =&gt; {<br/>  const video = document.getElementById('remote-view');<br/>  if (!video.srcObject) {<br/>    video.srcObject = event.streams[0];<br/>  }<br/>};</span></pre><h1 id="116d" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">客户代码</h1><p id="3a25" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们的页面首先看起来像这样:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/b889d065b72ff056d77a2ea3e5d2e21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EGQa28IMz2J4xDQe-NjXA.png"/></div></div></figure><p id="50ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点击开始按钮后，你会在左上角看到你自己，但是在连接建立之前你看不到你的联系人。一旦成功，你们就可以聊天了。</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/2bfb48065e9e2aa3fd427da9db91145c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyyi0Dl_Hd_QTvDiFxycsw.png"/></div></div></figure><p id="1882" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在客户端应用程序的文件夹中，创建一个<em class="nx">index.html</em>和一个<em class="nx"> styles.css </em>文件，然后复制这段代码。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5743" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还需要一个用于JavaScript的<em class="nx"> index.js </em>。这是最后的<em class="nx"> index.js </em>文件:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="01d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们定义用户可能会收到的消息类型。第一个是“SDP”，用于提供和回答。第二个“候选人”是为ICE候选人准备的。</p><p id="cc40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在点击开始页面按钮时，我们想要开始聊天，这就是我们正在做的第9行到第13行。</p><p id="b9f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看<em class="nx"> startChat </em>函数。我们首先从摄像机和麦克风请求数据。这应该会触发来自浏览器的访问请求，您必须接受该请求，然后才能继续:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/5cf600e73640305a00e1f3c3d4433e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6GqQhWuYRYw5eXqFQFTVA.png"/></div></div></figure><p id="f742" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦你接受了，我们显示聊天室，显示视频元素和隐藏开始按钮。我们建立到WebSocket服务器的连接(第20行)，并将这个连接称为<em class="nx">信令</em>。我们在<em class="nx"> createPeerConnection </em>函数中创建RTCPeerConnection对象。它给出了一个STUN服务器作为参数(这是一个假的，你可以用一个公共的STUN服务器来代替它)，并定义了我们讨论过的两个事件处理程序:<em class="nx"> onicecandidate </em>将把ICE候选发送给对等体，以及<em class="nx"> ontrack </em>将接收到的音轨设置为我们的视频HTML元素。它有一个额外的事件处理程序，实际上是一个非常重要的事件处理程序:<em class="nx">onnegationneedd</em>。当我们向连接添加跟踪时，以及稍后发生需要重新协商的情况时，将触发此事件。正是在这里，信令交换将真正开始。</p><p id="3e5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到<em class="nx"> startChat </em>函数，在创建了RTCPeerConnection对象之后，我们在<em class="nx"> addMessageHandler </em>函数<em class="nx">中定义了接收消息时要做什么。</em>如果我们收到一个候选人，我们会像前面描述的那样将其交给ICE代理。如果我们收到一个提议，我们设置远程描述，创建一个答案，将答案保存为本地描述，并将其发送给对等方。当我们收到一个答案时，我们只需将其设置为本地报价。</p><p id="f91f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将本地轨道设置为RTCPeerConnection对象，并在视频元素中显示它们。在对等连接对象上设置轨道将触发<em class="nx">negogationneedd</em>事件，事件监听器将调用<em class="nx"> createAndSendOffer </em>函数。</p><p id="10f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">启动WebSocket服务器，并在两个不同的选项卡中打开客户端。在两个页面点击“开始”后，你应该可以和自己交流了。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="56d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多亏了WebRTC，我们现在已经建立了一个连接。我们的解决方案仍然不是最佳的。我们处理了信令过程，但是目前还没有办法允许两个给定的用户，只有他们，进行通信。前两个用户点击按钮就建立了连接。在下一篇文章中，我们将通过调整我们的信令服务器来解决这个问题。</p></div></div>    
</body>
</html>