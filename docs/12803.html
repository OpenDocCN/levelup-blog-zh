<html>
<head>
<title>Why Split Large Methods Into Smaller Ones?!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么要把大方法分成小方法呢？！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-split-large-methods-into-smaller-ones-7b71f26f8745?source=collection_archive---------8-----------------------#2022-07-11">https://levelup.gitconnected.com/why-split-large-methods-into-smaller-ones-7b71f26f8745?source=collection_archive---------8-----------------------#2022-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4c7c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">回归基础</h2><div class=""/><div class=""><h2 id="2bbb" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习何时将大方法分解成小方法，让不可能变成可能。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/699c53d2cd434869f532c1c7309670a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wigBG8n81Nnht1rj_j1Dkw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">简介</strong>。照片由<a class="ae li" href="https://unsplash.com/@joshbrown?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·布朗</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> <strong class="bd lh">艾哈迈德·塔雷克</strong> </a>调整</figcaption></figure><h1 id="f78b" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="8323" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">作为一名软件开发人员，您总是听到有人告诉您不应该使用笨重的方法。换句话说，您应该避免在一个方法中有太多的逻辑或太多的代码行。</p><p id="433e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我现在能听到你说:</p><blockquote class="nb nc nd"><p id="49d4" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">是的，同样bla bla bla，饶了我吧。我不是业余爱好者。</p></blockquote><p id="0751" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">冷静下来，我的朋友，我不会重复你总是听到的同样的事情。</p><p id="3bfc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我不会告诉你，如果你的方法庞大臃肿，逻辑过多，这将是一个很好的迹象，表明它做得太多，或者，可能是整个类做得太多。在这种情况下，你将违反OLID原则的单一责任原则。</p><p id="2b6e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我知道你已经知道了。然而，我要给你看一些你可能会忽略的有趣的东西。</p><p id="21d2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在本文的下一节中，我将向您展示将大方法拆分成小方法会带来巨大的不同。实际上，它可以把不可能变成可能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="nj nk gp gr nl nm"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa lb nm"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/a2fd6104cc571942d93745d793daca65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzsecdSSo1bGyVr0vwlR6A.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">当一个方法被调用时会发生什么</strong>。照片由<a class="ae li" href="https://unsplash.com/@patrickian4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Patrick Fore </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">T21【Ahmed Tarek调整</a></figcaption></figure><h1 id="102c" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">当一个方法被调用时会发生什么</h1><p id="7bbd" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">您很可能知道，对于每个方法调用，都会在<strong class="mc jd">堆栈</strong>内存中创建和分配一个堆栈框架。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="a1f3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi oj translated"><span class="l ok ol om bm on oo op oq or di"> N </span>注:如果你不太了解<strong class="mc jd">栈</strong>内存，也许你可以查看文章<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/memory-management-in-net-740b03d01e24?sk=045076d6617410f78a56b2220172d2d5"> <strong class="mc jd">中的内存管理。网</strong> </a>。这会帮助你理解。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="7350" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">假设我们有下面这段简单的代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="56c6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">假设注释实际上代表了一些要执行的代码，当我们开始调用<code class="fe ou ov ow ox b">Function1</code>时，这就是将要发生的事情。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/e6acc8266d8112c5460b2f815cc8fd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jja1Y6K0YYmCaN83zk8YbQ.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">嵌套函数调用</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> <strong class="bd lh">艾哈迈德·塔里克</strong> </a>拍摄</figcaption></figure><p id="cb94" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如您所见，在每个函数开始时，都会创建一个堆栈帧，直到函数完全执行后，这个堆栈帧才会被释放。当一个子函数被调用时，一个子框架被创建等等，…</p><p id="448b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这里值得一提的是，当连续和嵌套的堆栈帧被创建并分配到堆栈内存中时，所分配的内存继续增加，直到一些帧被释放。</p><p id="f881" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，除非你有一个无限堆栈内存，否则你可能会遇到内存不足的异常，或者让我们称之为内存不足；<strong class="mc jd">堆栈溢出</strong>异常。</p><p id="5a1f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">你不相信我？让我展示给你看。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/c0df7fbf019e88b6aa084e490c1df55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-blgfesWbI0lLHPiU_1Tgw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">大法</strong>。照片由<a class="ae li" href="https://unsplash.com/@miteneva?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">玛利亚·特内娃</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克调整</a></figcaption></figure><h1 id="d9e8" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">大型方法</h1><p id="a3b8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在这个代码示例中，我们将通过使用<strong class="mc jd">递归</strong>来模拟一个<strong class="mc jd">堆栈溢出</strong>异常。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="3f5c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi oj translated"><span class="l ok ol om bm on oo op oq or di"> N </span>注:如果你不太了解<strong class="mc jd">递归</strong>，也许你可以查看文章<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/curse-of-recursion-in-net-c-b017271ddbe6?sk=e1a1f74d42d80a82d433d5be37bc15ac"> <strong class="mc jd">中的递归诅咒。NET C# </strong> </a>。这会帮助你理解。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="4970" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="3d59" class="pa pb it mc b md mw mg mx mj pc mn pd mr pe mv pf pg ph pi bi translated">我们正在调用一个递归方法，它将生成20，000个方法调用。</li><li id="c502" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">这种逻辑并不奇特，我们现在不应该太在意它。这只是为了演示。</li></ol></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="608d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，运行这段代码会产生以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/c3a6fafceef3da98766b0d51fbc06fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lq8givms2tSSg9ec8hPR7Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">堆栈溢出异常</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> <strong class="bd lh">艾哈迈德·塔里克</strong> </a>提供</figcaption></figure><p id="c6f4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">发生这种情况是因为对于每一个<strong class="mc jd"> 20，000个</strong>方法调用，当前一个堆栈帧还没有被清除时，一个新的堆栈帧被分配到堆栈存储器中。最终，我们用完了堆栈内存。</p><p id="8ede" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">好吧，现在你可能会问:</p><blockquote class="nb nc nd"><p id="aa4c" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">那么，如果我的业务逻辑实际上要求我执行<strong class="mc jd"> 20，000次</strong>呼叫，我该怎么办？我应该放弃吗？</p></blockquote><p id="bb2d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">咻，我还担心你永远不会问。我基于这个问题构建了整篇文章😁</p><p id="ec71" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我来回答你的问题；不，你不能把它扔掉，但是你应该稍微弯曲一下，让它工作起来。</p><p id="eec4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">继续下一部分，我会给你看一些有趣的东西…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/9a087aa1178355b24e24f3128a184e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiksoQrfIeG81ivrckiOog.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">小方法</strong>。照片由<a class="ae li" href="https://unsplash.com/@volkanolmez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">沃尔坎·奥尔梅斯</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">T21艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="2e22" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">小方法</h1><p id="1bb2" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们将对之前的代码应用一个<strong class="mc jd">如此简单/琐碎的改变</strong>。它简单/琐碎到你可能不相信会有任何不同的程度。</p><p id="8d0b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">说够了，让我们看看代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="f114" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="af09" class="pa pb it mc b md mw mg mx mj pc mn pd mr pe mv pf pg ph pi bi translated">我们修改了<code class="fe ou ov ow ox b">GetResultRecursively</code>方法以获得一个额外的参数，即下边界迭代次数。</li><li id="e3de" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">这样我们就可以调用<code class="fe ou ov ow ox b">GetResultRecursively</code>方法，决定从哪里开始计数，从哪里结束计数。</li><li id="8cc5" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">然后我们将对<code class="fe ou ov ow ox b">GetResultRecursively</code>方法的一次调用分成两次调用。现在，不再有一个巨大的<strong class="mc jd"> 20，000次</strong>迭代的调用，而是两个调用，每个调用只有<strong class="mc jd"> 10，000次</strong>迭代。</li><li id="5944" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">第一次调用从<strong class="mc jd">20000</strong>开始，到<strong class="mc jd">10000</strong>结束。</li><li id="b1f7" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">而第二次调用从<strong class="mc jd">10000</strong>开始，到<strong class="mc jd"> 0 </strong>结束。</li><li id="5aff" class="pa pb it mc b md pj mg pk mj pl mn pm mr pn mv pf pg ph pi bi translated">这样，我们仍然覆盖了整个<strong class="mc jd"> 20，000 </strong>系列。</li></ol><p id="f158" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我现在能听到你说:</p><blockquote class="nb nc nd"><p id="5512" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">你是哑巴吗？它仍然会产生同样的问题。最后，我们将在<code class="fe ou ov ow ox b">Main</code>方法中进行<strong class="mc jd"> 20，000次</strong>迭代。</p></blockquote><p id="8655" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">你确定吗？让我们运行新代码看看。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/1c1262077822d8291859da1cdc659827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I31JENnnj0l3Q6_sKU2ucA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">避免堆栈溢出异常</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">T3【艾哈迈德】塔里克T5】</a></figcaption></figure><p id="5a75" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">哦，成功了！！！这怎么可能呢？！！</p><p id="cf6f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">是的，我的朋友，这是可能的。事情是这样的，当我们将<strong class="mc jd"> 20，000次</strong>迭代分成2次调用时，堆栈内存中分配的堆栈帧只为<strong class="mc jd"> 10，000次</strong>调用累积，然后清除释放一些堆栈内存，然后执行下一个<strong class="mc jd"> 10，000次</strong>调用，到那时就有足够的堆栈内存了。</p><p id="a11a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，按照这种模式，你实际上可以做更多的<strong class="mc jd"> 10，000次</strong>呼叫，就像这样:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="89d1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">它仍然可以工作。是魔法吗？不，只是关于方法调用如何工作的基本知识。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/a52eef2843a10606af405eafc682ed92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4Gfwjao2rraYEw3rTM2WQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">总结</strong>。照片由<a class="ae li" href="https://unsplash.com/@aaronburden?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚伦负担</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">T21【Ahmed Tarek】调整T23】</a></figcaption></figure><h1 id="ac4e" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">摘要</h1><p id="92c1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">好了，现在我知道你可能会有一点困惑，所以让我为你总结一下。</p><p id="9d8d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">将一个方法调用的逻辑分成两个连续的方法调用会返回相同的逻辑输出，但会对堆栈内存产生不同的影响。</p><p id="2d0f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">所以，我给你的建议，如果你真的需要单个方法有太多的逻辑，那就尽量把这个逻辑拆分成多个方法。这将有助于堆栈内存在方法调用之间喘息，并最终避免遇到<strong class="mc jd">堆栈溢出</strong>异常。您可能遇到的唯一挑战是如何从这些多次调用中重建最终结果。</p><p id="fbcc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，为了简洁起见，您仍然应该首先考虑为什么您的方法或类应该处理那么多的逻辑。这是出问题的迹象。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/f9b214ad96409ebf23edba3c3d22a29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlUeEFrFJE_GcJdFLZIPsQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">最后的想法</strong>。照片由<a class="ae li" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">肯尼·埃利亚松</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克调整</a></figcaption></figure><h1 id="6546" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">最后的想法</h1><p id="0e8b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在本文中，我们证明了将大方法拆分成小方法不仅仅是美化代码的设计规则。它实际上可以把不可能变成可能。</p><p id="8a18" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最后，我希望你喜欢读这篇文章，就像我喜欢写它一样。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="25c3" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="5fe1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果您还不是<strong class="mc jd">中型</strong>会员，您可以使用<a class="ae li" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="mc jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="mc jd">中型</strong>中获得您的一部分费用，您无需支付任何额外费用。订阅<br/><a class="ae li" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"><strong class="mc jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="b6af" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">其他资源</h1><p id="8198" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这些是你可能会发现有用的其他资源。</p><div class="nj nk gp gr nl nm"><a rel="noopener  ugc nofollow" target="_blank" href="/template-method-design-pattern-in-net-c-73d0be82571e"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">中模板方法设计模式的分析。NET C#</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">中学习模板方法设计模式。NET C#并探索不同的可能性。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nv l"><div class="ps l nx ny nz nv oa lb nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a rel="noopener  ugc nofollow" target="_blank" href="/passing-parameters-to-a-net-c-method-388badb7c095"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">将参数传递给. NET C#方法</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">向. NET C#方法传递参数的不同方式。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nv l"><div class="pt l nx ny nz nv oa lb nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a rel="noopener  ugc nofollow" target="_blank" href="/protecting-public-methods-from-illogical-calls-in-net-c-91fcbb8bee33"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">保护公共方法免受不合逻辑的调用。NET C#</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">包含代码示例和解释的完整指南。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nv l"><div class="pu l nx ny nz nv oa lb nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a rel="noopener  ugc nofollow" target="_blank" href="/design-best-practices-in-net-c-8e37b7c3500a"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">在中设计最佳实践。NET C#</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">一些需要遵循的设计最佳实践。NET C#</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nv l"><div class="pv l nx ny nz nv oa lb nm"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="cc2c" class="lj lk it bd lh ll pw ln lo lp px lr ls ki py kj lu kl pz km lw ko qa kp ly lz bi translated">分级编码</h1><pre class="ks kt ku kv gt qb ox qc qd aw qe bi"><span id="d512" class="qf lk it ox b gy qg qh l qi qj">Thanks for being a part of our community! More content in the <a class="ae li" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">Level Up Coding publication</a>.<br/>Follow: <a class="ae li" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae li" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae li" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">Newsletter</a></span><span id="2d37" class="qf lk it ox b gy qk qh l qi qj">Level Up is transforming tech recruiting<strong class="ox jd"> </strong>👉<strong class="ox jd"> </strong><a class="ae li" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"><strong class="ox jd">Join our talent collective</strong></a></span></pre></div></div>    
</body>
</html>