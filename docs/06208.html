<html>
<head>
<title>Firebase Authentication and keeping users logged in with Provider in Flutter.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase认证和在Flutter中保持用户登录提供商。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/firebase-authentication-and-keeping-users-logged-in-with-provider-in-flutter-f1c66cdb1bc7?source=collection_archive---------1-----------------------#2020-11-03">https://levelup.gitconnected.com/firebase-authentication-and-keeping-users-logged-in-with-provider-in-flutter-f1c66cdb1bc7?source=collection_archive---------1-----------------------#2020-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/652e8757a1ec0ee6b6fb1d5c0d93422e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jW1ecwjjyd12ji5YESl8RQ.png"/></div></div></figure><p id="1019" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，将firebase身份验证整合到flutter应用程序中可以立即完成，但是传统的方式无论如何都不是用户友好的。我们只是不能期望我们的用户是键盘战士，让他们容忍每次登录我们的应用程序。</p><blockquote class="kw kx ky"><p id="8d42" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">因此，让我们通过使用<a class="ae ld" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> Provider </a>包管理状态来保持用户登录，直到用户点击“退出”按钮，从而解决用户体验混乱的问题。</p></blockquote><p id="0095" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将与提供者一起管理应用程序的状态，并根据用户是否“登录”来编排执行流程。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/57066623811b17b0658d41dca98f8c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zb3LeP930ioiWfOG3XZEdA.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><strong class="bd ln">本文应用的架构。</strong></figcaption></figure><ol class=""><li id="bc9f" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">在你的机器上创建一个flutter项目。(我跳过这部分解释步骤，因为我不想让你的眼皮厌倦阅读:)</li><li id="bc78" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">为Flutter创建一个firebase项目。如果你已经做了，那么我建议你跳到文章的情节。新手可以查看<a class="ae ld" href="https://firebase.google.com/docs/flutter/setup" rel="noopener ugc nofollow" target="_blank">这个网页</a>来将Firebase集成到你的flutter应用中。</li></ol><h1 id="b147" class="mc md iq bd ln me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">什么是Provider，为什么值得使用？</h1><blockquote class="kw kx ky"><p id="a28a" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">在底线上，我们将要监视一个值(在本例中，登录与否)并采取必要的行动。所以通常我们会监听一个值，观察它的变化来操作我们的应用程序的工作流程。这就是提供者发挥作用的地方，当您阅读本文时，有些人可能已经弄清楚到底是什么在幕后驱动这个提供者。提供者只是让您公开/创建/监听/处置值的<a class="ae ld" href="https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> InheritedWidget </em> </a>和<a class="ae ld" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">change notifier</em></a>的化身。于是解密了<a class="ae ld" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p></blockquote><p id="4314" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们深入研究一下待办事项。</p><p id="c7bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的Flutter项目中打开pubspec.yaml文件，并添加以下包。(<a class="ae ld" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">提供者</a>，<a class="ae ld" href="https://pub.dev/packages/firebase_auth" rel="noopener ugc nofollow" target="_blank"> firebase_auth </a>，<a class="ae ld" href="https://pub.dev/packages/firebase_core" rel="noopener ugc nofollow" target="_blank"> firebase_core </a>)</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d5b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将通过首先完成我们的提供商来启动这个应用程序。在lib目录中创建authentication.dart文件。</p><ol class=""><li id="d7e7" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">导入依赖项。</li><li id="2bb7" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">用一个<strong class="ka ir"> firebaseAuth </strong>实例创建一个<strong class="ka ir"> AuthenticationProvider </strong>类。</li></ol><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="be1f" class="ng md iq nc b gy nh ni l nj nk">import 'package:firebase_auth/firebase_auth.dart';</span><span id="9db0" class="ng md iq nc b gy nl ni l nj nk">class AuthenticationProvider{</span><span id="f3e0" class="ng md iq nc b gy nl ni l nj nk">final FirebaseAuth firebaseAuth;<br/>// FirebaseAuth instance </span><span id="92be" class="ng md iq nc b gy nl ni l nj nk">AuthenticationProvider(this.firebaseAuth);<br/>//Constructor to initialize the Firebase Auth instance.</span><span id="5e79" class="ng md iq nc b gy nl ni l nj nk">}</span></pre><p id="4d73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用一个流来持续监听身份验证状态(登录或未登录)。</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="900e" class="ng md iq nc b gy nh ni l nj nk">Stream&lt;User&gt; get authStateChanges =&gt; firebaseAuth.idTokenChanges();</span></pre><p id="18fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速添加注册、登录和注销方法。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a64e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在已经完成了身份验证提供者的设置。现在让我们将这个提供者放入我们的main.dart文件中。</p><ol class=""><li id="6101" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">在main.dart文件中，导入以下依赖项。</li></ol><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="1e79" class="ng md iq nc b gy nh ni l nj nk">import 'package:flutter/material.dart';<br/>import 'package:firebase_core/firebase_core.dart';<br/>import 'package:provider/provider.dart';<br/>import 'package:firebase_auth/firebase_auth.dart';</span></pre><p id="34c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.我们即将使我们的<strong class="ka ir">主</strong>方法<strong class="ka ir">异步</strong>以使我们的Firebase认证完全无误，并给它几纳秒的时间来准备。</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="9931" class="ng md iq nc b gy nh ni l nj nk">Future&lt;void&gt; main() async {</span><span id="5a05" class="ng md iq nc b gy nl ni l nj nk">WidgetsFlutterBinding.ensureInitialized();</span><span id="64c7" class="ng md iq nc b gy nl ni l nj nk">await Firebase.initializeApp();</span><span id="adce" class="ng md iq nc b gy nl ni l nj nk">runApp(MyApp()); </span><span id="f274" class="ng md iq nc b gy nl ni l nj nk">//MyApp is our root widget.</span><span id="f2cc" class="ng md iq nc b gy nl ni l nj nk">}</span></pre><blockquote class="kw kx ky"><p id="6c67" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">使用提供程序时需要考虑的几点</p><p id="3086" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">提供者的作用域是严格的，这意味着如果没有在正确的地方定义它们，那么它们就是错误的。始终确保在根小部件(更准确地说，在小部件树的顶部)中初始化您的提供者，以便它们在嵌套的小部件树和嵌套的导航路径中保持可访问性。</p><p id="50a7" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">如果您遇到不希望在根小部件中初始化提供者的情况，请记住，任何试图访问您在某个其他路由中定义的提供者的行为都会使该提供者无法被它在小部件树中的祖先小部件/根小部件访问。因此，该提供者只能被其子/后代小部件访问。</p></blockquote><p id="4885" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.创建我们的根小部件(MyApp)。由于提供者需要位于窗口小部件树的顶端，我们将使<strong class="ka ir"> MaterialApp </strong>窗口小部件成为<strong class="ka ir"> MultiProvider </strong>窗口小部件的子部件，以在<strong class="ka ir"> build </strong>方法中初始化我们的提供者。</p><p id="4dce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.a .使用Provider()初始化AuthenticationProvider</p><p id="96ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.b .使用StreamProvider()从AuthenticationProvider中的<strong class="ka ir"> authState </strong>方法读取值。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b4a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.现在让我们添加另一个类<strong class="ka ir"> Authenticate </strong>来决定应用程序必须基于<strong class="ka ir"> authState采取哪条路线。</strong></p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1e51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成<strong class="ka ir"> main.dart </strong>文件。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="624f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候建立我们的<strong class="ka ir">主页</strong>和<strong class="ka ir">登录页面</strong>路线了。(确保将它们导入到<strong class="ka ir"> main.dart </strong>文件中)。</p><h2 id="c858" class="ng md iq bd ln nm nn dn mh no np dp ml kj nq nr mp kn ns nt mt kr nu nv mx nw bi translated">登录_页面. dart</h2><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="f397" class="ng md iq bd ln nm nn dn mh no np dp ml kj nq nr mp kn ns nt mt kr nu nv mx nw bi translated"><strong class="ak"> home_page.dart </strong></h2><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5e06fc9d89a3252720f1dd74d39bdc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*hZlgHnLQ-slc2_Y5YJRofw.gif"/></div></figure><p id="3a52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样结束了！</p><p id="8d23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这种方式，我们与提供者一起管理状态，以保持用户登录。希望这篇文章足够吸引人。仍然被困在某个地方？请随意查看<a class="ae ld" href="https://github.com/RaajeevChandran/Firebase-Authentication-in-Flutter-with-Provider" rel="noopener ugc nofollow" target="_blank"> GitHub库。</a></p></div></div>    
</body>
</html>