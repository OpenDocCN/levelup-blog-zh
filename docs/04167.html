<html>
<head>
<title>Learn By Doing — Live Data Builder : Bridging Coroutines and Live Data in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">边做边学——动态数据构建器:在Android中桥接协同程序和动态数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-by-doing-live-data-builder-bridging-coroutines-and-live-data-in-android-6ea9aa597b4?source=collection_archive---------9-----------------------#2020-06-12">https://levelup.gitconnected.com/learn-by-doing-live-data-builder-bridging-coroutines-and-live-data-in-android-6ea9aa597b4?source=collection_archive---------9-----------------------#2020-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/22b30ff892d1b77cdf90c28d8fdff61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxAdN-DtLEhw5kKJXSlAmA.jpeg"/></div></div></figure><p id="e1e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">先决条件-您需要对本指南的协程、MVVM架构和改进有很好的理解。</p><p id="d18d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第1部分:<a class="ae kw" href="https://medium.com/@shivamdhuria/learn-by-doing-coroutines-a-guide-for-using-coroutines-in-android-for-retrofit-requests-eaef6ca58c7e" rel="noopener">边做边学:协程——在Android中使用协程处理改造请求的指南</a></p><p id="fcde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第1部分中，我使用了<code class="fe kx ky kz la b">viewModelScope.launch{}</code>来执行一个协程。在本指南中，我将使用<strong class="ka ir">实时数据构建器</strong>来代替。</p><p id="a0cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka ir">视图模型</strong>中，我调用了<code class="fe kx ky kz la b">init{}</code>中的<code class="fe kx ky kz la b">loadTopTwoDogsAsync()</code>，其中<code class="fe kx ky kz la b">mainActivityRepository.getTopTwoDogsAsync()</code>是一个挂起函数，它是一个在后台线程上运行的api请求。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="9ba1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后<code class="fe kx ky kz la b">get()</code>并从视图中观察<code class="fe kx ky kz la b">topDogsAsync</code>现场数据。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><blockquote class="lh"><p id="9023" class="li lj iq bd lk ll lm ln lo lp lq kv dk translated">现在，您可能想知道实时数据构建器在哪里出现？</p></blockquote><p id="1608" class="pw-post-body-paragraph jy jz iq ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated"><strong class="ka ir"> <em class="lw">动态数据构建器</em> </strong>填补了<strong class="ka ir">动态数据</strong>和<strong class="ka ir">协程之间的空白。</strong></p><p id="9bc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是使用方法。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="4ab2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初，通过调用<code class="fe kx ky kz la b">emit(GeneralResult.Progress(true))</code>来设置<strong class="ka ir"> livedataResult </strong>的值，之后调用一个函数(本例中为暂停函数)。该功能暂停，直到返回一个值，然后将<strong class="ka ir"> livedataResult </strong>的值设置为<code class="fe kx ky kz la b">emit(topTwoDogsResult)</code>。</p><p id="c956" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在<strong class="ka ir"> liveDataResult </strong>拥有观察者之前，这些都不起作用。所以从这个角度来看—</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="7849" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">那么，动态数据构建器是如何工作的呢？</h1><ul class=""><li id="786b" class="mv mw iq ka b kb mx kf my kj mz kn na kr nb kv nc nd ne nf bi translated">协程仅在活动数据<strong class="ka ir"> <em class="lw">活动</em> </strong>时启动，这意味着它应该至少有一个活动的观察器。</li><li id="4f6c" class="mv mw iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">如果在协程执行过程中，实时数据变得不活动，它将一直等到<code class="fe kx ky kz la b"><em class="lw">[timeoutInMs]</em></code>，如果仍然没有观察者，它将被取消。</li><li id="d840" class="mv mw iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">如果活动数据在取消后再次激活，它将再次执行。然而，如果它被完成或者甚至抛出异常，那么它<em class="lw">将不会被重启</em> <strong class="ka ir">。</strong></li><li id="4851" class="mv mw iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">它默认运行在主线程中，但是可以像<code class="fe kx ky kz la b"><em class="lw">liveData</em>(Dispatchers.IO) <strong class="ka ir">{..}</strong></code>一样使用它来切换线程</li><li id="8abd" class="mv mw iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated"><code class="fe kx ky kz la b">emit()</code>可以从任何线程内部调用。</li></ul><blockquote class="lh"><p id="b31f" class="li lj iq bd lk ll lm ln lo lp lq kv dk translated">为什么应该使用live data builder而不是viewModelScope.launch{}？</p></blockquote><p id="b3a6" class="pw-post-body-paragraph jy jz iq ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">对这个问题没有简单的答案。最简单的答案是，它使代码更干净🧹，更容易写🖊，你不必担心从哪个范围启动它🙌。</p><p id="0a55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，对于独立于视图的协程，您仍然应该✅使用<code class="fe kx ky kz la b">viewModel.launch{}</code>。一个用例场景是，当您在片段之间使用一个<strong class="ka ir">共享视图模型</strong>时，您希望协程仍然运行，即使视图中的某个观察者被移除或者活动数据不再活跃..</p><p id="44f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://stackoverflow.com/questions/56421347/what-problem-does-livedata-builder-function-solve" rel="noopener ugc nofollow" target="_blank">点击此处了解更多信息</a></p><h1 id="fc5b" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用实时数据构建器从实时数据源发出</h1><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="5c05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，函数在这里暂停，直到T2返回一个值。</p><p id="3564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> emitSource() </strong>用于发出LiveData并删除在此之前添加的任何源。如果<strong class="ka ir"> liveDataResult </strong>处于活动状态或被观察到，则<em class="lw">将继续发出实时数据</em>。</p><p id="8c93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数<code class="fe kx ky kz la b">getTopTwoDogsLiveData()</code>首先延迟<code class="fe kx ky kz la b">DELAY_BETWEEN_DOGS_IN_MS</code>，然后调用<code class="fe kx ky kz la b">mainActivityRepository.getTopTwoDogsAsync()</code>，这是一个挂起函数，从后台线程中运行的Api返回一个结果。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/cda7f38ff78e6acff13af9c9d3c5539d.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/1*1ZjDaz4h493xfDiel7mQqQ.gif"/></div></figure><h1 id="58f4" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">就这样，✅</h1><p id="b4c5" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj nm kl km kn nn kp kq kr no kt ku kv ij bi translated">现在，您已经在Android应用中成功实现了动态数据构建器。应用程序现在应该是这样的。</p><h2 id="46a2" class="np ly iq bd lz nq nr dn md ns nt dp mh kj nu nv ml kn nw nx mp kr ny nz mt oa bi translated"><a class="ae kw" href="https://github.com/Shivamdhuria/coroutines-guide/tree/upgrade_live_data_builder" rel="noopener ugc nofollow" target="_blank">Github上的源代码在这里。</a></h2><h1 id="a72b" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">资料来源和进一步阅读。</h1><p id="7179" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj nm kl km kn nn kp kq kr no kt ku kv ij bi translated"><a class="ae kw" href="https://www.youtube.com/watch?v=B8ppnjGPAGE&amp;vl=en" rel="noopener ugc nofollow" target="_blank">带有协程和流的LiveData(Android开发峰会’19)</a></p><p id="0847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://developer.android.com/topic/libraries/architecture/coroutines#livedata" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/topic/libraries/architecture/coroutines # livedata</a></p></div></div>    
</body>
</html>