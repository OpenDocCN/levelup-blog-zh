<html>
<head>
<title>Use Dependency Injection to Make Your Code Testable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用依赖注入使你的代码可测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-dependency-injection-to-make-your-code-testable-2ba2801189a5?source=collection_archive---------13-----------------------#2020-03-23">https://levelup.gitconnected.com/use-dependency-injection-to-make-your-code-testable-2ba2801189a5?source=collection_archive---------13-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d925" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要让单元测试对你自己太苛刻</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67b4545c34c33f6f3abad8960ba6541b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gr4WjTD6HDEIewFW"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@cdc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CDC </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="6435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是否曾经想为你的代码编写单元测试，但是你发现很难做到？这通常是没有考虑到测试而编写代码的结果。解决这个问题的一个简单方法是利用<a class="ae ky" href="https://medium.com/swlh/a-case-for-test-driven-development-8e36df33dc21" rel="noopener">测试驱动开发</a>，这是一个在应用程序代码之前编写测试<em class="lv">的开发过程。</em></p><p id="8c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，即使您不喜欢测试驱动开发，您仍然可以通过使用一种简单的技术<strong class="lb iu">依赖注入</strong>来使您的代码更容易测试，我们将在本文中讨论这一点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a834" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是依赖注入？</h1><p id="cd8a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">依赖注入是一种非常简单却非常强大的技术。简而言之，函数不是将依赖关系硬编码到函数中，而是允许使用函数的开发人员通过参数传递任何需要的依赖关系。</p><p id="c987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助巩固这个概念，让我们一起来看一个例子。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cd0d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解析Cookie字符串</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/b33c78c87ead6aa57ac3705c213d4e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0cSdUZyS5vAn_RbB"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·丹西在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b10e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要编写一个JavaScript函数，它可以从<code class="fe nb nc nd ne b">document.cookie</code>字符串中解析出单个cookie键值对。</p><p id="74e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您想检查是否有一个名为<code class="fe nb nc nd ne b">enable_cool_feature</code>的cookie，如果它的值是<code class="fe nb nc nd ne b">true</code>，那么您想为浏览您站点的用户启用一些很酷的特性。</p><p id="e07b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在JavaScript中使用<code class="fe nb nc nd ne b">document.cookie</code>字符串是非常糟糕的。如果我们可以用类似<code class="fe nb nc nd ne b">document.cookie.enable_cool_feature</code>的东西来查找房产价值就好了，但是，唉，我们不能。</p><p id="4bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将求助于编写我们自己的cookie解析函数，该函数将在一些潜在复杂的底层代码上提供一个简单的外观。</p><p id="789a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(声明一下，有几个JavaScript库和包已经完全做到了这一点，所以除非你想，否则不要觉得有必要在你自己的应用程序中重新编写这个函数。)</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="8451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为第一步，我们可能希望定义一个简单的函数，如下所示:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="9798" class="nj me it ne b gy nk nl l nm nn">function getCookie(cookieName) { /* body here */ }</span></pre><p id="81bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将允许我们通过如下调用来查找特定cookie的值:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="fc63" class="nj me it ne b gy nk nl l nm nn">getCookie('enable_cool_feature')</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="56b9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">样本溶液</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/9a911a290327b5a11db7679df5c2c641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7pdT1bf8-mF3hMIc"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@freegraphictoday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">absolute vision</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="156c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在谷歌上搜索“如何解析JavaScript中的cookie字符串”,会发现来自不同开发者的许多不同的解决方案。对于这篇文章，我们将看看由<a class="ae ky" href="https://www.w3schools.com/js/js_cookies.asp" rel="noopener ugc nofollow" target="_blank"> W3Schools </a>提供的解决方案。看起来是这样的:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="66bf" class="nj me it ne b gy nk nl l nm nn">export function getCookie(cookieName) {<br/>  var name = cookieName + '='<br/>  var decodedCookie = decodeURIComponent(document.cookie)<br/>  var ca = decodedCookie.split(';')</span><span id="6d85" class="nj me it ne b gy np nl l nm nn">  for (var i = 0; i &lt; ca.length; i++) {<br/>    var c = ca[i]<br/>    while (c.charAt(0) == ' ') {<br/>      c = c.substring(1)<br/>    }</span><span id="1320" class="nj me it ne b gy np nl l nm nn">    if (c.indexOf(name) == 0) {<br/>      return c.substring(name.length, c.length)<br/>    }<br/>  }</span><span id="ab3c" class="nj me it ne b gy np nl l nm nn">  return ''<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e902" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">对样本解决方案的批评</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/7df6e1ca8432d01bd124ff02318f2c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eT2HVGYPL7h3LRHC"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hhh13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">傅永华</a>摄于<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="7116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这有什么问题？我们不会批评代码的主体本身，而是看这一行代码:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="c1ec" class="nj me it ne b gy nk nl l nm nn">var decodedCookie = decodeURIComponent(document.cookie)</span></pre><p id="7277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe nb nc nd ne b">getCookie</code>依赖于<code class="fe nb nc nd ne b">document</code>对象和<code class="fe nb nc nd ne b">cookie</code>属性！乍一看，这似乎没什么大不了的，但它确实有一些缺点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="ea5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，如果出于某种原因，我们的代码无法访问<code class="fe nb nc nd ne b">document</code>对象，该怎么办？例如，在节点环境中，<code class="fe nb nc nd ne b">document</code>是<code class="fe nb nc nd ne b">undefined</code>。让我们看一些样本测试代码来说明这一点。</p><p id="8832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用Jest作为测试框架，然后编写两个测试:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="8b29" class="nj me it ne b gy nk nl l nm nn">import { getCookie } from './get-cookie-bad'</span><span id="4f52" class="nj me it ne b gy np nl l nm nn">describe('getCookie - Bad', () =&gt; {<br/>  it('can correctly parse a cookie value for an existing cookie', () =&gt; {<br/>    document.cookie = 'key2=value2'<br/>    expect(getCookie('key2')).toEqual('value2')<br/>  })</span><span id="52fd" class="nj me it ne b gy np nl l nm nn">  it('can correctly parse a cookie value for a nonexistent cookie', () =&gt; {<br/>    expect(getCookie('bad_key')).toEqual('')<br/>  })<br/>})</span></pre><p id="fbd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们运行我们的测试来看看输出。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="cf07" class="nj me it ne b gy nk nl l nm nn">ReferenceError: document is not defined</span></pre><p id="a4ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦不！在节点环境中，<code class="fe nb nc nd ne b">document</code>没有定义。幸运的是，我们可以在<code class="fe nb nc nd ne b">jest.config.js</code>文件中更改Jest配置，指定我们的环境应该是<code class="fe nb nc nd ne b">jsdom</code>，这将创建一个DOM供我们在测试中使用。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="48f1" class="nj me it ne b gy nk nl l nm nn">module.exports = {<br/>  testEnvironment: 'jsdom'<br/>}</span></pre><p id="71c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们再次运行我们的测试，他们通过。但是，我们仍然有一点问题。我们正在全局修改<code class="fe nb nc nd ne b">document.cookie</code>字符串，这意味着我们的测试现在是相互依赖的。如果我们的测试以不同的顺序运行，这会导致一些奇怪的测试用例。</p><p id="dc2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们在第二个测试中写<code class="fe nb nc nd ne b">console.log(document.cookie)</code>，它仍然会输出<code class="fe nb nc nd ne b">key2=value2</code>。哦不！这不是我们想要的。我们的第一次测试影响了我们的第二次测试。在这种情况下，第二个测试仍然通过了，但是当您的测试没有相互隔离时，很可能会陷入一些混乱的情况。</p><p id="c8a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以在第一次测试的<code class="fe nb nc nd ne b">expect</code>声明之后做一些清理工作:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="3e08" class="nj me it ne b gy nk nl l nm nn">it('can correctly parse a cookie value for an existing cookie', () =&gt; {<br/>  document.cookie = 'key2=value2'<br/>  expect(getCookie('key2')).toEqual('value2')<br/>  document.cookie = 'key2=; expires = Thu, 01 Jan 1970 00:00:00 GMT'<br/>})</span></pre><p id="344f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(一般来说，我会建议你用一个<code class="fe nb nc nd ne b">afterEach</code>方法来做一些清理工作，它会在每次测试后运行其中的代码。但是，不幸的是，删除cookies并不像说<code class="fe nb nc nd ne b">document.cookie = ''</code>那么简单。)</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="4b02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">W3Schools解决方案的第二个问题是，如果您想要解析当前没有在<code class="fe nb nc nd ne b">document.cookie</code>属性中设置的cookie字符串。你是怎么做到的？在这种情况下，你不能！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0b01" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">有更好的方法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/0f5c7e531644c3f5dfba73f7315c7b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g7E9ewBP2mgkFPo4"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@camadams?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cam Adams </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="cb38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经探索了一个可能的解决方案和它的两个问题，让我们看看一个更好的方法来编写这个方法。我们将使用依赖注入！</p><p id="8c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的函数签名看起来与我们最初的解决方案有些不同。这一次，它将接受两个参数:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="019f" class="nj me it ne b gy nk nl l nm nn">function getCookie(cookieString, cookieName) { /* body here */ }</span></pre><p id="f560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们可以这样称呼它:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="6eed" class="nj me it ne b gy nk nl l nm nn">getCookie(&lt;someCookieStringHere&gt; 'enable_cool_feature')</span></pre><p id="76c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个示例实现可能如下所示:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="5c41" class="nj me it ne b gy nk nl l nm nn">export function getCookie(cookieString, cookieName) {<br/>  var name = cookieName + '='<br/>  var decodedCookie = decodeURIComponent(cookieString)<br/>  var ca = decodedCookie.split(';')</span><span id="1f0e" class="nj me it ne b gy np nl l nm nn">  for (var i = 0; i &lt; ca.length; i++) {<br/>    var c = ca[i]<br/>    while (c.charAt(0) == ' ') {<br/>      c = c.substring(1)<br/>    }</span><span id="81d1" class="nj me it ne b gy np nl l nm nn">    if (c.indexOf(name) == 0) {<br/>      return c.substring(name.length, c.length)<br/>    }<br/>  }</span><span id="7e92" class="nj me it ne b gy np nl l nm nn">  return ''<br/>}</span></pre><p id="6429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这个函数与原始函数之间的唯一区别是，该函数现在接受两个参数，并且在解码第3行的cookie时使用参数作为<code class="fe nb nc nd ne b">cookieString</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="e42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们为这个函数编写两个测试。这两个测试将测试与我们最初的两个测试相同的东西:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="454a" class="nj me it ne b gy nk nl l nm nn">import { getCookie } from './get-cookie-good'</span><span id="304e" class="nj me it ne b gy np nl l nm nn">describe('getCookie - Good', () =&gt; {<br/>  it('can correctly parse a cookie value for an existing cookie', () =&gt; {<br/>    const cookieString = 'key1=value1;key2=value2;key3=value3'<br/>    const cookieName = 'key2'<br/>    expect(getCookie(cookieString, cookieName)).toEqual('value2')<br/>  })</span><span id="c284" class="nj me it ne b gy np nl l nm nn">  it('can correctly parse a cookie value for a nonexistent cookie', () =&gt; {<br/>    const cookieString = 'key1=value1;key2=value2;key3=value3'<br/>    const cookieName = 'bad_key'<br/>    expect(getCookie(cookieString, cookieName)).toEqual('')<br/>  })<br/>})</span></pre><p id="81c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意我们如何完全控制我们的方法现在使用的cookie字符串。</p><p id="1ca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不必依赖环境，我们不会遇到任何测试挂起，我们也不必假设我们总是直接从<code class="fe nb nc nd ne b">document.cookie</code>解析cookie。</p><p id="200e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4ac8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="115c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">就是这样！依赖注入实现起来非常简单，并且通过使您的测试易于编写并且使您的依赖易于模仿，它将极大地改善您的测试体验。(更不用说它有助于解耦您的代码，但这是另一天的主题。)</p><p id="390b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>