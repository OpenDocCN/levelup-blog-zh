<html>
<head>
<title>Using Data URLs to Load Dependencies in Deno</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Deno中使用数据URL加载依赖项</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-data-urls-to-load-dependencies-in-deno-18461713ec1e?source=collection_archive---------19-----------------------#2021-02-01">https://levelup.gitconnected.com/using-data-urls-to-load-dependencies-in-deno-18461713ec1e?source=collection_archive---------19-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bd471c7f90bb31d29d8d00f59d4e3c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tT9kikTTSAI04T95AiRWuw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这是一个你可以用它做什么的代码示例</figcaption></figure><p id="464f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最近<a class="ae la" href="https://deno.land/posts/v1.7" rel="noopener ugc nofollow" target="_blank"> Deno发布了v1.7.0 </a>，其中有<a class="ae la" href="https://deno.land/posts/v1.7#support-for-importing-data-urls" rel="noopener ugc nofollow" target="_blank">对数据URL</a>的支持。我认为这是一个非常酷的动态创建模块的方法。这可以用来动态地一次加载我们想要在文件中使用的所有依赖项。</p><h1 id="743c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数据URL</h1><p id="b9ac" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">数据URL基本上是URL，但数据以某种形式编码，因此它不是指向数据的链接，而是将数据保存在自身内部。数据URL首先需要以<code class="fe lb lc ld le b">data:</code>开头。然后我们需要添加正在加载的文件的MIME类型，在这个例子中是<code class="fe lb lc ld le b">application/typescript</code>，但是我们也可以使用<code class="fe lb lc ld le b">application/javascript</code>。在我们添加了文件的编码格式后，在本教程中我们将只使用<code class="fe lb lc ld le b">base64</code>，然后你也可以添加一个<code class="fe lb lc ld le b">,</code>，后跟文件的实际编码。</p><h2 id="87f6" class="mi lg iq bd lh mj mk dn ll ml mm dp lp kn mn mo lt kr mp mq lx kv mr ms mb mt bi translated">一个例子</h2><p id="8022" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">假设我们有这个文件:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="8485" class="mi lg iq le b gy nc nd l ne nf">export const add = (a: number, b: number) =&gt; a + b;</span></pre><p id="9c12" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们想从数据URL导入它。然后我们会首先得到样板文件。</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="c5ae" class="mi lg iq le b gy nc nd l ne nf">const { add } = await import("data:application/typescript;base64,");</span></pre><p id="778c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们需要添加base64编码。为此它</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="4784" class="mi lg iq le b gy nc nd l ne nf">ZXhwb3J0IGNvbnN0IGFkZCA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGI7</span></pre><p id="9ae1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以最后的代码是:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="07ef" class="mi lg iq le b gy nc nd l ne nf">const { add } = await import("data:application/typescript;base64,ZXhwb3J0IGNvbnN0IGFkZCA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGI7");</span></pre><p id="bd8f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它将正确地导出<code class="fe lb lc ld le b">add</code>函数。</p><h1 id="a586" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">加载依赖项</h1><p id="6475" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">现在我们知道了如何使用它们，让我们创建一个助手函数来加载依赖项。让我们首先创建类型定义。</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="5a71" class="mi lg iq le b gy nc nd l ne nf">interface Dependency {<br/> url: string;<br/> name: string;<br/>}</span><span id="496c" class="mi lg iq le b gy ng nd l ne nf">function loadDependencies(deps: Dependency[]) {</span><span id="2c5f" class="mi lg iq le b gy ng nd l ne nf">}</span></pre><p id="4d01" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们希望为要导入的数据URL创建一个变量，并为导入的源代码创建一个变量。我们还想对<code class="fe lb lc ld le b">deps</code>数组进行循环。</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="d25d" class="mi lg iq le b gy nc nd l ne nf">function loadDependencies(deps: Dependency[]) {<br/> let code = "";<br/> let dataURL = "data:application/typescript;base64,";<br/> deps.forEach({ url, name} =&gt; {<br/>  <br/> });<br/>}</span></pre><p id="7b28" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们为每个依赖项将导出追加到<code class="fe lb lc ld le b">code</code>中。</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="4447" class="mi lg iq le b gy nc nd l ne nf">function loadDependencies(deps: Dependency[]) {<br/> let code = "";<br/> let dataURL = "data:application/typescript;base64,";<br/> deps.forEach(({ url, name }) =&gt; {<br/>  code += `export * as ${name} from "${url}"`;<br/> });<br/>}</span></pre><p id="56c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们来编码一下。我们还必须向标准库添加一个依赖项。</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="112e" class="mi lg iq le b gy nc nd l ne nf">import { encode } from "<a class="ae la" href="https://deno.land/std@0.84.0/encoding/base64.ts" rel="noopener ugc nofollow" target="_blank">https://deno.land/std@0.84.0/encoding/base64.ts</a>";</span></pre><p id="ee65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们做最后的部分。</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="be7c" class="mi lg iq le b gy nc nd l ne nf">function loadDependencies(deps: Dependency[]) {<br/> let code = "";<br/> let dataURL = "data:application/typescript;base64,";<br/> deps.forEach(({ url, name }) =&gt; {<br/>  code += `export * as ${name} from "${url}"`;<br/> });<br/> dataURL += encode(code);<br/> return import(dataURL);<br/>}</span></pre><p id="2d6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和🎉可以用它导入依赖项！</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="fe77" class="mi lg iq le b gy nc nd l ne nf">const deps = await loadDependencies([{ name: "aleph", url: "<a class="ae la" href="https://deno.land/x/aleph/mod.ts" rel="noopener ugc nofollow" target="_blank">https://deno.land/x/aleph/mod.ts</a>" }]);</span></pre></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="d4ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="no">如果你喜欢这篇文章，我建议你在我的博客</em> <a class="ae la" href="https://h.shadowtime2000.com" rel="noopener ugc nofollow" target="_blank"> <em class="no">上查看我的其他文章</em> </a> <em class="no">。</em></p></div></div>    
</body>
</html>