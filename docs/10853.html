<html>
<head>
<title>Building a Chrome Extension That Also Runs Like a Website</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个也像网站一样运行的Chrome扩展</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-chrome-extension-that-also-runs-like-a-website-e9502b4f260f?source=collection_archive---------18-----------------------#2022-01-17">https://levelup.gitconnected.com/building-a-chrome-extension-that-also-runs-like-a-website-e9502b4f260f?source=collection_archive---------18-----------------------#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="758c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">工厂模式解耦的一个实例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1bcdcfc8eb287a8720f2adb77219cf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPzOi05aaoK0qwupGW6vLg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">背景图片上的Chrome浏览器设计来自<a class="ae ky" href="https://unsplash.com/photos/qLW70Aoo8BE" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。使用<a class="ae ky" href="http://figma.com" rel="noopener ugc nofollow" target="_blank"> Figma </a>制作的封面图像。</figcaption></figure><h1 id="e69b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">问题</h1><p id="238b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我最近使用React开发了一个名为<a class="ae ky" href="https://bit.ly/retro-notes-ext" rel="noopener ugc nofollow" target="_blank"> Retro Notes </a>的Chrome扩展。使用Chrome的存储同步API<a class="ae ky" href="https://developer.chrome.com/docs/extensions/reference/storage/" rel="noopener ugc nofollow" target="_blank">将你在文本框中填写的内容与你的Chrome档案同步。实现非常简单——我直接使用API来获取和设置存储值。</a></p><p id="a240" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当扩展在Chrome扩展上下文中运行时，它会像预期的那样工作。通过这种方式，应用程序可以访问Chrome的存储API。然而，当我将这个React应用程序作为独立网站运行时，它失败了，因为它无法再访问Chrome的存储API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/7a081aef3c187e2c5d96817c518181e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJGAdtam6Es7Y48yH9CB_w.png"/></div></div></figure><p id="0393" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这限制了我的开发体验，因为每次我对应用程序进行任何更改，即使只是装饰性的，我都必须在本地重新打开应用程序作为Chrome扩展，而不是在本地启动网站。</p><p id="8d1d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">那么，我们如何解决这个问题呢？</p><h1 id="64d4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">解决办法</h1><p id="9857" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里的问题是我们在两个组件之间有紧密的耦合——自定义的React组件和Chrome的存储API对象。在没有Chrome扩展上下文的情况下运行时，<code class="fe mt mu mv mw b">chrome.storage.sync</code>变得无效，由于这种紧密耦合，我们也不容易替换它。紧密耦合通常会使测试变得困难，而且由于直接的依赖关系，对依赖关系的更改也会影响依赖组件。因此，这被认为是不好的做法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c4c4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相反，当我们解耦或松散耦合依赖时，系统不会严重依赖彼此。在本例中，React组件不需要知道正在使用哪种类型的存储，也不需要知道我们如何将值设置到存储中的实现细节——但它需要知道，所以让我们更改一下。</p><h2 id="a221" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">步骤1:分离存储实现细节</h2><p id="1ab4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们首先将Chrome存储API代码提取到它自己的文件中。我们将把<code class="fe mt mu mv mw b">chrome.storage.sync.set()</code>方法包装成一个通用的<code class="fe mt mu mv mw b">setStorage()</code>方法，并且只传递相关的参数。我正在使用TypeScript，所以我可以创建一个接口来强类型化这些方法，并在这里使用该接口。请注意，我将接口命名为<code class="fe mt mu mv mw b">IStorageApi</code>而不是<code class="fe mt mu mv mw b">IChromeStorageApi</code>——这是有原因的，我们将在本文后面讨论。完整的代码片段可以在下面找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0dc1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们可以将上面创建的Chrome存储API文件导入到我们的自定义组件中，然后调用<code class="fe mt mu mv mw b">setStorage()</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e1fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这样更好——我们不再将存储功能紧密耦合到定制组件中，但是我们仍然紧密耦合存储方法。比方说，我决定交换存储方法，不使用Chrome的存储API，而是使用我自己的后端服务器的API端点。这意味着我只需要重构这个文件，例如，更新从<code class="fe mt mu mv mw b">ChromeStorageApi</code>到<code class="fe mt mu mv mw b">CustomStorageApi</code>的引用。</p><p id="4ffb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，如果我在Chrome的扩展上下文之外将应用程序作为独立的网站运行，它仍然无法工作，因为我们直接使用了Chrome存储API。所以，我们还没有真正改善开发体验。</p><h2 id="0d7e" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">步骤2:分离存储方法</h2><p id="fe5b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了解决这个问题，让我们创建另一个名为<code class="fe mt mu mv mw b">DevelopmentStorage.ts</code>的文件，它继承了相同的<code class="fe mt mu mv mw b">IStorageApi</code>接口，但是在方法的实现中，我们将数据存储在一个本地对象中，而不是使用Chrome的存储API。因为我们应该能够实现存储接口的不同实现，所以将接口命名为类似于<code class="fe mt mu mv mw b">IStorageApi</code>的通用名称更有意义。完整的代码片段如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="469f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们将创建一个<em class="nl">工厂</em>。根据条件，它要么返回实际的Chrome存储API模块，要么返回模拟的开发存储API模块。在我们的例子中，当我们将站点作为扩展运行时，<code class="fe mt mu mv mw b">process.env.NODE_ENV</code>被设置为<code class="fe mt mu mv mw b">production</code>，当我们将站点作为独立站点运行时，该值被设置为<code class="fe mt mu mv mw b">development</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="22c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，让我们更新定制组件并使用工厂生成的模块，而不是直接引用特定的模块。</p><p id="cdc3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">React组件不需要知道如何将项目提取并存储到Chrome的存储中的实现细节。它可以简单地与负责提供这种存储功能的API进行交互。这样，如果我们想要将值存储到我们的自定义存储中，我们就不需要对自定义组件进行任何更改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5093" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，如果我把这个应用程序作为一个独立的网站来运行，它可以很好地加载，并且是可用的。不用说，我也可以毫无问题地将这个应用作为Chrome扩展来运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/f0efa1ec613914388f44b5c55164415c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRopUd76mw5NFeMRvyGCNw.png"/></div></div></figure><h1 id="6f6b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><p id="5063" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你想看复古笔记的完整代码，可以在GitHub 上找到<a class="ae ky" href="https://github.com/ClydeDz/retro-notes-chrome-extension" rel="noopener ugc nofollow" target="_blank">。如果你想尝试一下复古笔记Chrome扩展，可以从</a><a class="ae ky" href="https://bit.ly/retro-notes-ext" rel="noopener ugc nofollow" target="_blank"> Chrome网上商店</a>下载。</p><p id="dfcc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样。感谢阅读！</p></div></div>    
</body>
</html>