<html>
<head>
<title>Unleashing the power of Redis x Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">释放Redis x Django的力量</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unleashing-the-power-of-redis-x-django-1c84b716679b?source=collection_archive---------1-----------------------#2020-10-31">https://levelup.gitconnected.com/unleashing-the-power-of-redis-x-django-1c84b716679b?source=collection_archive---------1-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5823" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Django中使用Redis缓存数据和排队作业</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3df51a02514beb307f956c7dde8ef8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4yRAn-muRAhvJ4d7"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://images.unsplash.com/photo-1567177173026-402dd75a5ab7?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1950&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的背景照片</figcaption></figure><h1 id="b64a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak"> 1。缓存数据Django会话的替代方案</strong></h1><p id="8138" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Django中的会话框架并不适合每个站点访问者获取、加载和设置大量数据的情况。错误消息“请求的会话在请求完成前被删除。例如，用户可能在并发请求中注销。”当有大量会话数据需要加载时，可能会弹出。由于每次请求都会加载会话数据，存储大量数据会降低应用程序的速度。在这种情况下，Redis缓存可以充当doppelgnger！事不宜迟，让我们快速检查一下这是如何完成的。</p><h2 id="b8c0" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">第一步:安装redis和django-redis库</strong></h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="901c" class="mk kx iq mx b gy nb nc l nd ne">yum install redis<br/>pip3 install django-redis</span></pre><p id="58c7" class="pw-post-body-paragraph lo lp iq lq b lr nf jr lt lu ng ju lw lx nh lz ma mb ni md me mf nj mh mi mj ij bi translated">启动Redis服务的便捷命令:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1f21" class="mk kx iq mx b gy nb nc l nd ne">On Linux: systemctl start redis.service<br/>On Windows: redis-server.exe</span></pre><h2 id="dd6f" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">第二步:在settings.py中定义缓存</strong></h2><p id="e90d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">必须通过定义所有必需的参数来实例化缓存—后端定义要使用的缓存后端，位置创建套接字连接，CLIENT_CLASS是默认的Redis客户端。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="76c5" class="mk kx iq mx b gy nb nc l nd ne"># Cache<br/>CACHES = {<br/>    'default': {<br/>        'BACKEND': 'django_redis.cache.RedisCache',<br/>        'LOCATION': 'redis://127.0.0.1:6379/',<br/>        'OPTIONS': {<br/>        'CLIENT_CLASS': 'django_redis.client.DefaultClient',<br/>        }<br/>    }<br/>}</span></pre><h2 id="7e4f" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">步骤3:在views.py中复制会话</strong></h2><p id="6659" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">django会话通常由一个键值对来标识。为了在定义缓存的同时复制相同的行为，必须获得会话密钥来隔离每个站点访问者的值。可以分别使用redis客户端的<em class="nk"> hset() </em>和<em class="nk"> hget() </em>方法来设置和检索键值对。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="fcc2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak"> 2。Redis队列—后台作业处理程序</strong></h1><p id="1455" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">用户不喜欢等待页面加载；他们打算快速地从一个网页转到另一个网页。在这种情况下，当构建web应用程序时，异步执行长期运行的后台任务通常是受欢迎的。Redis Queue将任务排队，并在后台一个接一个地运行它们(这可以通过控制工作线程的数量来实现异步运行),而不会中断用户的视图。这里有一个简短的安装和运行Django Redis队列的操作指南。</p><h2 id="8939" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">步骤1:安装django rq库</strong></h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="9b6c" class="mk kx iq mx b gy nb nc l nd ne">yum install redis<br/>pip3 install django-rq</span></pre><p id="9dd6" class="pw-post-body-paragraph lo lp iq lq b lr nf jr lt lu ng ju lw lx nh lz ma mb ni md me mf nj mh mi mj ij bi translated">启动Redis服务的便捷命令:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="69b0" class="mk kx iq mx b gy nb nc l nd ne">On Linux: systemctl start redis.service<br/>On Windows: redis-server.exe</span></pre><h2 id="fa21" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">第二步:在settings.py中实例化队列</strong></h2><p id="3310" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">必须在INSTALLED_APPS部分添加一个队列— HOST属于服务器，PORT是Redis使用的默认端口，DB属于第一个数据库。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0c67" class="mk kx iq mx b gy nb nc l nd ne">INSTALLED_APPS = [<br/>    ...<br/>    'django_rq',<br/>]</span><span id="1eeb" class="mk kx iq mx b gy nn nc l nd ne">RQ_QUEUES = {<br/>    'default': {<br/>    'HOST': 'localhost',<br/>    'PORT': 6379,<br/>    'DB': 0,<br/>    }<br/>}</span></pre><h2 id="900d" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">第三步:在urls.py中定义URL</strong></h2><p id="e71e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在主项目<em class="nk"> urls.py </em>文件夹中，定义Django Redis队列URL。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="555b" class="mk kx iq mx b gy nb nc l nd ne">urlpatterns = [<br/>    path("django-rq/", include('django_rq.urls')),<br/>    ...<br/>]</span></pre><h2 id="4088" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">第四步:在tasks.py中定义后台作业</strong></h2><p id="fcef" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在django app文件夹中创建一个名为<em class="nk"> tasks.py </em>的文件。在那里定义一个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="cda6" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">第五步:调用views.py中的redis队列</strong></h2><p id="e6b7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在<em class="nk"> views.py </em>中，需要调用之前定义的函数。获取队列<em class="nk">‘默认’</em>，设置超时，从而将任务排队。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="cf6d" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">第六步:django-rq上线</strong></h2><p id="7f61" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果服务器在localhost上，URL应该是<em class="nk"> localhost/django-rq </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e2ba52e021f44d7ad2e0b419015f786d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nR-Bk3X0EJHj23g45ZsN0g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">django-rq在线</figcaption></figure><p id="ad49" class="pw-post-body-paragraph lo lp iq lq b lr nf jr lt lu ng ju lw lx nh lz ma mb ni md me mf nj mh mi mj ij bi translated"><em class="nk">‘默认’</em>队列与1个工作线程相关联，而‘jira’队列与2个工作线程相关联。</p><p id="73cd" class="pw-post-body-paragraph lo lp iq lq b lr nf jr lt lu ng ju lw lx nh lz ma mb ni md me mf nj mh mi mj ij bi translated">方便的命令:启动“默认”rq工作器—</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e4a2" class="mk kx iq mx b gy nb nc l nd ne">python3 manage.py rqworker default</span></pre><p id="c183" class="pw-post-body-paragraph lo lp iq lq b lr nf jr lt lu ng ju lw lx nh lz ma mb ni md me mf nj mh mi mj ij bi translated">希望这篇文章对你有所帮助。感谢阅读！</p></div></div>    
</body>
</html>