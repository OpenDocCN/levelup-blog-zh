<html>
<head>
<title>Lifting Props Up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">举起支柱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lifting-props-up-f1be43a1d7a4?source=collection_archive---------2-----------------------#2019-08-16">https://levelup.gitconnected.com/lifting-props-up-f1be43a1d7a4?source=collection_archive---------2-----------------------#2019-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1a70" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用React的上下文API来访问父属性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a0ec98db0d8c7f0a9802e1cd2054b88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApHQh-JNs6CKy3dj6RUtNA.jpeg"/></div></div></figure><p id="9649" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React文档中有很大一部分是关于在几个组件共享相同变化数据的情况下<a class="ae ln" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">提升状态</a>的。建议将共享状态提升到组件最接近的公共祖先。然后将状态作为道具传递给所需的后代组件。</p><p id="0bab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在处理属性时，经常会将相同的属性传递给兄弟/后代组件(当将某个状态提升到一个共同的祖先时可能就是这种情况)。考虑以下标题组件的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="1e2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有一个带有子组件<code class="fe lq lr ls lt b">Navigation</code>和<code class="fe lq lr ls lt b">UserPanel</code>的<code class="fe lq lr ls lt b">Header</code>组件，它们都需要访问<code class="fe lq lr ls lt b">type</code>属性，我们假设属性是<code class="fe lq lr ls lt b">horizontal</code>或<code class="fe lq lr ls lt b">vertical</code>。然后<code class="fe lq lr ls lt b">Navigation</code>和<code class="fe lq lr ls lt b">UserPanel</code>组件将能够根据这个值呈现不同的布局。</p><p id="0039" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看子组件内部，我们可以看到如何使用<code class="fe lq lr ls lt b">type</code>道具:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="bfbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe lq lr ls lt b">Navigation</code>组件内部，当<code class="fe lq lr ls lt b">type</code>被设置为<code class="fe lq lr ls lt b">vertical</code>时，我们正在呈现一个带有徽标的更突出的标注部分。我们也会对<code class="fe lq lr ls lt b">UserPanel</code>组件做一些类似的事情；我们可以想象根据父<code class="fe lq lr ls lt b">Header</code>是<code class="fe lq lr ls lt b">vertical</code>还是<code class="fe lq lr ls lt b">horizontal</code>呈现稍微不同的布局。</p><h2 id="d27f" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">问题</h2><p id="d294" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在我看来，现在的问题是我们在重复将<code class="fe lq lr ls lt b">type</code> prop传递给后代组件；每个需要<code class="fe lq lr ls lt b">type</code>值的后代组件必须手动将其作为属性传递。虽然这种显式性可能是可取的，但我认为能够从父/祖先隐式访问<code class="fe lq lr ls lt b">type</code>值是一种更好的体验，并允许更干净、更干燥的JSX。这实际上意味着能够隐式访问父属性。关于父母道具的另一种思考方式是<em class="ms">情境</em>。</p><p id="5a08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">鉴于React有一个<a class="ae ln" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>，我们肯定能够设计出一个令人满意的API。使用原始的上下文API来实现我们想要的会相当麻烦；我们将不得不在<code class="fe lq lr ls lt b">Header</code>组件中创建并导出一个上下文对象，并将道具传播到其中。然后，在任何需要访问值的后代组件中，我们必须导入上下文并使用<code class="fe lq lr ls lt b">useContext</code>钩子。</p><p id="da0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将是比简单地把道具传给每个需要它的后代更糟糕的体验；目标是消除由钻柱引起的任何组件耦合——通过每次导入一个专用的上下文对象，组件仍然是耦合的。解决这种耦合的唯一方法是使用全局状态/上下文管理器(或者像Redux这样的东西，或者全局上下文对象)。</p><h2 id="f04e" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">不同的方法</h2><p id="5f00" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">本着将状态提升到最近的共同祖先的精神，我们希望我们的示例是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="9f9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从DX/API的角度来看，将道具一次传递给最近的公共祖先比多次传递给每个后代更有意义。在我们的子组件中，我们现在将通过<code class="fe lq lr ls lt b">context</code>而不是<code class="fe lq lr ls lt b">props</code>访问<code class="fe lq lr ls lt b">type</code>，所以我们需要为组件的函数提供第二个参数(由于析构了参数对象，其他都是一样的):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="0daa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按照这种思路，我们可以固有地访问父组件的属性。然而，不幸的是，从技术角度来看，这不太可行。在React中固有地访问父信息通常是不可取的，建议显式地向下传递数据。在这种特殊情况下，本质上访问父节点<code class="fe lq lr ls lt b">div</code>的道具是不可能的。如果不能访问<code class="fe lq lr ls lt b">div</code>的原型，我们就不能在这里用<code class="fe lq lr ls lt b">type</code> prop做任何有用的事情(比如将它传递给某个上下文对象)。</p><p id="ca9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们有某种<em class="ms">更高级别的组件</em>来处理所有的脏工作，并且我们愿意使用所述组件来将元素呈现给DOM，我们可以以下面的JSX结束:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="bb97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们所做的就是用定制的<code class="fe lq lr ls lt b">Component</code>组件替换父<code class="fe lq lr ls lt b">div</code>包装器。我们可以让<em class="ms">添加</em>一个新的包装器/提供者组件来包围现有的<code class="fe lq lr ls lt b">div</code>，但是考虑到任何UI组件都会有某种包装HTML元素，不引入更多的嵌套更实际。</p><p id="00e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个定制组件将在幕后维护它自己的上下文对象(对于每个实例)，传递它的属性。当然，为了接收上下文对象，后代组件也需要使用自定义的<code class="fe lq lr ls lt b">Component</code>，这将使<code class="fe lq lr ls lt b">Navigation</code>组件看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="b4d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，使用这种方法，因为是<code class="fe lq lr ls lt b">&lt;Component&gt;</code>提供了上下文，我们不能将<code class="fe lq lr ls lt b">context</code>参数作为第二个参数传递给组件的函数并期望访问它。我们能做的最好的事情是使用渲染道具(或者更具体地说，一个作为子的<em class="ms">函数)，所以类似于:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="0b28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…如果你问我，我觉得这并没有多糟糕，但仍然是一次非常愉快的经历。这使得我们能够继承父属性，甚至任何祖先属性，这取决于我们的定制<code class="fe lq lr ls lt b">Component</code>组件是如何构建的，而不必手动创建、导出和导入上下文对象。</p><h2 id="20ae" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated"><code class="fe lq lr ls lt b">&lt;Component&gt;</code></h2><p id="28db" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">您可以创建一个定制组件来相当容易地实现这一功能。最终结果可能类似于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="6a97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…您可以看到我们如何在内部利用上下文API为组件提供父属性。通过将这个功能提取到一个单独的实用程序组件，我们可以证明以这种方式使用<em class="ms">上下文</em>(即访问父/祖先属性)——为库中的每个UI组件手动这样做(或类似于 this的事情)是不值得的。</p><h2 id="0d2a" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">结论</h2><p id="bbc2" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">本文的目的是确定一种解决方案，允许祖先的信息被后代继承，而不会污染我们的JSX，不会将组件耦合在一起，也不会对我们的开发人员体验产生负面影响。动机来自于当兄弟组件需要访问相同的状态时，必须重复地将相同的信息传递给它们。像Redux这样的全局状态管理器应该被避免。使用自定义<em class="ms">高阶组件</em>而不是HTML标签的最终解决方案允许我们使用子函数来满足我们的目标，在子函数中我们可以暴露包含父道具的自定义<code class="fe lq lr ls lt b">context</code>对象。</p><h2 id="2a35" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">进一步的想法</h2><p id="6f1f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我正在开发一个库，更深入地探索本文中讨论的概念，它叫做<a class="ae ln" href="https://github.com/One-Nexus/Lucid" rel="noopener ugc nofollow" target="_blank"> Lucid，可以在Github </a>上找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/17833192eee8560848a3d123438eefdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gY3VhEaqoZLODvCkQS8Yug.png"/></div></div></figure><p id="7bb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还写了一些其他文章，探索与本文中讨论的类似的想法，如果你愿意，可以在这里查看:</p><ul class=""><li id="2f1f" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">创建可伸缩的用户界面:主题化&amp;配置</li><li id="3173" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated"><a class="ae ln" href="https://medium.com/valtech-design/beautiful-state-context-based-styling-with-react-css-in-js-781a14cb2f9b" rel="noopener">美丽状态&amp;基于上下文的样式与反应(CSS-in-JS) </a></li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/0f4eaa82f76695a20f09ba4fa9fd37ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbifSkjSDCs7zGgIwXMiwg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated"><a class="ae ln" href="https://twitter.com/esr360" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ln" href="https://github.com/esr360" rel="noopener ugc nofollow" target="_blank"> Github </a></figcaption></figure></div></div>    
</body>
</html>