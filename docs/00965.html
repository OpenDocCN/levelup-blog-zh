<html>
<head>
<title>The Call Stack is Not an Infinite Resource — How to Avoid a Stack Overflow in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调用堆栈不是无限的资源——如何避免JavaScript中的堆栈溢出</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-call-stack-is-not-an-infinite-resource-d530df0041bc?source=collection_archive---------0-----------------------#2019-10-02">https://levelup.gitconnected.com/the-call-stack-is-not-an-infinite-resource-d530df0041bc?source=collection_archive---------0-----------------------#2019-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b4f567a12862352e8858f31c091ca317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2iQ6C5wnHJ8K0bmWm5mjQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@brigittetohm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布里吉特·托姆</a>在<a class="ae jg" href="https://unsplash.com/s/photos/stack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><div class=""><h2 id="e124" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用JavaScript来理解递归如何导致堆栈溢出，以及防止它发生的技巧</h2></div><p id="64e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank">调用栈</a>不是无限的资源。在执行深度递归时尤其如此。函数内部的函数调用被放在调用栈的更高层，这意味着每个递归调用都位于调用栈中，等待被执行。</p><p id="95ba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Javascript 中<a class="ae jg" href="https://2ality.com/2014/04/call-stack-size.html" rel="noopener ugc nofollow" target="_blank">调用栈的大小是不固定的，但是它并不大。让我们看一个微不足道的例子:</a></p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f139" class="md me jj lz b gy mf mg l mh mi">let ct = 0;<br/>const MAX = 100_000</span><span id="5352" class="md me jj lz b gy mj mg l mh mi">const recurse = () =&gt; {<br/>  if (++ct &gt; MAX) return<br/>  recurse()<br/>}</span><span id="b4ef" class="md me jj lz b gy mj mg l mh mi">try {<br/>  recurse()<br/>} catch (e) {<br/>  console.error({ ct, e })<br/>}</span></pre><p id="b02f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我在Node.js中运行它，我会得到以下输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="84f7" class="md me jj lz b gy mf mg l mh mi">{<br/>  ct: 15711,<br/>  e: RangeError: Maximum call stack size exceeded<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:4:17)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>      at recurse (/home/jlowery2663/projects/stacksmash/overflow.js:6:3)<br/>}</span></pre><p id="3d1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第15，711次迭代时发生堆栈溢出。以下是一些防止这种情况发生的技巧。</p><h1 id="b81e" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">设置超时</h1><p id="0008" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">setTimeout函数调度一个函数调用，由事件循环在将来的某个时间点处理。在这种情况下，不会发生真正的递归:内部的“递归”函数将会执行，但是外部的函数将会返回，因此不再在事件消息队列中(告诉事件循环做什么以及何时做的队列)。</p><p id="d00b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">setTimeout方法有两个参数:一个函数和一个时间延迟(以毫秒为单位)。延迟可以是零毫秒，因此功能可以“立即”执行。让我们来试试:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3adb" class="md me jj lz b gy mf mg l mh mi">let ct = 0;<br/>const MAX = 100_000</span><span id="f5c2" class="md me jj lz b gy mj mg l mh mi">const recurse = (cb) =&gt; {<br/>  if (++ct &gt; MAX) {<br/>    return cb(ct)<br/>  }<br/>  <strong class="lz jk">setTimeout</strong>(() =&gt; recurse(cb), 0)<br/>}</span><span id="f5b5" class="md me jj lz b gy mj mg l mh mi">try {<br/>  const then = process.hrtime.bigint();</span><span id="dd58" class="md me jj lz b gy mj mg l mh mi">recurse((ct) =&gt; {<br/>    const now = process.hrtime.bigint();<br/>    const nanos = now - then<br/>    const runtime = Number(nanos) / 1_000_000_000<br/>    ct--<br/>    console.log({ ct, runtime });<br/>  })<br/>} catch (e) {<br/>  console.error({ ct, e })<br/>}</span></pre><p id="5a6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个程序输出执行时间和迭代次数。结果是:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="fbaa" class="md me jj lz b gy mf mg l mh mi">{ct: 100000, runtime: 144.47516928 }</span></pre><p id="565d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这避免了调用堆栈溢出，但是有点慢，你不觉得吗？</p><h1 id="b07b" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">setImmediate</h1><p id="5840" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">尽管setTimeout可以将0ms作为第二个参数，但它没有调用setImmediate快:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6ee9" class="md me jj lz b gy mf mg l mh mi">let ct = 0;<br/>const MAX = 100_000</span><span id="34ea" class="md me jj lz b gy mj mg l mh mi">const recurse = (cb) =&gt; {<br/>  if (++ct &gt; MAX) {<br/>    return cb(ct)<br/>  }<br/>  <strong class="lz jk">setImmediate</strong>(() =&gt; recurse(cb))<br/>}</span><span id="e9bc" class="md me jj lz b gy mj mg l mh mi">try {<br/>  const then = process.hrtime.bigint();</span><span id="9d52" class="md me jj lz b gy mj mg l mh mi">recurse((ct) =&gt; {<br/>    const now = process.hrtime.bigint();<br/>    const nanos = now - then<br/>    const runtime = Number(nanos) / 1_000_000_000<br/>    ct--<br/>    console.log({ ct, runtime });<br/>  })<br/>} catch (e) {<br/>  console.error({ ct, e })<br/>}</span></pre><p id="caca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个程序的执行时间比上一个程序快得多:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="86d9" class="md me jj lz b gy mf mg l mh mi">{ ct: 100000, runtime: 0.295789227 }</span></pre><p id="039c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几分之一秒，而不是144+！为什么？</p><p id="00c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过setImmediate执行函数不像setTimeout那样被调度。相反，它会在所有输入/输出处理器执行完毕后立即执行。JavaScript中的事件循环处理在其他地方已经有了很好的解释，比如这里的<a class="ae jg" href="http://voidcanvas.com/setimmediate-vs-nexttick-vs-settimeout/" rel="noopener ugc nofollow" target="_blank"/>，这篇文章是关于避免调用堆栈溢出的。</p><h2 id="80a7" class="md me jj bd ml ng nh dn mp ni nj dp mt lh nk nl mv ll nm nn mx lp no np mz nq bi translated">下一滴答</h2><p id="d121" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">当在Node.js环境中执行时，还有另一个资源可以避免堆栈溢出:<strong class="la jk"> process.nextTick()。</strong><strong class="la jk">进程</strong>对象是一个全局对象，很像浏览器中的<strong class="la jk">窗口</strong>对象。<strong class="la jk"> nextTick </strong>方法在第一时间执行函数，绕过事件消息队列。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="fb90" class="md me jj lz b gy mf mg l mh mi">let ct = 0;<br/>const MAX = 100_000</span><span id="e570" class="md me jj lz b gy mj mg l mh mi">const recurse = (cb) =&gt; {<br/>  if (++ct &gt; MAX) {<br/>    return cb(ct)<br/>  }<br/>  process.<strong class="lz jk">nextTick</strong>(() =&gt; recurse(cb))<br/>}</span><span id="1545" class="md me jj lz b gy mj mg l mh mi">try {<br/>  const then = process.hrtime.bigint();</span><span id="b509" class="md me jj lz b gy mj mg l mh mi">recurse((ct) =&gt; {<br/>    const now = process.hrtime.bigint();<br/>    const nanos = now - then<br/>    const runtime = Number(nanos) / 1_000_000_000<br/>    ct--<br/>    console.log({ ct, runtime });<br/>  })<br/>} catch (e) {<br/>  console.error({ ct, e })<br/>}</span></pre><p id="91c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果是:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6977" class="md me jj lz b gy mf mg l mh mi">{ ct: 100000, runtime: 0.109725787 }</span></pre><p id="5ce5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在这个简单的代码示例中，<strong class="la jk"> nextTick </strong>比<strong class="la jk"> setImmediate </strong>快60–70%。</p><h1 id="c7c2" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">环</h1><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/629f1767794d1560847ce20de0568179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*napoa3Kn5b50HTGOGn_Z2w.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">Marc Schaefer 在<a class="ae jg" href="https://unsplash.com/s/photos/loop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="18c4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不使用递归，可以将递归调用转换为循环。对于到目前为止显示的琐碎示例，这是一项简单的任务。</p><p id="9f6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，有时递归可能被嵌套得很深。假设函数A调用函数B调用函数C，函数C可能再次调用函数B<em class="ns">或</em>函数A。现在你有一个- &gt; B- &gt; C- &gt; B|A递归，将这种类型的递归转换成循环可能不那么容易。</p><p id="4e12" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">主循环可以通过变量调用函数，而不是直接调用函数。函数变量由每个函数调用设置，调用每个函数成为循环结构的责任:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9329" class="md me jj lz b gy mf mg l mh mi">let ct = 0;<br/>const MAX = 100_000</span><span id="3574" class="md me jj lz b gy mj mg l mh mi">const A = () =&gt; {<br/>  <strong class="lz jk">fp </strong>= B;<br/>}</span><span id="b590" class="md me jj lz b gy mj mg l mh mi">const B = () =&gt; {<br/>  <strong class="lz jk">fp</strong> = A;<br/>}</span><span id="501a" class="md me jj lz b gy mj mg l mh mi">let <strong class="lz jk">fp</strong> = B;</span><span id="1242" class="md me jj lz b gy mj mg l mh mi">const then = process.hrtime.bigint();</span><span id="f242" class="md me jj lz b gy mj mg l mh mi">for (; ;) {</span><span id="12f0" class="md me jj lz b gy mj mg l mh mi">if (++ct &gt; MAX) {<br/>    const now = process.hrtime.bigint();<br/>    const nanos = now - then;</span><span id="5da4" class="md me jj lz b gy mj mg l mh mi">const runtime = Number(nanos) / 1_000_000_000<br/>    ct--<br/>    console.log({ ct, runtime });<br/>    break;<br/>  }<br/>  <strong class="lz jk">fp</strong>()<br/>  continue;<br/>}</span></pre><p id="602d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个循环没有任何调用函数的函数，但是每个函数都有责任通过函数变量<strong class="la jk"> fp </strong>知道并控制下一步执行什么函数。这产生了迄今最快的结果:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="52a8" class="md me jj lz b gy mf mg l mh mi">{ ct: 100000, runtime: 0.015974012 }</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="34a4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你知道了:避免可怕的堆栈溢出的四种方法。</p></div></div>    
</body>
</html>