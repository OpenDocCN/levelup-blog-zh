<html>
<head>
<title>Practical approach to Microservices Architecture — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构的实用方法—第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-approach-to-microservices-architecture-part-2-7337c0444086?source=collection_archive---------9-----------------------#2021-01-07">https://levelup.gitconnected.com/practical-approach-to-microservices-architecture-part-2-7337c0444086?source=collection_archive---------9-----------------------#2021-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c587" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解基本模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7c1a771d090de36837634ea00a754b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSpy7k9q0ZJ2wwWuWocOpw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由来自Pixabay的Gerd Altmann拍摄</figcaption></figure><p id="73bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">任何大规模微服务应用都可以通过采用某些成功的设计实践来实现该架构的全部优势并避免常见缺陷。在本系列的第一篇文章中，我们讨论了API网关和消息代理如何抽象出内部集群的复杂性，为实现横切关注点提供一个公共位置，并提高应用程序的可靠性。</p><p id="66e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这第二篇也是最后一篇文章中，我们来看看:</p><ul class=""><li id="2a77" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">集中式遥测存储如何通过提供对请求流的可观察性来简化跟踪和调试。</li><li id="1251" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">中央配置存储和编排引擎如何大幅降低运营成本并提供易于使用的自动化API。</li></ul><p id="ae52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">集中遥测存储:</strong></p><p id="f216" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">单个客户端请求工作流最终可能会跨越多个辅助请求，这些请求需要在微服务之间跳跃才能得到处理，这使得跟踪请求流并识别任何故障或性能瓶颈变得非常复杂。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/7c3d67fc68ea2cfabaa451177855dfe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7c90brGbjasqKmadCmYu5Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae lr" href="https://medium.com/nikeengineering/hit-the-ground-running-with-distributed-tracing-core-concepts-ff5ad47c7058" rel="noopener">利用分布式跟踪核心概念立即行动|作者Nic Munroe | Nike Engineering | Medium</a></figcaption></figure><p id="4063" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用集中式遥测存储实现分布式跟踪有助于缓解这个问题。我看到团队遵循的一个普遍主题是定义一个公共遥测日志模式，每个服务都必须遵循该模式来将日志发布到中央存储。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/8f12c231056d39f58b4f5d6d6dba5cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRK4RXryuJkC970M2Yzt8g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">集中式遥测存储体系结构</figcaption></figure><p id="7810" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的场景中，标记为CID(关联ID)的属性在整个工作流中跟踪请求，并记录到每个服务层的遥测存储中。甚至错误也会记录在CID中。使用CID查询存储中的日志，以跟踪请求流和故障点。</p><p id="340e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">集中式遥测存储有助于:</p><ol class=""><li id="bc4a" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mi ly lz ma bi translated">使用相关令牌启用给定请求流的分布式跟踪。</li><li id="5935" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">查询和汇总失败率(过去N秒内的失败次数)、请求率(RPS)等指标可用于设置工作流，以便根据预定义的条件自动修复、扩展和关闭服务。</li><li id="5514" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">将每个服务的性能记录到一个集中的位置有助于调查瓶颈及其出现的频率。</li><li id="ce5f" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">审核微服务的所有入站和出站请求有助于分析用户行为，这可进一步用于评估任何试验功能的成功率。</li><li id="1bb1" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">审计还有助于我们检测异常，并识别应用程序中的安全性和合规性问题。</li></ol><p id="7627" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">协调集群管理</strong></p><p id="2fac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个微服务都必须依赖集群中的其他组件，至少它必须与数据存储/服务和API网关进行交互。每个这样的微服务将有多个副本在不同的IP地址和端口上运行。这些副本又必须与数据存储和API网关的其他副本进行交互。现在想象一下，管理和协调一个包含超过5个微服务的应用程序的集群，每个微服务都有自己的副本集，这些副本与其依赖关系的副本进行交互。这就是像Kubernetes这样的生产级集群编排器将有助于大大降低复杂性的地方。</p><p id="7d2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一下带有2个微服务的集群的放大版本</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/3d3aa44270ce8100f1c7d55acc2f35bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhuIQS6vX7enKixZAyRGiw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">具有两个微服务的集群的放大版本</figcaption></figure><p id="b829" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Cluster orchestrator具有以下优势:</p><ol class=""><li id="b341" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mi ly lz ma bi translated">编排器可以管理集群以反映所配置的期望状态。如果给定的微服务(微服务B)被配置为具有2个副本，则orchestrator通过旋转另一个实例来维持配置的状态，以防一个服务副本关闭。</li><li id="deaa" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">根据流量或资源利用率的激增，orchestrator可以自动增加/减少为微服务配置的副本数量(正如您在微服务A中看到的那样)。</li><li id="720f" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">通过用负载平衡器服务(正如您可以从每个“橙色”服务层观察到的那样)包装依赖性，抽象出依赖性的所有复杂性(如IP地址、端口和运行的副本数量),并协调这些服务之间的适当通信流。</li><li id="55a5" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">通过提供部署自动化API，可以轻松发布集群中任何给定微服务或一组微服务的新版本或回滚到旧版本。</li><li id="4168" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">灵活控制流向服务副本的流量，并执行各种版本的A/B测试。</li></ol><p id="6e9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">集中配置商店</strong></p><p id="3d96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从开发到生产前，基于微服务构建的每个应用都需要经过测试。尽管微服务应该是分散的，但是某些组件仍然需要集中起来以减轻部署的痛苦。在部署到生产环境之前，典型的微服务部署在开发、测试和生产前环境中。每个服务都有自己单独的应用程序配置、部署配置文件等。适用于各种环境。因此，假设每个服务有3-4个不同的环境，我们的应用程序中有10个这样的微服务，我们最终会有过多的文件，管理它们绝对是一场噩梦。这个问题可以通过使用一个集中的存储来解决，所有的配置文件都放在这个存储中，这样应用程序就可以平稳地运行。</p><p id="6cc1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">市场上有几种构建为分布式键值存储的解决方案，如Zookeeper、Azure应用配置。Kubernetes也有一个秘密和配置管理特性来解决这个需求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/4f65d7b89b1f075db2feaed0c0090c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*tJFK1Hi_FSesN97QE3Er6g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">集中式配置存储架构</figcaption></figure><p id="cce9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上图显示了配置/密码管理的一般最佳实践。</p><ol class=""><li id="b607" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mi ly lz ma bi translated">在服务的初始引导期间，每个微服务将基本配置加载到内存中。</li><li id="5144" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">所有后续更改都由DevOp成员完成，并在更新配置存储之前在遥测存储中进行审核。</li><li id="4c32" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">对相关配置的任何更新都由配置存储通知给适当的微服务。</li><li id="cb29" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">微服务使用最新的更改更新其内存中的配置版本。</li></ol><p id="fbfd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">拥有集中式配置存储具有以下优势:</p><ol class=""><li id="0573" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq mi ly lz ma bi translated">配置存储通常是一个高度可用的集中式地理冗余存储，服务可以安全地依靠它来获取最新的配置数据。</li><li id="cf00" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">审计和变更通知为解决由于配置变更导致的任何部署或代码故障提供了灵活性。</li><li id="342b" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq mi ly lz ma bi translated">轻松切换集群环境，无需担心跨每个服务修改配置值。</li></ol><p id="df76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这两篇系列文章中，我们讨论了成功产品在微服务架构中采用的最佳设计实践，以及它们如何帮助缓解一些最常见的问题。</p></div></div>    
</body>
</html>