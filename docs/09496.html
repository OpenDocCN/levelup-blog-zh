<html>
<head>
<title>Basic Parallel Computing in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的基本并行计算</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basic-parallel-computing-in-go-fda50894241c?source=collection_archive---------5-----------------------#2021-08-16">https://levelup.gitconnected.com/basic-parallel-computing-in-go-fda50894241c?source=collection_archive---------5-----------------------#2021-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7437445d361ec8a0c4826c4062c805f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84e3dPDbr3f02jgCCa6dVg.jpeg"/></div></div></figure><p id="573d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">去年，我一直在谷歌担任软件工程师，用Go编程已经成为我的新习惯。我的一些朋友问我为什么去，我也用“简单”来回答。</p><p id="f91f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过，我想写一篇关于Go中并发性的短文，因为这是我过去使用其他编程语言探索过的一个主题，例如我喜欢的<a class="ae kw" href="https://medium.com/hackernoon/a-sad-story-about-concurrency-346990a9a3fe?source=friends_link&amp;sk=5ff1e07d64a3af30e8434d0ff52c04b8" rel="noopener"> <strong class="ka ir"> <em class="kx"> Java </em> </strong> </a>和<a class="ae kw" href="https://medium.com/hackernoon/c-async-api-the-missing-parts-2229a2b3732?source=friends_link&amp;sk=4dcaafc6985b27a9638b09be910e5662" rel="noopener"> <strong class="ka ir"> <em class="kx"> C# </em> </strong> </a>。因此，在这篇文章中，我将尝试遵循以前在我的其他并发文章中使用的相同模式，从非常串行的程序走向并行版本的程序。</p><p id="dc30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想从一个URL下载内容。我们可以简单地使用下面的函数。这段代码同步运行。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b7d5" class="lh li iq ld b gy lj lk l ll lm">func content(url string) (string, error) {<br/> resp, err := http.Get(url)<br/> if err != nil {<br/>  return "", err<br/> }<br/> defer resp.Body.Close()</span><span id="4969" class="lh li iq ld b gy ln lk l ll lm"> out := &amp;strings.Builder{}<br/> buff := make([]byte, 1024)</span><span id="6d20" class="lh li iq ld b gy ln lk l ll lm"> for {<br/>   n, _ := resp.Body.Read(buff)<br/>   if n &lt;= 0 {<br/>    break<br/>  }</span><span id="c3ab" class="lh li iq ld b gy ln lk l ll lm"> out.Write(buff[:n])<br/> }</span><span id="d7ec" class="lh li iq ld b gy ln lk l ll lm"> time.Sleep(2000 * time.Millisecond)</span><span id="5fdc" class="lh li iq ld b gy ln lk l ll lm"> return out.String(), nil<br/>}</span></pre><p id="7d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，在计算中存在嵌入式延迟，这实际上可能是与数据库或任何其他系统对话的结果。</p><p id="d7e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，我们如何同步地编写如上代码，然后将它与其他相关计算链接起来。</p><p id="7065" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们定义一个新函数，它使用<code class="fe lo lp lq ld b">content</code>的结果来做一些其他的工作。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e7de" class="lh li iq ld b gy lj lk l ll lm">type Counts map[string]int</span><span id="a37e" class="lh li iq ld b gy ln lk l ll lm">func countWords(content string) Counts {<br/> out := Counts{}</span><span id="3185" class="lh li iq ld b gy ln lk l ll lm"> words := strings.Split(content, ",")</span><span id="03a0" class="lh li iq ld b gy ln lk l ll lm"> for _, w := range words {<br/>  out[w]++<br/> }</span><span id="ec44" class="lh li iq ld b gy ln lk l ll lm"> return out<br/>}</span></pre><p id="1ae4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们可以通过以下方式同步链接它们:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d02e" class="lh li iq ld b gy lj lk l ll lm">c, err := content("<a class="ae kw" href="https://www.google.com" rel="noopener ugc nofollow" target="_blank">https://www.google.com</a>")<br/> if err != nil {<br/>  fmt.Printf("error = %v", err)<br/>  os.Exit(1)<br/> }<br/>fmt.Printf("%v", countWords(c))</span></pre><p id="56f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们假设我们需要下载和字数数以百万计的网址，每一个都需要时间来处理。在这种情况下，我们不应该在每个URL上阻塞，我们应该尝试并行处理每个处理部分。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d944" class="lh li iq ld b gy lj lk l ll lm">func contentAsync(url string, output chan&lt;- string) error {<br/> c, err := content(url)<br/> if err != nil {<br/>  return err<br/> }</span><span id="b739" class="lh li iq ld b gy ln lk l ll lm">output &lt;- c<br/> return nil<br/>}</span></pre><p id="d77e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，<code class="fe lo lp lq ld b">contentAsync</code>收到一个通道，在<code class="fe lo lp lq ld b">content</code>实际完成下载后，它在那里写入结果。在此之前，没有任何异步，但是让我们看看如何调用这个函数。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1d68" class="lh li iq ld b gy lj lk l ll lm">size := 10<br/>q := make(chan string, size)</span><span id="82fc" class="lh li iq ld b gy ln lk l ll lm">for i := 0; i &lt; size * 2; i++ {<br/>  go contentAsync("<a class="ae kw" href="https://www.google.com" rel="noopener ugc nofollow" target="_blank">https://www.google.com</a>", q)<br/>}</span><span id="80dd" class="lh li iq ld b gy ln lk l ll lm">for i := 0; i &lt; size * 2; i++ {<br/>  c := &lt;-q<br/>  fmt.Println(len(c))<br/>}</span></pre><p id="f324" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们有<code class="fe lo lp lq ld b">size</code>来指定我们可以在通道中排队多少消息。试图在信道中放入更多的消息，会阻塞，直到从信道中取出一些其他消息。这确保了并行计算数量受限于<code class="fe lo lp lq ld b">size</code>。</p><p id="857a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，我们用特定的类型声明通道，所以只有字符串可以在通道上发送/接收。</p><p id="7456" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们启动一个名为goroutine的并行进程，它实际上负责下载URL的内容并将其写入给定的通道。请注意，我们下载的URL是通道中可用位置的两倍，<code class="fe lo lp lq ld b">contentAsync</code>将阻塞通道，等待其他进程从通道中取出项目。</p><p id="d56e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们有另一个for循环，它在元素变得可用时从通道中取出元素。请注意，如果通道中没有任何东西，<code class="fe lo lp lq ld b">&lt;-q</code>将会阻塞，直到有东西出现。事实上，这个for循环在第一个循环完成之前就开始执行了。</p><p id="b7cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要链接下载和计数，使它们并行发生。让我们看看我们如何能做到这一点。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="29bd" class="lh li iq ld b gy lj lk l ll lm">func countAsync(input &lt;-chan string, output chan&lt;- Counts) {<br/> for c := range input {<br/>  output &lt;- countWords(c)<br/> }<br/> close(output)<br/>}</span></pre><p id="905d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数<code class="fe lo lp lq ld b">countAsync</code>基本上从通道<code class="fe lo lp lq ld b">input</code>中读取，并将相应的计数写入通道<code class="fe lo lp lq ld b">output</code>。</p><p id="34fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们想要N个计算单元计数，我们只需要启动N个运行<code class="fe lo lp lq ld b">countAsync</code>的goroutines。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="43e6" class="lh li iq ld b gy lj lk l ll lm">size := 10<br/>q := make(chan string, size)<br/>o := make(chan Counts, size)</span><span id="1e88" class="lh li iq ld b gy ln lk l ll lm">for i := 0; i &lt; size*2; i++ {<br/>  go contentAsync("<a class="ae kw" href="https://www.google.com" rel="noopener ugc nofollow" target="_blank">https://www.google.com</a>", q)<br/>}</span><span id="bf11" class="lh li iq ld b gy ln lk l ll lm">go countAsync(q, o)</span><span id="8ec1" class="lh li iq ld b gy ln lk l ll lm">for i := 0; i &lt; size*2; i++ {<br/>  fmt.Println(len(&lt;-o))<br/>}</span></pre><p id="4e36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们从一个<code class="fe lo lp lq ld b">countAsync </code>开始，但是，如果我们想要更多，我们可以很容易地这样做。请注意，由于它们是并行运行的，它们不会阻塞，下面的for循环将等待size * 2计数出现在<code class="fe lo lp lq ld b">o</code>通道中。</p><p id="6ee4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们需要更多的计算能力，并且我们负担得起，我们只需用函数启动更多的goroutines。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b3ad" class="lh li iq ld b gy lj lk l ll lm">size := 10<br/>q := make(chan string, size)<br/>o := make(chan Counts, size)</span><span id="17fd" class="lh li iq ld b gy ln lk l ll lm">for i := 0; i &lt; size*2; i++ {<br/>  go contentAsync("<a class="ae kw" href="https://www.google.com" rel="noopener ugc nofollow" target="_blank">https://www.google.com</a>", q)<br/>}</span><span id="d2d8" class="lh li iq ld b gy ln lk l ll lm">for i := 0; i &lt; 5; i++ {<br/>  go countAsync(q, o)<br/>}</span><span id="a1ba" class="lh li iq ld b gy ln lk l ll lm">for i := 0; i &lt; size*2; i++ {<br/>  fmt.Println(len(&lt;-o))<br/>}</span></pre><p id="cf16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe lo lp lq ld b">countAsync</code>连同通道的使用，是链接计算的一种非常自然的方式。它们就像linux中的管道，其中生成器在多个实例中运行，而接收器(管道的另一端)也可以运行自身的多个实例。</p><p id="5792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在分布式系统的世界中，Apache Kafka以完全相同的方式工作。我们让发送器并行运行，生成数据并将其排入队列以供其他进程处理。在Kafka中，队列的大小受到集群资源的限制。在Go中，通道受到内存和处理能力的限制，但从概念上讲，它们与队列相同，在队列中，我们从多个独立的进程中进行读写。</p><p id="c9c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望通道和队列的类比能够帮助您理解Go中的同步和并行处理是如何工作的。当然，我们可以在Go中使用许多其他高级构造，但大多数都是使用本文中显示的构建模块。</p><p id="4d2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">快乐编码</em></p></div></div>    
</body>
</html>