<html>
<head>
<title>Docker From the Very Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最基础的码头工人</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-from-the-very-basic-64f15ac38ed7?source=collection_archive---------14-----------------------#2020-07-12">https://levelup.gitconnected.com/docker-from-the-very-basic-64f15ac38ed7?source=collection_archive---------14-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7dcf" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">学习发展选项</h2><div class=""/><div class=""><h2 id="3426" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">将Docker理解为独立的本地环境</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/35503e474d1ecb78b886bf5325aa4637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4G1ZHNdpiOa5ls7x"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="011b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">已经有很多关于Docker的教程了。它们有助于我开始理解Docker，但不能满足我临时设置一些东西的需要(例如，增量地构建<code class="fe mn mo mp mq b">Dockerimage</code>)，或者有一种增量地调试<code class="fe mn mo mp mq b">Dockerimage</code>而不需要运行整个Docker映像生成的方法。</p><blockquote class="mr ms mt"><p id="7866" class="li lj mu lk b ll lm kd ln lo lp kg lq mv ls lt lu mw lw lx ly mx ma mb mc md im bi translated">大多数教程从<em class="it">什么是Docker </em>跳到<em class="it">创建Dockerimage </em>，忽略了如何逐步创建<em class="it"> Dockerimage </em>的步骤。我可以理解为什么没有包括这一点，但在我的情况下，我需要这一点，因此在这里制作本教程来弥补差距。</p></blockquote><h1 id="02f2" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">Docker是什么？</h1><p id="66eb" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">用我自己的话来说，我认为Docker是一个超级有用的工具，可以用合适的环境构建一个小容器来运行您的web应用程序或执行特定的任务，例如编译和分发您的Android应用程序</p><div class="nv nw gp gr nx ny"><a href="https://medium.com/mobile-app-development-publication/intro-to-docker-building-android-app-cb7fb1b97602" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jd gy z fp od fr fs oe fu fw jc bi translated">docker简介:构建Android应用程序</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">如果您想知道如何将构建您的应用程序卸载到开发之外的另一个自动化流程中…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om lb ny"/></div></div></a></div><p id="4dea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设您有一些运行在本地机器上的虚拟环境容器，但是与本地机器环境完全分离。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/72b6c35bb45567e3ec989284a3a6da8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*ZW9OamnzDXXHnqCtqdCR3w.png"/></div></figure><p id="7c9d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">酷，用一台机器，你可以随时设置任何不同的环境，而且它们不会互相冲突。对我来说最好的是，我可以随时删除它们，而且干净利落。</p><h2 id="7846" class="oo mz it bd na op oq dn ne or os dp ni lr ot ou nk lv ov ow nm lz ox oy no iz bi translated">如何设置Docker？</h2><p id="9951" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">要在你的机器上安装Docker，你只需要安装它。</p><div class="nv nw gp gr nx ny"><a href="https://docs.docker.com/engine/install/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jd gy z fp od fr fs oe fu fw jc bi translated">安装Docker引擎</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">Docker Engine可在多种Linux平台、macOS和Windows 10上通过Docker Desktop获得，并作为…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">docs.docker.com</p></div></div><div class="oh l"><div class="oz l oj ok ol oh om lb ny"/></div></div></a></div><p id="c4f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">之后，您需要通过运行Docker应用程序来运行Docker守护程序。这就是你准备好它所需要的。</p><h1 id="b957" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">运行您的第一个容器</h1><p id="51b8" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">在您的机器中，让我们假设您有兴趣打开</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="630f" class="oo mz it mq b gy pe pf l pg ph">docker run -it --name my-container openjdk:8-jdk-slim</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/cbc61481e2acb6a8d1c3dc691864dc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*g7Xue9e4vh13GE-2llkOlw.png"/></div></figure><ul class=""><li id="3bc5" class="pj pk it lk b ll lm lo lp lr pl lv pm lz pn md po pp pq pr bi translated"><code class="fe mn mo mp mq b">run</code>是通过从映像创建容器来运行它。</li><li id="7c4b" class="pj pk it lk b ll ps lo pt lr pu lv pv lz pw md po pp pq pr bi translated"><code class="fe mn mo mp mq b">-it</code>是让它交互运行。就像贝壳一样。</li><li id="352d" class="pj pk it lk b ll ps lo pt lr pu lv pv lz pw md po pp pq pr bi translated"><code class="fe mn mo mp mq b">--name</code>是给容器命名，以防以后需要引用它。</li><li id="6304" class="pj pk it lk b ll ps lo pt lr pu lv pv lz pw md po pp pq pr bi translated"><code class="fe mn mo mp mq b">--rm</code>是在运行后移除容器。</li><li id="8d36" class="pj pk it lk b ll ps lo pt lr pu lv pv lz pw md po pp pq pr bi translated"><code class="fe mn mo mp mq b">openjdk:8-jdk-slim</code>是您希望用来设置容器的图像。通常来自<a class="ae lh" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>。你也可以有一个本地图像。</li></ul><p id="823d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于这是您第一次运行它，您可能会看到它下载了<code class="fe mn mo mp mq b">openjdk:8-jdk-slim</code>并以下面的代码结束。</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="9eaa" class="oo mz it mq b gy pe pf l pg ph">Unable to find image 'openjdk:8-jdk-slim' locally<br/>8-jdk-slim: Pulling from library/openjdk<br/>8559a31e96f4: Pull complete<br/>65306eca6b8e: Pull complete<br/>b8f37a6e9e9b: Pull complete<br/>33231475bae0: Pull complete<br/>Digest: sha256:3826479f6ca03bbd11e1e12eb78b856f90bf7cea0f534f7204854c82fd89eda2<br/>Status: Downloaded newer image for openjdk:8-jdk-slim<br/>root@2c867f3bc1da:/#</span></pre><p id="0a83" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们运行<code class="fe mn mo mp mq b">java -version</code>，它会显示</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="afda" class="oo mz it mq b gy pe pf l pg ph">root@2c867f3bc1da:/# java -version<br/>openjdk version "1.8.0_252"<br/>OpenJDK Runtime Environment (build 1.8.0_252-b09)<br/>OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)<br/>root@2c867f3bc1da:/#</span></pre><p id="eccb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，您可以使用OpenJDK java，而不会因为任何安装而破坏您的本地机器环境。</p><p id="d2a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要退出容器，你只需输入<code class="fe mn mo mp mq b">exit</code>，你将回到原来的终端。这也将删除创建的容器。</p><p id="1f2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您再次运行下面的</p><blockquote class="mr ms mt"><p id="5711" class="li lj mu lk b ll lm kd ln lo lp kg lq mv ls lt lu mw lw lx ly mx ma mb mc md im bi translated">注意:我使用<code class="fe mn mo mp mq b">my-container2</code>运行，因为<code class="fe mn mo mp mq b">my-container</code>名称已经被第一个使用，否则你会得到消息<code class="fe mn mo mp mq b">docker: Error response from daemon: Conflict. The container name “/my-container” is already in use by container</code> …不要担心，我会分享如何删除它</p></blockquote><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="591c" class="oo mz it mq b gy pe pf l pg ph">docker run -it --name my-container<strong class="mq jd">2</strong> --rm openjdk:8-jdk-slim</span></pre><p id="fe49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这次不再下载图像了。你将立即被发送到新的提示。</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="e3dd" class="oo mz it mq b gy pe pf l pg ph">root@d1279588bd9e:/#</span></pre><h2 id="37af" class="oo mz it bd na op oq dn ne or os dp ni lr ot ou nk lv ov ow nm lz ox oy no iz bi translated">幕后</h2><p id="0819" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">如上所述，当您第一次启动容器时，它会下载图像。在那之后，容器引用链接到图像</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi px"><img src="../Images/ebd75cc0010008db1ace6554cd955358.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*00XldzrTFYnkv1lrnUvIYg.png"/></div></figure><p id="d45c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要列出您机器上下载的图像，使用命令<code class="fe mn mo mp mq b">docker images</code>(在另一个终端中)，它将显示图像列表，如下所示。</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="03ba" class="oo mz it mq b gy pe pf l pg ph">REPOSITORY  TAG         IMAGE ID      CREATED      SIZE<br/>openjdk     8-jdk-slim  ceab49f001b1  4 weeks ago  285MB</span></pre><p id="4581" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，要知道活动容器正在运行，使用命令<code class="fe mn mo mp mq b">docker ps</code>。</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="2708" class="oo mz it mq b gy pe pf l pg ph">CONTAINER ID      IMAGE         ...  NAMES<br/>d1279588bd9e openjdk:8-jdk-slim      my-container</span></pre><p id="f2c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">退出容器后，您将无法使用<code class="fe mn mo mp mq b">docker ps</code>找到容器。但是如果你使用<code class="fe mn mo mp mq b">docker ps -a</code>你会看到如下的东西。</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="21f8" class="oo mz it mq b gy pe pf l pg ph">CONTAINER ID IMAGE  ...   STATUS  ...                 NAMES<br/>d964a09019b2 openjdk      Exited (0) 12 seconds ago   my-container2<br/>5134214c3ea5 openjdk      Exited (0) 12 minutes ago   my-container</span></pre><h2 id="7285" class="oo mz it bd na op oq dn ne or os dp ni lr ot ou nk lv ov ow nm lz ox oy no iz bi translated">移除容器和图像</h2><p id="d13e" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">docker的另一个好处是，当它不再使用时，我们可以将其完全删除。</p><p id="2114" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要移除它们，您可以使用<code class="fe mn mo mp mq b">docker container prune</code>。</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="9e1a" class="oo mz it mq b gy pe pf l pg ph">WARNING! This will remove all stopped containers.<br/>Are you sure you want to continue? [y/N] y<br/>Deleted Containers:<br/>d964a09019b23fc96f81bd52dd73cee63cb296044c08e23e255e91bb3e86e9a7<br/>5134214c3ea5d539393b739e62e678e4ce08675f12ace4d94795c5804e68bd9f</span><span id="6975" class="oo mz it mq b gy py pf l pg ph">Total reclaimed space: 10B</span></pre><p id="2002" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它将删除所有退出的容器。</p><blockquote class="mr ms mt"><p id="06bc" class="li lj mu lk b ll lm kd ln lo lp kg lq mv ls lt lu mw lw lx ly mx ma mb mc md im bi translated">提示，如果你在退出后懒得手动移除容器，可以在运行docker容器时添加<code class="fe mn mo mp mq b">--rm</code>参数。当你退出你的容器，它会自动删除。</p></blockquote><p id="cd08" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">移除容器后，您现在可以使用命令<code class="fe mn mo mp mq b">docker image prune -a</code>移除所有图像(没有其他容器引用)。(注意:如果没有<code class="fe mn mo mp mq b">-a</code>，它将只移除悬挂的图像)</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="92a3" class="oo mz it mq b gy pe pf l pg ph">WARNING! This will remove all images without at least one container associated to them.<br/>Are you sure you want to continue? [y/N] y<br/>Deleted Images:<br/>untagged: openjdk:8-jdk-slim<br/>untagged: openjdk@sha256:3826479f6ca03bbd11e1e12eb78b856f90bf7cea0<br/>deleted: sha256:ceab49f001b17bd71be68f2de9d8ded1bea7190da82dd0067c<br/>deleted: sha256:7f9ff1c804e9a64904548cf1f76b235c0525c16968ea0a8aef<br/>deleted: sha256:aa2da704309500fa4bf99a10d3a21fffbe34e4417d9abd3e8c<br/>deleted: sha256:e47aeb6e542620774a5364aff59e1593a8131532980b7dda9c<br/>deleted: sha256:13cb14c2acd34e45446a50af25cb05095a17624678dbafbcc9</span><span id="9c70" class="oo mz it mq b gy py pf l pg ph">Total reclaimed space: 284.6MB</span></pre><h1 id="f24e" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">交互式创建docker图像</h1><h2 id="7366" class="oo mz it bd na op oq dn ne or os dp ni lr ot ou nk lv ov ow nm lz ox oy no iz bi translated">访问容器中的本地文件</h2><p id="2bbd" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">有时候(事实上大多数时候)我们希望我们的容器与我们的本地文件进行交互，我们该怎么做呢？容器是与本地机器完全分离的环境，因此默认情况下它不允许这样做。</p><p id="84b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了将您的容器与本地文件连接起来，我们可以使用<code class="fe mn mo mp mq b">volume</code>参数</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="5f67" class="oo mz it mq b gy pe pf l pg ph">docker run -it --name my-container --volume=$(pwd):/localfolder --workdir=/localfolder openjdk:8-jdk-slim</span></pre><ul class=""><li id="e39d" class="pj pk it lk b ll lm lo lp lr pl lv pm lz pn md po pp pq pr bi translated"><code class="fe mn mo mp mq b">--volume=$(pwd):/localfolder</code>正在将本地文件夹(<code class="fe mn mo mp mq b">pwd</code>命令显示当前文件夹)映射到容器中的一个文件夹名<code class="fe mn mo mp mq b">localfolder</code>。</li><li id="89f3" class="pj pk it lk b ll ps lo pt lr pu lv pv lz pw md po pp pq pr bi translated"><code class="fe mn mo mp mq b">workdir=/localfolder</code>只是说我们将主要在<code class="fe mn mo mp mq b">localfolder</code>工作。</li></ul><p id="7666" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦您的容器启动，它将在<code class="fe mn mo mp mq b">localfolder</code>中，它被映射到您所在的本地机器文件夹。</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="24f7" class="oo mz it mq b gy pe pf l pg ph">root@15c3a84e38ca:/localfolder#</span></pre><p id="b17e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你做一个<code class="fe mn mo mp mq b">ls</code>，它会显示文件夹的内容。从这里，您可以使用容器中的本地文件夹文件。</p><blockquote class="mr ms mt"><p id="a3fb" class="li lj mu lk b ll lm kd ln lo lp kg lq mv ls lt lu mw lw lx ly mx ma mb mc md im bi translated">注意:如果您将本地文件夹映射到容器中已有的文件夹，例如<code class="fe mn mo mp mq b">opt</code>，那么您将看不到容器中的文件夹。相反，本地文件夹将优先显示。将一个本地文件夹与一个现有的容器文件夹进行卷映射是一个坏主意，如<a class="ae lh" href="https://stackoverflow.com/questions/62857104/how-to-copy-from-volume-mapped-opt-to-image-opt-folder-in-docker?noredirect=1#comment111159157_62857104" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出</a>中所解释的。</p></blockquote><h2 id="53a1" class="oo mz it bd na op oq dn ne or os dp ni lr ot ou nk lv ov ow nm lz ox oy no iz bi translated">将内容更改为容器</h2><p id="a2d2" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">一旦您位于包含映射的本地文件夹的容器中，如果您愿意，您可以将本地文件夹内容复制到容器文件夹中，例如</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="6529" class="oo mz it mq b gy pe pf l pg ph">root@15c3a84e38ca:/localfolder# cp localfolderfile ../opt/.</span></pre><p id="f60e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者你想下载一些库的更新，例如</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="3f7d" class="oo mz it mq b gy pe pf l pg ph">apt-get update</span><span id="c205" class="oo mz it mq b gy py pf l pg ph">apt-get install -y software-properties-common expect git wget libc6-i386 lib32stdc++6 lib32gcc1 lib32z1 python curl unzip lsb-release openssh-client gnupg</span></pre><p id="ee13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者如果你想去掉某样东西，例如</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="cd28" class="oo mz it mq b gy pe pf l pg ph">rm -rf /var/lib/apt/lists/*</span></pre><h2 id="8978" class="oo mz it bd na op oq dn ne or os dp ni lr ot ou nk lv ov ow nm lz ox oy no iz bi translated">制作本地图像</h2><p id="241a" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">在您根据需要修改了容器中的所有内容之后，您可以用它来制作一个图像以供将来使用。</p><p id="63f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你先从容器里取出<code class="fe mn mo mp mq b">exit</code>。然后，您可以使用下面的命令从容器中创建图像</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="e951" class="oo mz it mq b gy pe pf l pg ph">docker commit my-container my-image</span></pre><p id="e013" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您现在可以看到您的图像正在使用<code class="fe mn mo mp mq b">docker images</code></p><blockquote class="mr ms mt"><p id="517c" class="li lj mu lk b ll lm kd ln lo lp kg lq mv ls lt lu mw lw lx ly mx ma mb mc md im bi translated">提示:如果在<code class="fe mn mo mp mq b">exit</code>之后，你需要重新输入容器(无论什么原因)，你只需要使用<code class="fe mn mo mp mq b">docker start -a -i my-container</code></p></blockquote><h1 id="d1db" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">使用Dockerfile创建docker映像</h1><p id="84c6" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">上面的很好，因为我们可以创建一个图像。反复使用它。</p><p id="7299" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果我们想要一次又一次地创建一个图像，并且在不同的机器上创建相同的图像，更好的方法是使用<code class="fe mn mo mp mq b">Dockerfile</code>。</p><p id="77d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用具有以下内容的<code class="fe mn mo mp mq b">Dockerfile</code>可以轻松创建上述手动创建的图像</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="6908" class="oo mz it mq b gy pe pf l pg ph">FROM openjdk:8-jdk-slim<br/>COPY localfile ../opt/.<br/>RUN apt-get update &amp;&amp; apt-get install -y software-properties-common expect git wget libc6-i386 lib32stdc++6 lib32gcc1 lib32z1 python curl unzip lsb-release openssh-client gnupg &amp;&amp; rm -rf /var/lib/apt/lists/*</span></pre><p id="ff29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这个文件，您可以在<code class="fe mn mo mp mq b">Dockerfile</code>可用的文件夹中运行下面的命令。</p><pre class="ks kt ku kv gt pa mq pb pc aw pd bi"><span id="9e69" class="oo mz it mq b gy pe pf l pg ph">docker build -t my-image .</span></pre><blockquote class="mr ms mt"><p id="d448" class="li lj mu lk b ll lm kd ln lo lp kg lq mv ls lt lu mw lw lx ly mx ma mb mc md im bi translated">注意<code class="fe mn mo mp mq b">.</code>显示的是<code class="fe mn mo mp mq b">Dockerfile</code>所在的当前文件夹。如果它位于另一个文件夹中，则用<code class="fe mn mo mp mq b">anotherfolder/.</code>替换它</p></blockquote><p id="35dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe mn mo mp mq b">Dockerfile</code>创建图像的另一个好处是，它是一层一层堆叠的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/c227dc3dd26dadb0fc8c8d80e18d76bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*ws9lG0sLnYWFEeOTmKaoTA.png"/></div></figure><p id="60a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要查看堆栈，下面是一个可以帮助您可视化的工具。</p><div class="nv nw gp gr nx ny"><a href="https://github.com/wagoodman/dive" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jd gy z fp od fr fs oe fu fw jc bi translated">瓦格德曼/潜水</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">一个探索docker图像、图层内容和发现缩小Docker/OCI图像大小的方法的工具。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="qa l oj ok ol oh om lb ny"/></div></div></a></div><h2 id="f5a8" class="oo mz it bd na op oq dn ne or os dp ni lr ot ou nk lv ov ow nm lz ox oy no iz bi translated">超越创造形象</h2><p id="4201" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">创建图像后，您可能希望将您的图像发布到一个中心位置，例如DockerHub，以便全球访问，或者您希望将您的应用程序作为一个web服务来运行，并通过一个端口来访问它……您可以这样做。</p><p id="9036" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的教程应该有助于你继续在Docker中探索这个非常基础的东西。</p><div class="nv nw gp gr nx ny"><a href="https://docker-curriculum.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jd gy z fp od fr fs oe fu fw jc bi translated">面向初学者的Docker教程</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">学习使用Docker轻松构建和部署您的分布式应用程序到云中，Docker由…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">docker-curriculum.com</p></div></div><div class="oh l"><div class="qb l oj ok ol oh om lb ny"/></div></div></a></div><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qc qd l"/></div></figure></div></div>    
</body>
</html>