<html>
<head>
<title>Python — Object-Oriented Programming Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python——面向对象编程概述</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-object-oriented-programming-overview-f19f46eced85?source=collection_archive---------22-----------------------#2021-01-17">https://levelup.gitconnected.com/python-object-oriented-programming-overview-f19f46eced85?source=collection_archive---------22-----------------------#2021-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="69fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我对Python面向对象能力的笔记</h2></div><p id="f42e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你知道吗，父母更愿意让他们的孩子学习Python而不是法语？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/8a4ab2fa2a1a35f4f187b5d444b6a14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j8R7S3v3euepcSE0"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lv" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>拍摄的照片</figcaption></figure><p id="d28b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是Ocado Technology 不久前在英国进行的一项研究得出的结论。根据他们的说法，60%的父母宁愿让他们的孩子学习Python而不是法语。很有趣，不是吗？😉</p><p id="7806" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到这一点以及我手中的一些空闲时间，我决定尝试一下Python，并从面向对象的角度重新审视该语言的基本关键特性。</p><p id="e1e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从一个有趣的问题开始…</p><h1 id="f44d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Python是面向对象的吗？</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mo"><img src="../Images/bed06e799c2e255e408e02887c0a48cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjzRVOyNL_AP_ZfRT0OfOw.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://www.pexels.com/@divinetechygirl?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜·莫里洛</a>从<a class="ae lv" href="https://www.pexels.com/photo/python-book-1181671/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</figcaption></figure><p id="d223" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些作者会说Python可以被认为是一种基于对象的语言，而不是真正的面向对象的语言。<em class="le"> </em> 主要是因为在Python中一切都是对象，但面向对象编程本身只是语言中的一个可选特性，与Java等语言相反。</p><p id="27c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这个角度来看，人们也可以说Python是一种多范例语言，完全支持<strong class="kk iu">面向对象编程</strong>、<strong class="kk iu">结构化编程</strong>，以及对<strong class="kk iu">函数式编程</strong>的一些支持。</p><p id="4258" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来让我们仔细看看Python是如何实现关键的O.O .概念的:</p><h1 id="6404" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">目标</h1><p id="df00" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">对象是面向对象编程的主要明星，旨在通过将数据和行为封装在单个实体中来表示现实世界的元素。如果你问我的话，这是一个非常重要的角色！</p><p id="42fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，<strong class="kk iu">一切</strong>都是对象。这包括任何东西，甚至数字、字符串、函数和模块。因此一切都可以分配给一个<strong class="kk iu">变量</strong>。</p><p id="4ff7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Python，我们从<strong class="kk iu">类</strong>规范中创建对象。</p><h1 id="dca3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">班级</h1><p id="5706" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">类是用于创建对象的蓝图。它们定义了一个对象可以<strong class="kk iu">拥有</strong> <em class="le">的状态——数据——</em><strong class="kk iu"/>以及一个对象可以<strong class="kk iu">做什么</strong><em class="le">——行为</em>。</p><p id="0f74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果机器人是对象，那么机器人类就是它的蓝图。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">类别定义示例</figcaption></figure><p id="7999" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当需要或请求一个新对象时，Python程序将从其蓝图中构造这些对象。构造的对象将包含所有指定的函数和属性。</p><h1 id="c240" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">方法</h1><p id="5887" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">方法指定对象可以做什么。在Python中，我们使用<strong class="kk iu"> <em class="le"> def </em> </strong>关键字定义方法——就像函数一样，但是方法包含在类中。在我们前面的例子中，<strong class="kk iu"> <em class="le"> sayHello </em> </strong>是一个方法定义。</p><p id="55fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有方法都必须将<strong class="kk iu"> <em class="le"> self </em> </strong>作为它们的第一个参数。</p><h1 id="aeb7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">自己</h1><p id="3d2e" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Python程序中作为方法中第一个参数的<strong class="kk iu"> <em class="le"> self </em> </strong>参数，指的是类本身的实例。</p><p id="674d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的是，<strong class="kk iu"> <em class="le"> self </em> </strong>只是一个变量名，与C++、C#、Java等语言的<em class="le"/>关键字不同，<strong class="kk iu"><em class="le">self</em></strong>可以根据需要进行更改，尽管<strong class="kk iu">不鼓励这样做。</strong></p><p id="1ab8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，最被接受的惯例是总是使用<strong class="kk iu"> <em class="le">自我</em> </strong>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">方法接收<strong class="ak">自身</strong>和<strong class="ak">人员名称</strong>参数</figcaption></figure><h1 id="0649" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">构造器</h1><p id="f688" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Python使用<strong class="kk iu"> <em class="le"> __init__ </em> </strong>方法来构造一个处于<strong class="kk iu">预定义初始状态</strong>的对象。<strong class="kk iu"> <em class="le"> __init__ </em> </strong>方法是一个<strong class="kk iu">构造函数</strong>方法，一旦对象被实例化就会被执行。</p><p id="7550" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与任何其他方法一样，对正在构造的实例的引用作为第一个参数传递。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">使用<strong class="ak">构造函数</strong>的类定义</figcaption></figure><h1 id="ed53" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">包装</h1><p id="9c67" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Python主要用于将行为和数据捆绑和封装在一起，防止外部代理无意中造成副作用，它主要为我们提供了3个级别的封装和一些注意事项:</p><ul class=""><li id="69d8" class="mw mx it kk b kl km ko kp kr my kv mz kz na ld nb nc nd ne bi translated"><strong class="kk iu">私有</strong>:方法和变量以双下划线<em class="le"> </em> <strong class="kk iu"> __ </strong>为前缀</li><li id="b503" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><strong class="kk iu">受保护的</strong>:方法和变量以单下划线<em class="le"> </em> <strong class="kk iu"> _ </strong>为前缀</li><li id="9be5" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">公共的:其他的一切</li></ul><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">两个封装字段:<strong class="ak">_ _名称</strong>和<strong class="ak"> __isEnabled </strong></figcaption></figure><p id="61e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上例中，<strong class="kk iu"> <em class="le"> __name </em> </strong>和<em class="le"> __isEnabled </em> 都是<strong class="kk iu"> private* </strong>变量。</p><p id="dcfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> * </strong>关于封装，Python只是隐藏了被封装的成员，但是仍然可以使用类的父类名+字段名来访问该成员。按照我们的例子，那将是<strong class="kk iu"><em class="le">_机器人_ _名字** </em> </strong>。</p><p id="1a45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python从未真正限制对受保护的成员的访问。因此，在Python中没有什么是真正私有的。</p><p id="fe6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">* *上面的黑客很有趣，但是，现在你必须保证永远不会在任何产品代码中使用它！😁</p><p id="c34f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">* * *说真的，永远不要用它…</p><h1 id="7797" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">性能</h1><p id="9593" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">如果需要访问内部成员以向外界公开内部字段，那么可以而且应该使用属性。</p><p id="a998" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，属性是通过属性的用法来定义的:<strong class="kk iu"> <em class="le">、@property </em> </strong>、<strong class="kk iu"> <em class="le">、@setter </em> </strong>和<strong class="kk iu"> <em class="le">、@deleter: </em> </strong></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">使用<strong class="ak">属性</strong>作为私有字段的访问器</figcaption></figure><h1 id="c155" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">遗产</h1><p id="f889" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Python继承将允许我们从父类中派生出类— <em class="le">又名:基类</em>。</p><p id="71a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要从基类创建子类，子类必须在其声明名称前包含一组括号，指定其父基类:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">带有<strong class="ak">机器人基类</strong>的<strong class="ak">飞行机器人</strong>的虚拟例子</figcaption></figure><p id="1eb5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">子类将可以访问基类的所有实例变量和方法，<strong class="kk iu">包括</strong>私有和受保护的方法。</p><h1 id="dd26" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">接口</h1><p id="43ce" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">一个接口定义了一个对象必须拥有的所有方法，不管它的真实类型是什么。该接口将定义应该由其子类型实现的抽象方法。</p><p id="b02f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里重要的是:</p><ul class=""><li id="381b" class="mw mx it kk b kl km ko kp kr my kv mz kz na ld nb nc nd ne bi translated">Python为我们提供了两种不同的接口定义方式:非正式接口和正式接口</li><li id="cdb2" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">Python不包含<code class="fe nk nl nm nn b">interface</code>关键字(…我看着你们这些Java和C#的乡亲们！)</li></ul><h2 id="5c6f" class="no lx it bd ly np nq dn mc nr ns dp mg kr nt nu mi kv nv nw mk kz nx ny mm nz bi translated">非正式界面</h2><p id="3f42" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">非正式接口是一个Python类，它定义了应该被它的子类覆盖的方法，但是这种覆盖不是必须的。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">非正式界面</figcaption></figure><h2 id="2f06" class="no lx it bd ly np nq dn mc nr ns dp mg kr nt nu mi kv nv nw mk kz nx ny mm nz bi translated">正式接口——又名:抽象基类(ABC)</h2><p id="2432" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">正式接口是强制实现的接口。这些是通过使用<code class="fe nk nl nm nn b">abc</code> Python模块创建的:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">与ABC的正式接口</figcaption></figure><h1 id="ec2a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">静态方法</h1><p id="8df6" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">静态方法是不绑定到对象，而是绑定到类的方法。因此不强制要求为了执行它们而需要创建对象。</p><p id="4c99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义静态方法时，使用属性<strong class="kk iu"> <em class="le"> @staticmethod </em> </strong>:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">静态方法<strong class="ak">版本()</strong></figcaption></figure></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="8a28" class="lw lx it bd ly lz oh mb mc md oi mf mg jz oj ka mi kc ok kd mk kf ol kg mm mn bi translated">最后的想法</h1><p id="5dd0" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">花时间去理解像面向对象这样一个已知的概念是如何在Python中使用的，以及围绕它的语言的思维模式，对我来说是非常有启发性和令人满意的。</p><p id="dbf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事实证明，Python是一种简单的语言，不需要太多的设置就可以开始编码，语法简单明了，看起来非常像简单明了的英语。毫不奇怪，这种语言在脚本、自动化，包括最近的科学领域，如数据分析、人工智能，以及有时替代MATLAB和r。</p><p id="c8b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到那些宁愿让他们的孩子学习Python而不是法语的父母(…我自己也尝试过法语，但放弃了太多次😉)，他们可能终究有道理。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="1a04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于Python的<strong class="kk iu"> <em class="le">面向对象的</em> </strong>能力，它们似乎符合语言的动态本质。提供了大部分核心概念，而没有对编码人员的能力做太多限制。</p><p id="0f59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从该语言处理私有字段和封装的方式也可以看出这一点。并不是真的阻止我们访问私有字段和信息，而是把它们放在一边或者隐藏起来。C++和Java之类的语言没有这种思维模式。</p><p id="d8a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用我在Python邮件列表上找到的一句话简单地说…</p><blockquote class="om"><p id="c9f3" class="on oo it bd op oq or os ot ou ov ld dk translated">“…我们都是自愿的成年人…”—<a class="ae lv" href="https://mail.python.org/pipermail/tutor/2003-October/025932.html" rel="noopener ugc nofollow" target="_blank">Python邮件</a></p></blockquote><h1 id="9b63" class="lw lx it bd ly lz ma mb mc md me mf mg jz ow ka mi kc ox kd mk kf oy kg mm mn bi translated">其他资源</h1><ul class=""><li id="fc1a" class="mw mx it kk b kl mp ko mq kr oz kv pa kz pb ld nb nc nd ne bi translated"><a class="ae lv" href="https://docs.python.org/3/" rel="noopener ugc nofollow" target="_blank"> Python文档</a></li><li id="bf26" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae lv" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python下载</a></li><li id="2847" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae lv" href="https://mail.python.org/pipermail/tutor/2003-October/025932.html" rel="noopener ugc nofollow" target="_blank">什么是Pythonic？</a></li></ul></div></div>    
</body>
</html>