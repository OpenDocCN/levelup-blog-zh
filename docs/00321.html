<html>
<head>
<title>9 Tricks for Kickass JavaScript Developers in 2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2019年Kickass JavaScript开发者的9招</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/9-tricks-for-kickass-javascript-developers-in-2019-eb01dd3def2a?source=collection_archive---------0-----------------------#2019-01-07">https://levelup.gitconnected.com/9-tricks-for-kickass-javascript-developers-in-2019-eb01dd3def2a?source=collection_archive---------0-----------------------#2019-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9b6be81abc7b2c4c367c6f3195723145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acZ1mwCJ_jA17TWZUvIZeA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安德鲁·沃利在<a class="ae kc" href="https://unsplash.com/search/photos/nerd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a7ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">又一年过去了，JavaScript一直在变化。然而，有一些技巧可以帮助你编写干净有效的代码，甚至(或者可能特别？)2019年。下面列出了9个实用的技巧，可以让你成为更好的开发者。</p><h1 id="9802" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">1.异步/等待</h1><p id="7e42" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">如果你仍然被困在回调地狱，2014年想要回它的代码。只是不要使用回调，除非它是绝对必要的，例如库所要求的或者性能原因。承诺是好的，但是如果你的代码库变大了，使用起来就有点尴尬了。我现在最常用的解决方案是async / await，这使得阅读和改进我的代码更加简洁。事实上，你可以在JavaScript中<code class="fe mn mo mp mq b">await</code>每一个承诺，如果你正在使用的库返回一个承诺，只需<code class="fe mn mo mp mq b">await</code>它。事实上，async/await只是承诺的语法糖。为了让你的代码工作，你只需要在一个函数前面加上<code class="fe mn mo mp mq b">async</code>关键字。这里有一个简单的例子:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="64fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意顶层的<code class="fe mn mo mp mq b">await</code>是不可能的，你只能调用一个<code class="fe mn mo mp mq b">async</code>函数。</p><p id="9247" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx"> async / await是ES2017中引入的，所以请确保传输您的代码。</em></p><h1 id="d1e0" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">2.异步控制流</h1><p id="12cb" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">通常，在所有异步调用都返回值之后，有必要获取多个数据集，并为每个数据集做一些事情，或者完成一个任务。</p><h2 id="9292" class="my ll iq bd lm mz na dn lq nb nc dp lu ko nd ne ly ks nf ng mc kw nh ni mg nj bi translated">为了…的</h2><p id="df95" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">假设我们的页面上有几个口袋妖怪，我们必须获取它们的详细信息。我们不希望等待所有的调用都结束，尤其是当我们不知道有多少个调用时，但是我们希望在得到一些回报时立即更新我们的数据集。我们可以使用<code class="fe mn mo mp mq b">for...of</code>循环遍历一个数组，并在块内执行<code class="fe mn mo mp mq b">async</code>代码，执行将被暂停，直到每个调用成功。需要注意的是，如果您在代码中做了类似的事情，可能会出现性能瓶颈，但是将其保留在工具集中是非常有用的。这里有一个例子:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="nk nl nm"><p id="5160" class="kd ke mx kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated">这些例子实际上是可行的，请随意复制并粘贴到您最喜欢的代码沙箱中</p></blockquote><h2 id="94d4" class="my ll iq bd lm mz na dn lq nb nc dp lu ko nd ne ly ks nf ng mc kw nh ni mg nj bi translated">承诺。所有</h2><p id="6adc" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">如果你想并行获取所有的口袋妖怪呢？因为你可以<code class="fe mn mo mp mq b">await</code>所有的承诺，简单地使用<code class="fe mn mo mp mq b">Promise.all</code>:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8f78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b"><em class="mx">for...of</em></code> <em class="mx">和</em> <code class="fe mn mo mp mq b"><em class="mx">Promise.all</em></code> <em class="mx">是在ES6+中引入的，所以一定要移植你的代码。</em></p><h1 id="099c" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">3.析构&amp;默认值</h1><p id="5eb1" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">让我们回到上一个示例，执行以下操作:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="9734" class="my ll iq mq b gy nu nv l nw nx">const result = axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/${entry.id}`)</span><span id="5473" class="my ll iq mq b gy ny nv l nw nx">const data = result.data</span></pre><p id="1d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一种更简单的方法，我们可以使用析构来从一个对象或数组中取出一个或几个值。我们会这样做:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="6357" class="my ll iq mq b gy nu nv l nw nx">const { data } = await axios.get(...)</span></pre><p id="1486" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们保存了一行代码！耶！您也可以重命名变量:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="5f38" class="my ll iq mq b gy nu nv l nw nx">const { data: newData } = await axios.get(...)</span></pre><p id="c6a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个好的技巧是在析构时给出默认值。这确保了你永远不会以<code class="fe mn mo mp mq b">undefined</code>结束，你也不必手动检查变量。</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="7c59" class="my ll iq mq b gy nu nv l nw nx">const { id = 5 } = {}</span><span id="7407" class="my ll iq mq b gy ny nv l nw nx">console.log(id) // 5</span></pre><p id="b609" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些技巧也可以用于函数参数，例如:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e848" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子一开始可能看起来有点混乱，但是不要着急，慢慢来。当我们没有将任何值作为参数传递给函数时，将使用默认值。一旦我们开始传递值，就只使用不存在的参数的默认值。</p><p id="3040" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">ES6引入了析构和缺省值，所以一定要转换你的代码。</em></p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="0329" class="lk ll iq bd lm ln og lp lq lr oh lt lu lv oi lx ly lz oj mb mc md ok mf mg mh bi translated">4.真假价值观</h1><p id="a12e" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">使用默认值时，对现有值的一些检查将成为过去。然而，很高兴知道你可以用真值和假值工作。这将改进您的代码，并为您节省一些指令，使它更有说服力。我经常看到人们做这样的事情:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="eb71" class="my ll iq mq b gy nu nv l nw nx">if(myBool === true) {<br/>  console.log(...)<br/>}</span><span id="2e11" class="my ll iq mq b gy ny nv l nw nx">// OR</span><span id="daeb" class="my ll iq mq b gy ny nv l nw nx">if(myString.length &gt; 0) {<br/>  console.log(...)<br/>}</span><span id="2589" class="my ll iq mq b gy ny nv l nw nx">// OR</span><span id="2c86" class="my ll iq mq b gy ny nv l nw nx">if(isNaN(myNumber)) {<br/>  console.log(...)<br/>}</span></pre><p id="7377" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些都可以简化为:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="0b89" class="my ll iq mq b gy nu nv l nw nx">if(myBool) {<br/>  console.log(...)<br/>}</span><span id="9dac" class="my ll iq mq b gy ny nv l nw nx">// OR</span><span id="2bd3" class="my ll iq mq b gy ny nv l nw nx">if(myString) {<br/>  console.log(...)<br/>}</span><span id="9c7e" class="my ll iq mq b gy ny nv l nw nx">// OR</span><span id="1f4a" class="my ll iq mq b gy ny nv l nw nx">if(!myNumber) {<br/>  console.log(...)<br/>}</span></pre><p id="3d16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要真正利用这些陈述，你必须理解什么是真值和假值。这里有一个小的概述:</p><h2 id="6fc4" class="my ll iq bd lm mz na dn lq nb nc dp lu ko nd ne ly ks nf ng mc kw nh ni mg nj bi translated">福尔西</h2><ul class=""><li id="5331" class="ol om iq kf b kg mi kk mj ko on ks oo kw op la oq or os ot bi translated">长度为0的字符串</li><li id="d234" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la oq or os ot bi translated">数量<code class="fe mn mo mp mq b">0</code></li><li id="c4f3" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la oq or os ot bi translated"><code class="fe mn mo mp mq b">false</code></li><li id="41ad" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la oq or os ot bi translated"><code class="fe mn mo mp mq b">undefined</code></li><li id="1b0e" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la oq or os ot bi translated"><code class="fe mn mo mp mq b">null</code></li><li id="4775" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la oq or os ot bi translated"><code class="fe mn mo mp mq b">NaN</code></li></ul><h2 id="fd65" class="my ll iq bd lm mz na dn lq nb nc dp lu ko nd ne ly ks nf ng mc kw nh ni mg nj bi translated">真理</h2><ul class=""><li id="b7e4" class="ol om iq kf b kg mi kk mj ko on ks oo kw op la oq or os ot bi translated">空数组</li><li id="3391" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la oq or os ot bi translated">空对象</li><li id="803a" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la oq or os ot bi translated">其他一切</li></ul><p id="ef54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，当检查true/falsy值时，没有明确的比较，这相当于用两个等号<code class="fe mn mo mp mq b">==</code>而不是三个<code class="fe mn mo mp mq b">===</code>进行检查。一般来说，它的行为是一样的，但是在某些情况下，你会遇到一个bug。对我来说，它大多发生在数字<code class="fe mn mo mp mq b">0</code>上。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/080dbc029f2895452721126be7fffed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vD67FQ8g5cwQ_HR0MDZZ5A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">菲利普·莱昂在<a class="ae kc" href="https://unsplash.com/search/photos/contrast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="dfc8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">5.逻辑和三元运算符</h1><p id="cd3a" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这些都是用来缩短你的代码，节省你宝贵的代码行。通常它们是很好的工具，有助于保持代码的整洁，但是它们也会造成一些混乱，尤其是在链接它们的时候。</p><h2 id="d3fa" class="my ll iq bd lm mz na dn lq nb nc dp lu ko nd ne ly ks nf ng mc kw nh ni mg nj bi translated">逻辑运算符</h2><p id="4915" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">逻辑运算符基本上组合了两个表达式，将返回<code class="fe mn mo mp mq b">true</code>、<code class="fe mn mo mp mq b">false</code>或匹配值，并由表示“与”的<code class="fe mn mo mp mq b">&amp;&amp;</code>和表示“或”的<code class="fe mn mo mp mq b">||</code>表示。让我们来看看:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="2b0f" class="my ll iq mq b gy nu nv l nw nx">console.log(true &amp;&amp; true) // true</span><span id="f8b4" class="my ll iq mq b gy ny nv l nw nx">console.log(false &amp;&amp; true) // false</span><span id="8dd1" class="my ll iq mq b gy ny nv l nw nx">console.log(true &amp;&amp; false) // false</span><span id="59a9" class="my ll iq mq b gy ny nv l nw nx">console.log(false &amp;&amp; false) // false</span><span id="6dac" class="my ll iq mq b gy ny nv l nw nx">console.log(true || true) // true</span><span id="8ae8" class="my ll iq mq b gy ny nv l nw nx">console.log(true || false) // true</span><span id="52f7" class="my ll iq mq b gy ny nv l nw nx">console.log(false || true) // true</span><span id="5f45" class="my ll iq mq b gy ny nv l nw nx">console.log(false || false) // false</span></pre><p id="8472" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将逻辑运算符与我们从最后一点，truthy和falsy值中获得的知识结合起来。使用逻辑运算符时，以下规则适用:</p><ul class=""><li id="52eb" class="ol om iq kf b kg kh kk kl ko pa ks pb kw pc la oq or os ot bi translated"><code class="fe mn mo mp mq b">&amp;&amp;</code>:返回第一个falsy值，如果没有，则返回最后一个true值。</li><li id="0e72" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la oq or os ot bi translated"><code class="fe mn mo mp mq b">||</code>:返回第一个真值，如果没有，则等于最后一个假值。</li></ul><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="5adc" class="my ll iq mq b gy nu nv l nw nx">console.log(0 &amp;&amp; {a: 1}) // 0</span><span id="358c" class="my ll iq mq b gy ny nv l nw nx">console.log(false &amp;&amp; 'a') // false</span><span id="1655" class="my ll iq mq b gy ny nv l nw nx">console.log('2' &amp;&amp; 5) // 5</span><span id="ff06" class="my ll iq mq b gy ny nv l nw nx">console.log([] || false) // []</span><span id="46a6" class="my ll iq mq b gy ny nv l nw nx">console.log(NaN || null) // null</span><span id="2b25" class="my ll iq mq b gy ny nv l nw nx">console.log(true || 'a') // true</span></pre><h2 id="ad39" class="my ll iq bd lm mz na dn lq nb nc dp lu ko nd ne ly ks nf ng mc kw nh ni mg nj bi translated">三元运算符</h2><p id="68b9" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">三元运算符非常类似于逻辑运算符，但有三个部分:</p><ol class=""><li id="d957" class="ol om iq kf b kg kh kk kl ko pa ks pb kw pc la pd or os ot bi translated">这种比较要么是虚假的，要么是真实的</li><li id="25f4" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la pd or os ot bi translated">第一个返回值，以防比较结果为真</li><li id="b4e3" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la pd or os ot bi translated">第二个返回值，以防比较结果为假</li></ol><p id="3bad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个例子:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="1ee4" class="my ll iq mq b gy nu nv l nw nx">const lang = 'German'</span><span id="d355" class="my ll iq mq b gy ny nv l nw nx">console.log(lang === 'German' ? 'Hallo' : 'Hello') // Hallo</span><span id="f37b" class="my ll iq mq b gy ny nv l nw nx">console.log(lang ? 'Ja' : 'Yes') // Ja</span><span id="049f" class="my ll iq mq b gy ny nv l nw nx">console.log(lang === 'French' ? 'Bon soir' : 'Good evening') // Good evening</span></pre><h1 id="9e49" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">6.可选链接</h1><p id="327f" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">您是否遇到过这样的问题:在不知道对象或子属性是否存在的情况下，访问嵌套的对象属性？您可能会得到这样的结果:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="250f" class="my ll iq mq b gy nu nv l nw nx">let data<br/>if(myObj &amp;&amp; myObj.firstProp &amp;&amp; myObj.firstProp.secondProp &amp;&amp; myObj.firstProp.secondProp.actualData) data = myObj.firstProp.secondProp.actualData</span></pre><p id="c547" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很繁琐，有一个更好的方法，至少是一个建议的方法(继续阅读如何启用它)。它被称为可选链接，工作方式如下:</p><pre class="mr ms mt mu gt nq mq nr ns aw nt bi"><span id="e246" class="my ll iq mq b gy nu nv l nw nx">const data = myObj?.firstProp?.secondProp?.actualData</span></pre><p id="ba3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这是检查嵌套属性的一种很好的方式，并且使代码更干净。</p><p id="4815" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">目前，可选链接不是官方规范的一部分，而是作为一项实验性功能处于第一阶段。你得在你的babelrc中添加</em><a class="ae kc" href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank"><em class="mx">@ babel/plugin-proposal-optional-chaining</em></a><em class="mx">才能使用。</em></p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="8c30" class="lk ll iq bd lm ln og lp lq lr oh lt lu lv oi lx ly lz oj mb mc md ok mf mg mh bi translated">7.类属性和绑定</h1><p id="c925" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在JavaScript中绑定函数是一项常见的任务。随着ES6规范中箭头函数的引入，我们现在有了一种自动将函数绑定到声明上下文的方法——非常有用，并且在JavaScript开发人员中普遍使用。当类第一次被引入时，你不能再真正使用箭头函数，因为类方法必须以特定的方式声明。我们需要在其他地方绑定函数，例如在构造函数中(React.js的最佳实践)。我总是被先定义类方法，然后绑定它们的工作流所困扰，过一段时间后，这看起来很可笑。使用class property语法，我们可以再次使用箭头函数，并获得自动绑定的优势。箭头函数现在可以在类内部使用。下面是一个绑定了<code class="fe mn mo mp mq b">_increaseCount</code>的例子:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c482" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，职业属性并不是官方规范的一部分，而是作为一个实验性的特性处于第三阶段。你得在你的babelrc中添加<a class="ae kc" href="https://babeljs.io/docs/en/next/babel-plugin-proposal-class-properties.html" rel="noopener ugc nofollow" target="_blank"><em class="mx">【babel/plugin-proposal-class-properties</em></a><em class="mx">才能使用。</em></p><h1 id="b933" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">8.使用包裹</h1><p id="b651" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">作为一名前端开发人员，您几乎肯定遇到过捆绑和传输代码。很长一段时间以来，事实上的标准是webpack。我第一次使用webpack是在版本1中，那时候很痛苦。摆弄所有不同的配置选项，我花了无数个小时试图让捆绑运行起来。如果我能做到的话，为了不打碎任何东西，我不会再碰它了。几个月前，我偶然发现了<a class="ae kc" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">包裹</a>，这让我立即松了一口气。它几乎为你做了开箱即用的所有事情，同时如果有必要的话，你还可以改变它。它还支持一个插件系统，类似于webpack或babel，速度非常快。如果你不知道包裹，我绝对建议你去看看！</p><h1 id="4948" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">9.自己多写代码</h1><p id="9e1d" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这是一个很好的话题。对此我有过很多不同的讨论。即使对于CSS，很多人倾向于使用像bootstrap这样的组件库。对于JavaScript，我仍然看到有人使用jQuery和小型库进行验证、滑动条等等。虽然使用库是有意义的，但我强烈建议自己编写更多的代码，而不是盲目安装npm包。当有大型库(甚至框架)时，整个团队都在构建它，例如<a class="ae kc" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> moment.js </a>或<a class="ae kc" href="https://reactdatepicker.com/" rel="noopener ugc nofollow" target="_blank"> react-datepicker </a>，尝试自己编码是没有意义的。但是，您可以自己编写正在使用的大部分代码。这将给你带来三大优势:</p><ol class=""><li id="3a77" class="ol om iq kf b kg kh kk kl ko pa ks pb kw pc la pd or os ot bi translated">您确切地知道代码中发生了什么</li><li id="3b4f" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la pd or os ot bi translated">在某个时候，你会开始真正理解<strong class="kf ir"/><strong class="kf ir"/>编程以及幕后的工作原理</li><li id="030f" class="ol om iq kf b kg ou kk ov ko ow ks ox kw oy la pd or os ot bi translated">您可以防止代码库变得臃肿</li></ol><p id="3bd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一开始，使用npm包更容易。自己实现某些功能需要更多的时间。但是如果这个包不能像预期的那样工作，你不得不换另一个包，花更多的时间阅读他们的API是如何设置的，那该怎么办呢？当你自己实现它时，你可以根据你的用例百分之百地定制它。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="2542" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">关于作者:Lukas Gisder-Dubé作为CTO共同创立并领导了一家初创公司1年半，建立了技术团队和架构。离开创业公司后，他在</em><a class="pe pf ep" href="https://medium.com/u/1ff093a3da32?source=post_page-----eb01dd3def2a--------------------------------" rel="noopener" target="_blank"><em class="mx">iron hack</em></a><em class="mx">担任首席讲师教授编码，现在正在柏林建立一家创业机构&amp;咨询公司。查看</em><a class="ae kc" href="https://dube.io" rel="noopener ugc nofollow" target="_blank"><em class="mx">Dube . io</em></a><em class="mx">了解更多。</em></p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/840b0ca008c4fa8e0a1d00791a6c9f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*p-l0Cee1IHvX0RQkVTOceQ.png"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><figure class="mr ms mt mu gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi ph"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="pi pj gp gr pk pl"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd ir gy z fp pq fr fs pr fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">排名前64的JavaScript教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">gitconnected.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz jw pl"/></div></div></a></div></div></div>    
</body>
</html>