<html>
<head>
<title>Minimum Operations to Make Array Equal: Understanding the Thought Process for Interviews and Leetcoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使数组相等的最小运算:理解面试和Leetcoding的思维过程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/minimum-operations-to-make-array-equal-understanding-the-thought-process-for-interviews-5dd15d7390e7?source=collection_archive---------6-----------------------#2021-04-07">https://levelup.gitconnected.com/minimum-operations-to-make-array-equal-understanding-the-thought-process-for-interviews-5dd15d7390e7?source=collection_archive---------6-----------------------#2021-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cf4342c7d94b2fcf0ee3b7a9c9fe6912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rLFIeRPh-O2jKIIE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@cytonn_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cytonn摄影</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a986" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个标准的算法问题，被证实在许多技术访谈中被问过。<a class="ae kc" href="https://leetcode.com/problems/minimum-operations-to-make-array-equal/#:~:text=Minimum%20Operations%20to%20Make%20Array%20Equal%20%2D%20LeetCode&amp;text=You%20have%20an%20array%20arr,arr%5By%5D%20%2B%3D%201%20)" rel="noopener ugc nofollow" target="_blank">这个问题出现在2021年4月Leetcode月度挑战赛</a>中，难度为<strong class="kf ir">中等</strong>。无论你是在准备技术面试，还是像我一样只是一个算法爱好者，我都坚信这篇文章会很有意思。</p><p id="28b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">问题陈述</strong> <br/>你有一个长度为<code class="fe lb lc ld le b">n</code>的数组<code class="fe lb lc ld le b">arr</code>，其中<code class="fe lb lc ld le b">arr[i] = (2 * i) + 1</code>为<code class="fe lb lc ld le b">i</code>(即<code class="fe lb lc ld le b">0 &lt;= i &lt; n</code>的所有有效值。<br/>在一次操作中，您可以选择两个指标<code class="fe lb lc ld le b">x</code>和<code class="fe lb lc ld le b">y</code>，其中<code class="fe lb lc ld le b">0 &lt;= x, y &lt; n</code>从<code class="fe lb lc ld le b">arr[x]</code>中减去<code class="fe lb lc ld le b">1</code>并将<code class="fe lb lc ld le b">1</code>加到<code class="fe lb lc ld le b">arr[y]</code>(即执行<code class="fe lb lc ld le b">arr[x] -=1 </code>和<code class="fe lb lc ld le b">arr[y] += 1</code>)。目标是使数组<strong class="kf ir">的所有元素都等于</strong>。保证使用一些操作可以使数组的所有元素相等。</p><p id="51ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定一个整数<code class="fe lb lc ld le b"><strong class="kf ir">n</strong></code>、<strong class="kf ir">、</strong>数组的长度。Return <em class="lf">使arr的所有元素相等所需的最小操作数</em>。</p><p id="78be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">例</strong> <br/> <strong class="kf ir">输入:</strong> n = 3 <br/> <strong class="kf ir">输出:</strong> 2 <br/> <strong class="kf ir">解释:</strong> arr = [1，3，5] <br/>第一次运算选择x = 2，y = 0，这就导致arr为[2，3，4] <br/>第二次运算再次选择x = 2，y = 0，于是arr = [3，3，3]。</p><p id="f2a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">解决方案</strong> <br/>在面试中面对这类问题时，你的第一步会是什么？给定这样一个数组，<br/> <strong class="kf ir"> 1 </strong>)如何求<strong class="kf ir">目标数</strong>，即所有其他元素应该等于的数？<br/></p><p id="8d90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">识别模式:强力 <br/>解决任何对你来说是新的算法问题的第一步，也是最好的一步，就是总是尝试使用少量的测试用例来观察一些常见的模式。<br/>现在，我们将通过考虑每个数组中元素对的所有可能排列来研究两个测试数组。这样，每个排列中的第一对将用于生成<strong class="kf ir">目标数</strong>，我们将尝试将排列中的其他对减少到生成的目标数<strong class="kf ir">。</strong></p><p id="98f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">测试1 </strong>:当<code class="fe lb lc ld le b"><strong class="kf ir">n</strong></code>为偶数时。设<code class="fe lb lc ld le b">n = 4</code>、<code class="fe lb lc ld le b">arr=[1,3,5,7]</code>、<br/>对于这个数组有<code class="fe lb lc ld le b">6 </code>个不同的排列对。<br/> {1，3}，{5，7} <br/> {1，5}，{3，7} <br/> {1，7}，{3，5} <br/> {3，5}，{1，7} <br/> {5，7}，{1，3}</p><p id="7ecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> i. </strong> <code class="fe lb lc ld le b">{1,3}</code>在<code class="fe lb lc ld le b">1</code>操作中还原为<code class="fe lb lc ld le b">{2,2}</code>。然后<strong class="kf ir">目标数</strong> = <code class="fe lb lc ld le b">2</code> <br/> <code class="fe lb lc ld le b">{5,7}</code> →无法将这一对的元素减少到<code class="fe lb lc ld le b">2</code>。</p><p id="3e23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">二。</strong> <code class="fe lb lc ld le b">{1,5}</code>在2次操作中减少为<code class="fe lb lc ld le b">{3,3}</code>。然后<strong class="kf ir">目标数</strong> = <code class="fe lb lc ld le b">3<br/></code> <code class="fe lb lc ld le b">{3,7}</code> →无法将<code class="fe lb lc ld le b">7</code>减少为<code class="fe lb lc ld le b">3</code>。</p><p id="1d49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> iii。</strong> <code class="fe lb lc ld le b">{1,7}</code>在<code class="fe lb lc ld le b">3</code>操作中还原为<code class="fe lb lc ld le b">{4,4}</code>。然后<strong class="kf ir">目标数</strong> =4 <br/> <code class="fe lb lc ld le b">{3,5}</code>在<code class="fe lb lc ld le b">1</code>操作中减少为<code class="fe lb lc ld le b">{4,4}</code>。<br/>因此，需要<code class="fe lb lc ld le b">4</code>操作将所有元素减少到<code class="fe lb lc ld le b">4</code>。</p><p id="0207" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">四。</strong> <code class="fe lb lc ld le b">{3,5}</code>在<code class="fe lb lc ld le b">1</code>操作中还原为<code class="fe lb lc ld le b">{4,4}</code>。然后<strong class="kf ir">目标数</strong> = <code class="fe lb lc ld le b">4</code> <br/> <code class="fe lb lc ld le b">{1,7}</code>在<code class="fe lb lc ld le b">3</code>操作中减少为<code class="fe lb lc ld le b">{4,4}</code>。<br/>因此，需要<code class="fe lb lc ld le b">4</code>操作将所有元素减少到<code class="fe lb lc ld le b">4</code>。</p><p id="ac3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> v </strong>。<code class="fe lb lc ld le b">{3,7}</code>在<code class="fe lb lc ld le b">2</code>操作中还原为<code class="fe lb lc ld le b">{5,5}</code>。然后<strong class="kf ir">目标号</strong> = <code class="fe lb lc ld le b">5</code> <br/> <code class="fe lb lc ld le b">{1,5}</code> →不能把<code class="fe lb lc ld le b">1</code>改成<code class="fe lb lc ld le b">5</code>。</p><p id="10ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">六</strong>。<code class="fe lb lc ld le b">{5,7}</code>在<code class="fe lb lc ld le b">1</code>操作中还原为<code class="fe lb lc ld le b">{6,6}</code>。那么目标数= <code class="fe lb lc ld le b">6</code> <br/> <code class="fe lb lc ld le b">{1,3}</code> →不可能把这一对的元素改成<code class="fe lb lc ld le b">6</code></p><p id="78f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我们发现了一个图案</strong> <br/>瞧！我们找到了我们要找的模式。<strong class="kf ir">步骤iii和iv </strong>给出所需的解决方案。请注意，步骤iii和iv是方向相反的相同过程。无论你采取哪种模式，都会给你一个解决方案。到第<strong class="kf ir"> iii </strong>步，下面是需要注意的要点:<br/>1)<strong class="kf ir">目标数</strong>是使两个中间元素相等所需的运算次数。那么当所有其他剩余的线对都减少到这个目标数时，就实现了最小操作。<br/> 2)一对由2个元素组成，它们与阵列的<strong class="kf ir">中心距离<strong class="kf ir">相同。见下图。<br/> 3)给定一对数组元素，比如{a，b}，使它们等于目标数所需的运算次数是该对中两个元素之间正差的一半，即<code class="fe lb lc ld le b">(b-a)/2 where b &gt; a</code>。<br/> 4)从下图来看，<code class="fe lb lc ld le b">arr[i]</code>与<code class="fe lb lc ld le b">arr[n-i-1]</code>形成一对。由于<code class="fe lb lc ld le b">arr[i]=(2*i)+1</code>和<code class="fe lb lc ld le b">arr[n-i-1] &gt; arr[i]</code>，将对<code class="fe lb lc ld le b">{arr[i], arr[n-i-1)}</code>减少到目标数所需的操作数计算如下</strong></strong></p><p id="17c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">=(arr[n-i-1]-arr[i])/2 <br/> = (2(n-i-1) — (2i +1))/2<br/> = n-2i-1 </code> <br/>由于有效对的总数总是等于数组大小的一半，即<code class="fe lb lc ld le b">n/2</code>，所以使一个<code class="fe lb lc ld le b">n</code>大小的数组的所有元素相等所需的最小操作总数是所有<code class="fe lb lc ld le b">n-2i-1</code>的总和，其中<code class="fe lb lc ld le b">i= 0,1,...,(n/2)-1</code>。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/79e75e2149bfa6cdf535ce899d5ecfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*XKRTE6ItXNG_oyn2Dorysg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">当<strong class="bd ll"> n </strong>为偶数时，需要最少运算次数才能使数组中所有元素相等的元素对</figcaption></figure><p id="dec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">测试2 </strong>:当<code class="fe lb lc ld le b"><strong class="kf ir">n</strong></code><strong class="kf ir">T22】为奇数时。例如让<code class="fe lb lc ld le b">n= 5</code>，然后<code class="fe lb lc ld le b">arr = [1,3,5,7,9]</code>。注意，在这种情况下，除了一个元素之外，所有元素都可以成对出现。这意味着，由于一个元素不可能有一对，这样的元素将作为<strong class="kf ir">目标数</strong>。问题是哪些元素可以作为目标数？事实证明，我们必须考虑所有可能的配对排列，将每个元素作为目标数。注意，每当一个元素被作为目标数时，剩下的四个元素只能形成三种不同的配对排列。例如，当目标数为<code class="fe lb lc ld le b">1</code>时，考虑以下几对:<code class="fe lb lc ld le b">{3,5},{7,9}</code>、<code class="fe lb lc ld le b">{3,7},{5,9}</code>、<code class="fe lb lc ld le b">{3,9},{7,5}</code>。</strong></p><p id="7390" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lf">注意</em> <code class="fe lb lc ld le b"><em class="lf">n</em></code> <em class="lf">为偶数时与之前排列的区别。目标数未知，因此配对排列的</em> <strong class="kf ir"> <em class="lf">顺序</em> </strong> <em class="lf">很重要，因为第一对总是用于生成目标数。</em></p><p id="6ada" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于每个<code class="fe lb lc ld le b">5</code>可能的目标号码，有<code class="fe lb lc ld le b">3</code>个可能的配对排列。这意味着有<code class="fe lb lc ld le b">5*3 = 15</code>安排要检查。这可能很耗时，而且在实际面试中容易出错。相反，我想应用我们在测试1中发现的相同步骤。由于有效的配对是围绕数组中心对称的，所以数组中心的元素将总是<strong class="kf ir">目标数</strong>。</p><p id="f6da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于当前数组<code class="fe lb lc ld le b">Target number = 5</code>，对<code class="fe lb lc ld le b">{3,7}</code>需要<code class="fe lb lc ld le b">2</code>操作来将其元素更改为<code class="fe lb lc ld le b">5</code>。此外，对<code class="fe lb lc ld le b">{1,9}</code>需要<code class="fe lb lc ld le b">4</code>操作来将其元素改变为<code class="fe lb lc ld le b">5</code>。如果您能够检查所有其他可能的安排，您将会注意到，将中间的元素作为目标数字将会给出最佳解决方案。因此，当<code class="fe lb lc ld le b">n</code>为奇数时，配对形式如下图所示。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/0cc58ad5fd65de445c5dc7b7421fedbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*L690_U0Tb-UM5ZIv-W3MSw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">当<strong class="bd ll"> n </strong>为奇数时，需要最少运算次数才能使数组中所有元素相等的元素对</figcaption></figure><p id="1219" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了有效的模式，我们就可以编写解决方案的第一个实现了。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Java实现</figcaption></figure><p id="7d21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">上述方法的分析</strong> <br/>上述方法的<strong class="kf ir">时间复杂度</strong>为<code class="fe lb lc ld le b"><strong class="kf ir">O(n</strong>)</code>。<strong class="kf ir">空间复杂度是常数</strong>，因为实际的数组从未被创建。我们能做得比这更好吗？</p><p id="5a63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">高效改进 <br/>令人惊讶的是，这个看起来很难的问题竟然被简化成了几行可以理解的代码。但是我们可以做得更多。这一次，我们更加关注每一步所需的<strong class="kf ir">操作数以及这些操作数遵循的模式</strong>。</p><p id="af83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1)当<code class="fe lb lc ld le b">n</code>为偶数时。如果取一个较大的偶数作为<code class="fe lb lc ld le b">n</code>，从<code class="fe lb lc ld le b">i=0,1,2,...,(n/2)-1</code>开始计算运算次数即<code class="fe lb lc ld le b">n-2i-1</code>，会得到如下数列<code class="fe lb lc ld le b">n-1, n-3, ..., 7, 5, 3, 1</code>。当系列反转时，您将获得<code class="fe lb lc ld le b">1, 3, 5, 7, ..., n-3, n-1</code>。如果你还记得数学课的话，这只是一个从<code class="fe lb lc ld le b">1</code>开始的奇数序列或者是一个有<code class="fe lb lc ld le b">first element = 1</code>和<code class="fe lb lc ld le b">common difference = 2</code>的算术序列。数列中元素的个数正好是<code class="fe lb lc ld le b">n/2</code>。所需的结果是这一系列的总和。利用含有<code class="fe lb lc ld le b">n</code>个元素<code class="fe lb lc ld le b">Sum of A.S = n(2a + (n-1)d)/2, where a= first element, d = common difference</code>的等差数列求和公式，我们可以通过在<code class="fe lb lc ld le b">Sum of A.S</code>公式中代入<code class="fe lb lc ld le b">n = n/2, a= 1, and d= 2</code>来计算最小运算次数。于是，<code class="fe lb lc ld le b">Result = (n/2)(2a + (n/2 — 1)d)/2</code>。再进一步简化，<code class="fe lb lc ld le b">Result = (n*n)/4</code>。</p><p id="ccd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2)当<code class="fe lb lc ld le b">n</code>为奇数时。使用与上述相同的方法，生成以下序列:<code class="fe lb lc ld le b">2, 4, 6, ..., n-3, n-1</code>。这是从<code class="fe lb lc ld le b">2</code>开始的偶数序列。它也是一个有<code class="fe lb lc ld le b">n/2</code>个元素的等差数列，其中<code class="fe lb lc ld le b">first number, a = 2, commonn difference, d = 2</code>。使用上面的<code class="fe lb lc ld le b">Sum of A.S</code>公式，使数组中所有元素相等所需的总运算次数也是<code class="fe lb lc ld le b">(n*n)/4. </code>下面是Java中的代码实现。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="88ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">分析</strong> <br/>这简直不可思议的惊人！。只有一行代码并且时间和空间复杂度都是常数。</p><p id="f493" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">结论</strong> <br/>如果你走到了这一步，功不可没！我相信你学到了一两个。每当你遇到不熟悉的问题时，永远记住寻找模式。<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/find-the-location-of-the-max-element-in-an-unsorted-array-using-binary-search-96b6d2c9a547">你还可以找到如何从一个没有排序的数组中找到一个元素</a>，或者<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/shortest-unsorted-continuous-subarray-b7401e839b7e">如何找到应该排序的最短子数组以保持整个数组排序</a>。</p><p id="7ba3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">威尔逊:-)</p></div></div>    
</body>
</html>