<html>
<head>
<title>Log with Context in a Concurrent Java System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并发Java系统中的上下文日志</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/log-with-context-in-a-concurrent-java-system-b647a1ba70f3?source=collection_archive---------10-----------------------#2021-01-28">https://levelup.gitconnected.com/log-with-context-in-a-concurrent-java-system-b647a1ba70f3?source=collection_archive---------10-----------------------#2021-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6721" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保多线程之间的一致日志记录。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/38a724c72dfcfa1834df3a32312478c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-bt4xw17-nhUm47iWG9jA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@tompeham?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">托马斯·佩汉姆</a>在<a class="ae le" href="https://unsplash.com/s/photos/log?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2fbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多Java日志库和外观，我相信每个人都有自己喜欢的。许多人都有一个共同点，那就是MDC工具提供了上下文日志记录。因此，如果您的服务有某种想要添加到日志中的事件id，您可以使用<code class="fe lf lg lh li b">MDC.put(“eventId”, eventId)</code>来确保处理该事件的所有日志都将打印出该事件id。</p><p id="8c1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出现这个问题是因为它假设一个事件的处理都发生在一个线程上，尽管可能有多个线程同时处理多个事件。如果单个事件在不同的线程上处理，这种假设会导致系统陷入混乱。在像<a class="ae le" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> Project Reactor </a>这样的非阻塞系统中，线程来来去去，完全不可能预测在任何时间点哪个线程正在进行处理。</p><p id="4cba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的前几篇文章(见下面的文章列表)一直在一个示例二手车处理系统中工作，日志记录是用<code class="fe lf lg lh li b">System.out.println</code>完成的，只是为了保持简单。我们只记录了线程和一条消息，因此我们可以观察线程是如何处理的。这是他们的样子:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="1f57" class="ln lo it li b gy lp lq l lr ls">parallel-11 produced: PurchaseOrder(id=d0fb7857041cc7a0,<br/>    price=65585.10, type=Car, time=2021-01-27T18:40:05.247210Z)<br/>pool-29-thread-4 recevied po PurchaseOrder(id=d0fb7857041cc7a0,<br/>    price=65585.10, type=Car, time=2021-01-27T18:40:05.247210Z)<br/>parallel-14 produced: PurchaseOrder(id=34c0ef03c996cfce,<br/>    price=29356.60, type=Car, time=2021-01-27T18:40:05.252178Z)<br/>pool-29-thread-6 recevied po PurchaseOrder(id=34c0ef03c996cfce,<br/>    price=29356.60, type=Car, time=2021-01-27T18:40:05.252178Z)<br/>rabbitmq-sender-connection-subscription-6 sending car<br/>   Vehicle(po=PurchaseOrder(id=d0fb7857041cc7a0, price=65585.10,<br/>   type=Car, time=2021-01-27T18:40:05.247210Z), lot=)</span></pre><p id="dfe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到所有东西运行的线程，但是我们只能知道哪个日志行与哪个事件相关，因为它们都显示购买订单。情况可能并不总是这样，所以我们应该发送一个事件id，它在事件最终流经的所有服务中都是一致的。</p><p id="4fad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我仍然打算用<code class="fe lf lg lh li b">System.out.println</code>来记录日志，这样我所展示的内容将适用于你碰巧使用的任何一个记录系统。我将创建一个上下文类型和一个静态方法，用于使用对所有服务都可用的上下文进行日志记录。这将会是这样的:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="34ea" class="ln lo it li b gy lp lq l lr ls"><a class="ae le" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>@Builder<br/><a class="ae le" href="http://twitter.com/NoArgsConstructor" rel="noopener ugc nofollow" target="_blank">@NoArgsConstructor</a><br/><a class="ae le" href="http://twitter.com/AllArgsConstructor" rel="noopener ugc nofollow" target="_blank">@AllArgsConstructor</a><br/>public class ContextLogging {<br/>    private String eventId;<br/>    private String serviceName;<br/>    public static void log(ContextLogging context, <br/>            String msg) {<br/>        Instant instant = Instant.now();<br/>        System.out.println(instant.toString() <br/>                + " ["<br/>                + Thread.currentThread().getName()<br/>                + "] service: "<br/>                + context.getServiceName()<br/>                + " event id: "<br/>                + context.getEventId()<br/>                + " msg: "<br/>                + msg);<br/>    }<br/>    public static void log(String msg) {<br/>        Instant instant = Instant.now();<br/>        System.out.println(instant.toString() <br/>                + " ["<br/>                + Thread.currentThread().getName()<br/>                + "] msg: "<br/>                + msg);<br/>    }<br/>}</span></pre><p id="e022" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还创建了一个没有上下文的log方法，用于记录与事件无关的事情，比如启动或关闭例程。</p><p id="4fbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让处理事件的所有方法都可以使用上下文，我将创建一个<code class="fe lf lg lh li b">Tuple</code>，首先包含上下文，然后包含事件数据。我以前做过这样的事情来处理事件状态在系统中的构建。</p><p id="ec44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随身携带所有这些上下文似乎很麻烦，但是如果您想生活在一个没有全局或线程本地状态的系统中，您几乎别无选择。首先，我们可以将上下文添加到<code class="fe lf lg lh li b">PurchaseOrderGenerator</code>类中，它更像是一个测试类，我在测试系统时用它来驱动系统。下面是新代码，它生成一个新的事件id和一个随机购买订单，并将其发送到消息队列:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="fcf6" class="ln lo it li b gy lp lq l lr ls">final Sender sender = RabbitFlux.createSender(soptions);<br/>sender.declareQueue(QueueSpecification.queue(QUEUE_NAME));        <br/>sender.sendWithPublishConfirms(<br/>  Flux.generate((sink) -&gt; sink.next(createRandomPurchaseOrder()))<br/>    .cast(PurchaseOrder.class)<br/>    .map(i -&gt; Tuples.of(ContextLogging.builder()<br/>      .serviceName("PurchaseOrderGenerator")<br/>      .eventId(UUID.randomUUID().toString())<br/>      .build(), i))<br/>    .delayElements(Duration.ofMillis(100))<br/>    .take(Duration.ofMillis(1000))<br/>    .doOnNext(t -&gt; ContextLogging.log(t.getT1(), "produced: "<br/>            + t.getT2()))<br/>    .map(t -&gt; new OutboundMessage("", <br/>            QUEUE_NAME, <br/>            writeJson(t.getT1(), t.getT2()).orElse("").getBytes()))<br/>    .doFinally((s) -&gt; {<br/>         ContextLogging.log(<br/>            "PurchaseOrderGenerator in finally for signal " + s); <br/>         sender.close();<br/>    })<br/>)<br/>.subscribe();</span></pre><p id="f9e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建随机采购订单后，我做的第一件事是将它映射到一个包含新上下文和采购订单的<code class="fe lf lg lh li b">Tuple</code>。那么之后链接的所有方法都有这两个项目。此外，我将把上下文传递给<code class="fe lf lg lh li b">writeJson</code>方法，因为我们希望将事件id与采购订单一起发送，这样我们就可以将下游服务中的项目关联起来。最后要注意的是，<code class="fe lf lg lh li b">doFinally</code>方法中的<code class="fe lf lg lh li b">log</code>调用没有上下文，因为它是关机例程的一部分，与事件无关。</p><p id="ad9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们刚才提到的，事件id需要和事件一起发送到消息队列。因此，我们创建了一个名为<code class="fe lf lg lh li b">Payload</code>的类型，它包含事件id和采购订单，然后我们对其进行序列化。我可以将<code class="fe lf lg lh li b">Payload</code>移动到它自己的文件中，但是我不会这么做。我们试图模拟不同的服务，这些服务可能来自不同的团队，而这些团队没有能力共享代码。它不是很枯燥，但有时你必须分离事物，这通常意味着复制事物。下面是序列化事件id和采购订单的代码:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="11a2" class="ln lo it li b gy lp lq l lr ls">public static class Payload {<br/>  public Payload() {}<br/>  public Payload(String eventId, PurchaseOrder po) {<br/>    this.eventId = eventId;<br/>    this.po = po;<br/>  }<br/>  public String eventId;<br/>  public PurchaseOrder po;<br/>}<br/>    <br/>private static Optional&lt;String&gt; writeJson(ContextLogging context,<br/>                  PurchaseOrder po) {<br/>  try {<br/>    return Optional.of(writer.writeValueAsString(new<br/>               Payload(context.getEventId(),po)));<br/>  } catch (JsonProcessingException ex) {<br/>    ContextLogging.log(context, "unable to serialize po");<br/>    ex.printStackTrace(System.out);<br/>    return Optional.empty();<br/>  }<br/>}</span></pre><p id="bf72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成后，我们将必须修改消费服务以读入事件id和采购订单，并从中创建一个新的上下文。在<code class="fe lf lg lh li b">PurchaseOrderConsumer</code>类中，我更改了从消息队列中解析数据的方法:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="2ddc" class="ln lo it li b gy lp lq l lr ls">public static class Payload {<br/>  public Payload() {}<br/>  public Payload(String eventId, PurchaseOrder po) {<br/>    this.eventId = eventId;<br/>    this.po = po;<br/>  }<br/>  public String eventId;<br/>  public PurchaseOrder po;<br/>}<br/>    <br/>private static Payload readJson(String po) {<br/>  try {<br/>    return reader.readValue(po);<br/>  } catch (JsonProcessingException ex) {<br/>    ContextLogging.log("unable to serialize po");<br/>    ex.printStackTrace(System.out);<br/>    Payload empty = new Payload();<br/>    empty.eventId = "no event id";<br/>    empty.po = PurchaseOrder.builder().build();<br/>    return empty;<br/>  } catch (IOException ex) {<br/>     ContextLogging.log("unable to serialize po");<br/>     ex.printStackTrace(System.out);<br/>     Payload empty = new Payload();<br/>     empty.eventId = "no event id";<br/>     empty.po = PurchaseOrder.builder().build();<br/>     return empty;<br/>  }<br/>}</span></pre><p id="df11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以设置采购订单的处理链:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="3595" class="ln lo it li b gy lp lq l lr ls">Map&lt;String, Function&lt;GroupedFlux&lt;String, <br/>            Tuple2&lt;ContextLogging, PurchaseOrder&gt;&gt;, <br/>                Publisher&lt;OutboundMessageResult&gt;&gt;&gt; <br/>  publisherMap = Map.of(<br/>    "Car", (o) -&gt; getCarPublisher(sender, o),<br/>    "Truck", (o) -&gt; getTruckPublisher(sender, o),<br/>    "Motorcycle", (o) -&gt; getMotorcyclePublisher(sender, o));<br/>receiver<br/>  .consumeAutoAck(PO_QUEUE_NAME)<br/>  .timeout(Duration.ofSeconds(10))<br/>  .doFinally((s) -&gt; {<br/>     ContextLogging<br/>       .log("Purchase Order Consumer in finally for signal " + s);<br/>    receiver.close();<br/>    sender.close();<br/>    cluster.disconnect();<br/>  })<br/>  .map(p -&gt; readJson(new String(p.getBody())))<br/>  .map(p -&gt; Tuples.of(ContextLogging.builder()<br/>     .serviceName("PurchaseOrderConsumer")<br/>     .eventId(p.eventId)<br/>     .build(), p.po))<br/>  .filter(t -&gt; t.getT2().isValid())<br/>  .doOnNext(t -&gt; ContextLogging.log(t.getT1(), <br/>         "recevied po " + t.getT2()))<br/>  .doOnDiscard(Tuple2.class, t -&gt;<br/>       ContextLogging.log((ContextLogging)t.getT1(), <br/>         "Discarded invalid PO " + t.getT2()))<br/>  .flatMap(t -&gt; writePoJson(t.getT1(),t.getT2())<br/>    .map(j -&gt; reactiveCollection<br/>      .upsert(t.getT2().getId(), j)<br/>      .map(result -&gt; t))<br/>    .orElse(Mono.just(t)))<br/>  .groupBy(t -&gt; t.getT2().getType())<br/>  .flatMap(v -&gt; publisherMap.get(v.key()).apply(v))<br/>  .subscribe();</span></pre><p id="6118" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们在<code class="fe lf lg lh li b">readJson</code>中解析了来自消息队列的输入，我们就创建一个新的<code class="fe lf lg lh li b">Tuple</code>，它具有用原始事件id和购买订单构建的新上下文。</p><p id="c3ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当我们查看日志时，我们可以看到时间、线程名称、服务名称和事件id:</p><pre class="kp kq kr ks gt lj li lk ll aw lm bi"><span id="bc46" class="ln lo it li b gy lp lq l lr ls">2021-01-27T21:20:47.519385Z [parallel-11] service: PurchaseOrderGenerator event id: 3f7650b7-c304-4537-a07f-810a909d7479 msg: produced: PurchaseOrder(id=34f6525f239b5bce, price=8042.14, type=Truck, time=2021-01-27T21:20:47.356310Z)<br/>2021-01-27T21:20:47.756497Z [pool-29-thread-4] service: PurchaseOrderConsumer event id: 3f7650b7-c304-4537-a07f-810a909d7479 msg: recevied po PurchaseOrder(id=34f6525f239b5bce, price=8042.14, type=Truck, time=2021-01-27T21:20:47.356310Z)<br/>2021-01-27T21:20:47.827465Z [parallel-14] service: PurchaseOrderGenerator event id: 525962b9-b760-46cc-99d8-87eb83de84b5 msg: produced: PurchaseOrder(id=2ac5eb8193157cc2, price=77006.06, type=Car, time=2021-01-27T21:20:47.361935Z)<br/>2021-01-27T21:20:47.832642Z [pool-29-thread-5] service: PurchaseOrderConsumer event id: 525962b9-b760-46cc-99d8-87eb83de84b5 msg: recevied po PurchaseOrder(id=2ac5eb8193157cc2, price=77006.06, type=Car, time=2021-01-27T21:20:47.361935Z)<br/>2021-01-27T21:20:47.897228Z [rabbitmq-sender-connection-subscription-6] service: PurchaseOrderConsumer event id: 3f7650b7-c304-4537-a07f-810a909d7479 msg: sending truck Vehicle(po=PurchaseOrder(id=34f6525f239b5bce, price=8042.14, type=Truck, time=2021-01-27T21:20:47.356310Z), lot=)<br/>2021-01-27T21:20:47.905285Z [rabbitmq-sender-connection-subscription-6] service: PurchaseOrderConsumer event id: 525962b9-b760-46cc-99d8-87eb83de84b5 msg: sending car Vehicle(po=PurchaseOrder(id=2ac5eb8193157cc2, price=77006.06, type=Car, time=2021-01-27T21:20:47.361935Z), lot=)</span></pre><p id="800b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以看到，即使我们跨服务，具有相同采购订单编号的事件也具有相同的事件id，因此我们不再依赖于日志中的采购订单编号。在处理的下一步，我们甚至可能没有购买订单号，但是我们应该总是有事件id来关联服务与服务之间的日志。</p><p id="3d57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个很好的例子，说明了我们如何构建必须在整个流程中跟踪事件的事件状态。通过使用<code class="fe lf lg lh li b">Tuple</code>，我们可以在处理过程中根据需要从事件状态中添加或删除更多的项目，而不必改变核心数据结构。唯一的缺点是，如果你在<code class="fe lf lg lh li b">Tuple</code>中有很多项目，事情会变得很混乱。但是应该清楚的是，如果当您省略了一个“&gt;”时，编译器错误变得不可理解，那么您需要重新构建代码。</p><p id="2e2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文附带的代码:</p><div class="lt lu gp gr lv lw"><a href="https://github.com/rkamradt/usedvehicles/tree/v0.4" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd iu gy z fp mb fr fs mc fu fw is bi translated">rkamradt/二手车辆</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">在GitHub上创建一个帐户，为rkamradt/usedvehicles的开发做出贡献。</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">github.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk ky lw"/></div></div></a></div><p id="a0a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本系列的其他文章:</p><div class="lt lu gp gr lv lw"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-reactive-java-e8aaee9a204b"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd iu gy z fp mb fr fs mc fu fw is bi translated">理解反应式Java</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">因为你的线程阻碍了我的表现。</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mf l"><div class="ml l mh mi mj mf mk ky lw"/></div></div></a></div><div class="lt lu gp gr lv lw"><a rel="noopener  ugc nofollow" target="_blank" href="/creating-a-flux-of-fluxes-with-project-reactors-group-by-method-37200bfc2a"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd iu gy z fp mb fr fs mc fu fw is bi translated">用Project Reactor的Group By方法创建通量通量</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">什么通量？</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mf l"><div class="mm l mh mi mj mf mk ky lw"/></div></div></a></div><div class="lt lu gp gr lv lw"><a rel="noopener  ugc nofollow" target="_blank" href="/parallel-tasks-in-a-non-blocking-system-66c195aba56d"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd iu gy z fp mb fr fs mc fu fw is bi translated">非阻塞系统中的并行任务</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">利用Project Reactor的线程/非阻塞混合模型。</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mf l"><div class="mn l mh mi mj mf mk ky lw"/></div></div></a></div></div></div>    
</body>
</html>