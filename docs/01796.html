<html>
<head>
<title>All I Need Is A Kubernetes Namespace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我只需要一个Kubernetes名称空间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-tips-all-i-need-is-a-namespace-c81dec026294?source=collection_archive---------19-----------------------#2020-01-29">https://levelup.gitconnected.com/kubernetes-tips-all-i-need-is-a-namespace-c81dec026294?source=collection_archive---------19-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8215" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们从K8Spin获取一个来运行我的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eeec63c3d2714776cbfcd1b1b1c057ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWLTcIMKsq8b7bvy0KrXfQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">K8Spin提供名称空间来运行您的工作负载</figcaption></figure><h1 id="36bd" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="0184" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您已经开发了一个很棒的应用程序，并准备部署到Kubernetes集群上。您正在寻找一个云提供商来运行一个新的集群，但是…等等…当您需要的只是一个名称空间时，为什么您要使用整个集群呢？在本文中，我们将展示如何从K8Spin获取Kubernetes名称空间，并在其中部署应用程序。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="5731" class="ky kz it bd la lb mt ld le lf mu lh li jz mv ka lk kc mw kd lm kf mx kg lo lp bi translated">关于K8Spin</h1><p id="db92" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">K8Spin是一家位于西班牙的公司，它有一个很好的方法，允许用户创建Kubernetes名称空间来部署他们的应用程序。K8Spin为您管理所有底层组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/ebd00520d21e380d482accf6814aad0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpA_w6BeM0-Yo8xDMtLLJA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">托管Kubernetes解决方案与K8Spin云</figcaption></figure><p id="9963" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">命名空间通过使用以下各项相互隔离:</p><ul class=""><li id="6d24" class="ne nf it ls b lt mz lw na lz ng md nh mh ni ml nj nk nl nm bi translated"><a class="ae nn" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a>因此pod不能跨名称空间通信</li><li id="8f74" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><a class="ae nn" href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" rel="noopener ugc nofollow" target="_blank">资源配额</a>因此一个名称空间中的所有pod不能消耗超过授权的资源</li></ul><p id="599a" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">在引擎盖下，K8Spin使用GKE (Google Kubernetes引擎)作为其沙盒风格，意思是用gVisor作为容器运行时。简而言之，gVisor使用一种新的Linux内核实现来运行容器，这种实现是用Go编写的，在用户空间中运行。gVisor拦截应用程序的系统调用，从而为主机内核漏洞提供额外的保护，它专注于安全性、效率和易用性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/f8489c1794eebde475dfdb413f810728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rKlpoA5_cDrGKvZ5P6-Gw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">管理应用程序系统调用的几种方法</figcaption></figure><p id="ab35" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">gVisor不是这篇文章的主题，但绝对是一个值得密切关注的话题。你可以在谷歌云网站上找到更多信息:【https://cloud.google.com/kubernetes-engine/sandbox T4】</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="745f" class="ky kz it bd la lb mt ld le lf mu lh li jz mv ka lk kc mw kd lm kf mx kg lo lp bi translated">设置</h1><p id="1172" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们仔细看看K8Spin，从在<a class="ae nn" href="https://k8spin.cloud" rel="noopener ugc nofollow" target="_blank"> https://k8spin.cloud </a>上创建一个帐户开始</p><div class="kj kk kl km gt ab cb"><figure class="nu kn nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/513255b1d41a0177117363c99cf49d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qI6D6hUAasivo4xcNUFFOQ.png"/></div></figure><figure class="nu kn nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/54a5e70f813ce157e6227fdfc79f10aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*fM94edkQqkq_A_LapuVV3Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk oa di ob oc translated">在K8Spin上创建一个帐户并访问仪表板</figcaption></figure></div><p id="23de" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">从仪表板中，我们可以创建名称空间。让我们创建一个名为<strong class="ls iu">的演示。</strong></p><div class="kj kk kl km gt ab cb"><figure class="nu kn nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/38b42cae4073aec41b4d068d32596762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*CIAjTAUDfMiG1FNM973ByQ.png"/></div></figure><figure class="nu kn nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/f67d59b227f03c5792e2ef4c77c03423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tt1bx7OJg-zIaZoo2zNkyA.png"/></div></figure></div><p id="bfea" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">在自由层中，用户可以创建一个命名空间，受限于以下资源边界:</p><ul class=""><li id="ac36" class="ne nf it ls b lt mz lw na lz ng md nh mh ni ml nj nk nl nm bi translated">中央处理器:100兆赫兹</li><li id="5fe1" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">内存:128兆字节</li></ul><p id="1e25" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">一旦创建了名称空间，我们就可以下载kubeconfig文件。它是根据名称空间的名字命名的(在这个例子中是<strong class="ls iu"> demo.config </strong>)。它包含以下信息(为便于查看，CA和令牌数据被剪切):</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1ca7" class="oi kz it oe b gy oj ok l ol om">apiVersion: v1<br/>kind: Config<br/>clusters:<br/>- cluster:<br/>    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUS...EUtLS0tLQo=<br/>    server: <a class="ae nn" href="https://35.242.197.145" rel="noopener ugc nofollow" target="_blank">https://35.223.187.135</a><br/>  name: luc-juggery-gmail-com-demo</span><span id="29f6" class="oi kz it oe b gy on ok l ol om">users:<br/>- name: luc-juggery-gmail-com-demo<br/>  user:<br/>    token: eyJhbGciOiJ...Lud9rToUQAOIQ</span><span id="b008" class="oi kz it oe b gy on ok l ol om">contexts:<br/>- context:<br/>    cluster: luc-juggery-gmail-com-demo<br/><strong class="oe iu">    namespace: luc-juggery-gmail-com-vote<br/></strong>    user: luc-juggery-gmail-com-demo<br/>  name: luc-juggery-gmail-com-demo</span><span id="2563" class="oi kz it oe b gy on ok l ol om">current-context: luc-juggery-gmail-com-demo</span></pre><p id="f286" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">与任何kubeconfig文件一样，我们有:</p><ul class=""><li id="a1ce" class="ne nf it ls b lt mz lw na lz ng md nh mh ni ml nj nk nl nm bi translated">集群信息(认证机构和API服务器端点)</li><li id="7768" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">用户凭证(此处为令牌)</li><li id="61a4" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">链接集群和用户的上下文。这里需要注意的重要一点是上下文中指定的名称空间键，这个键确保使用这个kubeconfig运行的所有<strong class="ls iu"> kubectl </strong>命令都将在这个名称空间中执行！</li></ul><p id="8a09" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated"><em class="oo">注意</em>:我已经创建了一个名为<strong class="ls iu"> demo </strong>的名称空间，但是在内部它已经以我的电子邮件地址为前缀。</p><p id="1ef1" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">然后我们可以配置我们的本地<strong class="ls iu"> kubectl </strong>，这样它就可以使用上面的kubeconfig:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="21d7" class="oi kz it oe b gy oj ok l ol om">export KUBECONFIG=$PWD/demo.config</span></pre><p id="09a0" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">我们现在可以在我们的专用命名空间上部署任何工作负载。让我们用投票应用程序来测试一下。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="65ba" class="ky kz it bd la lb mt ld le lf mu lh li jz mv ka lk kc mw kd lm kf mx kg lo lp bi translated">投票应用程序</h1><p id="04b8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我在以前的许多文章中使用过投票应用程序。这个应用程序由Docker维护，用于演示Docker Compose、Docker Swarm的新功能……现在演示Kubernetes相关的东西也非常方便。这个应用程序遵循微服务架构。它由五个服务组成，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/d5d301e2b4c2f74f23f7e54038953ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CCsNh8b40Q7OIhfi"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Docker的投票应用架构</figcaption></figure><ul class=""><li id="ef0f" class="ne nf it ls b lt mz lw na lz ng md nh mh ni ml nj nk nl nm bi translated"><strong class="ls iu">投票</strong>:前端显示2个项目，用户可以从中选择</li><li id="e6d6" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls iu"> redis </strong>:存储选票的数据库。</li><li id="1ccd" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls iu"> worker </strong>:从Redis获取投票的服务，将结果整合并存储在Postgres数据库中。</li><li id="2367" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls iu"> db </strong>:存储结果的Postgres数据库</li><li id="ef6f" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls iu">结果</strong>:前端显示投票结果。</li></ul></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="33da" class="ky kz it bd la lb mt ld le lf mu lh li jz mv ka lk kc mw kd lm kf mx kg lo lp bi translated">在k8Spin上部署投票应用程序</h1><p id="ffec" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">由于投票应用程序的一些组件在启动时非常贪婪，K8Spin免费升级了我的名称空间上的配额集，因此整个应用程序可以部署。(谢谢伙计们！)</p><p id="61ee" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">下面是我们将要部署的投票应用程序的整体规范，每个微服务都有一个部署和一个服务资源。<strong class="ls iu"> worker </strong>微服务是唯一不需要服务资源的微服务，因为它没有被任何其他微服务调用。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8f7d" class="oi kz it oe b gy oj ok l ol om">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: vote<br/>  name: vote<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: vote<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: vote<br/>    spec:<br/>      containers:<br/>      - image: dockersamples/examplevotingapp_vote:before<br/>        name: vote<br/>        ports:<br/>        - containerPort: 80<br/>          name: vote<br/>        resources:<br/>          limits:<br/>            cpu: 80m<br/>            memory: 256Mi<br/>          requests:<br/>            cpu: 80m<br/>            memory: 256Mi<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: vote<br/>  name: vote<br/>spec:<br/>  ports:<br/>  - name: "vote-service"<br/>    port: 5000<br/>    targetPort: 80<br/>  selector:<br/>    app: vote<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: redis<br/>  name: redis<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: redis<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: redis<br/>    spec:<br/>      containers:<br/>      - image: redis<br/>        name: redis<br/>        ports:<br/>        - containerPort: 6379<br/>          name: redis<br/>        volumeMounts:<br/>        - mountPath: /data<br/>          name: redis-data<br/>        resources:<br/>          limits:<br/>            cpu: 80m<br/>            memory: 64Mi<br/>          requests:<br/>            cpu: 80m<br/>            memory: 64Mi<br/>      volumes:<br/>      - name: redis-data<br/>        emptyDir: {}<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: redis<br/>  name: redis<br/>spec:<br/>  ports:<br/>  - name: "redis-service"<br/>    port: 6379<br/>    targetPort: 6379<br/>  selector:<br/>    app: redis<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: worker<br/>  name: worker<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: worker<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: worker<br/>    spec:<br/>      containers:<br/>      - image: lucj/examplevotingapp_worker:java<br/>        name: worker<br/>        resources:<br/>          limits:<br/>            cpu: 80m<br/>            memory: 128Mi<br/>          requests:<br/>            cpu: 80m<br/>            memory: 128Mi<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: db<br/>  name: db<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: db<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: db<br/>    spec:<br/>      containers:<br/>      - image: postgres:9.4<br/>        name: postgres<br/>        ports:<br/>        - containerPort: 5432<br/>          name: postgres<br/>        volumeMounts:<br/>        - mountPath: /var/lib/postgresql/data<br/>          name: db-data<br/>        resources:<br/>          limits:<br/>            cpu: 80m<br/>            memory: 64Mi<br/>          requests:<br/>            cpu: 80m<br/>            memory: 64Mi<br/>      volumes:<br/>      - name: db-data<br/>        emptyDir: {}<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: db<br/>  name: db<br/>spec:<br/>  type: ClusterIP<br/>  ports:<br/>  - name: "db-service"<br/>    port: 5432<br/>    targetPort: 5432<br/>  selector:<br/>    app: db<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: result<br/>  name: result<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: result<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: result<br/>    spec:<br/>      containers:<br/>      - image: dockersamples/examplevotingapp_result:before<br/>        name: result<br/>        ports:<br/>        - containerPort: 80<br/>          name: result<br/>        resources:<br/>          limits:<br/>            cpu: 80m<br/>            memory: 64Mi<br/>          requests:<br/>            cpu: 80m<br/>            memory: 64Mi<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: result<br/>  name: result<br/>spec:<br/>  ports:<br/>  - name: "result-service"<br/>    port: 5001<br/>    targetPort: 80<br/>  selector:<br/>    app: result</span></pre><p id="23d1" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">注意:</p><ul class=""><li id="65c5" class="ne nf it ls b lt mz lw na lz ng md nh mh ni ml nj nk nl nm bi translated">我们为每个容器指定了资源限制和请求，否则将默认为30m CPU和64Mi RAM，这对于<strong class="ls iu">投票</strong>和<strong class="ls iu">工人</strong>微服务来说是不够的</li><li id="2282" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">默认情况下，worker使用的图像是java版本。由于一个问题(可能与<a class="ae nn" href="https://github.com/dotnet/coreclr/issues/4132" rel="noopener ugc nofollow" target="_blank">https://github.com/dotnet/coreclr/issues/4132</a>有关)，网络版无法运行</li></ul><p id="4933" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">以上规格在<a class="ae nn" href="https://files.techwhale.io/votingapp-k8spin.yaml," rel="noopener ugc nofollow" target="_blank">https://files.techwhale.io/votingapp-k8spin.yaml,</a>上有，我们来部署一下:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c7b0" class="oi kz it oe b gy oj ok l ol om">$ kubectl apply -f <a class="ae nn" href="https://files.techwhale.io/votingapp-k8spin.yaml" rel="noopener ugc nofollow" target="_blank">https://files.techwhale.io/votingapp-k8spin.yaml</a><br/>deployment.apps/vote created<br/>service/vote created<br/>deployment.apps/redis created<br/>service/redis created<br/>deployment.apps/worker created<br/>deployment.apps/db created<br/>service/db created<br/>deployment.apps/result created<br/>service/result created</span></pre><p id="5c18" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">让我们检查所有的豆荚都运行良好</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8d87" class="oi kz it oe b gy oj ok l ol om">$ <strong class="oe iu">kubectl get pods</strong><br/>NAME                      READY   STATUS    RESTARTS   AGE<br/>db-5cfb55b76f-8z4tf       1/1     Running   0          9s<br/>redis-689486ff99-jdmk6    1/1     Running   0          9s<br/>result-7cc85c55cf-5bfpf   1/1     Running   0          8s<br/>vote-5569b9d94f-6wnmd     1/1     Running   0          9s<br/>worker-547d9d9c4d-k5x9r   1/1     Running   0          9s</span></pre><p id="92a8" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">K8Spin控制台也证实了这一点，我们可以看到:</p><ul class=""><li id="cf72" class="ne nf it ls b lt mz lw na lz ng md nh mh ni ml nj nk nl nm bi translated">Pods running(投票应用程序的每个微服务一个)</li><li id="8696" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">服务已创建(每个微服务一个，工作服务除外)</li><li id="dc4b" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">已创建配置映射(本例中没有)</li><li id="6847" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">创建了永久卷(本例中没有)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/f0f857d761f8649086dd49cb2f8c8114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DR6ctxN0tIYKTXB1gAcFgQ.png"/></div></div></figure><p id="7a6d" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">应用程序运行在我们的<strong class="ls iu">演示</strong>名称空间中，微服务通过ClusterIP Kubernetes服务在内部公开。我们现在将向外界公开<strong class="ls iu">投票</strong>和<strong class="ls iu">结果</strong> web接口。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="6623" class="ky kz it bd la lb mt ld le lf mu lh li jz mv ka lk kc mw kd lm kf mx kg lo lp bi translated">向外界公开投票应用程序</h1><p id="2e3f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了展示应用程序，我们只需要定义一个入口资源，指定附属于用户帐户的入口域内的子域。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/ede6b6448c6add706108ffd0650cc3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19EwiiEM6Vh8rMmvaRftqA.png"/></div></div></figure><p id="fca4" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">我们只想确定:</p><ul class=""><li id="15dd" class="ne nf it ls b lt mz lw na lz ng md nh mh ni ml nj nk nl nm bi translated">针对<a class="ae nn" href="http://vote.luc.apps.k8spin.cloud" rel="noopener ugc nofollow" target="_blank">http://vote . Luc . apps . k8 spin . cloud</a>的请求被转发给<strong class="ls iu"> vote </strong>服务</li><li id="bac9" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">目标为<a class="ae nn" href="http://result.luc.apps.k8spin.cloud" rel="noopener ugc nofollow" target="_blank">http://result . Luc . apps . k8 spin . cloud</a>的被转发到<strong class="ls iu">结果</strong>服务</li></ul><p id="ed5b" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">我们根据以下规范创建入口资源:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c449" class="oi kz it oe b gy oj ok l ol om">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: votingapp<br/>spec:<br/>  rules:<br/>  - host: vote.luc.apps.k8spin.cloud<br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: vote<br/>          servicePort: 5000<br/>  - host: result.luc.apps.k8spin.cloud<br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: result<br/>          servicePort: 5001</span></pre><p id="454f" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">创建完成后，我们可以验证两个web界面都可用。从投票界面选择一个项目反映在结果界面上，整个应用程序运行良好。</p><div class="kj kk kl km gt ab cb"><figure class="nu kn nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/cfc3b1b9fd93a2951d87ee05b76120fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ZWYe7V6O8BtADR_eW7S_UA.png"/></div></figure><figure class="nu kn nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/07ba6d1a7b3e5509749fcaf430dc2a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*8eZTuSMf-oQNuaZhddVQqQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk oa di ob oc translated">K8Spin上的投票应用</figcaption></figure></div><h1 id="82cf" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">将TLS证书添加到图片</h1><p id="2764" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">即使对于一个简单的网站，设置TLS证书也是必须的。K8Spin让这一步变得非常简单，因为它为每个帐户创建了一个发行者。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="4c3b" class="oi kz it oe b gy oj ok l ol om"><strong class="oe iu">$ kubectl get issuer<br/></strong>NAME                    READY   AGE<br/>luc-juggery-gmail-com   True    20m</span></pre><p id="84cc" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">当创建证书登录请求(CSR)时，此颁发者可用于生成证书。在引擎盖下，它将调用“让我们加密认证机构”。</p><p id="ecf4" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">让我们使用以下规范来修改入口资源。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8d83" class="oi kz it oe b gy oj ok l ol om">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: votingapp<br/>  <strong class="oe iu">annotations:<br/>    ingress.kubernetes.io/ssl-redirect: "true"<br/>    cert-manager.io/issuer: </strong><strong class="oe iu">luc-juggery-gmail-com</strong><br/>spec:<br/>  <strong class="oe iu">tls:<br/>  - hosts:<br/>    - </strong><strong class="oe iu">vote.luc.apps.k8spin.cloud<br/>    - result.luc.apps.k8spin.cloud<br/></strong><strong class="oe iu">    secretName: votingapp-certificate</strong><br/>  rules:<br/>  - host: vote.luc.apps.k8spin.cloud<br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: vote<br/>          servicePort: 5000<br/>  - host: result.luc.apps.k8spin.cloud<br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: result<br/>          servicePort: 5001</span></pre><p id="4954" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">这里需要注意几件事:</p><ul class=""><li id="d5b5" class="ne nf it ls b lt mz lw na lz ng md nh mh ni ml nj nk nl nm bi translated">添加了2个<strong class="ls iu">注释</strong>:第一个注释确保每个http请求都被重定向到https端点；第二个指定应该用来生成证书的颁发者</li><li id="63d6" class="ne nf it ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">在<strong class="ls iu">规格</strong>下添加了新的<strong class="ls iu"> tls </strong>键。这个定义了需要TLS证书的主机。将创建一个秘密来存储证书，该秘密的名称在<strong class="ls iu"> secretName </strong>字段中指定。</li></ul><p id="d2b4" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">使用上述规范更新入口资源会触发CSR(证书登录请求)的生成，大约一分钟后，证书创建完成，我们可以验证:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="78b7" class="oi kz it oe b gy oj ok l ol om"><strong class="oe iu">$ kubectl get certificate<br/></strong>NAME                    READY   SECRET                  AGE<br/>votingapp-certificate   True    votingapp-certificate   97s</span></pre><p id="8dd2" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">我们还可以看到已经创建了<strong class="ls iu"> votingapp-certificate </strong>秘密</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1062" class="oi kz it oe b gy oj ok l ol om"><strong class="oe iu">$ kubectl get secret<br/></strong>NAME                    TYPE                 DATA   AGE<br/>votingapp-certificate   kubernetes.io/tls    3      2m</span></pre><p id="b487" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">如果我们用下面的命令检查它的内容，我们可以看到与证书相关联的私钥和公钥</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="10eb" class="oi kz it oe b gy oj ok l ol om">$ kubectl get secret votingapp-certificate -o yaml</span></pre><p id="083f" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly lz nb mb mc md nc mf mg mh nd mj mk ml im bi translated">现在让我们再次访问投票应用程序，并确保它使用https。</p><div class="kj kk kl km gt ab cb"><figure class="nu kn nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/e0801a8cbe509d79ae1ab98bd072446a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*TkXdlNFl9szoHX46meUXDg.png"/></div></figure><figure class="nu kn nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/eba086b952779437e452a292ffdefa02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yAAQsN-zcdsplZBEWnt87w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk oa di ob oc translated">通过TLS访问投票应用程序(为我们的域创建了一个新的Let's Encrypt证书)</figcaption></figure></div></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="fff2" class="ky kz it bd la lb mt ld le lf mu lh li jz mv ka lk kc mw kd lm kf mx kg lo lp bi translated">摘要</h1><p id="e82f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">提供Kubernetes名称空间无疑是一个很好的方法。这样做K8Spin设法隐藏了集群的底层复杂性。选择gVisor作为容器运行时可能很有挑战性，因为它仍然很新，但它也绝对是增强安全性的一大举措。</p></div></div>    
</body>
</html>