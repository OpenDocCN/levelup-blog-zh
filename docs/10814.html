<html>
<head>
<title>How to use Google Pub/Sub to build an asynchronous messaging system in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Google Pub/Sub在Python中构建异步消息传递系统</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-google-pub-sub-to-build-an-asynchronous-messaging-system-in-python-3b43094627dc?source=collection_archive---------0-----------------------#2022-01-13">https://levelup.gitconnected.com/how-to-use-google-pub-sub-to-build-an-asynchronous-messaging-system-in-python-3b43094627dc?source=collection_archive---------0-----------------------#2022-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f570" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解一个简单而强大的云发布/订阅系统</h2></div><p id="724a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Google云平台上的Pub/Sub(发布者/订阅者)服务是一个现代化的异步消息传递系统。它类似于开源的Apache Kafka，但是使用起来简单得多。Pub/Sub是GCP生态系统的一部分，因此与其他服务一起使用非常方便。你可以使用Pub/Sub将你的应用与云函数、数据流、Bigtable、云存储等进行集成。此外，Pub/Sub有许多编程语言的客户端库，包括Python。在本文中，我们将介绍Pub/Sub的基本概念，然后逐步说明如何在Python中使用它。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/98ed4460171d87821a3cd4df1d3a268f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H9rG6fn_opIsehtv.jpg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">图片来自<a class="ae lu" href="https://pixabay.com/photos/queue-playmobil-to-wave-655820/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>。</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ede9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键概念:</p><ul class=""><li id="6fae" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated"><strong class="kk iu">发布者</strong> —消息的生产者。</li><li id="6fd8" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">订阅者</strong>——消息消费者。</li><li id="4ecb" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">异步</strong> —事件的发生与事件的处理时间和方式无关。对于发布/订阅，发布者只发布消息，而不关心消息是否、如何以及何时被处理。通过这种方式，消息的发布和处理是分离的。</li><li id="a958" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">主题—GCP上的一个抽象资源，出版商向其发布消息。我们不需要关心背后的技术细节，只需要知道题目的<strong class="kk iu">名</strong>即可。</li><li id="99e3" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">订阅</strong> —与主题类似，订阅是一种抽象的GCP资源，它处理从特定主题到一些专用订阅者的消息流。</li><li id="185a" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">推送发送类型</strong> —发布/订阅自动将发布的消息推送给订阅者。云函数是推送机制的常见订户，因为发布/订阅可以自动触发云函数，如示例中所示。</li><li id="c6a2" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">拉取传递类型</strong> —订阅者必须自己从一个主题中拉取消息。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="55ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">建议创建一个临时项目，在您完成本教程后可以将其删除，这样您就不会被进一步收费。如果你不知道如何在GCP上创建和删除一个项目，先看看这篇文章。</p><p id="012d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在Python中发布和接收来自发布/订阅的消息，您需要创建一个具有“发布/订阅发布者”和“发布/订阅订阅者”角色的服务帐户:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mq"><img src="../Images/b908c90a216b5c5f78a3c25efb2d33bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ceAcL7XVCdjEY7FWGcjCw.png"/></div></div></figure><p id="2731" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建服务帐户后，记得为它创建一个JSON密钥，稍后将在我们的Python代码中使用该密钥进行身份验证。</p><p id="ed5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在GCP上创建服务帐户的逐步说明也包含在<a class="ae lu" href="https://medium.com/codex/how-to-write-logs-to-google-cloud-logging-in-python-46e7b514c60b" rel="noopener">上一篇文章</a>中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3ee7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然已经下载了服务帐户密钥，我们就可以用它来认证我们的Python应用程序了。</p><p id="c803" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们可以向Pub/Sub发送消息之前，我们需要为它安装客户端库。建议<a class="ae lu" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">创建一个虚拟环境</a>并在那里安装库，这样就不会搞乱系统库。为简单起见，我们将使用<a class="ae lu" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener"> <em class="mr"> conda </em> </a>来创建虚拟环境。为了更容易地以交互方式运行Python代码，我们还将安装iPython:</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="8550" class="mx my it mt b gy mz na l nb nc">(base) $ conda create --name gcp_pubsub python=3.10<br/>(base) $ conda activate gcp_pubsub<br/>(gcp_logging) $ pip install -U google-cloud-pubsub<br/>(gcp_logging) $ pip install ipython</span></pre><p id="d967" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们为服务帐户密钥设置一个环境变量。这是推荐的方法，因为它使用授予服务帐户的角色来验证所有gcloud服务。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="2c55" class="mx my it mt b gy mz na l nb nc">$ export <strong class="mt iu">GOOGLE_APPLICATION_CREDENTIALS</strong>=~/Downloads/service-account-key.json</span></pre><p id="e9a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">环境变量的名称必须是<strong class="kk iu">GOOGLE _ APPLICATION _ CREDENTIALS</strong>否则将无法工作。Google SDK使用这个环境变量进行身份验证。现在让我们开始使用Python中的Pub/Sub。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b24a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建主题和订阅</strong>。</p><p id="b8dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用发布/订阅进行消息传递之前，我们应该先创建一个主题和一个订阅。你可以在本地或谷歌云控制台上用<code class="fe nd ne nf mt b">gcloud</code>命令来完成。</p><p id="0cee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在本地运行<code class="fe nd ne nf mt b">gcloud</code>命令来创建主题和订阅，如下所示:</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="71ad" class="mx my it mt b gy mz na l nb nc">$ <strong class="mt iu">gcloud pubsub topics create test-topic</strong></span><span id="8f57" class="mx my it mt b gy ng na l nb nc">$ <strong class="mt iu">gcloud pubsub subscriptions create test-subscription --topic test-topic</strong></span></pre><p id="8e2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，您可以在<a class="ae lu" href="https://console.cloud.google.com/home/dashboard?project=temp-project-for-logging-2" rel="noopener ugc nofollow" target="_blank">谷歌云控制台</a>上创建一个主题和订阅。首先，找到发布/订阅并启用API(如果它还没有启用的话)。然后根据下面的说明创建一个主题和一个订阅。如果你没有以编程方式创建主题或订阅，你可能更喜欢在谷歌云控制台上创建它们，因为你可以在那里有更直接和更生动的控制。这些选项也可用于<code class="fe nd ne nf mt b">gcloud</code>命令。然而，如果你是第一次接触Pub/Sub，你会很难找到和使用它们。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nh"><img src="../Images/dc05e7320c74563ce68a2def9aa4a08e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOl772y1HAAN-kskfXCnaQ.png"/></div></div></figure><p id="d0b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Google Cloud控制台上创建的主题有一个为它创建的默认订阅。如果需要，您可以创建一个新的，就像这里将要做的那样。选择刚刚创建的“测试主题”，打开“主题详情”。向下滚动到页面底部，您会看到“订阅”部分:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f245d8e764f097d55caa31677f3bffd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*pN3nbDk1oh62UTUwnwIFpQ.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/17995c8aa567677e5490bec416ef578f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*fLxm4K3m-Z681XbSbRAHUQ.png"/></div></figure><p id="4c11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您只需要指定订阅ID，所有其他选项都可以保留为默认值。对于您自己的实际案例，您可能希望根据您的需求对选项进行微调。特别是，我们将在这里创建一个“拉”类型的订阅，这意味着我们需要通过这个订阅从一个主题中显式地拉消息。稍后，我们将创建一个“推送”类型的订阅，将消息推送到云功能并自动触发它。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/69e81e04495a715e2d3c3b7df2d36acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*2bkvkd0SL46WSesrp9ZMcQ.png"/></div></figure><p id="06be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以单击“创建”来创建订阅。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d777" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建一个发布者</strong>。</p><p id="d771" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然已经创建了主题和订阅，我们就可以向主题发布消息，并通过订阅从主题接收消息。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5038" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您需要指定您的GCP项目id和上面创建的主题ID。项目ID可以在Google Cloud控制台上找到，也可以通过<code class="fe nd ne nf mt b">gcloud projects list</code>命令找到。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a17132b484e0b9ce28ace4ead14884e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*bVYQBp3RMZXrAL_hnsgRuQ.png"/></div></figure><p id="e1b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码片段的要点:</p><ul class=""><li id="83eb" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">我们需要使用<em class="mr">发布者</em>的<code class="fe nd ne nf mt b">topic_path</code>方法来获得一个完全合格的主题字符串，看起来像<code class="fe nd ne nf mt b">projects/project-id/topics/topic-id</code>。</li><li id="001f" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><em class="mr">发布者</em>发送的消息必须是字节串。如果不是，它必须被编码成一个字节串。如果您对字符串编码/解码不清楚，请检查此处的<a class="ae lu" href="https://medium.com/codex/understand-the-encoding-decoding-of-python-strings-unicode-utf-8-f6f97a909ee0" rel="noopener">和</a>。</li><li id="6629" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">发布消息时返回“<em class="mr">未来</em>”。您可以调用<em class="mr"> future </em>的<code class="fe nd ne nf mt b">result()</code>方法来返回刚刚发布的消息的消息ID。</li></ul><p id="6c37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<em class="mr">未来</em>的<code class="fe nd ne nf mt b">result()</code>方法阻塞，直到消息成功发送。您可以为<code class="fe nd ne nf mt b">result()</code>设置超时参数。如果消息未在指定时间内发送，将引发<code class="fe nd ne nf mt b">TimeoutError</code>异常。为了让你的代码更高效、更健壮，你可以给<em class="mr">未来</em>添加一个回调函数:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="68e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本部分的要点:</p><ul class=""><li id="62d0" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">我们可以使用<em class="mr">未来</em>的<code class="fe nd ne nf mt b">add_done_callback</code>方法给<em class="mr">未来</em>添加一个回调函数。顾名思义，在<em class="mr">未来</em>解析的时候会调用回调函数。这样，我们就可以使代码非阻塞。同样，解析<em class="mr">未来</em>的异常可以在回调函数中处理。注意<code class="fe nd ne nf mt b">get_callback</code>函数不是真正的回调函数。它像一个工厂一样工作，并返回真正的回调函数，该函数将<em class="mr">未来</em>作为第一个参数。我们需要以这种方式返回回调函数，因为我们希望将消息传递给回调函数，以便在消息未成功发布时记录下来，这有助于调试。</li><li id="e390" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu"><em class="mr"/></strong>库的<strong class="kk iu"> <em class="mr">期货</em> </strong>模块用于将所有<em class="mr">期货</em>一起解析。通过这种方式，我们可以异步发布消息，并且在发布消息时不会被阻塞或导致应用程序崩溃。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a2cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建订户</strong>。</p><p id="b1cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在一些消息已经由发布者发布了，我们可以创建一个订阅者来通过订阅使用来自该主题的消息:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e296" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订户的要点:</p><ul class=""><li id="e3ae" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">正如我们所看到的，我们需要指定一个订阅id来接收来自主题的消息。我们不能直接从一个主题接收消息。</li><li id="63b2" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">我们需要使用<code class="fe nd ne nf mt b">SubscriberClient</code>通过订阅接收来自某个主题的消息。</li><li id="c5e3" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">向订户添加了回调函数。当一些消息发布到主题并通过订阅可用时，回调函数将被自动调用。</li><li id="7727" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">我们需要在收到消息时“确认”消息。否则，消息将被再次传递。</li><li id="7dc7" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">我们使用一个<code class="fe nd ne nf mt b">with</code>块来创建一个上下文管理器，当出现<code class="fe nd ne nf mt b">TimoutError</code>异常时，它会自动关闭订阅者。</li><li id="ded5" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">从技术上讲，在实践中，对于订阅者应用程序，我们不需要也通常不想为订阅者设置超时。订户应该在那里，只要有消息，就处理消息。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="e66c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面我们已经创建了一个<strong class="kk iu"> Pull </strong>类型的订阅，这意味着我们需要显式地从订阅中提取消息。现在让我们创建一个<strong class="kk iu">推送</strong>类型的订阅，当任何消息发布时，它会将消息推送到某个地方，这里是一个云功能。</p><p id="a267" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们创建一个云函数，你会看到它是如何工作的。云函数基础知识请参考<a class="ae lu" href="https://medium.com/codex/learn-how-to-use-google-cloud-functions-in-python-with-a-simple-example-6a50a45603ae" rel="noopener">本文</a>。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi no"><img src="../Images/b2d50a422201a70a15f74360cb21448e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWLeCwZMNKrq6itdm90tCw.png"/></div></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ddddde2ccf72f7ade21223ff103cd92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*h36rn8MEgQtWZPf4WQePXw.png"/></div></figure><p id="213e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">云功能的要点:</p><ul class=""><li id="d526" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">给云函数起一个描述性的名字，选择一个离你最近的地区。</li><li id="dcb0" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">重要的是，在“触发”部分，选择“云发布/订阅”作为触发类型，并选择您在</strong>上面创建的主题id。</li></ul><p id="f292" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，您可以单击“保存”，然后单击“下一步”进入下一步，编写Python代码来接收和处理消息。如果尚未启用“云构建”API，您可能需要启用它。因为，在引擎盖下，<a class="ae lu" href="https://medium.com/codex/build-a-docker-image-with-cloud-build-in-google-cloud-platform-5f6840af2c05" rel="noopener">云构建</a>用于构建云函数的docker映像。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nq"><img src="../Images/010e29e97103f1ac09ebefd39b30af83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WgTPxdt9D4qMoVUOIvyDsQ.png"/></div></div></figure><p id="f539" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尤其是选择最新的Python 3.x作为运行时。如果您创建了多个函数，那么您需要为云函数选择一个入口点函数，当云函数被调用时，这个入口点函数将被调用。实际上，自动创建的伪代码对于这个演示来说已经足够了。在你的实际使用中，这里会有更复杂的逻辑。例如，当收到一些消息时，您可以向您的工作通道发送通知，或者使用<strong class="kk iu"> <em class="mr">请求</em> </strong>模块调用后端API。</p><p id="79d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一切设置好后，点击“部署”即可部署云功能。您需要等到部署云功能后，才能发布新消息。否则，他们不会触发云功能。</p><p id="1fa4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们再次运行上面的发布者代码来发布一些消息。</p><p id="803e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">消息发布后，我们可以去云功能的“日志”查看收到的消息:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nr"><img src="../Images/de49185c951f07c2e3203d8327b7d3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDB9Jwq_-IdAZ7ioMkWoCQ.png"/></div></div></figure><p id="1400" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！消息被“推”到云功能，并在那里使用。如果您没有注意到，我们没有创建<strong class="kk iu">推送</strong>类型的订阅。实际上，我们不必这样做，因为Pub/Sub会自动为我们创建一个:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nr"><img src="../Images/1baa934eb8d36d2786f2c0aa9668c0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CG27JdKKptUA5aOXN_MhDA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b4ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们介绍了Google发布/订阅的基础知识。我们已经学习了如何创建主题和订阅。我们还学习了如何用Python创建简单的发布者和订阅者。此外，我们还介绍了如何创建一个由发布/订阅触发的云功能，为此我们在幕后创建了一个拉式订阅。我希望你喜欢这篇文章，并学到了很多东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4f01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相关文章:</p><ul class=""><li id="1156" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated"><a class="ae lu" href="https://betterprogramming.pub/how-to-use-redis-for-caching-and-pub-sub-in-python-3851174f9fb0?source=your_stories_page----------------------------------------" rel="noopener ugc nofollow" target="_blank">如何在Python中使用Redis进行缓存和发布/订阅</a></li></ul></div></div>    
</body>
</html>