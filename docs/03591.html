<html>
<head>
<title>How to test AWS Lambda locally</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在本地测试AWS Lambda</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-test-aws-lambda-locally-3395ca785276?source=collection_archive---------5-----------------------#2020-05-18">https://levelup.gitconnected.com/how-to-test-aws-lambda-locally-3395ca785276?source=collection_archive---------5-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a0d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AWS Lambda一直在为我们提供许多好处，让我们构建更小的功能，并让它们无服务器运行。你不必担心它被托管或专门为此调试服务器。这样，任何人都可以很容易地在线运行bare mettle quick utility功能，并利用无服务器的力量。</p><p id="2bdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然我们希望对各种问题有一个快速的解决方案，但了解如何测试它也很重要。为此，虽然我们有基于假设的测试，但我们肯定需要一种机制来本地测试它，这可以模拟实际的AWS堆栈。</p><p id="ffa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文将尝试展示我们如何执行AWS Lambda函数来连接MySQL，并通过使用AWS SAM(无服务器应用程序模型)在本地模拟AWS Apigateway来测试它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/69360104700672550be78cd97fdb88b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5mDdYlqXEId3r1HMAhnVg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">连接到MySQL的示例AWS Lambda应用程序</figcaption></figure><h1 id="aef7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何开始？</h1><p id="2a14" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated"><strong class="js iu"> </strong>本文使用的<strong class="js iu"> aws-sam-cli </strong>版本- <strong class="js iu"> 0.48.0 </strong></p><p id="6064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们从初始化一个可以从AWS网关触发Lambda函数的新应用程序开始。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f6c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，无论您看到什么，都非常简单，AWS SAM quick start已经提供了所有内容。</p><p id="4d86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们做得更高级一点！</p><h1 id="7a4a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用数据库调用添加自定义函数</h1><p id="128c" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我想从我的Lambda中进行JDBC调用，并获取每个API调用的结果。在这种情况下，让我使用MySQL服务器，其中，我将从数据库中查询雇员数据，这是一个API作为<strong class="js iu"> GET /employees，</strong>这将从数据库中获取所有雇员。</p><p id="f775" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们创建一个名为<strong class="js iu"> employees </strong>的数据库，然后使用以下代码创建一个表:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8e37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将MySQL驱动程序添加到pom.xml，如下所示:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="be6a" class="mo lf it mk b gy mp mq l mr ms">&lt;!-- <a class="ae mt" href="https://mvnrepository.com/artifact/mysql/mysql-connector-java" rel="noopener ugc nofollow" target="_blank">https://mvnrepository.com/artifact/mysql/mysql-connector-java</a> --&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br/>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br/>    &lt;version&gt;8.0.19&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="3f89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，创建一个新函数，并将其添加到已经存在的template.yaml下，如下所示:(注意:我添加了一个新函数- <strong class="js iu"> EmployeeFunction </strong>)</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="fff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在我用一个全新的样本模块创建了一个新函数之后，这个新函数的名称为<strong class="js iu"> EmployeeFunction </strong>，代码如下，用于获取数据:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="638c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mu">注意</em> </strong> : <strong class="js iu">创建Employee </strong>类来存储和保存结果。这是一个简单的java POJO类。同样，<strong class="js iu"> GatewayResponse </strong>类也是出现在<strong class="js iu"> HelloWorldFunction </strong>中的同一个类。</p><p id="c460" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们按如下方式构建项目:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="96e4" class="mo lf it mk b gy mp mq l mr ms"><strong class="mk iu">sam build</strong></span></pre><p id="7bf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以通过选择特定的函数在本地调用它，如下所示:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="ac27" class="mo lf it mk b gy mp mq l mr ms"><strong class="mk iu">sam local invoke “EmployeeFunction”</strong></span></pre><p id="81f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为正常的employees函数将调用/employees，所以输出将是:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="6a3c" class="mo lf it mk b gy mp mq l mr ms">[<br/>  {<br/>    "Id": "1",<br/>    "Name": "Nagaraj",<br/>    "Salary": "123450"<br/>  },<br/>  {<br/>    "Id": "2",<br/>    "Name": "Arpitha",<br/>    "Salary": "123456"<br/>  }<br/>]</span></pre><p id="3462" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我可以描述从API网关到函数的相同API调用，以及在docker中执行的所有调用，就像无服务器Lambda函数一样。</p><p id="6480" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了也考虑传递一个路径参数，我们可以把它作为一个API来启动:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="437f" class="mo lf it mk b gy mp mq l mr ms">sam local start-api</span></pre><p id="7aa2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后使用路径参数1(第一个雇员id，基于显示的结果)运行:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="a18d" class="mo lf it mk b gy mp mq l mr ms">curl http://127.0.0.1:&lt;port_number&gt;/employee/1</span></pre><p id="6fa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将打印:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="31b1" class="mo lf it mk b gy mp mq l mr ms">[<br/>  {<br/>    "Id": "1",<br/>    "Name": "Nagaraj",<br/>    "Salary": "123450"<br/>  }<br/>]</span></pre><h1 id="6cd6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最后的话！</h1><p id="24fb" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这个本地测试帮助我了解了它实际上是如何工作的。如果这不可用，那么我们将不得不通过反复试验在AWS控制台上测试它。</p><h1 id="ddf7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更多博客更新…</h1><p id="6fa3" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">查看我最新的博客:</p><div class="mv mw gp gr mx my"><a href="https://medium.com/miq-tech-and-analytics/ingesting-terabytes-of-data-every-day-using-microservices-architecture-at-miq-7ade41256a7f" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">每天接收数TB的数据——在MiQ使用微服务架构</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">MiQ的批量摄取之旅</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ky my"/></div></div></a></div></div></div>    
</body>
</html>