<html>
<head>
<title>Making Chess in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python制作象棋</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/chess-python-ca4532c7f5a4?source=collection_archive---------0-----------------------#2020-12-23">https://levelup.gitconnected.com/chess-python-ca4532c7f5a4?source=collection_archive---------0-----------------------#2020-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/255a05c76bf671db1dba6e0c2628040b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uD3OhzkYPaNHr2070jgUww.png"/></div></div></figure><blockquote class="jy jz ka"><p id="055e" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我将首先描述发生了什么，然后展示代码。</p></blockquote><p id="118e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这是我和一个朋友在学校进行的一个大项目。这很有趣，因为我们已经计划了几个月，7天后我们就完成了整个项目。我必须说，如果没有我的朋友埃德温的帮助，这是不可能的。首先，我们抽象了整个游戏，因为这是一个非常复杂的游戏编码，我们决定我将负责界面(用户可以看到的)，而埃德温负责每个部分的实际行为。他们都有自己的困难，我们确实需要协调很多，所以我们并不是没有互相帮助，例如，我确实教了他一点列表理解，以加快他的代码，而他揭露了我的相当愚蠢的错误，做列行而不是行列。</p><p id="2a0c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这段代码是我写的所有东西，旁边还有一些字典和上面的方法。首先我们创建一个窗口对象，它是我们运行国际象棋游戏时出现的窗口。我们将维度设置为800x800，这是我们传递给它的元组参数。我们特别选择了800 x 800，因为我们硬拼的国际象棋棋子的图像都是100x100，这意味着如果棋盘是800x800，它会非常适合。</p><p id="bea7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">使我的程序工作的主要东西是这些节点对象，它们只是保存棋子的容器(在这种情况下，它们被模拟为棋盘的瓷砖)。它们有自己的属性，即行、列、x、y坐标。我们分别需要这些，因为所有这些节点都将存储在一个8×8的2d列表中，所以如果我们调用它，我们需要使用它的行号和列号来调用它，而如果我们将它绘制到屏幕上，我们需要它的x，y像素值(我们可以只做row*100，但这将冒着我们忘记在整个代码中添加1次并看着整个东西崩溃的风险)。</p><p id="400d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">draw函数用于将图块绘制到屏幕上(因此是黑白图案)，而setup方法用于将任何图像绘制到屏幕上(如果我们在屏幕上的那个位置有一个图块)。你用blit在屏幕上绘图。</p><p id="52c5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">“绘制网格”绘制网格的边界(因此黑色的水平线和垂直线分隔了图块)“绘制网格”和“制作网格”正在创建2d列表，稍后将使用该列表来访问所有节点。更新显示用于在每次滴答时更新屏幕。我认为为了避免CPU过载，我们选择以20fps运行程序，这对于国际象棋来说是完全不合理的，但我们不想有太多的延迟。</p><p id="d510" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">当用户点击屏幕时，我们需要弄清楚他们点击了哪个磁贴，这就是find_node的功能。Display_potential_moves是edwin做的一个函数，但它只需要一个潜在移动的列表，并为这些移动改变瓷砖的颜色，使其突出。</p><p id="d5a1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Do_move用于acc在屏幕上进行交换，但是交换我的字典上的值，当屏幕更新时，这个变化将在屏幕上可见。</p><p id="f51f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">使用remove_highlight是因为很难移除特定图块的高光，所以我们决定只为所有图块重绘黑色。</p><p id="b2cb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">主函数包含了很多标准逻辑，如果你懂pygame的话，我希望你能理解。我会在这里附上一个视频，以防你没有</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="21e1" class="lm ln iq li b gy lo lp l lq lr">import pygame<br/><br/>import time<br/><br/>import sys<br/><br/>board = [['  ' for i in range(8)] for i in range(8)]<br/><br/>## Creates a chess piece class that shows what team a piece is on, what type of piece it is and whether or not it can be killed by another selected piece.<br/>class Piece:<br/>    def __init__(self, team, type, image, killable=False):<br/>        self.team = team<br/>        self.type = type<br/>        self.killable = killable<br/>        self.image = image<br/><br/><br/>## Creates instances of chess pieces, so far we got: pawn, king, rook and bishop<br/>## The first parameter defines what team its on and the second, what type of piece it is<br/>bp = Piece('b', 'p', 'b_pawn.png')<br/>wp = Piece('w', 'p', 'w_pawn.png')<br/>bk = Piece('b', 'k', 'b_king.png')<br/>wk = Piece('w', 'k', 'w_king.png')<br/>br = Piece('b', 'r', 'b_rook.png')<br/>wr = Piece('w', 'r', 'w_rook.png')<br/>bb = Piece('b', 'b', 'b_bishop.png')<br/>wb = Piece('w', 'b', 'w_bishop.png')<br/>bq = Piece('b', 'q', 'b_queen.png')<br/>wq = Piece('w', 'q', 'w_queen.png')<br/>bkn = Piece('b', 'kn', 'b_knight.png')<br/>wkn = Piece('w', 'kn', 'w_knight.png')<br/><br/><br/>starting_order = {(0, 0): pygame.image.load(br.image), (1, 0): pygame.image.load(bkn.image),<br/>                  (2, 0): pygame.image.load(bb.image), (3, 0): pygame.image.load(bk.image),<br/>                  (4, 0): pygame.image.load(bq.image), (5, 0): pygame.image.load(bb.image),<br/>                  (6, 0): pygame.image.load(bkn.image), (7, 0): pygame.image.load(br.image),<br/>                  (0, 1): pygame.image.load(bp.image), (1, 1): pygame.image.load(bp.image),<br/>                  (2, 1): pygame.image.load(bp.image), (3, 1): pygame.image.load(bp.image),<br/>                  (4, 1): pygame.image.load(bp.image), (5, 1): pygame.image.load(bp.image),<br/>                  (6, 1): pygame.image.load(bp.image), (7, 1): pygame.image.load(bp.image),<br/><br/>                  (0, 2): None, (1, 2): None, (2, 2): None, (3, 2): None,<br/>                  (4, 2): None, (5, 2): None, (6, 2): None, (7, 2): None,<br/>                  (0, 3): None, (1, 3): None, (2, 3): None, (3, 3): None,<br/>                  (4, 3): None, (5, 3): None, (6, 3): None, (7, 3): None,<br/>                  (0, 4): None, (1, 4): None, (2, 4): None, (3, 4): None,<br/>                  (4, 4): None, (5, 4): None, (6, 4): None, (7, 4): None,<br/>                  (0, 5): None, (1, 5): None, (2, 5): None, (3, 5): None,<br/>                  (4, 5): None, (5, 5): None, (6, 5): None, (7, 5): None,<br/><br/>                  (0, 6): pygame.image.load(wp.image), (1, 6): pygame.image.load(wp.image),<br/>                  (2, 6): pygame.image.load(wp.image), (3, 6): pygame.image.load(wp.image),<br/>                  (4, 6): pygame.image.load(wp.image), (5, 6): pygame.image.load(wp.image),<br/>                  (6, 6): pygame.image.load(wp.image), (7, 6): pygame.image.load(wp.image),<br/>                  (0, 7): pygame.image.load(wr.image), (1, 7): pygame.image.load(wkn.image),<br/>                  (2, 7): pygame.image.load(wb.image), (3, 7): pygame.image.load(wk.image),<br/>                  (4, 7): pygame.image.load(wq.image), (5, 7): pygame.image.load(wb.image),<br/>                  (6, 7): pygame.image.load(wkn.image), (7, 7): pygame.image.load(wr.image),}<br/><br/><br/>def create_board(board):<br/>    board[0] = [Piece('b', 'r', 'b_rook.png'), Piece('b', 'kn', 'b_knight.png'), Piece('b', 'b', 'b_bishop.png'), \<br/>               Piece('b', 'q', 'b_queen.png'), Piece('b', 'k', 'b_king.png'), Piece('b', 'b', 'b_bishop.png'), \<br/>               Piece('b', 'kn', 'b_knight.png'), Piece('b', 'r', 'b_rook.png')]<br/><br/>    board[7] = [Piece('w', 'r', 'w_rook.png'), Piece('w', 'kn', 'w_knight.png'), Piece('w', 'b', 'w_bishop.png'), \<br/>               Piece('w', 'q', 'w_queen.png'), Piece('w', 'k', 'w_king.png'), Piece('w', 'b', 'w_bishop.png'), \<br/>               Piece('w', 'kn', 'w_knight.png'), Piece('w', 'r', 'w_rook.png')]<br/><br/>    for i in range(8):<br/>        board[1][i] = Piece('b', 'p', 'b_pawn.png')<br/>        board[6][i] = Piece('w', 'p', 'w_pawn.png')<br/>    return board<br/><br/><br/>## returns the input if the input is within the boundaries of the board<br/>def on_board(position):<br/>    if position[0] &gt; -1 and position[1] &gt; -1 and position[0] &lt; 8 and position[1] &lt; 8:<br/>        return True<br/><br/><br/>## returns a string that places the rows and columns of the board in a readable manner<br/>def convert_to_readable(board):<br/>    output = ''<br/><br/>    for i in board:<br/>        for j in i:<br/>            try:<br/>                output += j.team + j.type + ', '<br/>            except:<br/>                output += j + ', '<br/>        output += '\n'<br/>    return output<br/><br/><br/>## resets "x's" and killable pieces<br/>def deselect():<br/>    for row in range(len(board)):<br/>        for column in range(len(board[0])):<br/>            if board[row][column] == 'x ':<br/>                board[row][column] = '  '<br/>            else:<br/>                try:<br/>                    board[row][column].killable = False<br/>                except:<br/>                    pass<br/>    return convert_to_readable(board)<br/><br/><br/>## Takes in board as argument then returns 2d array containing positions of valid moves<br/>def highlight(board):<br/>    highlighted = []<br/>    for i in range(len(board)):<br/>        for j in range(len(board[0])):<br/>            if board[i][j] == 'x ':<br/>                highlighted.append((i, j))<br/>            else:<br/>                try:<br/>                    if board[i][j].killable:<br/>                        highlighted.append((i, j))<br/>                except:<br/>                    pass<br/>    return highlighted<br/><br/>def check_team(moves, index):<br/>    row, col = index<br/>    if moves%2 == 0:<br/>        if board[row][col].team == 'w':<br/>            return True<br/>    else:<br/>        if board[row][col].team == 'b':<br/>            return True<br/><br/>## This takes in a piece object and its index then runs then checks where that piece can move using separately defined functions for each type of piece.<br/>def select_moves(piece, index, moves):<br/>    if check_team(moves, index):<br/>        if piece.type == 'p':<br/>            if piece.team == 'b':<br/>                return highlight(pawn_moves_b(index))<br/>            else:<br/>                return highlight(pawn_moves_w(index))<br/><br/>        if piece.type == 'k':<br/>            return highlight(king_moves(index))<br/><br/>        if piece.type == 'r':<br/>            return highlight(rook_moves(index))<br/><br/>        if piece.type == 'b':<br/>            return highlight(bishop_moves(index))<br/><br/>        if piece.type == 'q':<br/>            return highlight(queen_moves(index))<br/><br/>        if piece.type == 'kn':<br/>            return highlight(knight_moves(index))<br/><br/><br/>## Basically, check black and white pawns separately and checks the square above them. If its free that space gets an "x" and if it is occupied by a piece of the opposite team then that piece becomes killable.<br/>def pawn_moves_b(index):<br/>    if index[0] == 1:<br/>        if board[index[0] + 2][index[1]] == '  ' and board[index[0] + 1][index[1]] == '  ':<br/>            board[index[0] + 2][index[1]] = 'x '<br/>    bottom3 = [[index[0] + 1, index[1] + i] for i in range(-1, 2)]<br/><br/>    for positions in bottom3:<br/>        if on_board(positions):<br/>            if bottom3.index(positions) % 2 == 0:<br/>                try:<br/>                    if board[positions[0]][positions[1]].team != 'b':<br/>                        board[positions[0]][positions[1]].killable = True<br/>                except:<br/>                    pass<br/>            else:<br/>                if board[positions[0]][positions[1]] == '  ':<br/>                    board[positions[0]][positions[1]] = 'x '<br/>    return board<br/><br/>def pawn_moves_w(index):<br/>    if index[0] == 6:<br/>        if board[index[0] - 2][index[1]] == '  ' and board[index[0] - 1][index[1]] == '  ':<br/>            board[index[0] - 2][index[1]] = 'x '<br/>    top3 = [[index[0] - 1, index[1] + i] for i in range(-1, 2)]<br/><br/>    for positions in top3:<br/>        if on_board(positions):<br/>            if top3.index(positions) % 2 == 0:<br/>                try:<br/>                    if board[positions[0]][positions[1]].team != 'w':<br/>                        board[positions[0]][positions[1]].killable = True<br/>                except:<br/>                    pass<br/>            else:<br/>                if board[positions[0]][positions[1]] == '  ':<br/>                    board[positions[0]][positions[1]] = 'x '<br/>    return board<br/><br/><br/>## This just checks a 3x3 tile surrounding the king. Empty spots get an "x" and pieces of the opposite team become killable.<br/>def king_moves(index):<br/>    for y in range(3):<br/>        for x in range(3):<br/>            if on_board((index[0] - 1 + y, index[1] - 1 + x)):<br/>                if board[index[0] - 1 + y][index[1] - 1 + x] == '  ':<br/>                    board[index[0] - 1 + y][index[1] - 1 + x] = 'x '<br/>                else:<br/>                    if board[index[0] - 1 + y][index[1] - 1 + x].team != board[index[0]][index[1]].team:<br/>                        board[index[0] - 1 + y][index[1] - 1 + x].killable = True<br/>    return board<br/><br/><br/>## This creates 4 lists for up, down, left and right and checks all those spaces for pieces of the opposite team. The list comprehension is pretty long so if you don't get it just msg me.<br/>def rook_moves(index):<br/>    cross = [[[index[0] + i, index[1]] for i in range(1, 8 - index[0])],<br/>             [[index[0] - i, index[1]] for i in range(1, index[0] + 1)],<br/>             [[index[0], index[1] + i] for i in range(1, 8 - index[1])],<br/>             [[index[0], index[1] - i] for i in range(1, index[1] + 1)]]<br/><br/>    for direction in cross:<br/>        for positions in direction:<br/>            if on_board(positions):<br/>                if board[positions[0]][positions[1]] == '  ':<br/>                    board[positions[0]][positions[1]] = 'x '<br/>                else:<br/>                    if board[positions[0]][positions[1]].team != board[index[0]][index[1]].team:<br/>                        board[positions[0]][positions[1]].killable = True<br/>                    break<br/>    return board<br/><br/><br/>## Same as the rook but this time it creates 4 lists for the diagonal directions and so the list comprehension is a little bit trickier.<br/>def bishop_moves(index):<br/>    diagonals = [[[index[0] + i, index[1] + i] for i in range(1, 8)],<br/>                 [[index[0] + i, index[1] - i] for i in range(1, 8)],<br/>                 [[index[0] - i, index[1] + i] for i in range(1, 8)],<br/>                 [[index[0] - i, index[1] - i] for i in range(1, 8)]]<br/><br/>    for direction in diagonals:<br/>        for positions in direction:<br/>            if on_board(positions):<br/>                if board[positions[0]][positions[1]] == '  ':<br/>                    board[positions[0]][positions[1]] = 'x '<br/>                else:<br/>                    if board[positions[0]][positions[1]].team != board[index[0]][index[1]].team:<br/>                        board[positions[0]][positions[1]].killable = True<br/>                    break<br/>    return board<br/><br/><br/>## applies the rook moves to the board then the bishop moves because a queen is basically a rook and bishop in the same position.<br/>def queen_moves(index):<br/>    board = rook_moves(index)<br/>    board = bishop_moves(index)<br/>    return board<br/><br/><br/>## Checks a 5x5 grid around the piece and uses pythagoras to see if if a move is valid. Valid moves will be a distance of sqrt(5) from centre<br/>def knight_moves(index):<br/>    for i in range(-2, 3):<br/>        for j in range(-2, 3):<br/>            if i ** 2 + j ** 2 == 5:<br/>                if on_board((index[0] + i, index[1] + j)):<br/>                    if board[index[0] + i][index[1] + j] == '  ':<br/>                        board[index[0] + i][index[1] + j] = 'x '<br/>                    else:<br/>                        if board[index[0] + i][index[1] + j].team != board[index[0]][index[1]].team:<br/>                            board[index[0] + i][index[1] + j].killable = True<br/>    return board<br/><br/><br/>WIDTH = 800<br/><br/>WIN = pygame.display.set_mode((WIDTH, WIDTH))<br/><br/>""" This is creating the window that we are playing on, it takes a tuple argument which is the dimensions of the window so in this case 800 x 800px<br/>"""<br/><br/>pygame.display.set_caption("Chess")<br/>WHITE = (255, 255, 255)<br/>GREY = (128, 128, 128)<br/>YELLOW = (204, 204, 0)<br/>BLUE = (50, 255, 255)<br/>BLACK = (0, 0, 0)<br/><br/><br/>class Node:<br/>    def __init__(self, row, col, width):<br/>        self.row = row<br/>        self.col = col<br/>        self.x = int(row * width)<br/>        self.y = int(col * width)<br/>        self.colour = WHITE<br/>        self.occupied = None<br/><br/>    def draw(self, WIN):<br/>        pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / 8, WIDTH / 8))<br/><br/>    def setup(self, WIN):<br/>        if starting_order[(self.row, self.col)]:<br/>            if starting_order[(self.row, self.col)] == None:<br/>                pass<br/>            else:<br/>                WIN.blit(starting_order[(self.row, self.col)], (self.x, self.y))<br/><br/>        """<br/>        For now it is drawing a rectangle but eventually we are going to need it<br/>        to use blit to draw the chess pieces instead<br/>        """<br/><br/><br/>def make_grid(rows, width):<br/>    grid = []<br/>    gap = WIDTH // rows<br/>    print(gap)<br/>    for i in range(rows):<br/>        grid.append([])<br/>        for j in range(rows):<br/>            node = Node(j, i, gap)<br/>            grid[i].append(node)<br/>            if (i+j)%2 ==1:<br/>                grid[i][j].colour = GREY<br/>    return grid<br/>"""<br/>This is creating the nodes thats are on the board(so the chess tiles)<br/>I've put them into a 2d array which is identical to the dimesions of the chessboard<br/>"""<br/><br/><br/>def draw_grid(win, rows, width):<br/>    gap = width // 8<br/>    for i in range(rows):<br/>        pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))<br/>        for j in range(rows):<br/>            pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))<br/><br/>    """<br/>    The nodes are all white so this we need to draw the grey lines that separate all the chess tiles<br/>    from each other and that is what this function does"""<br/><br/><br/>def update_display(win, grid, rows, width):<br/>    for row in grid:<br/>        for spot in row:<br/>            spot.draw(win)<br/>            spot.setup(win)<br/>    draw_grid(win, rows, width)<br/>    pygame.display.update()<br/><br/><br/>def Find_Node(pos, WIDTH):<br/>    interval = WIDTH / 8<br/>    y, x = pos<br/>    rows = y // interval<br/>    columns = x // interval<br/>    return int(rows), int(columns)<br/><br/><br/>def display_potential_moves(positions, grid):<br/>    for i in positions:<br/>        x, y = i<br/>        grid[x][y].colour = BLUE<br/>        """<br/>        Displays all the potential moves<br/>        """<br/><br/><br/>def Do_Move(OriginalPos, FinalPosition, WIN):<br/>    starting_order[FinalPosition] = starting_order[OriginalPos]<br/>    starting_order[OriginalPos] = None<br/><br/><br/>def remove_highlight(grid):<br/>    for i in range(len(grid)):<br/>        for j in range(len(grid[0])):<br/>            if (i+j)%2 == 0:<br/>                grid[i][j].colour = WHITE<br/>            else:<br/>                grid[i][j].colour = GREY<br/>    return grid<br/>"""this takes in 2 co-ordinate parameters which you can get as the position of the piece and then the position of the node it is moving to<br/>you can get those co-ordinates using my old function for swap"""<br/><br/>create_board(board)<br/><br/><br/>def main(WIN, WIDTH):<br/>    moves = 0<br/>    selected = False<br/>    piece_to_move=[]<br/>    grid = make_grid(8, WIDTH)<br/>    while True:<br/>        pygame.time.delay(50) ##stops cpu dying<br/>        for event in pygame.event.get():<br/>            if event.type == pygame.QUIT:<br/>                pygame.quit()<br/>                sys.exit()<br/><br/>            """This quits the program if the player closes the window"""<br/><br/>            if event.type == pygame.MOUSEBUTTONDOWN:<br/>                pos = pygame.mouse.get_pos()<br/>                y, x = Find_Node(pos, WIDTH)<br/>                if selected == False:<br/>                    try:<br/>                        possible = select_moves((board[x][y]), (x,y), moves)<br/>                        for positions in possible:<br/>                            row, col = positions<br/>                            grid[row][col].colour = BLUE<br/>                        piece_to_move = x,y<br/>                        selected = True<br/>                    except:<br/>                        piece_to_move = []<br/>                        print('Can\'t select')<br/>                    #print(piece_to_move)<br/><br/>                else:<br/>                    try:<br/>                        if board[x][y].killable == True:<br/>                            row, col = piece_to_move ## coords of original piece<br/>                            board[x][y] = board[row][col]<br/>                            board[row][col] = '  '<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            Do_Move((col, row), (y, x), WIN)<br/>                            moves += 1<br/>                            print(convert_to_readable(board))<br/>                        else:<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            selected = False<br/>                            print("Deselected")<br/>                    except:<br/>                        if board[x][y] == 'x ':<br/>                            row, col = piece_to_move<br/>                            board[x][y] = board[row][col]<br/>                            board[row][col] = '  '<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            Do_Move((col, row), (y, x), WIN)<br/>                            moves += 1<br/>                            print(convert_to_readable(board))<br/>                        else:<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            selected = False<br/>                            print("Invalid move")<br/>                    selected = False<br/><br/>            update_display(WIN, grid, 8, WIDTH)<br/><br/><br/>main(WIN, WIDTH)</span></pre><p id="7088" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果我要解释整个代码，这将花费几个小时来编写，所以我将解释其中的功能和任何复杂的概念，并让您来解决其余的问题。</p><p id="0040" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke ir">代码解释:</strong></p><p id="afd3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们用pygame编写了这个程序，因为它可以很容易地给我们提供接口，而且我有使用A*算法制作网格的经验，所以大部分网格都是从中回收的代码。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="2d82" class="lm ln iq li b gy lo lp l lq lr">board = [['  ' for i in range(8)] for i in range(8)]<br/><br/>## Creates a chess piece class that shows what team a piece is on, what type of piece it is and whether or not it can be killed by another selected piece.<br/>class Piece:<br/>    def __init__(self, team, type, image, killable=False):<br/>        self.team = team<br/>        self.type = type<br/>        self.killable = killable<br/>        self.image = image<br/><br/><br/>## Creates instances of chess pieces, so far we got: pawn, king, rook and bishop<br/>## The first parameter defines what team its on and the second, what type of piece it is<br/>bp = Piece('b', 'p', 'b_pawn.png')<br/>wp = Piece('w', 'p', 'w_pawn.png')<br/>bk = Piece('b', 'k', 'b_king.png')<br/>wk = Piece('w', 'k', 'w_king.png')<br/>br = Piece('b', 'r', 'b_rook.png')<br/>wr = Piece('w', 'r', 'w_rook.png')<br/>bb = Piece('b', 'b', 'b_bishop.png')<br/>wb = Piece('w', 'b', 'w_bishop.png')<br/>bq = Piece('b', 'q', 'b_queen.png')<br/>wq = Piece('w', 'q', 'w_queen.png')<br/>bkn = Piece('b', 'kn', 'b_knight.png')<br/>wkn = Piece('w', 'kn', 'w_knight.png')<br/><br/><br/>starting_order = {(0, 0): pygame.image.load(br.image), (1, 0): pygame.image.load(bkn.image),<br/>                  (2, 0): pygame.image.load(bb.image), (3, 0): pygame.image.load(bk.image),<br/>                  (4, 0): pygame.image.load(bq.image), (5, 0): pygame.image.load(bb.image),<br/>                  (6, 0): pygame.image.load(bkn.image), (7, 0): pygame.image.load(br.image),<br/>                  (0, 1): pygame.image.load(bp.image), (1, 1): pygame.image.load(bp.image),<br/>                  (2, 1): pygame.image.load(bp.image), (3, 1): pygame.image.load(bp.image),<br/>                  (4, 1): pygame.image.load(bp.image), (5, 1): pygame.image.load(bp.image),<br/>                  (6, 1): pygame.image.load(bp.image), (7, 1): pygame.image.load(bp.image),<br/><br/>                  (0, 2): None, (1, 2): None, (2, 2): None, (3, 2): None,<br/>                  (4, 2): None, (5, 2): None, (6, 2): None, (7, 2): None,<br/>                  (0, 3): None, (1, 3): None, (2, 3): None, (3, 3): None,<br/>                  (4, 3): None, (5, 3): None, (6, 3): None, (7, 3): None,<br/>                  (0, 4): None, (1, 4): None, (2, 4): None, (3, 4): None,<br/>                  (4, 4): None, (5, 4): None, (6, 4): None, (7, 4): None,<br/>                  (0, 5): None, (1, 5): None, (2, 5): None, (3, 5): None,<br/>                  (4, 5): None, (5, 5): None, (6, 5): None, (7, 5): None,<br/><br/>                  (0, 6): pygame.image.load(wp.image), (1, 6): pygame.image.load(wp.image),<br/>                  (2, 6): pygame.image.load(wp.image), (3, 6): pygame.image.load(wp.image),<br/>                  (4, 6): pygame.image.load(wp.image), (5, 6): pygame.image.load(wp.image),<br/>                  (6, 6): pygame.image.load(wp.image), (7, 6): pygame.image.load(wp.image),<br/>                  (0, 7): pygame.image.load(wr.image), (1, 7): pygame.image.load(wkn.image),<br/>                  (2, 7): pygame.image.load(wb.image), (3, 7): pygame.image.load(wk.image),<br/>                  (4, 7): pygame.image.load(wq.image), (5, 7): pygame.image.load(wb.image),<br/>                  (6, 7): pygame.image.load(wkn.image), (7, 7): pygame.image.load(wr.image),}<br/><br/><br/>def create_board(board):<br/>    board[0] = [Piece('b', 'r', 'b_rook.png'), Piece('b', 'kn', 'b_knight.png'), Piece('b', 'b', 'b_bishop.png'), \<br/>               Piece('b', 'q', 'b_queen.png'), Piece('b', 'k', 'b_king.png'), Piece('b', 'b', 'b_bishop.png'), \<br/>               Piece('b', 'kn', 'b_knight.png'), Piece('b', 'r', 'b_rook.png')]<br/><br/>    board[7] = [Piece('w', 'r', 'w_rook.png'), Piece('w', 'kn', 'w_knight.png'), Piece('w', 'b', 'w_bishop.png'), \<br/>               Piece('w', 'q', 'w_queen.png'), Piece('w', 'k', 'w_king.png'), Piece('w', 'b', 'w_bishop.png'), \<br/>               Piece('w', 'kn', 'w_knight.png'), Piece('w', 'r', 'w_rook.png')]<br/><br/>    for i in range(8):<br/>        board[1][i] = Piece('b', 'p', 'b_pawn.png')<br/>        board[6][i] = Piece('w', 'p', 'w_pawn.png')<br/>    return board<br/></span></pre><p id="d3ea" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">除了从开始订单字典，所有这些都是埃德温的代码，所有这些都用于移动计算。理论上，你可以像他一样只使用字典或2d列表中的一个来完成这项工作，但由于我们在编码时都需要访问数组，并且我们不能共享python脚本，所以我们制作了自己的版本。Edwin为棋子创建了一个类，因为它更容易管理，在底部，他正在设置他的2d列表，以便所有的棋子都在它们的起始位置。在我的字典中，我自动地硬写了所有的位置，因为我需要将每个单独的图像文件的名称放入加载中。pygame.image.load()将图像加载到python文件中，然后我们只需要将图像绘制到屏幕上。这种方式比先加载图像然后再绘图要好，因为这意味着我们只需要为整个程序加载一次图像，然后将图像转换到屏幕上的新位置。</p><p id="6fd0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">edwins代码的其余部分非常简单明了，只需选择每个棋子可以移动到的正确位置，然后将这些“合法”的棋子放到棋盘上，供我们在界面上使用，以突出显示棋盘。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="02ef" class="lm ln iq li b gy lo lp l lq lr">WIDTH = 800<br/><br/>WIN = pygame.display.set_mode((WIDTH, WIDTH))<br/><br/>""" This is creating the window that we are playing on, it takes a tuple argument which is the dimensions of the window so in this case 800 x 800px<br/>"""<br/><br/>pygame.display.set_caption("Chess")<br/>WHITE = (255, 255, 255)<br/>GREY = (128, 128, 128)<br/>YELLOW = (204, 204, 0)<br/>BLUE = (50, 255, 255)<br/>BLACK = (0, 0, 0)<br/><br/><br/>class Node:<br/>    def __init__(self, row, col, width):<br/>        self.row = row<br/>        self.col = col<br/>        self.x = int(row * width)<br/>        self.y = int(col * width)<br/>        self.colour = WHITE<br/>        self.occupied = None<br/><br/>    def draw(self, WIN):<br/>        pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / 8, WIDTH / 8))<br/><br/>    def setup(self, WIN):<br/>        if starting_order[(self.row, self.col)]:<br/>            if starting_order[(self.row, self.col)] == None:<br/>                pass<br/>            else:<br/>                WIN.blit(starting_order[(self.row, self.col)], (self.x, self.y))<br/><br/>        """<br/>        For now it is drawing a rectangle but eventually we are going to need it<br/>        to use blit to draw the chess pieces instead<br/>        """<br/><br/><br/>def make_grid(rows, width):<br/>    grid = []<br/>    gap = WIDTH // rows<br/>    print(gap)<br/>    for i in range(rows):<br/>        grid.append([])<br/>        for j in range(rows):<br/>            node = Node(j, i, gap)<br/>            grid[i].append(node)<br/>            if (i+j)%2 ==1:<br/>                grid[i][j].colour = GREY<br/>    return grid<br/>"""<br/>This is creating the nodes thats are on the board(so the chess tiles)<br/>I've put them into a 2d array which is identical to the dimesions of the chessboard<br/>"""<br/><br/><br/>def draw_grid(win, rows, width):<br/>    gap = width // 8<br/>    for i in range(rows):<br/>        pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))<br/>        for j in range(rows):<br/>            pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))<br/><br/>    """<br/>    The nodes are all white so this we need to draw the grey lines that separate all the chess tiles<br/>    from each other and that is what this function does"""<br/><br/><br/>def update_display(win, grid, rows, width):<br/>    for row in grid:<br/>        for spot in row:<br/>            spot.draw(win)<br/>            spot.setup(win)<br/>    draw_grid(win, rows, width)<br/>    pygame.display.update()<br/><br/><br/>def Find_Node(pos, WIDTH):<br/>    interval = WIDTH / 8<br/>    y, x = pos<br/>    rows = y // interval<br/>    columns = x // interval<br/>    return int(rows), int(columns)<br/><br/><br/>def display_potential_moves(positions, grid):<br/>    for i in positions:<br/>        x, y = i<br/>        grid[x][y].colour = BLUE<br/>        """<br/>        Displays all the potential moves<br/>        """<br/><br/><br/>def Do_Move(OriginalPos, FinalPosition, WIN):<br/>    starting_order[FinalPosition] = starting_order[OriginalPos]<br/>    starting_order[OriginalPos] = None<br/><br/><br/>def remove_highlight(grid):<br/>    for i in range(len(grid)):<br/>        for j in range(len(grid[0])):<br/>            if (i+j)%2 == 0:<br/>                grid[i][j].colour = WHITE<br/>            else:<br/>                grid[i][j].colour = GREY<br/>    return grid<br/>"""this takes in 2 co-ordinate parameters which you can get as the position of the piece and then the position of the node it is moving to<br/>you can get those co-ordinates using my old function for swap"""<br/><br/>create_board(board)<br/><br/><br/>def main(WIN, WIDTH):<br/>    moves = 0<br/>    selected = False<br/>    piece_to_move=[]<br/>    grid = make_grid(8, WIDTH)<br/>    while True:<br/>        pygame.time.delay(50) ##stops cpu dying<br/>        for event in pygame.event.get():<br/>            if event.type == pygame.QUIT:<br/>                pygame.quit()<br/>                sys.exit()<br/><br/>            """This quits the program if the player closes the window"""<br/><br/>            if event.type == pygame.MOUSEBUTTONDOWN:<br/>                pos = pygame.mouse.get_pos()<br/>                y, x = Find_Node(pos, WIDTH)<br/>                if selected == False:<br/>                    try:<br/>                        possible = select_moves((board[x][y]), (x,y), moves)<br/>                        for positions in possible:<br/>                            row, col = positions<br/>                            grid[row][col].colour = BLUE<br/>                        piece_to_move = x,y<br/>                        selected = True<br/>                    except:<br/>                        piece_to_move = []<br/>                        print('Can\'t select')<br/>                    #print(piece_to_move)<br/><br/>                else:<br/>                    try:<br/>                        if board[x][y].killable == True:<br/>                            row, col = piece_to_move ## coords of original piece<br/>                            board[x][y] = board[row][col]<br/>                            board[row][col] = '  '<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            Do_Move((col, row), (y, x), WIN)<br/>                            moves += 1<br/>                            print(convert_to_readable(board))<br/>                        else:<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            selected = False<br/>                            print("Deselected")<br/>                    except:<br/>                        if board[x][y] == 'x ':<br/>                            row, col = piece_to_move<br/>                            board[x][y] = board[row][col]<br/>                            board[row][col] = '  '<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            Do_Move((col, row), (y, x), WIN)<br/>                            moves += 1<br/>                            print(convert_to_readable(board))<br/>                        else:<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            selected = False<br/>                            print("Invalid move")<br/>                    selected = False<br/><br/>            update_display(WIN, grid, 8, WIDTH)<br/><br/><br/>main(WIN, WIDTH)</span></pre><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="ls lt l"/></div></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="e6c1" class="mb ln iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">分级编码</h1><p id="9489" class="pw-post-body-paragraph kb kc iq ke b kf my kh ki kj mz kl km la na kp kq lb nb kt ku lc nc kx ky kz ij bi translated">感谢您成为我们社区的一员！升级正在改变技术招聘。<a class="ae nd" href="https://jobs.levelup.dev/talent" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">在最好的公司</strong>找到你最完美的工作 </a> <strong class="ke ir">。</strong></p><div class="ne nf gp gr ng nh"><a href="https://jobs.levelup.dev/talent" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">提升——改变招聘流程</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">🔥让软件工程师找到他们热爱的完美角色🧠寻找人才是最痛苦的部分…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">作业. levelup.dev</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jw nh"/></div></div></a></div></div></div>    
</body>
</html>