<html>
<head>
<title>Making Chess in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ç”¨Pythonåˆ¶ä½œè±¡æ£‹</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://levelup.gitconnected.com/chess-python-ca4532c7f5a4?source=collection_archive---------0-----------------------#2020-12-23">https://levelup.gitconnected.com/chess-python-ca4532c7f5a4?source=collection_archive---------0-----------------------#2020-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/255a05c76bf671db1dba6e0c2628040b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uD3OhzkYPaNHr2070jgUww.png"/></div></div></figure><blockquote class="jy jz ka"><p id="055e" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">æˆ‘å°†é¦–å…ˆæè¿°å‘ç”Ÿäº†ä»€ä¹ˆï¼Œç„¶åå±•ç¤ºä»£ç ã€‚</p></blockquote><p id="118e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">è¿™æ˜¯æˆ‘å’Œä¸€ä¸ªæœ‹å‹åœ¨å­¦æ ¡è¿›è¡Œçš„ä¸€ä¸ªå¤§é¡¹ç›®ã€‚è¿™å¾ˆæœ‰è¶£ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»è®¡åˆ’äº†å‡ ä¸ªæœˆï¼Œ7å¤©åæˆ‘ä»¬å°±å®Œæˆäº†æ•´ä¸ªé¡¹ç›®ã€‚æˆ‘å¿…é¡»è¯´ï¼Œå¦‚æœæ²¡æœ‰æˆ‘çš„æœ‹å‹åŸƒå¾·æ¸©çš„å¸®åŠ©ï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬æŠ½è±¡äº†æ•´ä¸ªæ¸¸æˆï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªéå¸¸å¤æ‚çš„æ¸¸æˆç¼–ç ï¼Œæˆ‘ä»¬å†³å®šæˆ‘å°†è´Ÿè´£ç•Œé¢(ç”¨æˆ·å¯ä»¥çœ‹åˆ°çš„)ï¼Œè€ŒåŸƒå¾·æ¸©è´Ÿè´£æ¯ä¸ªéƒ¨åˆ†çš„å®é™…è¡Œä¸ºã€‚ä»–ä»¬éƒ½æœ‰è‡ªå·±çš„å›°éš¾ï¼Œæˆ‘ä»¬ç¡®å®éœ€è¦åè°ƒå¾ˆå¤šï¼Œæ‰€ä»¥æˆ‘ä»¬å¹¶ä¸æ˜¯æ²¡æœ‰äº’ç›¸å¸®åŠ©ï¼Œä¾‹å¦‚ï¼Œæˆ‘ç¡®å®æ•™äº†ä»–ä¸€ç‚¹åˆ—è¡¨ç†è§£ï¼Œä»¥åŠ å¿«ä»–çš„ä»£ç ï¼Œè€Œä»–æ­éœ²äº†æˆ‘çš„ç›¸å½“æ„šè ¢çš„é”™è¯¯ï¼Œåšåˆ—è¡Œè€Œä¸æ˜¯è¡Œåˆ—ã€‚</p><p id="2a0c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">è¿™æ®µä»£ç æ˜¯æˆ‘å†™çš„æ‰€æœ‰ä¸œè¥¿ï¼Œæ—è¾¹è¿˜æœ‰ä¸€äº›å­—å…¸å’Œä¸Šé¢çš„æ–¹æ³•ã€‚é¦–å…ˆæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªçª—å£å¯¹è±¡ï¼Œå®ƒæ˜¯æˆ‘ä»¬è¿è¡Œå›½é™…è±¡æ£‹æ¸¸æˆæ—¶å‡ºç°çš„çª—å£ã€‚æˆ‘ä»¬å°†ç»´åº¦è®¾ç½®ä¸º800x800ï¼Œè¿™æ˜¯æˆ‘ä»¬ä¼ é€’ç»™å®ƒçš„å…ƒç»„å‚æ•°ã€‚æˆ‘ä»¬ç‰¹åˆ«é€‰æ‹©äº†800 x 800ï¼Œå› ä¸ºæˆ‘ä»¬ç¡¬æ‹¼çš„å›½é™…è±¡æ£‹æ£‹å­çš„å›¾åƒéƒ½æ˜¯100x100ï¼Œè¿™æ„å‘³ç€å¦‚æœæ£‹ç›˜æ˜¯800x800ï¼Œå®ƒä¼šéå¸¸é€‚åˆã€‚</p><p id="bea7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">ä½¿æˆ‘çš„ç¨‹åºå·¥ä½œçš„ä¸»è¦ä¸œè¥¿æ˜¯è¿™äº›èŠ‚ç‚¹å¯¹è±¡ï¼Œå®ƒä»¬åªæ˜¯ä¿å­˜æ£‹å­çš„å®¹å™¨(åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒä»¬è¢«æ¨¡æ‹Ÿä¸ºæ£‹ç›˜çš„ç“·ç –)ã€‚å®ƒä»¬æœ‰è‡ªå·±çš„å±æ€§ï¼Œå³è¡Œã€åˆ—ã€xã€yåæ ‡ã€‚æˆ‘ä»¬åˆ†åˆ«éœ€è¦è¿™äº›ï¼Œå› ä¸ºæ‰€æœ‰è¿™äº›èŠ‚ç‚¹éƒ½å°†å­˜å‚¨åœ¨ä¸€ä¸ª8Ã—8çš„2dåˆ—è¡¨ä¸­ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬è°ƒç”¨å®ƒï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨å®ƒçš„è¡Œå·å’Œåˆ—å·æ¥è°ƒç”¨å®ƒï¼Œè€Œå¦‚æœæˆ‘ä»¬å°†å®ƒç»˜åˆ¶åˆ°å±å¹•ä¸Šï¼Œæˆ‘ä»¬éœ€è¦å®ƒçš„xï¼Œyåƒç´ å€¼(æˆ‘ä»¬å¯ä»¥åªåšrow*100ï¼Œä½†è¿™å°†å†’ç€æˆ‘ä»¬å¿˜è®°åœ¨æ•´ä¸ªä»£ç ä¸­æ·»åŠ 1æ¬¡å¹¶çœ‹ç€æ•´ä¸ªä¸œè¥¿å´©æºƒçš„é£é™©)ã€‚</p><p id="400d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">drawå‡½æ•°ç”¨äºå°†å›¾å—ç»˜åˆ¶åˆ°å±å¹•ä¸Š(å› æ­¤æ˜¯é»‘ç™½å›¾æ¡ˆ)ï¼Œè€Œsetupæ–¹æ³•ç”¨äºå°†ä»»ä½•å›¾åƒç»˜åˆ¶åˆ°å±å¹•ä¸Š(å¦‚æœæˆ‘ä»¬åœ¨å±å¹•ä¸Šçš„é‚£ä¸ªä½ç½®æœ‰ä¸€ä¸ªå›¾å—)ã€‚ä½ ç”¨blitåœ¨å±å¹•ä¸Šç»˜å›¾ã€‚</p><p id="52c5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">â€œç»˜åˆ¶ç½‘æ ¼â€ç»˜åˆ¶ç½‘æ ¼çš„è¾¹ç•Œ(å› æ­¤é»‘è‰²çš„æ°´å¹³çº¿å’Œå‚ç›´çº¿åˆ†éš”äº†å›¾å—)â€œç»˜åˆ¶ç½‘æ ¼â€å’Œâ€œåˆ¶ä½œç½‘æ ¼â€æ­£åœ¨åˆ›å»º2dåˆ—è¡¨ï¼Œç¨åå°†ä½¿ç”¨è¯¥åˆ—è¡¨æ¥è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ã€‚æ›´æ–°æ˜¾ç¤ºç”¨äºåœ¨æ¯æ¬¡æ»´ç­”æ—¶æ›´æ–°å±å¹•ã€‚æˆ‘è®¤ä¸ºä¸ºäº†é¿å…CPUè¿‡è½½ï¼Œæˆ‘ä»¬é€‰æ‹©ä»¥20fpsè¿è¡Œç¨‹åºï¼Œè¿™å¯¹äºå›½é™…è±¡æ£‹æ¥è¯´æ˜¯å®Œå…¨ä¸åˆç†çš„ï¼Œä½†æˆ‘ä»¬ä¸æƒ³æœ‰å¤ªå¤šçš„å»¶è¿Ÿã€‚</p><p id="d510" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">å½“ç”¨æˆ·ç‚¹å‡»å±å¹•æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å¼„æ¸…æ¥šä»–ä»¬ç‚¹å‡»äº†å“ªä¸ªç£è´´ï¼Œè¿™å°±æ˜¯find_nodeçš„åŠŸèƒ½ã€‚Display_potential_movesæ˜¯edwinåšçš„ä¸€ä¸ªå‡½æ•°ï¼Œä½†å®ƒåªéœ€è¦ä¸€ä¸ªæ½œåœ¨ç§»åŠ¨çš„åˆ—è¡¨ï¼Œå¹¶ä¸ºè¿™äº›ç§»åŠ¨æ”¹å˜ç“·ç –çš„é¢œè‰²ï¼Œä½¿å…¶çªå‡ºã€‚</p><p id="d5a1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Do_moveç”¨äºaccåœ¨å±å¹•ä¸Šè¿›è¡Œäº¤æ¢ï¼Œä½†æ˜¯äº¤æ¢æˆ‘çš„å­—å…¸ä¸Šçš„å€¼ï¼Œå½“å±å¹•æ›´æ–°æ—¶ï¼Œè¿™ä¸ªå˜åŒ–å°†åœ¨å±å¹•ä¸Šå¯è§ã€‚</p><p id="f51f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">ä½¿ç”¨remove_highlightæ˜¯å› ä¸ºå¾ˆéš¾ç§»é™¤ç‰¹å®šå›¾å—çš„é«˜å…‰ï¼Œæ‰€ä»¥æˆ‘ä»¬å†³å®šåªä¸ºæ‰€æœ‰å›¾å—é‡ç»˜é»‘è‰²ã€‚</p><p id="b2cb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">ä¸»å‡½æ•°åŒ…å«äº†å¾ˆå¤šæ ‡å‡†é€»è¾‘ï¼Œå¦‚æœä½ æ‡‚pygameçš„è¯ï¼Œæˆ‘å¸Œæœ›ä½ èƒ½ç†è§£ã€‚æˆ‘ä¼šåœ¨è¿™é‡Œé™„ä¸Šä¸€ä¸ªè§†é¢‘ï¼Œä»¥é˜²ä½ æ²¡æœ‰</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="21e1" class="lm ln iq li b gy lo lp l lq lr">import pygame<br/><br/>import time<br/><br/>import sys<br/><br/>board = [['  ' for i in range(8)] for i in range(8)]<br/><br/>## Creates a chess piece class that shows what team a piece is on, what type of piece it is and whether or not it can be killed by another selected piece.<br/>class Piece:<br/>    def __init__(self, team, type, image, killable=False):<br/>        self.team = team<br/>        self.type = type<br/>        self.killable = killable<br/>        self.image = image<br/><br/><br/>## Creates instances of chess pieces, so far we got: pawn, king, rook and bishop<br/>## The first parameter defines what team its on and the second, what type of piece it is<br/>bp = Piece('b', 'p', 'b_pawn.png')<br/>wp = Piece('w', 'p', 'w_pawn.png')<br/>bk = Piece('b', 'k', 'b_king.png')<br/>wk = Piece('w', 'k', 'w_king.png')<br/>br = Piece('b', 'r', 'b_rook.png')<br/>wr = Piece('w', 'r', 'w_rook.png')<br/>bb = Piece('b', 'b', 'b_bishop.png')<br/>wb = Piece('w', 'b', 'w_bishop.png')<br/>bq = Piece('b', 'q', 'b_queen.png')<br/>wq = Piece('w', 'q', 'w_queen.png')<br/>bkn = Piece('b', 'kn', 'b_knight.png')<br/>wkn = Piece('w', 'kn', 'w_knight.png')<br/><br/><br/>starting_order = {(0, 0): pygame.image.load(br.image), (1, 0): pygame.image.load(bkn.image),<br/>                  (2, 0): pygame.image.load(bb.image), (3, 0): pygame.image.load(bk.image),<br/>                  (4, 0): pygame.image.load(bq.image), (5, 0): pygame.image.load(bb.image),<br/>                  (6, 0): pygame.image.load(bkn.image), (7, 0): pygame.image.load(br.image),<br/>                  (0, 1): pygame.image.load(bp.image), (1, 1): pygame.image.load(bp.image),<br/>                  (2, 1): pygame.image.load(bp.image), (3, 1): pygame.image.load(bp.image),<br/>                  (4, 1): pygame.image.load(bp.image), (5, 1): pygame.image.load(bp.image),<br/>                  (6, 1): pygame.image.load(bp.image), (7, 1): pygame.image.load(bp.image),<br/><br/>                  (0, 2): None, (1, 2): None, (2, 2): None, (3, 2): None,<br/>                  (4, 2): None, (5, 2): None, (6, 2): None, (7, 2): None,<br/>                  (0, 3): None, (1, 3): None, (2, 3): None, (3, 3): None,<br/>                  (4, 3): None, (5, 3): None, (6, 3): None, (7, 3): None,<br/>                  (0, 4): None, (1, 4): None, (2, 4): None, (3, 4): None,<br/>                  (4, 4): None, (5, 4): None, (6, 4): None, (7, 4): None,<br/>                  (0, 5): None, (1, 5): None, (2, 5): None, (3, 5): None,<br/>                  (4, 5): None, (5, 5): None, (6, 5): None, (7, 5): None,<br/><br/>                  (0, 6): pygame.image.load(wp.image), (1, 6): pygame.image.load(wp.image),<br/>                  (2, 6): pygame.image.load(wp.image), (3, 6): pygame.image.load(wp.image),<br/>                  (4, 6): pygame.image.load(wp.image), (5, 6): pygame.image.load(wp.image),<br/>                  (6, 6): pygame.image.load(wp.image), (7, 6): pygame.image.load(wp.image),<br/>                  (0, 7): pygame.image.load(wr.image), (1, 7): pygame.image.load(wkn.image),<br/>                  (2, 7): pygame.image.load(wb.image), (3, 7): pygame.image.load(wk.image),<br/>                  (4, 7): pygame.image.load(wq.image), (5, 7): pygame.image.load(wb.image),<br/>                  (6, 7): pygame.image.load(wkn.image), (7, 7): pygame.image.load(wr.image),}<br/><br/><br/>def create_board(board):<br/>    board[0] = [Piece('b', 'r', 'b_rook.png'), Piece('b', 'kn', 'b_knight.png'), Piece('b', 'b', 'b_bishop.png'), \<br/>               Piece('b', 'q', 'b_queen.png'), Piece('b', 'k', 'b_king.png'), Piece('b', 'b', 'b_bishop.png'), \<br/>               Piece('b', 'kn', 'b_knight.png'), Piece('b', 'r', 'b_rook.png')]<br/><br/>    board[7] = [Piece('w', 'r', 'w_rook.png'), Piece('w', 'kn', 'w_knight.png'), Piece('w', 'b', 'w_bishop.png'), \<br/>               Piece('w', 'q', 'w_queen.png'), Piece('w', 'k', 'w_king.png'), Piece('w', 'b', 'w_bishop.png'), \<br/>               Piece('w', 'kn', 'w_knight.png'), Piece('w', 'r', 'w_rook.png')]<br/><br/>    for i in range(8):<br/>        board[1][i] = Piece('b', 'p', 'b_pawn.png')<br/>        board[6][i] = Piece('w', 'p', 'w_pawn.png')<br/>    return board<br/><br/><br/>## returns the input if the input is within the boundaries of the board<br/>def on_board(position):<br/>    if position[0] &gt; -1 and position[1] &gt; -1 and position[0] &lt; 8 and position[1] &lt; 8:<br/>        return True<br/><br/><br/>## returns a string that places the rows and columns of the board in a readable manner<br/>def convert_to_readable(board):<br/>    output = ''<br/><br/>    for i in board:<br/>        for j in i:<br/>            try:<br/>                output += j.team + j.type + ', '<br/>            except:<br/>                output += j + ', '<br/>        output += '\n'<br/>    return output<br/><br/><br/>## resets "x's" and killable pieces<br/>def deselect():<br/>    for row in range(len(board)):<br/>        for column in range(len(board[0])):<br/>            if board[row][column] == 'x ':<br/>                board[row][column] = '  '<br/>            else:<br/>                try:<br/>                    board[row][column].killable = False<br/>                except:<br/>                    pass<br/>    return convert_to_readable(board)<br/><br/><br/>## Takes in board as argument then returns 2d array containing positions of valid moves<br/>def highlight(board):<br/>    highlighted = []<br/>    for i in range(len(board)):<br/>        for j in range(len(board[0])):<br/>            if board[i][j] == 'x ':<br/>                highlighted.append((i, j))<br/>            else:<br/>                try:<br/>                    if board[i][j].killable:<br/>                        highlighted.append((i, j))<br/>                except:<br/>                    pass<br/>    return highlighted<br/><br/>def check_team(moves, index):<br/>    row, col = index<br/>    if moves%2 == 0:<br/>        if board[row][col].team == 'w':<br/>            return True<br/>    else:<br/>        if board[row][col].team == 'b':<br/>            return True<br/><br/>## This takes in a piece object and its index then runs then checks where that piece can move using separately defined functions for each type of piece.<br/>def select_moves(piece, index, moves):<br/>    if check_team(moves, index):<br/>        if piece.type == 'p':<br/>            if piece.team == 'b':<br/>                return highlight(pawn_moves_b(index))<br/>            else:<br/>                return highlight(pawn_moves_w(index))<br/><br/>        if piece.type == 'k':<br/>            return highlight(king_moves(index))<br/><br/>        if piece.type == 'r':<br/>            return highlight(rook_moves(index))<br/><br/>        if piece.type == 'b':<br/>            return highlight(bishop_moves(index))<br/><br/>        if piece.type == 'q':<br/>            return highlight(queen_moves(index))<br/><br/>        if piece.type == 'kn':<br/>            return highlight(knight_moves(index))<br/><br/><br/>## Basically, check black and white pawns separately and checks the square above them. If its free that space gets an "x" and if it is occupied by a piece of the opposite team then that piece becomes killable.<br/>def pawn_moves_b(index):<br/>    if index[0] == 1:<br/>        if board[index[0] + 2][index[1]] == '  ' and board[index[0] + 1][index[1]] == '  ':<br/>            board[index[0] + 2][index[1]] = 'x '<br/>    bottom3 = [[index[0] + 1, index[1] + i] for i in range(-1, 2)]<br/><br/>    for positions in bottom3:<br/>        if on_board(positions):<br/>            if bottom3.index(positions) % 2 == 0:<br/>                try:<br/>                    if board[positions[0]][positions[1]].team != 'b':<br/>                        board[positions[0]][positions[1]].killable = True<br/>                except:<br/>                    pass<br/>            else:<br/>                if board[positions[0]][positions[1]] == '  ':<br/>                    board[positions[0]][positions[1]] = 'x '<br/>    return board<br/><br/>def pawn_moves_w(index):<br/>    if index[0] == 6:<br/>        if board[index[0] - 2][index[1]] == '  ' and board[index[0] - 1][index[1]] == '  ':<br/>            board[index[0] - 2][index[1]] = 'x '<br/>    top3 = [[index[0] - 1, index[1] + i] for i in range(-1, 2)]<br/><br/>    for positions in top3:<br/>        if on_board(positions):<br/>            if top3.index(positions) % 2 == 0:<br/>                try:<br/>                    if board[positions[0]][positions[1]].team != 'w':<br/>                        board[positions[0]][positions[1]].killable = True<br/>                except:<br/>                    pass<br/>            else:<br/>                if board[positions[0]][positions[1]] == '  ':<br/>                    board[positions[0]][positions[1]] = 'x '<br/>    return board<br/><br/><br/>## This just checks a 3x3 tile surrounding the king. Empty spots get an "x" and pieces of the opposite team become killable.<br/>def king_moves(index):<br/>    for y in range(3):<br/>        for x in range(3):<br/>            if on_board((index[0] - 1 + y, index[1] - 1 + x)):<br/>                if board[index[0] - 1 + y][index[1] - 1 + x] == '  ':<br/>                    board[index[0] - 1 + y][index[1] - 1 + x] = 'x '<br/>                else:<br/>                    if board[index[0] - 1 + y][index[1] - 1 + x].team != board[index[0]][index[1]].team:<br/>                        board[index[0] - 1 + y][index[1] - 1 + x].killable = True<br/>    return board<br/><br/><br/>## This creates 4 lists for up, down, left and right and checks all those spaces for pieces of the opposite team. The list comprehension is pretty long so if you don't get it just msg me.<br/>def rook_moves(index):<br/>    cross = [[[index[0] + i, index[1]] for i in range(1, 8 - index[0])],<br/>             [[index[0] - i, index[1]] for i in range(1, index[0] + 1)],<br/>             [[index[0], index[1] + i] for i in range(1, 8 - index[1])],<br/>             [[index[0], index[1] - i] for i in range(1, index[1] + 1)]]<br/><br/>    for direction in cross:<br/>        for positions in direction:<br/>            if on_board(positions):<br/>                if board[positions[0]][positions[1]] == '  ':<br/>                    board[positions[0]][positions[1]] = 'x '<br/>                else:<br/>                    if board[positions[0]][positions[1]].team != board[index[0]][index[1]].team:<br/>                        board[positions[0]][positions[1]].killable = True<br/>                    break<br/>    return board<br/><br/><br/>## Same as the rook but this time it creates 4 lists for the diagonal directions and so the list comprehension is a little bit trickier.<br/>def bishop_moves(index):<br/>    diagonals = [[[index[0] + i, index[1] + i] for i in range(1, 8)],<br/>                 [[index[0] + i, index[1] - i] for i in range(1, 8)],<br/>                 [[index[0] - i, index[1] + i] for i in range(1, 8)],<br/>                 [[index[0] - i, index[1] - i] for i in range(1, 8)]]<br/><br/>    for direction in diagonals:<br/>        for positions in direction:<br/>            if on_board(positions):<br/>                if board[positions[0]][positions[1]] == '  ':<br/>                    board[positions[0]][positions[1]] = 'x '<br/>                else:<br/>                    if board[positions[0]][positions[1]].team != board[index[0]][index[1]].team:<br/>                        board[positions[0]][positions[1]].killable = True<br/>                    break<br/>    return board<br/><br/><br/>## applies the rook moves to the board then the bishop moves because a queen is basically a rook and bishop in the same position.<br/>def queen_moves(index):<br/>    board = rook_moves(index)<br/>    board = bishop_moves(index)<br/>    return board<br/><br/><br/>## Checks a 5x5 grid around the piece and uses pythagoras to see if if a move is valid. Valid moves will be a distance of sqrt(5) from centre<br/>def knight_moves(index):<br/>    for i in range(-2, 3):<br/>        for j in range(-2, 3):<br/>            if i ** 2 + j ** 2 == 5:<br/>                if on_board((index[0] + i, index[1] + j)):<br/>                    if board[index[0] + i][index[1] + j] == '  ':<br/>                        board[index[0] + i][index[1] + j] = 'x '<br/>                    else:<br/>                        if board[index[0] + i][index[1] + j].team != board[index[0]][index[1]].team:<br/>                            board[index[0] + i][index[1] + j].killable = True<br/>    return board<br/><br/><br/>WIDTH = 800<br/><br/>WIN = pygame.display.set_mode((WIDTH, WIDTH))<br/><br/>""" This is creating the window that we are playing on, it takes a tuple argument which is the dimensions of the window so in this case 800 x 800px<br/>"""<br/><br/>pygame.display.set_caption("Chess")<br/>WHITE = (255, 255, 255)<br/>GREY = (128, 128, 128)<br/>YELLOW = (204, 204, 0)<br/>BLUE = (50, 255, 255)<br/>BLACK = (0, 0, 0)<br/><br/><br/>class Node:<br/>    def __init__(self, row, col, width):<br/>        self.row = row<br/>        self.col = col<br/>        self.x = int(row * width)<br/>        self.y = int(col * width)<br/>        self.colour = WHITE<br/>        self.occupied = None<br/><br/>    def draw(self, WIN):<br/>        pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / 8, WIDTH / 8))<br/><br/>    def setup(self, WIN):<br/>        if starting_order[(self.row, self.col)]:<br/>            if starting_order[(self.row, self.col)] == None:<br/>                pass<br/>            else:<br/>                WIN.blit(starting_order[(self.row, self.col)], (self.x, self.y))<br/><br/>        """<br/>        For now it is drawing a rectangle but eventually we are going to need it<br/>        to use blit to draw the chess pieces instead<br/>        """<br/><br/><br/>def make_grid(rows, width):<br/>    grid = []<br/>    gap = WIDTH // rows<br/>    print(gap)<br/>    for i in range(rows):<br/>        grid.append([])<br/>        for j in range(rows):<br/>            node = Node(j, i, gap)<br/>            grid[i].append(node)<br/>            if (i+j)%2 ==1:<br/>                grid[i][j].colour = GREY<br/>    return grid<br/>"""<br/>This is creating the nodes thats are on the board(so the chess tiles)<br/>I've put them into a 2d array which is identical to the dimesions of the chessboard<br/>"""<br/><br/><br/>def draw_grid(win, rows, width):<br/>    gap = width // 8<br/>    for i in range(rows):<br/>        pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))<br/>        for j in range(rows):<br/>            pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))<br/><br/>    """<br/>    The nodes are all white so this we need to draw the grey lines that separate all the chess tiles<br/>    from each other and that is what this function does"""<br/><br/><br/>def update_display(win, grid, rows, width):<br/>    for row in grid:<br/>        for spot in row:<br/>            spot.draw(win)<br/>            spot.setup(win)<br/>    draw_grid(win, rows, width)<br/>    pygame.display.update()<br/><br/><br/>def Find_Node(pos, WIDTH):<br/>    interval = WIDTH / 8<br/>    y, x = pos<br/>    rows = y // interval<br/>    columns = x // interval<br/>    return int(rows), int(columns)<br/><br/><br/>def display_potential_moves(positions, grid):<br/>    for i in positions:<br/>        x, y = i<br/>        grid[x][y].colour = BLUE<br/>        """<br/>        Displays all the potential moves<br/>        """<br/><br/><br/>def Do_Move(OriginalPos, FinalPosition, WIN):<br/>    starting_order[FinalPosition] = starting_order[OriginalPos]<br/>    starting_order[OriginalPos] = None<br/><br/><br/>def remove_highlight(grid):<br/>    for i in range(len(grid)):<br/>        for j in range(len(grid[0])):<br/>            if (i+j)%2 == 0:<br/>                grid[i][j].colour = WHITE<br/>            else:<br/>                grid[i][j].colour = GREY<br/>    return grid<br/>"""this takes in 2 co-ordinate parameters which you can get as the position of the piece and then the position of the node it is moving to<br/>you can get those co-ordinates using my old function for swap"""<br/><br/>create_board(board)<br/><br/><br/>def main(WIN, WIDTH):<br/>    moves = 0<br/>    selected = False<br/>    piece_to_move=[]<br/>    grid = make_grid(8, WIDTH)<br/>    while True:<br/>        pygame.time.delay(50) ##stops cpu dying<br/>        for event in pygame.event.get():<br/>            if event.type == pygame.QUIT:<br/>                pygame.quit()<br/>                sys.exit()<br/><br/>            """This quits the program if the player closes the window"""<br/><br/>            if event.type == pygame.MOUSEBUTTONDOWN:<br/>                pos = pygame.mouse.get_pos()<br/>                y, x = Find_Node(pos, WIDTH)<br/>                if selected == False:<br/>                    try:<br/>                        possible = select_moves((board[x][y]), (x,y), moves)<br/>                        for positions in possible:<br/>                            row, col = positions<br/>                            grid[row][col].colour = BLUE<br/>                        piece_to_move = x,y<br/>                        selected = True<br/>                    except:<br/>                        piece_to_move = []<br/>                        print('Can\'t select')<br/>                    #print(piece_to_move)<br/><br/>                else:<br/>                    try:<br/>                        if board[x][y].killable == True:<br/>                            row, col = piece_to_move ## coords of original piece<br/>                            board[x][y] = board[row][col]<br/>                            board[row][col] = '  '<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            Do_Move((col, row), (y, x), WIN)<br/>                            moves += 1<br/>                            print(convert_to_readable(board))<br/>                        else:<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            selected = False<br/>                            print("Deselected")<br/>                    except:<br/>                        if board[x][y] == 'x ':<br/>                            row, col = piece_to_move<br/>                            board[x][y] = board[row][col]<br/>                            board[row][col] = '  '<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            Do_Move((col, row), (y, x), WIN)<br/>                            moves += 1<br/>                            print(convert_to_readable(board))<br/>                        else:<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            selected = False<br/>                            print("Invalid move")<br/>                    selected = False<br/><br/>            update_display(WIN, grid, 8, WIDTH)<br/><br/><br/>main(WIN, WIDTH)</span></pre><p id="7088" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">å¦‚æœæˆ‘è¦è§£é‡Šæ•´ä¸ªä»£ç ï¼Œè¿™å°†èŠ±è´¹å‡ ä¸ªå°æ—¶æ¥ç¼–å†™ï¼Œæ‰€ä»¥æˆ‘å°†è§£é‡Šå…¶ä¸­çš„åŠŸèƒ½å’Œä»»ä½•å¤æ‚çš„æ¦‚å¿µï¼Œå¹¶è®©æ‚¨æ¥è§£å†³å…¶ä½™çš„é—®é¢˜ã€‚</p><p id="0040" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke ir">ä»£ç è§£é‡Š:</strong></p><p id="afd3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">æˆ‘ä»¬ç”¨pygameç¼–å†™äº†è¿™ä¸ªç¨‹åºï¼Œå› ä¸ºå®ƒå¯ä»¥å¾ˆå®¹æ˜“åœ°ç»™æˆ‘ä»¬æä¾›æ¥å£ï¼Œè€Œä¸”æˆ‘æœ‰ä½¿ç”¨A*ç®—æ³•åˆ¶ä½œç½‘æ ¼çš„ç»éªŒï¼Œæ‰€ä»¥å¤§éƒ¨åˆ†ç½‘æ ¼éƒ½æ˜¯ä»ä¸­å›æ”¶çš„ä»£ç ã€‚</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="2d82" class="lm ln iq li b gy lo lp l lq lr">board = [['  ' for i in range(8)] for i in range(8)]<br/><br/>## Creates a chess piece class that shows what team a piece is on, what type of piece it is and whether or not it can be killed by another selected piece.<br/>class Piece:<br/>    def __init__(self, team, type, image, killable=False):<br/>        self.team = team<br/>        self.type = type<br/>        self.killable = killable<br/>        self.image = image<br/><br/><br/>## Creates instances of chess pieces, so far we got: pawn, king, rook and bishop<br/>## The first parameter defines what team its on and the second, what type of piece it is<br/>bp = Piece('b', 'p', 'b_pawn.png')<br/>wp = Piece('w', 'p', 'w_pawn.png')<br/>bk = Piece('b', 'k', 'b_king.png')<br/>wk = Piece('w', 'k', 'w_king.png')<br/>br = Piece('b', 'r', 'b_rook.png')<br/>wr = Piece('w', 'r', 'w_rook.png')<br/>bb = Piece('b', 'b', 'b_bishop.png')<br/>wb = Piece('w', 'b', 'w_bishop.png')<br/>bq = Piece('b', 'q', 'b_queen.png')<br/>wq = Piece('w', 'q', 'w_queen.png')<br/>bkn = Piece('b', 'kn', 'b_knight.png')<br/>wkn = Piece('w', 'kn', 'w_knight.png')<br/><br/><br/>starting_order = {(0, 0): pygame.image.load(br.image), (1, 0): pygame.image.load(bkn.image),<br/>                  (2, 0): pygame.image.load(bb.image), (3, 0): pygame.image.load(bk.image),<br/>                  (4, 0): pygame.image.load(bq.image), (5, 0): pygame.image.load(bb.image),<br/>                  (6, 0): pygame.image.load(bkn.image), (7, 0): pygame.image.load(br.image),<br/>                  (0, 1): pygame.image.load(bp.image), (1, 1): pygame.image.load(bp.image),<br/>                  (2, 1): pygame.image.load(bp.image), (3, 1): pygame.image.load(bp.image),<br/>                  (4, 1): pygame.image.load(bp.image), (5, 1): pygame.image.load(bp.image),<br/>                  (6, 1): pygame.image.load(bp.image), (7, 1): pygame.image.load(bp.image),<br/><br/>                  (0, 2): None, (1, 2): None, (2, 2): None, (3, 2): None,<br/>                  (4, 2): None, (5, 2): None, (6, 2): None, (7, 2): None,<br/>                  (0, 3): None, (1, 3): None, (2, 3): None, (3, 3): None,<br/>                  (4, 3): None, (5, 3): None, (6, 3): None, (7, 3): None,<br/>                  (0, 4): None, (1, 4): None, (2, 4): None, (3, 4): None,<br/>                  (4, 4): None, (5, 4): None, (6, 4): None, (7, 4): None,<br/>                  (0, 5): None, (1, 5): None, (2, 5): None, (3, 5): None,<br/>                  (4, 5): None, (5, 5): None, (6, 5): None, (7, 5): None,<br/><br/>                  (0, 6): pygame.image.load(wp.image), (1, 6): pygame.image.load(wp.image),<br/>                  (2, 6): pygame.image.load(wp.image), (3, 6): pygame.image.load(wp.image),<br/>                  (4, 6): pygame.image.load(wp.image), (5, 6): pygame.image.load(wp.image),<br/>                  (6, 6): pygame.image.load(wp.image), (7, 6): pygame.image.load(wp.image),<br/>                  (0, 7): pygame.image.load(wr.image), (1, 7): pygame.image.load(wkn.image),<br/>                  (2, 7): pygame.image.load(wb.image), (3, 7): pygame.image.load(wk.image),<br/>                  (4, 7): pygame.image.load(wq.image), (5, 7): pygame.image.load(wb.image),<br/>                  (6, 7): pygame.image.load(wkn.image), (7, 7): pygame.image.load(wr.image),}<br/><br/><br/>def create_board(board):<br/>    board[0] = [Piece('b', 'r', 'b_rook.png'), Piece('b', 'kn', 'b_knight.png'), Piece('b', 'b', 'b_bishop.png'), \<br/>               Piece('b', 'q', 'b_queen.png'), Piece('b', 'k', 'b_king.png'), Piece('b', 'b', 'b_bishop.png'), \<br/>               Piece('b', 'kn', 'b_knight.png'), Piece('b', 'r', 'b_rook.png')]<br/><br/>    board[7] = [Piece('w', 'r', 'w_rook.png'), Piece('w', 'kn', 'w_knight.png'), Piece('w', 'b', 'w_bishop.png'), \<br/>               Piece('w', 'q', 'w_queen.png'), Piece('w', 'k', 'w_king.png'), Piece('w', 'b', 'w_bishop.png'), \<br/>               Piece('w', 'kn', 'w_knight.png'), Piece('w', 'r', 'w_rook.png')]<br/><br/>    for i in range(8):<br/>        board[1][i] = Piece('b', 'p', 'b_pawn.png')<br/>        board[6][i] = Piece('w', 'p', 'w_pawn.png')<br/>    return board<br/></span></pre><p id="d3ea" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">é™¤äº†ä»å¼€å§‹è®¢å•å­—å…¸ï¼Œæ‰€æœ‰è¿™äº›éƒ½æ˜¯åŸƒå¾·æ¸©çš„ä»£ç ï¼Œæ‰€æœ‰è¿™äº›éƒ½ç”¨äºç§»åŠ¨è®¡ç®—ã€‚ç†è®ºä¸Šï¼Œä½ å¯ä»¥åƒä»–ä¸€æ ·åªä½¿ç”¨å­—å…¸æˆ–2dåˆ—è¡¨ä¸­çš„ä¸€ä¸ªæ¥å®Œæˆè¿™é¡¹å·¥ä½œï¼Œä½†ç”±äºæˆ‘ä»¬åœ¨ç¼–ç æ—¶éƒ½éœ€è¦è®¿é—®æ•°ç»„ï¼Œå¹¶ä¸”æˆ‘ä»¬ä¸èƒ½å…±äº«pythonè„šæœ¬ï¼Œæ‰€ä»¥æˆ‘ä»¬åˆ¶ä½œäº†è‡ªå·±çš„ç‰ˆæœ¬ã€‚Edwinä¸ºæ£‹å­åˆ›å»ºäº†ä¸€ä¸ªç±»ï¼Œå› ä¸ºå®ƒæ›´å®¹æ˜“ç®¡ç†ï¼Œåœ¨åº•éƒ¨ï¼Œä»–æ­£åœ¨è®¾ç½®ä»–çš„2dåˆ—è¡¨ï¼Œä»¥ä¾¿æ‰€æœ‰çš„æ£‹å­éƒ½åœ¨å®ƒä»¬çš„èµ·å§‹ä½ç½®ã€‚åœ¨æˆ‘çš„å­—å…¸ä¸­ï¼Œæˆ‘è‡ªåŠ¨åœ°ç¡¬å†™äº†æ‰€æœ‰çš„ä½ç½®ï¼Œå› ä¸ºæˆ‘éœ€è¦å°†æ¯ä¸ªå•ç‹¬çš„å›¾åƒæ–‡ä»¶çš„åç§°æ”¾å…¥åŠ è½½ä¸­ã€‚pygame.image.load()å°†å›¾åƒåŠ è½½åˆ°pythonæ–‡ä»¶ä¸­ï¼Œç„¶åæˆ‘ä»¬åªéœ€è¦å°†å›¾åƒç»˜åˆ¶åˆ°å±å¹•ä¸Šã€‚è¿™ç§æ–¹å¼æ¯”å…ˆåŠ è½½å›¾åƒç„¶åå†ç»˜å›¾è¦å¥½ï¼Œå› ä¸ºè¿™æ„å‘³ç€æˆ‘ä»¬åªéœ€è¦ä¸ºæ•´ä¸ªç¨‹åºåŠ è½½ä¸€æ¬¡å›¾åƒï¼Œç„¶åå°†å›¾åƒè½¬æ¢åˆ°å±å¹•ä¸Šçš„æ–°ä½ç½®ã€‚</p><p id="6fd0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">edwinsä»£ç çš„å…¶ä½™éƒ¨åˆ†éå¸¸ç®€å•æ˜äº†ï¼Œåªéœ€é€‰æ‹©æ¯ä¸ªæ£‹å­å¯ä»¥ç§»åŠ¨åˆ°çš„æ­£ç¡®ä½ç½®ï¼Œç„¶åå°†è¿™äº›â€œåˆæ³•â€çš„æ£‹å­æ”¾åˆ°æ£‹ç›˜ä¸Šï¼Œä¾›æˆ‘ä»¬åœ¨ç•Œé¢ä¸Šä½¿ç”¨ï¼Œä»¥çªå‡ºæ˜¾ç¤ºæ£‹ç›˜ã€‚</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="02ef" class="lm ln iq li b gy lo lp l lq lr">WIDTH = 800<br/><br/>WIN = pygame.display.set_mode((WIDTH, WIDTH))<br/><br/>""" This is creating the window that we are playing on, it takes a tuple argument which is the dimensions of the window so in this case 800 x 800px<br/>"""<br/><br/>pygame.display.set_caption("Chess")<br/>WHITE = (255, 255, 255)<br/>GREY = (128, 128, 128)<br/>YELLOW = (204, 204, 0)<br/>BLUE = (50, 255, 255)<br/>BLACK = (0, 0, 0)<br/><br/><br/>class Node:<br/>    def __init__(self, row, col, width):<br/>        self.row = row<br/>        self.col = col<br/>        self.x = int(row * width)<br/>        self.y = int(col * width)<br/>        self.colour = WHITE<br/>        self.occupied = None<br/><br/>    def draw(self, WIN):<br/>        pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / 8, WIDTH / 8))<br/><br/>    def setup(self, WIN):<br/>        if starting_order[(self.row, self.col)]:<br/>            if starting_order[(self.row, self.col)] == None:<br/>                pass<br/>            else:<br/>                WIN.blit(starting_order[(self.row, self.col)], (self.x, self.y))<br/><br/>        """<br/>        For now it is drawing a rectangle but eventually we are going to need it<br/>        to use blit to draw the chess pieces instead<br/>        """<br/><br/><br/>def make_grid(rows, width):<br/>    grid = []<br/>    gap = WIDTH // rows<br/>    print(gap)<br/>    for i in range(rows):<br/>        grid.append([])<br/>        for j in range(rows):<br/>            node = Node(j, i, gap)<br/>            grid[i].append(node)<br/>            if (i+j)%2 ==1:<br/>                grid[i][j].colour = GREY<br/>    return grid<br/>"""<br/>This is creating the nodes thats are on the board(so the chess tiles)<br/>I've put them into a 2d array which is identical to the dimesions of the chessboard<br/>"""<br/><br/><br/>def draw_grid(win, rows, width):<br/>    gap = width // 8<br/>    for i in range(rows):<br/>        pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))<br/>        for j in range(rows):<br/>            pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))<br/><br/>    """<br/>    The nodes are all white so this we need to draw the grey lines that separate all the chess tiles<br/>    from each other and that is what this function does"""<br/><br/><br/>def update_display(win, grid, rows, width):<br/>    for row in grid:<br/>        for spot in row:<br/>            spot.draw(win)<br/>            spot.setup(win)<br/>    draw_grid(win, rows, width)<br/>    pygame.display.update()<br/><br/><br/>def Find_Node(pos, WIDTH):<br/>    interval = WIDTH / 8<br/>    y, x = pos<br/>    rows = y // interval<br/>    columns = x // interval<br/>    return int(rows), int(columns)<br/><br/><br/>def display_potential_moves(positions, grid):<br/>    for i in positions:<br/>        x, y = i<br/>        grid[x][y].colour = BLUE<br/>        """<br/>        Displays all the potential moves<br/>        """<br/><br/><br/>def Do_Move(OriginalPos, FinalPosition, WIN):<br/>    starting_order[FinalPosition] = starting_order[OriginalPos]<br/>    starting_order[OriginalPos] = None<br/><br/><br/>def remove_highlight(grid):<br/>    for i in range(len(grid)):<br/>        for j in range(len(grid[0])):<br/>            if (i+j)%2 == 0:<br/>                grid[i][j].colour = WHITE<br/>            else:<br/>                grid[i][j].colour = GREY<br/>    return grid<br/>"""this takes in 2 co-ordinate parameters which you can get as the position of the piece and then the position of the node it is moving to<br/>you can get those co-ordinates using my old function for swap"""<br/><br/>create_board(board)<br/><br/><br/>def main(WIN, WIDTH):<br/>    moves = 0<br/>    selected = False<br/>    piece_to_move=[]<br/>    grid = make_grid(8, WIDTH)<br/>    while True:<br/>        pygame.time.delay(50) ##stops cpu dying<br/>        for event in pygame.event.get():<br/>            if event.type == pygame.QUIT:<br/>                pygame.quit()<br/>                sys.exit()<br/><br/>            """This quits the program if the player closes the window"""<br/><br/>            if event.type == pygame.MOUSEBUTTONDOWN:<br/>                pos = pygame.mouse.get_pos()<br/>                y, x = Find_Node(pos, WIDTH)<br/>                if selected == False:<br/>                    try:<br/>                        possible = select_moves((board[x][y]), (x,y), moves)<br/>                        for positions in possible:<br/>                            row, col = positions<br/>                            grid[row][col].colour = BLUE<br/>                        piece_to_move = x,y<br/>                        selected = True<br/>                    except:<br/>                        piece_to_move = []<br/>                        print('Can\'t select')<br/>                    #print(piece_to_move)<br/><br/>                else:<br/>                    try:<br/>                        if board[x][y].killable == True:<br/>                            row, col = piece_to_move ## coords of original piece<br/>                            board[x][y] = board[row][col]<br/>                            board[row][col] = '  '<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            Do_Move((col, row), (y, x), WIN)<br/>                            moves += 1<br/>                            print(convert_to_readable(board))<br/>                        else:<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            selected = False<br/>                            print("Deselected")<br/>                    except:<br/>                        if board[x][y] == 'x ':<br/>                            row, col = piece_to_move<br/>                            board[x][y] = board[row][col]<br/>                            board[row][col] = '  '<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            Do_Move((col, row), (y, x), WIN)<br/>                            moves += 1<br/>                            print(convert_to_readable(board))<br/>                        else:<br/>                            deselect()<br/>                            remove_highlight(grid)<br/>                            selected = False<br/>                            print("Invalid move")<br/>                    selected = False<br/><br/>            update_display(WIN, grid, 8, WIDTH)<br/><br/><br/>main(WIN, WIDTH)</span></pre><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="ls lt l"/></div></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="e6c1" class="mb ln iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">åˆ†çº§ç¼–ç </h1><p id="9489" class="pw-post-body-paragraph kb kc iq ke b kf my kh ki kj mz kl km la na kp kq lb nb kt ku lc nc kx ky kz ij bi translated">æ„Ÿè°¢æ‚¨æˆä¸ºæˆ‘ä»¬ç¤¾åŒºçš„ä¸€å‘˜ï¼å‡çº§æ­£åœ¨æ”¹å˜æŠ€æœ¯æ‹›è˜ã€‚<a class="ae nd" href="https://jobs.levelup.dev/talent" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">åœ¨æœ€å¥½çš„å…¬å¸</strong>æ‰¾åˆ°ä½ æœ€å®Œç¾çš„å·¥ä½œ </a> <strong class="ke ir">ã€‚</strong></p><div class="ne nf gp gr ng nh"><a href="https://jobs.levelup.dev/talent" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">æå‡â€”â€”æ”¹å˜æ‹›è˜æµç¨‹</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">ğŸ”¥è®©è½¯ä»¶å·¥ç¨‹å¸ˆæ‰¾åˆ°ä»–ä»¬çƒ­çˆ±çš„å®Œç¾è§’è‰²ğŸ§ å¯»æ‰¾äººæ‰æ˜¯æœ€ç—›è‹¦çš„éƒ¨åˆ†â€¦</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">ä½œä¸š. levelup.dev</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jw nh"/></div></div></a></div></div></div>    
</body>
</html>