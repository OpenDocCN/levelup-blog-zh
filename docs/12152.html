<html>
<head>
<title>REST APIs are obsolete</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST APIs已经过时</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-rest-apis-are-not-lean-bd906393dcf8?source=collection_archive---------2-----------------------#2022-05-19">https://levelup.gitconnected.com/why-rest-apis-are-not-lean-bd906393dcf8?source=collection_archive---------2-----------------------#2022-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c01e2ac92602d269b979fd600eb57b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Efx8WtIMo8l5Jzxh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一名男子在公路中间休息</figcaption></figure><p id="d5c8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Fielding在2000年加州大学欧文分校的博士论文“架构风格和基于网络的软件架构的设计”中定义了REST。从那时起，它就成了创建API的事实上的T2。RESTful APIs提供了直观的界面和可预测性。它们很容易理解，也很容易开发。全球采用的完美组合。</p><p id="5009" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，RESTful APIs是以精益方式构建软件的次优解决方案，因为它们固有的缺乏灵活性。这使得软件的构建更加昂贵，更改更加困难。</p><p id="8f7e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，RESTful APIs通常效率低下。如果您想显示来自特定资源的单个字段，您仍然必须获取所有内容。对于嵌套的资源，你必须单独获取它们。这导致更高的延迟和较差的性能。</p><p id="f369" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">举个例子，假设我们有一个React应用程序，我们想在其中显示一个图书列表。我们创建了一个简单的react钩子来处理所有有状态逻辑，如下所示:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="48ff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">显示书籍的标题和概要是很好的，但是现在我们也想显示作者的肖像图片。我们更新了我们的钩子，所以对于每本书，我们也请求/authors/:id获取作者，并将每本书与它们各自的作者结合起来，就像这样:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="70e4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个例子中，除了如此简单的任务增加了复杂性之外，还有几个问题。首先，如果有1000本书呢？然后，我们会并行发出1000个调用来获取作者。这根本无法扩展。</p><p id="8ede" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，我们必须获取大量我们实际上并不需要的数据，如作者的简历和姓名，这会增加延迟。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><p id="0d7b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">早在2012年，脸书的开发人员发现很难为他们的IOS应用程序实现新闻提要部分。在开发阶段，他们经历了许多错误，因为没有关于前端和后端之间数据交换的约定。前端采用的数据形式与后端API发送的数据形式不同。有必要建造更好的东西！这种努力催生了<a class="ae ld" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu">graph QL</strong></a><em class="le">一种为API</em><em class="le">构建的查询语言。</em></p><p id="c716" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">GraphQL 由用于查询数据的查询语言和完成这些查询的运行时组成。<a class="ae ld" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">graph QL</a>API是根据类型和字段来组织的，而不是端点和资源。您可以从单个端点访问数据的全部功能。您可以在单个查询中获取嵌套资源。此外，GraphQL是强类型的，它帮助用户只询问什么是可能的，并在他们不这样做时提供清晰而有用的错误。此外，使用GraphQL，您可以在没有版本的情况下改进您的API，添加新的字段和废弃不再使用的字段。</p><p id="061a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">至于上面的书的例子。使用GraphQL，我们可以简单地编写如下代码来查询所有带有作者肖像的书籍:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="c939" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，我们的GraphQL API中仍然需要一些逻辑来以高效的方式满足请求。在构建GraphQL APIs时，您应该知道一些缺点。</p><p id="46a2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">过度蚀刻</strong>。即使客户机只得到它们所要求的数据，数据仍然必须从数据源获取。如果数据源仍然返回所有内容，例如完整的资源，那么只能减少来自GraphQL API的流量/出口，而不能减少内部流量。</p><p id="d0c0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">阅读放大。当客户可以请求无限深度的嵌套字段时，这会导致内部产生大量请求，实际上是在浪费我们的时间。因此，必须有一种类似于<em class="le">最大查询深度</em>的机制来阻止来自客户端的低效请求。以及用于内部优化请求的批处理等机制。</strong></p><p id="4142" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">缓存</strong>。当试图在服务器端缓存时，GraphQL带来的灵活性增加了很多复杂性。每个查询都可能不同，这使得响应更难缓存。然而，大多数GraphQL库都带有高效缓存的机制。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><p id="acc8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">GraphQL是以精益方式构建现代软件的更好的解决方案。它使软件更容易改变，并适应不断变化的需求。对于开发现代前端来说，这是一个更好的解决方案，因为数据的形式更加灵活。GraphQL效率更高，性能更好。</p><p id="b9ee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">有一些缺点和技术障碍需要克服，但在大多数情况下，我认为GraphQL的优点远远大于缺点。</p></div></div>    
</body>
</html>