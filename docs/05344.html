<html>
<head>
<title>Optimization in Python — Peephole</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的优化—窥视孔</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimization-in-python-peephole-e9dc84cc184d?source=collection_archive---------1-----------------------#2020-08-21">https://levelup.gitconnected.com/optimization-in-python-peephole-e9dc84cc184d?source=collection_archive---------1-----------------------#2020-08-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="ab35" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">编程，PYTHON</h2><div class=""/><div class=""><h2 id="11ed" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">Python的窥视孔优化技术简介</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/e8bc581d95a1907c58b329848105e90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t1I2WFIfrnE4dJ69"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@ratushny" rel="noopener ugc nofollow" target="_blank"> Dmitry Ratushny </a>在<a class="ae li" href="https://unsplash.com/photos/xsGApcVbojU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl lj lk hy ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="in io ip iq ir"><p id="9dd1" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">在我们深入窥视孔优化的细节之前，让我们试着理解Python代码是如何执行的。随着Python程序的运行，源代码被编译成一组名为<code class="fe mm mn mo mp b">bytecode</code>的指令。这个中间文件<code class="fe mm mn mo mp b">bytecode</code>以<code class="fe mm mn mo mp b">.pyc</code>扩展名存储在<code class="fe mm mn mo mp b">__pycache__</code>文件夹下，然后由Python解释器执行。这个<code class="fe mm mn mo mp b">bytecode</code>或<code class="fe mm mn mo mp b">.pyc</code>文件包含一个“更快”或“优化”版本的源代码。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj mq"><img src="../Images/5555e33d28f109a1f8f257218b884400.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*vcbd8kjyoBQcGwHwc4sUag.png"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><p id="2f60" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated"><a class="ae li" href="https://stackoverflow.com/questions/5768684/what-is-a-python-code-object" rel="noopener ugc nofollow" target="_blank">编译后的代码对象</a>可以通过函数上的属性<code class="fe mm mn mo mp b">__code__</code>访问，并带有一些重要的属性。这里我们感兴趣的是<code class="fe mm mn mo mp b">co_consts</code>。当我们浏览下面的例子时，我们会理解这些。</p><ul class=""><li id="10be" class="mr ms iu ls b lt lu lw lx lz mt md mu mh mv ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">co_consts</code>返回函数体中出现的任何文字的元组</li><li id="5391" class="mr ms iu ls b lt na lw nb lz nc md nd mh ne ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">co_varnames</code>返回包含函数体中使用的任何局部变量名称的元组</li><li id="cd40" class="mr ms iu ls b lt na lw nb lz nc md nd mh ne ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">co_names</code>返回函数体中引用的任何非本地名称的元组</li></ul><blockquote class="nf ng nh"><p id="3d22" class="lq lr ni ls b lt lu ke lv lw lx kh ly nj ma mb mc nk me mf mg nl mi mj mk ml in bi translated">代码对象包含<code class="fe mm mn mo mp b">bytecode</code>以及CPython运行<code class="fe mm mn mo mp b">bytecode</code>所需的一些其他信息。当我们在Python中定义一个函数时，它会为它创建一个代码对象，我们可以使用<code class="fe mm mn mo mp b">__code__</code>属性来访问它。</p></blockquote><h1 id="fa39" class="nm nn iu bd no np nq nr ns nt nu nv nw kj nx kk ny km nz kn oa kp ob kq oc od bi translated"><strong class="ak">窥视孔优化</strong></h1><p id="1e12" class="pw-post-body-paragraph lq lr iu ls b lt oe ke lv lw of kh ly lz og mb mc md oh mf mg mh oi mj mk ml in bi translated">这是Python中另一种类型的优化技术。随着Python源代码通过编译步骤，某些东西如数值表达式、字符串和元组得到优化并存储在<code class="fe mm mn mo mp b">bytecode</code>指令中。让我们进入细节。</p><h1 id="e712" class="nm nn iu bd no np nq nr ns nt nu nv nw kj nx kk ny km nz kn oa kp ob kq oc od bi translated">常量表达式</h1><h2 id="6d65" class="oj nn iu bd no ok ol dn ns om on dp nw lz oo op ny md oq or oa mh os ot oc ja bi translated">数字计算</h2><p id="9008" class="pw-post-body-paragraph lq lr iu ls b lt oe ke lv lw of kh ly lz og mb mc md oh mf mg mh oi mj mk ml in bi translated">常量表达式，例如<code class="fe mm mn mo mp b">a = 30 * 8 * 70,</code>在编译期间得到优化。</p><p id="f422" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">假设您的应用程序在程序执行期间必须多次引用这个变量。在这种情况下，Python决定通过计算值<code class="fe mm mn mo mp b">16800</code>并将其存储在变量<code class="fe mm mn mo mp b">a</code>中来优化这个表达式。你可能认为我们可以直接将<code class="fe mm mn mo mp b">16800</code>赋给变量<code class="fe mm mn mo mp b">a</code>。但这是以失去可读性为代价的，因为这可能表示30天、8小时和70美元/人。这样写比直接使用<code class="fe mm mn mo mp b">16800</code>更有意义。</p><h2 id="60fd" class="oj nn iu bd no ok ol dn ns om on dp nw lz oo op ny md oq or oa mh os ot oc ja bi translated">字符串长度≤ 4096 &amp;元组长度≤ 256</h2><p id="689c" class="pw-post-body-paragraph lq lr iu ls b lt oe ke lv lw of kh ly lz og mb mc md oh mf mg mh oi mj mk ml in bi translated">任何长度≤ 4096的字符串和长度≤ 256的元组都会像上面解释的数值常量一样得到优化。任何超出这个范围的都不会被Python优化。</p><p id="acc7" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">在这个例子中，a、b和c被优化，因为它们的长度小于上述阈值。</p><pre class="kt ku kv kw gu ou mp ov ow aw ox bi"><span id="8693" class="oj nn iu mp b gz oy oz l pa pb">a = "TDS" * 5<br/>b = [1, 2] * 7<br/>c = (10, 20, 30) * 3</span></pre><h1 id="4622" class="nm nn iu bd no np nq nr ns nt nu nv nw kj nx kk ny km nz kn oa kp ob kq oc od bi translated">会员测试</h1><p id="fa6f" class="pw-post-body-paragraph lq lr iu ls b lt oe ke lv lw of kh ly lz og mb mc md oh mf mg mh oi mj mk ml in bi translated">首先，让我们试试什么是成员操作符。成员资格运算符用于测试列表、元组或字符串等序列中的成员资格。Python中有两个成员操作符— <code class="fe mm mn mo mp b"><strong class="ls je">in</strong></code>和<code class="fe mm mn mo mp b"><strong class="ls je">not in</strong></code>。为了更好地理解，请参考下面的示例。</p><pre class="kt ku kv kw gu ou mp ov ow aw ox bi"><span id="e3f1" class="oj nn iu mp b gz oy oz l pa pb">2 in [1,2,3]<br/>&gt;&gt; True</span><span id="0c7f" class="oj nn iu mp b gz pc oz l pa pb">5 in [1,2,3]<br/>&gt;&gt; False</span><span id="4bbe" class="oj nn iu mp b gz pc oz l pa pb">5 not in [1,2,3]<br/>&gt;&gt; True</span></pre><p id="58dc" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">既然我们已经理解了什么是成员资格操作符，那么让我们来理解与成员资格测试相关的优化。</p><p id="a4f1" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">每当Python遇到可变对象(如列表和集合)的成员测试时，它们将在编译期间被它们的不可变对应物替换。这意味着编译过程中的<code class="fe mm mn mo mp b">lists are converted to tuples</code>和<code class="fe mm mn mo mp b">sets are converted to frozen sets</code>。</p><blockquote class="nf ng nh"><p id="83b5" class="lq lr ni ls b lt lu ke lv lw lx kh ly nj ma mb mc nk me mf mg nl mi mj mk ml in bi translated">如果你没有看过我之前关于Python中可变性和不变性的文章，请<a class="ae li" href="https://towardsdatascience.com/optimization-in-python-interning-805be5e9fd3e" rel="noopener" target="_blank"> <strong class="ls je">点击这里</strong> </a>阅读文章。</p></blockquote><p id="6097" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">当Python遇到列表[10，20，30]时，它在编译期间被替换为元组，即(10，20，30)。同样的方法<code class="fe mm mn mo mp b">sets</code>被替换为<code class="fe mm mn mo mp b">frozen sets</code>。</p><h2 id="1ac1" class="oj nn iu bd no ok ol dn ns om on dp nw lz oo op ny md oq or oa mh os ot oc ja bi translated">示例1:</h2><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pd"><img src="../Images/0fbfc0c8a76aeb78abd1af1d0ded063d.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*yplIt-IEgBANM1xeWEDbQQ.png"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><ul class=""><li id="23cd" class="mr ms iu ls b lt lu lw lx lz mt md mu mh mv ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">30 * 8 * 70</code>是常量表达式。所以它被编译器赋值给<code class="fe mm mn mo mp b">16800.</code></li><li id="e3e4" class="mr ms iu ls b lt na lw nb lz nc md nd mh ne ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">“TDS” * 3</code>也是常量表达式，长度小于4096。所以它也被编译器赋值给<code class="fe mm mn mo mp b">TDSTDSTDS.</code></li><li id="8cea" class="mr ms iu ls b lt na lw nb lz nc md nd mh ne ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">“T” * 4097</code>是长度≥ 4096的序列，因此编译器不会对其进行评估。</li><li id="0f3f" class="mr ms iu ls b lt na lw nb lz nc md nd mh ne ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">(1, 2) * 5</code>是长度为10的序列，小于元组的阈值，即256，因此它被评估并存储为<code class="fe mm mn mo mp b">(1,2,1,2,1,2,1,2,1,2).</code></li><li id="2804" class="mr ms iu ls b lt na lw nb lz nc md nd mh ne ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">(10,)</code>是一个长度为257的序列，超过了元组的阈值，因此编译器不会对其进行评估。</li><li id="cc15" class="mr ms iu ls b lt na lw nb lz nc md nd mh ne ml mw mx my mz bi translated"><code class="fe mm mn mo mp b">[101, 102] * 2</code>是列表。因为列表是可变的对象，所以它不会被编译器计算。</li></ul><h2 id="d9a3" class="oj nn iu bd no ok ol dn ns om on dp nw lz oo op ny md oq or oa mh os ot oc ja bi translated">示例2:</h2><p id="4d8c" class="pw-post-body-paragraph lq lr iu ls b lt oe ke lv lw of kh ly lz og mb mc md oh mf mg mh oi mj mk ml in bi translated">在这个例子中，我们将看看关于成员测试的窥视孔优化。从下面的代码中我们可以看到，list和sets分别被替换为tuple和freezed sets。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pe"><img src="../Images/1aa75e3c63a0ae72d86995e11e6a08f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*f7rtGzoyz1o9h3Z_bHY8zg.png"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><blockquote class="nf ng nh"><p id="a362" class="lq lr ni ls b lt lu ke lv lw lx kh ly nj ma mb mc nk me mf mg nl mi mj mk ml in bi translated"><strong class="ls je">提示</strong>:相对于链表和元组，我们更喜欢集合成员操作，因为集合成员操作要快得多。</p></blockquote><h1 id="7c97" class="nm nn iu bd no np nq nr ns nt nu nv nw kj nx kk ny km nz kn oa kp ob kq oc od bi translated">结论</h1><p id="ee68" class="pw-post-body-paragraph lq lr iu ls b lt oe ke lv lw of kh ly lz og mb mc md oh mf mg mh oi mj mk ml in bi translated">希望你已经理解了Python中窥孔优化的概念。阅读我之前关于Python优化技术“实习”的文章。</p><div class="pf pg gq gs ph pi"><a href="https://towardsdatascience.com/optimization-in-python-interning-805be5e9fd3e" rel="noopener follow" target="_blank"><div class="pj ab fp"><div class="pk ab pl cl cj pm"><h2 class="bd je gz z fq pn fs ft po fv fx jd bi translated">Python中的优化—实习</h2><div class="pp l"><h3 class="bd b gz z fq pn fs ft po fv fx dk translated">了解Python的优化技术——实习。</h3></div><div class="pq l"><p class="bd b dl z fq pn fs ft po fv fx dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw lc pi"/></div></div></a></div><p id="e91a" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated"><em class="ni">阅读更多关于Python和数据科学的此类有趣文章，</em> <a class="ae li" href="https://pythonsimplified.com/home/" rel="noopener ugc nofollow" target="_blank"> <strong class="ls je"> <em class="ni">订阅</em> </strong> </a> <em class="ni">到我的博客</em><a class="ae li" href="http://www.pythonsimplified.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ls je"><em class="ni">www.pythonsimplified.com</em></strong></a><strong class="ls je"><em class="ni">。</em> </strong>你也可以在<a class="ae li" href="https://www.linkedin.com/in/chetanambi/" rel="noopener ugc nofollow" target="_blank"><strong class="ls je">LinkedIn</strong></a><strong class="ls je">上联系我。</strong></p></div><div class="ab cl lj lk hy ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="in io ip iq ir"><h1 id="e19e" class="nm nn iu bd no np px nr ns nt py nv nw kj pz kk ny km qa kn oa kp qb kq oc od bi translated">参考</h1><div class="pf pg gq gs ph pi"><a href="https://towardsdatascience.com/understanding-python-bytecode-e7edaae8734d" rel="noopener follow" target="_blank"><div class="pj ab fp"><div class="pk ab pl cl cj pm"><h2 class="bd je gz z fq pn fs ft po fv fx jd bi translated">理解Python字节码</h2><div class="pp l"><h3 class="bd b gz z fq pn fs ft po fv fx dk translated">了解如何反汇编Python字节码</h3></div><div class="pq l"><p class="bd b dl z fq pn fs ft po fv fx dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="qc l pt pu pv pr pw lc pi"/></div></div></a></div></div></div>    
</body>
</html>