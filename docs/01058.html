<html>
<head>
<title>Understanding gRPC and implementing a practical application in Go and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解gRPC并在Go和Python中实现一个实际应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-grpc-a-practical-application-in-go-and-python-f3003c9158ef?source=collection_archive---------1-----------------------#2019-11-01">https://levelup.gitconnected.com/understanding-grpc-a-practical-application-in-go-and-python-f3003c9158ef?source=collection_archive---------1-----------------------#2019-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/efabf6ca1e49e5be08d0b81ba577703d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wE7BaJxtd_awBNdt58KC9Q.jpeg"/></div></div></figure><p id="cc52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你从未听说过gRPC，并且想知道它是什么，这篇文章就是为你准备的。您将了解到一个强大的新工具，可以用来开发分布式应用程序。</p><p id="e8bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">gRPC是一个复杂的主题，我的目的是提供一个温和的介绍，并提供概念背后的直觉。我们将首先回顾基础知识，然后回顾gRPC的概念。最后我们会看到一个Golang和Python的实际例子。</p><p id="21ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在深入gRPC之前，让我们回顾一下什么是RPC。如果您已经熟悉它，您可以放心地跳到gRPC。让我们开始吧。</p><h2 id="4e5e" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">RPC是什么？</h2><p id="7fc3" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">如果您关注了分布式系统课程，您就会知道什么是RPC。但是对于那些没有参加那些讲座的人来说，RPC代表<em class="lx">‘远程过程调用’。</em></p><p id="1acf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RPC是一个古老的概念。自70年代和80年代以来，这种技术一直被用于开发分布式系统。RPC的定义如下:</p><blockquote class="ly lz ma"><p id="440c" class="kb kc lx kd b ke kf kg kh ki kj kk kl mb kn ko kp mc kr ks kt md kv kw kx ky im bi translated">远程过程调用是一种协议，一个程序可以用它向网络上另一台计算机中的程序请求服务[…]</p></blockquote><p id="9749" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来分解一下。它是一个协议，这意味着它可以在不同的环境中以多种方式实现。您将发现RPC在C++中的实现和Java中的不同实现。</p><p id="6930" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据定义，我们理解RPC意味着一个系统(客户机)正在从另一个系统(服务器)请求一些服务。但是这个定义并没有真正解释为什么它被称为<em class="lx">远程过程调用。</em></p><p id="611e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在任何编程语言中，你都有函数的概念。在技术术语中，这被称为<em class="lx">程序。简单地说，你在程序中编写的任何函数都是一个<em class="lx">过程</em>，任何时候你调用这个函数，你都是在做一个<em class="lx">过程调用</em>。所以另一种看待RPC的方式是一个系统在另一个(远程)系统上调用一个<em class="lx">过程</em>(或函数)<em class="lx"> </em>。</em></p><p id="76bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当您调用本地过程或调用函数时，以下事情会按顺序发生:</p><ul class=""><li id="2ca6" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">进程的当前状态被推送到堆栈上，以便以后可以恢复。</li><li id="d1b2" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">收集传递给函数的参数，流程执行跳转到定义函数的地方。</li><li id="e110" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">使用传递的参数执行函数，并收集结果。</li><li id="eb97" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">然后我们带着结果回到之前的执行状态。</li></ul><p id="4788" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">把一个函数想象成一个黑盒。传递一些输入值，然后得到输出值。你并不关心为得到那个结果所采取的所有步骤。例如:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9e0f" class="kz la it mx b gy nb nc l nd ne">int a = add(10, 14);</span></pre><p id="97db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在RPC中，事情是非常相似的。你传递输入值，然后在程序中得到输出值。你给黑盒<code class="fe nf ng nh mx b">10</code>和<code class="fe nf ng nh mx b">14</code>，它会在你的结果变量<code class="fe nf ng nh mx b">a</code>中给你<code class="fe nf ng nh mx b">24</code>。</p><p id="889d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RPC的神奇之处在于，当您调用该函数时，数字的实际加法或函数的执行并不发生在您的机器上。事情是这样的:</p><ul class=""><li id="7e42" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">进程的当前状态被推送到堆栈上，以便以后可以恢复。</li><li id="e67c" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">收集传递的参数值，并构造一个包含函数名和参数值的消息包。</li><li id="cf1c" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">这个信息包被发送到一个远程系统。远程系统打开这个消息，查看函数名和参数。然后，远程系统使用传递的值执行该函数。</li><li id="047d" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">远程系统构建包含函数结果的消息。它被送回我们的系统。</li><li id="c51c" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">我们的系统解包消息并得到结果。程序中先前的执行状态被恢复，我们得到了函数调用的结果。</li></ul><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f3dc0869590261fa14b6e55393bde031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*qeuyQYwwcjRk8B1a4SoHOw.png"/></div></figure><p id="df7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有这些东西实际上都是为程序员抽象的。程序员关心的只是调用函数并得到结果。</p><p id="889f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在整个系统运行之前，有许多细节需要处理。但是现在，如果您能够理解在远程计算机上调用函数并在程序中获得结果的概念，那么我们就可以开始了！</p><h2 id="accf" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">gRPC是什么？</h2><p id="0cc0" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">RPC是一种协议。gRPC是RPC协议的一种实现。从前面的小节中，您可以对RPC协议进行一些观察:</p><ul class=""><li id="cc9e" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">客户端和服务器之间需要就功能和参数定义达成一致。</li><li id="624f" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">只要定义一致，客户机和服务器系统上的程序不必用同一种语言编写。</li><li id="dde5" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">我们需要某种方式通过网络在两个系统之间传递消息。</li></ul><p id="d22a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看gRPC是如何处理每一点的。</p><p id="23a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">任何RPC系统都必须有一致的函数和参数定义。否则，客户端会要求执行<code class="fe nf ng nh mx b">add</code>函数，如果服务器没有任何名为<code class="fe nf ng nh mx b">add</code>的函数，整个过程就会中断。</p><p id="1569" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">gRPC通过维护一个通用的配置文件来解决跨系统保持一致性的问题。服务器和客户机是使用这个公共配置(或者说定义文件)创建的，它定义了RPC函数、参数和返回值。</p><p id="72c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一点是客户机或服务器不需要用同一种语言编写。为了实现这一点，我们需要一种与语言无关的方式来定义配置文件，以便它在任何语言中都被解释为相同的。因此，gRPC提出了他们自己的定义语言，称为<a class="ae nj" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>，作为描述功能和参数的接口定义语言(IDL)。</p><p id="6b40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在日常的web系统中，每当服务器和客户机想要交互时，它们就使用JSON格式的消息。任何语言的客户机和服务器都可以解释这些JSON消息。但是JSON对于计算机来说解析起来不是很有效，尽管它更容易被人理解。计算机解析二进制比高级消息格式快得多。所以为了解决上面提到的第三点，gRPC使用了一种新的二进制消息格式，称为<a class="ae nj" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank"> protobuf </a>(是的，协议缓冲区和protobuf是一回事)。其优势在于protobuf是两个系统之间非常有效的通信方式。您可以在提供的链接中了解更多关于protobufs的信息，并了解为什么它比JSON更好。</p><p id="de4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，理论到此为止！让我们来看一个示例实现。</p><h2 id="578b" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">Python和Go中的示例</h2><p id="fc97" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">正如我们所见，gRPC是独立于语言的。您可以让客户机使用一种语言，让服务器使用另一种语言。今天我们将看到Python和Go如何使用gRPC相互交流。</p><p id="dcd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我有一个要求，清理一些文字和提取关键字。这个特殊的任务在Python中很容易执行，Python提供了像<code class="fe nf ng nh mx b">nltk</code>这样的工具来处理文本。但是我剩下的节目在Golang。而且我不想在Golang执行同样的任务。所以我决定用Python制作一个服务，它将接受一些文本并返回关键字。我们将从Golang调用这个服务作为RPC。</p><p id="307f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在使用gRPC之前，我们需要安装一些依赖项。你需要为<a class="ae nj" href="https://grpc.io/docs/tutorials/basic/go/" rel="noopener ugc nofollow" target="_blank"> Golang </a>和<a class="ae nj" href="https://pypi.org/project/grpcio-tools/" rel="noopener ugc nofollow" target="_blank"> Python </a>安装<a class="ae nj" href="https://developers.google.com/protocol-buffers/docs/downloads" rel="noopener ugc nofollow" target="_blank"> protobuf </a>编译器和gRPC插件。我假设您的系统上已经安装了Golang和Python。</p><p id="04c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当使用gRPC时，第一步总是编写公共定义文件。让我们为我们所需的服务编写一个定义文件，它将包含一个函数调用，该函数调用将执行我们所需的任务。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bb25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们将数据放在两个消息中— <code class="fe nf ng nh mx b">Request</code>和<code class="fe nf ng nh mx b">Response</code>(您可以给它们起任何名字)。我们还定义了一个<code class="fe nf ng nh mx b">KeywordService</code>，它包含一个<code class="fe nf ng nh mx b">rpc GetKeywords</code>，它接受一个<code class="fe nf ng nh mx b">Request</code>输入并返回一个<code class="fe nf ng nh mx b">Response</code>。因为我们想在<code class="fe nf ng nh mx b">Response</code>中返回一个<code class="fe nf ng nh mx b">Keywords</code>的列表，所以我们使用了<code class="fe nf ng nh mx b">repeated string</code>。您可以详细检查协议缓冲区的语法，但是现在这些已经足够了。</p><p id="79c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在下一步是，我们需要从这个定义文件中生成特定于语言的接口。使用gRPC提供的工具可以生成Golang和Python语言的特定接口。</p><p id="597d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您将定义文件保存为<code class="fe nf ng nh mx b">nltk_service.proto</code>的目录下创建两个名为<code class="fe nf ng nh mx b">python</code>和<code class="fe nf ng nh mx b">golang</code>的文件夹。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2d61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行这些命令后，您将看到<code class="fe nf ng nh mx b">golang</code>和<code class="fe nf ng nh mx b">python</code>文件夹现在包含一些自动生成的代码。您不应该修改生成的代码。我们将在程序中导入生成的代码来构建客户机和服务器。</p><p id="b2b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在两端构建客户端和服务器。但是对于这个例子，我只需要一个提供服务的Python服务器和一个使用该服务的Golang客户机。所以我们将用Python实现服务器，用Golang实现客户端。</p><h2 id="3704" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated"><strong class="ak"> Python服务器</strong></h2><p id="254b" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我们首先必须将自动生成的代码导入我们的程序。接下来，我们必须实现RPC方法<code class="fe nf ng nh mx b">GetKeywords</code>。生成的代码有一个Python类<code class="fe nf ng nh mx b">KeywordsServiceServicer</code>。我们想用自己的方法扩展这个类，并覆盖<code class="fe nf ng nh mx b">GetKeywords</code>方法。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7dfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当覆盖<code class="fe nf ng nh mx b">GetKeywords</code>函数时，我们可以访问定义文件中定义的输入参数，即包含<code class="fe nf ng nh mx b">string text</code>的<code class="fe nf ng nh mx b">Request</code>。因此，我们可以用它来访问参数值。我们使用一些逻辑处理从客户端收到的<code class="fe nf ng nh mx b">text</code>，然后返回一个带有<code class="fe nf ng nh mx b">repeated Keyword</code>的<code class="fe nf ng nh mx b">Response</code>对象。注意，我们使用的所有这些类(<code class="fe nf ng nh mx b">Request</code>、<code class="fe nf ng nh mx b">Response</code>和<code class="fe nf ng nh mx b">KeywordServiceServicer</code>)都是从自动生成的python文件中导入的。</p><p id="93da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经实现了服务器逻辑，我们需要添加一些样板文件来启动实际的服务器:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="26dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将上述文件作为<code class="fe nf ng nh mx b">server.py</code>保存在文件夹<code class="fe nf ng nh mx b">python</code>中。您可以运行该文件在端口6000上启动gRPC服务器。</p><p id="e014" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的服务器已经准备好了！我们去找客户吧。</p><h2 id="ad99" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated"><strong class="ak"> Golang客户端:</strong></h2><p id="aa12" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">首先在我们的<code class="fe nf ng nh mx b">golang</code>文件夹中创建<code class="fe nf ng nh mx b">nltk_service</code>文件夹来解决Golang导入需求。然后移动那个文件夹里的<code class="fe nf ng nh mx b">nltk_service.pb.go</code>。</p><p id="7eca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe nf ng nh mx b">golang</code>文件夹中创建一个文件<code class="fe nf ng nh mx b">client.go</code>，通过运行<code class="fe nf ng nh mx b">go mod init golang</code>将其初始化为go模块。</p><p id="2097" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们需要将自动生成的代码导入Golang客户端。导入的代码将包含一些我们将用来构建客户端的函数。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2f57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你需要提供地址。因为我们在同一个系统上运行两个程序，所以我们使用端口<code class="fe nf ng nh mx b">6000</code>来获取<code class="fe nf ng nh mx b">127.0.0.1</code>，这是我们在Python服务器中定义的。</p><p id="4934" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以调用服务的<code class="fe nf ng nh mx b">GetKeyword</code>函数来执行RPC。在上面的代码中，这是在<code class="fe nf ng nh mx b">MyKeywords</code>函数内部完成的。它将根据原型定义文件返回一个<code class="fe nf ng nh mx b">Response</code>的实例。</p><p id="25f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们通过向Golang客户端添加一个<code class="fe nf ng nh mx b">main</code>函数来完成代码:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f49a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在做的是在一个无限循环中从用户那里获取一些文本。然后我们从联系Python服务器并获得结果的<code class="fe nf ng nh mx b">nltk</code>服务中获取文本中的关键字。然后我们得到最终结果，作为传递给Golang程序的关键字列表。</p><p id="ba48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是相同的操作:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/ad843088c1698259b6855050ff9a9cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MMqrov6YAYQf0GJ6s3L6_w.gif"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">测试Python服务器和Golang客户端</figcaption></figure><p id="5bd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样！我们创建了一个python gRPC服务器和一个Golang客户机。</p><p id="b8fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">值得注意的是，当谈到使用gRPC时，我仅仅触及了皮毛。在开始使用gRPC编写微服务代码之前，您需要了解和包含许多内容。例如，如何处理错误？如何处理多重连接？负载均衡怎么做？如何进行服务发现？如何安全沟通？等等..</p><p id="856c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是希望您对gRPC是什么以及它是如何工作的有所了解。现在你已经准备好自己做一些研究了。另一件事——即使按照本指南进行操作，您也可能会遇到错误，因为我没有给出完成所有事情的详尽步骤。我建议你通过做一些研究来找出什么东西会坏掉。这将有助于巩固你的理解，并对这个话题有更深入的了解。</p><p id="6634" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本帖使用的所有代码都可以在<a class="ae nj" href="https://github.com/Cartmanishere/grpc-python-golang" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><p id="bfe6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>