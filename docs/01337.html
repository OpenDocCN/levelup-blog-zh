<html>
<head>
<title>Event-Based Asynchronous Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于事件的异步编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-programming-with-events-ed347e7fa32a?source=collection_archive---------0-----------------------#2019-12-15">https://levelup.gitconnected.com/asynchronous-programming-with-events-ed347e7fa32a?source=collection_archive---------0-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fdd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的最后两篇文章中，我们研究了各种减少线程阻塞的<a class="ae ko" href="https://medium.com/swlh/overcoming-io-overhead-in-micro-services-47d8f986268b?source=friends_link&amp;sk=7429086c7859c1e51170334edc479fcd" rel="noopener">异步编程范例</a>，然后深入研究了通过线程池完成的<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/asynchronous-programming-with-thread-pools-e42d6bacd171?source=friends_link&amp;sk=9bed94f66cb03b01043e8b03be8f77fb">异步编程。现在让我们来看看真正的非阻塞式编码，以及我们如何使用IO中断作为事件来构建面对大规模负载也能坚持的系统。</a></p><p id="5a77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和以前一样，让我重复一遍，每当我在讨论中提到“阻塞的线程”时，我指的是阻塞/等待IO的线程。我们还应该记住，我们不是在谈论两个系统之间基于事件的通信。我们正在讨论使用IO中断(IO开始、IO完成等)作为事件来控制系统中线程的行为。</p><h1 id="8aa7" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是基于事件的编程</h1><p id="ad87" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">基于事件的编程方法依赖于我们的应用程序中没有阻塞代码。这意味着线程发起IO操作(例如，服务A中的线程调用服务B的REST API)，然后切换到做其他事情。当IO操作完成时，该线程被通知(中断)返回并处理其操作的结果(反序列化响应)。从调用线程的角度来看，整个IO阶段都外包给了其他人，他们会在任务完成时通知它。然后，线程从之前停止的地方开始执行代码路径。</p><p id="91f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从30000英尺的高度看，这种描述与我们讨论的通过线程池进行异步编程非常相似。但是有一个重要的区别。虽然线程池被用来将阻塞IO与调用线程隔离，但是这里没有任何阻塞代码。我们不需要在调用线程的另一端有一个线程池来接受请求并通知调用线程。然而，这留下了一个问题，即在IO操作完成时，由谁来发出中断。</p><p id="dc4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案是——操作系统。*nix系统及其衍生产品长期以来一直支持从应用程序接受IO挂钩，跟踪IO生命周期，并在IO完成时通知应用程序。通过利用这一点，应用程序可以消除IO管理的顾虑，只需专注于触发IO和处理结果。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/402cc792d667b8b7efbcb9a5060493a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*ltwPF98JfgNHzyMsumQRYA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">NIO应用程序的组件</figcaption></figure><h1 id="96bc" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">处理任务移交</h1><p id="378c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">IO发生的方式是应用程序打开一个套接字，然后发出命令，开始通过该套接字发送和接收数据。一旦发送了请求数据，使用每个请求一个线程模型的典型应用程序将只是等待并轮询套接字以查看何时收到结果。这就是阻塞木卫一的由来。</p><p id="8b51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，非阻塞的、基于事件的应用程序将这个等待阶段交给了操作系统。操作系统附带了一个轮询程序(epoll/selector/其他依赖于发行版的程序),它可以非常有效地处理套接字的数据轮询。应用程序将其自己的套接字添加到正在轮询的套接字列表中，并为其提供一个钩子(也称为回调), epoll可以使用该钩子来通知应用程序套接字何时接收到响应以及入站数据流准备好进行处理。应用程序线程现在可以自由处理其他任务。</p><p id="26ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有应用程序线程现在都可以自由处理非IO任务(因为没有任何阻塞IO ),从而使应用程序能够处理大规模任务。</p><h1 id="1276" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">处理任务完成</h1><p id="b1f0" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Epoll将继续轮询向其注册的所有套接字，通常使用单线程。一旦套接字接收到数据，epoll就调用应用程序通过接收到的数据和线程执行上下文(在移交给epoll时也由应用程序隐藏在这里)给予它的回调。当然，epoll并不理解数据是什么，只是说有一些字节是应用程序可以处理的。这个回调中断应用程序线程来处理输出(反序列化、运行业务逻辑等)。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/7569bc86a96ea28571c949886a13a60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lnNAVi50w9R-DSzmgBLPRQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">基于事件的异步编程中的事件序列</figcaption></figure><p id="5688" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，在这种基于事件的风格中，任务移交和线程中断是跨应用程序-操作系统边界发生的。这种交换通常被称为<em class="mj">事件循环</em>。Node.js是第一个利用NIO构建单线程(！idspnonenote)的应用程序开发框架。！！)只要大部分工作是IO绑定的，应用程序仍然可以服务于大量的流量。如今，大多数语言中都有这样的框架(<a class="ae ko" href="https://vertx.io/docs/vertx-core/java/" rel="noopener ugc nofollow" target="_blank"> Vert.x </a>就是一个很好的例子)。</p><h1 id="7528" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">优雅和可扩展性</h1><p id="abd9" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我喜欢基于事件的风格，因为从应用程序设计的角度来看，它比窃取工作的风格优雅得多。应用程序不必在线程池中包装阻塞调用，也不必处理由线程池大小调整导致的敏感应用程序行为。整个应用程序可以异步运行，而不必处理IO管理的细节——我们只是启动IO，不停留，并在它准备好时回来处理输出。风格上的可扩展性！</p><h1 id="b0d6" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">编码时间！</h1><p id="89c4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">让我们回顾一下在每个请求一个线程的模型中进行HTTP API调用的代码。</p><pre class="lt lu lv lw gt mk ml mm mn aw mo bi"><span id="257c" class="mp kq it ml b gy mq mr l ms mt">public class Client {<br/>    public Response get(String url, Request request) {<br/>        // API calling logic<br/>    }<br/>}</span><span id="3f50" class="mp kq it ml b gy mu mr l ms mt">public class CallingClass {<br/>    private Client client = new Client();</span><span id="2b15" class="mp kq it ml b gy mu mr l ms mt">    public void call() {<br/>        String url = “some-api-url”;<br/>        Request requestData = new RequestData();<br/>        Response response = client.get(url, requestData);<br/>        LOG.info(“Got data {}”, response);<br/>   }<br/>}</span></pre><p id="73c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行CallingClass代码的线程将阻塞在<em class="mj"> client.get() </em>上，直到它返回数据。</p><p id="2c6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">NIO风格的代码看起来非常类似于工作窃取风格，只是没有任何任务队列或线程的工作池。</p><pre class="lt lu lv lw gt mk ml mm mn aw mo bi"><span id="f98a" class="mp kq it ml b gy mq mr l ms mt">public class AsyncClient {<br/>    public Future&lt;Response&gt; get(String url, Request request) {<br/>        // API calling logic<br/>    }<br/>}</span><span id="db80" class="mp kq it ml b gy mu mr l ms mt">public class CallingClass {<br/>    private AsyncClient client = new AsyncClient();</span><span id="60aa" class="mp kq it ml b gy mu mr l ms mt">    public void call() {<br/>        String url = “some-api-url”;<br/>        Request requestData = new RequestData();</span><span id="f87f" class="mp kq it ml b gy mu mr l ms mt">        Future&lt;Response&gt; responseFuture = client.get(url, requestData);</span><span id="27cb" class="mp kq it ml b gy mu mr l ms mt">        responseFuture.onComplete() {<br/>          // callback handler for successful future completion<br/>          LOG.info(“Success with data {}”, response);<br/>        }.onFailure() {<br/>          // callback handler for failed future completion<br/>           LOG.error(“API call failed with response {}”, response);<br/>        }<br/>        LOG.info(“Moving on immediately”);<br/>    }<br/>}</span></pre><p id="7082" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码将记录将IO控制权移交给操作系统后“立即继续前进”的情况。epoll将在收到API响应时中断运行CallingClass的线程。然后，应用程序解析数据以了解我们是成功还是失败，然后调用绑定到<em class="mj">未来</em>的相应处理程序。</p><p id="b7b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意这段代码比<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/asynchronous-programming-with-thread-pools-e42d6bacd171?source=friends_link&amp;sk=9bed94f66cb03b01043e8b03be8f77fb">作品窃取风格</a>的代码要简单得多，尽管它遭受了同样的<a class="ae ko" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱问题</a>。</p><h1 id="157b" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">规模限制</h1><p id="c283" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">尽管基于事件的编程范例很棒，但我们用它所能达到的目标是有限的。该模型中可伸缩性的限制来自以下因素。</p><h2 id="c84e" class="mp kq it bd kr mv mw dn kv mx my dp kz kb mz na ld kf nb nc lh kj nd ne ll nf bi translated">内存开销</h2><p id="a1d5" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">每次线程将IO任务移交给操作系统时，它也会移交其执行堆栈中的数据以进行安全保存(以便它可以在接收到完成中断时从同一点恢复)。这些信息保存在内存中，随着越来越多的线程隐藏它们的数据，我们可能会开始耗尽内存。这只会在很高的规模下发生，但是我们不会在低规模下做这种风格的编程。</p><h2 id="c17e" class="mp kq it bd kr mv mw dn kv mx my dp kz kb mz na ld kf nb nc lh kj nd ne ll nf bi translated">数据复制开销</h2><p id="b166" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">当我们使用NIO时，数据和控制在操作系统的用户空间(运行应用程序代码的地方)和内核空间(运行epoll的地方)之间切换。从用户空间到内核空间，然后再回到用户空间的数据复制在操作系统级别上可能非常昂贵。轻量级线程通过始终将所有数据保存在用户空间来避免这个问题，而工作线程池没有这个问题，因为它们从不将控制权交给操作系统。</p><h2 id="a67d" class="mp kq it bd kr mv mw dn kv mx my dp kz kb mz na ld kf nb nc lh kj nd ne ll nf bi translated">在应用程序的其他部分阻塞代码</h2><p id="57e5" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我曾经在某处读到过“<em class="mj">在node.js中做某件事的最好方式就是在node.js </em>中什么都不做”。这句话充分说明了非IO操作对应用程序可伸缩性的影响。虽然我们的IO是非阻塞的，但是应用程序的所有其他部分仍然是阻塞的，从序列化和反序列化IO数据开始。因此，应用程序的总体吞吐量现在由它必须完成的CPU工作量来定义和限制。</p><h2 id="d329" class="mp kq it bd kr mv mw dn kv mx my dp kz kb mz na ld kf nb nc lh kj nd ne ll nf bi translated">太多中断</h2><p id="ad6d" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">单个应用程序线程可能会处理数千个请求。然而，单个线程不能处理的是由于同时完成这些请求而产生的大量中断。我们最终可能会遇到这样的情况，应用程序线程经常被中断，以至于它无法在不增加大量延迟的情况下完全满足任何请求。</p><h1 id="fb6e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">最大化CPU使用率</h1><p id="c8d9" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">的确，使用NIO，单个应用程序线程可以满足比传统应用程序多得多的流量。然而，服务器硬件通常有不止一个CPU内核，如果我们只运行一个应用程序线程，我们会在桌面上留下大量硬件容量。单线程应用程序也更容易受到上面提到的最后两个问题的影响(由于阻塞代码和太多中断导致的性能下降)。</p><p id="ebe9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://vertx.io/docs/vertx-core/java/#_reactor_and_multi_reactor" rel="noopener ugc nofollow" target="_blank">多反应器模式</a>通过运行多个事件循环线程提供了一种解决方法(根据经验，线程数量通常是CPU内核数量的两倍)。通过充分利用所有内核，这为系统增加了大量容量，因此阻塞代码和中断数量不再是问题。</p><h1 id="1341" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">不是所有东西都可以无阻塞</h1><p id="5ceb" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">基于事件的编程范例的前提是，API不会阻塞线程来完成IO操作。通常，这些地方是对远程API的网络调用、数据库查询、文件读/写等。实际上，很少可能让我们所有的代码都是非阻塞的。数据库，尤其是RDBMS，通常对NIO的支持很差(主要是因为事务支持的实现方式)。应用程序容器也需要支持异步程序。如果我的REST服务返回一个未来的<response>，应用服务器(例如Tomcat)应该能够理解这一点，并拥有自己相应的事件驱动代码来处理客户端请求。不幸的是，这并没有被广泛采用。</response></p><p id="4270" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们不可能总是拥有一个完全基于事件的系统。为了解决这个问题，我们经常在大多数应用程序中看到NIO(在API允许的情况下)、线程池(将阻塞代码转换为异步模式)和普通的旧阻塞代码的组合。</p><h1 id="c046" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">我们真的改变了什么吗？</h1><p id="afdb" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">您可能已经注意到，epoll仍然需要运行一个线程来轮询所有的套接字，这实际上是一个阻塞操作。那么，从某种意义上来说，难道不是还在使用线程池(只有一个线程的线程池)吗？</p><p id="c758" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是正确的，但事实是我们(即应用程序)不再这样做了。该应用程序完全由事件驱动，操作系统在处理套接字轮询等低级操作方面效率极高。当然，这限制了我们可以执行的操作数量(就像前面提到的数据复制问题一样)，但总体而言，基于事件的风格使应用程序比每个请求一个线程的应用程序更具可伸缩性，并且比线程池风格的应用程序设计得更好。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="e539" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mj">如果你喜欢这篇文章，你可以订阅</em> <a class="ae ko" href="https://www.kislayverma.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mj">我的邮件列表</em> </a> <em class="mj">来获得最新消息。</em></p></div></div>    
</body>
</html>