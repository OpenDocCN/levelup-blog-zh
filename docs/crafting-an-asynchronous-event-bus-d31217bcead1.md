# 制作异步事件总线

> 原文：<https://levelup.gitconnected.com/crafting-an-asynchronous-event-bus-d31217bcead1>

![](img/bb3f7b0ccfb83155cd20e389cf603f7b.png)

由 [Pablo Heimplatz](https://unsplash.com/@pabloheimplatz) 在 [Unsplash](https://unsplash.com/) 上拍摄的照片

T4:我们都去过那里。愉快地使用一个应用程序，然后，点击，旋转球。应用程序不再响应，我们不得不永远等待，然后才能再次与它交互。没有什么比一个缓慢、无响应的应用程序更能扼杀用户体验了。解决方案通常很简单:将痛苦的任务推给后台线程、进程或服务器，并一直等待结果返回，同时用户可以愉快地与响应应用程序进行交互。但是，如何在一个复杂的应用程序中大规模地实现这一点呢？这个应用程序可能有许多动作需要在 gui 组件之间进行协调。这里，我们介绍一种解决方案，通过调用应用程序事件总线并将异步需求嵌入到事件总线中，允许事件总线处理同步和异步事件，干净地同时分离事件接口后面的应用程序的逻辑关注点，并将应用程序的异步特性集中在一个位置。

在本文中，我们将讨论一个桌面应用程序，但是如果有一些创造性的话，这个原理可以被更广泛地应用。值得注意的是，如果你的目标语言和框架支持协同多任务处理(比如 async/await)，那么就需要做一些修改，但是请继续阅读，寻找一些灵感和可能的想法。示例的存储库可以在 [Github](https://github.com/ctangell/event-example) 上找到。

# 激发事件总线

为了理解引入事件总线的必要性，让我们考虑一个两个窗口和一个需要协调行为的应用程序服务的常见示例。在这里，搜索窗口将向数据库发送查询，数据库将返回简短的结果，然后可以选择这些结果并在搜索窗口旁边的非模态结果窗口中显示。此外，结果窗口允许修改结果和更新数据库中的结果。原则上，结果窗口或数据库可以随后触发搜索窗口来更新其搜索结果。

![](img/d353dcdfeae384ddcc06e676ce927270.png)

图 1 泥球(左)与事件总线架构(右)

这种情况的简单解决方案如图 1 左侧所示。因为结果窗口和搜索窗口在应用程序的同一个逻辑层，所以没有明确的方法使一个从属于另一个。两者都依赖于数据库，搜索窗口影响结果窗口中显示的内容，结果窗口原则上可以通过更新结果来影响搜索窗口。这种解决方案需要给搜索窗口一个对要更新的结果窗口内部状态的直接引用，给结果窗口和搜索窗口一个对数据库的直接引用，并且可能将对搜索窗口的引用传递给结果窗口。我们可以创建一个容器对象来容纳两个窗口，并协调它们的行为，但是这种解决方案不能很好地伸缩，而且行为会被硬编码到组件中。无论我们选择哪种方式，我们这里只有三个组件，并且我们已经有了一个高度耦合的 mud 球。

通过引入事件总线，可以将三个组件分开，让它们只与事件总线对话，如图 1 右侧所示。通过抽象它们的行为来只反映可接收的事件，几个组件可以不需要知道其他对象的内部，并且可以依靠事件总线在应用程序中传输意图。事件总线的工作方式是为给定事件注册一个处理程序，然后在总线上发出事件以响应与应用程序的交互，或者传输来自服务层组件(如数据库和网络连接)的结果。这样，通过向事件总线注册另一个事件处理程序，可以将附加行为添加到应用程序中。例如，在长时间运行的过程结束时发送电子邮件或文本通知，或者向应用程序的所有窗口提供数据库状态更新。事件的发送者被巧妙地从接收者中抽象出来，减少了组件之间的耦合。

# GUI 和异步行为

![](img/b002771b4ffc39b2d4d7f91df1c5f47a.png)

图 2 GUI 事件循环是如何工作的。事件循环等待外部事件(通常来自操作系统)，然后在事件到达时获取注册的回调，然后同步运行每个回调。运行回调时，事件循环被阻塞。

为了理解为什么 gui 应用程序中的异步行为在本质上是必要的，以及为什么这个细节需要特别注意，我们需要首先理解 gui 事件循环是如何工作的。如图 2 所示，事件循环在应用程序的主线程上运行，并等待事件，通常是来自操作系统的 gui 交互。在此期间，线程完全空闲。事件一到达，线程就活跃起来，并搜索连接到该事件的处理程序。然后，它依次运行每个处理程序，并在完成后返回静止状态，等待另一个事件的到来。它在事件到达时的激烈活动标志着一个非常重要的警告:它是一个线程，并且只有一个线程，当它工作时不能做任何其他事情。所有后续的 gui 交互都被阻止。因此，如果您的处理程序通过从主线程下载网站或访问数据库等操作花费了太长时间，那么这个旋转的球就会运行。因此，需要将此类活动从主线程中移走，以便事件循环可以继续运行。

但是，你可能会问，为什么 gui 只在一个线程上运行？Gui 通常要求 gui 组件只能从与 gui 事件循环相同的线程中创建和更新。正如我们将在下面看到的，由于这一点，gui 系统提供了一种从其他线程安全地触发事件循环的方法，允许对更新的控制安全地移回到主线程。因此，只要其他线程使用这种内置机制来确保影响 gui 的更新发生在主线程上，就可以安全地产生其他线程来完成工作。另一方面，您也许可以从其他线程中进行 gui 更新，但是如果您这样做了，您的应用程序可能会不可思议地崩溃。

在这里，事件总线可以提供帮助，提供一种处理异步行为的方法，同时确保 gui 的更新总是发生在主线程上，并使应用程序能够根据需要灵活增长。将异步特性集中在单个位置还通过仅提供一个点和一种机制简化了 gui 应用程序设计，其中后台线程的结果需要被移回到 gui 事件循环线程。异步事件循环通过引入异步工作处理程序和同步 gui 更新处理程序的概念来解决这些问题，异步工作处理程序意味着在单独的线程上运行，同步 GUI 更新处理程序意味着在主线程上运行。在保持分离的同时，本解决方案通过简单地将所有发出的事件推送到主线程来解决 gui 更新问题，然后适当地处理 gui 更新并将工作处理程序分派到单独的线程。请注意，在下面的解决方案中，从主线程发出的事件确实有一点往返，但是本解决方案是最简单的解决方案，它维护了必要的抽象，并确保所有事件都源自主线程。

# 实际例子

为了演示图 1 右侧所示的上述架构示例，将使用 Python。应该强调的是，这些原则是与语言和 gui 无关的。然而，将只使用 Python 标准库模块。下面是代码片段，完整的例子可以在[这里](https://github.com/ctangell/event-example)找到。以下是我们使用的模块:

*   tkinter—Python 标准库中包含的一个 gui。有很多很多的例子和 howto 来解释如何使用它，所以大部分都是从下面的代码中截取的。
*   concurrent . futures——Python 中实现并发性的推荐方式。它使用 actor 模型将任务分派给线程或进程池。
*   队列—线程安全队列。它们可以用来在线程之间安全地发送信息，而不需要锁。
*   集合 namedtuple 数据类型用于提供具有预定义样板文件的原子对象。类似于数据类，但灵活性较低，可以在 Python 3.7 之前的版本中使用。

## 从最终目标开始

要在代码中查看所有内容是如何组合在一起的，请使用“__main__”。py”被显示。可以看出，数据库和两个窗口都只依赖于事件总线，而不是相互依赖。

__main__。巴拉圭

为了测试 app 的异步特性，克隆[库](https://github.com/ctangell/event-example)，并运行“python -m event_example”。不应该有应用程序的拖延。然后将“db.py”中的行“is_async=True”改为“is_async=False”。你现在应该注意到，当点击按钮时，应用程序会暂时停止响应。

## 异步事件总线

事件总线必须做四件事:它必须创建和管理异步任务被分派到的线程池，提供一种注册处理程序的方法，提供一种发出事件的机制，并确保发出的事件都在主线程上启动，独立于调用发出函数的线程。

eventbus.py

线程池(第 30 行)使用 ThreadPoolExecutor 的默认设置。这通常就足够了。特别是在 Python 中，使用线程池很重要，而不是每次都简单地产生一个新线程，以避免线程爆炸和随后由于 GIL(全局解释器锁)而发生的线程匮乏。即使有 IO 绑定的线程，Python 也有棘手的并发问题，这促使将线程总数保持在合理的数量。一个好的上限通常是 20 个线程。

处理程序注册是在 connect 方法中完成的(第 75 和 77 行)。维护两个独立的事件到处理程序的映射，一个用于应该同步调用的处理程序，另一个用于应该异步调用的处理程序。注意，对一个事件没有限制:一个传入事件可以合理地同时拥有多个同步和异步处理程序。这样做的一个很好的理由是，如果在调度给定事件时需要同步 gui 更新，通知系统相应的异步处理已经开始。此外，在这里，处理函数或方法被附加到一个列表中，在方法的情况下保持对底层对象的强引用。如果对象超出范围并被垃圾回收，这将导致问题。关于如何处理这个问题的想法，请参见下面的警告。

要发出一个事件，如 syncemit()(第 52 行)所示，线程不安全的版本，从事件类型的映射中查询处理程序，简单地循环所有同步处理程序并依次调用它们，同时将异步处理程序分派给线程池。

确保在主线程上处理事件的机制嵌入在 emit()(第 36 行)中，这是用于发出的线程安全版本。传入的事件被推送到一个队列中，然后 gui 事件循环被发送一个在第 n 行的 EventBus init 方法中注册的特殊事件。当 gui 事件被推送到 gui 事件循环(第 42 行)中时，它被调用注册的回调(第 34 行注册)的主线程依次处理，这里是第 44 行的 _emit()。_emit()从队列中弹出每个事件总线事件，因为我们保证在主线程上，所以可以安全地直接调用 emit 的同步版本。

队列用于在线程之间移动事件总线事件，因为 gui 不在 gui 事件循环中提供机制来搜寻除了 gui 事件已经发生之外的信息。对于 tkinter 来说，gui 事件只是一个特殊的标识字符串，我们可以为其注册回调，当在 gui 事件循环中看到该事件时将执行这些回调。由于事件总线事件原则上可以是任何事件，因此需要一种机制来存储该事件总线事件，同时应用程序等待 gui 事件循环通知事件总线处理来自主线程的事件总线事件。由于应用程序的异步特性，在处理发生之前，可能会在事件总线上接收到多个事件，因此需要一个可变大小的容器，而线程安全队列库正好符合这一需求。

## 经手人

在三个工作类(搜索窗口、结果窗口和数据库)中，事件处理程序方法在初始化时都连接到事件总线。看一下数据库类，搜索、获取和更新各有一个，在第 26–28 行显示为异步函数。搜索和获取的独特之处还在于它们沿着事件总线(线 38 和 44)发送自己的事件。上面提到的 emit 是线程安全的，所以即使它们将在独立于主线程的线程上被调用，产生的更新也将安全地出现在主线程上。其他两个类的完整代码类似，只是它们直接更新 gui，所以它们的处理程序是同步连接的，这里可以看到代码。

db.py

## 这些事件

这里显示的是一个事件的模板。使用类作为事件结构是有帮助的，因为它允许基于事件类型进行路由，但是任何对象，比如字典(hashmap)，只要使用一致，就可以携带公共标识符和有效负载，就可以作为事件工作。这里使用 namedtuple 只是因为它为实例化一个对象提供了样板。这里没有显示所有的事件类，它们与“SearchEvent”的创建方式相同。

events.py(缩写)

# 警告和注意事项

上面的事件总线尽可能简单地编码，只要下面的改进是不必要的，它就是可接受的。生产系统可能需要许多改进。这种细化包括在连接方法时对对象生命周期的关注、基于属性过滤事件、区分处理程序的优先级并尽早停止处理序列、报告异步事件状态以及报告事件总线上发生的错误。前三个是在 Python [encore.events 库](http://docs.enthought.com/encore/events/index.html)中实现的，读者可以在那里找到一个工作示例。

如果其方法连接到事件总线的对象预计会在某个时间点(比如当窗口关闭时)被删除，那么对象生命周期可能很重要。上面保留了防止对象被垃圾收集的方法的硬引用。为了允许预期的垃圾收集，应该保留对对象的弱引用，并且每次处理事件时，都将绑定必要的方法，然后将其丢弃。检查你的目标语言如何处理引用将有助于确保你的实现中正确的对象生命周期。

事件过滤有助于防止事件类的扩散，并允许处理程序只关注具有他们感兴趣的属性的特定事件。这样，发出函数只需要发出一个事件类，并且可以根据需要添加属性。如下所述，如果发送状态事件，这也是有帮助的，因为它允许处理程序只关注他们感兴趣的状态。当然，如果你愿意容忍许多类，过滤是不必要的。

区分处理程序的优先级是另一种过滤形式，其中为给定事件注册了多个处理程序，但这些处理程序是按优先级顺序调用的，每个处理程序决定它是否可以处理该事件。可以处理该事件的第一个处理程序将它标记为已处理，并且不再调用其他处理程序。这是责任链模式的一个例子。

当需要在仪表板上显示事件的状态时，例如当数据查询将要执行和正在执行时，报告异步事件非常有用。这些状态包括等待(万一线程池已满，不能立即处理请求)、执行、失败和完成。这种级别的报告通常需要在 future 中放置一个 runner，它运行事件处理程序并报告执行前后的状态。在 [traits_futures Python 库](https://docs.enthought.com/traits-futures/)中可以找到这种类型的运行器的一个例子。

同步和异步处理程序中的失败报告对用户和调试都有帮助。一种方法是在注册处理程序时注册一个失败事件，如果该处理程序失败，将会发出该事件。另一种方法是将原始事件嵌入到常见的失败事件中，并提取出嵌入事件的名称以允许过滤，这样处理程序就可以注册到过滤中，从而只接收感兴趣的原始事件的失败事件。

# 摘要

在本文中，我们介绍了一种方法，可以同时确保异步处理阻塞任务，同时确保组件通过事件总线通信保持松散耦合。这种组合有助于推理应用程序中的并发性，并通过不必在整个应用程序中重复重写并发模型来提高可维护性和可扩展性。只需将处理程序类型改为“is_async=True”就足够了。这里讨论了桌面应用程序，但是同样的思想也可以应用于服务器应用程序，尤其是在计算任务必须阻止使用异步/等待式并发的情况下。事件总线的另一个扩展是将任务分派给一个单独的服务器，比如运行 [Dask](https://dask.org/) 的服务器，并使用一个外部事件代理将计算结果发送回面向客户端的服务器和客户端。关于 [Redis](https://redis.io/) 的例子，参见【Python 中的[架构模式】。虽然这里介绍了两个独立的模式，一个并发模型和一个事件架构，但希望这将激发您自己的应用程序中的扩展，使您的应用程序响应迅速，易于维护和扩展。](https://www.cosmicpython.com/book/preface.html)