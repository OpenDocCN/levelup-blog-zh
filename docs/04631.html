<html>
<head>
<title>Finding the REAL shortest path in JavaScript: Depth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中寻找真正的最短路径:深度优先搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/finding-the-real-shortest-path-in-javascript-depth-first-search-93a3ce514250?source=collection_archive---------1-----------------------#2020-07-07">https://levelup.gitconnected.com/finding-the-real-shortest-path-in-javascript-depth-first-search-93a3ce514250?source=collection_archive---------1-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一次大公司的面试中通过了所有的问题后，我再次被迷宫解决者的问题所困扰。但这一次，我不得不找到通往出口的最短路径。</p><p id="4fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是董事会上提出的问题:</p><p id="f4f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“你需要写一个得到三个参数的函数:2D数组、起点和出口点。这个函数返回一些到出口的最短路径，如果它存在的话”。</p><p id="dff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">2D数组中的数字表示如下:0是有效路径，1是墙，2是出口</em>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/301bc4a7e4fa30a39a0b5c2c4e00e74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*oJXbd5vvpaFujdND4kspKg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">最短路径的演示，如这里看到的路径是10</figcaption></figure><p id="9180" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">如果你有兴趣知道如何在不考虑最短路径的情况下解决问题，我在那个</em> <a class="ae ky" href="https://talkwondo.github.io/the-maze-gunner/" rel="noopener ugc nofollow" target="_blank"> <em class="kl">这个</em> </a> <em class="kl">环节上做了一个巨型项目。</em></p><p id="d8b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">于是回家想出解决最短路径的最佳算法，遇到了<a class="kz la ep" href="https://medium.com/u/4a3c4c41313c?source=post_page-----93a3ce514250--------------------------------" rel="noopener" target="_blank">诺姆·绍尔-乌特利</a>的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/finding-the-shortest-path-in-javascript-pt-1-breadth-first-search-67ae4653dbec">文章</a>。Noam给出了一个树结构和函数的例子，该函数使用BFS返回从一个表示为10的节点到另一个表示为12的节点的最短路径。</p><p id="de2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不打算详细说明这两种不同的算法，你可以阅读诺姆的文章和维基百科——我更喜欢专注于解决方案。</p><p id="32ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">诺姆文章中的例子:</p><blockquote class="lb lc ld"><p id="b460" class="jn jo kl jp b jq jr js jt ju jv jw jx le jz ka kb lf kd ke kf lg kh ki kj kk ij bi translated">我将尝试运行我们的<strong class="jp ir"><em class="iq">breadsthfirssearch</em></strong>函数，使用我们之前创建的<strong class="jp ir"> <em class="iq">树</em> </strong>对象、10的一个<strong class="jp ir"> <em class="iq">根节点</em> </strong>(实际根节点)，以及“12”的一个<strong class="jp ir"> <em class="iq">搜索值</em> </strong>。</p></blockquote><pre class="kn ko kp kq gt lh li lj lk aw ll bi"><span id="6366" class="lm ln iq li b gy lo lp l lq lr">     10<br/>    /  \<br/>   4    17  <br/>  / \   / \<br/> 1   9 12  18</span><span id="dcb9" class="lm ln iq li b gy ls lp l lq lr">The path -&gt; 10,4,17,1,9,12!</span></pre><p id="3121" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你同意我说的最符合逻辑的最短路径是:10，17，12吗？</p><p id="0580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，如果你在网上搜索或问同事在迷宫或等价模式中寻找最短路径的最佳算法是什么，对于未加权的图，他们会向你推荐BFS。所以我在这里说<strong class="jp ir">不！</strong>DFS会给你最短路径的数据，或者可能每个人都定义最短路径(意思是最短时间)来查找节点是否存在？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/2015dc633d4528d58cd1bb300ceb2764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mmxz4-OhxcMDYR7d.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">寻找最短路径的导航</figcaption></figure><p id="5e63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将很快向您展示完整的解决方案和结论，所以请耐心等待并阅读逻辑方法。</p><p id="74fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为DFS挑选和使用的最佳数据结构是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树</a>。</p><p id="2e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当解决一个复杂的迷宫必须有至少两个方向移动，但最有可能是三到四个，因此我们不能建立一个二叉树。相反，我们需要构建一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Tree_(graph_theory)" rel="noopener ugc nofollow" target="_blank">图树</a>。</p><p id="fb1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是该解决方案的里程碑:</p><p id="c868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.创建一个节点和一个树类。</p><p id="5e5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.在树中创建一个递归函数，通过有效的移动来增加“状态”位置。</p><p id="e08a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.过滤超出阵列、墙和已访问位置的位置。</p><p id="a1ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.获取最多四个过滤位置的数组来指示交汇点。</p><p id="14e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.对于按移动排序的树，检查最后一个状态位置的增量，并执行switch语句。</p><p id="f7cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.分配位置并用当前位置和节点递归调用。</p><p id="173d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">7.用深度优先搜索遍历树，直到找到出口，从根节点开始将位置数组添加到数组。</p><p id="b471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8.按数组长度排序，返回第一个数组的长度，如果没有，返回false。</p><p id="32a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能看起来令人困惑，所以我将写下代码中的每一步，这样你就会完全理解。</p><p id="29dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> 1。</span>首先，如上所述，让我们用JavaScript创建节点和树类:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="b4dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> 2。在树类内部，我们将编写递归函数。我们将称之为(讽刺地)“成长”。在那之前，我们在迷宫里走了一系列的棋。</span></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">迷宫是2D阵列，轴表示为[y，x],正<em class="mj">坐标如下:y↓ x→ </em></figcaption></figure><p id="ba67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对上面代码的一个详细说明:走法是一个数组，在迷宫数组的4个方向上增加一步，迷宫的宽度和高度很简单，只要看看从当前位置开始的走法是如何递增/递减的。</p><p id="ede7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> 3。我们将使用JavaScript方法过滤器来清理墙壁、超出的数组点，最重要的是检查<strong class="jp ir">轨迹</strong>！</span></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ed70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是<strong class="jp ir">赛道</strong>？如果我们想避免循环移动，我们需要建立某种数据结构来保存路径。这也会给我们以后带来问题。顺便说一下，函数addTwo()只是在树中加2，只是为了在树形图中显示出口。</p><p id="98eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> 4。</span>现在，我们将为每个过滤后的移动制作一个节点，并将它们添加到轨迹中。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4af9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> 5。</span>为了组织迷宫中每一步移动的树，我们将检查移动的增量，并将它们分配给树。</p><p id="65b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> 6。</span>现在，我们将使用迭代的当前位置再次调用递归函数。当函数离开调用堆栈时，我们将返回到其他位置。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5864" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，对于数组中的每个节点，我们将其分配给树。在这一部分中，我们还需要更新节点类中的一些构造函数变量:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/527aa676cc1d66b35b78c2f220a30a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*jv6elY47A94OHRJ2opiZHA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更新的节点类</figcaption></figure><p id="0450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> 7。</span>我们将使用DFS(！)并将路径推送到数组。我们可以得到一对夫妇的路径，但最短的是我们感兴趣的，我们将照顾它。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a48e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的DFS是一个递归函数，返回路径数组的数组。</p><p id="155c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> 8。</span>我们将按照数组长度对路径进行排序，得到结果。如果没有出口，数组将为空，那么我们将返回false。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="91ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们测试代码之前，我想向你解释一下我们的递归函数。正如你可能知道的，递归函数的主要问题是创建一个语句来结束递归，这意味着我们需要创建一个条件来在函数溢出之前停止反复调用调用堆栈中的函数。然而，在我们的函数中没有条件，那么它什么时候结束呢？当循环遍历元素的[nodeArr]到达末尾时。</p><p id="dfc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个递归真的很混乱…那我们为什么要用它呢？只是因为我们需要记住我们在选择下一条路之前已经遇到的相同的路口，以便我们可以返回并尝试另一条可能更短的路(或通向出口)。如果我们选择使用迭代，我们需要建立一个交叉点的数据结构(可能是某种<strong class="jp ir">散列表</strong>),并在每次进入死胡同时返回。但是递归为我们做到了！当路径到达一个死胡同时，它返回到[nodeArr]循环，并转到连接中的相邻路径，最酷的部分是，在我们选择下一个递归函数之前，所有变量都“及时返回”到它们的值。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ml"><img src="../Images/8b90059099deee9a651c9fdedaee0037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qHLJOfyQbjfd2OcKVpncPQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这就是递归函数的工作方式</figcaption></figure><p id="e2d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们做一些测试。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/981b96049e2b1f29adf5490019dc4f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*c0TE-tux6dSN-ot_uKA61A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这不是最短的路！</figcaption></figure><p id="dee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看，那没用。那不是最短的路径…让我们试着找出我们在这里错过了什么…</p><p id="28d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能还记得，我们有跟踪阵列。它会保存之前访问过的所有位置。例如，如果我们选择一条路，并通过一个特定的位置，导致出口，一旦我们从不同的方式返回到相同的位置，我们不能再通过它，因为它已经包括在轨道中，以避免循环。</p><p id="7aa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要考虑如何清理赛道，但我们应该什么时候做呢？</p><p id="06d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们想象一下，我们在一个迷宫里…我们带着一个指南针来指示出口。我们做什么呢我们要怎么移动？</p><p id="b1a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是每次向出口走一步，我们会检查指南针的指针来决定下一步的方向。这意味着我们将选择两个坐标来生成一个矢量。我们将随机选择一个方向作为第一个方向。如果我们到达终点，我们会想也许另一条路会更短。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/67583393d3c38528bce236ecf5e95531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*bbBAkcUz5fp-KzDHKJ2DVw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由于我们只能垂直和水平移动，我们将创建一个到出口的向量，并向它走去</figcaption></figure><p id="74d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着用代码来实现。</p><p id="a51e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建一个switch语句来检查出口在哪里以及我们当前位置的增量，并相应地创建move数组。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="0dae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通向出口的最重要的路径应该在第一个和第二个移动数组处，它们构成了通向出口的Y和X向量。如果我们到达了末尾，并且[nodeArr]有多个元素，我们将清除该轨道，并转到第二个选项。让我用代码向您展示更新递归函数调用:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4d70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试试另一个测试:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/6a7cc5960e01cade67e45556f63c1a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*7wyV9iXOvPY81Qx9YUFyXQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">它应该先选下一步再选左一步</figcaption></figure><p id="d5d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，我们还有一个问题！但这次我不会详细说明，问题只是移动数组中的第三和第四个元素。在这个特定的迷宫中，如果向下的位置在第三个元素中，我们将获得最短的路径，因此我们可以在第三和第四个元素之间切换，但在这个阶段，我们需要考虑全局解决方案，而不是私人解决方案。起初，我不认为第三和第四有任何不同，我只是武断地把它们放在那里，但现在我看到了逻辑决定。</p><p id="a297" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们可以在第三和第四个索引中清除轨道，但这将使堆栈溢出！这将是一棵巨大的树。如果我们想避免由于递归而导致的最大调用阻塞，并尝试建立一个迭代方法，这将导致我们花费大量时间来得到答案，所以我们需要有创造性。</p><p id="96af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我找到了最佳解决方案，实际上移动数组中的第四个位置应该与退出方向完全相反，如果每条路径都失败了，我们仍然会选择它，但是这将解决我们的问题。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mo"><img src="../Images/66beb49feff4f98db661230f7888f249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLj1XFymUsaQUMHjHrEckQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这就是如何在delta条件下确定moves数组的元素</figcaption></figure><p id="f76c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">移动数组从开始就保持不变:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/921200e0fbeda0479a8e0c686af3b1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*u1n4u6k89gxlyd34sbolJw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">按以下顺序移动数组:[上、左、右、下]</figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ef2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，最后的考验！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/f48731077f7ba4044fc9b17cdb281092.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*8HTArOfUNjU5hndykSAAeQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">你也可以在我的网站上玩这个游戏<a class="ae ky" href="https://talkwondo.github.io/the-maze-gunner/" rel="noopener ugc nofollow" target="_blank">https://talkwondo.github.io/the-maze-gunner/</a></figcaption></figure><p id="f779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！那是一个非常具有挑战性的项目。我对我的方法非常肯定，但是如果你看到我的算法不起作用的私人案例，请给我写一个评论，以便我可以继续努力。</p><p id="941c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自以色列的和平！</p></div></div>    
</body>
</html>