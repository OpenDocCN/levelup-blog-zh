<html>
<head>
<title>Remove Your If-Else and Switch Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移除你的If-Else并交换大小写</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/remove-your-if-else-and-switch-cases-1ed2b625b4cf?source=collection_archive---------0-----------------------#2021-05-06">https://levelup.gitconnected.com/remove-your-if-else-and-switch-cases-1ed2b625b4cf?source=collection_archive---------0-----------------------#2021-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="55cd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">实用编程建议</h2><div class=""/><div class=""><h2 id="db44" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何让代码量翻倍变得更好？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/87519c5f72ef671007fa6ad3d3570c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhislqWw6bBcU959K8rbow.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">尼克拉斯·米勒德拍摄的图片</figcaption></figure><p id="4a3b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我知道你在想什么“代码量翻倍？！这个疯子是谁？”和“你是一个时钟应用程序占用20MB的原因。”</p><p id="e55a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是，让我们弄清楚一件事。</p><blockquote class="mf"><p id="cee0" class="mg mh it bd mi mj mk ml mm mn mo me dk translated">代码行数从来都不是衡量代码质量的好指标。永远不会。</p></blockquote><p id="737c" class="pw-post-body-paragraph lj lk it ll b lm mp kd lo lp mq kg lr ls mr lu lv lw ms ly lz ma mt mc md me im bi translated">许多开发人员想提高技能，放弃他们的老方法。扩展您的方法和技术来消除分支是一个快速的方法。<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/writing-cleaner-code-with-examples-69be2160b4c1">通常，你的代码在这个过程中也会变得更加清晰</a>。</p><p id="aafb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">像上面例子这样疯狂的代码需要被删除。不可读。它不可维护，也不灵活。只是可怕的代码。可悲的是，这还没那么糟糕。</p><p id="bbaa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">If-Else和Switch可能是您进行代码分支的实际模式。但其实不必如此。您可以很容易地将“else”关键字从您的编程词汇表中完全删除。</p><p id="5079" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/if-else-is-a-poor-mans-polymorphism-ab0b333b7265"> If-else常用作穷人的多形性。</a></p><h2 id="5121" class="mv mw it bd mx my mz dn na nb nc dp nd ls ne nf ng lw nh ni nj ma nk nl nm iz bi translated">“传统分支有什么错？”</h2><p id="c4f3" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">很多事情。</p><p id="5c7a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，传统的分支很快变得令人讨厌。每次需要添加新特性时，都必须修改现有的代码。它违反了开闭原则。特性必须用新的类来实现。</p><p id="5f71" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">理想情况下，您只需要在重构或执行错误修复时修改现有的类。或者如果一个类有合理的理由进行更改，比如更新的业务规则或者我们对自己的领域有了更深入的理解。</p><p id="a15f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">此外，传统的分支经常通过屋顶发射<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/why-cognitive-and-cyclomatic-complexity-matters-in-software-development-5fce1efb56ab">圈和认知复杂性。</a></p><h2 id="30aa" class="mv mw it bd mx my mz dn na nb nc dp nd ls ne nf ng lw nh ni nj ma nk nl nm iz bi translated">“我们有什么选择？”</h2><p id="5499" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">备选方案太多了，无法在一篇文章中一一介绍。</p><p id="391b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是我将分享我从代码中移除传统分支时经常使用的3种典型方法。</p><ol class=""><li id="5eba" class="ns nt it ll b lm ln lp lq ls nu lw nv ma nw me nx ny nz oa bi translated">用类对概念建模</li><li id="1842" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">在处理变化的对象状态时使用多态执行</li><li id="c9d4" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me nx ny nz oa bi translated">将策略封装在单独的类中</li></ol><p id="6177" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">上面列出的3种方法可以轻松处理你将遇到的大多数日常情况。</p><p id="214a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">第三点——在策略类中封装分支——是我的最爱。它在最后一节中被涉及。</p><p id="c47f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">另一个很好的选择是使用命令对象。这超出了本文的范围，<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/replacing-if-else-with-commands-and-handlers-527e0abe2147">但是如果您想了解更多，这里有一篇关于这方面的文章。</a></p><p id="fba4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这三种技术都有一些共同点，比如1)新的功能是用新的类实现的。添加代码通常比修改代码更安全。任何时候修改已经运行的代码，都有把事情搞砸的巨大风险。</p><p id="c495" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">2)测试简单的专门化类更容易——这是一个巨大的好处。简单的类和方法更容易推理。一般来说，理解许多小的、内聚的类比理解单一的、神圣的类更容易。</p><p id="85d8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">3)在细粒度级别捕获概念比扩展单个类的职责要好。</p><h1 id="32d5" class="og mw it bd mx oh oi oj na ok ol om nd ki on kj ng kl oo km nj ko op kp nm oq bi translated">用简单的类建模概念。</h1><p id="1cc8" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">任何熟悉领域驱动设计的人都知道<a class="ae mu" href="https://betterprogramming.pub/stop-using-primitive-types-in-domain-classes-c45f5973d640" rel="noopener ugc nofollow" target="_blank">通过在小型专业课堂上获取商业知识和规则来避免原始困扰的重要性</a>。</p><p id="9018" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">假设我们有一个需要用户名的<code class="fe or os ot ou b">User</code>类。用户名是一个字符串，只有两个规则:1)不能为null或空字符串，2)不能超过50个字符。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/9fe5aabd1ad030fdbd3b355f7e342d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrrUHXB4QsMRnFlA-emTyg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">简单用户类。</figcaption></figure><p id="6af0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我知道这是一个人为的例子，但请听我说。重要的是我展示的概念，而不是我在塑造什么样的模型。</p><p id="d3bb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我认为假设我们在应用程序的其他部分需要用户名是安全的。每当我们收到用户名时，我们都必须执行相同的验证检查。我们将有效地将商业规则分散到各处。</p><p id="9a5f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们的规则发生了变化，突然需要防范像“o”这样的特殊字符，我们将需要找到收到用户名的每个地方，并添加新的验证。</p><p id="47d9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一个好得多的方法是捕获用户名概念并创建一个小的专用对象，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/63b530cad844bdde91393f228b2a9b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8W4CGQDEx2eyVJG-LJyS-w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">封装的用户名。</figcaption></figure><p id="778f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">不可否认，上面的代码片段更简洁。现在，任何时候我们需要更新用户名业务规则，我们都可以在一个地方完成。</p><h1 id="f6a9" class="og mw it bd mx oh oi oj na ok ol om nd ki on kj ng kl oo km nj ko op kp nm oq bi translated">根据对象的状态更改其方法的实现。</h1><p id="4945" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">有时，您需要一个对象根据其内部状态表现出不同的行为。实现这一点的一个典型的、懒惰的方法是使用传统的分支。</p><p id="c610" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">就像下面这个例子，花几秒钟浏览一下。我会在片段之后详细说明。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/a8459145755cf676de9088c780c6bd03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IfykeNUg-Qv5nSNe_rO6dA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">可怕的分支代码。</figcaption></figure><p id="258e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，有3种状态，每当我们需要取钱时，帐户需要检查其内部状态并相应地运行。</p><p id="a312" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">传统分支的一个缺陷是嵌套条件逻辑。代码中任何类似圣诞树的形状都是代码味。遵循逻辑和推理并不容易，<code class="fe or os ot ou b">if</code>和<code class="fe or os ot ou b">else</code>分支开始彼此远离，使得阅读和维护更加困难。</p><p id="39d3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">状态模式是去除疯狂嵌套的条件逻辑的一种非常棒的方法。</p><p id="0c53" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们希望我们的代码更像下面这样。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/51308791633f978d9732f07354ff6e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CS9LrFxtv8JSD8iXoO0MA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用状态模式的帐户。</figcaption></figure><p id="8c11" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">你看到这个结构有多平了吗？</p><p id="535b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每个分支现在都封装在自己的类中。account类只是将责任委托给专门的<code class="fe or os ot ou b">AccountState</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/c9f55f113db943ac436fa63340c991cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kw61KqyeFTzTUK3TU1P1Gg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">专用帐户状态类。</figcaption></figure><p id="0d37" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">双倍代码。两倍的可读性。</p><p id="d237" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">你看，每个状态对象都继承了一个基类。</p><p id="3e12" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们得到一个新的特性请求来添加一个“RequiresValidation”状态，或者其他什么，在不涉及现有类的情况下实现这个特性是很容易的。</p><p id="6e60" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在你说“但是没有状态转换！”，我知道。这些类显然没有完全实现。从一种状态转换到另一种状态超出了本文的范围。</p><h1 id="8920" class="og mw it bd mx oh oi oj na ok ol om nd ki on kj ng kl oo km nj ko op kp nm oq bi translated">将分支重构为单独的策略类。</h1><p id="5af9" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">我最喜欢的，也可能是最常用的消除条件分支的方法:策略对象。</p><blockquote class="pb pc pd"><p id="e6dd" class="lj lk ow ll b lm ln kd lo lp lq kg lr pe lt lu lv pf lx ly lz pg mb mc md me im bi translated"><a class="ae mu" href="https://youtu.be/ufeZazqrHjM?t=180" rel="noopener ugc nofollow" target="_blank">请点击这里继续关注YouTube，本部分开始于03:00 </a></p></blockquote><p id="b0e3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">你会经常看到用程序化的方式实现的策略模式，也就是用<code class="fe or os ot ou b">if-elseif</code>和switch cases。</p><p id="8298" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">假设我们想要将任何类型转换为CSV格式，并且我们想要指定该类型的每个属性是如何转换的，但是，该类型不应该自己定义它。</p><p id="64db" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们想出了一些类似下面的代码。<code class="fe or os ot ou b">[CsvInfo]</code>是一个属性，本质上是关于类型的元信息。然后使用<code class="fe or os ot ou b">ToCsv()</code>方法中的一点反射来读取这个元信息。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/295507ee6123b151b591851c3f7348cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6S5RlctZc_P0rROdG0jxow.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">属性附带元信息的用户类。</figcaption></figure><p id="4f2d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下面是CsvInfoAttribute类的一个片段。这个设计不完全是垃圾。但是，它不太具有可扩展性、灵活性或可维护性。</p><p id="95f5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每次你需要添加一个新的转换选项时，你都必须添加一个额外的枚举，然后在<code class="fe or os ot ou b">Format()</code>方法中实现这个枚举的转换。也就是说，您需要修改现有的代码。</p><p id="1044" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">其次，假设这个类存在于某个共享库中，组织中的许多项目都依赖这个库。如果一个团队需要一个新的转换选项，他们将不得不联系包含该代码的项目的维护人员——维护人员然后添加功能，构建新版本，并发布它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/caa968ef92ed41a7ca54ae4bd347eacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzZiwLu7rTC_JDAmodptxw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">csv转换的元信息。</figcaption></figure><p id="6349" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">更合适的方法是允许每个团队在他们自己的项目中扩展格式选项。</p><p id="7773" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以通过将每个switch case分支分离到专门的类中来做到这一点，从而不必使用enum。</p><p id="212d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每个策略都需要实现一个公共接口，并且，<code class="fe or os ot ou b">CsvInfoAttribute</code>不再有自己的<code class="fe or os ot ou b">Format()</code>方法。相反，它将把格式化的责任委托给专门化的对象。</p><p id="2f15" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">花点时间浏览下面的代码。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/375ee035bede6c52d732052538ee9de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfE4oCtJVOzvFwMU5eTy1w.png"/></div></div></figure><p id="da66" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，任何时候你想要一个新的格式化程序类型，只需要创建一个新的类。不再修改多个现有的类。</p><p id="99fe" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了实现这一点，您需要定义一些约束。我设置了两个约束。任何格式化程序必须1)实现<code class="fe or os ot ou b">IValueFormatter</code>，2)必须有一个默认的构造函数。</p><p id="9258" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">想象一下现在测试和修复错误是多么容易。你总是确切地知道要测试什么和在哪里寻找。不再遵循疯狂的开关逻辑。</p><h1 id="6dcf" class="og mw it bd mx oh oi oj na ok ol om nd ki on kj ng kl oo km nj ko op kp nm oq bi translated">你的主要收获。</h1><p id="94fb" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">使用传统分支被广泛(错误)使用。许多开发人员坚持他们的分支代码的可靠方法，只是意识到维护和添加特性已经变成了一场噩梦。</p><p id="5338" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用if-else和switch cases就是放弃伟大的面向对象实践。</p><p id="7af6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果你真的想成为一名开发人员，那么开始寻找消除传统分支的方法。</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><h1 id="3334" class="og mw it bd mx oh pr oj na ok ps om nd ki pt kj ng kl pu km nj ko pv kp nm oq bi translated">让我们保持联系！</h1><p id="c086" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated"><a class="ae mu" href="https://nmillard.medium.com/subscribe" rel="noopener">通过在这里</a>注册时事通讯获得类似文章的通知，并查看新的YouTube频道<a class="ae mu" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank"><em class="ow">(@ Nicklas Millard)</em></a></p><p id="d0a4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><em class="ow">连接上</em><a class="ae mu" href="https://www.linkedin.com/in/nicklasmillard/" rel="noopener ugc nofollow" target="_blank"><em class="ow">LinkedIn</em></a></p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><h1 id="b165" class="og mw it bd mx oh pr oj na ok ps om nd ki pt kj ng kl pu km nj ko pv kp nm oq bi translated">好奇者的资源</h1><ul class=""><li id="199c" class="ns nt it ll b lm nn lp no ls pw lw px ma py me pz ny nz oa bi translated"><a class="ae mu" href="https://github.com/NMillard/AvoidTraditionalBranching" rel="noopener ugc nofollow" target="_blank">尼可拉斯·米勒德</a>的GitHub回购</li><li id="b9e0" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me pz ny nz oa bi translated"><a class="ae mu" href="https://youtu.be/DGHH4m5squo" rel="noopener ugc nofollow" target="_blank">没有原始类型的干净类——如何避免原始困扰</a></li><li id="b4dc" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me pz ny nz oa bi translated"><a class="ae mu" href="https://youtu.be/ufeZazqrHjM" rel="noopener ugc nofollow" target="_blank">“If-else and Switch”——无代码</a></li><li id="abac" class="ns nt it ll b lm ob lp oc ls od lw oe ma of me pz ny nz oa bi translated"><a class="ae mu" href="https://medium.com/swlh/stop-using-if-else-statements-f4d2323e6e4" rel="noopener">停止使用If-Else语句</a></li></ul></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><h1 id="e738" class="og mw it bd mx oh pr oj na ok ps om nd ki pt kj ng kl pu km nj ko pv kp nm oq bi translated">分级编码</h1><p id="7a47" class="pw-post-body-paragraph lj lk it ll b lm nn kd lo lp no kg lr ls np lu lv lw nq ly lz ma nr mc md me im bi translated">感谢您成为我们社区的一员！<a class="ae mu" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅我们的YouTube频道</a>或者加入<a class="ae mu" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> Skilled.dev编码面试课程</strong> </a>。</p></div></div>    
</body>
</html>