<html>
<head>
<title>A Sort of All Sorting Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种排序算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-sort-of-all-sorting-algorithms-506cbc76d47?source=collection_archive---------0-----------------------#2019-03-25">https://levelup.gitconnected.com/a-sort-of-all-sorting-algorithms-506cbc76d47?source=collection_archive---------0-----------------------#2019-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8da2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Python实现的所有常见排序算法概述</h2></div><p id="addf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我之前关于<a class="ae lb" href="https://medium.com/@scbronder12/algorithm-complexity-and-the-big-o-cb703e093faa" rel="noopener">算法复杂性和大O </a>的博客中，有一个常见的例子可以帮助解释这个概念，那就是编程中存在的不同种类的排序算法。</p><p id="80b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，可能很难从概念上理解如何以不同的方式处理排序问题。然而，自从计算开始以来，随着不同语言的发展或创造，排序算法已经获得了很多关注。随着它质疑解决一个简单而熟悉的问题的复杂性和效率，这种趋势可能会继续下去。因此，我将尝试描述一些比较流行的排序方法，并强调它们的优点和缺点。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">https://www.toptal.com/developers/sorting-algorithms<a class="ae lb" href="https://www.toptal.com/developers/sorting-algorithms" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="72b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这些例子中每一个，我都会尽可能多地加入视觉效果。每个人学习的方式都不一样，有几种不同的方式让我头脑中的灯泡熄灭，最终理解一个概念，希望这些也能让你受益。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="1de6" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">插入排序</h1><ul class=""><li id="1f4e" class="mm mn iq kh b ki mo kl mp ko mq ks mr kw ms la mt mu mv mw bi translated">大O:最好= O(N)，最差= O(N)</li></ul><p id="4db4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">插入的工作方式是从列表中一个接一个地取出元素，并把它们插入到新的排序列表中正确的位置。在数组中，新的列表和剩余的元素可以共享数组的空间，但是插入的开销很大，需要将后面的所有元素移动一位。</p><p id="9282" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个快速的分步示例。我们将已排序的部分涂成红色，未排序的部分涂成黑色。我们从未排序的部分中取出一个元素，并将其与排序的部分中的元素进行比较，从右向左移动。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/062ccf779e31a64fc62a7aab85f6cddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/1*d2cSMtdU6LwcwSqzH-lm5g.png"/></div></figure><p id="f45a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们计算插入排序的最大复杂度，最昂贵的部分是两个元素的比较。我们将计算N个元素的数组的比较次数:</p><blockquote class="na nb nc"><p id="d4e1" class="kf kg nd kh b ki kj jr kk kl km ju kn ne kp kq kr nf kt ku kv ng kx ky kz la ij bi translated"><em class="iq">我们需要0个比较来插入第一个元素<br/>我们需要1个比较来插入第二个元素<br/>我们需要2个比较来插入第三个元素<br/>……<br/>我们需要(最多)N-1个比较来插入最后一个元素</em></p></blockquote><p id="f201" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总计…</p><blockquote class="na nb nc"><p id="b590" class="kf kg nd kh b ki kj jr kk kl km ju kn ne kp kq kr nf kt ku kv ng kx ky kz la ij bi translated"><em class="iq"> 1 + 2 + 3 + … + (N-1) = O(n2) </em></p></blockquote><p id="f1af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，从左边1个元素和右边N-1个未排序项目的排序列表开始，取第一个未排序项目(元素#2)并将其插入到排序列表中，必要时移动元素。我们现在有一个大小为2的排序列表和N -2个未排序的元素。对所有元素重复此过程。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4b1eb07983f7a2c153ea161aea97be40.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*iD6nnem3DO7yeuND3moAsw.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae lb" href="https://www.geeksforgeeks.org/insertion-sort/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/insertion-sort/</a></figcaption></figure><blockquote class="ni"><p id="caef" class="nj nk iq bd nl nm nn no np nq nr la dk translated">python中的一个例子</p></blockquote><figure class="ns nt nu nv nw lg gh gi paragraph-image"><div class="ab gu cl nx"><img src="../Images/685ab45984366e23b06d667a7961c1ba.png" data-original-src="https://miro.medium.com/v2/1*onU9OmVftR5WeoLWh14iZw.gif"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ny li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">一个令人难以置信和有趣的例子</figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="f49d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">选择排序</h1><ul class=""><li id="31e3" class="mm mn iq kh b ki mo kl mp ko mq ks mr kw ms la mt mu mv mw bi translated">大O:最好/最差= O(N)</li></ul><p id="6c41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择排序是比较容易直观理解的算法之一。它的工作方式如下:你在整个数组中寻找最小的元素，一旦你找到它，你就把它(最小的元素)和数组的第一个元素交换。然后在剩下的数组(没有第一个元素的数组)中寻找最小的元素，并与第二个元素交换。然后在剩下的数组(没有第一个和第二个元素的数组)中寻找最小的元素，并与第三个元素交换，依此类推。下面是一个例子，红色数字被标识为最小的数字，粗体数字是与之比较的元素。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a949f39c49478fc90e9b7d03720ed746.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*m0c2hNMQiKPTeGTBV3QTXA.png"/></div></figure><p id="269f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择排序在大型列表上是低效的，并且通常比相似的插入排序执行得更差。在某些情况下，它比更复杂的算法具有性能优势。它只进行了<em class="nd"> n </em>次交换，因此在交换非常昂贵的情况下非常有用。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/00bbf9389ad013cdea570ad8484e8cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*6QMQQ3JcF6L9Tk6gP083lA.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae lb" href="https://www.geeksforgeeks.org/python-program-for-selection-sort/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/python-program-for-selection-sort/</a></figcaption></figure><blockquote class="ni"><p id="a221" class="nj nk iq bd nl nm nn no np nq nr la dk translated">python中的一个例子</p></blockquote><figure class="ns nt nu nv nw lg gh gi paragraph-image"><div class="ab gu cl nx"><img src="../Images/6360f5e39717e5512c8a141c25698905.png" data-original-src="https://miro.medium.com/v2/1*OA7a3OGWmGMRJQmwkGIwAw.gif"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">又一个通过舞蹈的例子！</figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="cd67" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">合并排序</h1><ul class=""><li id="cb8d" class="mm mn iq kh b ki mo kl mp ko mq ks mr kw ms la mt mu mv mw bi translated">大O: O(N log N)</li></ul><p id="2914" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">合并排序是一个分而治之算法的完美例子。它简单地使用了这种算法的两个主要步骤:</p><ol class=""><li id="d390" class="mm mn iq kh b ki kj kl km ko oc ks od kw oe la of mu mv mw bi translated"><em class="nd">划分</em>未排序的列表，直到你有N个子列表。每个子列表有1个未排序的元素，N是原始数组中元素的数量</li><li id="d7ca" class="mm mn iq kh b ki og kl oh ko oi ks oj kw ok la of mu mv mw bi translated"><em class="nd">征服</em>(合并)一次两个子列表，产生一个新的排序子列表，直到它包含一个排序数组中的所有元素</li></ol><p id="d441" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法可以很好地扩展到非常大的列表，因为它的最坏情况运行时间是O( <em class="nd"> n </em> log <em class="nd"> n </em>)。它也很容易应用于列表，而不仅仅是数组，因为它只需要顺序访问，而不是随机访问。然而，它具有额外的O( <em class="nd"> n </em>)空间复杂度，并且在简单实现中涉及大量副本。</p><p id="fab4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们如何合并两个排序的子数组呢？我们在每个数组的前面定义了三个引用。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/528ac8412e2e7420d31884eb894b3438.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*LpN-Zsxo55b13U2Vw3fU1A.png"/></div></figure><p id="4a7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不断挑选最小的元素，并将其移动到一个临时数组中，增加相应的索引。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi om"><img src="../Images/295a1acea5dd166027ca8b0a7b3ef7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*ko1o8hIVQH6AKuPv-dm-6w.png"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi on"><img src="../Images/e00aedd5bc43036e34b9a901bf69aaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*zw5UX28iEyx5g84Zxv13WA.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae lb" href="https://www.geeksforgeeks.org/merge-sort/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/merge-sort/</a></figcaption></figure><blockquote class="ni"><p id="fb6d" class="nj nk iq bd nl nm nn no np nq nr la dk translated">python中的一个例子</p></blockquote><figure class="ns nt nu nv nw lg gh gi paragraph-image"><div class="ab gu cl nx"><img src="../Images/65b204d530440916d0233219e1540721.png" data-original-src="https://miro.medium.com/v2/1*fE7yGW2WPaltJWo6OnZ8LQ.gif"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">别担心，我没有忘记我们跳舞的例子</figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="d257" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">堆排序</h1><ul class=""><li id="dcf6" class="mm mn iq kh b ki mo kl mp ko mq ks mr kw ms la mt mu mv mw bi translated">大O: O(N log N)</li></ul><p id="88ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这类似于选择排序，但有一个更好的方法来获得最大的元素。它不是扫描所有的条目来寻找最大值，而是从一个堆中取出最大值。堆具有允许堆排序就地工作的属性，而无需额外的内存</p><p id="0c12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">堆排序的工作原理是确定列表中最大(或最小)的元素，并相应地将其放在列表的末尾(或开头)。重复这个过程，直到完成原始列表。一旦新列表被放入堆中，根节点肯定是最大(或最小)的元素。当它被移除并放在列表的末尾时，堆被重新排列，因此剩余的最大元素移到了根。使用堆，查找下一个最大的元素需要O(log N)时间，而不是像简单选择排序那样线性扫描需要O(N)时间。这允许堆排序在O(N log N)时间内运行，这也是最坏情况的复杂度。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f02b091345ce09ddf51bb224891bbf02.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*X6g87hd3nzrlN54ESqdcpg.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae lb" href="https://www.geeksforgeeks.org/heap-sort/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/heap-sort/</a></figcaption></figure><blockquote class="ni"><p id="a0c4" class="nj nk iq bd nl nm nn no np nq nr la dk translated">python中的一个例子</p></blockquote><figure class="ns nt nu nv nw lg"><div class="bz fp l di"><div class="op li l"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">我并不特别喜欢这支舞的音乐，尽管这支舞使用了max-heap的概念，但仍然很好地诠释了舞台上的舞蹈理念</figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="9ab8" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">快速排序</h1><ul class=""><li id="c7f1" class="mm mn iq kh b ki mo kl mp ko mq ks mr kw ms la mt mu mv mw bi translated">大O:最好= O(N log N)，最差O(N)</li></ul><p id="f6c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快速排序和合并排序一样，也是一种分治算法。尽管有点复杂，但它通常比合并排序快得多，并且很少达到最坏情况下的O(n)复杂度。它有3个基本步骤:</p><ol class=""><li id="703b" class="mm mn iq kh b ki kj kl km ko oc ks od kw oe la of mu mv mw bi translated">从数组中选择一个被指定为<em class="nd">枢轴</em>的元素</li><li id="de09" class="mm mn iq kh b ki og kl oh ko oi ks oj kw ok la of mu mv mw bi translated">将较小的元素移动到枢轴的左侧，将较大的元素移动到枢轴的右侧</li><li id="774e" class="mm mn iq kh b ki og kl oh ko oi ks oj kw ok la of mu mv mw bi translated">使用递归将步骤1和2应用于后续子数组</li></ol><p id="7962" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于快速排序的重要警告是，当选择第一个或最后一个元素作为支点时，它的最坏情况性能是O(N)。因此，快速排序中最重要的问题是选择一个好的枢纽元素。这个问题已经或多或少地通过使用<a class="ae lb" href="https://stackoverflow.com/questions/7559608/median-of-three-values-strategy" rel="noopener ugc nofollow" target="_blank">三中值</a>策略得到了解决，该策略将性能导向O(N log N)复杂度。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0de5b42e89f3a787b5a3845504c0441b.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*xswZsbuUPnxyN8QIUsD2Ww.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae lb" href="https://www.geeksforgeeks.org/quick-sort/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/quick-sort/</a></figcaption></figure><blockquote class="ni"><p id="233d" class="nj nk iq bd nl nm nn no np nq nr la dk translated">python中的一个例子</p></blockquote><figure class="ns nt nu nv nw lg gh gi paragraph-image"><div class="ab gu cl nx"><img src="../Images/c52a9667a39ebf6f4a9d43ed5ba8beb0.png" data-original-src="https://miro.medium.com/v2/1*hk2TL8m8Kn1TVvewAbAclQ.gif"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">一个真正的踢踏舞者！</figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="d244" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">冒泡排序</h1><ul class=""><li id="8317" class="mm mn iq kh b ki mo kl mp ko mq ks mr kw ms la mt mu mv mw bi translated">大O:最好= O(N)，最差= O(N)</li></ul><p id="79b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">冒泡排序清楚而简单地演示了排序的概念，因此经常被用作教学工具。然而，由于它的大，在学术界之外并不经常使用。</p><p id="d59b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法的工作原理是将列表中的每个项目与其旁边的项目进行比较，并在需要时交换它们。换句话说，最大的元素冒泡到数组的顶部。该算法重复这一过程，直到它遍历列表，而不交换任何项目。因为冒泡排序重复通过列表中未排序的部分，所以它的最坏情况复杂度为O(N)。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi or"><img src="../Images/47e5aad4e56a01f8f081a108037fad05.png" data-original-src="https://miro.medium.com/v2/resize:fit:210/format:webp/1*JNJsjYTe30oPg8bPkY9puA.png"/></div></figure><p id="1b75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，最大的元件(7)被鼓泡到顶部。然后重复该过程，直到不能再进行进一步的改变。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi os"><img src="../Images/1afdc93e5aad6f061a85ec585bd7aa1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*zE-ouZ9LHWwDhU2Jo-CQMw.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated"><a class="ae lb" href="https://www.geeksforgeeks.org/python-program-for-bubble-sort/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/python-program-for-bubble-sort/</a></figcaption></figure><blockquote class="ni"><p id="bf4a" class="nj nk iq bd nl nm nn no np nq nr la dk translated">python中的一个例子</p></blockquote><figure class="ns nt nu nv nw lg gh gi paragraph-image"><div class="ab gu cl nx"><img src="../Images/d50238effaf2189a866549175822e076.png" data-original-src="https://miro.medium.com/v2/1*LllBj5cbV91URiuzAB-xzw.gif"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">最后但同样重要的是！</figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="c849" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，我希望上面的解释和图片(和视频)能帮助你理解不同种类排序算法的区别和用途。我相信理解这些差异对于成长为一名数据科学家并能够尽最大能力编码是非常重要的！我会给你留下一些关于以上内容的图片总结，以及一些令人着迷的图片供你思考！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="ab gu cl nx"><img src="../Images/7103c0f90b34c6e8d2618e82a3c75845.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ipkeWQ_Lb0lbkhB8rigxTA.png"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ot li l"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ot li l"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ot li l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="962e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">来源</h1><div class="ou ov gp gr ow ox"><a href="https://medium.com/human-in-a-machine-world/quicksort-the-best-sorting-algorithm-6ab461b5a9d0" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">快速排序——最好的排序算法？</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">在最好的情况下，快速排序的时间复杂度为O(n log n ),在一般情况下为O(n log n ),在最差情况下为O(n^2</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://en.wikipedia.org/wiki/Sorting_algorithm" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">排序算法-维基百科</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">在计算机科学中，排序算法是将列表中的元素按一定顺序排列的算法。最…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">en.wikipedia.org</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl my ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://medium.com/@george.seif94/a-tour-of-the-top-5-sorting-algorithms-with-python-code-43ea9aa02889" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">使用Python代码浏览5大排序算法</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">排序是每个软件工程师和开发人员都需要了解的技能。不仅要通过编码…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl my ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">整理</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">排序是对一系列对象进行排序。我们可以区分两种类型的排序。如果对象的数量很少…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">www.cs.cmu.edu</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl my ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://betterexplained.com/articles/sorting-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">排序算法</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">(仍在进行中；我想用直观的解释和扑克牌的例子来重温)排序是…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">betterexplained.com</p></div></div><div class="pg l"><div class="po l pi pj pk pg pl my ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://cs.stackexchange.com/questions/86628/why-do-we-need-so-many-sorting-algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">为什么我们需要这么多排序算法？</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">我们有一些最好的排序方法，如快速排序，合并排序等。，那么为什么我们需要其他排序方法…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">cs.stackexchange.com</p></div></div><div class="pg l"><div class="pp l pi pj pk pg pl my ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://www.quora.com/Why-do-we-need-so-many-sorting-algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">为什么我们需要这么多排序算法？</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">回答(15个中的第1个):1)我们所知道的排序算法并不是都是同时开发出来的。有时我们学习…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">www.quora.com</p></div></div><div class="pg l"><div class="pq l pi pj pk pg pl my ox"/></div></div></a></div><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e5752d888be167135cc8786a12fe2c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*BMA6aw8Pu4ZZJ8KE.jpg"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">https://www.computerhope.com/jargon/s/sort.htm<a class="ae lb" href="https://www.computerhope.com/jargon/s/sort.htm" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><div class="lc ld le lf gt ox"><a href="https://gitconnected.com/learn/python" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">学习Python -最佳Python教程(2019) | gitconnected</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">50大Python教程-免费学习Python。课程由开发人员提交并投票，使您能够…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">gitconnected.com</p></div></div><div class="pg l"><div class="ps l pi pj pk pg pl my ox"/></div></div></a></div></div></div>    
</body>
</html>