<html>
<head>
<title>Scala journals — data manipulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala期刊—数据操作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-part-3-data-manipulation-289be03a8b0?source=collection_archive---------3-----------------------#2019-07-19">https://levelup.gitconnected.com/scala-journals-part-3-data-manipulation-289be03a8b0?source=collection_archive---------3-----------------------#2019-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/51a8c4646f9d28aecd96e3e6bca39111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3d-iyhDB9Ig8tuku5VGb-Q.jpeg"/></div></div></figure><p id="e440" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据操作和转换是一件大事。既然我已经分享了递归的重要性，但也提到了实现某些目标的其他方法，那么让我们深入研究一下。这将是关于数据操作和转换的迷你系列的第一篇文章。我现在将主要关注<strong class="kd iu">集合</strong>——这个主题还有其他重要的方面，但是让我们首先从最直观的东西开始。</p><p id="b719" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住这一点，让我们快速回忆一下Scala基本集合:</p><ul class=""><li id="47de" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">目录</li><li id="c705" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">地图</li><li id="511a" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">一组</li><li id="e276" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">元组</li><li id="7662" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">选项(要么是空的，要么只有一件物品，从阿尔文·亚历山大<a class="ae ln" href="https://alvinalexander.com/scala/using-scala-option-some-none-idiom-function-java-null" rel="noopener ugc nofollow" target="_blank">到这里</a>)</li></ul><p id="ab90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我发现我通常想对集合做一些基本的事情(除了获取大小等琐碎的事情之外)。):</p><ul class=""><li id="7ef4" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">获取符合特定条件的项目</li><li id="d546" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">对每一项都做些什么</li><li id="9923" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">对满足特定条件的项目做某事</li><li id="344a" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">检查是否有满足特定条件的项目</li></ul><p id="a648" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住这一点，让我们从<code class="fe lo lp lq lr b">map</code>、<code class="fe lo lp lq lr b">flatMap</code>、<code class="fe lo lp lq lr b">collect</code>和<code class="fe lo lp lq lr b">filter</code>开始。</p><h1 id="cdfb" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">地图</h1><p id="97ba" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">你可以在所有的收藏上调用<code class="fe lo lp lq lr b">map</code>。它将传递的函数应用于每个元素，并返回转换后的元素的集合。</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="9c50" class="nd lt it lr b gy ne nf l ng nh">def divideByTwo(number: Int) = number / 2  <br/>List(10, 20, 30).map(divideByTwo) // List(5, 10, 15)</span></pre><p id="cc2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…这个函数也可以是匿名的，你会<strong class="kd iu">非常</strong>经常看到这样的代码:</p><p id="5d15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">List(10, 20, 30).map(nr =&gt; nr / 2) // List(5, 10, 15)</code></p><p id="120b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…或者更常见的是对匿名函数使用语法糖，如下所示:</p><p id="c48f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">List(10, 20, 30).map(_ / 2) // List(5, 10, 15)</code></p><p id="293c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，<code class="fe lo lp lq lr b">map</code>中使用的函数可以是从(在我们的例子中)<code class="fe lo lp lq lr b">Int</code>到任何其他类型的函数——天空是你的极限。所以让我们试试从<code class="fe lo lp lq lr b">Int</code>到<code class="fe lo lp lq lr b">String</code>的函数？</p><p id="5ebc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">List(10, 20, 30).map(_.toString) // List("5", "10", "15")</code></p><p id="77de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">总结</strong>T25】你可以把<code class="fe lo lp lq lr b">map</code>想成“把这个函数应用到这个集合的每个元素上，并返回结果”。</p><p id="4d5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">重要提示—选项</strong>的地图</p><p id="55f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">map</code>对<code class="fe lo lp lq lr b">Option</code>有特殊的用法——它只会执行<code class="fe lo lp lq lr b">Some</code>上传递的功能:</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="1e95" class="nd lt it lr b gy ne nf l ng nh">val someString: Option[String] = Some("hello") <br/>val noneString: Option[String] = None </span><span id="da0a" class="nd lt it lr b gy ni nf l ng nh">someString.map(_.length) // Some(5) <br/>noneString.map(_.length) // None</span></pre><p id="17b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您已经看到它对于错误处理是多么方便了吗？将会有一个关于错误处理的独立帖子，而<code class="fe lo lp lq lr b">Option</code>将会是这一集的明星之一。</p><h1 id="9cc5" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">平面地图</h1><p id="0fd5" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated"><code class="fe lo lp lq lr b">flatMap</code>无非是先叫<code class="fe lo lp lq lr b">map</code>再叫<code class="fe lo lp lq lr b">flatten</code>。为什么会有用？</p><p id="c38b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在集合中，<code class="fe lo lp lq lr b">flatMap</code>是一个救命稻草，当你发现自己有一种嵌套类型，比如<code class="fe lo lp lq lr b">List[List[_]]</code>或者<code class="fe lo lp lq lr b">Option[Option[_]]</code>。</p><p id="a851" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们得到一个非直观类型的用户列表<code class="fe lo lp lq lr b">List[List[String]]</code>:</p><p id="863a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">val allUsers = List(List("ann", "betty"), List("caro", "ciara"))</code></p><p id="c645" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们需要将所有的名字列为一个列表，但是所有的名字都要大写。为了让最终代码更具可读性，我们可以先创建一个小函数:</p><p id="8ba0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">def listOfStringUpCase(list: List[String]) = list.map(_.toUpperCase)</code></p><p id="6c23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们现在可以<code class="fe lo lp lq lr b">map</code>，对吗？</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="8197" class="nd lt it lr b gy ne nf l ng nh">val upperCasedListsOfUsers = allUsers.map(listOfStringUpCase) <br/>// List(List("ANN", "BETTY"), List("CARO", "CIARA"))</span></pre><p id="5a1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…不幸的是，这又给我们留下了一个<code class="fe lo lp lq lr b">List[List[String]]</code>。所以现在是时候<code class="fe lo lp lq lr b">flatten</code>——“合并”我们嵌套的<code class="fe lo lp lq lr b">List</code>并以单个<code class="fe lo lp lq lr b">List</code>结束:</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="c98e" class="nd lt it lr b gy ne nf l ng nh">upperCasedListsOfUsers.flatten <br/>// List(ANN, BETTY, CARO, CIARA)</span></pre><p id="dfdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是<code class="fe lo lp lq lr b">flatmap</code>呢？我们可以用<code class="fe lo lp lq lr b">flatMap</code>代替所有这些噪音，得到一个非常直观和优雅的解决方案:</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="eefc" class="nd lt it lr b gy ne nf l ng nh">allUsers.flatMap(listOfStringUpCase) <br/>// List(ANN, BETTY, CARO, CIARA)</span></pre><p id="b5c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">总结</strong> <br/>你可以把<code class="fe lo lp lq lr b">flatMap</code>想成“把这个函数应用到这个集合的每个元素上，然后把结果扁平化，返回转换后的集合”。</p><p id="ff42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">重要提示—用于</strong>和<code class="fe lo lp lq lr b"><strong class="kd iu">List[Option[_]]</strong></code>的平面图</p><p id="953e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">flatMap</code>对<code class="fe lo lp lq lr b">List[Option]</code>有一个特殊的用法——它将<code class="fe lo lp lq lr b">None</code>的值“移除”(flatten):</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="df4a" class="nd lt it lr b gy ne nf l ng nh">List(Some("hello"), None, None, Some("world")) .flatMap(_.map(_.toUpperCase))  <br/>// List(HELLO, WORLD)</span></pre><p id="f208" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">..不像<code class="fe lo lp lq lr b">map</code>:</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="02a5" class="nd lt it lr b gy ne nf l ng nh">List(Some("hello"), None, None, Some("world")) .map(_.map(_.toUpperCase))  <br/>// List(Some(HELLO), None, None, Some(WORLD))</span></pre><p id="7094" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是对于上面的<code class="fe lo lp lq lr b">map</code> -如果我们随后使用<code class="fe lo lp lq lr b">flatten</code>，结果显然与上面的<code class="fe lo lp lq lr b">flatMap</code>相同</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="0192" class="nd lt it lr b gy ne nf l ng nh">List(Some("hello"), None, None, Some("world")) .map(_.map(_.toUpperCase)).flatten <br/>// List(HELLO, WORLD)</span></pre><h1 id="a781" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">过滤器</h1><p id="19f8" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">这很简单— <code class="fe lo lp lq lr b">filter</code>做了您认为它会做的事情——它返回满足给定谓词的项目:</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="d0b4" class="nd lt it lr b gy ne nf l ng nh">List(1, 2, 3, 4).filter(_ &gt; 3) // List(4)</span></pre><h1 id="8e90" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">收集</h1><p id="80b5" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">一个<code class="fe lo lp lq lr b">filter</code>和<code class="fe lo lp lq lr b">map</code>的“混合体”。语法可能看起来有点复杂，因为<code class="fe lo lp lq lr b">collect</code>采用了部分函数(关于部分函数的帖子将很快发布):</p><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="a970" class="nd lt it lr b gy ne nf l ng nh">List(1, 2, 3, 4).collect {     <br/>   case i if(i &gt; 3) =&gt; i * 3 <br/> }  <br/>// List(12)</span></pre><p id="0a9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">摘要</strong> <br/>您可以将<code class="fe lo lp lq lr b">collect</code>视为“从该集合中过滤值，并对匹配的值应用该函数”</p><h2 id="2cc9" class="nd lt it bd lu nj nk dn ly nl nm dp mc km nn no mg kq np nq mk ku nr ns mo nt bi translated">实际上，你多久用一次这些来代替循环等等？</h2><p id="6d6f" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated"><strong class="kd iu">每一天</strong>，无一故障。我认为<code class="fe lo lp lq lr b">map</code>、<code class="fe lo lp lq lr b">flatMap</code>和<code class="fe lo lp lq lr b">filter</code>是你最先学习的东西。我记得我的第一个Scala代码，我所说的第一个是指第一行。我准备好了这个华丽的for循环，有人在我的代码审查中指出，我的9行代码可以替换为不到10个字符…当然，我被说服了！</p><p id="3c52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一些关于如何使用我今天解释的方法解决一些简单问题的想法，在你的头脑中把它们与不使用<code class="fe lo lp lq lr b">map</code>、<code class="fe lo lp lq lr b">flatmap</code>、<code class="fe lo lp lq lr b">filter</code>或<code class="fe lo lp lq lr b">collect</code>的解决方案进行比较。下面的解决方案更简洁，不是吗？</p><h2 id="2fcb" class="nd lt it bd lu nj nk dn ly nl nm dp mc km nn no mg kq np nq mk ku nr ns mo nt bi translated">列出所有奇数</h2><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="b66a" class="nd lt it lr b gy ne nf l ng nh">val list = List(1, 2, 3, 4) list.filter(_ % 2 != 0)</span></pre><h2 id="68fe" class="nd lt it bd lu nj nk dn ly nl nm dp mc km nn no mg kq np nq mk ku nr ns mo nt bi translated">找出句子中最短单词的长度</h2><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="4cff" class="nd lt it lr b gy ne nf l ng nh">val sentence = "How long is the shortest word?" <br/>sentence.split(" ").map(_.length).min <br/>// 2</span></pre><h2 id="aff0" class="nd lt it bd lu nj nk dn ly nl nm dp mc km nn no mg kq np nq mk ku nr ns mo nt bi translated">复制列表中的所有元素</h2><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="eb7a" class="nd lt it lr b gy ne nf l ng nh">val list = List(1, 2, 3, 4) list.flatMap(element =&gt; List(element, element))</span></pre><h2 id="f904" class="nd lt it bd lu nj nk dn ly nl nm dp mc km nn no mg kq np nq mk ku nr ns mo nt bi translated">将所有以A开头的名称改为大写，并只返回它们</h2><pre class="mv mw mx my gt mz lr na nb aw nc bi"><span id="d485" class="nd lt it lr b gy ne nf l ng nh">val list = List("anna", "brad", "aga", "steve") <br/>list.collect {     <br/>  case name if(name.startsWith("a")) =&gt; name.toUpperCase <br/> }</span></pre><h2 id="79b2" class="nd lt it bd lu nj nk dn ly nl nm dp mc km nn no mg kq np nq mk ku nr ns mo nt bi translated">最后一个音符</h2><p id="ec62" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">当然，如果你想解决以上所有问题，你也可以使用for循环和命令式方法。不过，我永远不会鼓励这样做。Scala提供了极其强大的集合API，这就像把扫雪机挂在法拉利上一样。就我自己而言，我想充分利用Scala，我喜欢代码看起来如此干净，你可以得到如此丰富的表达。拥有这些一行解决方案是多么令人满意…</p></div></div>    
</body>
</html>