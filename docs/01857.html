<html>
<head>
<title>Using Firebase Authentication in a Nuxt Server-side Rendered Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Nuxt服务器端呈现的应用程序中使用Firebase身份验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-firebase-authentication-in-a-nuxt-server-side-rendered-application-c2a624a9e999?source=collection_archive---------5-----------------------#2020-02-03">https://levelup.gitconnected.com/using-firebase-authentication-in-a-nuxt-server-side-rendered-application-c2a624a9e999?source=collection_archive---------5-----------------------#2020-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/68c38a859ffd3144502bacc6f101774f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPFfmhjgaYUMlNHQuWS4oQ.png"/></div></div></figure><p id="d8a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在通用应用程序中使用Firebase身份验证可能不太直接。我这篇文章的目的是分享我让Firebase客户端认证在Nuxt上运行良好的经验。JS框架，并且不牺牲Nuxt的任何内置功能。JS框架。</p><h1 id="590d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">前言</h1><p id="4ba4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Medium、Stack Overflow和其他一些网站上散布着大量的问题，更不用说你可能会发现的无数文章了。可悲的是，他们没有给出有效的答案，可能误导，重复别人过去的答案，过时，或者只是不适用于通用模式Nuxt。JS应用。</p><p id="e34e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，您可能会想看看市场上有哪些库。在撰写本文时，还没有多少即插即用模块/库可以让Nuxt与Firebase身份验证一起工作。在现有的那些库中，似乎没有一个能提供通用模式的解决方案。然而，由Lupas——该库的作者——命名为nuxt-fire的库如果继续发展下去，看起来确实很有希望；我说“如果它继续发展下去，那将是有希望的”，因为它是最好的即插即用Nuxt。JS模块，但在为使用通用模式的身份验证提供可靠的解决方案方面，它还不是很好。</p><h2 id="fa0e" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">是时候让新火来拯救我们了</h2><p id="6f47" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Lupas的模块有助于将Firebase的许多服务集成到Nuxt中，同时也为其中的一些集成提供了一些他自己的实验功能——我们将在我们的应用程序中使用这个库。此外，卢帕斯似乎对他的图书馆充满热情，并希望它成为最好、最全面的解决方案。在其当前版本(3.5.5)中，您可以简单地启用auth，方法是将一个布尔值传递到模块选项或一个对象中，该对象包含当某些Firebase auth事件发生时将调用的Vuex存储突变和操作的名称，以及一个设置SSR的选项。</p><p id="0102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我在配置auth集成的文档中看到SSR选项时，我眼前一亮。我想“哈利路亚！终于有人做到了！”在阅读了那个选项做了什么、结果启用了哪些代码以及Firebase文档之后，我开始有了新的想法。</p><h2 id="8722" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">Lupas认证解决方案的前提</h2><p id="eeeb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Lupas的解决方案附带了一个服务人员，即一块Nuxt。JS服务器中间件，和一个插件。服务工作人员处理fetch事件，以确保每当浏览器需要获取任何内容时，它都会劫持请求，并使用当前用户id令牌为特定请求设置授权头。服务器中间件查找先前设置的授权头，并将在响应对象上设置几个属性，这些属性包含来自解码声明的用户信息。最后，插件设置onAuthStateChanged事件监听器，该监听器将相应地提交和调度上述Vuex突变和动作。</p><p id="4892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在Lupas的解决方案中遇到的核心问题是它所做的假设。首先，它要我注册一个服务工作者，这个服务工作者似乎是从nuxt-fire库内部复制到每个nuxt版本的apps静态目录中的。其次，我不知道这是特定于Firebase功能还是托管解决方案，但我注意到，如果我没有运行服务器框架(例如express、fastify)，那么任何注册的Nuxt服务器中间件在Firebase功能上托管时都不会在生产中执行。然而，这并不是立即显而易见的，因为服务器中间件将在运行开发服务器时执行。</p><h1 id="3900" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">定义解决方案</h1><p id="62ed" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">注意了。我们将在接下来的解决方案中使用nuxt-fire，Axios，一个定制的nuxt插件，以及nuxtServerInit调用。但是在我们开始之前，我将简要回顾一下这个高层次的概念。</p><h2 id="dac5" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">nuxtServerInit</h2><p id="5302" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">nuxtServerInit将检查我们将在客户端设置的包含当前登录用户的ID令牌的cookie是否存在。如果这个cookie存在，我们将尝试向Firebase Admin验证ID令牌。如果id令牌有效，我们将解码ID令牌，并将令牌中包含的声明提交给我们的Vuex存储，以便与我们的auth-listener插件一起使用。</p><h2 id="5a30" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">授权监听器插件</h2><p id="0c33" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">auth-listener插件是一个只在客户端运行的插件，负责检查Vuex存储以查看用户是否能够通过服务器的身份验证，还负责注册Firebase提供给我们的onIdTokenChanged事件侦听器。在这里记下来，因为这里进行的顺序很重要。该插件中的Vuex身份验证检查需要优先进行，因为我们需要在注册onIdTokenChanged事件侦听器之前调用$fireAuth.signOut()的能力，否则用户会话将被刷新。这很重要，如果服务器没有用用户信息初始化我们的Vuex存储，这意味着id令牌无效。接下来是我们的客户端插件运行的时候了，我们要确保它不会认为用户是经过认证的，这会导致客户端/服务器呈现不匹配。</p><h2 id="2a02" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">Axios拦截器</h2><p id="47d4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">最后，如果您正在发出需要认证的API请求，并且希望您的ID令牌作为认证用户的手段，那么您将需要使用请求拦截器。不符合这个要求也不用担心。跳过这一部分。谢天谢地，Axios让拦截请求变得很容易。让我们概述一下需要拦截器的原因。在发送网络请求之前，我们需要确保在向我们的API发出请求之前，我们拥有最新的ID令牌。这将减少服务器向我们发回未授权请求的机会。想象一下，在给定的ID令牌过期之前，您有1秒钟的时间。假设您在一个慢速连接上发出一个请求，因此请求直到客户端发送请求后2秒钟才到达服务器。看到问题了吗？客户端认为我们通过了身份验证，但是由于时间延迟，服务器看到的是相反的情况。这就是为什么在发送令牌之前更新它很重要。</p><h1 id="63d8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">上班时间</strong></h1><p id="065d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们从安装6个必要的NPM模块开始:</p><div class="mm mn gp gr mo mp"><a href="https://www.npmjs.com/package/firebase-admin" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">firebase-管理</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">Node.js的Firebase管理SDK</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.npmjs.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd jw mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a href="https://www.npmjs.com/package/@nuxtjs/axios" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">@nuxtjs/axios</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">安全轻松的Axios与Nuxt.js集成自动设置客户端和服务器端的基本URL暴露setToken…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.npmjs.com</p></div></div><div class="my l"><div class="ne l na nb nc my nd jw mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a href="https://www.npmjs.com/package/nuxt-fire" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">nuxt-火</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">轻松地将Firebase集成到您的Nuxt 2项目中。📖阅读完整文档📖访问GitHub页面安装Nuxt-Fire…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.npmjs.com</p></div></div><div class="my l"><div class="nf l na nb nc my nd jw mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a href="https://www.npmjs.com/package/js-cookie" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">js-cookie</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">一个用于处理cookies的简单、轻量级的JavaScript API</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.npmjs.com</p></div></div><div class="my l"><div class="ng l na nb nc my nd jw mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a href="https://www.npmjs.com/package/cookie" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">甜饼干</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">HTTP服务器的基本HTTP cookie解析器和序列化器。解析HTTP Cookie头字符串并返回一个对象…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.npmjs.com</p></div></div><div class="my l"><div class="nh l na nb nc my nd jw mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a href="https://www.npmjs.com/package/jwt-decode" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">jwt-解码</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">jwt-decode是一个小的浏览器库，帮助解码Base64Url编码的jwt令牌。重要提示:这…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.npmjs.com</p></div></div><div class="my l"><div class="ni l na nb nc my nd jw mp"/></div></div></a></div><p id="cdc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装好这些之后，让我们定义所需的Vuex存储操作、getters和突变:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d09c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:cookie名称在这里很重要，尤其是当您使用Firebase函数时；它必须是_ _会话。</p><p id="8e54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要auth-listener插件:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前面代码中的_handleAuthError函数是供您实现的；这与这个例子无关。</p><p id="7291" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要Axios拦截器:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="06b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我承认，我认为Lupas让Firebase auth按需可用的做法非常酷。因此，主要思想是您等待一个承诺，该承诺执行Firebase的onAuthStateChanged事件侦听器，从而捕获取消订阅。然后，您立即取消订阅事件侦听器，一旦auth可用，您就可以获得用户并解析承诺。所以给那个想出这段代码的人一点鼓励吧。</p><p id="0ced" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，为了完整起见，我将提供nuxt.config.js的相关部分:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e6c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你需要遵循Lupas的nuxt-fire配置指南:<a class="ae np" href="https://nuxtfire.netlify.com/guide/getting-started/#simple-configuration" rel="noopener ugc nofollow" target="_blank">https://nuxt fire . netlify . com/guide/getting-started/# simple-Configuration</a></p><h1 id="0164" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="599e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">你有它！我希望你觉得这是有帮助的，如果我错过了什么，请让我知道(这是一篇很长的文章)XD。此外，您可以扩展这个示例。假设您希望服务器在现有会话过期时将您重定向到一个更新会话的页面，然后该页面将您重定向回原始目的地。无论如何，祝你好运，下次再见。</p></div></div>    
</body>
</html>