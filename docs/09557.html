<html>
<head>
<title>3 Things I Learned Writing 300+ Tests in a Month</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在一个月内写300多个测试中学到的3件事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-things-i-learned-writing-300-tests-in-a-month-a9d48a7184c7?source=collection_archive---------1-----------------------#2021-08-22">https://levelup.gitconnected.com/3-things-i-learned-writing-300-tests-in-a-month-a9d48a7184c7?source=collection_archive---------1-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/97a17cd51c4e98b680eea0262eabb4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQzchii7xTo-zNCuzGmzrQ.png"/></div></div></figure><p id="047e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们都经历过这种情况:给你一个要维护的应用程序。这款应用的测试数据糟糕透顶，几乎没有测试覆盖率。维护和扩展是一个很大的痛苦，没有真正的方法来告诉你是否已经破坏了什么。</p><p id="6ae2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常困难的情况:在你之前的工程师认为他们不需要单元测试，他们是上天派来成为第一次就写出完美代码的唯一工程师的。</p><p id="16c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我继承的应用程序有0个单元测试。这是一场混乱&amp;分别是Typescript前端和后端。不知何故，它设法在几乎没有错误的情况下完成了它的核心工作:也许在应用程序中投入了大量的人工测试。</p><p id="d220" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我决定做我想看到的改变——在连续4周每周花费40个小时后，我最终将覆盖率提高到了90%。以下是我学到的。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6e39" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">1.在编写实现时，您绝对需要考虑测试</h1><p id="887b" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">你有没有尝试过在没有依赖注入的情况下为应用程序深处的组件编写单元测试？这几乎是不可能的——你需要模仿每一个小的交互，因为它的所有依赖都是真实的，而不仅仅是模仿。我愚蠢地花了第一周的时间，认为我可以不用重构实现代码。</p><p id="ba13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我大错特错了。</p><p id="70d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">引入依赖注入使得测试变得容易很多很多倍。能够创建您想要的确切的交互是非常好的，并且帮助我们创建健壮而简洁的测试。</p><p id="9c02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你是用编译语言写的，很有可能你不能模仿导入。使用TS/JS，您可以模拟一个导入的函数，然后导入您模拟的版本——这对于Java或Dart这两种编译语言来说不太适用。相反，您需要直接在对象中注入依赖关系。</p><p id="b0d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试时我不得不重构的其他事情是将所有字符串提取为常量。例如，如果用户要注销，我们会向他们显示文本“注销！”。</p><p id="23eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们如何验证文本在屏幕上？它可能看起来像这样:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="00ad" class="ms lh it mo b gy mt mu l mv mw">expect(find.text("logged out!"), toFindOneWidget);</span></pre><p id="1d88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果UI/UX人员要求快速更改注销的副本，您就必须重构所有的测试来使用新的副本。相反，我提取出“注销！”文本到变量中。</p><p id="c93d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单，但是在编写单元测试时非常重要。</p><h1 id="2814" class="lg lh it bd li lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md bi translated">2.100%的测试覆盖率(可能是！)过度杀戮</h1><p id="2808" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">当我开始的时候，我决定我还不如完整的发送它，去实现100%的测试覆盖率。我很快了解到，有一些黑暗的角落很难测试或者测试起来毫无用处。以此为例:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e632" class="ms lh it mo b gy mt mu l mv mw">MyListener(<br/>    onEvent: (event) =&gt; event.join(<br/>        (state1) =&gt; null, <br/>        (state2) =&gt; null, <br/>        (state3) =&gt; doSomething(state3.property)<br/>   )<br/>);</span></pre><p id="3fe7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试状态3完全有效，这是我最终测试的分支。但是编写一个类似“在state1 / state2上什么都不做”的测试是1。没用，2。<em class="nc">不可能</em>。</p><p id="f9ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想一想:你如何验证一个函数什么也不做？你会仔细检查每一个mock并确保它没有被调用吗？不太容易扩展。</p><p id="2313" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我可能最终会对所有只对一种状态做出反应的事件编写扩展，但这是积压工作。我想专注于让应用程序更好地为我的用户服务，而不是当开发人员看到“覆盖率:100%”时，在他们的大脑中释放多巴胺！</p><p id="9453" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不过，这并不意味着100%的覆盖率对所有应用都不好。测试是一场马拉松，不是短跑——但我最终在这里跑完了马拉松。我在待办事项清单上添加了许多项目，等我有空的时候，我会慢慢开始挑选。</p><p id="352f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中一项就是获得100%的保险。</p><h1 id="3b4c" class="lg lh it bd li lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md bi translated">3.测试后端比前端容易</h1><p id="5fd4" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在你举起你的干草叉之前:这是一篇观点文章！如果你不同意，我很想在评论中听到原因。</p><p id="f157" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">后端代码是非常确定的。动作大多是线性的，(例如，一个路由调用一个服务)，每个入口点都非常清晰，输出也同样清晰。</p><p id="15f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前端不是这样的。</p><p id="85dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">应用程序中的单个屏幕不只有一个入口点:也许一个deeplink推送通知会将你发送到该屏幕。也许有些字段是预填充的，或者用户不是管理员，所以他甚至不应该出现在那个屏幕上。</p><p id="8081" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以编写易于测试的前端代码，但这是“在编写时请记住测试”的另一种情况。每个加载状态，故障状态，都需要有自己的单元测试，你只能知道当用户使用应用程序时会出现什么故障。</p><p id="34d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的应用程序中有一个我没想过要测试但确实带来了错误的例子，当一个用户来回发送两个按钮时，他们会创建一个竞争条件。这个竞争条件意味着一个加载事件将在一个加载事件之后发送，整个应用程序将永远挂在一个加载屏幕上。</p><p id="37c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我怎么知道要测试这种互动？我知道在我的后端，我不会在一个循环中调用足够多的函数来让类似的行为发生。</p><p id="8884" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总的来说，人类是不可预测的生物，而机器是不可思议的可预测的。测试机器行为比测试人类容易得多。</p><p id="399c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关于这一点的最后一点是，可以在前端进行数百种生活质量的改变，如缓存和预测。对于用户可能永远不会注意到的事情，至少要额外进行两次测试(当缓存正常时和出错时)。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="6796" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不要让这阻碍你写测试。每次我添加一个新功能，就像呼吸了一口新鲜空气，因为我知道其他一切都在按预期运行。</p><p id="aedf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一名开发人员，单元测试是我最喜欢做的事情之一，因为我对自己的代码感到无比的高效和快乐。我不再写没有测试的代码，持有微脚本，并且我是一个更高效的开发人员。</p><p id="5ee1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你有什么测试故事可以分享吗？有任何问题或意见吗？请在评论里告诉我！我总是在阅读和学习。</p><p id="1aea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p></div></div>    
</body>
</html>