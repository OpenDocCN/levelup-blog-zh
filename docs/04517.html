<html>
<head>
<title>Working with CSV Data in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中使用CSV数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/working-with-csv-data-in-rust-7258163252f8?source=collection_archive---------4-----------------------#2020-06-30">https://levelup.gitconnected.com/working-with-csv-data-in-rust-7258163252f8?source=collection_archive---------4-----------------------#2020-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5ad08f92426f128b70936b90866156dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wB9URXuyb-XnU_728RUujg.png"/></div></div></figure><p id="3b0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CSV文件格式是存储表格数据的一种非常常用的方法。本文涵盖了读取和写入CSV文件的基础知识，使用Serde库对CSV数据进行反序列化，最后给出了一个数据聚合示例。</p><h1 id="c499" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h1><p id="78af" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">产生这篇文章的想法是因为我需要一种快速便捷的方法来处理CSV格式的数据。一种选择是编写自己的库，但我觉得这不是一个方便的解决方案。所以，经过一番研究，我决定使用由安德鲁·格兰特创作的csv机箱。我选择这个板条箱是因为API相当简单，而且对我来说最重要的是，文档非常全面。</p><h1 id="1887" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置</h1><p id="d1dd" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要使用这个机箱，只需使用<code class="fe ma mb mc md b">cargo new</code>创建一个新的Rust项目，并将其添加到<code class="fe ma mb mc md b">Cargo.toml</code>文件中的<code class="fe ma mb mc md b">[dependencies]</code>下:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="27b7" class="mm kx iq md b gy mn mo l mp mq">csv = "1.1"</span></pre><p id="0f90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，本文部分内容将利用Serde的自定义派生功能，所以继续添加:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e1b3" class="mm kx iq md b gy mn mo l mp mq">serde = { version = "1", features = ["derive"] }</span></pre><h1 id="1c1f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数据源</h1><p id="4e4d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">本文中的所有数据都是从<a class="ae lz" href="https://mockaroo.com/" rel="noopener ugc nofollow" target="_blank"> Mockaroo </a>生成的，这是一个免费的模拟数据服务，非常灵活，易于使用和共享。我将使用的模式可以在以下链接中找到:</p><blockquote class="mr ms mt"><p id="e4b1" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated"><em class="iq">关于</em> <code class="fe ma mb mc md b"><em class="iq">Order</em></code> <em class="iq">模式的一个快速注释。它与</em> <code class="fe ma mb mc md b"><em class="iq">Customer</em></code> <em class="iq">模式有一个外键关系。要在Mockaroo站点上进行设置，首先创建</em> <code class="fe ma mb mc md b"><em class="iq">Customer</em></code> <em class="iq">模式，将其下载为csv文件，将csv文件上传为数据集，然后您可以创建</em> <code class="fe ma mb mc md b"><em class="iq">Order</em></code> <em class="iq">模式。</em></p></blockquote><h1 id="2a51" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">读取CSV数据</h1><p id="796f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe ma mb mc md b">csv</code>机箱提供了一个<code class="fe ma mb mc md b">Reader</code>结构，用于将原始CSV数据转换为标准Rust类型。<code class="fe ma mb mc md b">Reader</code>具有从输入流或文件中读取数据，并使用Serde将数据反序列化为定制结构的功能。</p><h2 id="928e" class="mm kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">从<code class="fe ma mb mc md b">stdin</code>读取</h2><p id="53c7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从<code class="fe ma mb mc md b">stdin</code>读取可能不是一个常见的用例，除非您将CSV数据传递给命令行应用程序。为了从<code class="fe ma mb mc md b">stdin</code>中读取，机箱提供了一个名为<code class="fe ma mb mc md b">from_reader</code>的功能。这个方法适用于任何实现trait的类型，这意味着您可以从一个字节数组读入一个<code class="fe ma mb mc md b">Reader</code>。以下示例显示了如何从<code class="fe ma mb mc md b">stdin</code>读取CSV数据:</p><p id="abbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://github.com/andrewleverette/rust_csv_examples/blob/master/src/bin/csv_read_stdin.rs" rel="noopener ugc nofollow" target="_blank"><em class="mu">/src/bin/CSV _ read _ stdin . RS</em>T20】</a></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/dbe46f4a2690ae6dff41f1ef374eae37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x5U_T5RjSKlE5n0z.png"/></div></div></figure><p id="ec5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦该代码被编译，就可以通过向它传递下载的CSV文件来调用它。例如，我使用<code class="fe ma mb mc md b">cargo build --release</code>编译了上面的代码，并能够通过在终端中键入以下代码来运行它:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="bef8" class="mm kx iq md b gy mn mo l mp mq">./target/release/read_csv_stdin &lt; data/Customers.csv</span></pre><p id="c22d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出将如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="cca1" class="mm kx iq md b gy mn mo l mp mq">StringRecord(["26fa5a49-5194-40eb-8faf-219c9fff831e", "Arline", "Jardine", "ajardine0@vimeo.com", "61635 Dawn Hill"]) StringRecord(["708fcc04-e387-47e3-b85d-99ccd4e18320", "Baillie", "Pierri", "bpierri1@people.com.cn", "70540 Gerald Way"]) StringRecord(["9a8ffa76-0280-4754-b75c-4de7508cdd67", "Jenda", "Print", "jprint2@umn.edu", "928 Bluestem Parkway"]) StringRecord(["c5b4b822-2b59-435f-a697-6f1d4bbb0684", "Lucia", "Rhucroft", "lrhucroft3@techcrunch.com", "212 Schiller Pass"]) StringRecord(["f266b61e-534f-483b-9f70-0029b7424aa8", "Sybila", "Valdes", "svaldes4@google.com.au", "2 Gateway Avenue"])</span></pre><p id="617d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到了一点，那就是<code class="fe ma mb mc md b">.records()</code>不包括标题行。该方法跳过第一行，因为默认情况下它被解释为标题记录。<code class="fe ma mb mc md b">Reader</code>结构有一个名为<code class="fe ma mb mc md b">.headers()</code>的独立方法来检索标题记录。</p><h2 id="e6e4" class="mm kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">从文件中读取</h2><p id="eb3c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从文件中读取可能是<code class="fe ma mb mc md b">Reader</code>结构最常见的用例。crate提供了一个名为<code class="fe ma mb mc md b">from_path</code>的方法，它从CSV数据文件路径创建一个<code class="fe ma mb mc md b">Reader</code>。从文件中读取的代码看起来与从<code class="fe ma mb mc md b">stdin</code>中读取的代码非常相似。以下示例显示了如何从文件中读取CSV:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c8e49af67958c5ee33aa226580c62bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OjMoSodAjqHmAnV_.png"/></div></figure><h2 id="3bd5" class="mm kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">和Serde一起阅读</h2><p id="92fe" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这个机箱的一个便利特性是支持Serde，它提供了读取CSV数据并将其反序列化为自定义Rust数据类型的功能。例如，原始的<code class="fe ma mb mc md b">Customer</code>数据看起来像这样</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3b20" class="mm kx iq md b gy mn mo l mp mq">customer_guid,first_name,last_name,email,address 26fa5a49-5194-40eb-8faf-219c9fff831e,Arline,Jardine,ajardine0@vimeo.com,61635 Dawn Hill</span></pre><p id="f571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-可以反序列化为Rust结构，如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="8a39" class="mm kx iq md b gy mn mo l mp mq">struct Customer {<br/>    customer_guid: String,<br/>    first_name: String,<br/>    last_name: String,<br/>    email: String,<br/>    address: String<br/>}</span></pre><p id="beeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而不是像前面的例子那样使用<code class="fe ma mb mc md b">.records</code>方法。<code class="fe ma mb mc md b">Reader</code>结构提供了另一个名为<code class="fe ma mb mc md b">.deserialize</code>的方法，在每个反序列化的记录上创建一个迭代器。以下示例显示了如何读取CSV数据并将其反序列化为Rust类型:</p><p id="9a56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【T21<em class="mu">/src/bin/CSV _ read _ serde . RS</em></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/44d9580c31153845832f361f0386b20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u4k5QUadP6Cyst8Q.png"/></div></div></figure><p id="b924" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的一件重要事情是，反序列化数据会带来一些固有的开销。如果将前两个例子与这个例子进行比较，您会发现反序列化数据会更慢。</p><h2 id="14d0" class="mm kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">用Serde处理无效数据</h2><p id="d09d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">前面的例子都假设了相当干净的数据。然而，CSV文件格式不强制这样的假设。因此，如果我们试图反序列化无法转换为声明类型的数据，那么将会出现错误。</p><p id="ab97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，对于Orders模式，Rust结构可能如下所示:</p><p id="009f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们假设有一条记录是这样的:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="bdcf" class="mm kx iq md b gy mn mo l mp mq">order_guid,customer_guid,order_date,total 02a771c1-9885-40d6-9acc-75cd108e9218,022d6000-b4da-412b-ba7c-cd0dbf868af9,4/16/2020,Null</span></pre><p id="9f27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当Serde试图反序列化<code class="fe ma mb mc md b">Null</code>值时，将会出现如下所示的错误:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f2cb" class="mm kx iq md b gy mn mo l mp mq">CSV deserialize error: record 1 (line: 2, byte: 42): field 3: invalid float literal</span></pre><p id="2a56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，crate提供了一个助手函数，可以应用于<code class="fe ma mb mc md b">Option</code>字段，告诉Serde在出现错误时将值转换为<code class="fe ma mb mc md b">None</code>。添加该功能如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="26a9" class="mm kx iq md b gy mn mo l mp mq">#[derive(Debug, Deserialize)]<br/>struct Order {<br/>    order_guid: String,<br/>    customer_guid: String,<br/>    order_date: String,<br/><br/>    #[serde(deserialize_with = "csv::invalid_option")]<br/>    total: Option&lt;f64&gt;<br/>}</span></pre><p id="f914" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了<code class="fe ma mb mc md b">invalid_option</code> helper方法，其余的代码与前面的例子完全相同。</p><h1 id="0d01" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">写入CSV数据</h1><p id="1716" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">写CSV数据比读它更简单，因为您对输出有更多的控制。机箱提供了一个<code class="fe ma mb mc md b">Writer</code>结构，它与<code class="fe ma mb mc md b">Reader</code>结构的接口非常相似。<code class="fe ma mb mc md b">Writer</code>结构提供了写入<code class="fe ma mb mc md b">stdout</code>、写入文件以及将Rust类型序列化为CSV数据的功能。</p><h2 id="3e36" class="mm kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">写入<code class="fe ma mb mc md b">stdout</code></h2><p id="768b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个简单的用例可能是将CSV数据写入<code class="fe ma mb mc md b">stdout</code>，以便它可以通过管道进入另一个应用程序。为了写入<code class="fe ma mb mc md b">stdout</code>，crate提供了<code class="fe ma mb mc md b">from_writer</code>方法来创建一个配置为写入<code class="fe ma mb mc md b">stdout</code>的<code class="fe ma mb mc md b">Writer</code>结构。一旦创建了<code class="fe ma mb mc md b">Writer</code>结构，就通过调用<code class="fe ma mb mc md b">Writer</code>实例上的<code class="fe ma mb mc md b">write_record</code>方法来添加记录。以下显示了如何将CSV数据写入<code class="fe ma mb mc md b">stdout</code>:</p><p id="ffc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://github.com/andrewleverette/rust_csv_examples/blob/master/src/bin/csv_write_stdout.rs" rel="noopener ugc nofollow" target="_blank"><em class="mu">/src/bin/CSV _ write _ stdout . RS</em>T22】</a></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/11bd7915c8929bd016be2cd8607239de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kCfOy-7yV5YDf1aL.png"/></div></div></figure><p id="48c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这只是写到<code class="fe ma mb mc md b">stdout</code>，程序可以这样调用:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c790" class="mm kx iq md b gy mn mo l mp mq">./target/release/csv_write_stdout</span></pre><p id="f06b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，您可以通过管道进入这样一个文件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="7425" class="mm kx iq md b gy mn mo l mp mq">/target/release/csv_write_stdout &gt; test.csv</span></pre><h2 id="0550" class="mm kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">写入文件</h2><p id="6355" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">写入CSV数据的另一个用例是写入文件。<code class="fe ma mb mc md b">csv</code> crate提供了<code class="fe ma mb mc md b">from_path</code>方法来创建一个<code class="fe ma mb mc md b">Writer</code>结构以写入给定的文件。除了<code class="fe ma mb mc md b">from_path</code>方法，这个例子和写<code class="fe ma mb mc md b">stdout</code>是一样的。</p><p id="3e1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://github.com/andrewleverette/rust_csv_examples/blob/master/src/bin/csv_write_file.rs" rel="noopener ugc nofollow" target="_blank"><em class="mu">/src/bin/CSV _ write _ file . RS</em>T19】</a></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/a344a17d338f397c48171942f4d23274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f3wI-EABg2euvmoX.png"/></div></div></figure><h2 id="f198" class="mm kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">用Serde写作</h2><p id="e030" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">类似于<code class="fe ma mb mc md b">Reader</code>结构，<code class="fe ma mb mc md b">Writer</code>结构支持使用Serde将Rust类型的数据序列化为CSV记录。这个例子重用了前面的<code class="fe ma mb mc md b">Customer</code>模式，并将<code class="fe ma mb mc md b">Customer</code>的实例转换成CSV数据。</p><p id="0b3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://github.com/andrewleverette/rust_csv_examples/blob/master/src/bin/csv_write_serde.rs" rel="noopener ugc nofollow" target="_blank"><em class="mu">/src/bin/CSV _ write _ serde . RS</em></a></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/c69c14c058721b6e9de34d553a7367fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WhoCDVwin_t5rtKb.png"/></div></div></figure><p id="59ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与其他写入示例相比，本示例的主要区别在于使用了<code class="fe ma mb mc md b">serialize</code>方法而不是<code class="fe ma mb mc md b">write_record</code>方法来写入数据。</p><h1 id="26a2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">CSV聚合</h1><p id="b936" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">处理CSV数据时，一个常见的用例是读取CSV文件，处理数据，然后将结果写回文件。此示例读取两个CSV文件，执行内部联接，然后将结果写入文件。由于这个例子比其他的要长，我只想强调几个部分，但是源代码可以在<a class="ae lz" href="https://github.com/andrewleverette/rust_csv_examples/blob/master/src/bin/csv_aggregation.rs" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="73f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定做的第一件事是定义一个结构来保存标题和记录，使执行聚合稍微容易一些。这个结构看起来像这样:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1472" class="mm kx iq md b gy mn mo l mp mq">#[derive(Debug)]<br/>struct DataSet {<br/>    /// Header row of CSV file<br/>    headers: StringRecord,<br/><br/>    /// Records from CSV file<br/>    records: Vec&lt;StringRecord&gt;,<br/>}</span></pre><p id="b232" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">StringRecord</code>类型是定义记录的<code class="fe ma mb mc md b">csv</code>箱中的结构。在读取和写入CSV数据时，在<code class="fe ma mb mc md b">DataSet</code>中使用这种类型便于与<code class="fe ma mb mc md b">Reader</code>和<code class="fe ma mb mc md b">Writer</code>内部集成。</p><p id="e2b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了连接这两个数据集，我将使用排序合并连接算法。基本上，它对给定列上的两个数据集进行排序，然后扫描两个数据集寻找匹配。当发现匹配时，它将两个数据集中的记录合并成一个记录，并将其添加到一个新的数据集中。</p><p id="411a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我有一个保存记录的自定义结构，所以我可以添加一个带有函数的<code class="fe ma mb mc md b">impl</code>块来对数据集中的记录进行排序。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5250" class="mm kx iq md b gy mn mo l mp mq">/// Sort data records by the given index.<br/>///<br/>/// # Errors<br/>///<br/>/// An error occurs if the index is out of bounds<br/>fn sort_by_index(&amp;mut self, index: usize) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {<br/>    if index &gt;= self.headers.len() {<br/>        Err(Box::new(IndexError(format!(<br/>            "Index '{}' out of bounds",<br/>            index<br/>        ))))<br/>    } else {<br/>        self.records.sort_by(|a, b| a[index].cmp(&amp;b[index]));<br/>        Ok(())<br/>    }<br/>}</span></pre><p id="ca78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦两个数据集都被排序了，我就可以把它们连接起来。内部连接方法的核心逻辑如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="d955" class="mm kx iq md b gy mn mo l mp mq">let mut left_cursor = 0;<br/>let mut right_cursor = 0;<br/><br/>while left_cursor &lt; self.records.len() &amp;&amp; right_cursor &lt; right.records.len() {<br/>    // If two fields match, merge fields into a single record<br/>    // and add to records vector<br/>    // If they don't match and the left value is less then right value advance the left cursor<br/>    // else advance the right cursor<br/>    if self.records[left_cursor][left_index] == right.records[right_cursor][right_index] {<br/>        let record = StringRecord::from(<br/>            self.records[left_cursor]<br/>                .iter()<br/>                .chain(right.records[right_cursor].iter())<br/>                .collect::&lt;Vec&lt;&amp;str&gt;&gt;(),<br/>        );<br/><br/>        records.push(record);<br/><br/>        // Since data sets are sorted<br/>        // Advance cursor through right data set to<br/>        // see if there are matches<br/>        let mut k = right_cursor + 1;<br/>        while k &lt; right.records.len()<br/>            &amp;&amp; self.records[left_cursor][left_index] == right.records[k][right_index]<br/>        {<br/>            let record = StringRecord::from(<br/>                self.records[left_cursor]<br/>                    .iter()<br/>                    .chain(right.records[k].iter())<br/>                    .collect::&lt;Vec&lt;&amp;str&gt;&gt;(),<br/>            );<br/><br/>            records.push(record);<br/><br/>            k += 1;<br/>        }<br/><br/>        left_cursor += 1;<br/>    } else if self.records[left_cursor][left_index]<br/>        &lt; right.records[right_cursor][right_index]<br/>    {<br/>        left_cursor += 1;<br/>    } else {<br/>        right_cursor += 1;<br/>    }<br/>}</span></pre><p id="5a41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">排序合并算法是有效连接数据集的众多算法之一。如果你想阅读更多关于这些类型的算法，我发现<a class="ae lz" href="http://blog.felipe.rs/2019/01/29/demystifying-join-algorithms/" rel="noopener ugc nofollow" target="_blank">这篇</a>文章是一个很好的起点。</p><h1 id="fcb3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">回顾</h1><p id="eecb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">总的来说，我认为<code class="fe ma mb mc md b">csv</code> crate非常容易使用，当我想要一个快速的CSV解析库时，它是我的第一选择。板条箱受益于记录良好的源代码和更详细的教程文档。Rust社区似乎也有同样的感觉，因为这个板条箱已经被下载了超过300万次。</p><h1 id="44da" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">谢谢</h1><p id="8185" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">感谢阅读！如果你想联系或想提供反馈，请随时通过<a class="ae lz" href="https://www.linkedin.com/in/andrewleverette/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="8f0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mu">原载于2020年6月30日</em><a class="ae lz" href="https://andrewleverette.github.io/working-with-csv-data/" rel="noopener ugc nofollow" target="_blank"><em class="mu">https://andrewleverette . github . io</em></a><em class="mu">。</em></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2683b9f8b8766fdf390a456bcd63ab22.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*3N6R_9KQPVOHCiYG66Iytg.png"/></div></figure></div></div>    
</body>
</html>