<html>
<head>
<title>Real-time user interaction using SignalR and Blazor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SignalR和Blazor的实时用户交互</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/trying-out-signalr-22948e809618?source=collection_archive---------7-----------------------#2021-06-02">https://levelup.gitconnected.com/trying-out-signalr-22948e809618?source=collection_archive---------7-----------------------#2021-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="801b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki"> dotnet新blazorserver </em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/e1712158e6b028764b320fd249911cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9s8d6M43giAijpceTn2LYw.png"/></div></div></figure><p id="8840" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di"> L </span>上周NextJS Conf开放注册(如果你还没有注册的话，请注册)。该网站有一个有趣的元素，访问该网站的用户可以看到其他用户，并可以与其他人实时共享消息。我认为这是对常规注册页面的一个很好的补充。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ma"><img src="../Images/0b613e4f28bd94f9bc59e44d7052a854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Y9wRXvAWBVO89jqUn6l8bQ.gif"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated"><a class="ae mf" href="https://nextjs.org/conf" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/conf</a></figcaption></figure><p id="9e7f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我知道SignalR及其实时功能，但从未真正尝试过。我想尝试看看是否可以使用ASP.NET核心信号构建类似于NextJS Conf网站的东西。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="6b17" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">关于SignalR的一点信息</h1><blockquote class="nf ng nh"><p id="3767" class="kv kw ni kx b ky kz ju la lb lc jx ld nj lf lg lh nk lj lk ll nl ln lo lp lq im bi translated">SignalR是微软ASP.NET的免费开源软件库，允许服务器代码向客户端web应用程序发送异步通知。ASP.NET核心信号是一个开源库，它简化了向应用程序添加实时网络功能。实时web功能使服务器端代码能够将内容即时推送到客户端。</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nm"><img src="../Images/ef72acb8776056fc591a5e5b0d0fdd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RL6TbrF6vyo9isH4SArEow.png"/></div></div></figure><p id="8505" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">SignalR可用于:</p><ul class=""><li id="a76d" class="nn no it kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated">需要频繁更新用户界面的应用，如游戏、仪表盘和监控应用</li><li id="77bd" class="nn no it kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated">白板等协作应用</li><li id="79ff" class="nn no it kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated">需要通知的应用程序。社交网络、电子邮件、聊天、游戏、旅行提醒和许多其他应用程序都使用通知</li></ul><p id="aa77" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">ASP.NET核心can的信号装置:</p><ul class=""><li id="27d2" class="nn no it kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated">自动管理连接</li><li id="73dd" class="nn no it kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated">同时向所有连接的客户端发送消息</li><li id="461d" class="nn no it kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated">向特定客户端或客户端组发送消息</li><li id="2261" class="nn no it kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated">扩展以处理不断增长的流量</li></ul><p id="8ee5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你可以在微软的网站上了解更多关于SignalR的信息</p><div class="ob oc gp gr od oe"><a href="https://dotnet.microsoft.com/apps/aspnet/signalr" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">使用SignalR |的实时ASP.NET。网</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">你可以自己托管SignalR应用，或者使用Azure SignalR服务作为完全托管的平台。Azure SignalR服务…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">dotnet.microsoft.com</p></div></div><div class="on l"><div class="oo l op oq or on os kt oe"/></div></div></a></div></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8640" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">让我们看看代码</h1><h2 id="4b5e" class="ot mo it bd mp ou ov dn mt ow ox dp mx le oy oz mz li pa pb nb lm pc pd nd pe bi translated">服务器端</h2><p id="c279" class="pw-post-body-paragraph kv kw it kx b ky pf ju la lb pg jx ld le ph lg lh li pi lk ll lm pj lo lp lq im bi translated">在服务器端，我有一个简单的<code class="fe pk pl pm pn b">ClientHub</code>类，它继承自SignalR的基本Hub类。SignalR使用<code class="fe pk pl pm pn b">hubs</code>在客户端和服务器之间进行通信。集线器是一个高级管道，它允许客户端和服务器相互调用方法。SignalR自动处理跨机器边界的分派，允许客户端调用服务器上的方法，反之亦然。集线器通过发送包含客户端方法的名称和参数的消息来调用客户端代码。作为方法参数发送的对象使用配置的协议进行反序列化。客户端尝试将该名称与客户端代码中的方法进行匹配。当客户端找到匹配项时，它调用方法并传递反序列化的参数数据。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="4046" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在<code class="fe pk pl pm pn b">ClientHub</code>类中，我有<code class="fe pk pl pm pn b">SendMessage</code>方法和基类中被覆盖的几个方法。被调用的<code class="fe pk pl pm pn b">SendMessage</code>方法将向所有连接的客户端发送消息，传递的是数据。我还有一个静态类<code class="fe pk pl pm pn b">ConnectedClients</code>和一个静态属性<code class="fe pk pl pm pn b">ConnectedClientIds</code>。当新客户端加入时，它们的id会被添加到<code class="fe pk pl pm pn b">ConnectedClientIds</code>列表中，当客户端断开连接时，它们的id会从列表中删除。这是为了让我可以跟踪连接的客户端，并使用他们的id来更新他们在应用程序中的光标位置。</p><p id="ab59" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当新用户访问网站时，<code class="fe pk pl pm pn b">OnConnectedAsync</code>方法被调用，<code class="fe pk pl pm pn b">UserConnected</code>和<code class="fe pk pl pm pn b">LoadAllConnectedUsers</code>消息被发送到所有连接的客户端。类似地，当一个客户端断开连接时，<code class="fe pk pl pm pn b">userDisconnected</code>消息被发送到所有客户端，之后用户的光标元素被从客户端移除。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4dbb" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">客户端</h1><p id="e2e8" class="pw-post-body-paragraph kv kw it kx b ky pf ju la lb pg jx ld le ph lg lh li pi lk ll lm pj lo lp lq im bi translated">在客户端，我有一个标准的razor文件，包含基本的HTML和c#代码。在组件被初始化之后，一个新的<code class="fe pk pl pm pn b">HubConnection</code>被创建，并且客户机被连接到服务器。还设置了由服务器发布的特定类型消息的监听器，如<code class="fe pk pl pm pn b">ReceiveMessage</code>、<code class="fe pk pl pm pn b">UserConnected</code>、<code class="fe pk pl pm pn b">UserDisconnected</code>和<code class="fe pk pl pm pn b">LoadAllConnectedUsers</code>。在<code class="fe pk pl pm pn b">index.html</code>页面上，我们定义了JavaScript函数，当客户端收到不同类型的消息时将调用这些函数。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="edf7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe pk pl pm pn b">hubConnection.On</code>扩展方法注册一个处理程序，当调用指定名称的hub方法时，该处理程序将被调用。一旦接收到特定的消息，就会执行相应的处理程序代码。当客户端收到<code class="fe pk pl pm pn b">UserConnected</code>或<code class="fe pk pl pm pn b">UserDisconnected</code>消息时，处理程序将调用定义在窗口对象上的JavaScript函数<code class="fe pk pl pm pn b">nextjs.onUserConnected</code>或<code class="fe pk pl pm pn b">nextjs.onUserDisconnected</code>。一旦开始连接到服务器，就会调用<code class="fe pk pl pm pn b">nextjs.addMouseEventListener</code>函数来注册<code class="fe pk pl pm pn b">mousemove</code>事件监听器。</p><p id="a39d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe pk pl pm pn b">nextjs.addMouseEventListener</code>在<code class="fe pk pl pm pn b">mousemove</code>事件上设置一个事件监听器。当这个事件发生时，它捕获用户光标的<code class="fe pk pl pm pn b">clientX </code>和<code class="fe pk pl pm pn b"> clientY</code>值，最后调用传入数据的<code class="fe pk pl pm pn b">c#</code> <code class="fe pk pl pm pn b">CaptureMouseEvents</code>方法。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="fcf8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe pk pl pm pn b">CaptureMouseEvents</code>方法将传入的数据反序列化为一个<code class="fe pk pl pm pn b">Cursor</code>记录类型，然后调用func，func调用<code class="fe pk pl pm pn b">SendMouseEvents</code>,从这里使用指定的名称和参数调用服务器上的hub方法。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="7ea4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe pk pl pm pn b">SendMessage</code>方法是在我们的<code class="fe pk pl pm pn b">ClientHub</code>中定义的，它向所有连接的客户端发送消息，并传入<code class="fe pk pl pm pn b">connectionId</code>、<code class="fe pk pl pm pn b">x</code>和<code class="fe pk pl pm pn b">y</code>值。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="8c13" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当客户端收到这个消息时，它调用传入数据的<code class="fe pk pl pm pn b">updateCursor</code> JS函数来更新连接的用户的光标位置。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="2ce7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe pk pl pm pn b">updateCursor</code>方法简单地获取id等于<code class="fe pk pl pm pn b">connectionId</code>的光标元素，并通过应用转换来更新元素</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="877d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是该应用程序在多个客户端(浏览器窗口)中运行的短片。当在新窗口中打开页面时，将建立从客户端到SignalR hub的新连接。所有连接的客户端都会收到此消息，新的光标元素会添加到DOM中。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pq pp l"/></div></figure><p id="1ed7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你可以通过下面的链接查看这个网站</p><div class="ob oc gp gr od oe"><a href="https://nextjsconf-server.azurewebsites.net/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">NextJS会议信号演示</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">使用blazor和SignalR的实时用户交互</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">nextjsconf-server.azurewebsites.net</p></div></div><div class="on l"><div class="pr l op oq or on os kt oe"/></div></div></a></div></div></div>    
</body>
</html>