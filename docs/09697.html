<html>
<head>
<title>7 Tricky Questions to Ask .NET Developer in a Job Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要问的7个棘手问题。NET开发人员在工作面试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-tricky-questions-to-ask-net-developer-in-a-job-interview-9cdb3789db54?source=collection_archive---------1-----------------------#2021-09-05">https://levelup.gitconnected.com/7-tricky-questions-to-ask-net-developer-in-a-job-interview-9cdb3789db54?source=collection_archive---------1-----------------------#2021-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带着答案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b673a00eef6a8d8a51b7d7d18ed332b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4g79soZNd602fpj2"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@vantaymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Van Tay Media </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="903f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些希望扩展面试问题列表的面试官，或者那些希望在下一次面试前变得更加自信的受访者，或者所有人。NET开发人员希望学习新的东西，我准备了一些有趣的问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f89f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.单例对象可以依赖于限定了作用域的/每请求的对象吗？</h1><p id="8d0e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">或者，这个问题可以换成“下面这段代码能工作吗？”：</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="69ea" class="ne md it na b gy nf ng l nh ni">public class Controller<br/>{<br/>    public Controller(UserService userService) { }<br/>}</span><span id="dc3a" class="ne md it na b gy nj ng l nh ni">public class UserService<br/>{<br/>    public UserService(IUserRepository userRepository) { }<br/>}</span><span id="1b9a" class="ne md it na b gy nj ng l nh ni">public class UserRepository : IUserRepository<br/>{<br/>}</span><span id="76bd" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">//DI registration:<br/></strong>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddSingleton&lt;UserService&gt;();<br/>    services.AddScoped&lt;IUserRepository, UserRepository&gt;();<br/>}</span></pre><p id="490d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码可以编译，但是开发人员会在运行时得到依赖注入容器抛出的异常。</p><p id="11b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码示例演示了名为<a class="ae ky" href="https://blog.ploeh.dk/2014/06/02/captive-dependency/" rel="noopener ugc nofollow" target="_blank">受控依赖</a>的问题。当较高级别的服务<code class="fe nk nl nm na b">(UserService)</code>比依赖的较低级别的服务<code class="fe nk nl nm na b">(IUserRepository).</code>具有更长的生存期时，问题就出现了</p><p id="e158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以解决这个问题。第一种方法是重新配置对象的生存期，以便更高级别的服务总是具有与其依赖项相同或更短的生存期。例如，<code class="fe nk nl nm na b">UserService</code>和<code class="fe nk nl nm na b">UserRepository</code>都可以有一个限定范围的(每个请求)生存期。或者<code class="fe nk nl nm na b">UserService</code>可以具有短暂的生存期，而<code class="fe nk nl nm na b">UserRepository</code>具有限定范围的生存期。</p><p id="2406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在大型代码库中简单地更改对象的生存期范围有时会很困难，因为这会对整个应用程序的行为产生不良影响。</p><p id="3a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在不改变生存期范围的情况下解决生存期较短的依赖项的一个有效方法是使用<code class="fe nk nl nm na b">IServiceScopeFactory.</code></p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c958" class="ne md it na b gy nf ng l nh ni">public class UserService<br/>{<br/>    private readonly IServiceScopeFactory _scopeFactory;</span><span id="c046" class="ne md it na b gy nj ng l nh ni">    public UserService(IServiceScopeFactory scopeFactory) =&gt;   <br/>        _scopeFactory = scopeFactory;</span><span id="a2fa" class="ne md it na b gy nj ng l nh ni">    public void DoSomething()<br/>    {<br/>        using (var scope = _scopeFactory.CreateScope())<br/>        {<br/>            <strong class="na iu">//Resolving scoped dependency</strong><br/>            var userRepository = scope.<br/>                    ServiceProvider.   <br/>                    GetRequiredService&lt;IUserRepository&gt;();</span><span id="02e7" class="ne md it na b gy nj ng l nh ni">        //Use repository instance<br/>        }<br/>    }<br/>}</span></pre><p id="80e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔔<a class="ae ky" href="https://esashamathews.medium.com/subscribe" rel="noopener"> <strong class="lb iu">现在就订阅</strong> </a> <strong class="lb iu">，所以大家不要错过我接下来的文章。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2dd6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.让DbContext成为web应用程序中的单例是个好主意吗？</h1><p id="cbcb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">实体框架核心中的<code class="fe nk nl nm na b">DbContext</code>类负责与数据库交互。因为通常一个服务器实例与一个数据库实例通信，所以为DI容器中的<code class="fe nk nl nm na b">DbContext</code>选择一个单独的生存期范围似乎是一个好主意。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5191" class="ne md it na b gy nf ng l nh ni">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddSingleton&lt;DbContext&gt;();<br/>}</span></pre><p id="e906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现不是线程安全的。实体框架核心将检测同一个<code class="fe nk nl nm na b">DbContext</code>是否被多个线程访问，并抛出一个异常。让<code class="fe nk nl nm na b">DbContext</code>成为单例将需要大量的线程同步逻辑。但是添加同步逻辑会降低web应用程序中并行用户请求的执行速度。</p><p id="e9ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">DbContext</code>在单线程应用中可以是singleton。对于默认情况下多线程的web应用程序，作用域或每请求生存期是<code class="fe nk nl nm na b">DbContext</code>类的一个好选择。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e54" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.如何实现一个可以创建任何对象的深层副本的方法？</h1><p id="4ca0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">C#开发人员可以使用<code class="fe nk nl nm na b">MemberwiseClone</code>方法来创建对象的浅层副本。但是，创建深层副本通常需要一些自定义实现。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fb4b" class="ne md it na b gy nf ng l nh ni">public T CreateDeepCopy&lt;T&gt;(T original)<br/>{<br/>    <strong class="na iu">//Implementation?</strong><br/>}</span></pre><p id="4c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至少有办法实现一个方法，可以创建任意对象的深度副本并返回给调用者:<strong class="lb iu">序列化</strong>和<strong class="lb iu">反射</strong>。</p><p id="6a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果选择序列化方法，您将需要使用二进制、JSON或其他类型的序列化在内存中序列化输入对象。然后，您需要将流反序列化回对象。这个反序列化的对象将是原始对象的深层副本。</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-clone-an-object-in-c-d1374ec28efa"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">在C#中克隆对象的5种方法</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">各有利弊</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><p id="0ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用反射创建对象的深层副本将比序列化有更复杂的实现。然而，使用反射，您不需要用<code class="fe nk nl nm na b">[Serializable]</code>属性标记域类，也不需要用序列化提供者需要的其他东西污染它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3d34" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.字符串的不变性有什么利弊？</h1><p id="e382" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">任何修改字符串的尝试都会导致创建该字符串的新实例。这种行为被称为不变性。每个人都知道不可变性会导致性能问题，因为频繁修改字符串会导致大量的冗余分配。</p><p id="aeb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好处呢？最根本的优势是副作用是不可能的。</p><ul class=""><li id="d091" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">字符串是线程安全的。每个试图修改字符串实例的线程都会得到它的一个副本。不需要同步对字符串的访问、创建临界区等等。</li><li id="a4d7" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">字符串滞留机制是一种内存优化，如果字符串是可变的数据类型，这种机制将不起作用。</li></ul><p id="18a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，使用字符串或其他不可变类型的代码更容易阅读。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9ba6" class="ne md it na b gy nf ng l nh ni">string message = "Hello";<br/>DoSomethingWithMessage(message);<br/>Console.Write(message);</span></pre><p id="6deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在阅读这样的代码时，开发人员不需要分析<code class="fe nk nl nm na b">DoSomethingWithMessage</code>方法的实现细节来发现<code class="fe nk nl nm na b">message</code>是否不同于“Hello”或no。</p><p id="accc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不可变数据类型减少了开发人员阅读代码的时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="50a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.如何用两行代码实现Singleton模式？</h1><p id="1beb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">C#开发人员可以用多种方式实现单例模式。最短的实现如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fcc7" class="ne md it na b gy nf ng l nh ni">public class Singleton<br/>{<br/>    private Singleton() { }    <br/>    public static readonly Singleton Instance = new Singleton();<br/>}</span></pre><p id="9ed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">new Singleton()</code>保证在应用程序的生命周期中只执行一次，因为编译器把它放在一个静态构造函数中。此外，静态构造函数在默认情况下是线程安全的。</p><p id="32a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在我的另一篇文章中找到实现单例模式的其他方法，这些方法各有利弊:</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">在C#中实现单例设计反模式的5种方法</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">各有利弊</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="ot l ob oc od nz oe ks nq"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="991e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.如何实现自定义HashSet <t>数据结构？</t></h1><p id="3682" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个问题可以考验开发者的数据结构知识，以及用C#代码实现的能力。</p><p id="cef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">HashSet&lt;T&gt;</code>收藏由提供。NET基类库存储唯一的项。搜索(包含)、插入或删除等操作以常数时间O(1)执行。</p><p id="861c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何实现自己的散列集数据结构，该结构将表现为现有的<code class="fe nk nl nm na b">HashSet&lt;T&gt;</code>实现？</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a93d" class="ne md it na b gy nf ng l nh ni">public class CustomHastSet&lt;T&gt;<br/>{<br/>    public bool Add(T item)<br/>    { <br/>        <strong class="na iu">//Implementation?</strong><br/>    }</span><span id="d037" class="ne md it na b gy nj ng l nh ni">    public bool Contains(T item)<br/>    {<br/>        <strong class="na iu">//Implementation?</strong><br/>    }<br/>}</span></pre><p id="e5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义散列集数据结构可以作为<code class="fe nk nl nm na b">Dictionary&lt;TKey, TValue&gt;</code>数据结构的包装器来实现，它必须将值的散列代码存储为字典键，并将值本身存储为字典值。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f217" class="ne md it na b gy nf ng l nh ni">public class CustomHastSet&lt;T&gt;<br/>{<br/>    private readonly Dictionary&lt;int, T&gt; _items = <br/>           new Dictionary&lt;int, T&gt;()</span><span id="80bf" class="ne md it na b gy nj ng l nh ni">    public bool Add(T item)<br/>    {<br/>        var hashCode = item.GetHashCode();</span><span id="1704" class="ne md it na b gy nj ng l nh ni">        if (!_items.ContainsKey(hashCode))<br/>        {<br/>            _items.Add(hashCode, item);<br/>            return true;<br/>        }</span><span id="f2f6" class="ne md it na b gy nj ng l nh ni">        return false;<br/>    }</span><span id="2a47" class="ne md it na b gy nj ng l nh ni">    public bool Contains(T item)<br/>    {<br/>        var hashCode = item.GetHashCode();<br/>        bool contains = _items.ContainsKey(hashCode);<br/>        return contains;<br/>    }</span><span id="83c8" class="ne md it na b gy nj ng l nh ni">    <strong class="na iu">//Other methods</strong><br/>}</span></pre><p id="b012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ou">该实施不包括两个不同值可能具有相同散列码的情况。你如何支持这一点？</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="52d0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.可以在lock语句中包装异步代码吗？</h1><p id="209e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nk nl nm na b">lock</code>关键字用于创建一个只有一个线程可以进入的临界区。</p><p id="5cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时有必要为异步代码创建一个临界区，以避免潜在的并发问题。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c082" class="ne md it na b gy nf ng l nh ni">private static object _lock = new object();</span><span id="c5ca" class="ne md it na b gy nj ng l nh ni">public async Task DoAsync()<br/>{<br/>    <!-- -->lock (<!-- -->_lock<!-- -->)<br/>    {<br/>        await Task.Delay(1);<br/>    }<br/>}</span></pre><p id="e655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，上面的代码甚至无法编译，因为编译器不允许在<code class="fe nk nl nm na b">lock</code>语句体中使用<code class="fe nk nl nm na b">await</code>关键字。这样做是为了<a class="ae ky" href="https://stackoverflow.com/questions/7612602/why-cant-i-use-the-await-operator-within-the-body-of-a-lock-statement/7612714#7612714" rel="noopener ugc nofollow" target="_blank">防止死锁问题</a>。</p><p id="3ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为异步代码创建临界区的一个可行解决方案是使用其他同步原语，如<code class="fe nk nl nm na b">SemaphoreSlim</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1966" class="ne md it na b gy nf ng l nh ni">private static SemaphoreSlim _lock = new SemaphoreSlim(1,1);</span><span id="34ce" class="ne md it na b gy nj ng l nh ni">public async Task DoAsync()<br/>{<br/>    <!-- -->await _lock.WaitAsync();</span><span id="12bc" class="ne md it na b gy nj ng l nh ni">    try<br/>    {<br/>        await Task.Delay(1);<br/>    }<br/>    finally<br/>    {<br/>        _lock.Release();<br/>    }<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="491c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面试愉快！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="40a5" class="ne md it bd me ov ow dn mi ox oy dp mm li oz pa mo lm pb pc mq lq pd pe ms pf bi translated">我的其他文章</h2><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="pg l ob oc od nz oe ks nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/5-github-repositories-for-net-developers-to-take-tech-skills-to-the-next-level-84f244f6257b"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">5 GitHub。净回购，让你的技术技能更上一层楼</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">亲身体验GitHub资源库。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="ph l ob oc od nz oe ks nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-create-an-object-in-c-and-when-to-choose-which-one-4aabea5c3e40"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">用C#创建对象的5种方法以及何时选择哪一种</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">当创建一个对象时，像建筑师一样思考。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="pi l ob oc od nz oe ks nq"/></div></div></a></div></div></div>    
</body>
</html>