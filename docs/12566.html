<html>
<head>
<title>Java algorithms: Merge Intervals (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java算法:合并间隔(LeetCode)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-algorithms-merge-intervals-leetcode-24a3277cfa28?source=collection_archive---------0-----------------------#2022-06-20">https://levelup.gitconnected.com/java-algorithms-merge-intervals-leetcode-24a3277cfa28?source=collection_archive---------0-----------------------#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/627b19e254c63c55e0f21ab5e9fe0d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tNFAnLTX2nK1B732.jpg"/></div></div></figure><h2 id="a089" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">任务描述:</h2><p id="b079" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">给定一个数组<code class="fe lp lq lr ls b">intervals</code>，其中<code class="fe lp lq lr ls b">intervals[i] = [start_i, end_i]</code>，合并所有重叠区间，并返回<em class="lt">一个非重叠区间数组，覆盖输入</em>中的所有区间。</p><p id="5227" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated"><strong class="kw ir">例1: </strong></p><pre class="lz ma mb mc gt md ls me mf aw mg bi"><span id="779e" class="jy jz iq ls b gy mh mi l mj mk"><strong class="ls ir">Input:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]<br/><strong class="ls ir">Output:</strong> [[1,6],[8,10],[15,18]]<br/><strong class="ls ir">Explanation:</strong> Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</span></pre><p id="b9d4" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated"><strong class="kw ir">例2: </strong></p><pre class="lz ma mb mc gt md ls me mf aw mg bi"><span id="7d0d" class="jy jz iq ls b gy mh mi l mj mk"><strong class="ls ir">Input:</strong> intervals = [[1,4],[4,5]]<br/><strong class="ls ir">Output:</strong> [[1,5]]<br/><strong class="ls ir">Explanation:</strong> Intervals [1,4] and [4,5] are considered overlapping.</span></pre><p id="a10c" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated"><strong class="kw ir">约束:</strong></p><ul class=""><li id="8ad5" class="ml mm iq kw b kx lu lb lv kh mn kl mo kp mp lo mq mr ms mt bi translated"><code class="fe lp lq lr ls b">1 &lt;= intervals.length &lt;= 10^4</code></li><li id="6012" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated"><code class="fe lp lq lr ls b">intervals[i].length == 2</code></li><li id="7c2b" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo mq mr ms mt bi translated"><code class="fe lp lq lr ls b">0 &lt;= starti &lt;= endi &lt;= 10^4</code></li></ul><h2 id="1ad3" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">推理:</h2><p id="fcfd" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">让我们试着做一些自然的事情。让我们从第一个例子中画出间隔。这将帮助我们了解问题的本质，并决定采取什么方法来解决这个问题。</p><p id="26fe" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">我们有这些区间[1，3]，[2，6]，[8，10]，[15，18]</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/f08a5381d0850a4857c6f7bf961edf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYmIWljKjLUpR3CqGjcTxA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">间隔</figcaption></figure><p id="3942" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">看着这张图表，我们可以得出两个重要的观察结果。</p><ol class=""><li id="2fa1" class="ml mm iq kw b kx lu lb lv kh mn kl mo kp mp lo ne mr ms mt bi translated">一旦我们画了线，我们就可以很容易地说出哪一条线彼此相交。</li><li id="a6c8" class="ml mm iq kw b kx mu lb mv kh mw kl mx kp my lo ne mr ms mt bi translated">一旦我们画线，它们就被分类了。</li></ol><p id="7359" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">记住这一点，我们就可以着手解决问题了</p><h2 id="7115" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">解决方案:</h2><p id="cdda" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我们要做的第一件事是对我们所有的区间进行排序，这样我们就可以把它们合并在一起，就像我们看上面的图表时在脑海中所做的那样。排序很简单，我们先按区间的起点排序，再按区间的终点排序。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="55b4" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">一旦区间被排序，我们就可以开始合并它们。看上面的图表，我们可以做出重要的观察——交叉区间有一些重叠，或者它们从另一个区间的结束位置开始。我们将使用LinkedList，因为它提供了getLast()方法。我们也可以使用ArrayList，通过调用list.get(list.size() — 1)来获取最后一个元素。对于每个区间，我们检查是否与前一个区间有交集。如果我们有一个intesection，我们只需将它们合并在一起，并放回列表中。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1de7" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">最后要做的就是创造答案。我们这样做是因为我们一开始不知道有多少元素是不相交的。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d86f" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">所以任务的解决方案看起来像这样</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f8ef" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">上面的代码给了我们很好的结果。它具有n log n的时间和线性空间复杂度。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/30bcc1357ab43da6224b43cebe537f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*STOP0mc90S8Idm5WIJlNFw.png"/></div></figure></div></div>    
</body>
</html>