<html>
<head>
<title>How to Override CSS in a Shadow Dom/Web Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在影子Dom/Web组件中覆盖CSS</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-override-css-in-a-shadow-dom-web-component-38ee2ad79cce?source=collection_archive---------2-----------------------#2020-09-01">https://levelup.gitconnected.com/how-to-override-css-in-a-shadow-dom-web-component-38ee2ad79cce?source=collection_archive---------2-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7ee2d8d6686d20ce1f2c3c2694f2e061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKJ7yU2ySTXK98PQOmh-rQ.png"/></div></div></figure><p id="2ddd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Web组件的一个主要目的是提供封装——能够保持标记结构和样式隐藏，并与页面上的其他代码分开，以便不同部分不会冲突；这样，代码可以保持整洁。</p><p id="9b8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Shadow DOM为我们提供了作用域样式封装，并提供了一种让外界尽可能多(或尽可能少)进入的方法。</p><blockquote class="kz"><p id="f6e3" class="la lb it bd lc ld le lf lg lh li ky dk translated">但是，如果我想让我的组件可以针对某些样式属性进行定制，该怎么办呢？</p></blockquote><p id="e966" class="pw-post-body-paragraph kb kc it kd b ke lj kg kh ki lk kk kl km ll ko kp kq lm ks kt ku ln kw kx ky im bi translated">本文涵盖了使用CSS自定义属性穿透影子DOM并让您的web组件可自定义的基础知识。</p><h1 id="e116" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">创建HTML元素</h1><p id="f049" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我们将使用JavaScript类创建自定义HTML元素，该类扩展了基本HTML element。然后我们将使用我们想要创建的标签名和我们刚刚创建的类来调用<code class="fe mr ms mt mu b">customElements.define()</code>。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c099" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们将创建这个简单的材料设计卡。当我们在HTML: <code class="fe mr ms mt mu b">&lt;app-card&gt;&lt;/app-card&gt;</code>中添加这个元素时，它就会显示出来</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/36d91c760dceb93bfba049d3c0f6e89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_UpPjYawnRByBwEeMZoK6Q.png"/></div></div></figure><p id="6194" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们创建影子DOM根，然后我们将HTML和CSS字符串分配给影子DOM根innerHTML，如下所示。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="68f6" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">覆盖尝试</h1><p id="30ec" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在这个例子中，我们想要修改卡片的背景颜色。如果它是HTML中的一个简单的<code class="fe mr ms mt mu b">div</code>元素，你可以覆盖<code class="fe mr ms mt mu b">card</code>类或者通过CSS选择器来访问<code class="fe mr ms mt mu b">div</code>元素。但是下面的尝试是行不通的:</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="0055" class="ng lp it mu b gy nh ni l nj nk">// access the div <br/>app-card &gt; div {<br/>  background-color: #2196F3;<br/>}</span><span id="c1b8" class="ng lp it mu b gy nl ni l nj nk">// override card class<br/>app-card &gt; .card {<br/>  background-color: #2196F3;<br/>}</span></pre><h1 id="3140" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用CSS自定义属性</h1><p id="ded4" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">为了解决这个问题，我们可以使用<a class="ae nm" href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*" rel="noopener ugc nofollow" target="_blank"> CSS自定义属性</a> (CSS变量)。可以使用CSS中定义的CSS自定义属性来更改自定义元素中的一些CSS属性。</p><p id="5063" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按照我们的例子，我们将使用属性<code class="fe mr ms mt mu b">background-color</code>上的变量<code class="fe mr ms mt mu b">card-bg</code>来获取由使用定制元素的用户定义的颜色。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="327f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们将使用<code class="fe mr ms mt mu b">app-card</code>定制元素，并在Body元素的CSS中创建<code class="fe mr ms mt mu b">card-bg</code>变量。我们将把十六进制颜色<code class="fe mr ms mt mu b">#2196F3</code>分配给变量。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/34320f21d6da1f1e2bb32e462efb2b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imPtFns2coNcRF9cT9AF1Q.png"/></div></div></figure><h1 id="72a1" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="f79b" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">使用这种策略，我们可以在你的文档中包含一个封装的CSS元素，同时我们可以使用CSS定制一些属性。您可以点击查看<a class="ae nm" href="https://codepen.io/cesarwbr/pen/abNyEPe" rel="noopener ugc nofollow" target="_blank">完整示例。</a></p></div></div>    
</body>
</html>