<html>
<head>
<title>Implementing Threading in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中实现线程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-threading-in-python-3e2e0858ad07?source=collection_archive---------6-----------------------#2020-08-10">https://levelup.gitconnected.com/implementing-threading-in-python-3e2e0858ad07?source=collection_archive---------6-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e7e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python实现线程的快速简单指南</h2></div><p id="fc78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，你将学到</p><ul class=""><li id="fec5" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">线程的基本概念</li><li id="06a7" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用线程库实现线程</li><li id="77ab" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用ThreadPoolExecutor实现线程</li><li id="2fb7" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用线程的利与弊</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/6e160878a4feaca098b87e7825996017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*wJzB-HofEjvRaFlJR5dZwA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">尼科·纳泽尔在<a class="ae me" href="https://unsplash.com/s/photos/thread?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3b12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个线程是:</p><ul class=""><li id="5f97" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">程序中要执行的最小独立命令集</li><li id="1a9a" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">应用程序中的多个线程可以在一个CPU上同时执行，这被称为多线程</li><li id="b28d" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">总是在程序中运行，不能独立运行</li><li id="c04c" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">当程序受限于网络或有大量I/O操作时使用</li><li id="ee8f" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">内存在一个进程中的多个线程之间共享，因此具有较低的资源消耗</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/1a6596301ab92ecb94b5c0112f1f38c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*lxUPRupqxS2iWAEODn73KQ.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">一个进程中的多个线程共享内存</figcaption></figure><p id="7cac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多线程的一个简单例子是从互联网下载多个文件。</p><p id="1bc9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想要下载100个文件。我们可以等待一个文件下载，然后开始下载下一个文件，或者创建多个线程并允许它们下载文件。当一个线程等待连接建立时，另一个线程可以下载另一个文件的数据，从而提供更快的执行速度和更好的系统利用率。</p><p id="22a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="mg">我们将以从网上下载文件为例，演示Python中线程的实现。</em> </strong></p><h2 id="66f6" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">使用线程库实现线程</h2><p id="651c" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">您想从互联网上下载文件，所以您编写了一个简单的python脚本，如下所示。</p><p id="727f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将从<a class="ae me" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>传递一些图像URL，使用请求库下载文件，并将其保存到当前目录。</p><pre class="lt lu lv lw gt nf ng nh ni aw nj bi"><span id="a819" class="mh mi it ng b gy nk nl l nm nn">file_list=["<a class="ae me" href="https://unsplash.com/photos/agzJY5jrsAw/download?force=True" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/agzJY5jrsAw/download?force=True</a>",<br/>"<a class="ae me" href="https://unsplash.com/photos/4rDCa5hBlCs/download?force=True" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/4rDCa5hBlCs/download?force=True</a>",<br/>"<a class="ae me" href="https://unsplash.com/photos/jFCViYFYcus/download?force=True" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/jFCViYFYcus/download?force=True</a>",<br/>"<a class="ae me" href="https://unsplash.com/photos/Y8lCoTRgHPE/download?force=True" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/Y8lCoTRgHPE/download?force=True</a>",<br/>"<a class="ae me" href="https://unsplash.com/photos/4KrQq8Z6Y5c/download?force=True" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/4KrQq8Z6Y5c/download?force=True</a>"]</span><span id="108b" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">import requests<br/>from datetime import datetime</strong></span><span id="b953" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">def download_file(file):<br/>    file_1=file.split('/')[4]<br/>    r = requests.get(file, allow_redirects=True)    <br/>    open(file_1, 'wb').write(r.content)<br/>    return True</strong></span><span id="9b67" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">start_time= datetime.now()<br/>for i in range(len(file_list)):<br/>    result= download_file(file_list[i])<br/>end_time= datetime.now()<br/>exec_time= end_time-start_time</strong></span><span id="d09d" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">print(f"Total execution time for the function {exec_time}")</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4116f45a3435d96ef6f83b8d51c4612a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*eQhruTVBwtRmSO3e-C23TA.png"/></div></figure><p id="3547" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用线程，看看我们是否可以减少执行时间。</p><p id="eb4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将线程库添加到导入列表中。</p><pre class="lt lu lv lw gt nf ng nh ni aw nj bi"><span id="1b98" class="mh mi it ng b gy nk nl l nm nn"><strong class="ng iu">import threading</strong><br/><strong class="ng iu">import requests<br/>from datetime import datetime</strong></span></pre><p id="25c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">download_file函数保持不变。</p><pre class="lt lu lv lw gt nf ng nh ni aw nj bi"><span id="c299" class="mh mi it ng b gy nk nl l nm nn"><strong class="ng iu">def download_file(file):<br/>    file_1=file.split('/')[4]<br/>    print(file_1)<br/>    r = requests.get(file, allow_redirects=True)    <br/>    open(file_1, 'wb').write(r.content)<br/>    return True</strong></span></pre><p id="d21f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建一个线程实例，将你要在单线程上执行的函数作为<em class="mg">目标</em>传递，函数的参数作为<em class="mg"> args </em>传递。</strong></p><p id="4cd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过<strong class="kk iu"><em class="mg">download _ file()</em></strong>对<strong class="kk iu"> <em class="mg">目标</em> </strong>和<strong class="kk iu"> <em class="mg"> file_list </em> </strong>中的每一项作为<strong class="kk iu"> <em class="mg">自变量</em> </strong>进行函数。</p><p id="6669" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> t1.start()启动线程执行。</strong></p><p id="e5a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们追加所有线程，然后在遍历所有文件并下载它们之后加入它们。</p><p id="ab49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Join()应该放在主线程中。Join阻塞调用线程或主线程，直到被加入的线程的执行也终止。</strong></p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/bdfde96ded4dea4a54c1988d5e1881d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OB1D50RaD2_M0O6H30RU3w.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><strong class="bd mj"> join()阻塞主线程，直到线程1和2的执行终止</strong></figcaption></figure><h2 id="ba88" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">With join()</h2><pre class="lt lu lv lw gt nf ng nh ni aw nj bi"><span id="5f34" class="mh mi it ng b gy nk nl l nm nn"><strong class="ng iu">def download_file(file):<br/>    file_1=file.split('/')[4]<br/>    #print(file_1)<br/>    r = requests.get(file, allow_redirects=True)    <br/>    open(file_1, 'wb').write(r.content)<br/>    print(f'Download complete for file {file}')</strong><br/>threads=[]<br/>start_time=datetime.now()<br/><strong class="ng iu">for i in range(len(file_list)):<br/>    t1= threading.Thread(target=download_file, args=[file_list[i]])<br/>    t1.start()<br/>    threads.append(t1)</strong></span><span id="8020" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">for thread in threads:<br/>    thread.join()</strong><br/> <br/><strong class="ng iu">end_time=datetime.now()<br/>exec_time= end_time-start_time<br/>print(f"Total execution time for the function {exec_time}")</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nv"><img src="../Images/7c46fbfb3bdcb3374402f03db1fc9421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_GUX_9FhGJgn0OFDZypKQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">带有join()的输出</figcaption></figure><h2 id="f15a" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">不带联接()</h2><p id="9b79" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们现在移除join()方法来理解join()的影响</p><pre class="lt lu lv lw gt nf ng nh ni aw nj bi"><span id="53ca" class="mh mi it ng b gy nk nl l nm nn"><strong class="ng iu">def download_file(file):<br/>    file_1=file.split('/')[4]<br/>    r = requests.get(file, allow_redirects=True)    <br/>    open(file_1, 'wb').write(r.content)<br/>    print(f'Download complete for file {file}')</strong></span><span id="5587" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">start_time=datetime.now()<br/>for i in range(len(file_list)):<br/>    <br/>    t1= threading.Thread(target=download_file, args=[file_list[i]])<br/>    t1.start()   <br/> <br/>end_time=datetime.now()<br/>exec_time= end_time-start_time<br/>print(f"Total execution time for the function {exec_time}")</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nw"><img src="../Images/6aec3d38117b9bd4e783dde844c0ee38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDlIyDR8vSEpvBOWjobQJg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">没有连接的输出()</figcaption></figure><p id="d53a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">join()上的结论</strong></p><ul class=""><li id="9c9a" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">当我们使用join()时，主线程被阻塞，直到下载文件的线程完成。</li><li id="e609" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">当我们不使用join()时，主线程的执行甚至在下载文件的线程完成之前就完成了。</li></ul><h2 id="563b" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">ThreadPoolExecutor</h2><p id="106e" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">ThreadPoolExector是一种使用<code class="fe nx ny nz ng b"><a class="ae me" href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">concurrent.futures</strong></a><strong class="kk iu">.</strong></code>实现和产生多个线程的简单方法</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6dd860aaf3ed90c82fbc9304796c1b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*-U2O6zmthGvFzQRUyAnF0g.png"/></div></figure><p id="4a83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> concurrent.futures有一个抽象类Executor，它有两个具体的子类</strong></p><ul class=""><li id="0f85" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu"> ThreadPoolExecutor:用于多线程</strong></li><li id="684c" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu"> ProcessPoolExecutor:用于多重处理</strong></li></ul><h2 id="6785" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">使用ThreadPoolExecutor实现相同的下载文件</h2><p id="9a61" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们导入<strong class="kk iu"> concurrent.futures </strong>并创建一个<strong class="kk iu"> ThreadPoolExecutor()的实例。</strong></p><p id="8e99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<strong class="kk iu"/><strong class="kk iu"><em class="mg">映射</em> () </strong>来应用<strong class="kk iu"><em class="mg">download _ file()</em></strong>并迭代<strong class="kk iu"> <em class="mg"> file_list </em> </strong>中的每个URL。</p><pre class="lt lu lv lw gt nf ng nh ni aw nj bi"><span id="a6d9" class="mh mi it ng b gy nk nl l nm nn"><strong class="ng iu">import concurrent.futures<br/>def download_file(file):<br/>    file_1=file.split('/')[4]<br/>    r = requests.get(file, allow_redirects=True)    <br/>    open(file_1, 'wb').write(r.content)<br/>    return f'Download complete for file {file} using ThreadPoolExecutor'<br/>start_time=datetime.now()</strong></span><span id="8c92" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">with concurrent.futures.ThreadPoolExecutor() as executor:<br/>   results= executor.map(download_file, file_list)</strong></span><span id="0405" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">for result in results:<br/>    print(result)<br/>    <br/>end_time=datetime.now()<br/>exec_time= end_time-start_time</strong></span><span id="0a35" class="mh mi it ng b gy no nl l nm nn"><strong class="ng iu">print(f"Total execution time for the function {exec_time}")</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ob"><img src="../Images/579a8e26b6144a5d12ab589e763cc4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fXzceH2BSCFnIy2rpwc4g.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用ThreadPoolExecutor的输出</figcaption></figure><h2 id="1f40" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">使用线程的利与弊</h2><p id="805a" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated"><strong class="kk iu">使用线程的优点</strong></p><ul class=""><li id="12ed" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">为I/O或网络绑定程序提供更快的执行速度<strong class="kk iu"/></li><li id="f135" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">一个进程中的所有线程将<strong class="kk iu">共享内存，</strong> <strong class="kk iu">让程序响应更快。</strong></li><li id="abc5" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">线程间共享内存也使得<strong class="kk iu">上下文切换更加容易和快速。</strong></li></ul><p id="f51a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用穿线的缺点</strong></p><ul class=""><li id="b717" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">线程不应用于计算密集型程序</strong>。对CPU密集型程序使用多处理。</li><li id="075e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">线程化增加了程序的复杂性，</strong>从而使调试变得困难。</li><li id="e4d8" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">即使进程中的一个线程挂起，也会导致整个进程崩溃。</li><li id="83d9" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">开销与管理线程相关联。</li></ul><h2 id="747f" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">结论:</h2><p id="d611" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">对于Python中的I/O或网络密集型程序，使用多线程使用Threading class或ThreadPoolExecutor。对于CPU密集型进程，使用ProcessPoolExecutor进行多处理。</p><h2 id="f725" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">参考资料:</h2><p id="1452" class="pw-post-body-paragraph ki kj it kk b kl na ju kn ko nb jx kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated"><a class="ae me" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/concurrent.futures.html</a></p></div></div>    
</body>
</html>