<html>
<head>
<title>Effective Debugging with .NET Core &amp; Docker Compose (Launch Compose Stack on Debug Start in VS Code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效的调试。NET Core &amp; Docker Compose(在VS代码中调试开始时启动Compose堆栈)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/effective-debugging-with-net-2ed70167de58?source=collection_archive---------8-----------------------#2021-10-11">https://levelup.gitconnected.com/effective-debugging-with-net-2ed70167de58?source=collection_archive---------8-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bdcbbd00ab97b1b34d07e78bdc5eb003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3-8xNYnXhthoucclFJfeg.png"/></div></div></figure><p id="fdb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我今天处理的大多数项目都有某种外部依赖。这可能是一个数据库、一个云提供商，或者只是我需要与之交流的另一个API。为了开发我的代码，我很少不通过网络与某些东西交流。能够有效地开发和调试那些外部依赖是清洁软件的关键，但也可以大大加快你的努力。这就是Docker和Docker Compose的用武之地。通过使用Compose，您可以轻松地创建这些依赖项的模拟版本，并随时运行它们。通过使用Compose，我们可以加速开发工作并产生更好的代码。</p><p id="269f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本帖中，我们将看看最常见的场景之一，在本地运行数据库进行测试。然而，我们将通过在. NET中将撰写启动与调试会话的启动联系起来来实现这一点。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9fc6" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">设置</h1><p id="3e2e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">这个项目的回购非常简单。NET核心Web API，它简单地返回我们数据库中的用户。这篇文章的目的不是构建一个REST API，所以我们将保持它的超级简单。下面是项目结构的样子:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/39cb7c867780d2287501fa6910fdffe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*zyCQIXw0kVvHCs6fHo9alA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">演示代码项目结构和文件</figcaption></figure><p id="854c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们快速分解一下:</p><ul class=""><li id="e18f" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><strong class="kd iu">控制器</strong>包含一个具有一个<code class="fe nc nd ne nf b">Get</code>端点的单个<code class="fe nc nd ne nf b">UsersController</code>。对于这个演示，它所做的只是从数据库中返回第一个用户。</li><li id="c4ce" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated"><strong class="kd iu">数据</strong>包含我们的<code class="fe nc nd ne nf b">DbContext</code>和一个用于与我们的数据库交互的<code class="fe nc nd ne nf b">Users</code>模型。</li><li id="9df0" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated"><strong class="kd iu"> Fixtures </strong>包含了所有的<code class="fe nc nd ne nf b">.sql</code>文件，这些文件创建了一个模式并用数据播种数据库中的<code class="fe nc nd ne nf b">Users</code>表。</li></ul><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/cc684cb6c0575c7da54a57e642f9482f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*vhsLmWMJdqHGdlhxMIlvOg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">创建数据库模式的SQL</figcaption></figure><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/efe2551fb68ebc462056c0cd8ab54156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*B-BxJFJb9jmpSXLFVvmXBA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">用数据植入用户表的SQL</figcaption></figure><ul class=""><li id="e047" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">其余文件是标准的。NET和Docker文件，所以我们不会对它们进行太深入的讨论。</li></ul><p id="97b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们看一下<code class="fe nc nd ne nf b">docker-compose.yml</code>文件，它将加速我们的API所需的依赖关系，在本例中是一个PostgreSQL数据库:</p><pre class="ml mm mn mo gt nn nf no np aw nq bi"><span id="9ccd" class="nr lh it nf b gy ns nt l nu nv">version: "3.7"</span><span id="b702" class="nr lh it nf b gy nw nt l nu nv">services:<br/>  database:<br/>    container_name: api_postgres<br/>    image: postgres:11.6-alpine<br/>    environment:<br/>      POSTGRES_DB: api_postgres<br/>    volumes:<br/>      - ./Fixtures/sql/:/docker-entrypoint-initdb.d/<br/>    ports:<br/>      - "5432:5432"</span><span id="564b" class="nr lh it nf b gy nw nt l nu nv">  dozzle:<br/>    container_name: api_dozzle<br/>    image: amir20/dozzle:latest<br/>    volumes:<br/>      - /var/run/docker.sock:/var/run/docker.sock<br/>    ports:<br/>      - "8888:8080"</span></pre><p id="891b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">坚持“保持简单”的趋势，这个文件中没有太多内容。我们构建了两个容器，PostreSQL数据库和一个Dozzle容器。如果你不熟悉Dozzle，<a class="ae mj" href="https://github.com/amir20/dozzle" rel="noopener ugc nofollow" target="_blank">去这里看看</a>。我不能说足够多的好话，但我们不会在这里覆盖它。</p><p id="745b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于PostgreSQL容器，我们只需拉一个11.6 Alpine版本，将我们的SQL文件从<code class="fe nc nd ne nf b">Fixtures</code>文件夹挂载到<code class="fe nc nd ne nf b">docker-entrypoint-initdb.b</code>文件夹，然后就可以了。此时，我们可以运行一个<code class="fe nc nd ne nf b">docker-compose up</code>来让我们的数据库运行起来:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/2af9215772debddc480b4cdc55de86b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wL8Nl_jg-Q8suEqKTfOuXA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Dozzle日志查看器显示我们的Postgres容器正在运行</figcaption></figure><p id="b6a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以开始调试我们的应用程序，并确认它连接到我们的数据库并返回数据:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/6bb75776fb438fcd2078ec329adad472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2hf1t8UcB-wbsnA_5bTww.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">邮递员调用我们的用户控制器，返回数据库中的第一个用户</figcaption></figure><p id="e7e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">老实说，我们可以就此打住！我们有一个组合文件来加速我们的依赖关系，我们可以开始调试并很好地访问我们的数据库。老实说，这种设置绝对没有任何问题:</p><ul class=""><li id="2660" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">用您的依赖项创建一个<code class="fe nc nd ne nf b">docker-compose.yml</code>文件。</li><li id="13f1" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated">当你准备好调试的时候，运行一个<code class="fe nc nd ne nf b">docker-compose up</code>命令。</li><li id="288a" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated">开始调试。</li></ul><p id="9563" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我一直都在用这个设置，非常棒！但是，有几个方面我们可以改进:</p><ul class=""><li id="e8a4" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">每次我想调试时都必须手动启动Compose堆栈，或者让它在我开发的整个过程中一直运行，这感觉不太好。</li><li id="f438" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated">有时我会忘记运行<code class="fe nc nd ne nf b">docker-compose down</code>来拆除堆栈，几个小时后回来时会发现堆栈仍在运行。</li></ul><p id="4dcd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以做得更好，现在我们来看看如何自动化这一切。</p><h1 id="4c36" class="lg lh it bd li lj nz ll lm ln oa lp lq lr ob lt lu lv oc lx ly lz od mb mc md bi translated">将所有东西绑定到调试器</h1><p id="868b" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我真正想要的是以下内容:</p><ul class=""><li id="0dae" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">当我启动调试器时，自动启动我的合成堆栈。</li><li id="ba12" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated">当我退出调试器时，自动拆除我的合成堆栈。</li></ul><p id="46f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实证明，在您的项目中使用<code class="fe nc nd ne nf b">launch.json</code>和<code class="fe nc nd ne nf b">tasks.json</code>文件，这些事情非常容易。当您在VS代码中启动一个调试会话时，这两个文件驱动了让您的会话运行的所有步骤。让我们来看看这个项目中的<code class="fe nc nd ne nf b">launch.json</code>文件:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/82d418d6c2aee932a16b5a9573d0aaab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1Td-B4uvuafhkA5wQ7KDQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">launch.json文件</figcaption></figure><p id="8c3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你以前曾经打开过这个文件，所有这些应该看起来很熟悉。事实上，这个文件几乎是样板代码而不是为我创建的代码，只有几处改动:</p><ul class=""><li id="4d52" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><code class="fe nc nd ne nf b">name</code>(第8行):此已更新为”。NET Core Compose”，以清楚地表明我们将使用Compose文件进行调试。这个名称显示在调试器面板中，因为您可以有多个调试配置，所以您想很容易地看到您将要启动哪个。</li></ul><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e3bd7997bd783ffcdc36d746c7467ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*XIFKcXA4FTgBUvsxL9kN7w.png"/></div></figure><ul class=""><li id="7b61" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><code class="fe nc nd ne nf b">preLaunchTask</code>(第11行):这是在<code class="fe nc nd ne nf b">tasks.json</code>文件中定义的一个新任务，它将负责启动调试会话。</li><li id="d9f8" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated"><code class="fe nc nd ne nf b">postLaunchTask</code>(第12行):<code class="fe nc nd ne nf b">tasks.json</code>文件中定义的新任务，将在调试器停止时运行。</li><li id="ec5e" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated"><code class="fe nc nd ne nf b">env:CONNECTION_STRING</code>(第23行):这是到Postgres数据库的连接字符串，并指向localhost，因为我们从Compose文件本地运行容器。</li></ul><p id="4311" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文件中的其他内容都是样板文件，可能就是您在最初的<code class="fe nc nd ne nf b">launch.json</code>文件中看到的内容。现在，我们来看一下推动这种配置的任务。</p><p id="f5e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将按相反的顺序来看这些:</p><ul class=""><li id="32d5" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><code class="fe nc nd ne nf b">down</code>负责拆缀栈。如果你记得从<code class="fe nc nd ne nf b">launch.json</code>文件中，它被配置为<code class="fe nc nd ne nf b">postLaunchTask</code>，并将在调试器停止时自动拆除堆栈。这是一项非常方便的任务，可以确保所有东西都被清理干净。我们通过<code class="fe nc nd ne nf b">-f</code>标志来告诉Compose我们的文件在哪里，因为<code class="fe nc nd ne nf b">tasks.json</code>通常位于项目的根目录，我将我的API嵌套在一个子目录中。</li></ul><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/0aa4beb3ddc0376f98ec4b142194d32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5P6SoCoh1Xld-OO_fnXYg.png"/></div></div></figure><ul class=""><li id="2638" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><code class="fe nc nd ne nf b">up</code>负责为我们启动撰写堆栈。类似地，在<code class="fe nc nd ne nf b">down</code>任务中，我们传递<code class="fe nc nd ne nf b">-f</code>标志来告诉Compose我们的文件在哪里。还要注意我们传入了<code class="fe nc nd ne nf b">-d</code>标志。这是分离模式标志，它将在后台运行容器。如果您不将此标志传入，Compose将会阻塞，调试器将永远不会启动，这一点非常关键！</li></ul><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/1f590799d35c1933de0e8c5edd580058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBl86AJqzpYIaa9p3Hh6TQ.png"/></div></div></figure><ul class=""><li id="8b5f" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><code class="fe nc nd ne nf b">compose-debug</code>是所有魔法发生的任务。这是在我们的<code class="fe nc nd ne nf b">launch.json</code>文件中配置为<code class="fe nc nd ne nf b">preLaunchTask</code>的任务，并且将是我们启动调试器时调用的任务。其中大部分是样板代码，您可以从VS代码中获得基本的调试任务，但是包含了两个关键元素！</li></ul><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f3466365c14595968073728932a68bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*8MtQDNCYQzGVqEPV_G2gtg.png"/></div></figure><p id="eac8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nc nd ne nf b">dependsOrder</code>使用<code class="fe nc nd ne nf b">dependsOn</code>属性，这里我们使用<code class="fe nc nd ne nf b">sequence</code>值。这告诉任务，我们希望按照列出的顺序运行在<code class="fe nc nd ne nf b">dependsOn</code>属性中定义的任务。在我们的例子中，我们希望在启动调试器之前，首先运行<code class="fe nc nd ne nf b">down</code>任务，然后运行<code class="fe nc nd ne nf b">up</code>任务！这允许我们执行以下操作:</p><ul class=""><li id="e01a" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">杀死任何因任何原因仍在运行的合成堆栈。这只是一个有用的检查，将确保<code class="fe nc nd ne nf b">up</code>命令可以正常运行。</li><li id="4d68" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated">启动新的合成堆栈。</li><li id="e1a5" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated">启动调试器会话。</li></ul><p id="4a72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们不必担心在调试之前运行Compose，它会自动为我们完成！</p><h1 id="97d3" class="lg lh it bd li lj nz ll lm ln oa lp lq lr ob lt lu lv oc lx ly lz od mb mc md bi translated"><strong class="ak">收尾</strong></h1><p id="4a9d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">如果您没有使用Docker Compose来帮助您的本地开发，现在就开始使用它吧！即使你没有实现这篇文章中展示的技巧，它也会节省你大量的时间。自从完成这些任务后，我发现我的开发经历变得更加顺畅，我真的很喜欢它。我承认这并不能节省你大量的时间，但是让所有这些事情自动开始，然后自己清理也是很好的。深入挖掘<code class="fe nc nd ne nf b">launch.json</code>和<code class="fe nc nd ne nf b">tasks.json</code>的文件和生命周期也很有趣。我绝对可以看到这在未来的各种事情中派上用场！</p><h2 id="6c68" class="nr lh it bd li oi oj dn lm ok ol dp lq km om on lu kq oo op ly ku oq or mc os bi translated">参考</h2><ul class=""><li id="e1f8" class="mt mu it kd b ke me ki mf km ot kq ou ku ov ky my mz na nb bi translated">GitHub Repo:<a class="ae mj" href="https://github.com/atkinsonbg/dotnet-debug-and-launch-compose" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/atkinsonbg/dot net-debug-and-launch-compose</a></li><li id="c4fc" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated">Docker撰写参考:<a class="ae mj" href="https://docs.docker.com/compose/reference/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/compose/reference/</a></li><li id="06b6" class="mt mu it kd b ke ng ki nh km ni kq nj ku nk ky my mz na nb bi translated">VS代码任务:<a class="ae mj" href="https://code.visualstudio.com/docs/editor/tasks" rel="noopener ugc nofollow" target="_blank">https://code.visualstudio.com/docs/editor/tasks</a></li></ul></div></div>    
</body>
</html>