<html>
<head>
<title>What a Redis migration taught us about burstable EC2 instances</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis迁移教会了我们如何处理突发EC2实例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-a-redis-migration-taught-us-about-burstable-ec2-instances-508990b002b3?source=collection_archive---------5-----------------------#2020-03-31">https://levelup.gitconnected.com/what-a-redis-migration-taught-us-about-burstable-ec2-instances-508990b002b3?source=collection_archive---------5-----------------------#2020-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="beef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">由我们的工程师西蒙·怀杜格</em>自豪地写下的</strong></p><p id="43fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在DPG媒体公司，我们开发各种软件来支持、发展和数字化我们的媒体足迹。其中一个产品是<a class="ae km" href="https://vtm.be/vtmgo" rel="noopener ugc nofollow" target="_blank"> VTM GO </a>，这是我们的流媒体解决方案，可以让你观看我们的视频内容直播和点播。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/e2caa0b83b41c532a39b9792175c3afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSWvbI0F5K5pQmhWCP0Frw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">标识Redis</figcaption></figure><p id="02b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让VTM继续前进的支柱是我们的长格式视频平台(简称LFVP)。这个主干的一部分是所有VTM GO客户端使用的后端API。这个后端API有一个致命弱点:Redis，一个内存中的键值数据库。就像阿基里斯一样，雷迪斯也是一个英雄！</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="253d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">雷迪斯</h1><p id="e20b" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">这位特别的英雄有三重目的(1):</p><ul class=""><li id="a0e0" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">首先，它是一个持久的数据库。这个数据库是由从各种上游主要事实来源收到的事件构成的。</li><li id="3413" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">其次，它充当了一个通读/直写缓存，其中持久性并不是真正的关键，但是如果没有这个缓存，上游依赖性将会受到(太)严重的影响。</li><li id="7329" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">第三，当人们观看内容时，它可以作为视频播放的临时存储。只有在某人停止观看之后，他们的视频进展才被写入永久存储器。</li></ul><p id="e754" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，Redis是必不可少的、节省成本的骨干组件。但是如果那个致命弱点消失了…</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1969a35f969e0094ff6721ce4af022af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*i0JWz9MF2L64LlDmynUhwA.jpeg"/></div></figure><h1 id="5f06" class="lk ll iq bd lm ln nc lp lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh bi translated">AWS ElastiCache</h1><p id="6464" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">直到最近，我们还使用AWS ElastiCache来托管Redis主实例和副本实例。然而，Redis故障转移和升级场景从未真正为我们带来ElastiCache。AWS没有使用几乎所有流行的Redis客户端库都支持的Redis Sentinel，而是决定采用一种不同的方法。他们在幕后实现了自己的故障转移机制。发生故障转移时，它们会发布主端点和副本端点的新DNS记录。非常简单，但是没有适当的客户端支持(2)，非常无用。</p><p id="af3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们决定离开ElastiCache，在EC2上自己主持一个Redis Sentinel设置。这将使我们受益于久经考验的莴苣客户端库哨兵支持。DPG媒体的另一项工程工作是我们的投票系统，我们在“好声音”和“比利时达人”等节目中使用该系统进行现场投票。已经在那里建立并使用了一个相当类似的Redis Sentinel设置，我们觉得继续这样做很舒服。</p><h1 id="67a1" class="lk ll iq bd lm ln nc lp lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh bi translated">迁移到EC2</h1><p id="91ef" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">我们的ElastiCache设置运行在cache.m5.large实例上。我们不妨也重新评估一下这个选择，对吧？让我们看一些指标，看看哪种EC2实例能够满足我们的使用。这是典型的VTM围棋使用模式:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nh"><img src="../Images/6e543b5029bc3d98f89798d1bd6de403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMLL2jcrZ0vGVg542VVofQ.png"/></div></div></figure><p id="6fc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用量在一天中慢慢增加，在晚餐时间下降，然后通常在22小时左右达到峰值，除非有计划的行动号召。这反映在Redis引擎的CPU使用率中:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nh"><img src="../Images/decaecfbee49efa85a07a287948604db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6Y58rgHyNqgonjWUFIYzQ.png"/></div></div></figure><p id="63ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis主服务器的使用率略高于副本服务器。总而言之，我们似乎只使用了CPU内核的10%多一点。让我们看看Redis实例的内存使用情况:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ni"><img src="../Images/80bbe029ba04a710ec15beacad4a5ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NYmL229WY9A503KLv9_KA.png"/></div></div></figure><p id="9b1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们目前的内存使用量是400MiB左右，没有那么多。我们确实存储了一些相当大的物体，其大小可达几百KiB。某些Redis查询可能导致高达几个MiB的响应。让我们来看看网络的使用情况:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nj"><img src="../Images/a71303d71d7ecb8e89d9cf79ada1729e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymbiOS8wxH7WV31q9OUOuA.png"/></div></div></figure><p id="e200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">典型的网络总使用率约为20 MB/s (160 Mbit/s)，峰值约为50MB/s (400 Mbit/s)。现在我们有了数据，让我们选择一个实例类型。关于CPU和内存，t3a.small实例已经足够了:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/4f0479dec7774180b55837bea6c32d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*oNCrRiQeYtdx3BpOElA1pQ.png"/></div></figure><p id="9652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">评估带宽有点棘手。在很多情况下，AWS只公布最大突发速率，但没有提供你可以预期的持续带宽的数据。正如AWS自己建议的那样，做出明智决策的唯一真正方法是进行基准测试(3)。一个快速的iperf基准测试之后，它似乎是t3a。小实例只能支持大约122 Mbit/s的持续带宽，低于所需的160 Mbit/s。但是，t3a.medium实例可以支持大约255 Mbit/s，这就足够了。所有实例都成功地突发高达5Gbps。所以做出了选择，还是来个t3a.medium吧。</p><p id="4fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在设置好一切并执行彻底的迁移测试之后，是时候进行生产迁移了。Redis数据库转储来自ElastiCache集群，并恢复到Redis Sentinel集群。然后，我们部署了一个新的代码库，切换到新的Redis Sentinel端点。随后执行上游事件重放，以恢复在此窗口期间丢失的任何重要写入。看，切换:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/abed07e0e1b94d4662ca388c0f129b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*fm0vtt8-vKxQaWGxx0dg5g.png"/></div></figure><p id="8b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面是旧的ElastiCache实例。下面是新的自托管Redis Sentinel实例</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e53ac14af2c0e981003ff71bde8d7aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*dTWTwoSLUF5slntvFDFEMA.png"/></div></figure><p id="fc35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，完成了，让我们打包回家吧！嘿，等等，那边的度量标准是什么？</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nn"><img src="../Images/b0bbc0989b953495eb2ee8822f47d05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21ZZIK7Nl3EWkXUI3kRlRQ.png"/></div></div></figure><h1 id="708e" class="lk ll iq bd lm ln nc lp lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh bi translated">排除故障</h1><p id="5956" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">上面的指标是99.9%的延迟，这看起来有点寒酸，因为迁移已经完成。大多数请求仍然以相当可观的延迟得到处理，但是对于少数请求，延迟似乎变得更加令人不安。但是这些机器应该能承受这种负荷，不是吗？这些机器甚至没有浪费CPU信用，因为它们几乎一直低于20% CPU使用率的突发基线。也许我们应该看看CPU窃取指标:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi no"><img src="../Images/5fa5b61d10c1428abfee54a1c7852bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5wPCcma_tbW15Atu7JreA.png"/></div></div></figure><p id="4392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，那也很紧张。等等，什么叫CPU偷来着？atop手册页(4)是这样定义CPU偷取时间的:</p><p id="2378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于虚拟机，将显示窃取百分比(“steal”)，反映在相同硬件上运行的其他虚拟机窃取的CPU时间的百分比。</p><p id="8e54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是可突发EC2机器的情况，比如t3和t3a类型。基本上，它们更便宜，因为AWS在同一个硬件虚拟机管理程序上打包了比c5等其他类更多的组件。这使得他们尽管价格较低，但仍能从中获利。与内存(5)不同，CPU是一种可扩展的资源，这意味着您可以在更多的机器上扩展这种资源，并且当物理CPU被完全使用时，它们不会全部崩溃。它们可能更慢，性能更不可预测，但是它们不会因此而死(不像当你的机器内存耗尽，Linux OOM杀手来毁了你的生活)。“吵闹的邻居”(其他需要大量CPU的虚拟机)越多，CPU占用率就越高。请注意，如果您在没有“无限制”模式(7)的情况下运行突发实例，高CPU占用率也可能表明您已经耗尽了CPU信用。注意度量。</p><p id="0f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实验有时是解决问题的最快方法，所以让我们把这些讨厌的机器升级到c5.large，看看会发生什么。这些是99.9%的延迟指标:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi np"><img src="../Images/3ccad6563d9655ca09f78c29115c0842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwRQTmIGuU6Kj-sC60CkOQ.png"/></div></div></figure><p id="7c31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我猜你能认出升级是什么时候完成的。偷CPU的事怎么样了？</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nq"><img src="../Images/707749a800ebc9e685c9f22b47a24f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKzBUbP2y6B8jJxTNrpv1g.png"/></div></div></figure><p id="bd34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，这是我见过的最明显的关联。迁移完成！</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b46c0761f4f2cdf745457e1344e470a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*XswjoBV80ooB0cklQjaPUg.gif"/></div></figure><h1 id="e77a" class="lk ll iq bd lm ln nc lp lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh bi translated">让我们结束它</h1><p id="0f98" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">结论:</p><ul class=""><li id="56cf" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">CPU、内存和带宽是选择正确实例类型的关键，但是您还必须考虑其他因素。尤其是延迟敏感型应用程序，Redis就是其中之一，可能会受到过度调配的虚拟机管理程序容量的严重影响。</li><li id="06f5" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">这并不意味着可爆发的实例没有用。你还得运行的那个FTP服务器？当然，为什么不呢？对于轻量级应用，它们是完美的。延迟不是真正问题的批处理工作负载，它们可能也很适合。永远记住要逐案评估。</li><li id="5cff" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">当你处理吵闹的邻居时，你总是可以尝试停止你的实例，然后重新启动它。这将在不同的虚拟机管理程序上启动您的虚拟机，并且您可能会摆脱那些烦人的邻居(一段时间)。如果CPU占用率达到某个阈值，您甚至可以设置一个警报。</li><li id="f2b0" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">具体到Redis延迟调试，有一些有用的信息和很好的工具:</li></ul><p id="53b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://redis.io/topics/latency" rel="noopener ugc nofollow" target="_blank">https://redis.io/topics/latency</a><br/>T3】https://redis.io/topics/latency-monitor</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="f020" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(1)将单个Redis集群混合用于持久存储和缓存的目的可能会被认为是一种反模式。这是一个架构遗产，超出了本文的范围。</p><p id="82c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(2)生菜问题:<a class="ae km" href="https://github.com/lettuce-io/lettuce-core/issues/338#issuecomment-397618666" rel="noopener ugc nofollow" target="_blank">https://github . com/莴苣-io/莴苣-core/issues/338 # issue comment-397618666</a></p><p id="bd40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(3)<a class="ae km" href="https://aws.amazon.com/premiumsupport/knowledge-center/network-throughput-benchmark-linux-ec2/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/premium support/knowledge-center/network-throughput-benchmark-Linux-ec2/</a></p><p id="e98b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">④https://linux.die.net/man/1/atop<a class="ae km" href="https://linux.die.net/man/1/atop" rel="noopener ugc nofollow" target="_blank"/></p><p id="2b53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(5)虽然不完全正确:<a class="ae km" href="https://en.wikipedia.org/wiki/Memory_overcommitment" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Memory_overcommitment</a></p><p id="3a98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(6)<a class="ae km" href="https://linux-mm.org/OOM_Killer" rel="noopener ugc nofollow" target="_blank">https://linux-mm.org/OOM_Killer</a></p><p id="02a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(7)<a class="ae km" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/AWS C2/latest/user guide/burst able-performance-instances-unlimited-mode . html</a></p></div></div>    
</body>
</html>