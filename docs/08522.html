<html>
<head>
<title>Practical Understanding of FLP Impossibility for Distributed Consensus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式共识的FLP不可能性的实践理解</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-understanding-of-flp-impossibility-for-distributed-consensus-8886e73cdfe5?source=collection_archive---------4-----------------------#2021-05-09">https://levelup.gitconnected.com/practical-understanding-of-flp-impossibility-for-distributed-consensus-8886e73cdfe5?source=collection_archive---------4-----------------------#2021-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="89e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">尽管存在FLP定理，分布式一致性算法(如Raft)在现实世界中是如何实现的？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/428d194efe3550cca6b011a4c7b25c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ObDdJ6rettKdDLdR"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@guilhermevt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">古伊列梅·特谢拉</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="dac7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> F </span> LP ( <strong class="ky ir"> F </strong> ischer，<strong class="ky ir"> L </strong> ynch，<strong class="ky ir"> P </strong> aterson)不可能性是分布式系统中最基本的结果之一，在很多计算类本科课程中都有讲授。考虑到数据和计算的规模，分布式系统(用更多的机器来扩展服务)本质上是今天用来构建可扩展系统基础设施的默认模式。分布式共识变得至关重要，因为机器需要就一致的状态达成一致，以提供一致的服务。</p><p id="d7e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">FLP定理回答了以下关于共识的基本问题:</p><p id="f5c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mb">在异步分布式系统中，是否存在一个确定性的一致性算法，能够满足一致性、有效性、终止性和容错性？</em></p><p id="f072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如定理中的“不可能”一词所暗示的那样，Fisher、Lynch和Paterson已经证明，实现容许甚至单个节点故障的一致算法是不可能的。</p><p id="a7e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鉴于Raft和Zookeeper等现有共识算法目前普遍用于大型分布式系统，在这些系统中，节点故障不仅常见，而且预计会发生，因此FLP结果可能违反直觉，甚至令人困惑。当我了解Raft时，我也面临着理论上的FLP结果和现实世界的共识算法之间的脱节。写这篇文章我希望能阐明</p><ul class=""><li id="e3ec" class="mc md iq ky b kz la lc ld lf me lj mf ln mg lr mh mi mj mk bi translated"><strong class="ky ir">FLP定理</strong>在现实世界系统中的实际应用前景。</li><li id="1597" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr mh mi mj mk bi translated">业界公认的共识算法(如Raft)如何克服FLP不可能性结果。</li></ul></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="bf82" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">分布式共识的同义问题</h1><p id="dc58" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">那么我们为什么要关注分布式共识问题呢？在分布式系统中，不同的机器(节点)通常需要保持某种形式的状态一致。事实上，分布式共识有多种形式— <strong class="ky ir">在分布式系统中，面对这些共识的变体之一是不可避免的</strong>。已经证明与共识同义的问题的例子有:</p><ol class=""><li id="a8c1" class="mc md iq ky b kz la lc ld lf me lj mf ln mg lr nu mi mj mk bi translated">领导者选举(用于选举节点成为领导者/主节点，例如在Raft中)</li><li id="f8b2" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr nu mi mj mk bi translated">共享日志(在复制日志系统中)</li><li id="7abc" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr nu mi mj mk bi translated">原子广播(例如，在主/辅助复制中，主节点将向辅助节点广播操作)</li></ol><p id="0b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解有关主/辅助复制的更多信息，请访问:</p><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/deep-dive-into-primary-secondary-replication-for-fault-tolerance-6ba203b06901"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">深入研究主/辅助复制以实现容错</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">你真的了解复制是如何工作的吗？</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><h1 id="f434" class="mx my iq bd mz na on nc nd ne oo ng nh jw op jx nj jz oq ka nl kc or kd nn no bi translated">理解FLP不可能定理</h1><p id="25f5" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">在我们从实际的角度重新定义FLP定理之前，我们必须首先理解不可能性定理的主张以及该定理的背景。</p><h2 id="836f" class="os my iq bd mz ot ou dn nd ov ow dp nh lf ox oy nj lj oz pa nl ln pb pc nn pd bi translated">异步网络模型</h2><p id="5632" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">FLP不可能性定理最基本的前提是异步网络模型。异步模型的特征是什么？它与同步模型有什么不同？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/56dd9d00860416c3cc03522ba86d3904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WruxCKFMJYxJihxxqwe2nA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在异步网络模型下，我们没有准确的节点故障检测。</figcaption></figure><p id="1e0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在异步模型中，从一个节点到另一个节点的消息传播延迟是有限的，但没有限制。这意味着，如果一个节点没有收到消息，它就不能准确判断发送方节点是崩溃了还是消息被延迟了。换句话说，我们不能根据超时机制准确地确定一个节点是否崩溃。相反，在同步网络模型中，消息延迟是有限的，并且可以可靠地检测到节点崩溃。</p><p id="19b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在异步网络设置下，FLP定理还假设I)消息通道不会丢弃消息ii)非拜占庭故障(没有恶意方)。</p><h2 id="82b2" class="os my iq bd mz ot ou dn nd ov ow dp nh lf ox oy nj lj oz pa nl ln pb pc nn pd bi translated">不可能三角</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/61a03cd16295c36173326c5c026ba504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpruNi4VAg4-UvNm6FatMw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">FLP定理:在异步网络模型下，我们不能同时拥有这三个属性。</figcaption></figure><p id="8d7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在异步网络模型下，FLP定理声称我们不能实现终止性、一致性和容错性这三个属性。我们将这三个属性描述如下:</p><ol class=""><li id="a87b" class="mc md iq ky b kz la lc ld lf me lj mf ln mg lr nu mi mj mk bi translated">终止(活跃度):所有节点(没有失败)最终决定。</li><li id="1a64" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr nu mi mj mk bi translated">协议(安全):所有决定的节点(甚至是决定后失败的节点)应该决定相同的值。如果所有节点都有相同的初始输入，则该值应该是唯一可能的决策值。</li><li id="9809" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr nu mi mj mk bi translated">容错:所有节点都要求协议在节点故障的情况下也必须有效。</li></ol><p id="6905" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意，FLP定理并没有宣称:</strong></p><ul class=""><li id="934c" class="mc md iq ky b kz la lc ld lf me lj mf ln mg lr mh mi mj mk bi translated">分布式共识一般是不可能的。</li><li id="8786" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr mh mi mj mk bi translated">我们不能拥有上面列出的三个属性中的任何一个。事实上，Raft已经表明，我们可以同时拥有协议和容错，但不能终止。</li></ul><p id="9c2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">相反，FLP定理声称:</strong></p><ul class=""><li id="a272" class="mc md iq ky b kz la lc ld lf me lj mf ln mg lr mh mi mj mk bi translated">在异步网络模型下，我们不能同时拥有这三种属性。</li><li id="0d42" class="mc md iq ky b kz ml lc mm lf mn lj mo ln mp lr mh mi mj mk bi translated">特别是在同步网络模型下(其中消息延迟是有限的)，存在满足所有三个期望属性的算法。</li></ul><p id="60db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">言外之意:</strong>在现实世界中，我们可以<strong class="ky ir">做出牺牲(三个属性中的一个)或者放松约束(例如在异步模型上)</strong>提出一个符合业务需求的共识算法。我们将在下一节讨论现代共识算法如何做出这些权衡。</p><h1 id="0ada" class="mx my iq bd mz na on nc nd ne oo ng nh jw op jx nj jz oq ka nl kc or kd nn no bi translated">交叉检查现实世界系统中的约束</h1><p id="677c" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">既然我们已经理解了FLP定理的主张，我们终于可以把我们的实际镜头，并检查我们如何可以应用这些知识到现实世界的系统！在上一节中，我们已经看到，我们通常可以放松异步模型的约束。下表交叉分析了异步模型对现实世界分布式系统的约束。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/8ca55d955c14dc0e11dd3b5660073be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGwQlXGV5CVVJUTxI8eNxw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">现实世界的系统支持部分同步的网络模型，在这种模型中，可以通过超时机制非常可靠地检测到故障。</figcaption></figure><p id="84e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，在现实世界中，我们通常有一个更宽松的异步模型版本，可以通过超时机制充分检测到故障。因此，在这种部分同步网络模型中，预定超时充当用户可配置的消息延迟界限。</p><p id="d3c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在实践中，共识算法往往选择牺牲不可能性三角形的三个属性之一。在分布式系统中，节点故障几乎是不可避免的。因此，必须考虑容错。FLP不可能性意味着任何共识协议除了容错之外只能具有终止性或协议性。</p><p id="0449" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以Raft为例，牺牲终止性来实现容错和协议属性(理论上Raft的领袖选举有可能经历无限次分裂投票，从而永不终止)。为了减少协议没有终止从而没有进展的几率，Raft使用了随机选举超时。事实上，随机化算法是许多共识算法中的常见策略。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="2746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，我们已经看到，在实践中，我们可以放松FLP定理的约束，也可以牺牲协议或终止来实现满足我们业务需求的分布式共识。</p><p id="5a06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有兴趣了解更多关于大型分布式系统的知识，请查看我以前的一些帖子:</p><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/the-google-file-system-the-distributed-file-system-that-google-built-68463670ac57"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">Google文件系统:Google构建的分布式文件系统</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">从分布式文件系统中学到的经验是，像BigTable、MapReduce这样的Google应用程序都是建立在分布式文件系统之上的。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="pg l oj ok ol oh om kp ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/lessons-learnt-from-scaling-memcached-in-production-86778ab616c7"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">在生产中扩展Memcached的经验教训</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">为业务用例构建高可用性缓存解决方案的主要考虑事项和策略</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="ph l oj ok ol oh om kp ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/paper-summary-mapreduce-simplified-data-processing-on-large-clusters-58dac068462e"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">MapReduce:大型集群上的简化数据处理</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">从谷歌建立的分布式大规模计算管道中吸取的教训。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="pi l oj ok ol oh om kp ny"/></div></div></a></div><h1 id="5872" class="mx my iq bd mz na on nc nd ne oo ng nh jw op jx nj jz oq ka nl kc or kd nn no bi translated">参考</h1><p id="7503" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">[1]<a class="ae kv" href="http://www.cs.cornell.edu/courses/cs6410/2016fa/slides/18-distributed-systems-flp.pdf" rel="noopener ugc nofollow" target="_blank">http://www . cs . Cornell . edu/courses/cs 6410/2016 fa/slides/18-distributed-systems-FLP . pdf</a></p><p id="e76c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]<a class="ae kv" href="https://www.alibabacloud.com/blog/from-distributed-consensus-algorithms-to-the-blockchain-consensus-mechanism_595315" rel="noopener ugc nofollow" target="_blank">https://www . Alibaba cloud . com/blog/from-distributed-consensus-algorithms-to-the-区块链-consensus-mechanism_595315 </a></p><p id="9a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]<a class="ae kv" href="https://medium.com/pyrofex/on-flp-impossibility-c0280bb965da" rel="noopener">https://medium . com/pyro fex/on-FLP-不可能性-c0280bb965da </a></p></div></div>    
</body>
</html>