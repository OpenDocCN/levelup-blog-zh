<html>
<head>
<title>Explain Free Monad Like I am Five (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像我五岁一样解释自由单子(第二部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/explain-free-monad-like-i-am-five-part-2-691d77bec78?source=collection_archive---------13-----------------------#2020-09-21">https://levelup.gitconnected.com/explain-free-monad-like-i-am-five-part-2-691d77bec78?source=collection_archive---------13-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/663691c7ea1a9faa706a7490ec96bb4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TnHGFsXhxOaUsBUn"/></div></div></figure><p id="2383" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章的第一部分中，我们讨论了自由单子如何从函子构建单子。为此，您可以创建一个类似DSL的程序并生成另一个程序。您编写的程序变成了表示领域逻辑的普通数据结构。一旦你编写了程序，你就可以用解释器连接这些程序。您可以在dev和QA上切换不同的解释器。您还可以抽象出程序的实现，或者在不改变领域逻辑的情况下优化它们。</p><p id="ad42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先用这些代数创建一个Todo应用程序:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="67dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们创建了一个代数<code class="fe ld le lf lg b">FlatMap</code>和<code class="fe ld le lf lg b">Pure</code>，并介绍了如何通过将Todo代数包装到“自由”数据结构中来制作类似单子的程序:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="c8ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们通过创建<code class="fe ld le lf lg b">Action[A] =&gt; Free[Action, A]</code>的隐式转换，创建了一种将这些代数“提升”到“自由”单子的方法:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="12ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们用我们构建的“自由”代数连接程序和解释器。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="e53f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:这是“像我五岁一样解释自由单子(第一部分)”的简短回顾，我解释了我如何得出这些结论的思考过程。如果你有兴趣，在进一步阅读之前先看看。</p><div class="lh li gp gr lj lk"><a rel="noopener  ugc nofollow" target="_blank" href="/explain-free-monad-like-i-am-five-part-1-5bee794074bd"><div class="ll ab fo"><div class="lm ab ln cl cj lo"><h2 class="bd ir gy z fp lp fr fs lq fu fw ip bi translated">像我五岁一样解释自由单子(第1部分)</h2><div class="lr l"><h3 class="bd b gy z fp lp fr fs lq fu fw dk translated">以函数的方式用简单的数据结构构造复杂的程序。</h3></div><div class="ls l"><p class="bd b dl z fp lp fr fs lq fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly jw lk"/></div></div></a></div><h1 id="bcfa" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">问题</h1><p id="90db" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">上面的解决方案似乎可以使用免费的Monad为Todo应用程序构建一个程序。然而，该解决方案仅适用于该特定应用。我们不能使用我们的<code class="fe ld le lf lg b">runProgram</code>函数或将我们的代数“提升”到“自由”版本。如果我们需要为我们构建的每个程序实现<code class="fe ld le lf lg b">runProgram</code>,并且在每次构建新的代数集时创建一个隐式转换，这将是非常乏味的。</p><h1 id="e94b" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">广义升力</h1><p id="7b91" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">为了推广lift，我们只需要将<code class="fe ld le lf lg b">Action</code>抽象成一个<code class="fe ld le lf lg b">F[_]</code>类型的构造函数:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a2b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果我们这样做，将会导致编译错误，因为很多时候，我们希望提升具体的类型构造函数，而不是一般的“密封特征”:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="9ae5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在for-comprehension中抛出一个错误，因为它不能自动将值提升到<code class="fe ld le lf lg b">Action</code>密封特征。</p><p id="5048" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种方法是创建一个“智能构造器”，首先将值设置为一般代数<code class="fe ld le lf lg b">Action</code>，并定义将常规输入抽象为“自由”版本的函数。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="ad19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住“自由”类型的返回是由广义代数返回类型定义的。例如，<code class="fe ld le lf lg b">create</code>将返回一个<code class="fe ld le lf lg b">TodoAction[Todo]</code>，因为<code class="fe ld le lf lg b">Create</code>的代数返回一个<code class="fe ld le lf lg b">Action[Todo]</code>:</p><pre class="kx ky kz la gt nc lg nd ne aw nf bi"><span id="6db5" class="ng ma iq lg b gy nh ni l nj nk">case class Create(description: String) extends Action[Todo]</span></pre><p id="6c68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们可以用这些智能构造函数来构造我们的程序:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="eee7" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">一般化运行程序</h1><p id="8eba" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">引用自<a class="ae kw" href="https://edward-huang.com/functional-programming/scala/programming/monad/2020/09/06/explain-free-monad-like-i-am-five-part-1/" rel="noopener ugc nofollow" target="_blank">上一篇</a>文章中的<code class="fe ld le lf lg b">runProgram</code>:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="64f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当前运行程序有一个<code class="fe ld le lf lg b">execute</code>功能与带有<code class="fe ld le lf lg b">Action</code>的功能相关联。此外，<code class="fe ld le lf lg b">Free[Action,A]</code>仅限于特定的<code class="fe ld le lf lg b">Todo</code>应用。如何进一步推广这个来取<code class="fe ld le lf lg b">F[_]</code>的任何一个程序？</p><p id="e86c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过采用类型构造函数<code class="fe ld le lf lg b">F[_]</code>来一般化<code class="fe ld le lf lg b">runProgram</code>，但是我们如何一般化<code class="fe ld le lf lg b">execute</code>函数呢？</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="e5c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不知何故，<code class="fe ld le lf lg b">execute</code>函数应该是用户在创建程序时定义的通用函数。因此，需要将某个<code class="fe ld le lf lg b">trait</code>作为参数传入。如果仔细观察上面的实现，函数<code class="fe ld le lf lg b">execute(fa)</code>接受一个<code class="fe ld le lf lg b">F[A]</code>并返回一个<code class="fe ld le lf lg b">A</code>。然后，该<code class="fe ld le lf lg b">A</code>可以是<code class="fe ld le lf lg b">fn</code>功能的输入。因此，我们需要定义接受一个<code class="fe ld le lf lg b">F[A]</code>并返回一个<code class="fe ld le lf lg b">A</code>的<code class="fe ld le lf lg b">execute</code>函数。让我们在一个<code class="fe ld le lf lg b">Executor</code>特征中定义<code class="fe ld le lf lg b">execute</code>函数:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="bba4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将<code class="fe ld le lf lg b">Executor</code>特征类作为一个参数传入<code class="fe ld le lf lg b">runProgram</code>中，并在该<code class="fe ld le lf lg b">Executor</code>特征中调用<code class="fe ld le lf lg b">execute</code>:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="9f21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以在<code class="fe ld le lf lg b">Executor</code>、<code class="fe ld le lf lg b">execute</code>函数中为Todo应用程序定义解释器，并将值传递给<code class="fe ld le lf lg b">runProgram</code>:</p><pre class="kx ky kz la gt nc lg nd ne aw nf bi"><span id="7e51" class="ng ma iq lg b gy nh ni l nj nk">runProgram(program, executor)</span></pre><p id="47d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过提供解释我们的代数的自定义“execute ”,我们终于可以在任何程序上运行<code class="fe ld le lf lg b">Free[F,A]</code>。然而，我们能进一步推广这一点吗？</p><h1 id="1bed" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">一般化执行器</h1><p id="4165" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">当前的<code class="fe ld le lf lg b">Executor</code>函数接收一个<code class="fe ld le lf lg b">F[A]</code>并返回一个<code class="fe ld le lf lg b">A</code>。但是，该功能仅限于纯效果类型。我们可以通过推广它的效果类型来进一步推广它。如果你不确定effect是什么意思，看看我的文章<a class="ae kw" href="https://edward-huang.com/functional-programming/scala/monad/2020/06/21/what-is-effect-or-effectful-mean-in-functional-programming/" rel="noopener ugc nofollow" target="_blank">在函数式编程中“effect”或“effective”是什么意思？</a></p><p id="f9e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函子之间的这种变换叫做<a class="ae kw" href="https://typelevel.org/cats/datatypes/functionk.html" rel="noopener ugc nofollow" target="_blank">自然变换</a>。我们可以有<code class="fe ld le lf lg b">F[A] =&gt; G[A]</code>，而不是有一个等同于<code class="fe ld le lf lg b">F[A] =&gt; Id[A]</code>的<code class="fe ld le lf lg b">F[A] =&gt; A</code>签名，其中<code class="fe ld le lf lg b">G[_]</code>可以是任何类型的构造函数。</p><p id="8022" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们重构我们的<code class="fe ld le lf lg b">Executor</code>函数，加入两个类型构造函数:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="61ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，<code class="fe ld le lf lg b">runProgram</code>会带一个额外的类型构造函数<code class="fe ld le lf lg b">G[_]</code>:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d7d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您注意到上面的代码无法编译。最初，<code class="fe ld le lf lg b">execute</code>函数返回<code class="fe ld le lf lg b">A</code>。然而，在将我们的<code class="fe ld le lf lg b">Executor</code>函数改为返回<code class="fe ld le lf lg b">G[A]</code>后，我们不能将结果传递给<code class="fe ld le lf lg b">FlatMap</code>中的<code class="fe ld le lf lg b">f</code>函数。</p><p id="9364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过要求<code class="fe ld le lf lg b">G</code>为单子来解决这个问题，并使用<code class="fe ld le lf lg b">flatMap</code>将<code class="fe ld le lf lg b">G</code>中的值绑定到<code class="fe ld le lf lg b">f</code>:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="f346" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">结论</h1><p id="63ae" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">在本文中，我们将学习如何通过推广我们的“免费”包装器来进一步推广我们的应用程序，以便在各种应用程序中使用它。</p><p id="30aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们推广了<code class="fe ld le lf lg b">lift</code>函数，并引入了一个“智能构造器”来构造我们的程序。然后，我们通过提交一个<code class="fe ld le lf lg b">Executor</code>特征来概括我们的<code class="fe ld le lf lg b">runProgram</code>，即运行程序的解释器。最后，我们通过在我们的<code class="fe ld le lf lg b">Executor</code>特征上引入自然转换来进一步推广我们的<code class="fe ld le lf lg b">Executor</code>特征。</p><p id="ba7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自由结构以不同的名称存在于<code class="fe ld le lf lg b">Cats</code> <a class="ae kw" href="https://typelevel.org/cats/datatypes/freemonad.html" rel="noopener ugc nofollow" target="_blank">库</a>中。希望你能理解免费的概念以及免费是如何运作的。也有自由应用的，区别在于<code class="fe ld le lf lg b">runProgram</code>和它的“自由”代数，它不是一个单子，而是一个应用功能。</p><p id="15a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的所有源代码可以在<a class="ae kw" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ScalaTutorial/freeMonad/src/main/scala/GeneralizedFreeStructure" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p><p id="0dc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来源与参考:<a class="ae kw" href="https://medium.com/@olxc/free-monads-explained-pt-1-a5c45fbdac30" rel="noopener">游离单子讲解(pt 1)。构建可组合DSLs |作者Oleksii Avramenko | Medium</a><a class="ae kw" href="https://typelevel.org/cats/datatypes/freemonad.html" rel="noopener ugc nofollow" target="_blank">Cats:free monads</a></p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="7552" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae kw" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a><strong class="ka ir">以获得关于科技职业的文章、有趣的链接和内容的通知！</strong></p><p id="7d41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以关注我，也可以在<a class="ae kw" href="https://medium.com/@edwardgunawan880" rel="noopener"> Medium </a>上关注我，获取更多类似的帖子。</p><p id="7c67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ns">原载于【https://edward-huang.com】<a class="ae kw" href="https://edward-huang.com/functional-programming/scala/programming/monad/2020/09/20/explain-free-monad-like-i-am-five-part-2/" rel="noopener ugc nofollow" target="_blank"><em class="ns"/></a><em class="ns">。</em></em></p></div></div>    
</body>
</html>