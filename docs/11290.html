<html>
<head>
<title>A Micropayments Channel Factory with Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个可靠的微支付渠道工厂</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-micropayments-channel-factory-with-solidity-ccf586afb519?source=collection_archive---------5-----------------------#2022-03-05">https://levelup.gitconnected.com/a-micropayments-channel-factory-with-solidity-ccf586afb519?source=collection_archive---------5-----------------------#2022-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b40a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理两个以太坊账户之间的支付就像从一个账户向另一个账户发送交易一样简单。但每笔交易都有成本，如果你的目标是对不同的账户进行大量交易，你可能希望避免每次都支付费用。</p><p id="3acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种选择？让接收方为获得自己的钱买单。</p><p id="db4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">又是如何做到的？这个想法是将带有签名信息的支付指令发送给在完整的<strong class="jp ir">链外</strong>操作中的任何受益人，当他们准备好时，可以通过与持有它的智能合同进行交互来要求他们的资金。</p><p id="e1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种小额支付渠道方法在<a class="ae kl" href="https://docs.soliditylang.org/en/v0.8.11/solidity-by-example.html#micropayment-channel" rel="noopener ugc nofollow" target="_blank">的官方可靠性文件</a>中可用。我从这里开始，做了一些修改，使合同符合我的预期解决方案。</p><p id="4dcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我将描述我是如何设法开发这个解决方案的，而不是集中在CI/CD和工程基础上。你可以在<a class="ae kl" href="https://coinsbench.com/building-a-dapp-using-truffle-and-react-with-ci-cd-integration-aa278a207247" rel="noopener ugc nofollow" target="_blank">我的上一篇文章</a>中找到细节。</p><h1 id="489f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解决方案</h1><p id="0db3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">一个Web应用程序，允许一个<em class="lp"> "company" </em>使用一个工厂合同来管理几个小额付款合同。从UI中，拥有工厂的帐户可以<strong class="jp ir">创建</strong>和<strong class="jp ir">删除</strong>小额付款实例，并在其初始余额中添加指定数量的乙醚。此外，从UI中，所有者可以生成已签名的消息，以允许任何地址向合同的<strong class="jp ir">索取资金</strong>。</p><p id="a271" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UI的另一部分更简单，它允许任何用户通过使用签名的消息作为输入来声明收取他们的资金。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/9a0c7b7c59ff16d01d929ec9a3ef02e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zi2Wr6H_6Fus5BcThiVa1Q.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">公司端界面</figcaption></figure><p id="a962" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了允许账户从合同中获得资金，用户需要在ETH中指明允许接收的<em class="lp">索赔人地址</em>和<em class="lp">金额</em> <strong class="jp ir"> <em class="lp"> </em> </strong>。有了这些信息和我将在后面描述的附加数据，就可以使用元掩码生成签名。</p><h2 id="e741" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">生成签名</h2><pre class="lr ls lt lu gt ms mt mu mv aw mw bi"><span id="7338" class="mg kn iq mt b gy mx my l mz na">constructMessage(recipient, amount, nonce) {<br/>   return soliditySHA3(<br/>      ['address', 'uint256', 'uint256', 'address'], <br/>      [recipient, amount, nonce, <strong class="mt ir">this._contractAddress</strong>]);<br/>}</span></pre><p id="94ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前面的方法采用<em class="lp">接收者的地址</em>、<em class="lp">合同的地址</em>、金额<em class="lp">、</em>和一个<em class="lp">随机数</em>，并生成一个32字节的固定长度散列。这样做是为了在签名前限制基本消息的长度。</p><ul class=""><li id="f5f8" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated"><strong class="jp ir"> <em class="lp">收款人:</em> </strong> <em class="lp"> W </em> e表示被允许索款的人。当声明者与智能合约交互时，<em class="lp"> msg.sender </em>值应该与接收者匹配。</li><li id="ebad" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><strong class="jp ir"> <em class="lp">金额:</em> </strong>索赔金额应与允许金额相符。</li><li id="b867" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><strong class="jp ir"> <em class="lp"> nonce: </em> </strong>唯一标识符，保证同一个签名不能被使用两次。该值保存在合同中，如果已经使用，将拒绝索赔。</li><li id="548e" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><strong class="jp ir"><em class="lp">contract address:</em></strong>这是为了确保声明者只与预期的契约进行交互。如果不这样做，同一个签名可能会在同一个签名者帐户创建的几个合同中使用。</li></ul><p id="d2e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成散列后，让我们使用下面的方法对它进行签名。</p><pre class="lr ls lt lu gt ms mt mu mv aw mw bi"><span id="f89c" class="mg kn iq mt b gy mx my l mz na">web3.eth.personal.sign(hash, signerAddress, '');</span></pre><p id="ae57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，第三个参数对应一个<em class="lp">密码</em>。我把它留为空白，没有必要在这里设置任何值。我尝试使用几个不同的值，总是得到相同的签名。调用此方法时，MetaMask会提示并要求您确认签名。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ec632fd6e281b7ad27c06d4cd6f8ff57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*rtelAA5RqgqRHdUDS6TTuw.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">签名确认</figcaption></figure><p id="7075" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UI很好地显示了执行声明所必需的值，这些值应该与声明者共享。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nq"><img src="../Images/024a985840dd6cbc19f5bf52cdb27701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_ii5b3wjSpFJ95EDKFV5A.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">签名详细信息</figcaption></figure><p id="ffb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们还没有与智能合约进行交互，所以所有这些都是免费的。让我们复制这些信息并与目标用户分享。</p><h2 id="e822" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">要求付款</h2><p id="51ce" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在，目标用户想要认领他们的资金，让我们去那里认领吧</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/dc3aeae628a6fcc38f7a6e575a7e1785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yO0ysconwPK7IwWIdfbKlg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">要求付款</figcaption></figure><p id="955e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是与智能合约的实际交互开始的地方，也是有人付费的地方。</p><p id="202d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要索赔，我们只需要知道提出请求的合同地址、索赔的<strong class="jp ir">金额</strong>、随机数，当然还有<strong class="jp ir">签名。</strong></p><pre class="lr ls lt lu gt ms mt mu mv aw mw bi"><span id="6c2c" class="mg kn iq mt b gy mx my l mz na">function claimPayment(uint256 amount, uint256 nonce, bytes memory signature) external {<br/>   require(!usedNonces[nonce], "Claim already done");<br/>   usedNonces[nonce] = true;<br/>   <br/>   bytes32 message = keccak256(abi.encodePacked(_msgSender(), amount, nonce, this)).prefixed();<br/>   <br/>   require(message.recoverSigner(signature) == owner(), "Signature is invalid [owner]");</span><span id="eb1b" class="mg kn iq mt b gy nr my l mz na">   payable(_msgSender()).transfer(amount);<br/>   emit PaymentClaimed(_msgSender(), name, block.timestamp);<br/>}</span></pre><p id="1156" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来分析一下这个。第一个"<em class="lp">需求</em>"是检查nonce是否从未被用于声明。那么第二行将生成与应该由<code class="fe ns nt nu mt b">web3.eth.personal.sign</code>生成的消息完全相同的消息。然后,“recoverSigner”方法获取消息和签名，并检索应该签名的所有者。如果它与合同的所有者匹配，那么它就是一个有效的签名，资金被转移。</p><p id="9e1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法<em class="lp"> prefixed() </em>将<code class="fe ns nt nu mt b">\x19Ethereum Signed Message:\32</code>添加到消息散列的前面。这是用于区分签名邮件的唯一标记。注意，最后一个<code class="fe ns nt nu mt b">32</code>是原始消息散列的长度。</p><p id="9b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法<em class="lp"> recoverSigner() </em>调用<em class="lp"> ecrecover </em>，这是一个非常有用的方法，用于从给定的消息及其签名中获取签名者。</p><p id="0f09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，这个调用<code class="fe ns nt nu mt b">keccak256(abi.encodePacked(_msgSender(), amount, nonce, this))</code>和<em class="lp">构造消息做的一样。</em>它对输入数据进行哈希处理。如你所见，索赔人来自于<em class="lp">消息发送者</em>，合同地址来自于实际合同。</p><h2 id="ee57" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">工厂</h2><p id="a871" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">网上有一些工厂实现，你可以查看我将在本文结尾与你分享的repo中的代码。所以我只想解决我必须解决的最重要的问题。</p><p id="9d41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，简单的一个。我希望创建的契约的所有权是创建实例的帐户，而不是工厂。感谢上帝我们有<a class="ae kl" href="https://openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>并且我们不需要写代码，我只是从<a class="ae kl" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> Ownable </a>继承我的小额支付合同。所以我只是调用<em class="lp"> transferOwnership() </em>并使msg.sender成为新的所有者。</p><pre class="lr ls lt lu gt ms mt mu mv aw mw bi"><span id="72f4" class="mg kn iq mt b gy mx my l mz na">Micropayments micropaymentContract = (new Micropayments){value: msg.value}(name);</span><span id="a835" class="mg kn iq mt b gy nr my l mz na">micropaymentContract.transferOwnership(_msgSender());</span></pre><p id="22af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个问题出现在删除小额支付实例时。由于工厂跟踪创建的实例，如果我们只是其中的一个，工厂不会注意到。因此，我所做的是在Micropayments契约中创建一个<em class="lp"> shutdown() </em>方法，该方法只能从创建它的工厂调用，并将该地址存储在一个新变量中。因此，实例的所有者就是创建它的人。但是只能从工厂删除。此外，执行删除的工厂方法只能由工厂所有者调用。</p><pre class="lr ls lt lu gt ms mt mu mv aw mw bi"><span id="e9e5" class="mg kn iq mt b gy mx my l mz na">function deleteContract(address location) external onlyOwner {<br/>  uint256 contractIndex = addressToIndex[location];<br/>  Micropayments toDelete = Micropayments(contracts[contractIndex]);</span><span id="941e" class="mg kn iq mt b gy nr my l mz na">  bytes32 nameHash = keccak256(bytes(toDelete.name()));<br/>  nameToAddress[nameHash] = address(0);</span><span id="a846" class="mg kn iq mt b gy nr my l mz na">  toDelete.shutdown();</span><span id="969b" class="mg kn iq mt b gy nr my l mz na">  addressToIndex[address(Micropayments(contracts[contracts.length - 1]))] = contractIndex;<br/>  contracts[contractIndex] = contracts[contracts.length - 1];<br/>  contracts.pop();</span><span id="d253" class="mg kn iq mt b gy nr my l mz na">  emit MicropaymentsDeleted(_msgSender(), location);<br/>}</span></pre><blockquote class="nv nw nx"><p id="7e80" class="jn jo lp jp b jq jr js jt ju jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj kk ij bi translated">提示:在deleteContract()方法中检查合同数组是如何更新的。如果你尝试做<code class="fe ns nt nu mt b">delete contracts[index]</code>，那个位置不会从数组中移除，长度也是一样的。它只是用数组的默认值来设置位置。</p></blockquote><p id="c06b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，这里你有回购和网站。合同部署在林克比。</p><p id="6fc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/adpinola/Micropayments" rel="noopener ugc nofollow" target="_blank">https://github.com/adpinola/Micropayments</a></p><div class="ob oc gp gr od oe"><a href="https://adpinola.github.io/Micropayments/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">小额支付工厂</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">@阿德皮诺拉的DApp</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">adpinola.github.io</p></div></div></div></a></div><p id="bcb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为你不是工厂的所有者，所以你不能与它互动。如果你想得到一些ETH，请分享你的地址，我会为你签名！！</p><p id="fc6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您可以自己部署它，拥有工厂并开始创建支付订单。</p><p id="5a5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你的阅读，我希望它对你的发展冒险有所帮助。</p><p id="e99a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">___________________________________________________________________</p><p id="6308" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lp">更新4月11日:</em></strong><br/>T5】delete contract方法现在清除<em class="lp"> nameToAddress </em>映射，以允许在删除后重复合同名称。<br/>此外，<em class="lp"> addressToIndex </em>地图在删除合同后没有保持正确的跟踪，现在已经修复。</p></div></div>    
</body>
</html>