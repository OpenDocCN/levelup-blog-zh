<html>
<head>
<title>Experience sharing: Golang performance optimization and common mistakes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验分享:Golang性能优化和常见错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/experience-sharing-golang-performance-optimization-and-common-mistakes-b9e26c3d39b2?source=collection_archive---------4-----------------------#2022-10-11">https://levelup.gitconnected.com/experience-sharing-golang-performance-optimization-and-common-mistakes-b9e26c3d39b2?source=collection_archive---------4-----------------------#2022-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ee33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Golang性能优化</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/fed0bd2bdedce8caa00f5ba448b11a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*w4bB1VQJntxCdccCEpd1eQ.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@brittfowler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布里特·福勒</a>在<a class="ae la" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="779d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">内存优化。</strong></p><p id="81c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #1。小对象合并。</em> </strong></p><p id="43d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在堆内存上频繁创建和销毁小对象，会导致内存碎片，一般使用内存池。</p><p id="fa61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Golang的内存机制也是一个内存池，每个span大小为4KB，并维护一个缓存，缓存中有一个列表数组</p><p id="48a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数组存储一个链表，就像HashMap的zipper方法一样，数组的每个网格代表的内存大小不一样，64位机是以8字节为单位的。</p><p id="d46f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，下标0是一个大小为8字节的链表节点，下标1是一个大小为16字节的链表节点。每个下标的内存是不同的，使用最近按需分配的内存。</p><p id="54ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再比如，一个结构的内存其实是31字节，分配的时候会分配32字节。</p><p id="b4af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">带下标的链表每个节点存储的内存是一致的。</p><p id="090c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以建议将小对象合并到一个结构中。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="9c2e" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">for</strong> k, v := <strong class="ld iu">range</strong> m {<br/>    // copy for capturing by the goroutine<br/>    x := <strong class="ld iu">struct</strong> {k , v <strong class="ld iu">string</strong>} {k, v} <br/>    <strong class="ld iu">go</strong> <strong class="ld iu">func</strong>() {<br/>        // using x.k &amp; x.v<br/>    }()<br/>}</span></pre><p id="60b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #2。合理使用</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">buff</em></strong></code> <strong class="js iu"> <em class="lb">缓存。</em>T24】</strong></p><p id="1eec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当协议编码需要频繁操作buff时，可以使用<code class="fe ln lo lp ld b">bytes.Buffer</code>作为缓冲对象，它会一次性分配足够的内存，避免内存不够时动态申请内存，减少内存分配的次数，buff可以重复使用(推荐复用)</p><p id="d497" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在创建切片和地图时，预先估计大小并指定容量。</p><p id="8bc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提前分配内存，可以减少动态扩展带来的开销。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="54fc" class="lh li it ld b gy lj lk l ll lm">t := make([]<strong class="ld iu">int</strong>, 0, 100)<br/>m := make(<strong class="ld iu">map</strong>[<strong class="ld iu">string</strong>]<strong class="ld iu">int</strong>, 100)</span></pre><p id="e089" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不确定<code class="fe ln lo lp ld b">slice</code>是否会初始化，使用<code class="fe ln lo lp ld b">var</code>不会分配内存，<code class="fe ln lo lp ld b">make([]int,0)</code>会分配内存空间。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="dff1" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">var</strong> t []<strong class="ld iu">int</strong></span></pre><p id="5186" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提示:在容量小于或等于1024之前，切片容量加倍。容量大于1024后，每次增加为<code class="fe ln lo lp ld b">1/4</code>。</p><p id="4a97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">地图的扩展机制更复杂。每次展开都是2的倍数。结构中有一个桶<code class="fe ln lo lp ld b">oldBuckets</code>实现增量扩展。</p><p id="dda8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #3。长调用栈避免了申请更多的临时对象。</em>T12】</strong></p><p id="0092" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">goroutine</code>的默认堆栈大小是4KB。</p><p id="4675" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Golang1.7中，改为2KB，采用连续堆栈机制。当堆栈空间不够时，goroutine会继续扩展，每次扩展都和切片的扩展一样。</p><p id="ff7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它涉及新堆栈空间的应用和旧堆栈空间的复制。如果<code class="fe ln lo lp ld b">GC</code>发现当前空间只有之前的1/4，就会再次收缩，频繁的内存申请和复制会带来额外的开销。</p><p id="20d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议:控制函数调用栈框架的复杂度，避免创建过多的临时对象，如果确实需要长的调用栈或者作业类型代码，可以考虑池化goroutines</p><p id="7a18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #4。避免频繁创建临时变量。</em> </strong></p><p id="3408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GC STW的时间已经优化到最差的1毫秒，但仍有混合写入障碍会降低性能。如果临时变量太多，GC性能损失会很大。</p><p id="d646" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议:缩小变量的范围，使用局部变量，最小化可见性，并将多个变量合并到一个结构数组中(减少扫描次数)</p><p id="ac80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #5。大型结构通过指针传递。</em> </strong></p><p id="679a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Golang是全值复制，特别是当<code class="fe ln lo lp ld b">struct</code>被压入栈帧时，它会一个一个的压入变量，频繁的申请内存，可以使用指针转移来优化性能。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="5766" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">并发优化。</strong></p><p id="5a12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #1。使用</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">goroutine</em></strong></code> <strong class="js iu"> <em class="lb">汇集。</em> </strong></p><p id="e6e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go是轻量级的，但是对于高度并发的轻量级任务，比如高度并发的作业类型代码。</p><p id="4679" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑使用goroutine池来减少go routine的创建和销毁。</p><p id="8045" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #2。减少系统调用。</em> </strong></p><p id="b49d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">goroutine</code>的实现是通过同步来模拟异步操作。例如，下面的操作不会阻塞<code class="fe ln lo lp ld b">runtime</code>的线程调度。</p><ul class=""><li id="5bb9" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">网络IO。</li><li id="6eb2" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">渠道。</li><li id="768f" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated"><code class="fe ln lo lp ld b">time.Sleep</code>。</li><li id="b4ea" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">基于底层异步<code class="fe ln lo lp ld b">SysCall</code>。</li></ul><p id="542a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的阻塞创建了一个新的线程调度。</p><ul class=""><li id="884d" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">本地IO。</li><li id="312d" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated"><code class="fe ln lo lp ld b">SysCall</code>基于低级同步。</li><li id="9bf3" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">CGO调用IO或其他阻塞。</li></ul><p id="c0ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议同步调用:隔离到可控的goroutine中，而不是直接的高级go routine调用。</p><p id="eb1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #3。合理降低锁的粒度。</em>T19】</strong></p><p id="3b09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go建议使用通道调用，而不是共享内存。存在通道之间的锁定范围太大的问题，这会降低锁定的强度。</p><p id="1e45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，不要在<code class="fe ln lo lp ld b">channel</code>中传递大数据，会有值复制的问题。</p><p id="2085" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">channel</code>的底层是链表+锁。</p><p id="5cb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要用<code class="fe ln lo lp ld b">channel</code>传递图片等数据，任何队列的性能都很低，可以尝试用指针优化大型对象</p><p id="f4f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #4。合理使用</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">protobuf</em></strong></code> <strong class="js iu"> <em class="lb">。</em> </strong></p><p id="e01f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">protobuf</code>在存储和解析上比<code class="fe ln lo lp ld b">json</code>更高效。建议使用<code class="fe ln lo lp ld b">protobuf</code>代替<code class="fe ln lo lp ld b">json</code>进行持久化或数据传输。</p><p id="7135" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #5。基于业务场景聚合数据。</em> </strong></p><p id="c5d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于网关接口，通常需要聚合多个模块的数据。当这些业务模块的数据之间没有依赖关系时，可以进行并行请求以减少耗时。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="af95" class="lh li it ld b gy lj lk l ll lm">ctxTimeout, cf := context.WithTimeout(context.Background(), time.Second)<br/><strong class="ld iu">defer</strong> cf()<br/>g, ctx := errgroup.WithContext(ctxTimeout)<br/><strong class="ld iu">var</strong> urls = []<strong class="ld iu">string</strong>{<br/>    "http://www.golang.org/",<br/>    "http://www.google.com/",<br/>    "http://www.foo.com/",<br/>}<br/><strong class="ld iu">for</strong> _, url := <strong class="ld iu">range</strong> urls {<br/>    // Launch a goroutine to fetch the URL.<br/>    url := url // https://golang.org/doc/faq#closures_and_goroutines<br/>    g.Go(<strong class="ld iu">func</strong>() <strong class="ld iu">error</strong> {<br/>        // Fetch the URL.<br/>        resp, err := http.Get(url)<br/>        <strong class="ld iu">if</strong> err == <strong class="ld iu">nil</strong> {<br/>            resp.Body.Close()<br/>        }<br/>        <strong class="ld iu">return</strong> err<br/>    })<br/>}<br/>// Wait for all HTTP fetches to complete.<br/><strong class="ld iu">if</strong> err := g.Wait(); err == <strong class="ld iu">nil</strong> {<br/>    fmt.Println("Successfully fetched all URLs.")<br/>}<br/><strong class="ld iu">select</strong> {<br/><strong class="ld iu">case</strong> &lt;-ctx.Done():<br/>    fmt.Println("Context canceled")<br/><strong class="ld iu">default</strong>:<br/>    fmt.Println("Context not canceled")<br/>}</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="3ebd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">容易犯的错误。</strong></p><p id="791e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #1。关于</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">channels</em></strong></code> <strong class="js iu"> <em class="lb">的常见故障。</em>T41】</strong></p><ul class=""><li id="663e" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">关闭已关闭的通道将<code class="fe ln lo lp ld b">panic</code>。</li><li id="b4a4" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">向封闭通道发送数据将<code class="fe ln lo lp ld b">panic</code>。</li><li id="c85c" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">从封闭通道读取数据是初始值默认值。</li></ul><p id="ff9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">渠道封闭原则。</p><ul class=""><li id="edaf" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">不要关闭接收器上的<code class="fe ln lo lp ld b">channel</code>。</li><li id="e94d" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">不要关闭有多个发送器的<code class="fe ln lo lp ld b">channels</code>。</li><li id="8b2e" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">当只有一个发送方，以后没有数据发送时，可以关闭<code class="fe ln lo lp ld b">channel</code>。</li></ul><p id="1c80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，请注意，缓存的频道不一定是有序的。</p><p id="e390" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何优雅地关闭频道？</p><p id="b885" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">【https://go101.org/article/channel-closing.html T42】</p><p id="781b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #2。关于</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">defer</em></strong></code> <strong class="js iu"> <em class="lb">的常见故障。</em>T51】</strong></p><p id="b836" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应额外注意<code class="fe ln lo lp ld b">defer</code>中的变量。</p><ul class=""><li id="8042" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">调用时传递参数。</li></ul><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="6935" class="lh li it ld b gy lj lk l ll lm">i := 1<br/><strong class="ld iu">defer</strong> println("defer", i)<br/>i++<br/>// defer 1</span></pre><ul class=""><li id="1043" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">非参数闭包。</li></ul><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="b2b5" class="lh li it ld b gy lj lk l ll lm">i := 1<br/><strong class="ld iu">defer</strong> <strong class="ld iu">func</strong>() {<br/>    println("defer", i)<br/>}()<br/>i++<br/>// defer 2</span></pre><ul class=""><li id="cbb5" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">命名返回是相同的闭包，将修改命名返回的返回值。</li></ul><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="ec86" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">func</strong> <strong class="ld iu">main</strong>(){<br/>   fmt.Printf("main: %v\n", getNum())<br/>   // defer 2<br/>   // main: 2<br/>}<br/><br/><strong class="ld iu">func</strong> <strong class="ld iu">getNum</strong>() (i <strong class="ld iu">int</strong>) {<br/>   <strong class="ld iu">defer</strong> <strong class="ld iu">func</strong>() {<br/>      i++<br/>      println("defer", i)<br/>   }()<br/>   i++<br/>   <strong class="ld iu">return</strong><br/>}</span></pre><p id="defa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特别要注意不要在<code class="fe ln lo lp ld b">for loop</code>中调用<code class="fe ln lo lp ld b">defer</code>。</p><p id="348f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为延迟只会在函数返回后执行，这将累积大量的延迟，并且非常容易出错。</p><p id="6c9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议:将需要defer的for循环的代码逻辑封装到一个函数中。</p><p id="91e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #3。关于</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">http</em></strong></code> <strong class="js iu"> <em class="lb">的常见故障。</em> </strong></p><p id="a140" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Golang的HTTP默认请求没有超时，这是个大问题。</p><p id="bd9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为如果服务器不响应，不断开连接，客户端就会一直等待，导致客户端阻塞，请求量巨大时服务就会崩溃。</p><p id="2c5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，HTTP请求框架的响应必须用<code class="fe ln lo lp ld b">Close</code>方法关闭，否则可能会出现内存泄漏。</p><p id="6b41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #4。关于</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">interface</em></strong></code> <strong class="js iu"> <em class="lb">的常见故障。</em> </strong></p><p id="525f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">什么时候一个<code class="fe ln lo lp ld b">interface</code>等于<code class="fe ln lo lp ld b">nil</code>？</p><p id="ff80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:<code class="fe ln lo lp ld b">interface{}</code>和<code class="fe ln lo lp ld b">struct</code>接口类型不同。接口的底层有两个成员，一个是<code class="fe ln lo lp ld b">type</code>，一个是<code class="fe ln lo lp ld b">value</code>。</p><p id="dc53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有当<code class="fe ln lo lp ld b">type</code>和<code class="fe ln lo lp ld b">value</code>都是<code class="fe ln lo lp ld b">nil</code>时，<code class="fe ln lo lp ld b">interface{}</code>才等于<code class="fe ln lo lp ld b">nil</code>。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="c3f3" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">var</strong> u <strong class="ld iu">interface</strong>{} = (*<strong class="ld iu">interface</strong>{})(<strong class="ld iu">nil</strong>)<br/><strong class="ld iu">if</strong> u == <strong class="ld iu">nil</strong> {<br/>    t.Log("u is nil")<br/>} <strong class="ld iu">else</strong> {<br/>    t.Log("u is not nil")<br/>}<br/>// u is not nil</span></pre><p id="5941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接口示例。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="bea6" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">var</strong> u Car = (Car)(<strong class="ld iu">nil</strong>)<br/><strong class="ld iu">if</strong> u == <strong class="ld iu">nil</strong> {<br/>    t.Log("u is nil")<br/>} <strong class="ld iu">else</strong> {<br/>    t.Log("u is not nil")<br/>}<br/>// u is nil</span></pre><p id="d263" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自定义结构。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="b748" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">var</strong> u *user = (*user)(<strong class="ld iu">nil</strong>)<br/><strong class="ld iu">if</strong> u == <strong class="ld iu">nil</strong> {<br/>    t.Log("u is nil")<br/>} <strong class="ld iu">else</strong> {<br/>    t.Log("u is not nil")<br/>}<br/>// u is nil</span></pre><p id="9d1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #5。关于</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">map</em></strong></code> <strong class="js iu"> <em class="lb">的常见故障。</em>T46】</strong></p><p id="1b9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">Map</code>并发读写将<code class="fe ln lo lp ld b">panic</code>，需要锁定或使用<code class="fe ln lo lp ld b">sync.Map</code>。</p><p id="d03a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">map</code>也不能直接更新<code class="fe ln lo lp ld b">value</code>的字段。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="0a44" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">type</strong> User <strong class="ld iu">struct</strong>{<br/>   name <strong class="ld iu">string</strong><br/>}<br/><strong class="ld iu">func</strong> <strong class="ld iu">TestMap</strong>(t *testing.T) {<br/>   m := make(<strong class="ld iu">map</strong>[<strong class="ld iu">string</strong>]User)<br/>   m["1"] = User{name:"1"}<br/>   m["1"].name = "2"<br/>   // Compilation failed, you cannot directly modify a field value of map<br/>}</span></pre><p id="093c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要单独拿出来。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="996e" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">func</strong> <strong class="ld iu">TestMap</strong>(t *testing.T) {<br/>   m := make(<strong class="ld iu">map</strong>[<strong class="ld iu">string</strong>]User)<br/>   m["1"] = User{name: "1"}<br/>   u1 := m["1"]<br/>   u1.name = "2"<br/>}</span></pre><p id="98a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #6。关于</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">slice</em></strong></code> <strong class="js iu"> <em class="lb">的常见故障。</em> </strong></p><p id="a0bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数组是值类型，切片是引用类型(指针)。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="cd93" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">func</strong> <strong class="ld iu">TestArray</strong>(t *testing.T) {<br/>   a := [1]<strong class="ld iu">int</strong>{}<br/>   setArray(a)<br/>   println(a[0])<br/>   // 0<br/>}</span><span id="27af" class="lh li it ld b gy ml lk l ll lm"><strong class="ld iu">func</strong> <strong class="ld iu">setArray</strong>(a [1]<strong class="ld iu">int</strong>) {<br/>   a[0] = 1<br/>}</span><span id="dc56" class="lh li it ld b gy ml lk l ll lm"><strong class="ld iu">func</strong> <strong class="ld iu">TestSlice</strong>(t *testing.T) {<br/>   a := []<strong class="ld iu">int</strong>{<br/>      1,<br/>   }<br/>   setSlice(a)<br/>   println(a[0])<br/>   // 1<br/>}</span><span id="3c07" class="lh li it ld b gy ml lk l ll lm"><strong class="ld iu">func</strong> <strong class="ld iu">setSlice</strong>(a []<strong class="ld iu">int</strong>) {<br/>   a[0] = 1<br/>}</span></pre><p id="496c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">range</code>方法将创建每个元素的副本，并且将有一个值的副本。如果数组存储大型结构，可以使用索引遍历或指针优化。</p><p id="e9f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为<code class="fe ln lo lp ld b">value</code>是副本，所以不能修改原值。</p><p id="0afe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">append</code>方法改变地址。</p><p id="2683" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">slice</code>型的本质是一种结构。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="65b0" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">type</strong> slice <strong class="ld iu">struct</strong> {<br/>   array unsafe.Pointer<br/>   len   <strong class="ld iu">int</strong><br/>   cap   <strong class="ld iu">int</strong><br/>}</span></pre><p id="8aff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">复制函数值将使修改无效。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="4cf4" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">func</strong> <strong class="ld iu">TestAppend1</strong>(t *testing.T) {<br/>   <strong class="ld iu">var</strong> a []<strong class="ld iu">int</strong><br/>   add(a)<br/>   println(len(a))<br/>   // 0<br/>}<br/><br/><strong class="ld iu">func</strong> <strong class="ld iu">add</strong>(a []<strong class="ld iu">int</strong>) {<br/>   a = append(a, 1)<br/>}</span></pre><p id="6148" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #7。关于</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">closure</em></strong></code> <strong class="js iu"> <em class="lb">的常见故障。</em>T19】</strong></p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="3745" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">for</strong> i := 0; i &lt; 3; i++ {<br/>    <strong class="ld iu">go</strong> <strong class="ld iu">func</strong>() {<br/>        println(i)<br/>    }()<br/>}<br/>time.Sleep(time.Second)<br/>// 2<br/>// 2<br/>// 2</span></pre><p id="83bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为闭包导致<code class="fe ln lo lp ld b">i</code>变量转义到堆空间，所以所有goroutines共享<code class="fe ln lo lp ld b">i</code>变量，从而导致并发问题。</p><p id="5fb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案1:局部变量。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="cb4e" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">for</strong> i := 0; i &lt; 3; i++ {<br/>    ii := i<br/>    <strong class="ld iu">go</strong> <strong class="ld iu">func</strong>() {<br/>        println(ii)<br/>    }()<br/>}<br/>time.Sleep(time.Second)<br/>// 2<br/>// 0<br/>// 1</span></pre><p id="f581" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案2:参数传递。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="a992" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">for</strong> i := 0; i &lt; 3; i++ {<br/>    <strong class="ld iu">go</strong> <strong class="ld iu">func</strong>(ii <strong class="ld iu">int</strong>) {<br/>        println(ii)<br/>    }(i)<br/>}<br/>time.Sleep(time.Second)<br/>// 2<br/>// 0<br/>// 1</span></pre><p id="c7fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lb"> #8。关于</em> </strong> <code class="fe ln lo lp ld b"><strong class="js iu"><em class="lb">select</em></strong></code> <strong class="js iu"> <em class="lb">的常见故障。</em> </strong></p><p id="7349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp ld b">for</code>中的<code class="fe ln lo lp ld b">default</code>会在<code class="fe ln lo lp ld b">select</code>中执行，不会一直占用CPU，导致CPU空闲。</p><p id="85d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例代码。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="f2e7" class="lh li it ld b gy lj lk l ll lm"><strong class="ld iu">func</strong> <strong class="ld iu">TestForSelect</strong>(t *testing.T) {<br/>   <strong class="ld iu">for</strong> {<br/>      <strong class="ld iu">select</strong> {<br/>        <strong class="ld iu">case</strong> &lt;-time.After(time.Second * 1):<br/>            println("hello")<br/>        <strong class="ld iu">default</strong>:<br/>            <strong class="ld iu">if</strong> math.Pow10(100) == math.Pow(10, 100) {<br/>                println("equal")<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="8441" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行<code class="fe ln lo lp ld b">top</code>命令。</p><pre class="kp kq kr ks gt lc ld le lf aw lg bi"><span id="7520" class="lh li it ld b gy lj lk l ll lm">top - 15:00:50 up 1 day, 15:55,  0 users,  load average: 1.36, 0.85, 0.35<br/>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND   <br/>28632 root      20   0 2168296   1.4g   2244 S 252.8  11.7   1:04.15 __debug_bin</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="d047" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读。</p><p id="2feb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这样的故事，想支持我，请给我鼓掌。</p><p id="beb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的支持对我来说非常重要，谢谢你。</p></div></div>    
</body>
</html>