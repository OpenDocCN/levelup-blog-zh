<html>
<head>
<title>Scaling Kubernetes: Intro to Kubernetes-based event-driven autoscaling (KEDA)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缩放Kubernetes:基于Kubernetes的事件驱动自动缩放简介(KEDA)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scaling-kubernetes-intro-to-kubernetes-based-event-driven-autoscaling-keda-60d835a35cfd?source=collection_archive---------16-----------------------#2020-05-12">https://levelup.gitconnected.com/scaling-kubernetes-intro-to-kubernetes-based-event-driven-autoscaling-keda-60d835a35cfd?source=collection_archive---------16-----------------------#2020-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a5b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes集群需要计算资源来运行应用程序，这些资源可能需要根据应用程序的需求而增加或减少。这通常属于“扩展”的范畴，可以大致分为集群和应用程序扩展。</p><p id="ff6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了处理不断增长的需求，比如高流量，可以通过运行多个实例来扩展应用程序。在Kubernetes中，这相当于扩展部署来添加更多的单元。</p><p id="66e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以手动完成，但是<code class="fe kl km kn ko b">Horizontal Pod Autoscaler</code>是一个内置的组件，可以自动处理这个问题。您可能还需要横向扩展底层Kubernetes节点，比如虚拟机、裸机实例等。这也可以手动完成，但是您可以使用一个<a class="ae kp" href="https://docs.microsoft.com/azure/aks/cluster-autoscaler?WT.mc_id=openMS-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">集群自动缩放器</a>，它将自动缩放您的集群。</p><p id="5f31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个博客系列将涵盖可以在现有Kubernetes原语之上使用的开源组件，以帮助扩展Kubernetes集群和应用程序。我们将探索:</p><p id="3ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是这一系列博文的分类:</p><ul class=""><li id="4f84" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated">第1部分(这篇文章)将涵盖基本的KEDA概念</li><li id="240c" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">第2部分将通过一个实例展示KEDA自动缩放的实际应用</li><li id="c303" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">第3部分将介绍虚拟Kubelet</li><li id="a013" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">第4部分将用另一个例子来结束本系列，展示如何将KEDA和Virtual Kubelet结合起来提供可伸缩性</li></ul><p id="6c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，你将对KEDA、它的建筑以及它的幕后运作有一个大致的了解。这将为你深入下一篇文章打下良好的基础，在下一篇文章中，你将通过一个实际的例子亲自探索KEDA。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/de0eda8b11ef42e720ef030c0e52276c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dd8Ztm19ov0RAigN.png"/></div></div></figure><p id="0a2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KEDA(基于Kubernetes的事件驱动自动缩放)是由微软<a class="ae kp" href="https://cloudblogs.microsoft.com/opensource/2019/05/06/announcing-keda-kubernetes-event-driven-autoscaling-containers/" rel="noopener ugc nofollow" target="_blank">和红帽</a>开发的开源组件，允许任何Kubernetes工作负载受益于事件驱动架构模型。这是CNCF的官方项目，目前是CNCF沙盒的一部分。KEDA通过水平缩放一个Kubernetes <a class="ae kp" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>或一个<a class="ae kp" href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" rel="noopener ugc nofollow" target="_blank">作业</a>来工作。它构建在<a class="ae kp" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">Kubernetes Horizontal Pod auto scaler</a>之上，允许用户利用Kubernetes中的<code class="fe kl km kn ko b">External Metrics</code>来基于来自任何事件源的信息定义自动缩放标准，例如Kafka主题延迟、Azure队列长度或从Prometheus查询中获得的指标。</p><p id="4924" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以从一系列<a class="ae kp" href="https://keda.sh/#scalers" rel="noopener ugc nofollow" target="_blank">预定义触发器</a>(也称为<code class="fe kl km kn ko b">Scalers</code>)中进行选择，这些触发器充当自动扩展部署(或<code class="fe kl km kn ko b">Job</code>)的事件和指标的来源。这些可以被认为是适配器，包含连接到外部源(例如Kafka、Redis、Azure Queue)的必要逻辑，并获取驱动自动缩放操作所需的指标。KEDA使用<a class="ae kp" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank"> Kubernetes操作符模型</a>，它定义了<a class="ae kp" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">自定义资源定义</a>，比如<code class="fe kl km kn ko b">ScaledObject</code>，你可以用它来配置自动缩放属性。</p><blockquote class="lx ly lz"><p id="cece" class="jn jo ma jp b jq jr js jt ju jv jw jx mb jz ka kb mc kd ke kf md kh ki kj kk ij bi translated"><em class="iq">KEDA内置了可插拔性，可以扩展以支持新的触发器/定标器</em></p></blockquote><p id="6fdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在高层次上，KEDA做了两件事来推动自动缩放过程:</p><ul class=""><li id="d2f9" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated">提供一个组件来激活和停用部署，以便在没有事件时从零开始扩展</li><li id="bacf" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">提供Kubernetes度量服务器来公开事件数据(例如，队列长度、主题延迟)</li></ul><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi me"><img src="../Images/6b5cb1cf7b43b679a4d8ded799dd9111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zzodoIEVBFpG3M5e.png"/></div></div></figure><p id="9219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KEDA使用三个组件来完成其任务:</p><ul class=""><li id="aeb5" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">Scaler</code>:连接到外部组件(例如Kafka)并获取指标(例如主题延迟)</li><li id="4858" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">Operator</code>(代理):负责“激活”部署并创建水平窗格自动缩放对象</li><li id="6320" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">Metrics Adapter</code>:将外部来源的指标呈现给水平Pod自动缩放器</li></ul></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="6b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更深入地了解这些组件是如何协同工作的。</p><h1 id="1494" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">攀登者</h1><p id="ae8c" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">如前所述，<code class="fe kl km kn ko b">Scaler</code>是由<code class="fe kl km kn ko b">ScaledObject</code>(自定义资源)清单定义的。它与在<code class="fe kl km kn ko b">ScaledObject</code>中定义的外部源或触发器集成，以获取所需的指标，并将它们呈现给KEDA指标服务器。KEDA集成了多种来源，还可以使用可插拔接口添加其他定标器或外部指标来源。</p><p id="4684" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些定标器包括:</p><p id="586a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kp" href="https://keda.sh/#scalers" rel="noopener ugc nofollow" target="_blank"> KEDA主页</a>上可以找到最新的定标员列表。</p><p id="e1e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KEDA操作符由一个控制器组成，该控制器实现一个“协调循环”,并充当一个代理来激活和停用一个部署，以便从零扩展到零。这是由安装KEDA时运行的KEDA操作器容器驱动的。</p><p id="ec22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它通过创建<code class="fe kl km kn ko b">Horizontal Pod Autoscaler</code> (HPA)对<code class="fe kl km kn ko b">ScaledObject</code>资源的创建做出“反应”。需要注意的是，KEDA负责将部署从零扩展到一个实例，然后再扩展回零，而HPA则负责自动扩展<code class="fe kl km kn ko b">Deployment</code>。</p><p id="2d30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，<code class="fe kl km kn ko b">Horizontal Pod Autoscaler</code>也需要指标来使自动缩放工作。它从哪里获得指标？输入度量适配器！</p><h1 id="e520" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">度量适配器</h1><p id="31af" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">除了定义一个<code class="fe kl km kn ko b">Custom Resource Definition</code>和一个控制器/操作器来操作它，KEDA还实现并充当外部度量的服务器。准确地说，它实现了<a class="ae kp" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/external-metrics-api.md" rel="noopener ugc nofollow" target="_blank"> Kubernetes外部指标API </a>，并作为一个“适配器”将来自外部来源的指标(如上所述)转换成一种形式，使<code class="fe kl km kn ko b">Horizontal Pod Autoscaler</code>能够理解和使用，从而驱动自动缩放过程。</p><p id="9ba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们将在随后的博客文章中讨论细节，但这里是从开发人员的角度快速浏览一下如何使用KEDA。一旦它被安装到您的Kubernetes集群，这就是您通常使用KEDA的方式(详细信息，请参考https://github.com/kedacore/samples<a class="ae kp" href="https://github.com/kedacore/samples" rel="noopener ugc nofollow" target="_blank">的示例)。</a></p><ol class=""><li id="9ad2" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk ni kw kx ky bi translated">创建一个<code class="fe kl km kn ko b">Deployment</code>(或者一个<code class="fe kl km kn ko b">Job</code>):这就是你希望KEDA基于缩放触发器缩放的应用程序。除此之外，它是完全独立的。</li><li id="c8de" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk ni kw kx ky bi translated">创建一个<code class="fe kl km kn ko b">ScaledObject</code>:这是定制的资源定义，您可以用它来定义度量的来源，以及自动缩放标准。</li></ol><p id="0072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦完成，KEDA将开始从事件源收集信息，并相应地驱动自动缩放。下面是一个<code class="fe kl km kn ko b">ScaledObject</code>的例子，它定义了如何自动缩放一个Redis列表消费者，称为处理器，作为Kubernetes <code class="fe kl km kn ko b">Deployment</code>在集群中运行。</p><pre class="lm ln lo lp gt nj ko nk nl aw nm bi"><span id="89c7" class="nn mg iq ko b gy no np l nq nr">apiVersion: keda.k8s.io/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: redis-scaledobject<br/>  namespace: default<br/>  labels:<br/>    deploymentName: processor<br/>spec:<br/>  scaleTargetRef:<br/>    deploymentName: processor<br/>  pollingInterval: 20<br/>  cooldownPeriod:  200<br/>  minReplicaCount: 0<br/>  maxReplicaCount: 50<br/>  triggers:<br/>  - type: redis<br/>    metadata:<br/>      address: redis:6739<br/>      listName: jobs<br/>      listLength: "20"<br/>    authenticationRef:<br/>      name: redis-auth-secret</span></pre><p id="a93b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，<code class="fe kl km kn ko b">ScaledObject</code>定义主要分为两部分:一部分是通用的，另一部分是特定于事件源的(Redis已经被用作一个例子)。</p><p id="409d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通用参数包括:</p><ul class=""><li id="70c7" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">scaleTargetRef.deploymentName</code>:您想要自动缩放的<code class="fe kl km kn ko b">Deployment</code>的名称</li><li id="5ac9" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">minReplicaCount</code>:KEDA将缩减部署的最小副本数量。您可以缩小到零，但也可以使用任何其他值</li><li id="ed9e" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">cooldownPeriod</code>:在最后一个触发被报告为活动之后，在将部署缩放回<code class="fe kl km kn ko b">minReplicaCount</code>之前等待的时间段</li><li id="a5a5" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">pollingInterval</code>:检查每次触发的时间间隔</li><li id="92e9" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">maxReplicaCount</code>:KEDA将向外扩展部署的最大副本数量</li></ul><p id="4982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件源或触发器的具体参数有:</p><ul class=""><li id="9c2e" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">triggers.type</code>:正在使用的事件源(如<code class="fe kl km kn ko b">redis</code>)</li><li id="2e5b" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">triggers.metadata</code>:因触发器而异的属性(例如在<code class="fe kl km kn ko b">redis</code>的情况下，其地址、<code class="fe kl km kn ko b">listName</code>和<code class="fe kl km kn ko b">listLength</code>)</li><li id="7c69" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><code class="fe kl km kn ko b">triggers.authenticationRef</code>:允许您引用<code class="fe kl km kn ko b">TriggerAuthentication</code>对象，这是另一个KEDA特有的对象，用于捕获事件源的认证机制</li></ul><p id="b918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KEDA是一个轻量级组件，可以添加到任何Kubernetes集群中以扩展其功能。它可用于自动扩展从传统部署到FaaS(无服务器功能)的各种工作负载。</p><p id="1bfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以明确地选择和配置特定的应用程序(<code class="fe kl km kn ko b">Deployment</code>和<code class="fe kl km kn ko b">Job</code>)，让KEDA自动伸缩而不影响其他组件。KEDA将确保您的应用程序缩减到零实例(可配置)，除非有工作要做。最后但同样重要的是，它是可扩展的。您可以以缩放器的形式集成自定义事件源，以驱动自动缩放过程。</p><p id="0279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请继续关注本系列的下一部分，在那里我们将借助一个实际的例子更深入地研究KEDA。其他问题或意见？请在下面的评论中告诉我。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="f40f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ma">原载于2020年5月12日</em><a class="ae kp" href="https://cloudblogs.microsoft.com/opensource/2020/05/12/scaling-kubernetes-keda-intro-kubernetes-based-event-driven-autoscaling/" rel="noopener ugc nofollow" target="_blank"><em class="ma"/></a><em class="ma">。</em></p></div></div>    
</body>
</html>