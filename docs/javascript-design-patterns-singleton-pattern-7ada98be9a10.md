# JavaScript 设计模式:单例模式

> 原文：<https://levelup.gitconnected.com/javascript-design-patterns-singleton-pattern-7ada98be9a10>

![](img/f2892c534612c1303efe644bcc83691d.png)

Singleton 模式:将类实例化的次数限制为一次，一个类只有一个实例，并提供一个全局访问点来访问它。

单体模式是一种创造性的设计模式。对于全局只需要一个对象的场景，比如线程池、全局缓存、窗口对象等。

## 特征

1.  类只有一个实例
2.  该实例是全局可访问的
3.  自我实例化(主动实例化)
4.  延迟初始化，即延迟执行(不同于静态类/对象)

JavaScript 是一种非正式的面向对象语言，没有类定义。单例模式需要一个“唯一的”和“全局可访问的”对象，类似于 JavaScript 中的一个全局对象，只是为了满足单例模式的两个特征:“唯一的”和“全局可访问的”。虽然它不是正式的单例模式，但不可否认的是，它确实具有类单例模式的特征。

//全局对象

`var globaObj = {}*;*`

使用全局变量有以下问题:

1.  命名空间污染(变量名冲突)
2.  维护时不便于控制(容易意外覆盖)

全局变量问题的折衷解决方案:

1.  使用名称空间
2.  闭包封装私有变量(使用函数作用域)
3.  ES6 `const` / `symbol`

虽然全局变量可以实现 singleton，但是由于其自身的问题，在实际项目中不建议将其作为 singleton 模式使用，尤其是在中大型项目的应用中。维护全局变量应该被认为是一种成本。

## 实现

使用一个变量来存储类实例对象(最初的值是`null` / `undefined` )。实例化一个类时，判断该类实例对象是否存在，如果存在则返回实例。如果不存在，则创建并返回类实例。多次调用类生成实例方法会返回同一个实例对象。

单例模式的“简单版本”:

代码定义了一个`Singleton` 函数，它是 JavaScript 中的“一等公民”，可以为它定义属性方法。因此，我们可以在函数`Singleton` 中定义一个`getInstance()`方法来管理 singleton，并创建一个返回的类实例对象，而不是通过传统的 new 运算符创建一个类实例对象。

`this.instance`存储创建的实例对象。每次接收到创建的实例对象时，判断`this.instance`中是否有实例对象，并返回。最终只会返回同一个 Singleton 类实例对象。

存在的问题:

1.  用 new 实例化一个类不够“透明”，需要约束类实例化的调用方法:`Singleton.getInstance(…)`
2.  管理单例的操作与对象创建和功能代码的操作相耦合，这不符合“单一责任原则”

**“透明”单例模式:**

实现 singleton 模式的“透明版”，意图是解决:统一使用 new 运算符得到 singleton 对象，而不是`Singleton.getInstance(…)`

“透明版”singleton 模式解决了“透明性”不足的问题，我们可以使用`new` 操作符来创建实例对象。

## “代理版本”单例模式

通过“代理”的形式，意图是解决:将管理单体操作从对象创建操作中拆分出来，实现更小粒度的划分，符合“单一责任原则”

## 懒惰单例模式

惰性单例，意在解决:只在需要的时候创建类实例对象。前端开发者对懒加载性能优化并不陌生。懒惰的单例也解决了“按需加载”的问题。

> 要求:页面弹窗提示，多次调用，只有一个弹窗对象，但显示的信息内容不同。

要开发这样一个全局弹出对象，我们可以应用单例模式。为了提高它的性能，我们可以让它在需要调用时生成实例并创建 DOM 节点。

代码中的演示是一个通用的“懒惰单例”创建方法。如果还需要`createLoginLayer`登录框、`createFrame` 框架框，可以调用`getSingleton(…)` 方法生成相应的实例对象。

## 适用场景

singleton 模式的特点，旨在解决:维护一个全局实例对象。

1.  对第三方库的引用(多个引用将只使用一个库引用，如 jQuery)
2.  弹出窗口(登录框、信息推广框)
3.  购物车(每个用户一辆购物车)
4.  全局状态管理存储(Vuex / Redux)

当项目中引入第三方库，库文件重复加载时，只会全局实例化一个库对象，如 jQuery、lodash、moment……其实它们的实现理念也是一种 singleton 模式的应用:

## 优点和缺点

**优点**:适用于单个对象，只生成一个对象实例，避免频繁创建和销毁实例，减少内存占用。

**缺点**:不适合动态扩展对象，或者需要创建多个相似对象的场景。

提示:在多线程编程语言中，单例模式涉及到同步锁的问题。由于 JavaScript 是单线程编程语言，所以这个问题暂时可以忽略。