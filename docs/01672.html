<html>
<head>
<title>Enforcing a Class Implementation in TypeScript — Introduction to TypeScript Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中实施类实现—TypeScript接口简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-typescript-interfaces-enforcing-class-implementation-b41f9e290bf9?source=collection_archive---------7-----------------------#2020-01-21">https://levelup.gitconnected.com/introduction-to-typescript-interfaces-enforcing-class-implementation-b41f9e290bf9?source=collection_archive---------7-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e5515e781819d88b274ab2bf31fdadd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UDLVvvBb2y6hthLy"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jasonhafso?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jason Hafso </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d553" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与普通JavaScript相比，TypeScript的最大优势在于，它通过为我们的程序对象添加类型安全来扩展JavaScript的特性。它通过检查对象所呈现的值的形状来做到这一点。检查形状被称为鸭分型或结构分型。</p><p id="1783" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接口是在TypeScript中扮演命名数据类型角色的一种方式。这对于在TypeScript程序的代码中定义契约非常有用。在本文中，我们将看看如何使用接口来加强类的实现。</p><h1 id="e99f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类别类型</h1><p id="716f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用TypeScript接口来确保类满足接口指定的特定约定，就像在其他编程语言中一样，比如C#和Java。例如，我们可以用关键字<code class="fe mh mi mj mk b">implements</code>定义一个类来实现接口指定的项目，就像我们在下面的代码中所做的那样:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2032" class="mt lf it mk b gy mu mv l mw mx">interface PersonInterface {<br/>  name: string;<br/>}</span><span id="e418" class="mt lf it mk b gy my mv l mw mx">class Person implements PersonInterface {<br/>  name: string = 'Mary';    <br/>}</span></pre><p id="6679" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们实现了类<code class="fe mh mi mj mk b">Person</code>，它实现了<code class="fe mh mi mj mk b">PersonInterface</code>中列出的项目。因为<code class="fe mh mi mj mk b">PersonInterface</code>有一个字符串字段<code class="fe mh mi mj mk b">name</code>，所以我们遵循在它下面实现的<code class="fe mh mi mj mk b">Person</code>类中的契约。上面的代码实现了接口中概述的所有项目，因此TypeScript编译器会将上面的代码视为有效。如果我们没有实现接口中的项目，而是使用了<code class="fe mh mi mj mk b">implements</code>关键字，那么我们将得到一个错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2d8f" class="mt lf it mk b gy mu mv l mw mx">interface PersonInterface {<br/>  name: string;  <br/>  age: number;  <br/>}</span><span id="aea7" class="mt lf it mk b gy my mv l mw mx">class Person implements PersonInterface {    <br/>  name: string = 'Mary';  <br/>  foo: any = 'abc';<br/>}</span></pre><p id="e958" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有上面的代码，那么TypeScript编译器将错误地拒绝它，因为我们在<code class="fe mh mi mj mk b">Person</code>中只有<code class="fe mh mi mj mk b">name</code>字段，但是没有<code class="fe mh mi mj mk b">age</code>字段，而是有<code class="fe mh mi mj mk b">foo</code>字段。因此，如果我们试图编译上面的代码，我们会得到一个错误消息“类‘Person’错误地实现了接口‘Person interface’。类型“Person”中缺少属性“age”，但类型“PersonInterface”中需要该属性。</p><p id="1ca8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在我们实现了接口中的所有项之后，我们可以添加接口中未指定的额外项，并且TypeScript编译器将接受代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e717" class="mt lf it mk b gy mu mv l mw mx">interface PersonInterface {<br/>  name: string;    <br/>}</span><span id="5107" class="mt lf it mk b gy my mv l mw mx">class Person implements PersonInterface {    <br/>  name: string = 'Mary';  <br/>  age: number = 20;<br/>}</span></pre><p id="134a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码会被TypeScript编译器接受，因为我们在接口中有所有的东西，并且我们向类中添加了接口中没有的东西，这在TypeScript中是可以接受的。</p><p id="f745" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以用一个接口描述我们将在类中实现的方法。为此，我们可以在接口中添加方法签名及其返回类型，如下面的代码所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6079" class="mt lf it mk b gy mu mv l mw mx">interface PersonInterface {<br/>  name: string;<br/>  age: number;<br/>  setName(name: string): string;<br/>  setAge(age: number): number;<br/>}</span><span id="6d55" class="mt lf it mk b gy my mv l mw mx">class Person implements PersonInterface {    <br/>  name: string = 'Mary';  <br/>  age: number = 20;<br/>  setName(name: string) {<br/>    this.name = name;<br/>    return name;<br/>  }</span><span id="abf9" class="mt lf it mk b gy my mv l mw mx">  setAge(age: number) {<br/>    this.age = age;<br/>    return age;<br/>  }<br/>}</span></pre><p id="4479" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将在实现接口的类中实现的2个方法签名放在<code class="fe mh mi mj mk b">PersonInterface</code>中。我们有一个用于<code class="fe mh mi mj mk b">setName</code>方法的方法签名，还有一个用于<code class="fe mh mi mj mk b">setAge</code>方法的方法签名。在每个方法的括号内，我们指定了每个方法所需的参数。在<code class="fe mh mi mj mk b">setName</code>方法中，我们指定我们需要<code class="fe mh mi mj mk b">name</code>参数，并且是字符串类型。在<code class="fe mh mi mj mk b">setAge</code>方法中，我们指定我们有一个<code class="fe mh mi mj mk b">age</code>参数，并且是number类型。那是结肠左边的部分。在冒号的右边，我们有每个方法的返回类型。对于<code class="fe mh mi mj mk b">setName</code>方法，我们指定它返回一个字符串。在<code class="fe mh mi mj mk b">setAge</code>方法的签名中，我们指定它返回一个数字。</p><p id="a113" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">Person</code>类中，我们只是按照接口中的描述执行。所以我们添加了<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">age</code>字段，我们分别将它们指定为类型字符串和数字。然后我们添加<code class="fe mh mi mj mk b">setName</code>和<code class="fe mh mi mj mk b">setAge</code>方法，就像我们在<code class="fe mh mi mj mk b">PersonInterface</code>中概述的那样。请注意，方法参数中的类型指定是必需的，但返回类型不是必需的，因为它可以由TypeScript推断，但必须显式检查参数类型。这意味着，如果我们有类似下面这样省略了参数类型的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fa4a" class="mt lf it mk b gy mu mv l mw mx">interface PersonInterface {<br/>  name: string;<br/>  age: number;<br/>  setName(name: string): string;<br/>  setAge(age: number): number;<br/>}</span><span id="50d5" class="mt lf it mk b gy my mv l mw mx">class Person implements PersonInterface {    <br/>  name: string = 'Mary';  <br/>  age: number = 20;<br/>  setName(name) {<br/>    this.name = name;<br/>    return name;<br/>  }</span><span id="3d10" class="mt lf it mk b gy my mv l mw mx">  setAge(age) {<br/>    this.age = age;<br/>    return age;<br/>  }<br/>}</span></pre><p id="dafd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">则TypeScript编译器将拒绝代码，并显示错误消息“Parameter 'name '隐式具有' any '类型。(7006)<code class="fe mh mi mj mk b">setName</code>方法的“和”参数“年龄”隐含有“任何”类型。(7006)".正如我们从错误中看到的，没有附加类型指定的参数将被隐式指定为<code class="fe mh mi mj mk b">any</code>类型，这不是<code class="fe mh mi mj mk b">PersonInterface</code>中指定的类型。</p><p id="a9bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接口只描述了类的公共端，而不是公共端和私有端。这意味着我们不能用它来检查私有字段和方法。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c54ae269032f8d73f4923cabf2e18881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BBM6sbEInZZFaOrH"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@impatrickt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Patrick Tomasso </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f1d9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类的静态端与实例端</h1><p id="3dc1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在TypeScript中，接口只检查类的实例端，所以不检查任何与类的静态端相关的东西。例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6492" class="mt lf it mk b gy mu mv l mw mx">interface PersonInterface {<br/>  new (name: string, age: number);<br/>}</span><span id="5844" class="mt lf it mk b gy my mv l mw mx">class Person implements PersonInterface {    <br/>  constructor(name: string, age: number) {}<br/>}</span></pre><p id="310e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到错误“类‘Person’不正确地实现了接口‘Person interface’。类型“Person”不提供签名“new (name: string，age: number)”的匹配，因为类的静态端不能被接口检查，而<code class="fe mh mi mj mk b">constructor</code>在静态端。相反，我们必须为静态端的每个部分添加不同的接口。我们可以这样做，如下面的代码所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cef9" class="mt lf it mk b gy mu mv l mw mx">interface PersonConstructor {<br/>  new (name: string, age: number): PersonInterface;<br/>}</span><span id="b1eb" class="mt lf it mk b gy my mv l mw mx">interface PersonInterface {<br/>  name: string;<br/>  age: number;<br/>  greet(name: string): void;<br/>}</span><span id="4369" class="mt lf it mk b gy my mv l mw mx">const createPerson = (ctor: PersonConstructor, name: string, age: number): PersonInterface =&gt;{<br/>  return new ctor(name, age);    <br/>}</span><span id="1d4a" class="mt lf it mk b gy my mv l mw mx">class Person implements PersonInterface {    <br/>  name: string;<br/>  age: number;<br/>  constructor(name: string, age: number) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>  greet(name: string) {<br/>    console.log(`Hello ${this.name}. You're ${this.age} years old.`)<br/>  }<br/>}</span><span id="cf99" class="mt lf it mk b gy my mv l mw mx">let person = createPerson(Person, 'Jane', 20);<br/>console.log(person);</span></pre><p id="021f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mh mi mj mk b">PersonInterface</code>只有公共成员，分别是<code class="fe mh mi mj mk b">name</code>、<code class="fe mh mi mj mk b">age</code>和<code class="fe mh mi mj mk b">greet</code>方法。这迫使我们在我们的<code class="fe mh mi mj mk b">Person</code>类中实现这些成员。因为<code class="fe mh mi mj mk b">constructor</code>是一个静态成员，所以它不会被<code class="fe mh mi mj mk b">PersonInterface</code>检查。我们将检查留在<code class="fe mh mi mj mk b">createPerson</code>函数中。在<code class="fe mh mi mj mk b">createPerson</code>中，我们检查了<code class="fe mh mi mj mk b">ctor</code>参数是否正确实现了<code class="fe mh mi mj mk b">PersonConstructor</code>，因为我们在签名中使用了带有<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">age</code>参数的<code class="fe mh mi mj mk b">new</code>方法，并且我们检查了它是否返回了一个<code class="fe mh mi mj mk b">PersonInterface</code>，这意味着构造函数正在返回实现<code class="fe mh mi mj mk b">PersonInterface</code>的某个类的实例。上面的代码将被TypeScript编译器接受，因为我们检查静态端与实例端是分开的，因为我们创建了<code class="fe mh mi mj mk b">createPerson</code>来让我们检查静态端，也就是<code class="fe mh mi mj mk b">constructor</code>。</p><p id="a614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript的另一个强大特性是，我们可以使用接口来检查我们通过使用接口在类中实现了什么。这对于检查类的非静态成员很有用。然而，对于像<code class="fe mh mi mj mk b">constructor</code>这样的静态成员，我们必须在我们用来实现类的接口之外检查它们，因为它们不能像<code class="fe mh mi mj mk b">constructor</code>方法那样检查静态成员。</p></div></div>    
</body>
</html>