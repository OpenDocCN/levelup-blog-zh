<html>
<head>
<title>Learning Go: Various Array Processing Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Go:各种数组处理模板</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-various-array-processing-templates-865c6ba4627?source=collection_archive---------14-----------------------#2020-03-16">https://levelup.gitconnected.com/learning-go-various-array-processing-templates-865c6ba4627?source=collection_archive---------14-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1cde692b4c3975d87b9e45c8cd64574c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SUkni0wpOJM__VHb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@laughayette?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马腾纽霍尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="daba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上一篇文章展示了一些在Go中使用数组的编程模板。在本文中，我将介绍更多的模板。这些模板包括用于搜索数组、复制数组内容以及向数组中插入新元素的模板。</p><h1 id="af5c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">搜索数组模板</h1><p id="bde5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">可以使用简单的线性算法搜索一维数组。该算法从数组的第一个元素开始，检查是否匹配，如果匹配，则返回真值或元素位置，或者继续到下一个元素。算法结束，如果没有找到匹配，则返回一个<code class="fe mh mi mj mk b">false</code>值或一个<code class="fe mh mi mj mk b">-1</code>(一个无效的数组位置)。</p><p id="5ed0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用两个伪代码模板，一个用于布尔返回，另一个用于返回找到的元素的数组位置或-1的算法。以下是这两种可能性的伪代码，首先是布尔模板:</p><p id="b838" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">声明布尔变量并设置为假<br/>从第一个数组元素<br/>开始，而不是从最后一个数组元素开始:<br/>如果数组元素匹配搜索值:<br/>将布尔变量设置为真<br/>否则<br/>移动到下一个元素</em></p><p id="0ff1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个整数值的版本:</p><p id="548c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">将位置变量设置为-1 <br/>从第一个数组元素<br/>开始，而不是最后一个数组元素:<br/>如果数组元素与搜索值匹配:<br/>将位置变量设置为数组元素位置<br/>否则<br/>移动到下一个元素</em></p><p id="d304" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看如何在Go中实现这些模板。首先，这里是布尔变量版本:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="fd4c" class="mu lf it mk b gy mv mw l mx my">package main</span><span id="e372" class="mu lf it mk b gy mz mw l mx my">import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/> )</span><span id="8ea9" class="mu lf it mk b gy mz mw l mx my">func main() {<br/>  const size = 10;<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  var numbers[size] int<br/>  for i := 0; i &lt; size; i++ {<br/>    numbers[i] = rng.Intn(100)<br/>  }<br/>  fmt.Println(numbers)<br/>  var find int<br/>  found := false<br/>  fmt.Print("Enter a number to search for: ")<br/>  fmt.Scan(&amp;find)<br/>  for _, num := range numbers {<br/>    if find == num {<br/>      found = true<br/>    }<br/>  }<br/>  if found {<br/>    fmt.Println(find,"is in the array.")<br/>  } else {<br/>    fmt.Println(find,"is not in the array.")<br/>  }<br/>}</span></pre><p id="b2dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是整数位置版本:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="54e6" class="mu lf it mk b gy mv mw l mx my">package main</span><span id="90e3" class="mu lf it mk b gy mz mw l mx my">import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/>)</span><span id="759a" class="mu lf it mk b gy mz mw l mx my">func main() {<br/>  const size = 10<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  var numbers[size] int<br/>  for i := 0; i &lt; size; i++ {<br/>    numbers[i] = rng.Intn(100)<br/>  }<br/>  fmt.Println(numbers)<br/>  var find int<br/>  position := -1<br/>  fmt.Print("Enter a number to search for: ")<br/>  fmt.Scan(&amp;find)<br/>  for index, num := range numbers {<br/>    if find == num {<br/>      position = index<br/>    }<br/>  }<br/>  if position &gt; -1 {<br/>    fmt.Printf("%d is at position %d.\n", find, position)<br/>  } else {<br/>    fmt.Println(find,"is not in the array.")<br/>  }<br/>}</span></pre><p id="8c34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种类型的搜索称为线性搜索或顺序搜索，适用于小数据集，但对于大数据集效率很低。一个更有效的算法是二分搜索法算法，它需要一个排序的数组，但在数组中找到一个元素需要更少的比较。</p><h1 id="9530" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">复制数组模板</h1><p id="433a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有些情况下，您需要将一个数组的内容复制到另一个数组。您可以通过声明一个新的空数组，然后使用循环将现有数组的内容复制到新数组来实现这一点。该模板的伪代码如下所示:</p><p id="293f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">为旧数组的每个元素声明新数组<br/>:<br/>将元素复制到新数组的相同位置</em></p><p id="9a31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该模板的一个实现:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="9053" class="mu lf it mk b gy mv mw l mx my">package main</span><span id="aff5" class="mu lf it mk b gy mz mw l mx my">import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/>)</span><span id="5efe" class="mu lf it mk b gy mz mw l mx my">func main() {<br/>  const size = 10<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  var numbers[size] int<br/>  for i := 0; i &lt; size; i++ {<br/>    numbers[i] = rng.Intn(100)<br/>  }<br/>  var numbersCopy[size] int<br/>  for index, number := range numbers {<br/>    numbersCopy[index] = number<br/>  }<br/>  fmt.Println("Old array: ")<br/>  fmt.Println(numbers)<br/>  fmt.Println("Copied array: ")<br/>  fmt.Println(numbersCopy)<br/>}</span></pre><p id="043c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，复制数组的额外循环是不必要的。您可以简单地将旧数组分配给新数组，以复制旧数组。你不能在C++中这样做，因为它创建了旧数组的一个<em class="ml">浅拷贝</em>。使用浅层复制，如果原始数组中的一个元素被更改，新数组中该位置的元素也会被更改。</p><p id="44f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们上面所做的将原始数组复制到新数组的操作称为<em class="ml">深度复制</em>。如果我们在C++中执行这种复制，对原始数组的更改将不会反映在新数组中。</p><p id="5fb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Go中，通过赋值来复制数组会执行数组的深度复制，因此不需要逐个元素地复制，我们可以编写如下代码:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="a55f" class="mu lf it mk b gy mv mw l mx my">package main</span><span id="f3b9" class="mu lf it mk b gy mz mw l mx my">import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/>)</span><span id="1be6" class="mu lf it mk b gy mz mw l mx my">func main() {<br/>  const size = 10<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  var numbers[size] int<br/>  for i := 0; i &lt; size; i++ {<br/>    numbers[i] = rng.Intn(100);<br/>  }<br/>  numbersCopy := numbers<br/>  fmt.Println("Old array: ")<br/>  fmt.Println(numbers)<br/>  fmt.Println("Copied array: ")<br/>  fmt.Println(numbersCopy)<br/>}</span></pre><h1 id="68f7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将元素插入数组模板</h1><p id="171e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当您需要将数据元素插入数组时，可以使用该模板。当插入到一个数组中时，首先要找到想要插入新值的地方。然后将插入点右侧的所有值移动一个位置，为新值腾出空间。最后，在移位完成后，在移位后腾出的空间中插入新值。</p><p id="20c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模板的伪代码如下所示:</p><p id="330c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">(新值将被插入到集合中的位置p) <br/>将变量(I)设置为集合的最后一个元素的索引加1(k)<br/>当I大于p+1时重复:<br/>coll[I]= coll[I-1]<br/>coll[p]=新值<br/>将集合元素的编号加1</em></p><p id="7db9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用这个模板的问题。您有一组按数字顺序排列的成绩，您需要在这组成绩的中间添加一个成绩来保持顺序。下面是一个解决这个问题的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="df6d" class="mu lf it mk b gy mv mw l mx my">func main() {<br/>  const size = 20<br/>  last := 9<br/>  grades := [size] int {71,72,73,75,76,77,78,80,89,90}<br/>  fmt.Println(grades)<br/>  newGrade := 74<br/>  var start int<br/>  for index, grade := range grades {<br/>    if grade &gt; newGrade {<br/>      start = index<br/>      break<br/>    }<br/>  }<br/>  for i := last; i &gt;= start; i-- {<br/>    grades[i+1] = grades[i]<br/>  }<br/>  grades[start] = newGrade<br/>  fmt.Println(grades)<br/>}</span></pre><p id="5770" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个模板对于小数据集来说很好，但是对于大数据集来说效率非常低，因为如果插入点在大数据集的前半部分，就必须进行多次移动来为插入的元素打开一个槽。</p><p id="c479" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">必须进行大量插入和删除的问题的解决方案是使用不同的数据结构，比如链表，但这超出了本文的范围。</p><h1 id="a0b2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Go数组和切片</h1><p id="5168" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">数组是所有严肃的计算机编程语言中常见的数据结构。过去，数组是大多数编程入门课程中讨论的唯一数据结构。然而，这种情况已经发生了变化，因为大多数语言现在提供了一种更灵活的数据结构，其效率实际上与数组相同。在其他语言中，这是C++中的vector，或者Java或C#中的ArrayList，或者Python中的List。在Go中，这种更灵活的数据结构被称为切片，这将是我下一篇文章的主题。</p><p id="c915" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，如果您有任何意见或建议，请发邮件给我。</p></div></div>    
</body>
</html>