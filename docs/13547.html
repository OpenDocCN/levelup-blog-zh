<html>
<head>
<title>Angular Best Practices: The Container/Presenter Pattern Explained with Case Studies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度最佳实践:用案例研究解释容器/演示者模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-container-presenter-pattern-a8f27a541802?source=collection_archive---------7-----------------------#2022-09-15">https://levelup.gitconnected.com/angular-container-presenter-pattern-a8f27a541802?source=collection_archive---------7-----------------------#2022-09-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="676d" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">包含重构技巧的深度指南</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f0d07acd4d6fc17d3d95d3167a9cdfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3qlNXipDLpgfyjWOgeakA.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://pixabay.com//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5821903" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>(作者编辑)</figcaption></figure><p id="3f11" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我是在2020年夏天发现并爱上容器/呈现者模式的，然后我开始在我的Angular项目中使用它，并获得了非常满意的结果。</p><p id="4d3a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我一直在努力克服在我的组件中混合关注的问题，这违反了软件开发的许多原则，并且使得理解和维护源代码变得乏味。</p><p id="61e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是使用容器-呈现者模式帮助我通过将组件组织成类别来阐明它们的职责:</p><ul class=""><li id="7bac" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><strong class="lc iv">容器组件</strong>是智能组件。他们知道如何从政府和服务部门获取数据。它们通过输入和输出与子组件(表示组件)进行通信。</li><li id="5003" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv">表示组件</strong>负责呈现UI并管理与用户的交互。请记住，它们不应该总是被转储。如果您在容器及其子容器之间传递数据时，注意到组件树中有大量的输入&amp;输出，这表明您需要将服务注入到您的叶组件中，以缓解这个被称为<em class="mk">冒泡事件</em>的问题，并使代码设计更易于维护。</li></ul><h1 id="78b3" class="ml mm iu bd mn mo mp mq mr ms mt mu mv ka mw kb mx kd my ke mz kg na kh nb nc bi translated">赞成的意见</h1><p id="75aa" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">下面是使用该模式的一些好处:</p><ol class=""><li id="9d4d" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv ni mc md me bi translated">通过将组件拆分成更小的组件来清理代码。</li><li id="b17f" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ni mc md me bi translated">组件之间的职责分离。</li><li id="f69b" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ni mc md me bi translated">更好地理解工作流和组件之间的通信。</li><li id="e6c6" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ni mc md me bi translated">您可以使用<code class="fe nj nk nl nm b">async</code>管道指示Angular管理对<code class="fe nj nk nl nm b">Observable</code>的订阅和取消订阅。</li><li id="c614" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ni mc md me bi translated">为使用<code class="fe nj nk nl nm b">OnPush</code>变更检测提供一个更好的基础设施:从observable发出并由<code class="fe nj nk nl nm b">async</code>管道处理的新值将有新的引用→这是处理不变性问题的最佳方式。</li></ol><h1 id="9925" class="ml mm iu bd mn mo mp mq mr ms mt mu mv ka mw kb mx kd my ke mz kg na kh nb nc bi translated">个案研究</h1><p id="7ade" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">在下面的视频中，我将展示如何通过重构两个组件来应用容器/呈现者模式，这两个组件在开始时都有一些关注点。</p><ul class=""><li id="ce62" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">第一个组件是<code class="fe nj nk nl nm b">ScrumboardCardDetailsComponent</code>:这是一个在scrum板上显示卡片细节的对话框。它还允许更新卡的内容。</li><li id="ccc2" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">第二个组件是<code class="fe nj nk nl nm b">ScrumboardBoardComponent</code>:它代表一个scrum板，包含许多列表——像开放列表和进行中列表。每个列表包含一堆卡片。</li></ul><p id="7a6b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是一些截图，让您对所取得的成果有所了解:</p><div class="kk kl km kn gu ab cb"><figure class="nn ko no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><img src="../Images/90b9c739b19814b60456b6539345920c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*I4nWHqcBXDCl5WfNx6ohUQ.png"/></div></figure><figure class="nn ko nt np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><img src="../Images/bda1c011d43d0489e74cb9747094ac0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*OOIYi1SOtlc6OTsIdiwl6w.png"/></div></figure></div><div class="ab cb"><figure class="nn ko nu np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><img src="../Images/642139054c8ad65664ae6eb922522802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rKNOtKKi33MBJs-B53Jjig.png"/></div></figure><figure class="nn ko nv np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><img src="../Images/7531cb8a29792ee01405869715a79ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*e0e5-U_odL8mylSGtIehlQ.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk nw di nx ny translated">容器/呈现者模式重构之前/之后(作者截图)</figcaption></figure></div><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://www.youtube.com/watch?v=9HVGHdEofPI&amp;ab_channel=RakiaBenSassi%7CSoftwareEngineering" rel="noopener ugc nofollow" target="_blank">第1部分:使用容器呈现模式重构角度组件</a></figcaption></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://www.youtube.com/watch?v=9HVGHdEofPI&amp;ab_channel=RakiaBenSassi%7CSoftwareEngineering" rel="noopener ugc nofollow" target="_blank">第2部分:使用容器呈现模式重构角度组件</a></figcaption></figure></div><div class="ab cl ob oc hy od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="in io ip iq ir"><h1 id="a3d6" class="ml mm iu bd mn mo oi mq mr ms oj mu mv ka ok kb mx kd ol ke mz kg om kh nb nc bi translated">想要更多吗？</h1><ul class=""><li id="2051" class="lw lx iu lc b ld nd lg ne lj on ln oo lr op lv mb mc md me bi translated">我为一群聪明、好奇的🧠人写关于工程、技术和领导力的文章💡。<a class="ae kz" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank">加入我的免费电子邮件简讯，获得独家访问</a> <strong class="lc iv"> </strong>或在此注册Medium <a class="ae kz" href="https://rakiabensassi.medium.com/membership" rel="noopener">如果你还没有注册。</a></li><li id="ad1f" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv">加入8K+学员</strong>查看我的Udemy视频课程:<a class="ae kz" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/?couponCode=8F87E5E3936D469E121D" rel="noopener ugc nofollow" target="_blank">如何识别、诊断&amp;修复Web应用中的内存泄漏</a></li></ul></div></div>    
</body>
</html>