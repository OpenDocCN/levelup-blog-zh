<html>
<head>
<title>Antiforgery Tokens Behind The Scenes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幕后的防伪标记</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/antiforgery-tokens-behind-the-scenes-dcddda54db8a?source=collection_archive---------25-----------------------#2021-01-12">https://levelup.gitconnected.com/antiforgery-tokens-behind-the-scenes-dcddda54db8a?source=collection_archive---------25-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4043" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">防伪标记的工作原理。NET 5.0</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8314c07e5c5917cd77d3d05884d63d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gpi8XhKzenufEqkV"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">汤姆·温克尔斯在<a class="ae ky" href="https://unsplash.com/photos/I7oLRdM9YIw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="20ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将通过回答以下问题来讨论防伪标记是如何在幕后工作的:</p><ol class=""><li id="2f87" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何生成<strong class="lb iu"> cookie </strong> <strong class="lb iu">名称</strong>？</li><li id="224a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">cookie和HTML表单标记是如何生成的？</li><li id="e6fe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">令牌<strong class="lb iu">是如何验证的</strong>？</li></ol><p id="5c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该已经知道什么是防伪标志，以及如何在Asp.Net核心使用它们。</p><h2 id="3c61" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">跟着走</h2><p id="8403" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">您可以跳过这一部分，但是自己调试会更有趣。</p><p id="25a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会在这里展示所有的代码，但是这是一个非常简单的MVC应用程序，它有一个表单和一个发布表单的按钮。</p><p id="d835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以从我的<a class="ae ky" href="https://github.com/DavidKlempfner/AntiforgeryTest" rel="noopener ugc nofollow" target="_blank"> GitHub </a>账号下载代码。</p><p id="6a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保你设置了VS，让它以匿名模式打开Chrome，这样每次运行时cookie都是新鲜的。</p><p id="3019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用这些<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-debug-asp-net-core-source-code-448544c16473">指令</a>来调试。NET 5.0源代码。</p><h1 id="3bef" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">cookie名称是如何生成的？</h1><p id="03cd" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当您向设置为使用防伪令牌的后端发出POST请求时，以下cookie将随请求一起发送。</p><p id="dc3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">cookie名称是在<code class="fe ns nt nu nv b">=</code>之前的部分，之后的部分是值。</p><p id="1f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看那些随机字符是怎么产生的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/bf93c5b08f33963c10c2a1239af81515.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*mPVOx5C6ol_wmtNruUerBA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作为标题传递的防伪cookie</figcaption></figure><p id="f77e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神奇发生在<code class="fe ns nt nu nv b">AntiforgeryOptionsSetup.ComputeCookieName()</code>。</p><p id="dc14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码可以在<a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/AntiforgeryOptionsSetup.cs#L28" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="da08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">C76fbftIiNo</code>是从存储您的解决方案的文件夹路径生成的<strong class="lb iu">，它存储在<code class="fe ns nt nu nv b">applicationId</code>变量中。</strong></p><p id="07dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">流程为:</strong></p><ol class=""><li id="404f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将<code class="fe ns nt nu nv b">applicationId</code>转换为存储UTF8字节的字节数组。</li><li id="74d4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">取这个字节数组的SHA256哈希。</li><li id="fc40" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Base64URL对值进行编码，就是这样！</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/d5fea289dc43a3feb834d020cde08d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2SsWDPkYcYMdm8WtCwNjA.png"/></div></div></figure><p id="f42e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为该值是基于<code class="fe ns nt nu nv b">applicationId</code>的，所以应用程序的所有用户应该有相同的cookie名称。</p><h1 id="845b" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">cookie和HTML表单标记是如何生成的？</h1><p id="b681" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在下面的代码中，cookie标记被称为<code class="fe ns nt nu nv b">NewCookieToken</code>，HTML表单标记被称为<code class="fe ns nt nu nv b">NewRequestToken</code>。</p><p id="c2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神奇的事情发生在<a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/DefaultAntiforgery.cs/#L418" rel="noopener ugc nofollow" target="_blank">默认防伪。序列化()</a>。</p><p id="33f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤有:</strong></p><ol class=""><li id="70d4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用<a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/BinaryBlob.cs#L95" rel="noopener ugc nofollow" target="_blank">随机数发生器</a>构建一个字节数组。</li><li id="e159" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">基于步骤1生成一个<a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/DefaultAntiforgeryTokenSerializer.cs#L134" rel="noopener ugc nofollow" target="_blank">唯一数组</a>。</li><li id="cdf4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/DefaultAntiforgeryTokenSerializer.cs#L168" rel="noopener ugc nofollow" target="_blank">加密</a>数组。</li><li id="ff90" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在加密数组前添加一个<a class="ae ky" href="https://github.com/aspnet/Universe/blob/release/2.2/src/DataProtection/src/Microsoft.AspNetCore.DataProtection/KeyManagement/KeyRingBasedDataProtector.cs#L130" rel="noopener ugc nofollow" target="_blank">魔法头</a>和<code class="fe ns nt nu nv b">defaultKeyId</code>。</li><li id="1e22" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/DefaultAntiforgeryTokenSerializer.cs#L173" rel="noopener ugc nofollow" target="_blank"> Base64URL对加密数组进行编码</a>并将其用作令牌字符串。</li></ol><p id="cf11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上步骤用于构建<code class="fe ns nt nu nv b">NewCookieToken</code>和<code class="fe ns nt nu nv b">NewRequestToken. </code>，它们都重用了第一步中的同一个数组。</p><p id="a96d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的屏幕截图显示了“监视”窗口中用于输入的值，以及作为实际令牌字符串的最终输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/5d83424f294737bf0ad1bb3c36639d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evcZwy4dqamRgIFu3zAyJQ.jpeg"/></div></div></figure><p id="44e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看观察窗口，您可以看到<code class="fe ns nt nu nv b">NewRequestToken</code>和<code class="fe ns nt nu nv b">NewCookieToken</code>都有相同的字节数组，但是实际生成的令牌的值不同。</p><p id="9021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看是怎么回事。</p><ol class=""><li id="d93b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">使用随机数生成器构建一个字节数组</strong></li></ol><p id="09ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码可以在这里找到<a class="ae ky" href="https://github.com/dotnet/corefx/blob/master/src/System.Security.Cryptography.Algorithms/src/System/Security/Cryptography/RandomNumberGenerator.cs#L97" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="bd21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字节数组是使用一个随机数生成器在<a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/BinaryBlob.cs#L92\" rel="noopener ugc nofollow" target="_blank"> BinaryBlob中填充的。GenerateNewToken() </a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/d355655e1c4407ca13420552ebbbc4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*Nb0rv6UgFY-tk3gAUqvBDg.png"/></div></div></figure><p id="b58c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。基于步骤1 </strong>生成唯一数组</p><p id="5df7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码可以在<a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/DefaultAntiforgeryTokenSerializer.cs#L134" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="be5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步中的逻辑对于这两个令牌略有不同。</p><p id="8c4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，当存储在字节数组中时，任何空字符串和布尔值<code class="fe ns nt nu nv b">false</code>都被转换为0x00，而布尔值<code class="fe ns nt nu nv b">true</code>被转换为0x01。</p><p id="e084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新库克托肯</p><p id="702e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下内容创建一个新数组:</p><p id="9e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引0 </strong>:硬编码令牌版本01写入第一个字节。</p><p id="0bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引1到16 </strong>:来自步骤1的字节数组。</p><p id="bebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引17 </strong>:布尔值<code class="fe ns nt nu nv b">true</code> ( <code class="fe ns nt nu nv b">IsCookieToken</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/024cdc76ffc3b1689584beb150887166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iV0dHQiu-dlfJIsPGL9NGw.jpeg"/></div></div></figure><p id="e62d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">新请求令牌:</strong></p><p id="a780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下内容创建一个新数组:</p><p id="a879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引0 </strong>:硬编码令牌版本01写入第一个字节。</p><p id="557c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引1到16 </strong>:来自步骤1的字节数组。</p><p id="95eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引17 </strong>:布尔值<code class="fe ns nt nu nv b">false</code> ( <code class="fe ns nt nu nv b">IsCookieToken</code>)。</p><p id="726f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引18 </strong>:来自<code class="fe ns nt nu nv b">else</code>块的<code class="fe ns nt nu nv b">false</code>的布尔值。</p><p id="a172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引19 </strong>:空字符串(<code class="fe ns nt nu nv b">token.Username</code>)。</p><p id="0b2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引20 </strong>:空字符串(<code class="fe ns nt nu nv b">token.AdditionalData</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/e0bfc5eb4812f5c3e086485583627c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-o3fa6iRjt98fNeK5WLQw.jpeg"/></div></div></figure><p id="4831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。加密数组</strong></p><p id="59a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码可以在<a class="ae ky" href="https://github.com/aspnet/Universe/blob/release/2.2/src/DataProtection/src/Microsoft.AspNetCore.DataProtection/KeyManagement/KeyRingBasedDataProtector.cs#L117" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="9926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以把这个部分想象成一个黑匣子。这很复杂，但是您可以自行调试，以便更深入地了解它是如何加密的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/fd674aa160464e17a9727759ce2204a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*NRwE6huT2ovkNTVK0e59-Q.png"/></div></figure><p id="6807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4。在加密数组前添加一个magic头和defaultKeyId。</strong></p><p id="4db5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码可以在<a class="ae ky" href="https://github.com/aspnet/Universe/blob/release/2.2/src/DataProtection/src/Microsoft.AspNetCore.DataProtection/KeyManagement/KeyRingBasedDataProtector.cs#L130" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2cd88ed64cfbee344c12723578c9ca5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*8ZrEfb65jSDLdPoXcWQdoA.png"/></div></figure><p id="785f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">WriteBigEndianInteger()</code>方法将一个<code class="fe ns nt nu nv b">uint</code>写入加密数组。您可以看到下面的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/ee7b51088d9af474bf97b66bbeee4a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIt5uO6xQTb6Rf9kj05ACg.jpeg"/></div></div></figure><p id="ada4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看上面截图中的评论。您可以通过使用在线SHA1哈希生成器<a class="ae ky" href="https://passwordsgenerator.net/sha1-hash-generator/" rel="noopener ugc nofollow" target="_blank">来检查它是否真的是SHA1哈希:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/1ddbeabe9587c4720a69e58949c62364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*5dUCyiYClK-2wEVrEJDlGA.png"/></div></figure><p id="11da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">Write32bitAlignedGuid()</code>方法写一个GUID，指示使用了哪个加密密钥。</p><p id="956d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5。Base64URL对加密数组进行编码，并将其用作令牌</strong></p><p id="1b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码可以在<a class="ae ky" href="https://github.com/dotnet/aspnetcore/blob/master/src/Shared/WebEncoders/WebEncoders.cs#L259" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f2677c20f0236666dbb36ed0131f523a.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*R72IRWn0rZrQEs-6zIvaoA.png"/></div></figure><p id="27cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加密数组是Base64Url编码的，它返回一个字符串。这是最后的结果。</p><h2 id="c880" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">最终结果</h2><p id="716b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">您可以看到<code class="fe ns nt nu nv b">NewRequestToken</code>值被写入DOM，并将与HTTP POST的主体一起发送。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/f03e43dd882511b1dbeb8c74c35014a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7qOD_e7CE9g-LD8Kdtd2A.png"/></div></div></figure><p id="8337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当发出POST请求时，您可以在标题中看到<code class="fe ns nt nu nv b">NewCookieToken</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ecb94a2f1b6638bf8154f9d38f8c17ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fR3O6k55fda79NKBrXM1Hg.png"/></div></div></figure><h1 id="240c" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">身份cookie</h1><p id="f453" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">您是否注意到<code class="fe ns nt nu nv b">NewRequestToken</code>和<code class="fe ns nt nu nv b">NewCookieToken</code>中的前26个字符是相同的？这是因为它只是魔术头，加密密钥ID base64URL编码，这在生成两个令牌时是相同的。</p><p id="7ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来AspNetCore使用了相同的代码。应用程序cookie，如果你的应用程序使用身份。</p><p id="fb86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么你的AspNetCore？身份。应用程序和防伪cookies将具有相同的前26个字符。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/563bc1de1abf4b515d23219f0aecafe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OE3obGVqM0K7R4dw"/></div></div></figure><h1 id="35b6" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">令牌是如何验证的？</h1><p id="3341" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">该过程本质上与生成过程完全相同，只是相反。</p><p id="5e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令牌被去除了魔术头和加密密钥ID。剩下的是加密的、随机生成的字节数组。</p><p id="fbc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些数组被解密。</p><p id="4fc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为使用了相同的随机生成的字节数组来生成cookie和HTML表单标记，所以只要生成的未加密数组相同，就会验证标记并处理HTTP请求。</p><p id="b7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是进行<a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/DefaultAntiforgeryTokenGenerator.cs#L143" rel="noopener ugc nofollow" target="_blank">验证的代码块</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/2aeac879f5aaad53cb095160c6a4590a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*P6ftxQUGfrHwg7nwr9ugSQ.png"/></div></figure><h1 id="8f72" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">发送多个请求</h1><p id="2dde" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">上面已经向您展示了在第一个HTTP请求期间会发生什么。</p><p id="7eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">刷新页面会怎么样？</strong></p><p id="5f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相同的cookie将被发送给后续的请求，但是HTML表单令牌在每次页面加载时都是不同的。</p><p id="0aa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果重新加载页面，则通过解密cookie提取随机生成的数组。</p><p id="6bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后像以前一样，使用这个数组来生成HTML表单的令牌。由于<code class="fe ns nt nu nv b">CbcAuthenticatedEncryptor</code>类中的一些<a class="ae ky" href="https://github.com/aspnet/DataProtection/blob/88a191f0f348a1eae467a906048e6adcac5f9cc3/src/Microsoft.AspNetCore.DataProtection/Cng/CbcAuthenticatedEncryptor.cs#L311" rel="noopener ugc nofollow" target="_blank">随机化</a>，你每次都会得到一个新的HTML表单标记字符串。</p><p id="c43a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么，如果你不断刷新页面，你会看到<strong class="lb iu"> cookie标记保持不变</strong>，而<strong class="lb iu"> HTML表单标记每次都不一样</strong>，但两者的前26个字符总是相同的。</p><h2 id="e4b4" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">一个防伪标记可以有多少种不同的值？</h2><p id="6a6f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">要深入了解防伪令牌值背后的统计数据，请阅读这篇文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/possible-values-for-antiforgery-tokens-d1adecb93db5"/>。</p></div></div>    
</body>
</html>