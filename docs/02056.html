<html>
<head>
<title>How I Structure Cloud Functions in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在Go中构造云函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-structure-cloud-functions-in-go-61e151b278ac?source=collection_archive---------3-----------------------#2020-02-16">https://levelup.gitconnected.com/how-i-structure-cloud-functions-in-go-61e151b278ac?source=collection_archive---------3-----------------------#2020-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3d83b2c3958de705e8be6f80164e59fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpKBk1fH7zXN09ng7H_Kpg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在Go中部署云功能</figcaption></figure><blockquote class="kf kg kh"><p id="bd66" class="ki kj kk kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这篇文章也发表在<a class="ae lh" href="https://rizwaniqbal.com/posts/how-i-structure-cloud-functions-in-go/" rel="noopener ugc nofollow" target="_blank">https://rizwaniqbal . com/posts/how-I-structure-cloud-functions-in-go/</a></p></blockquote></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="3121" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">去年Golang第一次发布测试版时，我就开始在其中部署云功能。云函数的Go运行时支持目前支持Go版本1.11.6和Go版本1.13.1 (Beta)。这是最稳定的，在过去6个月的生产运行中，我遇到了一些“啊哈”的时刻，如果我有一个像我现在写的这样的指南，我就可以避免。因此，这篇文章更多的是关于旅程和我现在使用的结构，在迭代了一些不同的技术之后。</p><h1 id="59ac" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">语境</h1><p id="7ca6" class="pw-post-body-paragraph ki kj it kl b km mq ko kp kq mr ks kt lp ms kw kx lq mt la lb lr mu le lf lg im bi translated">我使用云函数来处理小的日常任务，有时来自客户端，有时作为Google PubSub主题的订阅者。所以，我同时部署了<a class="ae lh" href="https://cloud.google.com/functions/docs/writing/background" rel="noopener ugc nofollow" target="_blank">后台函数</a>和<a class="ae lh" href="https://cloud.google.com/functions/docs/writing/http" rel="noopener ugc nofollow" target="_blank"> HTTP函数</a>。所有调用都需要一个服务帐户或一个已登录的firebase用户，并且是安全的。考虑到调用函数的次数是要收费的，这些限制是在安全环境中运行所必需的。</p><p id="fab7" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">关于冷函数调用和热启动也有一些警告。大多数情况下，您的函数已经在实例中运行，并准备好响应触发器，但是，有时您的函数可能由于以下原因而处于“冷状态”:</p><ul class=""><li id="fb4c" class="mv mw it kl b km kn kq kr lp mx lq my lr mz lg na nb nc nd bi translated">您的功能已经部署，但尚未触发。</li><li id="a683" class="mv mw it kl b km ne kq nf lp ng lq nh lr ni lg na nb nc nd bi translated">您的函数已经空闲了足够长的时间，可以被回收以释放资源。</li><li id="e962" class="mv mw it kl b km ne kq nf lp ng lq nh lr ni lg na nb nc nd bi translated">您的功能是自动扩展以创造容量。</li></ul><p id="3f88" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">所有这些都需要仔细考虑您需要在函数中包含哪些依赖项，以及您需要在<code class="fe nj nk nl nm b">init()</code>方法中放置什么，以确保您在那里完成所有繁重的计算和初始化。</p><blockquote class="kf kg kh"><p id="59a5" class="ki kj kk kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">考虑到这一点，让我们开始着手处理手头的问题。我们需要以冷启动时间短的方式构建云功能。我们可以在本地运行该函数，如果需要，我们可以定义私有依赖关系。</p></blockquote><h1 id="de21" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">过程</h1><p id="f6a2" class="pw-post-body-paragraph ki kj it kl b km mq ko kp kq mr ks kt lp ms kw kx lq mt la lb lr mu le lf lg im bi translated">因此，我们有一套标准和界限，我们必须按照这些标准和界限来运作，以充分利用我们的云功能。</p><p id="84d3" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">我最初的方法是将我所有的功能放在一个存储库中，如果一些常见的依赖关系发生变化，就用部署脚本来部署它们。你可以想象，当我达到第五个函数的时候，事情变得一团糟。除了在这样一个共享代码库中你通常会做的噩梦之外，我不想重复大量代码的诚实意图现在已经在我试图复制文件时结束了，因为你需要部署所有的依赖项以及每个函数。如果你有用于初始化的公共代码，你将会把它复制到你所有的函数中。</p><p id="8c6c" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">像任何正常的Go开发人员一样，我决定在同一个存储库中创建一个我自己的包，并将该包导入到我的函数中，但是这也不起作用，因为您需要上传整个包目录和所有其他云函数，因为您上传的是整个根文件夹。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="b258" class="nv lt it nm b gy nw nx l ny nz">// crappy idea</span><span id="6bb9" class="nv lt it nm b gy oa nx l ny nz">|-- pkg<br/>    |<br/>    |-- common code<br/>|-- function1<br/>    |-- function code<br/>|-- function2<br/>    |-- function code</span></pre><p id="172e" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">因此，我做了下一件明智的事情，创建一个模块，并从一个必须是私有的外部存储库中导入这个模块。对于那些研究围棋的人来说，你已经知道模块是如何工作的，供应商模式是什么，我就不赘述了，如果你需要了解更多，你可以通读<a class="ae lh" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank">https://blog.golang.org/using-go-modules</a>。这导致了一个新的问题，因为如果您有私有存储库，cloud deploy将无法提取这些模块，您需要使用供应商模式。这很容易解决，在这里<a class="ae lh" href="https://cloud .google.com/functions/docs/writing/specifying-dependencies-go" rel="noopener ugc nofollow" target="_blank">有详细的记录</a>。</p><p id="499c" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">有了这个，我找到了一个为我工作了一段时间的结构。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="abd3" class="nv lt it nm b gy nw nx l ny nz">.<br/>├── README.md<br/>├── cmd<br/>│   ├── func1<br/>│   │   └── main.go<br/>│   ├── func2<br/>│   │   └── main.go<br/>├── deploy.sh<br/>├── go.mod<br/>├── go.sum<br/>├── pkg<br/>│   ├── func1<br/>│   │   ├── func1.go<br/>│   │   ├── someInit.go<br/>│   │   ├── go.mod<br/>│   │   ├── go.sum<br/>│   │   └── vendor<br/>│   ├── func2<br/>│   │   ├── func2.go<br/>│   │   ├── someInit.go<br/>│   │   ├── go.mod<br/>│   │   ├── go.sum<br/>│   │   └── vendor</span></pre><p id="e02a" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">这种结构有其自身的问题。首先，同一个存储库中的多个go.mod文件使得几乎不可能在本地测试这些功能。我在本地使用这种结构的过程是:</p><ul class=""><li id="137b" class="mv mw it kl b km kn kq kr lp mx lq my lr mz lg na nb nc nd bi translated">签出到不同的分支</li><li id="ed81" class="mv mw it kl b km ne kq nf lp ng lq nh lr ni lg na nb nc nd bi translated">推动分支机构的职能转变</li><li id="774b" class="mv mw it kl b km ne kq nf lp ng lq nh lr ni lg na nb nc nd bi translated">在<code class="fe nj nk nl nm b">cmd/</code>包内运行<code class="fe nj nk nl nm b">go get -d func1@branchName</code></li><li id="ef75" class="mv mw it kl b km ne kq nf lp ng lq nh lr ni lg na nb nc nd bi translated">继续运行本地服务器进行测试</li></ul><p id="e434" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">这连同<code class="fe nj nk nl nm b">deploy.sh</code>对我来说很麻烦。多个go.mod造成了很大的破坏，我当时想要为不同的函数使用不同的环境变量。然而，所有这些函数共享一个我不想重写的公共初始化脚本。</p><h1 id="cd70" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">该结构</h1><p id="d09f" class="pw-post-body-paragraph ki kj it kl b km mq ko kp kq mr ks kt lp ms kw kx lq mt la lb lr mu le lf lg im bi translated">我现在最终得到的东西，帮助我更快地编码和部署，易于测试，并且易于在本地运行。我做的第一件事是将每个功能拆分到它自己的存储库中。为此，所有的初始化代码被打包到一个外部包中。</p><p id="c074" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">这是我现在的函数结构:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="be9e" class="nv lt it nm b gy nw nx l ny nz">.<br/>├── README.md<br/>├── .env.yaml<br/>├── .gcloudignore<br/>├── cmd<br/>│   └── main.go<br/>├── deploy.sh<br/>├── functions.go<br/>├── FunctionOne.go<br/>├── FunctionOne_test.go<br/>├── go.mod<br/>├── go.sum<br/>└── vendor</span></pre><p id="361f" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">我有一个functions.go，可以在冷启动的情况下初始化依赖关系。每次调用一个函数时，这些都会被重用。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="6205" class="nv lt it nm b gy nw nx l ny nz">// functions.go</span><span id="472f" class="nv lt it nm b gy oa nx l ny nz">// Package function is the package that houses my cloud function<br/>package function</span><span id="9a34" class="nv lt it nm b gy oa nx l ny nz">import (<br/>        "context"<br/>        "encoding/json"<br/>        "fmt"<br/>        "io/ioutil"<br/>        "log"<br/>        "net/http"<br/>        "os"</span><span id="49f7" class="nv lt it nm b gy oa nx l ny nz">        "github.com/automaticalldramatic/mypackage"<br/>)</span><span id="0983" class="nv lt it nm b gy oa nx l ny nz">// projectID is set from the GCP_PROJECT environment variable, which is<br/>// automatically set by the Cloud Functions runtime.<br/>var envVar = os.Getenv("SOME_VAR")</span><span id="f14f" class="nv lt it nm b gy oa nx l ny nz">var (<br/>	client *mypackage.Client<br/>	logger *log.Logger<br/>)</span><span id="4b7f" class="nv lt it nm b gy oa nx l ny nz">func init() {<br/>        // err is pre-declared to avoid shadowing client.<br/>        var err error<br/>        <br/>        logger = log.New(os.Stdout, "[Timefox::Function::"+funcName+"]", log.LstdFlags)<br/></span><span id="c236" class="nv lt it nm b gy oa nx l ny nz">        // client is initialized with context.Background() because it should<br/>        // persist between function invocations.<br/>        client, err = mypakcage.NewClient(context.Background(), envVar)<br/>        if err != nil {<br/>                logger.Fatalf("something: %v", err)<br/>        }<br/>}</span></pre><p id="08e4" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">外部包也有重试和不重试特定情况的错误代码。当您正在编写后台函数，并且不希望某些场景在执行出错时重试时，这些是很重要的。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="b953" class="nv lt it nm b gy nw nx l ny nz">&amp;package.ErrorResponse{<br/>    Error:   errors.New("400 - Bad Request"),<br/>    Message: "You are not welcome here, my dear",<br/>    Code:    http.StatusNoContent, // we don't retry the message with a 204<br/>}</span></pre><p id="8529" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">为了在本地运行这个函数，我用一个主文件创建了一个命令模块。通常看起来是这样的:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="9f9b" class="nv lt it nm b gy nw nx l ny nz">// cmd/main.go</span><span id="29b2" class="nv lt it nm b gy oa nx l ny nz">package main</span><span id="28bd" class="nv lt it nm b gy oa nx l ny nz">import (<br/>	"log"<br/>	"net/http"<br/>	"net/http/httputil"</span><span id="11e2" class="nv lt it nm b gy oa nx l ny nz">	"github.com/gorilla/mux"</span><span id="2064" class="nv lt it nm b gy oa nx l ny nz">	"github.com/automaticalldramatic/server"</span><span id="a787" class="nv lt it nm b gy oa nx l ny nz">	function "github.com/automaticalldramatic/function-module"<br/>)</span><span id="05a7" class="nv lt it nm b gy oa nx l ny nz">func main() {</span><span id="b62e" class="nv lt it nm b gy oa nx l ny nz">	options := server.DefaultOptions<br/>	options.Address = ":8080"<br/>	s := server.NewServer(options)</span><span id="1e3d" class="nv lt it nm b gy oa nx l ny nz">	r := mux.NewRouter()</span><span id="4ae0" class="nv lt it nm b gy oa nx l ny nz">	log.Printf("server started on: %s", options.Address)<br/>	<br/>	r.Use(VerifyHTTPRequest)</span><span id="ef51" class="nv lt it nm b gy oa nx l ny nz">	r.HandleFunc("/function/method", function.FunctionName)<br/>	s.Handler = r<br/>	log.Fatal(s.ListenAndServe())<br/>}</span></pre><p id="c2bb" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">这有助于我在本地测试并应用中间件来检查我的身份验证令牌。</p><h1 id="bf24" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">部署</h1><p id="42eb" class="pw-post-body-paragraph ki kj it kl b km mq ko kp kq mr ks kt lp ms kw kx lq mt la lb lr mu le lf lg im bi translated">我使用<code class="fe nj nk nl nm b">.gcloudignore</code>来忽略go.mod文件，因为由于私有包，我使用的是出售模式。如果你愿意，你可以跳过这一步，但是拥有其中一个被认为是很好的实践。</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="394f" class="nv lt it nm b gy nw nx l ny nz"># For more information, run:<br/>#   $ gcloud topic gcloudignore<br/>#<br/>.gcloudignore<br/>deploy.sh</span><span id="c8dd" class="nv lt it nm b gy oa nx l ny nz">.env.yaml</span><span id="12a5" class="nv lt it nm b gy oa nx l ny nz">go.mod<br/>go.sum</span></pre><p id="da3c" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated"><code class="fe nj nk nl nm b">deploy.sh</code>可以被任何配置项替换。将<code class="fe nj nk nl nm b">.env.yaml</code>添加到<code class="fe nj nk nl nm b">.gitignore</code>和<code class="fe nj nk nl nm b">.gcloudignore</code>中，并且仅用于本地部署。当您使用CI设置时，您最好将env变量和秘密添加到您的CI中。</p><p id="59d7" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">然而，这是我使用环境文件从我的本地部署文件部署该函数所运行的基本内容:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="75ac" class="nv lt it nm b gy nw nx l ny nz">gcloud functions deploy FunctionName --entry-point FunctionName --trigger-http  --region europe-west1 --runtime go113<br/> --env-vars-file ./.env.yaml  --clear-labels --update-labels version=someVersion</span></pre><div class="ob oc gp gr od oe"><a href="https://github.com/agilefoxHQ/go-function-template" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">GitHub-agile fox HQ/go-function-template</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">该函数是使用“agilefoxhq/go-template-function”存储库生成的。这是一个谷歌云函数写的…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os jz oe"/></div></div></a></div><p id="ab1f" class="pw-post-body-paragraph ki kj it kl b km kn ko kp kq kr ks kt lp kv kw kx lq kz la lb lr ld le lf lg im bi translated">我希望这有助于您部署和维护您的云功能。如果您需要进一步的帮助，文档—https://cloud . Google . com/functions/docs/how-to非常好，几乎涵盖了所有的用例。</p></div></div>    
</body>
</html>