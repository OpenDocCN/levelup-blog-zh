<html>
<head>
<title>Résumé analysis with zero shot classification, nltk feature extraction, the quirks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">零镜头分类简历分析，nltk特征提取，怪癖</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/r%C3%A9sum%C3%A9-analysis-with-zero-shot-classification-nltk-feature-extraction-the-quirks-d789425a2d59?source=collection_archive---------5-----------------------#2022-08-06">https://levelup.gitconnected.com/r%C3%A9sum%C3%A9-analysis-with-zero-shot-classification-nltk-feature-extraction-the-quirks-d789425a2d59?source=collection_archive---------5-----------------------#2022-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a48f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CV解析是一个问题陈述，迫切需要能够灵活处理模糊复杂性挑战的解决方案。CV格式令人讨厌的模糊性加剧了这种情况，导致文本混乱，从而阻碍了一致解析<br/>以识别特定数据元素的尝试。</p><p id="28e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这篇文章试图研究一些策略，这些策略可能会提供访问路径，为解析练习的随机性带来一些方法上的相似性。在和一些NLP库调情的时候。</p><p id="a352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数简历解析文章提出使用正则表达式来筛选凝结的大量单词(在PDF/DOC到文本转换之后)以获得电子邮件、数字、技能等。本文中的方法旨在分离简历中的句子，然后分析每个句子以确定上下文，它是否包含工作经历简介/公司名称、技能组合、雇佣期或只是项目/责任的任意文本描述等。</p><p id="04ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为机器学习非常擅长处理的文本分类练习奠定了基础。请注意，这篇文章的目的仅仅是介绍用ML解决这个问题的替代方法——构建一个完整的产品级解析器的最终选择将需要大量的微调，并且可能涉及各种方法的组合。</p><p id="3b57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们把一个标准的简历切成几行，每一行都要进行分类。</p><p id="f3b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我倾向于使用零镜头分类进行第一次尝试，这基本上是NLP分类，很少或没有任何数据集的训练。这是为了避免繁琐的任务，即必须创建带有手动注释的训练数据或使预解析的样本与类别匹配。</p><p id="a8f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在快照中，零镜头学习是指应用预先训练的分类器模型在它从未见过的文本序列上运行。零距离分类器是基于NLI(自然语言推理)的原则，在一个句子中，这意味着解释一个序列来限定(遵循)或否定一个假设(指的是一个类别)。简而言之，这意味着我们可以通过零命中率分类器运行任何文本样本，同时为其提供一些预定义的类和预先训练的模型，如BART或Roberta，以查看分类器预测的句子类型。</p><p id="af46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是让我们先写代码，然后再谈…看看几行zero shot是如何对CV句子进行快速分类的。</p><p id="44f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Requirements.txt来安装必要的库…前提假设是熟悉python和regex。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="42cd" class="ku kv iq kq b gy kw kx l ky kz">numpy<br/>pdfminer.six<br/>transformers[torch]<br/>nltk</span></pre><p id="3443" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用的库是HuggingFace Transformers，为了CPU友好，用一个较小的模型代替。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="eb47" class="ku kv iq kq b gy kw kx l ky kz">import re<br/>import numpy as np<br/>from pdfminer.high_level import extract_text<br/>from transformers import pipeline</span><span id="d6f6" class="ku kv iq kq b gy la kx l ky kz">labels = ["date range or time period", "name of organization or company", "job title or designation", "programming languages", "software libraries", "educational institutes", "academic qualifications",  "project description"]<br/>classifier = pipeline("zero-shot-classification",  model='cross-encoder/nli-distilroberta-base')</span><span id="f5b6" class="ku kv iq kq b gy la kx l ky kz">def zero_shot_test(cv):<br/>    cvtext = extract_text(cv)<br/>    for text in cvtext.split("\n"):<br/>        text = text.strip()<br/>        text = re.sub("^[^A-Za-z0-9]","",text) <br/>        token_arr = re.split("(\t+|\s{4}|\|+|:)\s*", text) # a crude hack to split lines that have employment dates and company names in the same line<br/>        for token in token_arr:<br/>            token = token.strip()<br/>            token = re.sub("^[^A-Za-z0-9]","",token)<br/>            if len(token) &gt; 0:<br/>                res = classifier(token, labels)<br/>                res_label = res["labels"][np.argmax(res["scores"])]<br/>                print(f'text {token} is categorized as { res["labels"][np.argmax(res["scores"])] }')</span><span id="261b" class="ku kv iq kq b gy la kx l ky kz">zero_shot_test("SomeCV.pdf")</span></pre><p id="f55c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一些输出示例-</p><p id="32f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-设计、开发、修改、维护和改进网络应用程序和移动应用程序。被归类为<em class="lb">项目描述</em><br/>——React-Native、ReactJS、NodeJS、Android studio、Xcode框架等技术。被归类为<em class="lb">编程语言</em><br/>——HTML、CSS、C++、JAVA、jQuery、Bootstrap、Git。被归类为<em class="lb">编程语言</em><br/>——Oracle、MySQL、MongoDB。被归类为<em class="lb">软件库</em> <br/> -可视化代码、Android studio、XCode、Chrome调试、Postman被归类为<em class="lb">编程语言</em><br/>-2018年5月-工作被归类为<em class="lb">日期范围或时间段</em><br/>-6月-9月18日被归类为<em class="lb">日期范围或时间段</em> <br/> -国际科学奥林匹克银牌。被归类为<em class="lb">学历</em><br/>-B . sc . 2018年以74.01%的成绩从{编校}信息技术学院毕业。被归类为<em class="lb">教育机构</em><br/>-03/2019-目前被归类为<em class="lb">日期范围或时间段</em> <br/> - JavaScript、Python、C++、HTML、CSS被归类为<em class="lb">编程语言</em> <br/> -计算机科学B.Tech被归类为<em class="lb">学历</em></p><p id="4aee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我觉得这是个不错的开端。进一步的步骤可以将这些分类的行提供给熟练的正则表达式解析器，以提取我们需要的精确CV数据元素。<br/>但这里有几个失误——<br/>与现有客户和新客户密切合作，了解被归类为<em class="lb">组织或公司的名称</em>。！！</p><p id="b278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，人们总是可以通过微调预训练的变压器模型来采取另一种分类方法，但如果需要进一步追求零命中率，则可以通过对我们提供给分类器的标签进行文本调整来提高命中率，使它们更好地与样本句子的更明显总结保持一致。</p><p id="90c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是现在我们将把这个主题留在这里，因为我们将改变话题，尝试另一种方法，这种方法将使我们对分类练习有更多的控制。</p><p id="5572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将尝试通过特征提取进行文本分类，回到比HuggingFace更简单的库，以及在特征定义后进行分类训练的更基本的方法。</p><p id="adb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们用NLP学者的宠儿nltk测试了(相对较浅的)水域。老实说，这不是最好的选择，但目标是尝试操作将决定分类练习的特征。</p><p id="eea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，这是一个简单的函数，它将一个样本行作为输入，并为该样本构建有资格作为“特征”的内容。关于特征构建的快速脚注:<br/>如下面的函数所示，它定义了哪些特征与确定句子的类别相关，以及如何对这些特征进行编码——在这种情况下，我们创建了一个具有简单关键字的特征字典，这些关键字确定句子样本的上下文。这导致分类器，在我们的例子中是一个相对幼稚的朴素贝叶斯，来确定句子的类别。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="00c4" class="ku kv iq kq b gy kw kx l ky kz">def cv_features(sentence):<br/>    features = dict()<br/>    edu_pattern=r'([A-Z][a-z]+\s*(University|School|College))|((University|School|College)\s*[A-Z][a-z]+)'<br/>    date_grammar = r"""<br/>    DT: {&lt;IN|JJ|NN|NNP&gt;&lt;CD&gt;&lt;.*&gt;?&lt;NN|NNP&gt;&lt;CD&gt;}<br/>        {&lt;CD&gt;&lt;CD&gt;&lt;.*&gt;?&lt;CD&gt;&lt;CD&gt;}<br/>    """<br/>    tokens = nltk.word_tokenize(sentence)<br/>    tokens = [x for x in tokens if x not in stop_words ]<br/>    if re.search('([A-Za-z0-9]+\s*,\s*){2,}',sentence):<br/>        tokens = [ x for x in tokens if x != ',' ]<br/>    tags = nltk.pos_tag(tokens)<br/>    # chunking of POS tags to identify noun chunks and consequent NER's i.e. ORGANIZATION or DATE etc..<br/>    ne_list =  [ (x[0][1], x.label())  for x in nltk.chunk.ne_chunk(tags) if hasattr(x, "label") ]<br/>    if any (True for x in tokens if x.lower() in skills_set):<br/>        features["technologies"] = True<br/>        return features</span><span id="5667" class="ku kv iq kq b gy la kx l ky kz">    if any (True for (pos, label) in ne_list if label == 'ORGANIZATION' and pos == 'NNP'):<br/>        features["organization"] = True<br/>    if re.search(edu_pattern, sentence, re.IGNORECASE):<br/>        features["educational institute"] = True<br/>    if any (True for (pos, label) in ne_list if label == 'DATE' ):<br/>        features["date"] = True<br/>    if (not features):<br/>        # RegExpParser works on groups of POS tags to match<br/>        cp = nltk.RegexpParser(date_grammar)<br/>        tree = cp.parse(nltk.pos_tag(nltk.word_tokenize(re.sub(r'[^A-Za-z0-9]',' ', sentence))))<br/>        for subtree in tree.subtrees():<br/>            if hasattr(subtree, "label") and subtree.label() == "DT":<br/>                features["date"] = True<br/>    if (not features):<br/>        features["description"] = True</span><span id="c020" class="ku kv iq kq b gy la kx l ky kz">return features</span></pre><p id="0a42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是基本的函数和简单的正则表达式，用于检查句子是否包含日期？正如RegExpParser的分块练习所定义的那样。老实说，虽然分块使用POS标签来匹配我们想要的，但我更喜欢使用普通的正则表达式来检测日期，因为它更容易预测。<br/> nltk POS并不总是可靠的，因为月份名称可以被解释为NN、NNP甚至JJ(名词或形容词)。不太可靠，但这里的目的还是演示特性构建。<br/>——类似地，我们使用普通的正则表达式或带有nltk的NER标签来窥探教育机构和公司名称——简单的东西。<br/> -技术名称可以使用一组技术样本进行匹配，如</p><p id="3018" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le kq b">skills_set = set([‘java’,’c++’,’c’,’python’,’javascript’,’cassandra’,’julia’, ‘oracle’,’mongodb’,’.net’……………..])</code></p><p id="69b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成特征定义后，让我们训练一个样本语料库-</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="b810" class="ku kv iq kq b gy kw kx l ky kz">def train_corpus():<br/>    global classifier<br/>    train_arr=[]<br/>    fp = open('cv_train_data.csv', 'r')<br/>    for x in fp:<br/>        rec = x.split(",")<br/>        train_arr.append(( ",".join(rec[0:-1]), rec[-1:][0].strip() ))<br/>    featuresets = [(cv_features(txt), category) for (txt, category) in train_arr]<br/>    classifier = nltk.NaiveBayesClassifier.train(featuresets)</span></pre><p id="64c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">训练用的是平原。CSV文件，带有CV线样本和它的类别，简单如- <br/> <code class="fe lc ld le kq b">Jan 2019-Feb 2022,dates<br/>C, Python, Java, .net, technologies<br/>won 3rd prize in chess competition, description<br/>IBM Corp.,organization ........</code></p><p id="9d8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，这只是一个非常简单的列表，您可以将其扩展为一个包含更多类别的完整列表，但是特征提取将需要筛选文本中反映这些附加类别的元素。</p><p id="3800" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用一个样本CV运行这个，使用与零镜头完全相同的块——只是替换零镜头分类的2行</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="297d" class="ku kv iq kq b gy kw kx l ky kz">    res = classifier(token, labels)<br/>    res_label = res["labels"][np.argmax(res["scores"])]<br/>    print(f'text {token} is categorized as { res["labels"][np.argmax(res["scores"])] }')</span></pre><p id="454c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="be26" class="ku kv iq kq b gy kw kx l ky kz">    res = classifier.classify(cv_features(token))<br/>    print(f'text {token} is categorized as { res }')</span></pre><p id="eb08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后看一些结果输出，如果我们注意到的话，它比零炮运行要快得多</p><p id="0f51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React-Native，ReactJS，NodeJS，JavaScript，Clojurescript，SQL，NOSQL。C被归类为<em class="lb">技术</em> <br/> HTML，CSS，C++，JAVA，jQuery，Bootstrap，Git。被归类为<em class="lb">技术</em><br/>2014年6月-2018年6月被归类为<em class="lb">日期</em><br/>2016年9月—2017年10月被归类为<em class="lb">日期</em> <br/> B.Sc.IT于2018年以74.01%的成绩从{ Redacted }信息技术学院毕业。被归类为<em class="lb">教育学院</em> <br/>时间监控应用程序就像一个生物识别应用程序，雇主每天进出被归类为<em class="lb">描述</em></p><p id="fd35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一些真正的大失误——<br/>React——Native、ReactJS、NodeJS、Android studio、Xcode框架等技术。被归类为<em class="lb">组织</em> <br/>在整个软件过程中积极协调UI团队、测试团队、经理、同事成员被归类为<em class="lb">组织</em></p><p id="8a96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为nltk的NER分类将许多技术名称识别为ORG的。人们会注意到这里面有许多不着边际的预测，因为NER在nltk中可以抛出荒谬的东西，就像他们之前对月份名称所做的那样。</p><p id="88c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到零镜头在主要类别中工作得更好，但是nltk分类在这里仅仅是为了显示特征提取的简易性。如果您想使用nltk的分类，强烈建议使用您自己的特征提取块，使用比这里介绍的更复杂的方法提取特征字典元素。<br/>类似地，建议使用另一个NER解析器，POS tagger，直观脚本来确定和填充特征字典，而不是nltk的名词分块，因为后者不准确。</p><p id="3f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们谈到了两种CV曲线分析方法，它们从方法和努力的角度来看都非常不同。如果我必须建议一个产品级的解析，我会强烈推荐Spacy，这是我个人最喜欢的自然语言。</p><p id="e329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这一点将留待下次讨论！</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="ba28" class="lm kv iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">分级编码</h1><p id="e0ec" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="f430" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="980d" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">📰查看<a class="ae nc" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="00e5" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">🔔关注我们:<a class="ae nc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae nc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nc" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="e7e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae nc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>