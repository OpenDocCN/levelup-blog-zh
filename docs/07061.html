<html>
<head>
<title>Creating a Flux of Fluxes with Project Reactor’s Group By Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Project Reactor的Group By方法创建通量通量</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-flux-of-fluxes-with-project-reactors-group-by-method-37200bfc2a?source=collection_archive---------4-----------------------#2021-01-21">https://levelup.gitconnected.com/creating-a-flux-of-fluxes-with-project-reactors-group-by-method-37200bfc2a?source=collection_archive---------4-----------------------#2021-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b2b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么通量？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/55b0d97ce742a8502152f3680edd4e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1IPCde_WPvVJI7bSmsvtg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1577983" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1577983" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="81e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-reactive-java-e8aaee9a204b">了解Reactive Java </a>中，我创建了一个Reactive Java强大功能的简单演示。我创建的微型应用程序代表了一组微服务，它们根据类型处理二手车的诱导。输入是一个简单的采购订单类型，它产生了<code class="fe lv lw lx ly b">Car</code>、<code class="fe lv lw lx ly b">Motorcycle</code>和<code class="fe lv lw lx ly b">Truck</code>类型供进一步处理。</p><p id="aea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应式Java的思想是创建一个处理链，允许系统调度非阻塞任务，并将阻塞任务分成输入和输出任务。这个链使得我们做一件事然后做另一件事的代码看起来更有命令性，并且我们确信链中的每一项都是顺序处理的。</p><p id="65b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在这个简单的例子中，我们的处理是非常线性的，我们对每个项目只有一个链，即使每个项目可能需要不同的逻辑，如果我们可以通过某种类型来区分项目的话。在我们的原始代码中，我们有一个工厂和一些映射，根据原始采购订单中的字符串类型给出不同的结果。所以我们有了这个代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2577" class="md me it ly b gy mf mg l mh mi">static final Map&lt;String, String&gt; outQueue = Map.of(<br/>            "Car", CAR_QUEUE_NAME,<br/>            "Truck", TRUCK_QUEUE_NAME,<br/>            "Motorcycle", MOTORCYCLE_QUEUE_NAME);<br/>static final Map&lt;String, Function&lt;Vehicle, Optional&lt;String&gt;&gt;&gt;<br/>   vehicleWriter = Map.of(<br/>            "Car", (s) -&gt; writeCarJson((Vehicle.Car)s),<br/>            "Truck", (s) -&gt; writeTruckJson((Vehicle.Truck)s),<br/>            "Motorcycle", (s) -&gt;<br/>                    writeMotorcycleJson((Vehicle.Motorcycle)s));</span></pre><p id="1875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和这个工厂类型:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d404" class="md me it ly b gy mf mg l mh mi">Factory&lt;String, Vehicle, PurchaseOrder&gt; factory = new Factory&lt;&gt;();<br/>factory.add("Car", (po) -&gt; new Vehicle.Car(po));        factory.add("Truck", (po) -&gt; new Vehicle.Truck(po));        factory.add("Motorcycle", (po) -&gt; new Vehicle.Motorcycle(po));</span></pre><p id="595a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多地方我们需要修改，增加另一种类型。如果我们能够将水流分流成几股不同的水流，然后再将它们汇合成一股，那就太好了。这是我们最初的流程:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cd9d" class="md me it ly b gy mf mg l mh mi">sender.sendWithPublishConfirms(receiver<br/>    .consumeAutoAck(PO_QUEUE_NAME)<br/>    .map(d -&gt; readJson(new String(d.getBody())))<br/>    .filter(PurchaseOrder::isValid)<br/>    .doOnNext(po -&gt; log("recevied po " + po))<br/>    .doOnDiscard(PurchaseOrder.class, <br/>                    po -&gt; log("Discarded invalid PO " + po))<br/>    .flatMap(po -&gt; writePoJson(po).map(j -&gt;<br/>        reactiveCollection<br/>            .upsert(po.getId(), j)<br/>            .map(result -&gt; po))<br/>          .orElse(Mono.just(po)))<br/>    .map(gf -&gt; factory.build(gf.getType(), gf))<br/>    .timeout(Duration.ofSeconds(10))<br/>    .doFinally((s) -&gt; {<br/>      log("Consumer in finally for signal " + s);         <br/>      receiver.close();<br/>      sender.close();<br/>      cluster.disconnect();<br/>    })<br/>    .map(v -&gt; new OutboundMessage("", <br/>            outQueue.get(v.getPo().getType()), <br/>            vehicleWriter<br/>              .get(v.getPo().getType())<br/>              .apply(v)<br/>              .orElse("")<br/>              .getBytes()))<br/>    )<br/>    .subscribe();</span></pre><p id="9b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们正在使用采购订单的<code class="fe lv lw lx ly b">getType</code>方法来更改处理。这是一个相对简单的例子。想象一个更完整的例子，让多个流独立执行。</p><p id="ae7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能通过<code class="fe lv lw lx ly b">Flux.groupBy(Function&lt;T, K&gt; getkey)</code>方法实现。它将一个接受类型并返回一个键的<code class="fe lv lw lx ly b">Function</code>作为参数。返回值是一个<code class="fe lv lw lx ly b">Flux&lt;GroupedFlux&lt;K,T&gt;&gt;</code>。<code class="fe lv lw lx ly b">GroupedFlux</code>就是简单的<code class="fe lv lw lx ly b">Flux</code>，但是它有一个额外的方法<code class="fe lv lw lx ly b">key()</code>，该方法将返回创建它时使用的键。</p><p id="e7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在你基本上有了通量。外部的通量代表不同的类型，内部的<code class="fe lv lw lx ly b">Flux</code>是由那个特定类型组成的<code class="fe lv lw lx ly b">Flux</code>。内部的流动必须向下游排出，否则事情可能会悬而未决。最好的方法是将上游通量分解成相对较少的类型。在我们的情况下，我们有三种类型，我不会想象我们会增加很多，所以我们应该很好。</p><p id="162f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你如何处理不同流量的内部通量呢？首先，我们需要一种方法来判断什么流与什么类型相匹配。为此，我绘制了一张地图:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ad31" class="md me it ly b gy mf mg l mh mi">Map&lt;String, Function&lt;GroupedFlux&lt;String, PurchaseOrder&gt;,<br/>    Publisher&lt;OutboundMessageResult&gt;&gt;&gt; publisherMap = Map.of(<br/>            "Car", (o) -&gt; getCarPublisher(sender, o),<br/>            "Truck", (o) -&gt; getTruckPublisher(sender, o),<br/>            "Motorcycle", (o) -&gt; getMotorcyclePublisher(sender, o)<br/>);</span></pre><p id="1800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个映射将返回一个为每种类型提供流程的方法。输出类型是<code class="fe lv lw lx ly b">OutboundMessageResult</code>，随着处理的进行，它将与其余的流合并。</p><p id="618b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<code class="fe lv lw lx ly b">getCarPublisher</code>方法，我们可以看到它需要一个RabbitMQ <code class="fe lv lw lx ly b">sender</code>,一个购买订单处理它并返回发送到下一个消息队列的结果:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bc45" class="md me it ly b gy mf mg l mh mi">private static Flux&lt;OutboundMessageResult&gt; <br/>       getCarPublisher(Sender sender, <br/>                      GroupedFlux&lt;String, PurchaseOrder&gt; input) {<br/>   return sender.sendWithPublishConfirms(input<br/>     .map(po -&gt; new Vehicle.Car(po))<br/>     .doOnNext(car -&gt; log("sending car " + car))<br/>     .map(v -&gt; {<br/>        try {<br/>          return Optional.of(objectMapper<br/>                            .writerFor(Vehicle.Car.class)<br/>                            .writeValueAsString(v));<br/>        } catch (JsonProcessingException ex) {<br/>          return Optional.&lt;String&gt;empty();<br/>        }<br/>      })<br/>      .filter(o -&gt; o.isPresent())<br/>      .map(o -&gt; o.get())<br/>      .doOnDiscard(String.class, <br/>                    s -&gt; log("Discarded invalid Car"))<br/>      .map(s -&gt; new OutboundMessage("", <br/>                    CAR_QUEUE_NAME, <br/>                    s.getBytes())));<br/>}</span></pre><p id="4f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在所有专门处理<code class="fe lv lw lx ly b">Car</code>类型的逻辑都包含在一个方法中。我们为每个其他类型创建相同的方法。</p><p id="bcb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在开始执行每个流程，我们可以获取<code class="fe lv lw lx ly b">Flux.groupBy</code>的输出并用<code class="fe lv lw lx ly b">Flux.flatMap</code>链接它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7f0d" class="md me it ly b gy mf mg l mh mi">.groupBy(po -&gt; po.getType())<br/>.flatMap((v) -&gt; publisherMap.get(v.key()).apply(v))<br/>.subscribe();</span></pre><p id="3a85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将基于类型分割<code class="fe lv lw lx ly b">Flux</code>，对于每个类型，它将调用<code class="fe lv lw lx ly b">publisherMap.get</code>方法并在采购订单上应用该函数。<code class="fe lv lw lx ly b">getCarPublisher</code>和类似的函数将只被调用一次，因为该类型出现在上游通量中，并且内部通量将被附加到包含在其中的流中。<code class="fe lv lw lx ly b">Flux.flatMap</code>将重新组合所有单独的通量，最后，<code class="fe lv lw lx ly b">Flux.subscribe</code>将开始滚球。</p><p id="a3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的例子，所以这种重构看起来有些多余，但是很容易想象一个更复杂的例子，同样的基本模式也适用。同样，这是一个使用Project Reactor提供的反应式一元方法来消除switch或if/else链并简化整体代码流的示例。所有的代码都在我的GitHub页面上。</p><div class="mj mk gp gr ml mm"><a href="https://github.com/rkamradt/usedvehicles/tree/v0.2" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">rkamradt/二手车辆</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">在GitHub上创建一个帐户，为rkamradt/usedvehicles的开发做出贡献。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><p id="29a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提到的其他文章</p><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-reactive-java-e8aaee9a204b"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">理解反应式Java</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">因为你的线程阻碍了我的表现。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mv l"><div class="nb l mx my mz mv na ks mm"/></div></div></a></div></div></div>    
</body>
</html>