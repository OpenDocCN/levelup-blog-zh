<html>
<head>
<title>A Guide To Prototype-Based Class Inheritance In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中基于原型的类继承指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-prototype-based-class-inheritance-in-javascript-e2e30c2c92b4?source=collection_archive---------1-----------------------#2019-02-08">https://levelup.gitconnected.com/a-guide-to-prototype-based-class-inheritance-in-javascript-e2e30c2c92b4?source=collection_archive---------1-----------------------#2019-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="edc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是我最好的web开发教程列表。</p><p id="43e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://jst.hashnode.dev/complete-css-flex-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">在Hashnode上完成CSS flex教程</strong> </a>。</p><p id="d8a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://jst.hashnode.dev/css-grid-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">终极CSS网格教程</strong> </a>关于Hashnode。</p><p id="9365" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://jst.hashnode.dev/javascript-higher-order-functions-map-filter-and-reduce" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">高阶函数。地图，。过滤器&amp;。减少Hashnode上的</strong> </a>。</p><p id="43f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关注我@ <strong class="jp ir"> </strong> <a class="ae kl" href="https://twitter.com/js_tut" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">推特</strong> </a>，<a class="ae kl" href="https://www.instagram.com/javascriptteacher/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">insta gram</strong></a>&amp;<a class="ae kl" href="https://www.facebook.com/javascriptteacher/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">FB</strong></a>绝不错过优质文章。</p><div class="km kn gp gr ko kp"><a href="https://jstutorial.medium.com/my-coding-books-4f4dd2c35dd3" rel="noopener follow" target="_blank"><div class="kq ab fo"><div class="kr ab ks cl cj kt"><h2 class="bd ir gy z fp ku fr fs kv fu fw ip bi translated">我的编码书籍</h2><div class="kw l"><h3 class="bd b gy z fp ku fr fs kv fu fw dk translated">CSS可视化字典包含了每一个常用CSS属性的可视化图表。JavaScript语法包含…</h3></div><div class="kx l"><p class="bd b dl z fp ku fr fs kv fu fw dk translated">jstutorial.medium.com</p></div></div><div class="ky l"><div class="kz l la lb lc ky ld le kp"/></div></div></a></div><p id="e91b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计算机语言通常提供一种方法，使一个对象从另一个对象继承而来。继承的对象包含其父对象的所有属性。此外，它还将指定自己的一组唯一属性。</p><h2 id="c7fe" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">创建对象的逻辑层次结构</h2><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/3c2ba6e222353a3eccf83cb4660c8d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfPVquM32vvD47sJzbx4mA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated"><strong class="bd li">猫</strong>和<strong class="bd li">狗</strong>继承自<strong class="bd li">宠物</strong>，宠物继承自<strong class="bd li">动物</strong>。</figcaption></figure><p id="3f4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一只<strong class="jp ir">狗</strong>和一只<strong class="jp ir">猫</strong>有着相似的特征。与其创建两个不同的类，<br/>我们可以简单地创建一个类<strong class="jp ir">宠物</strong>并从中继承<strong class="jp ir">猫</strong>和<strong class="jp ir">狗</strong>。但是<strong class="jp ir">宠物</strong>类本身也可以继承<strong class="jp ir">动物</strong>类。</p><h2 id="1ebf" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">在后台</h2><p id="330e" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">对象继承背后的思想是为类似对象的层次结构提供结构。你也可以说一个子对象是从它的父对象“派生”而来的。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mt"><img src="../Images/22b78bdaf7148f58454104709ae3c018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5mSP1RRSgjGW4YoMILUgw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">如何在JavaScript中创建原型链。</figcaption></figure><p id="22ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">技术上来说，这是它看起来的样子。尽量不要想太多。只需知道在层次结构的最顶端有<strong class="jp ir">对象</strong>对象</p><p id="6479" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于原型的对象继承 <br/> JavaScript通过所谓的<strong class="jp ir">原型</strong>来支持对象继承。每个对象都有一个名为prototype的对象属性。</p><p id="ca9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用class和extends关键字很容易，但是实际上理解基于原型的继承是如何工作的并不容易。希望这篇教程至少能驱散一些迷雾！</p><p id="542b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">对象构造函数</strong> <br/>函数可以作为<strong class="jp ir">对象构造函数</strong>。构造函数的名字通常以大写字母开头，以区别普通函数。对象构造函数用于创建对象的实例。</p><p id="70ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些JavaScript内置对象已经按照相同的规则创建了。例如<strong class="jp ir">号</strong>、<strong class="jp ir">数组</strong>和<strong class="jp ir">字符串</strong>都是从<strong class="jp ir">对象</strong>继承而来。正如我们前面所讨论的，这意味着附加到对象的任何属性在它的所有子对象上都自动可用。</p><p id="5d7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">构造函数</strong> <br/>不了解构造函数的解剖，就不可能理解原型。</p><p id="0987" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，当我们创建一个自定义的构造函数时，会发生什么呢？两个属性神奇地出现在我们的类定义中:<strong class="jp ir">构造函数</strong>和<strong class="jp ir">原型.构造函数</strong></p><p id="9b45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们不指向同一个对象。让我们来分解一下:</p><p id="aa47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们定义了一个新的类<strong class="jp ir"> Crane </strong>(使用函数或者类关键字。)</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mu"><img src="../Images/3e9c559a71db83dfdd96ff78e16e43a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHEFo6jeEwjvXWddzg4Dbw.png"/></div></div></figure><p id="c6c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们刚刚创建的自定义构造函数现在被附加到我们的自定义<strong class="jp ir"> Crane </strong>类的prototype属性上。这是一个指向它自己的构造函数的链接。它创造了循环逻辑。但这只是谜题的一部分。</p><p id="9939" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来看看<strong class="jp ir">起重机:</strong></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mu"><img src="../Images/a9906b91fc17053f8f54e665ec708944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIZUV5f7SQsU_3ASjd9CKA.png"/></div></div></figure><p id="7981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Crane.constructor </strong>本身指向创建它的对象的类型。<br/>因为所有对象构造函数都是本机函数，所以对象</p><p id="2694" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Crane.constructor </strong>指向的是<strong class="jp ir">类型函数</strong>的对象，换句话说就是函数构造器。</p><p id="486d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">crane . prototype . constructor</strong>和<strong class="jp ir"> Crane.constructor </strong>之间的这种动态是在分子水平上实现原型继承的原因。在编写JavaScript代码时，您甚至很少需要考虑这一点。但这绝对是一个面试问题。</p><p id="e40d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再简单回顾一下。<strong class="jp ir">crane . prototype . constructor</strong>指向自己的构造函数。这几乎就像在说“我就是我。”</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mt"><img src="../Images/cc1b8210ee05640bb0aa7e7723bb7210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BN-GD1He4ryzD-Poze5tg.png"/></div></div></figure><p id="f36a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您使用class关键字定义一个类时，会发生完全相同的事情:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mt"><img src="../Images/1fe7bfeb10228783b4c989c0f920d9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAyDIVAS42f5KX02xCD_sA.png"/></div></div></figure><p id="07a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，<strong class="jp ir"> Crane.constructor </strong>属性指向函数构造器。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mt"><img src="../Images/62174a5e86ded6eec460937e09ae0440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uk7ugoISf9hxdDilYe_qxw.png"/></div></div></figure><p id="2ddd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接就是这样建立起来的。</p><p id="d817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在<strong class="jp ir">鹤</strong>物体本身可以成为另一个物体的“原型”。且该对象可以是另一个对象原型。诸如此类。这个链条可以永远延续下去。</p><p id="eec1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">边注:</strong>在ES5风格的函数中，函数本身就是<br/>构造函数。但是ES6 class关键字将构造函数放在其作用域内。这个<br/>只是语法上的区别。</p><p id="41c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">基于原型的继承</strong> <br/>我们应该始终使用class和extends关键字来创建和继承对象。但它们只是隐藏在幕后的糖果包装。</p><p id="f940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管使用ES5风格的语法创建对象继承层次结构早已过时，并且在专业软件开发人员中很少见到，但是通过理解它，您将对它的实际工作方式有更深入的了解。</p><p id="f2e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们定义一个新的对象<strong class="jp ir">鸟</strong>并添加3个属性:<strong class="jp ir">类型</strong>、<strong class="jp ir">颜色</strong>和<strong class="jp ir">蛋</strong>。我们再加上3个方法:<strong class="jp ir">飞</strong>、<strong class="jp ir">走</strong>和<strong class="jp ir">产卵</strong>。所有鸟类都会做的事情:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/7aa1944bc924bd275bd52ee7a1818e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKaMU1BjaHLU7q6x_bwRAw.png"/></div></div></figure><p id="387e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我故意将<strong class="jp ir"> lay_egg </strong>方法灰显。还记得我们之前讨论过的<br/>bird . prototype指向它自己的构造函数吗？</p><p id="3c9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以将产卵方法直接附加到<strong class="jp ir"> Bird.prototype </strong>上，如下例所示:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/2c6dcdb0e719e22320b12f93ddfd4cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PExzfnNUaM9IslXq3qX2fw.png"/></div></div></figure><p id="36db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，在<strong class="jp ir"> Bird </strong>中使用<strong class="jp ir"> this </strong>关键字的附加方法和简单地将它直接添加到<strong class="jp ir"> Bird.prototype </strong>属性中没有区别。因为它还能用对吗？</p><p id="e4b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这并不完全正确。到目前为止，我不会深入细节，因为我还没有完全理解这里的区别。但是当我收集到更多关于这个主题的见解时，我打算更新这个教程。</p><p id="7224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不是所有的鸟都是一样的。对象继承的要点是使用一个公共类来定义该类的所有子对象将自动继承的所有属性和方法。这使得代码更短并节省了内存。</p><p id="08c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(<em class="lf">想象一下，在所有子对象上分别重新定义相同的属性和方法。它需要两倍的内存。</em></p><p id="0cdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建几种不同类型的鸟。尽管它们都仍然可以<strong class="jp ir">飞行</strong>、<strong class="jp ir">行走</strong>和<strong class="jp ir">下蛋</strong>(因为它们是从主<strong class="jp ir">鸟</strong>类继承而来的)，但是每个独特的鸟类型都会添加它自己独特的方法给那个类。比如只有鹦鹉会说话。只有瑞文能解谜。只有鸣鸟会唱歌。</p><p id="dc41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Parrot </strong> <br/>让我们创建一只<strong class="jp ir"> Parrot </strong>并从<strong class="jp ir"> Bird </strong>继承它:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/0d147f5baf659c1a831d5ec650c61c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiasVVfaQAP87MpxHCSTiQ.png"/></div></div></figure><p id="cba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Parrot </strong>和<strong class="jp ir"> Bird </strong>一样是一个常规的构造函数。</p><p id="310b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不同之处在于，在附加我们自己的方法之前，我们用<strong class="jp ir"> Bird.call </strong>调用Bird的构造函数，并传递<strong class="jp ir"> Parrot </strong>的上下文。<strong class="jp ir"> Bird.call </strong>简单的把它所有的属性和方法加到<strong class="jp ir"> Parrot </strong>上。除此之外，我们也在添加自己的方法:<strong class="jp ir"> talk </strong>。</p><p id="97b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在鹦鹉会<strong class="jp ir">飞</strong>，<strong class="jp ir">走</strong>，<strong class="jp ir">下蛋</strong>和<strong class="jp ir">说话</strong>！但是我们从来不需要在<strong class="jp ir">鹦鹉</strong>内部定义<strong class="jp ir">飞走</strong>和<strong class="jp ir">产卵</strong>的方法。</p><p id="27ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">渡鸦</strong> <br/>同理，让我们创建<strong class="jp ir">渡鸦</strong>并从<strong class="jp ir">鸟</strong>继承它:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/513fbf2fd678c9b69508a9257ec91bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_54ZGRnB1ZvDVeiASbEAg.png"/></div></div></figure><p id="9e98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">渡鸦是独一无二的，因为它们能解谜。</p><p id="0bb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们创建Songbird并从bird继承它:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/e3cf1d920f7d6465f7024bc59baee56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6GCwuOPzwVTYYqT4DhPIA.png"/></div></div></figure><p id="3eab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鸣鸟会唱歌。</p><p id="6084" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们刚刚创造了一群拥有独特能力的不同的鸟。让我们看看他们有什么能力！到目前为止，我们只定义了类并建立了它们的层次关系。</p><p id="b07d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了处理对象，我们需要实例化它们:</p><p id="b4b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用原始的<strong class="jp ir"> Bird </strong>构造函数实例化一个<strong class="jp ir"> sparrow </strong>:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/789e2f3b06b597b21469a50a4b1b8c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4AMpb_7WGy5Hy5xQrTg8g.png"/></div></div></figure><p id="f29d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">麻雀会飞，会走，会下蛋，因为它是从鸟类那里继承来的，定义了所有这些方法。</p><p id="8757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是麻雀不会说话。因为它不是<strong class="jp ir">鹦鹉</strong>。</p><p id="c569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从<strong class="jp ir"> Parrot </strong>类创建一个<strong class="jp ir">鹦鹉</strong>:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/be18eb460633c5c6d9e5001edac87c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byBKXxISAbGTYxCLnfkdIw.png"/></div></div></figure><p id="7f47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为<strong class="jp ir"> Parrot </strong>是从Bird继承的，所以我们得到了它的所有方法。一只长尾小鹦鹉有独特的能力去说话，但是它不会唱歌！<strong class="jp ir"> sing </strong>方法只适用于Songbird类型的对象。让我们从鸣禽类继承starling:</p><p id="56ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们创建一只乌鸦，并解决一些难题:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/2b865001178cd84a47cd2d1dd8e9c164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsEimInEhBs2wxBYmp-z0Q.png"/></div></div></figure><h1 id="30c1" class="mw lh iq bd li mx my mz ll na nb nc lo nd ne nf lr ng nh ni lu nj nk nl lx nm bi translated">使用<code class="fe nn no np nq b">class </code>和<code class="fe nn no np nq b">extends </code>关键字</h1><p id="b155" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">ES5风格的构造函数可能有点麻烦。</p><p id="0a8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，我们现在有了<strong class="jp ir">类</strong>和<strong class="jp ir">扩展</strong>关键字来完成与我们在上一节中所做的完全相同的事情。</p><p id="d3db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">类</strong>取代<strong class="jp ir">功能</strong></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/85bfbca14b5cecf35d7206f79ed266b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRC2O4mqhV_pLEnH9ZHmGA.png"/></div></div></figure><p id="1a3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">扩展</strong>和<strong class="jp ir"> super() </strong>替换前面示例中的<strong class="jp ir"> Bird.call </strong>。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/de83d0418016eca27a4cc003d7b733e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pHq_cQvAvmlmKh-yID54g.png"/></div></div></figure><p id="ee6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们必须使用<strong class="jp ir"> super() </strong>来调用父类的构造函数。</p><p id="9116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种语法看起来更容易管理！</p><p id="6876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们要做的就是实例化对象:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/21e6e58d916b4798fcf60392fc89fdae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIeFOjoVzwMnUnUCqBl61w.png"/></div></div></figure><p id="d619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">概述</strong> <br/>类继承有助于建立对象的层次结构。</p><p id="f751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类是应用程序设计和架构的基本构建块。他们让代码工作更人性化。</p><p id="91e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，<strong class="jp ir">鸟</strong>只是一个例子。在真实的场景中，它可以是基于您试图构建的应用程序类型的任何东西。</p><p id="8255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">车辆</strong>类可以是<strong class="jp ir">摩托车</strong>、<strong class="jp ir">汽车</strong>或<strong class="jp ir">坦克</strong>的父类。</p><p id="c2ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">鱼</strong>可以用来继承<strong class="jp ir">鲨鱼</strong>、<strong class="jp ir">金鱼</strong>、<strong class="jp ir">狗鱼</strong>等等。</p><p id="876b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继承有助于我们编写更简洁的代码，并重用父对象，以节省重复对象属性和方法定义的内存。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><figure class="ma mb mc md gt me gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi oa"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="km kn gp gr ko kp"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="kq ab fo"><div class="kr ab ks cl cj kt"><h2 class="bd ir gy z fp ku fr fs kv fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="kw l"><h3 class="bd b gy z fp ku fr fs kv fu fw dk translated">前65名JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="kx l"><p class="bd b dl z fp ku fr fs kv fu fw dk translated">gitconnected.com</p></div></div><div class="ky l"><div class="ob l la lb lc ky ld le kp"/></div></div></a></div></div></div>    
</body>
</html>