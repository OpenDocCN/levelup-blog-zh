<html>
<head>
<title>How to create a simple Bitcoin API with Node.js &amp; GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js &amp; GraphQL创建一个简单的比特币API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-simple-bitcoin-api-with-nodejs-graphql-part-i-a8cd8832fed5?source=collection_archive---------3-----------------------#2019-07-16">https://levelup.gitconnected.com/how-to-create-a-simple-bitcoin-api-with-nodejs-graphql-part-i-a8cd8832fed5?source=collection_archive---------3-----------------------#2019-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d0f3749e5495d52978714370e261d58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06C3qzWKw-O5s-Hd-z94Iw.png"/></div></div></figure><h1 id="a6bd" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是GraphQL</h1><p id="29cb" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在开始写代码之前，我想说这个教程是给初学者的。这个想法是以一种温和而简单的方式开始使用GraphQL，在未来的部分中，我们将使我们的API更加复杂。</p><p id="0ee3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">来自官方<a class="ae mc" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">网站</a>:</p><blockquote class="md me mf"><p id="d2d0" class="kz la mg lb b lc lx le lf lg ly li lj mh lz lm ln mi ma lq lr mj mb lu lv lw im bi translated">GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL为您的API中的数据提供了完整且易于理解的描述。</p></blockquote><p id="43be" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">GraphQL将帮助我们标准化我们的API结构，并使它更易于维护、易于阅读、易于在我们的客户之间共享等等。</p><p id="f4ce" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将构建一个非常简单的API来获取不同货币的比特币价格。我们将开始了解GraphQL是如何工作的，以及如何在我们的比特币应用程序中使用它。</p><h1 id="066c" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">开始使用。</h1><p id="f6ba" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我将介绍整个过程，但是你可以在这里得到整个库<a class="ae mc" href="https://github.com/LuisAcerv/graphql-api-tutorial" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="bec4" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">项目设置</h1><p id="dcc8" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">首先，我们需要建立我们的项目。</p><h1 id="22dc" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">1创建您的工作目录</h1><p id="bc51" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在你的终端运行下面的命令:<code class="fe mk ml mm mn b">mkdir btc-gql-api &amp;&amp; cd btc-gql-api</code>，这个命令会在你当前的目录下创建并访问一个新的文件夹。</p><h1 id="7b38" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">2初始化您的项目</h1><p id="f685" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在您的终端上运行<code class="fe mk ml mm mn b">yarn init</code>或<code class="fe mk ml mm mn b">npm install</code>，并填写将被提示的字段。这将在您的目录中创建以下文件:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="4694" class="mw kc it mn b gy mx my l mz na">package.json</span></pre><p id="7517" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这个包看起来会像这样:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="2439" class="mw kc it mn b gy mx my l mz na">{<br/>  "name": "my-new-project",<br/>  "version": "1.0.0",<br/>  "description": "My New Project description.",<br/>  "main": "index.js",<br/>  "repository": {<br/>    "url": "https://example.com/your-username/my-new-project",<br/>    "type": "git"<br/>  },<br/>  "author": "Your Name &lt;you@example.com&gt;",<br/>  "license": "MIT"<br/>}</span></pre><ul class=""><li id="0d1e" class="nb nc it lb b lc lx lg ly lk nd lo ne ls nf lw ng nh ni nj bi translated">运行<code class="fe mk ml mm mn b">touch index.js</code>以便在您的工作目录中创建您的条目文件。(如果您在windows中，请在代码编辑器中手动创建该文件)。</li><li id="1c69" class="nb nc it lb b lc nk lg nl lk nm lo nn ls no lw ng nh ni nj bi translated">添加一个开始命令，在你的<code class="fe mk ml mm mn b">package.json</code>中添加一个新的章节:</li></ul><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="a951" class="mw kc it mn b gy mx my l mz na">...<br/>"scripts": {<br/>  "start": "node index.js"<br/>},<br/>...</span></pre><p id="c292" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您的包应该是这样的:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="ceb8" class="mw kc it mn b gy mx my l mz na">{<br/>  "name": "my-new-project",<br/>  "version": "1.0.0",<br/>  "description": "My New Project description.",<br/>  "main": "index.js","scripts": {<br/>    "start": "node index.js"<br/>  },<br/>  "repository": {<br/>    "url": "https://example.com/your-username/my-new-project",<br/>    "type": "git"<br/>  },<br/>  "author": "Your Name &lt;you@example.com&gt;",<br/>  "license": "MIT"<br/>}</span></pre><p id="2c41" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在您的工作目录中创建一个名为<code class="fe mk ml mm mn b">graphql</code>的新文件夹，因此您的结构应该如下所示:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="153f" class="mw kc it mn b gy mx my l mz na">+ btc-gql-api<br/>|__ graphql<br/>|__ package.json<br/>|__ index.json</span></pre><p id="b639" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在<code class="fe mk ml mm mn b">graphql</code>目录下创建三个名为<code class="fe mk ml mm mn b">types.js</code>、<code class="fe mk ml mm mn b">resolvers.js</code>、<code class="fe mk ml mm mn b">request.js</code>的新文件，您的项目应该如下所示:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="0f3e" class="mw kc it mn b gy mx my l mz na">+ btc-gql-api<br/>|__+graphql<br/>|____request.js<br/>|____resolvers.js<br/>|____types.js<br/>|__ package.json<br/>|__ index.json</span></pre><h1 id="979e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">3安装依赖项</h1><p id="cc44" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">对于这个项目，我们需要两个依赖项:<code class="fe mk ml mm mn b">axios</code>和<code class="fe mk ml mm mn b">graphql-yoga</code>，所以我们运行<code class="fe mk ml mm mn b">yarn add axios graphql-yoga</code>。</p><p id="09f1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">就这样，我们已经建立了我们的项目，我们可以开始写一些代码了！</p><h1 id="0274" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">类型</h1><p id="626c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">GraphQL模式最基本的组成部分是对象类型，它只是表示一种可以从服务中获取的对象，以及它有哪些字段。在GraphQL模式语言中，我们可以这样表示它:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="31a9" class="mw kc it mn b gy mx my l mz na">type User {<br/>  name: String!<br/>  email: String!<br/>}</span></pre><p id="b622" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">GraphQL自带了一组默认的标量类型:</p><ul class=""><li id="62a2" class="nb nc it lb b lc lx lg ly lk nd lo ne ls nf lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">Int</code>:一个带符号的32位整数。</li><li id="50be" class="nb nc it lb b lc nk lg nl lk nm lo nn ls no lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">Float</code>:有符号双精度浮点值。</li><li id="d01a" class="nb nc it lb b lc nk lg nl lk nm lo nn ls no lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">String</code>:UTF‐8字符序列。</li><li id="ad74" class="nb nc it lb b lc nk lg nl lk nm lo nn ls no lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">Boolean</code>:真或假。</li><li id="4b2c" class="nb nc it lb b lc nk lg nl lk nm lo nn ls no lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">ID</code>:ID标量类型表示一个惟一的标识符，通常用于获取一个对象或作为缓存的键。ID类型的序列化方式与a <code class="fe mk ml mm mn b">String</code>相同；但是，将其定义为ID意味着它不适合人类阅读。</li></ul><p id="586e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">还有一种指定自定义标量类型的方法。例如，我们可以定义一个<code class="fe mk ml mm mn b">Date</code>类型:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="3fbd" class="mw kc it mn b gy mx my l mz na">scalar Date</span></pre><p id="42f6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果你想学习更多关于GraphQL中类型的知识，我鼓励你去看看GraphQL文档<a class="ae mc" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"/></p><p id="e2dd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们创造我们的类型！</p><p id="b7ed" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在代码编辑器中打开文件<code class="fe mk ml mm mn b">./graphql/types.js</code>并添加以下内容:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="e423" class="mw kc it mn b gy mx my l mz na">const typeDefs = `<br/>scalar JSON</span><span id="d20e" class="mw kc it mn b gy np my l mz na">type Price {<br/>  price:JSON!<br/>}`;</span><span id="19b7" class="mw kc it mn b gy np my l mz na">module.exports = typeDefs;</span></pre><p id="8411" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里刚刚发生了什么？嗯，正如我们在GraphQL使用类型语言来表示API中的对象之前所了解的，对于我们的比特币API，我们现在在模式中只需要一种类型，即类型<code class="fe mk ml mm mn b">Price</code></p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="ce9a" class="mw kc it mn b gy mx my l mz na">...<br/>type Price {<br/>  price:JSON!<br/>}<br/>...</span></pre><p id="a26f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如你所见，类型<code class="fe mk ml mm mn b">Price</code>只有一个名为<code class="fe mk ml mm mn b">price</code>的字段，它的类型是<code class="fe mk ml mm mn b">JSON</code>并且不能为空(这就是符号<code class="fe mk ml mm mn b">!</code>的含义)。我们已经讨论了默认情况下<code class="fe mk ml mm mn b">GraphQL</code>包含的默认数据类型，而<code class="fe mk ml mm mn b">JSON</code>不在其中，所以我们需要定义它:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="c552" class="mw kc it mn b gy mx my l mz na">scalar JSON</span><span id="4491" class="mw kc it mn b gy np my l mz na">type Price {<br/>  price:JSON!<br/>}<br/>...</span></pre><h1 id="fd0d" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">问题</h1><p id="9ddf" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">GraphQL是关于管理数据的，a <code class="fe mk ml mm mn b">query</code>基本上是询问对象上的特定字段:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="0697" class="mw kc it mn b gy mx my l mz na">query {<br/>  getPrices {<br/>    price<br/>  }<br/>}</span></pre><p id="5097" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">结果:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="d4fc" class="mw kc it mn b gy mx my l mz na">{<br/>  "data": {<br/>    "getPrices": {<br/>      "price": {<br/>        "USD": {<br/>          "15m": 10436.54,<br/>          "last": 10436.54,<br/>          "buy": 10436.54,<br/>          "sell": 10436.54,<br/>          "symbol": "$"<br/>        }<br/>        ...<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="7489" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如您所见，响应具有与请求相同的结构。</p><h1 id="3b9e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">查询和变异类型</h1><p id="f301" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在一个模式中还有另外两种特殊的类型，<code class="fe mk ml mm mn b">Query</code>和<code class="fe mk ml mm mn b">Mutation</code>。</p><p id="80e2" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">每个GraphQL服务至少有一个查询类型，可能有也可能没有突变类型。这些类型与常规对象类型相同，但是它们定义了每个GraphQL查询的入口点。它们看起来像这样:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="dd6b" class="mw kc it mn b gy mx my l mz na">scalar JSON</span><span id="b329" class="mw kc it mn b gy np my l mz na">type Price {<br/>  price:JSON!<br/>}</span><span id="ddb7" class="mw kc it mn b gy np my l mz na">type Query {<br/>  getPrices: Price!<br/>  getPrice(currency:String!): Price!<br/>}</span></pre><p id="7cd8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这意味着我们的GraphQL服务有一个带有<code class="fe mk ml mm mn b">getPrices</code>和<code class="fe mk ml mm mn b">getPrice</code>字段的查询类型，两者都等于我们的<code class="fe mk ml mm mn b">Price</code>类型，我们可以看到字段<code class="fe mk ml mm mn b">getPrice</code>有一个参数<code class="fe mk ml mm mn b">(currency:String!)</code>。GraphQL对象类型上的每个字段可以有零个或多个参数。</p><p id="7fe8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">参数可以是必需的，也可以是可选的，在本例中，我们需要一个名为currency的必需参数，我们将使用它来选择要查询的货币。</p><p id="5889" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">到此为止，您已经了解了GraphQL中存在哪些类型，并且我们已经为我们的应用程序设置了必要的类型。</p><h1 id="5d06" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">7请求帮助者</h1><p id="8f0b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在我们继续使用GraphQL之前，我们需要一个助手来负责获取比特币价格，为了实现这一点，我们将使用<a class="ae mc" href="https://www.blockchain.com/es/api/exchange_rates_api" rel="noopener ugc nofollow" target="_blank">Blockchain.com</a>API，但是您也可以使用任何其他您想要的服务。</p><p id="7a14" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">打开我们之前创建的文件:<code class="fe mk ml mm mn b">./graphql/request.js</code>并添加以下内容:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="f00d" class="mw kc it mn b gy mx my l mz na">const axios = require("axios");</span><span id="bd5d" class="mw kc it mn b gy np my l mz na">module.exports = {<br/>  getPrices: async () =&gt; {<br/>    const url = "https://blockchain.info/ticker";<br/>    try {<br/>      return await axios.get(url);<br/>    } catch (error) {<br/>      console.error(error);<br/>    }<br/>  }<br/>};</span></pre><p id="aad4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将使用<code class="fe mk ml mm mn b">axios</code>来发出<code class="fe mk ml mm mn b">GET</code>请求，但是您可以轻松地使用任何其他工具来实现这一点。</p><h1 id="efd2" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">8个解析器</h1><p id="2e83" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">每种类型上的每个字段都由GraphQL服务器开发人员提供的一个名为resolver的函数支持。当一个字段被执行时，相应的解析器被调用以产生下一个值。</p><p id="65f5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果一个字段产生一个标量值，如字符串或数字，则执行完成。但是，如果一个字段产生一个对象值，那么查询将包含适用于该对象的另一个字段选择。这一直持续到达到标量值。GraphQL查询总是以标量值结束。</p><p id="9ff9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在每一个GraphQL服务器的顶层都有一个代表所有可能的GraphQL API入口点的类型，它通常被称为根类型或查询类型。</p><p id="af6e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">打开名为<code class="fe mk ml mm mn b">./graphql/resolvers.js</code>的文件，添加以下内容:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1327" class="mw kc it mn b gy mx my l mz na">const requests = require("./requests");</span><span id="e02e" class="mw kc it mn b gy np my l mz na">const resolvers = {<br/>  Query: {<br/>    // Get all available prices<br/>    async getPrices(parent, args, ctx, info) {<br/>      const prices = await requests.getPrices();<br/>      return { price: prices.data };<br/>    },<br/>    // Get the price of a given currency symbol<br/>    async getPrice(parent, args, ctx, info) {<br/>      const prices = await requests.getPrices();<br/>      return { price: { [args["currency"]]: prices.data[args["currency"]] } };<br/>    }<br/>  }<br/>};</span><span id="d660" class="mw kc it mn b gy np my l mz na">module.exports = resolvers;</span></pre><p id="9f5f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们分解一下，首先我们导入我们的请求帮助器:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="d26f" class="mw kc it mn b gy mx my l mz na">const request = require("./request");</span></pre><p id="62d3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们不需要声明或解析对象:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="838b" class="mw kc it mn b gy mx my l mz na">const resolvers = {<br/>  Query: {<br/>    // Get all available prices<br/>    async getPrices(parent, args, ctx, info) {<br/>      const prices = await requests.getPrices();<br/>      return { price: prices.data };<br/>    },<br/>    // Get the price of a given currency symbol<br/>    async getPrice(parent, args, ctx, info) {<br/>      const prices = await requests.getPrices();<br/>      return { price: { [args["currency"]]: prices.data[args["currency"]] } };<br/>    }<br/>  }<br/>};</span></pre><p id="6b46" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们的解析器对象有一个名为<code class="fe mk ml mm mn b">Query</code>的根，在这个对象中，我们将声明我们在GraphQL模式中的所有解析器，请注意，我们已经像在<code class="fe mk ml mm mn b">types.js</code>文件中一样命名了这些解析器。</p><p id="eb92" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">每个解析器只是一个实现我们的请求帮助器的函数，我们的解析器函数接收四个参数:</p><ul class=""><li id="851f" class="nb nc it lb b lc lx lg ly lk nd lo ne ls nf lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">parent</code>:前一个对象，对于根查询类型上的字段通常不使用。</li><li id="6828" class="nb nc it lb b lc nk lg nl lk nm lo nn ls no lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">args</code>:在GraphQL查询中提供给字段的参数。</li><li id="b6d5" class="nb nc it lb b lc nk lg nl lk nm lo nn ls no lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">ctx</code>:提供给每个解析器的值，保存重要的上下文信息，如当前登录的用户或对数据库的访问。</li><li id="d18f" class="nb nc it lb b lc nk lg nl lk nm lo nn ls no lw ng nh ni nj bi translated"><code class="fe mk ml mm mn b">info</code>:保存与当前查询相关的特定于字段的信息以及模式细节的值。</li></ul><h1 id="e54d" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">9服务器</h1><p id="bf09" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们已经有了<code class="fe mk ml mm mn b">types</code>、<code class="fe mk ml mm mn b">resolvers</code>和助手，我们只需要设置<code class="fe mk ml mm mn b">server</code>来完成我们非常小的比特币API。</p><p id="715a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">打开我们之前创建的文件<code class="fe mk ml mm mn b">index.js</code>，添加以下内容:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5220" class="mw kc it mn b gy mx my l mz na">const { GraphQLServer } = require("graphql-yoga");<br/>const typeDefs = require("./graphql/types.js");<br/>const resolvers = require("./graphql/resolvers.js");</span><span id="c526" class="mw kc it mn b gy np my l mz na">const server = new GraphQLServer({<br/>  typeDefs,<br/>  resolvers,<br/>  context: {<br/>    //if we pass anything here can be available in all resolvers<br/>  }<br/>});</span><span id="07ba" class="mw kc it mn b gy np my l mz na">server.start(() =&gt; console.log("Server is running on localhost:4000☄"));</span></pre><p id="5d9c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如您所见，我们导入了GraphQLServer库和我们的typeDefs和解析器，然后我们创建了一个新的<code class="fe mk ml mm mn b">GraphQLServer</code>实例，并传递了配置:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="9733" class="mw kc it mn b gy mx my l mz na">...<br/>const server = new GraphQLServer({<br/>  typeDefs,<br/>  resolvers,<br/>  context: {<br/>    //if we pass anything here can be available in all resolvers<br/>  }<br/>});<br/>...</span></pre><p id="98c8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">最后，我们运行服务器！：</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="6b8e" class="mw kc it mn b gy mx my l mz na">server.start(() =&gt; console.log("Server is running on localhost:4000☄"));</span></pre><p id="5ff3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">就是这样！现在我们只需要在终端中运行<code class="fe mk ml mm mn b">npm start</code>，如果我们的代码一切正常，我们应该会看到下面的消息:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="15bb" class="mw kc it mn b gy mx my l mz na">Server is running on localhost:4000☄</span></pre><p id="cf22" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">打开你的浏览器，进入<code class="fe mk ml mm mn b">http://localhost:4000</code>，如果一切正常，你应该会看到操场界面。</p><p id="efd0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">测试查询:所有可用货币:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="c9f1" class="mw kc it mn b gy mx my l mz na">query{<br/>  getPrices{<br/>    price<br/>  }<br/>}</span></pre><p id="37cd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">查询特定货币:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="016e" class="mw kc it mn b gy mx my l mz na">query($currency:String!){<br/>  getPrice(currency:$currency){<br/>    price<br/>  }<br/>}</span><span id="6095" class="mw kc it mn b gy np my l mz na"># Variables:<br/>{<br/>  "currency": "USD"<br/>}</span></pre><p id="0d19" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您应该会看到这样的响应:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/fdb162d17bebdb9e72a3382da30be90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMqsT1Ck8P103aUDP626Bw.png"/></div></div></figure><p id="be9e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">就这样，我们用GraphQL建立了一个非常简单的比特币API，我们已经了解了开始使用GraphQL的基础知识，如果你想了解更多关于这项技术的信息，请访问<a class="ae mc" href="https://graphql.org" rel="noopener ugc nofollow" target="_blank">GraphQL.org</a>。</p><p id="79a1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在下面的帖子中，我们将学习如何使用突变来创建比特币地址，并使用测试网将交易推送到网络，然后我们将使用Apollo client构建一个web客户端，并与我们的GraphQL API进行交互。</p><p id="54ed" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果您有任何问题，请在评论中提问或在twitter上关注我，我很乐意帮助您！</p><p id="2cc7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">编码快乐！</p><p id="a0e9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">资源:</p><p id="5d49" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><a class="ae mc" href="https://graphql.org/learn" rel="noopener ugc nofollow" target="_blank">https://graphql.org/learn</a></p></div></div>    
</body>
</html>