<html>
<head>
<title>React State in Class and Function Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对类和函数组件中的状态做出反应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-state-in-class-and-function-components-2269614579c4?source=collection_archive---------1-----------------------#2020-08-17">https://levelup.gitconnected.com/react-state-in-class-and-function-components-2269614579c4?source=collection_archive---------1-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/49f785154a80e6afddad8ae36aab45f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*96wsYuftLOLmNgzK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="4098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React 16.8之前，功能组件没有状态或生命周期挂钩。在16.8+中，函数组件现在可以使用钩子来使用状态，你可以在第一次渲染和每次更新后实现副作用。为了更深入地了解这一点，让我们通过构建两次—<a class="ae kc" href="https://darrylmendonez.github.io/barebones-react-todo-list/#/function-component" rel="noopener ugc nofollow" target="_blank">——一次作为</a><a class="ae kc" href="https://github.com/darrylmendonez/barebones-react-todo-list/blob/master/src/components/classComponent.js" rel="noopener ugc nofollow" target="_blank">类组件</a>，然后再次作为<a class="ae kc" href="https://github.com/darrylmendonez/barebones-react-todo-list/blob/master/src/components/functionComponent.js" rel="noopener ugc nofollow" target="_blank">函数组件</a>，来看看函数和类组件如何在初始和后续渲染中使用状态和触发函数。</p><h1 id="89af" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装</h1><p id="4cc3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当然，类和函数组件之间的第一个显著区别是它们的语法。一个类组件从<code class="fe me mf mg mh b">React.Component</code>扩展而来，并设置一个返回React组件的渲染函数。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c4c8" class="mq lc iq mh b gy mr ms l mt mu">import React, { Component } from 'react';</span><span id="138d" class="mq lc iq mh b gy mv ms l mt mu">class ClassComponent extends Component {<br/>  render() {<br/>    return ();<br/>  }<br/>}</span><span id="64d5" class="mq lc iq mh b gy mv ms l mt mu">export default ClassComponent;</span></pre><p id="9e45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而函数组件是普通的JavaScript，接受props作为参数并返回React组件。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b91e" class="mq lc iq mh b gy mr ms l mt mu">import React from 'react';</span><span id="dd93" class="mq lc iq mh b gy mv ms l mt mu">const FunctionComponent = () =&gt; {<br/>  return ();<br/>}</span><span id="1905" class="mq lc iq mh b gy mv ms l mt mu">export default FunctionComponent</span></pre><h1 id="55c8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">初始化状态</h1><p id="7e18" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的状态是一个JavaScript对象，包含可以绑定到呈现函数输出的数据。每当状态属性更新时，React都会相应地重新呈现组件。在类组件中，有两种初始化状态的方法——在构造函数中或者作为类属性。</p><p id="f06b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES6中引入的构造函数是类第一次实例化时调用的第一个函数——也就是从类中创建新对象时。在构造函数中初始化状态允许在React呈现组件之前创建状态对象。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e23f" class="mq lc iq mh b gy mr ms l mt mu">import React, { Component } from 'react';</span><span id="0be4" class="mq lc iq mh b gy mv ms l mt mu">class ClassComponent extends Component {<br/>  <strong class="mh ir">constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      list: [],<br/>      currentItem: '',<br/>    }<br/>  }</strong><br/>  render() {<br/>    return ();<br/>  }<br/>}</span><span id="b91a" class="mq lc iq mh b gy mv ms l mt mu">export default ClassComponent;</span></pre><p id="5762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用Class属性来初始化状态。一旦类的一个实例在内存中，状态的属性就被创建，并可以被render函数读取。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="62b3" class="mq lc iq mh b gy mr ms l mt mu">import React, { Component } from 'react';</span><span id="8f4e" class="mq lc iq mh b gy mv ms l mt mu">class ClassComponent extends Component {<br/>  <strong class="mh ir">this.state = {<br/>    list: [],<br/>    currentItem: '',<br/>  }</strong><br/>  render() {<br/>    return ();<br/>  }<br/>}</span><span id="c8d8" class="mq lc iq mh b gy mv ms l mt mu">export default ClassComponent;</span></pre><p id="dacc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两种方法的净输出是相同的，所以这完全取决于偏好。为了这篇文章，我将坚持使用构造函数的方法，继续我们的比较。</p><p id="50cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React 16.8中，函数组件现在可以使用状态。在此之前，来自状态的数据必须作为道具从类组件传递到函数组件，或者必须将函数组件转换为类组件。现在，我们可以使用React钩子，要使用state，我们可以使用<code class="fe me mf mg mh b">useState</code>钩子。通过使用数组析构来声明状态变量和设置状态变量，而不是将状态声明为对象并一次设置所需数量的属性。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ebcf" class="mq lc iq mh b gy mr ms l mt mu">import React, { useState } from 'react';</span><span id="36db" class="mq lc iq mh b gy mv ms l mt mu">const FunctionComponent = () =&gt; {<br/>  <strong class="mh ir">const [list, setList] = useState([]);<br/>  const [currentItem, setCurrentItem = useState('');</strong><br/>  return ();<br/>}</span><span id="1e62" class="mq lc iq mh b gy mv ms l mt mu">export default FunctionComponent</span></pre><h1 id="1d08" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">渲染组件</h1><p id="bd73" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">很好，现在我们已经初始化了我们的状态，让我们渲染我们的组件。我将在<code class="fe me mf mg mh b">state</code>中的<code class="fe me mf mg mh b">list</code>属性中添加一些项目，这样我们就有一些数据要呈现了。请注意，<code class="fe me mf mg mh b">list</code>中的每一项都是一个具有三个属性的对象——一个<code class="fe me mf mg mh b">id</code>、一个<code class="fe me mf mg mh b">task</code>和一个<code class="fe me mf mg mh b">completed</code>属性，这三个属性表明我们的待办事项列表中的任务是否已经完成。我还将<a class="ae kc" href="https://www.npmjs.com/package/react-flexbox-grid" rel="noopener ugc nofollow" target="_blank">安装</a>并导入<code class="fe me mf mg mh b"><a class="ae kc" href="https://roylee0704.github.io/react-flexbox-grid/" rel="noopener ugc nofollow" target="_blank">react-flexbox-grid</a></code>，这样我们就有了一个易于使用的网格系统。</p><h2 id="8a18" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">类别组件:</h2><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5ee5" class="mq lc iq mh b gy mr ms l mt mu">import React, { Component } from 'react';<br/><strong class="mh ir">import { Grid, Row, Col } from 'react-flexbox-grid';</strong></span><span id="b41e" class="mq lc iq mh b gy mv ms l mt mu">class ClassComponent extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      <strong class="mh ir">list: [<br/>        {<br/>          id: 1,<br/>          task: 'Create tasks',<br/>          completed: false,<br/>        },<br/>        {<br/>          id: 2,<br/>          task: 'Read tasks',<br/>          completed: false,<br/>        },<br/>        {<br/>          id: 3,<br/>          task: 'Mark complete',<br/>          completed: false,<br/>        },<br/>        {<br/>          id: 4,<br/>          task: 'Delete tasks',<br/>          completed: false,<br/>        },<br/>      ],<br/>      currentItem: '',</strong><br/>    }<br/>  }<br/>  render() {<br/>    return (<br/>      <strong class="mh ir">&lt;Grid fluid&gt;<br/>        &lt;Row&gt;<br/>          &lt;Col xs={6} md={3}&gt;<br/>            &lt;h3&gt;Things to do:&lt;/h3&gt;<br/>            &lt;ul&gt;<br/>              {this.state.list.length ? (                this.state.list.map( item =&gt; (<br/>                  &lt;React.Fragment key={item.id}&gt;<br/>                    &lt;li&gt;<br/>                      {item.task}<br/>                    &lt;/li&gt;<br/>                  &lt;/React.Fragment&gt;<br/>                ))<br/>              ) : (null)<br/>              }<br/>            &lt;/ul&gt;<br/>          &lt;/Col&gt;<br/>        &lt;/Row&gt;<br/>      &lt;/Grid&gt;</strong><br/>    );<br/>  }<br/>}</span><span id="8091" class="mq lc iq mh b gy mv ms l mt mu">export default ClassComponent;</span></pre><h2 id="7ea6" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">功能组件:</h2><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2438" class="mq lc iq mh b gy mr ms l mt mu">import React, { useState } from 'react';</span><span id="de02" class="mq lc iq mh b gy mv ms l mt mu">const FunctionComponent = () =&gt; {<br/>  const [list, setList] = useState([<br/>    <strong class="mh ir">{<br/>      id: 1,<br/>      task: 'Create tasks',<br/>      completed: false,<br/>    },<br/>    {<br/>      id: 2,<br/>      task: 'Read tasks',<br/>      completed: false,<br/>    },<br/>    {<br/>      id: 3,<br/>      task: 'Mark complete',<br/>      completed: false,<br/>    },<br/>    {<br/>      id: 4,<br/>      task: 'Delete tasks',<br/>      completed: false,<br/>    },</strong><br/>  ],);<br/>  const [currentItem, setCurrentItem] = useState('');<br/>  return (<br/>    <strong class="mh ir">&lt;Grid fluid&gt;<br/>      &lt;Row&gt;<br/>        &lt;Col xs={6} md={3}&gt;<br/>          &lt;h3&gt;Things to do:&lt;/h3&gt;<br/>          &lt;ul style={{listStyleType: 'none'}}&gt;<br/>            {list.length ? (<br/>              list.map( item =&gt; (<br/>                &lt;React.Fragment key={item.id}&gt;<br/>                  &lt;li&gt;<br/>                    {item.task}<br/>                  &lt;/li&gt;<br/>                &lt;/React.Fragment&gt;<br/>              ))<br/>            ) : (null)<br/>            }<br/>          &lt;/ul&gt;<br/>        &lt;/Col&gt;<br/>      &lt;/Row&gt;<br/>    &lt;/Grid&gt;</strong><br/>  );<br/>}</span><span id="f054" class="mq lc iq mh b gy mv ms l mt mu">export default FunctionComponent</span></pre><h1 id="b65d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置状态</h1><p id="6f45" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们已经初始化了状态并呈现了组件，让我们添加一些操作状态数据的功能，比如添加任务、标记任务完成和删除任务。这将让我们看到类和函数组件中状态更新方式的不同。</p><p id="a8cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在类和函数组件中，当更新状态时，不应该直接更新它。对于类组件，提供的方法是<code class="fe me mf mg mh b">setState</code>。对于函数组件，我们可以使用在使用React钩子<code class="fe me mf mg mh b">useState</code>初始化状态时声明的set状态变量。</p><h2 id="057e" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">在类组件中添加任务:</h2><p id="8e1b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我想添加一个文本输入字段，允许用户将任务添加到他们的待办事项列表中。我将把<code class="fe me mf mg mh b">value</code>属性设置为<code class="fe me mf mg mh b">this.state.currentItem</code>，这是我们刚刚在<code class="fe me mf mg mh b">state</code>对象中初始化的，我还将创建一个<code class="fe me mf mg mh b">handleChange</code>函数，它将通过<code class="fe me mf mg mh b">input</code>标签的<code class="fe me mf mg mh b">onChange</code>属性触发。<code class="fe me mf mg mh b">handleChange</code>函数将使用<code class="fe me mf mg mh b">setState</code>来更新<code class="fe me mf mg mh b">state</code>的<code class="fe me mf mg mh b">currentItem</code>属性。当输入值由React而不是HTML控制时，这被称为<em class="nh">受控组件— </em>。现在，当用户在输入域中输入时，<code class="fe me mf mg mh b">currentItem</code>会随着每次击键而更新。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8b3b" class="mq lc iq mh b gy mr ms l mt mu">handleChange = e =&gt; this.setState({currentItem: e.target.value})</span></pre><p id="449b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，<code class="fe me mf mg mh b">setState</code>接受一个对象，该对象用该对象中相应的一个或多个属性更新状态。</p><p id="720b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还将用<code class="fe me mf mg mh b">form</code>标签包装<code class="fe me mf mg mh b">input</code>标签，并将<code class="fe me mf mg mh b">onSubmit</code>属性设置为<code class="fe me mf mg mh b">handleSubmit</code>函数。这将在<code class="fe me mf mg mh b">list</code>数组中添加另一个项目。该项将是一个具有我们前面提到的三个属性的对象。在阻止了刷新页面的默认行为<code class="fe me mf mg mh b">onSubmit</code>之后，我们需要生成一个惟一的<code class="fe me mf mg mh b">id</code>，然后设置状态以将新的项目推送到列表中。我将再次使用<code class="fe me mf mg mh b">setState</code>，但这一次，我将传入一个返回对象的函数，而不是传入一个对象。因为我们的新状态依赖于从前一个状态获取数据，所以我们可以传入前一个状态来实现这一点。我们的<code class="fe me mf mg mh b">handleChange</code>函数更新了<code class="fe me mf mg mh b">currentItem</code>，所以现在我们的<code class="fe me mf mg mh b">handleSubmit</code>需要获取<code class="fe me mf mg mh b">currentItem</code>的值，并将其设置为新项目的<code class="fe me mf mg mh b">task</code>属性。最后，对于第三个属性，我们将把<code class="fe me mf mg mh b">completed</code>设置为<code class="fe me mf mg mh b">false</code>。此外，通过传入函数，我们可以在返回对象之前运行一些代码。我将声明一个<code class="fe me mf mg mh b">const newItem</code>并将它设置为一个具有我们三个属性的对象。现在我们可以返回一个对象，将<code class="fe me mf mg mh b">list</code>属性设置到一个数组中，该数组将<code class="fe me mf mg mh b">list</code>从前一个状态展开，并将<code class="fe me mf mg mh b">newItem</code>添加到数组的末尾。我们也可以将<code class="fe me mf mg mh b">currentItem</code>设置为空字符串。这将把输入字段重置为空白，使用户更容易输入另一个任务。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f19c" class="mq lc iq mh b gy mr ms l mt mu">import React, { Component } from 'react';<br/>import { Grid, Row, Col } from 'react-flexbox-grid';</span><span id="6d53" class="mq lc iq mh b gy mv ms l mt mu">class ClassComponent extends Component {<br/>  .<br/>  .<br/>  .<br/>  <strong class="mh ir">handleChange = e =&gt; this.setState({currentItem: e.target.value})</strong></span><span id="1846" class="mq lc iq mh b gy mv ms l mt mu"><strong class="mh ir">  handleSubmit = e =&gt; {<br/>    e.preventDefault()</strong></span><span id="c7ef" class="mq lc iq mh b gy mv ms l mt mu"><strong class="mh ir">  <em class="nh">// generate an unused id</em><br/>    let newId = 1;<br/>    let sortedListByIds = this.state.list.slice().sort((a, b) =&gt; (a.id - b.id))<br/>    for (let i = 0; i &lt; sortedListByIds.length; i++) {<br/>      if (newId === sortedListByIds[i].id) {<br/>        newId++<br/>      }<br/>    }</strong></span><span id="2e08" class="mq lc iq mh b gy mv ms l mt mu"><strong class="mh ir">this.setState(prevState =&gt; {<br/>      const newItem = {<br/>        id: newId,<br/>        task: prevState.currentItem,<br/>        completed: false,<br/>      }<br/>      return {<br/>        list: [...prevState.list, newItem],<br/>        currentItem: '',<br/>      }<br/>    })<br/>  }</strong></span><span id="1489" class="mq lc iq mh b gy mv ms l mt mu">render() {<br/>    return (<br/>      &lt;Grid fluid&gt;<br/>        &lt;Row&gt;<br/>          &lt;Col xs={6} md={3}&gt;<br/>            .<br/>            .<br/>            .<br/>          &lt;/Col&gt;<br/>          <strong class="mh ir">&lt;Col xs={6} md={6}&gt;<br/>            &lt;h4&gt;Add task:&lt;/h4&gt;<br/>            &lt;form onSubmit={this.handleSubmit}&gt;<br/>              &lt;input type="text" autoFocus value={this.state.currentItem} onChange={this.handleChange} /&gt;<br/>              &lt;button type="submit"&gt;+&lt;/button&gt;</strong><br/>            <strong class="mh ir">&lt;/form&gt;<br/>          &lt;/Col&gt;</strong><br/>        &lt;/Row&gt;<br/>      &lt;/Grid&gt;<br/>    );<br/>  }<br/>}</span><span id="e904" class="mq lc iq mh b gy mv ms l mt mu">export default ClassComponent;</span></pre><h2 id="a5f5" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">在功能组件中添加任务:</h2><p id="8388" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于函数组件,<code class="fe me mf mg mh b">form</code>和<code class="fe me mf mg mh b">input</code>标签将与我们在类组件中设置它们的方式完全相同。<code class="fe me mf mg mh b">handleChange</code>和<code class="fe me mf mg mh b">handleSubmit</code>将使用我们通过<code class="fe me mf mg mh b">useState</code> React钩子初始化状态时声明的设置变量。回想一下，当我们为<code class="fe me mf mg mh b">currentItem</code>设置数组析构时，第二项是<code class="fe me mf mg mh b">setCurrentItem</code>。这是我们用来更新我们的<code class="fe me mf mg mh b">currentItem</code>的。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="826f" class="mq lc iq mh b gy mr ms l mt mu">const handleChange = e =&gt; setCurrentItem(e.target.value)</span></pre><p id="6484" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe me mf mg mh b">handleSubmit</code>函数，我们仍将阻止默认行为，我们仍将生成唯一的<code class="fe me mf mg mh b">id</code>，但我们将使用<code class="fe me mf mg mh b">useState</code> React钩子更新状态。与我们可以一次更新两个属性的类组件不同，使用<code class="fe me mf mg mh b">useState</code>我们必须为每个属性分别更新。要将新项目添加到我们的<code class="fe me mf mg mh b">list</code>，就像在类组件中一样，我们需要访问之前的<code class="fe me mf mg mh b">list</code>。<code class="fe me mf mg mh b">useState</code>也可以接受一个函数作为参数，我们可以向该函数传递一个参数，在我们的例子中是<code class="fe me mf mg mh b">prevList</code>，以获取之前的数据。为了重置输入字段，我们可以在<code class="fe me mf mg mh b">setCurrentItem</code>中传递一个空字符串…</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d61d" class="mq lc iq mh b gy mr ms l mt mu">const handleSubmit = e =&gt; {<br/>  e.preventDefault()</span><span id="e5b8" class="mq lc iq mh b gy mv ms l mt mu"><em class="nh">  // generate an unused id</em><br/>  let newId = 1;<br/>  let sortedListByIds = list.slice().sort((a, b) =&gt; (a.id - b.id))<br/>  for (let i = 0; i &lt; sortedListByIds.length; i++) {<br/>    if (newId === sortedListByIds[i].id) {<br/>      newId++<br/>    }<br/>  }</span><span id="e0d8" class="mq lc iq mh b gy mv ms l mt mu"><strong class="mh ir">setList(prevList =&gt; {<br/>    const newItem = {<br/>      id: newId,<br/>      task: currentItem,<br/>      completed: false,<br/>    }<br/>    return [...prevList, newItem]<br/>  })<br/>  setCurrentItem('')</strong><br/>}</span></pre><h2 id="08ab" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">切换完成状态和删除类组件中的任务:</h2><p id="c714" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于类和函数组件，用于将项目标记为完成或未完成的jsx和用于删除任务的按钮的jsx是相同的。单击列表项会给它一条删除线，表示任务已完成，再次单击它会删除表示任务未完成的删除线。每个列表项还会有一个从列表中删除该项的按钮。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7373" class="mq lc iq mh b gy mr ms l mt mu">.<br/>.<br/>.<br/>&lt;ul style={{listStyleType: 'none'}}&gt;<br/>  {list.length ? (<br/>    list.map( item =&gt; (<br/>      &lt;React.Fragment key={item.id}&gt;<br/>        &lt;li onClick={() =&gt; toggleCompleteStatus(item.id)} style={{textDecoration: item.completed ? 'line-through' : 'none'}}&gt;<br/>          {item.task}<br/>        &lt;/li&gt; &lt;button onClick={() =&gt; deleteTask(item.id)}&gt;x&lt;/button&gt;<br/>      &lt;/React.Fragment&gt;<br/>    ))<br/>  ) : (null)<br/>  }<br/>&lt;/ul&gt;<br/>.<br/>.<br/>.</span></pre><p id="42ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们把这些连接到一些函数上。对于<code class="fe me mf mg mh b">toggleCompleteStatus</code>，我们将传入一个<code class="fe me mf mg mh b">id</code>并使用<code class="fe me mf mg mh b">setState</code>返回一个具有<code class="fe me mf mg mh b">list</code>属性的对象。我们将使用<code class="fe me mf mg mh b">map</code>方法映射当前的<code class="fe me mf mg mh b">list</code>并找到具有匹配<code class="fe me mf mg mh b">id</code>的项目，并将该项目的完成状态从<code class="fe me mf mg mh b">false</code>切换到<code class="fe me mf mg mh b">true</code>，反之亦然。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cc2d" class="mq lc iq mh b gy mr ms l mt mu">toggleCompleteStatus = id =&gt; {<br/>  this.setState(() =&gt; {<br/>    return {<br/>      list: this.state.list.map( item =&gt; item.id === id ? {...item, completed: !item.completed} : item)<br/>    }<br/>  }<br/>}</span></pre><p id="e81f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe me mf mg mh b">deleteTask</code>函数，我们也将传入一个<code class="fe me mf mg mh b">id</code>。我们还将声明一个变量<code class="fe me mf mg mh b">let filteredList</code>，我们将使用<code class="fe me mf mg mh b">filter</code>方法来搜索<code class="fe me mf mg mh b">list</code>中的每一项，寻找与参数不匹配的<code class="fe me mf mg mh b">id</code>。所有不匹配的条目都将在一个新的数组中返回，忽略被删除的条目。然后我们可以使用<code class="fe me mf mg mh b">setState</code>返回一个属性为<code class="fe me mf mg mh b">list</code>的对象，该对象等于一个展开了<code class="fe me mf mg mh b">filteredList</code>的数组。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="49b1" class="mq lc iq mh b gy mr ms l mt mu">deleteTask = id =&gt; {<br/>  let filteredList = this.state.list.filter( item =&gt; item.id !== id)<br/>  this.setState({<br/>    list: [...filteredList]<br/>  }<br/>}</span></pre><h2 id="cd8f" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">切换完成状态和删除功能组件中的任务:</h2><p id="36e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在函数组件中，这些函数看起来非常相似，除了我们将再次使用我们用React的<code class="fe me mf mg mh b">useState</code>声明的set state变量来更新我们的数据，而不是使用<code class="fe me mf mg mh b">setState</code>。我们使用的数组方法——<code class="fe me mf mg mh b">map</code>和<code class="fe me mf mg mh b">filter</code>——使用方式完全相同。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="557a" class="mq lc iq mh b gy mr ms l mt mu">const toggleCompleteStatus = id =&gt; {<br/>  <strong class="mh ir">setList</strong>(list.map( item =&gt; item.id === id ? {...item, completed: !item.completed} : item))<br/>}</span><span id="61ee" class="mq lc iq mh b gy mv ms l mt mu">const deleteTask = id =&gt; {<br/>  let filteredList = list.filter( item =&gt; item.id !== id)<br/>  <strong class="mh ir">setList</strong>([...filteredList])<br/>}</span></pre><h1 id="fade" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生命周期和使用效果挂钩</h1><p id="d817" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类组件可以使用生命周期挂钩在组件生命周期的特定点触发功能。例如，从api获取数据的最佳时机是在组件输出呈现到DOM之后运行的<code class="fe me mf mg mh b">componentDidMount</code>钩子期间。然而，函数组件没有生命周期挂钩，但仍然可以在第一次渲染和每次更新后产生副作用。所以只在第一次渲染时产生副作用相当于在<code class="fe me mf mg mh b">componentDidMount</code>钩子上产生一个函数。这是使用React钩子<code class="fe me mf mg mh b">useEffect</code>完成的。</p><p id="8e23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了展示这两者的例子，让我们使用<code class="fe me mf mg mh b">localStorage</code>作为一种使数据持久化的方法。这也将使这个待办事项应用程序成为一个真正的功能性应用程序，因为即使用户刷新页面、关闭浏览器或关闭计算机，数据也会持续存在。</p><h2 id="b330" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">用setState的回调函数保存列表项:</h2><p id="5f54" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">setState</code>函数接受第二个参数，这是一个回调函数。因此，对于<code class="fe me mf mg mh b">handleSubmit</code>、<code class="fe me mf mg mh b">toggleCompleteStatus</code>和<code class="fe me mf mg mh b">deleteTask</code>，我们可以添加一些代码，将<code class="fe me mf mg mh b">list</code>数据保存到用户设备的本地。<code class="fe me mf mg mh b">localStorage</code>的<code class="fe me mf mg mh b">setItem</code>方法将数据保存为用户浏览器中的键值对，其中的值是JSON格式。在我们的例子中，我们将保存我们的<code class="fe me mf mg mh b">state</code>的<code class="fe me mf mg mh b">list</code>属性的值。<code class="fe me mf mg mh b">setItem</code>方法有两个参数。第一个是字符串，用作我们的键，第二个是JSON对象，用作我们的值。我们将使用方法<code class="fe me mf mg mh b">JSON.stringify</code>并传入我们的<code class="fe me mf mg mh b">list</code>来将其转换成JSON对象…</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="95d9" class="mq lc iq mh b gy mr ms l mt mu">localStorage.setItem('list', JSON.stringify(this.state.list))</span></pre><p id="681c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在我们可以把它附加到<code class="fe me mf mg mh b">handleSubmit</code>、<code class="fe me mf mg mh b">toggleCompleteStatus</code>和<code class="fe me mf mg mh b">deleteTask</code>的<code class="fe me mf mg mh b">setState</code>回调函数上。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1ff3" class="mq lc iq mh b gy mr ms l mt mu"><strong class="mh ir">handleSubmit</strong> = e =&gt; {<br/>  .<br/>  .<br/>  .<br/>  this.setState(prevState =&gt; {<br/>    const newItem = {<br/>      id: newId,<br/>      task: prevState.currentItem,<br/>      completed: false,<br/>    }<br/>    return {<br/>      list: [...prevState.list, newItem],<br/>      currentItem: '',<br/>    }<br/>  }<strong class="mh ir">, () =&gt; localStorage.setItem('list', JSON.stringify(this.state.list))</strong><br/>  )<br/>}</span><span id="0a5d" class="mq lc iq mh b gy mv ms l mt mu"><strong class="mh ir">toggleCompleteStatus</strong> = id =&gt; {<br/>  this.setState(() =&gt; {<br/>    return {<br/>      list: this.state.list.map( item =&gt; item.id === id ? {...item, completed: !item.completed} : item)<br/>    }<br/>  }<strong class="mh ir">, () =&gt; localStorage.setItem('list', JSON.stringify(this.state.list))</strong><br/>  )<br/>}</span><span id="e5b2" class="mq lc iq mh b gy mv ms l mt mu"><strong class="mh ir">deleteTask</strong> = id =&gt; {<br/>  let filteredList = this.state.list.filter( item =&gt; item.id !== id)<br/>  this.setState({<br/>    list: [...filteredList]<br/>  }<strong class="mh ir">, () =&gt; localStorage.setItem('list', JSON.stringify(this.state.list))</strong><br/>  )<br/>}</span></pre><p id="e7c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">setState</code>是一个异步函数，它的第二个参数回调函数在状态更新后触发。这意味着您可以确信传递到开发工具的本地存储中的数据将是最新的。</p><p id="25bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过打开您的开发工具并单击Application选项卡来查看本地存储数据。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/440f169af87821c6270d6d837a6ea6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tq8etiGHfle2NnFPtSgW5A.png"/></div></div></figure><h2 id="8c1a" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">保留具有useEffect的列表项:</h2><p id="7656" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们一直在使用我们的“set”函数来更新函数组件中的状态。虽然<code class="fe me mf mg mh b">setState</code>允许回调函数作为类组件中的第二个参数，但是我们的set state函数没有同样的便利。然而，我们可以使用React钩子<code class="fe me mf mg mh b">useEffect</code>在特定状态更新时触发副作用。让我们像这样导入使用效果…</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="11d7" class="mq lc iq mh b gy mr ms l mt mu">import React, { useState<strong class="mh ir">, useEffect</strong> } from 'react';</span></pre><p id="b319" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有将代码添加到我们当前的函数中，而是将一个匿名函数作为第一个参数传递给<code class="fe me mf mg mh b">useEffect</code>，并将一个变量数组作为第二个参数。每当第二个参数数组中的一个变量被更新时，匿名函数中的代码块将被触发。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="05ec" class="mq lc iq mh b gy mr ms l mt mu">useEffect(() =&gt; {<br/>  localStorage.setItem('list', JSON.stringify(list))<br/>}, [list])</span></pre><p id="6d80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意第二个参数有一个包含变量<code class="fe me mf mg mh b">list</code>的数组。由于<code class="fe me mf mg mh b">handleSubmit</code>、<code class="fe me mf mg mh b">toggleCompleteStatus</code>和<code class="fe me mf mg mh b">deleteTask</code>都更新<code class="fe me mf mg mh b">list</code>状态，那么每当这些函数更新<code class="fe me mf mg mh b">list</code>时，这个useEffect函数将被触发。</p><h2 id="fd08" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">获取componentDidMount上的本地数据:</strong></h2><p id="ace3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">酷，所以现在我们可以在类和函数组件中设置数据到我们的本地存储中，但是我们仍然需要获取数据，这样它就可以呈现到DOM中。</p><p id="dcaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的类和函数组件，我们确实有我们的<code class="fe me mf mg mh b">list</code>项的初始状态，但我们也想检查是否有本地数据，所以如果用户已经使用了这个应用程序，他们可以看到他们的任务列表，就像他们上次加载站点时一样。</p><p id="dbd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取类组件数据的最佳时间是在类组件呈现后的生命周期挂钩期间。我们将使用<code class="fe me mf mg mh b">localStorage</code>的<code class="fe me mf mg mh b">getItem</code>方法，它接受一个参数，这个参数是存储我们数据的键的名称字符串——在我们的例子中是<code class="fe me mf mg mh b">'list'</code>。我们还必须使用<code class="fe me mf mg mh b">JSON.parse()</code>将我们的JSON字符串转换成一个数组。如果用户没有本地数据，那么它将返回<code class="fe me mf mg mh b">null</code>。如果它是<code class="fe me mf mg mh b">null</code>,那么我们不需要设置我们的状态，我们在构造函数中设置的初始状态将会保留并呈现。如果不是<code class="fe me mf mg mh b">null</code>，那么我们将设置我们的<code class="fe me mf mg mh b">state</code>来用我们刚刚获取的数据更新<code class="fe me mf mg mh b">list</code>属性。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c082" class="mq lc iq mh b gy mr ms l mt mu">componentDidMount() {<br/>  let localList = JSON.parse(localStorage.getItem('list'));<br/>  if (localList !== null) {<br/>    this.setState(() =&gt; {<br/>      return {<br/>        list: localList<br/>      }<br/>    })<br/>  }<br/>}</span></pre><h2 id="6ba8" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">使用useEffect获取初始渲染的本地数据:</strong></h2><p id="ee31" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们现在知道，只要我们的一个状态变量更新，我们就可以激发副作用。但是如果功能组件没有生命周期挂钩，我们怎么能在初始渲染时产生副作用呢？为此，我们所要做的就是传入一个空数组作为第二个参数。在这种情况下，useEffect只会在初始渲染时触发，就像<code class="fe me mf mg mh b">componentDidMount</code>一样。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e743" class="mq lc iq mh b gy mr ms l mt mu">useEffect(() =&gt; {<br/>  let localList = JSON.parse(localStorage.getItem('list'));<br/>  if (localList !== null) {<br/>    setList(localList)<br/>  }<br/>}, []) <em class="nh">// empty array as second argument will behave exactly like componentDidMount</em></span></pre><h1 id="dd03" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="20d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">就是这样！我们现在有了一个全功能的待办事项列表应用程序，它是通过两种不同的方式构建的——通过类组件和通过函数组件。我们有一个列表项的初始状态，用户第一次使用这个应用程序时会加载它。他们可以添加和删除任务。他们可以将任务标记为完成或未完成。数据保存在浏览器的本地存储器中，因此，如果他们关闭浏览器，稍后回到这个网站，他们的数据仍然可以查看，并根据需要进行更新。无需保存到云或登录帐户。他们数据的隐私和他们设备的隐私一样好。这是一个基本的实现，所以我把CSS交给你了。我的希望是，您已经了解或巩固了状态如何通过React中的类和函数组件初始化和更新，以及如何使用生命周期钩子和<code class="fe me mf mg mh b">useEffect</code>的区别。感谢您阅读并坚持到现在。做好人！</p><p id="9e66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看app:<a class="ae kc" href="https://darrylmendonez.github.io/barebones-react-todo-list/#/" rel="noopener ugc nofollow" target="_blank">https://darrylmendonez . github . io/bare bones-react-todo-list/#/</a></p><p id="32f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看回购:<a class="ae kc" href="https://github.com/darrylmendonez/barebones-react-todo-list" rel="noopener ugc nofollow" target="_blank">https://github.com/darrylmendonez/barebones-react-todo-list</a></p></div></div>    
</body>
</html>