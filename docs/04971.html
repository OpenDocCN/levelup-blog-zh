<html>
<head>
<title>Diesel: A Rust-y ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">柴油:一种铁锈色的形式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/diesel-a-rust-y-orm-e2c247e97835?source=collection_archive---------8-----------------------#2020-07-27">https://levelup.gitconnected.com/diesel-a-rust-y-orm-e2c247e97835?source=collection_archive---------8-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/83da5660430046c5881875942480db37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qYOF9utBG538Q-idibjs0A.jpeg"/></div></figure><p id="5119" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><a class="ae kv" href="https://www.mmhaskell.com/blog/2020/7/13/basic-postgres-data-in-rust" rel="noopener ugc nofollow" target="_blank">上周</a>周一早上Haskell我们用Rust迈出了进入一些真实世界任务的第一步。我们探索了简单的Rust Postgres库来连接数据库并运行一些查询。本周我们将使用<a class="ae kv" href="https://diesel.rs/guides/getting-started/" rel="noopener ugc nofollow" target="_blank"> Diesel </a>，这是一个具有一些很酷的ORM功能的库。这有点像Haskell库Persistent，您可以在我们的<a class="ae kv" href="https://www.mmhaskell.com/real-world/databases" rel="noopener ugc nofollow" target="_blank">真实世界Haskell系列</a>中探索更多。</p><p id="c17b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要更深入地了解本文的代码，您应该看看我们的<a class="ae kv" href="https://github.com/MondayMorningHaskell/RustWeb" rel="noopener ugc nofollow" target="_blank"> Github库</a>！您可能想看看下面引用的文件，以及这里的可执行文件<a class="ae kv" href="https://github.com/MondayMorningHaskell/RustWeb/blob/master/src/bin/pg_diesel.rs" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="15af" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Diesel CLI</h1><p id="1192" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">我们的第一步是在程序中添加Diesel作为依赖项。我们在上周的文章中简要讨论了货物的“特性”。对于您可能使用的每个后端，Diesel都有单独的特性。所以我们将指定“postgres”。同样，我们还将为<code class="fe lz ma mb mc b">chrono</code>库使用一个特殊的特性，这样我们就可以在数据库中使用时间戳。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="a44a" class="ml kx it mc b gy mm mn l mo mp">[[dependencies]]<br/>diesel={version="1.4.4", features=["postgres", "chrono"]}</span></pre><p id="dac9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但还有更多！Diesel附带了一个CLI来帮助我们管理数据库迁移。它还会生成一些我们的模式代码。正如我们可以使用<code class="fe lz ma mb mc b">stack install</code>用Stack安装二进制文件一样，我们也可以用Cargo安装二进制文件。我们只想指定我们想要的特性。否则，如果我们没有安装其他数据库，它就会崩溃。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="c5b6" class="ml kx it mc b gy mm mn l mo mp">&gt;&gt; cargo install diesel_cli --no-default-features --features postgres</span></pre><p id="c25b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们可以开始使用这个程序来设置我们的项目，以生成我们的迁移。我们从这个命令开始。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="5761" class="ml kx it mc b gy mm mn l mo mp">&gt;&gt; diesel setup</span></pre><p id="dec8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这在我们的项目目录中创建了几个不同的项目。首先，我们有一个“migrations”文件夹，我们将在其中放置一些SQL代码。然后我们还在我们的<code class="fe lz ma mb mc b">src</code>目录中得到一个<code class="fe lz ma mb mc b">schema.rs</code>文件。Diesel会在这个文件中自动为我们生成代码。让我们看看如何！</p><h1 id="26cb" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">迁移和模式</h1><p id="606e" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">在Haskell中使用Persistent时，我们使用特殊的模板语言在一个模式文件中定义了基本类型。我们可以通过编程在整个模式上运行迁移，而不需要我们自己的SQL。但是随着模式的发展，很难跟踪更复杂的迁移。</p><p id="43a4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">柴油有点不一样。不幸的是，我们必须自己编写SQL。但是，我们会以一种更容易在我们的桌面上采取更细粒度行动的方式来这样做。然后，Diesel将为我们生成一个模式文件。但是我们仍然需要一些额外的工作来得到我们需要的铁锈类型。首先，让我们使用Diesel来生成我们的第一次迁移。这个迁移将创建我们的“用户”表。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="c35f" class="ml kx it mc b gy mm mn l mo mp">&gt;&gt; diesel migration generate create_users</span></pre><p id="660b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这将在我们的“migrations”目录中为“create_users”迁移创建一个新文件夹。它有两个文件，<code class="fe lz ma mb mc b">up.sql</code>和<code class="fe lz ma mb mc b">down.sql</code>。我们从填充<code class="fe lz ma mb mc b">up.sql</code>文件开始，指定运行迁移所需的SQL。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="ec69" class="ml kx it mc b gy mm mn l mo mp">CREATE TABLE users (<br/>  id SERIAL PRIMARY KEY,<br/>  name TEXT NOT NULL,<br/>  email TEXT NOT NULL,<br/>  age INTEGER NOT NULL<br/>)</span></pre><p id="f835" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们还希望<code class="fe lz ma mb mc b">down.sql</code>文件包含逆转迁移的SQL。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="ff3f" class="ml kx it mc b gy mm mn l mo mp">DROP TABLE users CASCADE;</span></pre><p id="8d3b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦我们写了这些，我们就可以运行我们的迁移！</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="43d8" class="ml kx it mc b gy mm mn l mo mp">&gt;&gt; diesel migration run</span></pre><p id="8910" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们可以撤销迁移，用这个命令运行<code class="fe lz ma mb mc b">down.sql</code>中的代码:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="25d8" class="ml kx it mc b gy mm mn l mo mp">&gt;&gt; diesel migration redo</span></pre><p id="36ad" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行我们的迁移的结果是Diesel填充了<code class="fe lz ma mb mc b">schema.rs</code>文件。这个文件使用了<code class="fe lz ma mb mc b">table</code>宏，它为我们生成了有用的类型和特征实例。当我们将表格合并到代码中时，我们会用到它。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="59bc" class="ml kx it mc b gy mm mn l mo mp">table! {<br/>  users (id) {<br/>    id -&gt; Int4,<br/>    name -&gt; Text,<br/>    email -&gt; Text,<br/>    age -&gt; Int4,<br/>  }<br/>}</span></pre><p id="8c6c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，让我们再进行一次迁移，添加一个articles表。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="bd84" class="ml kx it mc b gy mm mn l mo mp">-- migrations/create_articles/up.sql<br/>CREATE TABLE articles (<br/>  id SERIAL PRIMARY KEY,<br/>  title TEXT NOT NULL,<br/>  body TEXT NOT NULL,<br/>  published_at TIMESTAMP WITH TIME ZONE NOT NULL,<br/>  author_id INTEGER REFERENCES users(id) NOT NULL<br/>)</span><span id="b340" class="ml kx it mc b gy mq mn l mo mp">-- migrations/create_articles/down.sql<br/>DROP TABLE articles;</span></pre><p id="a166" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们可以再次使用<code class="fe lz ma mb mc b">diesel migration run</code>。</p><h1 id="9cbe" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">模型类型</h1><p id="c150" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">现在，虽然Diesel将为我们生成大量有用的代码，但我们仍然需要自己做一些工作。我们必须为数据类型创建自己的结构，以利用我们获得的实例。有了Persistent，我们可以免费得到这些。Persistent还使用了一个包装器<code class="fe lz ma mb mc b">Entity</code>类型，它将一个<code class="fe lz ma mb mc b">Key</code>附加到我们的实际数据上。</p><p id="dfec" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Diesel没有实体的概念。我们必须手动创建两个不同的类型，一个有数据库密钥，一个没有。对于拥有密钥的“实体”类型，我们将派生出“可查询”类。然后我们可以使用Diesel的函数从表中选择项目。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="fe0a" class="ml kx it mc b gy mm mn l mo mp">#[derive(Queryable)]<br/>pub struct UserEntity {<br/>  pub id: i32<br/>  pub name: String,<br/>  pub email: String,<br/>  pub age: i32<br/>}</span></pre><p id="b544" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们必须声明一个实现“Insertable”的单独类型。这没有数据库密钥，因为我们在插入项目之前不知道密钥。这应该是我们的实体类型的副本，但是没有关键字段。我们使用第二个宏将它绑定到<code class="fe lz ma mb mc b">users</code>表。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="292d" class="ml kx it mc b gy mm mn l mo mp">#[derive(Insertable)]<br/>#[table_name="users"]<br/>pub struct User {<br/>  pub name: String,<br/>  pub email: String,<br/>  pub age: i32<br/>}</span></pre><p id="6d40" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，对于我们的外键类型，我们将使用一个普通的整数作为列引用。在持久化中，我们会有一个特殊的<code class="fe lz ma mb mc b">Key</code>类型。这样做我们就失去了这个字段的一些语义意义。但是它可以帮助我们将更多的代码从这个特定的库中分离出来。</p><h1 id="c000" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">进行查询</h1><p id="5d91" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">现在我们已经有了模型，我们可以开始使用它们来编写查询。首先，我们需要使用<code class="fe lz ma mb mc b">establish</code>函数建立一个数据库连接。在本文中，我们将使用<code class="fe lz ma mb mc b">.expect</code>来展开我们的结果，而不是使用<code class="fe lz ma mb mc b">?</code>语法。这不太安全，但是更容易操作。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="5fa0" class="ml kx it mc b gy mm mn l mo mp">fn create_connection() -&gt; PgConnection {<br/>  let database_url = "postgres://postgres:postgres@localhost/rust_db";<br/>  PgConnection::establish(&amp;database_url)<br/>    .expect("Error Connecting to database")<br/>}</span><span id="ea2d" class="ml kx it mc b gy mq mn l mo mp">fn main() {<br/>  let connection: PgConnection = create_connection();<br/>  ...<br/>}</span></pre><p id="a45b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们从插入开始。当然，我们首先创建一个“Insertable”<code class="fe lz ma mb mc b">User</code>项目。然后我们可以开始用Diesel函数<code class="fe lz ma mb mc b">insert_into</code>编写一个插入查询。</p><p id="de4f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Diesel的查询函数是可组合的。我们向查询中添加不同的元素，直到查询完成。对于插入，我们使用<code class="fe lz ma mb mc b">values</code>结合我们想要插入的项目。然后，我们用我们的连接调用<code class="fe lz ma mb mc b">get_result</code>。插入的结果是我们的“实体”类型。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="601d" class="ml kx it mc b gy mm mn l mo mp">fn create_user(conn: &amp;PgConnection) -&gt; UserEntity {<br/>  let u = User<br/>    { name = "James".to_string()<br/>    , email: "james@test.com".to_string()<br/>    , age: 26};</span><span id="8b7e" class="ml kx it mc b gy mq mn l mo mp">  diesel::insert_into(users::table).values(&amp;u)<br/>    .get_result(conn).expect("Error creating user!")<br/>}</span></pre><h1 id="6e55" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">选择项目</h1><p id="a106" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">选择项目有点复杂。Diesel为我们的每种类型生成一个<code class="fe lz ma mb mc b">dsl</code>模块。这允许我们在“过滤器”和排序中使用每个字段名作为一个值。假设我们想获取某个用户写的所有文章。我们将在<code class="fe lz ma mb mc b">articles</code>表上开始我们的查询，并调用<code class="fe lz ma mb mc b">filter</code>开始构建我们的查询。然后我们可以在<code class="fe lz ma mb mc b">author_id</code>字段上添加一个约束。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="b0fc" class="ml kx it mc b gy mm mn l mo mp">fn fetch_articles(conn: &amp;PgConnection, uid: i32) -&gt; Vec&lt;ArticleEntity&gt; {<br/>  use rust_web::schema::articles::dsl::*;<br/>  articles.filter(author_id.eq(uid))<br/>  ...</span></pre><p id="b946" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们还可以在查询中添加一个排序。再次注意这些函数是如何组成的。当使用<code class="fe lz ma mb mc b">load</code>函数来完成我们的选择查询时，我们还必须指定我们想要的返回类型。主要情况是返回完整的实体。这就像SQL行话中的<code class="fe lz ma mb mc b">SELECT * FROM</code>。应用<code class="fe lz ma mb mc b">load</code>将会给我们一个这些项目的向量。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="2cbe" class="ml kx it mc b gy mm mn l mo mp">fn fetch_articles(conn: &amp;PgConnection, uid: i32) -&gt; Vec&lt;ArticleEntity&gt; {<br/>  use rust_web::schema::articles::dsl::*;<br/>  articles.filter(author_id.eq(uid))<br/>    .order(title)<br/>    .load::&lt;ArticleEntity&gt;(conn)<br/>    .expect("Error loading articles!")<br/>}</span></pre><p id="60b6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是我们也可以指定我们想要返回的特定字段。我们将在最后一个例子中看到这一点，其中我们的结果类型是一个元组向量。最后一个查询将是我们两个表之间的连接。我们从<code class="fe lz ma mb mc b">users</code>开始，应用<code class="fe lz ma mb mc b">inner_join</code>功能。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="7b85" class="ml kx it mc b gy mm mn l mo mp">fn fetch_all_names_and_titles(conn: &amp;PgConnection) -&gt; Vec&lt;(String, String)&gt; {<br/>  use rust_web::schema::users::dsl::*;<br/>  use rust_web::schema::articles::dsl::*;<br/>  users.inner_join(...<br/>}</span></pre><p id="c1aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们将它加入到特定ID字段的articles表中。因为我们的两个表都有<code class="fe lz ma mb mc b">id</code>字段，所以我们必须命名它来指定用户的ID字段。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1b0a" class="ml kx it mc b gy mm mn l mo mp">fn fetch_all_names_and_titles(conn: &amp;PgConnection) -&gt; Vec&lt;(String, String)&gt; {<br/>  use rust_web::schema::users::dsl::*;<br/>  use rust_web::schema::articles::dsl::*;</span><span id="1c8c" class="ml kx it mc b gy mq mn l mo mp">  users.inner_join(<br/>    articles.on(author_id.eq(rust_web::schema::users::dsl::id)))...<br/>}</span></pre><p id="e664" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们通过查询得到结果。但是注意，我们使用<code class="fe lz ma mb mc b">select</code>并且只要求用户的<code class="fe lz ma mb mc b">name</code>和文章的<code class="fe lz ma mb mc b">title</code>。这给了我们最终的值，所以每个元素都是两个字符串的元组。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="cea8" class="ml kx it mc b gy mm mn l mo mp">fn fetch_all_names_and_titles(conn: &amp;PgConnection) -&gt; Vec&lt;(String, String)&gt; {<br/>  use rust_web::schema::users::dsl::*;<br/>  use rust_web::schema::articles::dsl::*;</span><span id="c461" class="ml kx it mc b gy mq mn l mo mp">  users.inner_join(<br/>    articles.on(author_id.eq(rust_web::schema::users::dsl::id)))<br/>    .select((name, title)).load(conn).expect("Error on join query!")<br/>}</span></pre><h1 id="b7c2" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="5c97" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">对我来说，我更喜欢Haskell中Persistent提供的功能。但是Diesel提供一个单独的CLI来处理迁移的方法也非常酷。很高兴在这种相对较新的语言中看到更复杂的功能。</p><p id="af66" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你还不熟悉Rust，我们还有一些初学者相关的资料。阅读我们的<a class="ae kv" href="https://www.mmhaskell.com/rust" rel="noopener ugc nofollow" target="_blank"> Rust初学者系列</a>或者更好，观看我们的<a class="ae kv" href="https://www.mmhaskell.com/rust-video-tutorial" rel="noopener ugc nofollow" target="_blank"> Rust视频教程</a>！</p></div></div>    
</body>
</html>