<html>
<head>
<title>Reactive Programming in a Modern Web Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代Web应用程序中的反应式编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/approach-reactive-programming-in-modern-web-application-b20f59b7699d?source=collection_archive---------2-----------------------#2019-11-28">https://levelup.gitconnected.com/approach-reactive-programming-in-modern-web-application-b20f59b7699d?source=collection_archive---------2-----------------------#2019-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9565" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Rxjs</h2><div class=""/><div class=""><h2 id="e905" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何在现代web应用中处理异步代码，以及用于管理它的不同理念——从回调和承诺到RxJS</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0aacb60b7f02c9372c8680efaa92ba08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FI41vBMU0QIEz69p4HgIfA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">杰森·贝茨在<a class="ae lh" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7f39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将讨论反应式编程的3个方面:</p><ol class=""><li id="0906" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">同步和异步问题</li><li id="a35d" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">承诺</li><li id="af58" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">反应式编程</li></ol><p id="fa09" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">【https://betterfullstack.com查看 <a class="ae lh" href="https://betterfullstack.com" rel="noopener ugc nofollow" target="_blank"> <em class="ms">更多类似内容</em></a></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="6aad" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">同步和异步问题</h1><p id="71e9" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">本节将涵盖3个要点:</p><ul class=""><li id="4c19" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nx mk ml mm bi translated">解释同步与异步</li><li id="d173" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">同步发行</li><li id="c13f" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">回调和异步问题</li></ul><h2 id="0217" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated">解释同步和异步代码</h2><p id="4ca0" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">当讨论现代应用程序时，同步和异步是经常使用的两个词。这些概念对于理解是必不可少的，但对于初学者来说可能是一个挑战。</p><p id="6a39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，怎样才能快速理解呢？我在<strong class="lk jd">stackoverflow.com</strong>上找到了一个关于它的最有趣的答案:</p><p id="a02d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">“同步</strong>就像你晚餐想吃披萨，而你又没有冷冻的那种。所以你必须停止玩PUBG，这会让你的朋友不开心。你去厨房，做面团，涂上酱汁，加入奶酪，然后裹上你最喜欢的培根。你刚刚花了20分钟做披萨，又花了10分钟在烤箱里。计时器发出哔哔声，你把热馅饼拿出来。你可以坐下来，吃披萨，继续玩。</p><p id="a8d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">异步</strong>就像你一边玩PUBG一边想晚餐吃披萨。你打开一个浏览器窗口。你打开披萨网站，点了一份额外的奶酪培根披萨，外加培根油大蒜酱。你继续玩，20分钟后门铃响了。你去拿披萨。你坐下来，吃披萨，享受夜晚。<strong class="lk jd"/></p><p id="e54f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在同步解释中，你必须停下手头的工作，自己动手做披萨，按顺序完成所有步骤。在异步解释中，你继续玩游戏，而披萨是并行制作的。当你在等待和做其他事情的时候，披萨已经完成并送到了，当它准备好了，你就可以享受最终产品了。</p><p id="808a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，简单来说，这里的主要区别是<em class="ms">等待时间</em>。</p><p id="0b44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同步代码一步一步地处理任务，并防止在完成当前操作之前进入下一个操作。</p><blockquote class="oj"><p id="bea7" class="ok ol it bd om on oo op oq or os md dk translated">“这样做；那就这么做。那就这么做。那就这么办吧……”</p></blockquote><p id="72a1" class="pw-post-body-paragraph li lj it lk b ll ot kd ln lo ou kg lq lr ov lt lu lv ow lx ly lz ox mb mc md im bi translated">在异步代码中，我们有自己不能处理的操作。例如，当我们发出一个API请求时，在得到响应之前需要等待一段时间。当我们等待API返回时，我们能够执行其他代码。一旦API调用完成，我们就可以处理响应。</p><blockquote class="oj"><p id="060d" class="ok ol it bd om on oo op oq or os md dk translated">“这样做；(等待时间)做其他任务；然后在第一个完成时处理响应。</p></blockquote><h2 id="66db" class="ny nb it bd nc nz oy dn ng ob oz dp nk lr pa oe nm lv pb og no lz pc oi nq iz bi translated">同步发行</h2><p id="42b5" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><strong class="lk jd">同步</strong>当每个代码块必须等待前一个代码块完成后才能继续执行时，就会发生同步执行。</p><p id="5c5b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">JavaScript是单线程的。任何长时间运行的任务，比如等待HTTP请求响应，都不应该同步完成，因为响应时间是未知的。如果我们停止程序等待，对缓慢的请求可能会有3-5秒的无响应时间。</p><p id="4096" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将阻止下一个代码运行，因为整个应用程序都处于空闲状态，等待当前任务完成。等待这个过程完成会给用户带来可怕的体验。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/8070ed197b9ff75aed3291323675ee85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*OBRaPxX2I7zTbXKzX4y1cw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">同步调用两个进程的程序</figcaption></figure><p id="9fb2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，<code class="fe pe pf pg ph b">doTask1()</code>在等待API响应的过程中运行并阻止下一个代码运行。</p><p id="fcb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更好的方法是在等待响应时调用HTTP调用并执行其他操作。</p><p id="0d59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，JavaScript提供了回调函数来处理这个问题。当请求完成时，我们可以提供一个函数在请求完成后执行。</p><p id="0278" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这通过将我们的代码转换成异步的来解决最初的问题(我们在响应准备好的时候处理它)。几年前JavaScript就是这样处理异步的。然而，回调也有自己的问题。</p><h2 id="1195" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated">回调和异步问题</h2><p id="a2a8" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">JavaScript中有很多东西是由回调函数处理的，比如鼠标事件、文件I/O和HTTP请求。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/6522ed9c977b8f996f3c1fb7184cca31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4fUBFiTYD7s7IpAxBWWlA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">JavaScript中的回调函数</figcaption></figure><p id="e54e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对异步(AJAX)请求使用回调会创建一个<strong class="lk jd">控制反转</strong>，允许您的应用程序继续执行下一行代码。</p><p id="dbfb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">控制反转</strong>在这个意义上，指的是代码的某些部分从运行时系统接收控制流的方式。</p><p id="623e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">异步</strong>代码允许应用程序保持响应，但它有一个缺点，即当代码解析时，很难预测应用程序的未来状态。</p><p id="8630" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通常，<strong class="lk jd">应用程序状态</strong>只是存储在变量中的所有信息在任一时间点的快照。因为同步代码是一个接一个执行的，所以当我们编写更多代码并进行调试时，预测应用程序的状态将会更加容易。但是，异步代码是不可预测的，因为应用程序会在响应的<strong class="lk jd">等待时间</strong>内继续运行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/1bbc48c2f9059d1d0a434308e9b924ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*Y72arKPH-305tzvL87nyyQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">异步代码示例</figcaption></figure><p id="3201" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的示例代码在这些方法相互独立的情况下没有问题。</p><p id="4a61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是如果他们是依赖的，会发生什么呢？这些任务共享全局状态。他们需要依次跑<code class="fe pe pf pg ph b">task1</code>到<code class="fe pe pf pg ph b">task2</code>到<code class="fe pe pf pg ph b">task3</code>。我一直把这些<strong class="lk jd"> <em class="ms">副作用叫做</em> </strong>。有副作用的函数不可靠。</p><p id="390e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="ms">等待时间</em> </strong>也是另一个问题。为了确保这些函数按顺序执行，你必须通过使用回调将这些函数组合在一起，即<code class="fe pe pf pg ph b">task1</code>的输出将成为<code class="fe pe pf pg ph b">task2</code>的输入，而<code class="fe pe pf pg ph b">task2</code>的输出将成为<code class="fe pe pf pg ph b">task3</code>的输入。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/3a0b41979ff53bcd6d0b22f5d1bc577a.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*tuMMNV1jouJj7TJXEtz1Dg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">按顺序处理异步代码</figcaption></figure><p id="1d7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这段代码将更难阅读和调试，有时我们会陷入一种被称为“回调地狱”的状态。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="5dfb" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">承诺</h1><p id="97e0" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">JavaScript ES6承诺表示异步操作的最终完成(或失败)及其结果值。</p><p id="c67c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用未来值将一组承诺行为链接在一起，形成一个延续。</p><p id="91af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们来看一个现实世界的问题:我们需要获取一个银行列表，对于每一条银行信息，我们需要获取它们所有的分支机构。一旦我们有了这些数据，我们就需要根据这些信息执行一些额外的任务。</p><blockquote class="pl pm pn"><p id="cf3d" class="li lj ms lk b ll lm kd ln lo lp kg lq po ls lt lu pp lw lx ly pq ma mb mc md im bi translated">注意:本节中的所有代码都是我在<a class="ae lh" href="https://carbon.now.sh" rel="noopener ugc nofollow" target="_blank"> carbon </a>上写的草稿代码，只是作为一个教育示例。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ff28b167847fc53f3b141953320527c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*Efp3F4KY5Mav35W4KvgOLA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">用回拨处理问题</figcaption></figure><p id="9514" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面这段代码很难读懂。下面我们将应用承诺链:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/5383e6dd00c1af1e898cd3208921ed17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*0fSIuWkRJzB3HX7U0J5KZw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">答应处理这个问题</figcaption></figure><p id="7159" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe pe pf pg ph b">then</code>显式地指导代码处理任务的顺序。在失败的情况下，我们可以使用<code class="fe pe pf pg ph b">catch</code>来处理错误。</p><p id="86d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用承诺的缺点是:</p><ul class=""><li id="38a6" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nx mk ml mm bi translated">无法处理生成多个值的数据源</li><li id="65a7" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">缺乏从失败中重试的能力</li><li id="9fa6" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">承诺是不可改变，不能取消的</li></ul><h2 id="4cce" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated">承诺和回访的区别</h2><ul class=""><li id="1e7f" class="me mf it lk b ll ns lo nt lr ps lv pt lz pu md nx mk ml mm bi translated">我们将使用一个<strong class="lk jd">回调</strong>来告诉函数的执行在异步任务完成时做什么。</li><li id="ac5c" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">执行函数将返回一个<strong class="lk jd">承诺</strong>对象，我们将告诉承诺当异步任务完成时做什么。</li></ul><h2 id="a0af" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated">承诺和事件发射器之间不同</h2><ul class=""><li id="3d29" class="me mf it lk b ll ns lo nt lr ps lv pt lz pu md nx mk ml mm bi translated">承诺是针对像HTTP请求这样的单值返回的</li><li id="973c" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">事件发射器用于多值返回，就像鼠标点击处理程序一样</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="9d3f" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">反应式编程</h1><p id="1b6c" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><a class="ae lh" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>是一个通过使用可观察序列来组成异步和基于事件的程序的库。</p><blockquote class="oj"><p id="d8d3" class="ok ol it bd om on oo op oq or os md dk translated"><em class="pv">把RxJS想象成事件的Lodash。</em></p></blockquote><p id="bccd" class="pw-post-body-paragraph li lj it lk b ll ot kd ln lo ou kg lq lr ov lt lu lv ow lx ly lz ox mb mc md im bi translated">它将<a class="ae lh" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>与<a class="ae lh" href="https://en.wikipedia.org/wiki/Iterator_pattern" rel="noopener ugc nofollow" target="_blank">迭代器模式</a>和<a class="ae lh" href="http://martinfowler.com/articles/collection-pipeline/#NestedOperatorExpressions" rel="noopener ugc nofollow" target="_blank">函数式编程与集合</a>相结合，以满足管理事件序列的理想方式的需求。</p><p id="d193" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">RxJS是回调或基于承诺的库的完美替代，它使用单一的编程模型来处理任何无处不在的事件源，如读取文件、发出HTTP调用、单击按钮、移动鼠标或共享应用程序状态。</p><p id="957e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与承诺相比，反应式编程有一些优势:</p><ul class=""><li id="b26d" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nx mk ml mm bi translated">容易取消</li><li id="4402" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">失败时易于重试</li><li id="b5a8" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">能够处理具有多个值的数据源</li></ul><p id="44c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以从我的文章中阅读使用RxJS的示例:</p><ul class=""><li id="0565" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nx mk ml mm bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/angular-and-rxjs-patterns-use-reactive-programming-to-compose-and-manage-data-in-angular-apps-2e0c4ce7a39c?source=friends_link&amp;sk=be4b4ec70b1564b9802d1e5afac805a8"> Angular和RxJS模式——使用反应式编程在Angular应用程序中编写和管理数据</a></li><li id="2d29" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/handle-multiple-api-requests-in-angular-using-mergemap-and-forkjoin-to-avoid-nested-subscriptions-a20fb5040d0c?source=friends_link&amp;sk=f7105b524d60af631c8c5ec19d59d4f7">使用mergeMap和forkJoin处理Angular中的多个API请求，以避免嵌套订阅</a></li><li id="e744" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/communicate-between-angular-components-using-rxjs-7221e0468b2?source=friends_link&amp;sk=925501345e5562179adaff0700216fba">使用RxJS在角度组件之间进行通信</a></li></ul><p id="be0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">RxJS有助于解决这些问题:</p><ul class=""><li id="1651" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nx mk ml mm bi translated">控制事件如何流经你的观察对象。</li><li id="33f4" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">使用纯函数产生值的能力。这意味着你的代码不容易出错。</li><li id="556b" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">转换通过你的观察值传递的值。</li><li id="e0eb" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">错误处理策略变得很容易。我们可以很容易地实现出错时重试的逻辑。</li><li id="3c69" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">非常简单地抑制用户与任何UI组件的交互。</li><li id="73a2" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">通过<code class="fe pe pf pg ph b">unsubscribe()</code>处理取消。</li><li id="657a" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">避免回调地狱。</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="b3c9" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">摘要</h1><p id="4244" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">这篇文章提供了为什么我们从回调和承诺转向现代web应用程序的反应式编程的基础知识。</p><p id="cbb0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">RxJS的强大之处在于建立在函数式和反应式编程之上，以及一些众所周知的设计模式，如observer和iterator。</p><p id="72dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用！你可以在<a class="ae lh" href="https://medium.com/@transonhoang?source=post_page---------------------------" rel="noopener">媒体</a>上关注我。我也在<a class="ae lh" href="https://twitter.com/transonhoang" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt pw"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="px ab fo"><div class="py ab pz cl cj qa"><h2 class="bd jd gy z fp qb fr fs qc fu fw jc bi translated">故事-更好的全栈</h2><div class="qd l"><h3 class="bd b gy z fp qb fr fs qc fu fw dk translated">关于JavaScript、Python和Wordpress的有用文章，有助于开发人员减少开发时间并提高…</h3></div><div class="qe l"><p class="bd b dl z fp qb fr fs qc fu fw dk translated">betterfullstack.com</p></div></div><div class="qf l"><div class="qg l qh qi qj qf qk lb pw"/></div></div></a></div></div></div>    
</body>
</html>