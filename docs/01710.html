<html>
<head>
<title>A Beginner’s Guide to Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人入门指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-beginners-guide-to-docker-3167e635f857?source=collection_archive---------10-----------------------#2020-01-23">https://levelup.gitconnected.com/a-beginners-guide-to-docker-3167e635f857?source=collection_archive---------10-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="5bd4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="486b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">docker——一段时间以来，这是科技行业的一个流行词，也是一个最初需要处理的令人生畏的概念。在本文中，我们将探索Docker是什么，为什么我们需要它，以及我们如何在Docker容器中运行一个基本的Golang服务器。所以，让我们开始吧。</p><h2 id="ba2b" class="lm jr it bd js ln lo dn jw lp lq dp ka kz lr ls ke ld lt lu ki lh lv lw km lx bi translated">Docker是什么？</h2><p id="041c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Docker只是一个生态系统，它为我们提供了一套服务和工具来帮助运行和管理容器。</p><p id="920d" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">那么，什么是容器呢？<br/>根据docker.com、<strong class="kq iu">的说法，“容器是一个标准的软件单元，它将代码及其所有依赖项打包，以便应用程序能够快速可靠地从一个计算环境运行到另一个计算环境”</strong>。<br/>这意味着docker容器为你提供了一个打包了你的应用、库、二进制文件和设置的包，这样它就可以在任何与主机OS隔离的系统上独立运行。</p><h2 id="44d0" class="lm jr it bd js ln lo dn jw lp lq dp ka kz lr ls ke ld lt lu ki lh lv lw km lx bi translated">为什么是Docker？</h2><ol class=""><li id="f415" class="md me it kq b kr ks kv kw kz mf ld mg lh mh ll mi mj mk ml bi translated"><strong class="kq iu">无单点故障</strong> —我们都曾遇到过这种情况，一个微小功能的错误会使整个应用崩溃，其功能甚至与其无关，即单点故障。Docker帮助你避免这种情况。您可以将一个巨大的单片应用程序分解为多个微服务，从而帮助您更轻松地进行部署。</li><li id="adb7" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated"><strong class="kq iu">“在我的机器上工作”综合症</strong>——有没有npm包因为你在系统中进行了全新安装而开始表现怪异？或者有人在应用程序中硬编码了一个目录，它无法在您的云上工作。在使用敏捷方法开发的大型团队中经常听到这个术语。Docker容器带有一个隔离的环境，如果它在容器中工作，那么它在任何地方都可以工作。</li><li id="8416" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated"><strong class="kq iu">可伸缩性</strong> —借助于诸如Kubernetes或swarm之类的编排服务，容器可快速伸缩，这些服务可帮助it快速创建和销毁容器的多个副本。</li><li id="6c3c" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated"><strong class="kq iu"> Docker支持操作系统级别的隔离</strong>——多个容器可以在单个操作系统上运行，而虚拟机可以在操作系统的不同副本上运行它们的隔离环境。容器与其他容器共享系统内核，使它们更快。</li></ol><p id="6397" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">参考下图——每个容器在内核之外都有一个隔离的空间，所有容器共享主机的OS资源。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/9a133f9e2bfe68d404e64ebb4ff6fba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TFrvGAsB-UH5UNe6SJskg.png"/></div></div></figure><h2 id="da2a" class="lm jr it bd js ln lo dn jw lp lq dp ka kz lr ls ke ld lt lu ki lh lv lw km lx bi translated">我们的应用</h2><p id="46f7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">出于本教程的目的，让我们考虑一个服务于HTTP请求的简单Go应用程序。下面的代码展示了这一点的实现，其中一个简单的服务器接收HTTP请求，并用一条消息进行响应。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a151" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">上面的代码片段可用于服务一个GET请求，该请求发送一个“hello world”的JSON响应。</p><p id="eea0" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">上述代码中的主要功能有两个目的:</p><ol class=""><li id="aff7" class="md me it kq b kr ly kv lz kz nf ld ng lh nh ll mi mj mk ml bi translated">处理GET请求。</li><li id="77ef" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated">监听端口8080上的活动请求。</li></ol><p id="5bea" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">Go附带了一个标准的内置<code class="fe ni nj nk nl b">net/http</code>包，我们将使用它来实现上面列出的功能。</p><p id="cbd6" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">注意——如果你是新手，或者如果你想更好地理解Golang的概念，我强烈推荐阅读这本书<br/><a class="ae nm" href="https://github.com/karlseguin/the-little-go-book" rel="noopener ugc nofollow" target="_blank">https://github.com/karlseguin/the-little-go-book</a></p><h2 id="bfc1" class="lm jr it bd js ln lo dn jw lp lq dp ka kz lr ls ke ld lt lu ki lh lv lw km lx bi translated">容器化我们的应用程序</h2><p id="eb7f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一步是用我们选择的配置在一个隔离的容器中运行我们的应用程序。</p><p id="2449" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">通常，容器包含一个进程或一组进程，这些进程有一组专门分配给它们的资源。它拥有分配给该特定进程的物理资源子集。</p><p id="df8c" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">为了在容器中运行我们的go应用程序，我们需要创建一个<strong class="kq iu"> Docker映像</strong>。</p><p id="6c83" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">docker映像是在容器中运行我们的应用程序所需的文件中的一组指令，映像包含在Docker文件的不同步骤中创建的多个层。</p><p id="47bd" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">docker图像可以通过创建一个名为“<strong class="kq iu"> Dockerfile </strong>”的无扩展名文本文件，并将其放在我们应用程序的根目录中来创建。下面的代码显示了我们的docker文件。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b7be" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">当我们构建docker映像来创建一个容器时，Docker文件中的每一行都会被顺序执行。以下是相同的步骤。</p><p id="7bdc" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated"><strong class="kq iu">步骤1 </strong> —提取基础映像，为我们的应用程序创建一个环境。这是第一步，有助于确定基础层。对于我们的应用程序，我们选择基本图像为alpine，因为与其他基本图像(如Ubuntu或Debian)相比，该图像的大小较小。根据您的应用需求，您可以选择不同的基础映像。<br/>查看<a class="ae nm" href="https://hub.docker.com/search?q=&amp;type=image" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/search?q=&amp;type = image</a>获取可用图像。<br/> <strong class="kq iu">步骤2 </strong> —设置我们的应用程序可以驻留的工作目录，您可以创建额外的目录来启用缓存。<br/> <strong class="kq iu">第三步</strong> —将我们app的源代码复制到工作目录中。<br/> <strong class="kq iu">第4步</strong> —构建我们的应用程序以创建一个可执行文件(具体到Go)。<br/> <strong class="kq iu">第5步</strong> —设置一条命令，一旦容器启动，该命令将运行。</p><p id="0650" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">注意-“fig let”只是一个帮助打印文字横幅的程序。</p><h2 id="0dfe" class="lm jr it bd js ln lo dn jw lp lq dp ka kz lr ls ke ld lt lu ki lh lv lw km lx bi translated">建立我们的码头工人形象</h2><p id="64b1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">docker build命令帮助我们从docker文件构建docker映像。</p><pre class="ms mt mu mv gt nn nl no np aw nq bi"><span id="064e" class="lm jr it nl b gy nr ns l nt nu">docker build -t simple-web-server:v1 .</span></pre><p id="f73c" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">这将创建一个名为simple-web-server的映像，其标签为v1，如果我们在创建docker映像时没有指定标签，docker将假定该标签为“最新”。</p><p id="8edd" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">docker build的典型用法如下所示:</p><pre class="ms mt mu mv gt nn nl no np aw nq bi"><span id="cf23" class="lm jr it nl b gy nr ns l nt nu">docker build [OPTIONS] PATH | URL | -</span></pre><p id="4225" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">要深入理解构建命令，请点击链接-<br/><a class="ae nm" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">【https://docs.docker.com/engine/reference/commandline/build/】</a></p><h2 id="9b37" class="lm jr it bd js ln lo dn jw lp lq dp ka kz lr ls ke ld lt lu ki lh lv lw km lx bi translated">运行我们的Docker容器</h2><pre class="ms mt mu mv gt nn nl no np aw nq bi"><span id="6d64" class="lm jr it nl b gy nr ns l nt nu">docker run -p 5000:8080 simple-web-server:v1</span></pre><p id="9d35" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">一旦我们运行了上面的命令，容器就开始执行docker文件中指定的命令(在我们的例子中，运行我们的go应用程序的可执行文件)。这也在容器中创建了一个可写层，我们对容器的所有新更改都将驻留在这个层中。一旦容器被删除，可写层也会被删除。这种行为的主要用途之一是，从同一个映像创建的多个容器可以用不同的状态存储不同的数据。</p><p id="c1b2" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">因为容器是用它们自己的一组端口和分配的资源隔离的，所以我们不能从主机直接访问它们。命令中的<strong class="kq iu">“p”</strong>标志有助于将我们主机的端口映射到运行应用程序的容器的端口。对于我们的应用程序，由于我们使用主机端口5000，我们将能够通过端口5000访问我们的应用程序。</p><p id="c515" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">一旦执行了run命令，请访问— <a class="ae nm" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000/ </a>查看作为API响应的“hello-world”消息。</p><p id="88a0" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">要查看与运行命令相关的其他标志或深入参考，请查看官方文档—<a class="ae nm" href="https://docs.docker.com/engine/reference/commandline/run/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/reference/commandline/run/</a>。</p><h2 id="eb2c" class="lm jr it bd js ln lo dn jw lp lq dp ka kz lr ls ke ld lt lu ki lh lv lw km lx bi translated">其他有用的命令</h2><ol class=""><li id="e686" class="md me it kq b kr ks kv kw kz mf ld mg lh mh ll mi mj mk ml bi translated">通过运行以下命令查看正在运行的docker容器</li></ol><pre class="ms mt mu mv gt nn nl no np aw nq bi"><span id="4a18" class="lm jr it nl b gy nr ns l nt nu">docker ps</span></pre><p id="c97e" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">2.查看系统中存在的所有容器，不管它们是否正在运行</p><pre class="ms mt mu mv gt nn nl no np aw nq bi"><span id="610f" class="lm jr it nl b gy nr ns l nt nu">docker ps -a</span></pre><p id="0438" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">3.要释放主机的内存并删除所有现有的容器，请使用prune命令-<a class="ae nm" href="https://docs.docker.com/engine/reference/commandline/system_prune/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/reference/command line/system _ prune/</a></p><h1 id="6ded" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="0e76" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本文中，我们介绍了容器化的基础知识，以及一个简单的go应用程序如何在容器中运行，同样可以扩展到运行几乎任何东西。<br/>尽管这些概念只是触及了Docker世界的表面，但它们在开始使用分布式系统时变得必不可少。</p><p id="86d5" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">应用程序的代码可以在<br/><a class="ae nm" href="https://github.com/puneeth8994/docker-with-go-server" rel="noopener ugc nofollow" target="_blank">https://github.com/puneeth8994/docker-with-go-server</a>上找到</p><p id="3051" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated"><strong class="kq iu">推荐阅读- <br/> </strong> 1。<a class="ae nm" href="https://www.freecodecamp.org/news/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/a-初学者友好-入门-容器-VMs-and-docker-79 a9 e 3 e 119 b/</a><br/>2 .<a class="ae nm" href="https://github.com/karlseguin/the-little-go-book" rel="noopener ugc nofollow" target="_blank">https://github.com/karlseguin/the-little-go-book</a></p></div></div>    
</body>
</html>