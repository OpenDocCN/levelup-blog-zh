<html>
<head>
<title>Dependency Resolving Mastery in ASP.NET Core Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心应用程序中的依赖性解决技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-resolving-mastery-in-asp-net-core-apps-f3515ab40fd2?source=collection_archive---------3-----------------------#2022-02-14">https://levelup.gitconnected.com/dependency-resolving-mastery-in-asp-net-core-apps-f3515ab40fd2?source=collection_archive---------3-----------------------#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1937" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何正确解析应用程序不同部分的依赖关系？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/260711c936fc10fc06ecea70c97ed9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gdfGgRTXzma5fXKA"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="69c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入是软件开发中一个相当简单的概念。然而，当它在一个复杂的ASP.NET核心项目的整个代码库中大量使用时，通常会出现许多细微差别。</p><p id="058e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用ASP.NET核心时，开发人员可能会注意到，众所周知的构造函数注入技术在应用程序的某些地方工作得很好，而在其他地方则完全不合适。</p><p id="355c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将探讨如何正确解析来自ASP.NET核心应用程序不同部分的虚拟<code class="fe lv lw lx ly b">IService</code>接口。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5bd1" class="md me it ly b gy mf mg l mh mi">public interface IService<br/>{<br/>    void Do();<br/>}</span><span id="da83" class="md me it ly b gy mj mg l mh mi">public class Service : IService<br/>{<br/>    public void Do()<br/>    {<br/>        Console.WriteLine("Do");<br/>    }<br/>}</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="20dc" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从构造函数解析依赖关系</h1><p id="3c85" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在绝大多数情况下，构造函数注入技术用于解决依赖关系。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b420" class="md me it ly b gy mf mg l mh mi">public class ParentService<br/>{<br/>    private readonly <strong class="ly iu">IService _service</strong>;</span><span id="349b" class="md me it ly b gy mj mg l mh mi">    public ParentService(<strong class="ly iu">IService service</strong>) =&gt;<br/>        _service = service;<br/>}</span></pre><p id="2ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过构造函数注入依赖关系极大地简化了代码的可读性。为了理解一个特定的类使用什么依赖关系，开发人员只需要看一下类的构造函数。</p><p id="eac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，构造函数注入至少在以下情况下不起作用:</p><ul class=""><li id="7223" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">依赖项的生存期比注入依赖项的类的生存期短。这个问题被称为<strong class="lb iu">受控依赖</strong>，并且已经在我的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/top-misconceptions-about-dependency-injection-in-asp-net-core-c6a7afd14eb4">另一篇文章</a>中描述过。</li><li id="46f2" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当不再需要依赖项时，开发人员需要删除它，而不是等待DI容器来处理它(瞬态或限定范围的依赖项仅在请求结束时处理)。</li><li id="be72" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">需要将依赖项注入到自定义属性的构造函数中，但是只能将文本传递给属性构造函数。</li></ul><p id="768c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章的剩余部分，我们将看看开发人员可能会在哪里遇到上述限制，以及如何克服它们。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ead9" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从程序类解析依赖关系</h1><p id="1f17" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当需要从web应用程序入口点(即<code class="fe lv lw lx ly b">Program</code>类)解析依赖关系时，构造函数注入将不起作用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码没有太大意义。应用的入口点是静态的<code class="fe lv lw lx ly b">Main</code>方法，所以不会调用<code class="fe lv lw lx ly b">Program</code>类的非静态构造函数。即使<code class="fe lv lw lx ly b">Main</code>方法是非静态的，构造函数注入仍然没有意义，因为<code class="fe lv lw lx ly b">ConfigureServices</code>方法的执行比<code class="fe lv lw lx ly b">Program</code>类的构造函数晚得多。</p><p id="2ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过访问<code class="fe lv lw lx ly b">IHost</code>对象，可以从<code class="fe lv lw lx ly b">Program</code>类中正确解析所需的依赖关系:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，依赖关系很容易解决，因为<code class="fe lv lw lx ly b">ConfigureServices </code>方法是在<code class="fe lv lw lx ly b">IHost</code>对象完全构建之前执行的。</p><p id="cfe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个重要的注意事项:<code class="fe lv lw lx ly b">IService</code>对象将被放置在创建它的作用域的末尾(第13行)。因此，从自定义范围解析依赖关系允许开发人员在需要时更好地控制依赖关系的生存期。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2216" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">解决中间件的依赖性</h1><p id="daea" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">中间件的生存期是单一的，因此具有单一生存期的依赖关系可以安全地注入到中间件构造函数中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f0f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有时也有必要将限定范围的或暂时的依赖注入到中间件中。试图通过中间件构造器做到这一点将导致<strong class="lb iu">强制依赖问题</strong>。正确的方法是将依赖注入到<code class="fe lv lw lx ly b">Invoke</code>方法中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="324a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，具有单一生存期的依赖项不仅可以在构造函数中注入，也可以在<code class="fe lv lw lx ly b">Invoke</code>方法中注入。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="958e" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">解析托管服务的依赖关系</h1><p id="35b3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">托管服务具有单一生存期，因此只有具有相同生存期的依赖项才能通过构造函数安全地注入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="dc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不应将限定范围的或暂时的依赖注入托管服务的构造函数中，以避免强制依赖问题。</p><p id="b247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安全的方法是将<code class="fe lv lw lx ly b">IServiceProvider</code>实例注入托管服务的构造函数中，并通过在<code class="fe lv lw lx ly b">ExecuteAsync</code>方法中创建一个范围来解决依赖性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IService</code>接口的实例将在调用<code class="fe lv lw lx ly b">GetRequiredService</code>方法时创建，并在<code class="fe lv lw lx ly b">ExecuteAsync</code>方法结束时由于其作用域被释放而被释放。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="6078" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从操作筛选器属性解析依赖关系</h1><p id="822c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当需要在API端点执行之前或之后执行某些逻辑时，可以使用动作过滤器。实现动作过滤器的一种方法是从<code class="fe lv lw lx ly b">ActionFilterAttribute</code>中派生出自己的类，然后覆盖所需的方法。</p><p id="4257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时可能需要将一些依赖项注入到属性中，如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="71bc" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">//Action filter:</strong><br/>public class MyAttribute : ActionFilterAttribute<br/>{<br/>    private readonly IService _service;</span><span id="f3aa" class="md me it ly b gy mj mg l mh mi">    public MyAttribute(IService service) =&gt; _service = service;</span><span id="abd0" class="md me it ly b gy mj mg l mh mi">    public override void OnActionExecuting(ActionExecutingContext context)<br/>    {<br/>        _service.Do();</span><span id="76c3" class="md me it ly b gy mj mg l mh mi">        //...<br/>    }<br/>}</span><span id="979f" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu">//API Endpoint:<br/></strong>[MyAttribute]<br/>public IEnumerable&lt;Student&gt; Get()<br/>{<br/>    //...<br/>}</span></pre><p id="3980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，将非基元类型注入属性的构造函数将使该属性由于编译错误而无法应用于控制器操作— <em class="od">没有给定的参数对应于“MyAttribute”的必需形参“service”。我的属性(IService)' </em>。</p><p id="c495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决属性依赖性的一种有效方法是访问执行上下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种方法并不干净，因为开发人员需要检查<code class="fe lv lw lx ly b">MyAttribute</code>类的整个实现，以便理解属性使用了什么依赖关系。基本上，它是一个服务定位器反模式，在代码中创建隐式依赖关系。</p><p id="fa31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更干净的解决方案是开始使用<code class="fe lv lw lx ly b">IActionFilter</code>接口和<code class="fe lv lw lx ly b">ServiceFilter</code>属性，这允许开发人员使用构造函数注入技术:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="c7f1" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">最后的想法</h1><p id="4d34" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们已经涵盖了ASP.NET核心应用程序中开发人员可能需要注入依赖项的大部分地方。</p><p id="80cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构造函数注入是一项惊人的技术，但它并不是100%的时候都有效。了解其他方法会让开发人员在日常工作中更加自信。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="b29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/7-tricky-questions-to-ask-net-developer-in-a-job-interview-9cdb3789db54"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">要问的7个棘手问题。NET开发人员在工作面试</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">带着答案。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div></div></div>    
</body>
</html>