<html>
<head>
<title>Limit Unbound Concurrency in Go (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">限制Go中的无限制并发性(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/limit-unbound-concurrency-in-go-part-2-a00ada3bb50f?source=collection_archive---------3-----------------------#2021-12-30">https://levelup.gitconnected.com/limit-unbound-concurrency-in-go-part-2-a00ada3bb50f?source=collection_archive---------3-----------------------#2021-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e986" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Go中实现一个端口扫描器并解释管道模式</h2></div><p id="1758" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<strong class="kk iu">端口扫描器</strong>被设计用来探测一个<a class="ae le" href="https://en.wikipedia.org/wiki/Server_(computing)" rel="noopener ugc nofollow" target="_blank">服务器</a>或<a class="ae le" href="https://en.wikipedia.org/wiki/Host_(network)" rel="noopener ugc nofollow" target="_blank">主机</a>是否打开<a class="ae le" href="https://en.wikipedia.org/wiki/TCP_and_UDP_port" rel="noopener ugc nofollow" target="_blank">端口</a>。在这一系列文章中，我们将在Go中实现一个端口扫描器，同时解释一些并发概念。</p><p id="2736" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在《限制无限制并发性》的第2部分中讨论管道模式。如果你错过了第一部分和中的<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/limit-unbound-concurrency-in-go-part-1-72f7cedf2e61?source=your_stories_page----------------------------------------">和<strong class="kk iu">部分，请仔细阅读，了解必要的背景知识。</strong></a></p><div class="lf lg gp gr lh li"><a rel="noopener  ugc nofollow" target="_blank" href="/limit-unbound-concurrency-in-go-part-1-72f7cedf2e61"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">限制Go中的无限制并发性(第1部分)</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">在Go中实现一个端口扫描器，并解释一些并发概念</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw lx li"/></div></div></a></div><h1 id="8fee" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是管道？</h1><p id="80c0" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">Go中没有管道的正式定义；它只是众多并发程序中的一种。非正式地说，管道是由通道连接的一系列<em class="mv">阶段</em>，其中每个阶段是一组运行相同功能的goroutines。在每一个阶段，戈鲁丁人</p><ul class=""><li id="6811" class="mw mx it kk b kl km ko kp kr my kv mz kz na ld nb nc nd ne bi translated">通过<em class="mv">入站</em>通道从<em class="mv">上游</em>接收数值</li><li id="afa9" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">对数据执行一些功能，通常产生新值</li><li id="27d7" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">通过<em class="mv">出站</em>通道向下游发送数值<em class="mv"/></li></ul><h1 id="2a5f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">管道流程图</h1><figure class="nl nm nn no gt np gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e3bc529287168b2db960f0c3133a6d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*ChGGnKpjR6FEerqGTx0j_w.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">管道</figcaption></figure><p id="4071" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图显示了端口扫描器的整个管道。让我们在下一节中逐一解释每个相关的功能。</p><ul class=""><li id="f419" class="mw mx it kk b kl km ko kp kr my kv mz kz na ld nb nc nd ne bi translated">功能初始化</li><li id="eaef" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">Func parsePortsToScan</li><li id="b895" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">结构<code class="fe nv nw nx ny b">scanOp</code></li><li id="7a52" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">功能生成</li><li id="22c1" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">功能扫描</li><li id="1d53" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">函数过滤器</li><li id="b749" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">功能商店</li><li id="6972" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">功能主体</li></ul><h1 id="e595" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">主要成分</h1><ul class=""><li id="ac7b" class="mw mx it kk b kl mq ko mr kr nz kv oa kz ob ld nb nc nd ne bi translated"><strong class="kk iu">功能初始化</strong></li></ul><p id="7a80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx ny b">init</code>函数定义了用户传入的参数。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="fdee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx ny b">ports</code>变量是一串由破折号分隔的要扫描的端口。<code class="fe nv nw nx ny b">outFile</code>变量是写入结果的文件。</p><blockquote class="oe of og"><p id="18b2" class="ki kj mv kk b kl km ju kn ko kp jx kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated"><strong class="kk iu"> Func parsePortsToScan </strong></p></blockquote><p id="09af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx ny b">parsePortsToScan</code>函数从命令行参数解析要扫描的端口。如果参数无效，将返回错误。如果参数有效，则返回<code class="fe nv nw nx ny b">ints</code>的一部分。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><blockquote class="oe of og"><p id="49fc" class="ki kj mv kk b kl km ju kn ko kp jx kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated"><strong class="kk iu">结构扫描操作</strong></p></blockquote><p id="2da1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx ny b">scanOp</code>表示单端口扫描操作及其结果(<code class="fe nv nw nx ny b">open</code>、<code class="fe nv nw nx ny b">scanErr</code>、<code class="fe nv nw nx ny b">scanDuration</code>)。<code class="fe nv nw nx ny b">open</code>是一个布尔值，表示端口是否打开。<code class="fe nv nw nx ny b">scanErr</code>是扫描失败时的错误信息。<code class="fe nv nw nx ny b">scanDuration</code>是执行扫描所花费的时间。</p><p id="8327" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要将结果输出到CSV文件，CSV编写器使用两种方法。<code class="fe nv nw nx ny b">csvHeaders</code>返回一段字符串中的头。<code class="fe nv nw nx ny b">asSlice</code>将<code class="fe nv nw nx ny b">scanOp</code>的值字段作为一段字符串返回。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><blockquote class="oe of og"><p id="48b1" class="ki kj mv kk b kl km ju kn ko kp jx kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated"><strong class="kk iu">功能基因</strong></p></blockquote><figure class="nl nm nn no gt np gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/3577888c3af780128e83a258bc12685e.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*_DbjrWrvur_hAZIpdJfuqw.png"/></div></figure><p id="efae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx ny b">gen</code>函数是一个生成器函数，它从一片int端口返回一个缓冲通道的<code class="fe nv nw nx ny b">scanOps</code>结构值。它用于创建将按顺序执行的函数管道，它是管道中的第一个函数。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><blockquote class="oe of og"><p id="ee92" class="ki kj mv kk b kl km ju kn ko kp jx kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated"><strong class="kk iu">功能扫描</strong></p></blockquote><p id="20e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx ny b">scan</code>功能负责执行实际的端口扫描。它获取一个缓冲通道<code class="fe nv nw nx ny b">scanOps</code>并返回一个非缓冲通道<code class="fe nv nw nx ny b">scanOps</code>。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><blockquote class="oe of og"><p id="4b4b" class="ki kj mv kk b kl km ju kn ko kp jx kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated"><strong class="kk iu"> Func滤波器</strong></p></blockquote><p id="92c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx ny b">filter</code>功能负责过滤打开的扫描操作。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><blockquote class="oe of og"><p id="d1c5" class="ki kj mv kk b kl km ju kn ko kp jx kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated"><strong class="kk iu"> Func store </strong></p></blockquote><p id="9c59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">存储功能负责将<code class="fe nv nw nx ny b">scanOps</code>存储在一个CSV文件中。这是流水线中的最后一个函数。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><blockquote class="oe of og"><p id="a364" class="ki kj mv kk b kl km ju kn ko kp jx kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated"><strong class="kk iu"> Func main </strong></p></blockquote><p id="61b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主函数负责执行函数管道。它从命令行参数中获取一部分int端口和一个字符串<code class="fe nv nw nx ny b">outfile</code>。</p><p id="d9fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，它开始编排函数管道，从<code class="fe nv nw nx ny b">gen</code>函数开始，到<code class="fe nv nw nx ny b">store</code>函数结束。</p><p id="d813" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，它将结果打印到控制台。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="eb5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得注意的是，我们还可以通过将管道中的函数链接在一起来堆叠它们。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="bb48" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="d63c" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">通道可用于将goroutines连接在一起，以便一个的输出成为另一个的输入。当您的管道中有许多函数并且想要连接它们时，它会非常有用。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="3833" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发现这篇文章很有用👏？看看我下面的其他文章吧！</p><ol class=""><li id="8157" class="mw mx it kk b kl km ko kp kr my kv mz kz na ld os nc nd ne bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/how-does-golang-channel-works-6d66acd54753">Golang频道是如何工作的</a></li><li id="be1b" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld os nc nd ne bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/solid-principles-in-golang-explained-by-examples-4a4cccf47388">用实例解释Golang中的固体原理</a></li><li id="e244" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld os nc nd ne bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/observer-design-pattern-in-golang-with-an-example-6c24898059b1">Golang中的观察者设计模式与实例</a></li></ol></div></div>    
</body>
</html>