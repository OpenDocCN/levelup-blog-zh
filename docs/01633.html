<html>
<head>
<title>Basic Routing with Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速基本路由</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basic-routing-with-express-bc6a07783eaf?source=collection_archive---------7-----------------------#2020-01-17">https://levelup.gitconnected.com/basic-routing-with-express-bc6a07783eaf?source=collection_archive---------7-----------------------#2020-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c672c876932c5c5f90e89747bb564766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7lhcF_N64SIsx8wE"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Justin Lawrence 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="ef65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">路由是后端应用程序最重要的部分。Express允许我们轻松地将URL路由到我们的路由处理程序代码。</p><p id="08a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解如何使用Express创建基本路线。</p><h1 id="d869" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基本路由</h1><p id="55f1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">路由是Express应用程序响应来自URL或路径以及特定HTTP请求方法(如GET或POST)的客户端请求的地方。</p><p id="de47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Express中的每条路线都可以有一个以上的处理函数，当路线匹配时执行这些函数。</p><p id="af8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">路由的一般定义采用以下格式:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7cb8" class="mq lf it mm b gy mr ms l mt mu">app.METHOD(PATH, HANDLER);</span></pre><p id="b631" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">app</code>是快递app实例。</p><p id="94ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">METHOD</code>是小写的HTTP请求方法。可能的方法包括GET、POST、PUT和DELETE。</p><p id="228f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">PATH</code>是以小路为路线。<code class="fe mv mw mx mm b">HANDLER</code>是路径匹配时运行的处理函数。</p><p id="6363" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cc62" class="mq lf it mm b gy mr ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World!')<br/>})</span></pre><p id="cd57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在屏幕上显示<code class="fe mv mw mx mm b">'Hello World!'</code>。</p><p id="2db8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们希望我们的应用程序接受POST请求，我们可以如下使用<code class="fe mv mw mx mm b">app.post</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="aed2" class="mq lf it mm b gy mr ms l mt mu">app.post('/', (req, res) =&gt; {<br/>  res.send('Received POST request');<br/>})</span></pre><p id="e826" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用像Postman这样的HTTP客户端，通过向运行我们的应用程序的URL发送POST请求来测试这一点。那么我们应该得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5c8c" class="mq lf it mm b gy mr ms l mt mu">Received POST request</span></pre><p id="c77f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在响应正文中。</p><p id="d76f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以对PUT和DELETE请求做同样的事情，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="77f8" class="mq lf it mm b gy mr ms l mt mu">app.put('/', (req, res) =&gt; {<br/>  res.send('Got a PUT request at /user')<br/>})</span><span id="2574" class="mq lf it mm b gy my ms l mt mu">app.delete('/', (req, res) =&gt; {<br/>  res.send('Got a DELETE request')<br/>})</span></pre><p id="52cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，在每个路由处理器中，我们有一个<code class="fe mv mw mx mm b">req</code>和<code class="fe mv mw mx mm b">res</code>参数。<code class="fe mv mw mx mm b">req</code>具有请求对象，该对象具有URL、头和其他字段。</p><p id="3ca6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">res</code>对象让我们将响应返回给客户端。</p><h1 id="e3db" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">请求对象</h1><p id="3972" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们在上面的路由处理程序中的<code class="fe mv mw mx mm b">req</code>参数是<code class="fe mv mw mx mm b">req</code>对象。</p><p id="6000" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有一些属性，我们可以使用这些属性来获取客户端发出的请求的相关数据。下面列出了比较重要的几个。</p><h2 id="e28c" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">req.baseUrl</h2><p id="2555" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">req.baseUrl</code>属性保存已挂载的路由器实例的基本URL。</p><p id="595c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e92a" class="mq lf it mm b gy mr ms l mt mu">const express = require('express');</span><span id="f7da" class="mq lf it mm b gy my ms l mt mu">const app = express();<br/>const greet = express.Router();<br/>greet.get('/', (req, res) =&gt; {<br/>  console.log(req.baseUrl);<br/>  res.send('Hello World');<br/>})</span><span id="bd52" class="mq lf it mm b gy my ms l mt mu">app.use('/greet', greet);</span><span id="8b29" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="6f0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们从<code class="fe mv mw mx mm b">console.log</code>得到<code class="fe mv mw mx mm b">/greet</code>。</p><h2 id="c0d2" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">请求体</h2><p id="aa9b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">req.body</code>有请求体。我们可以用<code class="fe mv mw mx mm b">express.json()</code>解析JSON主体，用<code class="fe mv mw mx mm b">express.urlencoded()</code>解析URL编码的请求。</p><p id="b745" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1f33" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="e96c" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="05ba" class="mq lf it mm b gy my ms l mt mu">app.post('/', (req, res) =&gt; {<br/>  res.json(req.body)<br/>})</span><span id="4311" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="49c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们用JSON主体发出POST请求时，我们得到的是我们在请求中发送的内容。</p><h2 id="8edb" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">req.cookies</h2><p id="3d39" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以获得带有<code class="fe mv mw mx mm b">req.cookies</code>属性的请求所发送的cookies。</p><h2 id="8227" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">请求主机名</h2><p id="f8e9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mv mw mx mm b">req.hostname</code>从HTTP头中获取主机名。</p><p id="f8f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当信任代理设置未评估为<code class="fe mv mw mx mm b">false</code>时，Express将从<code class="fe mv mw mx mm b">X-Forwarded-Host</code>报头字段获取值。报头可以由客户端或代理设置。</p><p id="f5cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有一个以上的<code class="fe mv mw mx mm b">X-Forwarded-Host</code>标题，那么将使用第一个。</p><p id="a6b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="84c9" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="4c68" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="8ad0" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.json(req.hostname)<br/>})</span><span id="59a1" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="e643" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果没有<code class="fe mv mw mx mm b">X-Forwarded-Host</code>标头，并且信任代理的评估结果不是<code class="fe mv mw mx mm b">false</code>，我们将获得应用所在的域名。</p><h2 id="ee1b" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">请求. ip</h2><p id="c647" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用这个属性获取发出请求的IP地址。</p><h2 id="0d2d" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">请求方法</h2><p id="4d2a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">属性有请求的请求方法，比如GET、POST、PUT或DELETE。</p><h2 id="766a" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">请求参数</h2><p id="4549" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">params</code>属性有来自URL的请求参数。</p><p id="6708" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e282" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="808c" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="7ed5" class="mq lf it mm b gy my ms l mt mu">app.get('/:name/:age', (req, res) =&gt; {<br/>  res.json(req.params)<br/>})</span><span id="fe84" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="01ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们将<code class="fe mv mw mx mm b">/john/1</code>作为URL的参数部分传入时，我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9cbb" class="mq lf it mm b gy mr ms l mt mu">{<br/>    "name": "john",<br/>    "age": "1"<br/>}</span></pre><p id="5d14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为上面路线的回应。</p><h2 id="4e23" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">req.query</h2><p id="826b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">属性从解析成对象的请求URL中获取查询字符串。</p><p id="1685" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0e08" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="262c" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="345e" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.json(req.query)<br/>})</span><span id="aa40" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="a2d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们将<code class="fe mv mw mx mm b">?name=john&amp;age=1</code>附加到主机名的末尾时，我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="aa0d" class="mq lf it mm b gy mr ms l mt mu">{<br/>    "name": "john",<br/>    "age": "1"<br/>}</span></pre><p id="d48e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从回应来看。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/b0a178f8f2bf8cc9f418eead49c0df36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A5Awk3TZFaIPqQIa"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@fezbot2000?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fezbot2000 </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="cae9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">响应对象</h1><p id="1e9d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">response对象有一些有用的方法让我们返回各种类型的响应。</p><h2 id="520e" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">资源追加</h2><p id="eb6e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">append</code>方法让我们将响应头附加到我们的响应上。</p><p id="abc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="122f" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="0d82" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="5ed2" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.append('Link', ['&lt;<a class="ae kf" href="http://localhost/" rel="noopener ugc nofollow" target="_blank">http://localhost/</a>&gt;', '&lt;<a class="ae kf" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a>&gt;'])<br/>  res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly')<br/>  res.append('Warning', 'Alert')<br/>  res.send();<br/>})</span><span id="3864" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="6d5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们转到Postman时，当我们查看数据时，应该会在响应的Headers选项卡中看到相同的数据。</p><p id="4d45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们必须运行<code class="fe mv mw mx mm b">res.send()</code>来实际发送响应。</p><h2 id="d866" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">资源附件</h2><p id="d0b3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">res.attachment</code>让我们为响应添加一个文件。它不发送响应。</p><p id="7166" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a10e" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="2130" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="f49d" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.attachment('../public/foo.txt');<br/>  res.send();<br/>})</span><span id="bff9" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="3494" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们在<code class="fe mv mw mx mm b">public</code>文件夹中有一个<code class="fe mv mw mx mm b">foo.txt</code>，那么如果我们请求路由，该文件将被下载。</p><p id="2dfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们再次使用<code class="fe mv mw mx mm b">res.send()</code>来实际发送响应。</p><h2 id="2a41" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">res.cookie</h2><p id="aa2d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">res.cookie</code>让我们向响应添加一个cookie。</p><p id="7aa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c862" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="5e5b" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="0761" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.cookie('name', 'foo', { domain: 'repl.it', path: '/', secure: true })<br/>  res.send();<br/>})</span><span id="072a" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="7505" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们向客户端发送一个名为<code class="fe mv mw mx mm b">foo</code>的cookie。我们可以在右上角的Cookies链接下签到Postman。</p><h2 id="105c" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">res .下载</h2><p id="ba8f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">res.download</code>向服务器发送文件响应。</p><p id="eca4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7a66" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="0029" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="34dc" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.download('./public/foo.txt');<br/>})</span><span id="77e9" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="6a42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当一个请求被发送到这个路径时，我们就会下载一个文件。</p><h2 id="c452" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">研究报告</h2><p id="f158" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">res.json</code>让我们向客户端发送一个JSON响应。该参数可以是任何JSON类型，包括对象、数组、字符串、布尔值、数字或null。</p><p id="0aba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ab14" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="6d11" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="b1ae" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.json({ message: 'hi' });<br/>})</span><span id="d651" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="c639" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5b40" class="mq lf it mm b gy mr ms l mt mu">{"message":"hi"}</span></pre><p id="e6bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为回应。</p><h2 id="bdec" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">资源重定向</h2><p id="7447" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用它重定向到另一个传入字符串的URL。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="12c9" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="2862" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="bf2d" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.redirect('<a class="ae kf" href="http://medium.com'" rel="noopener">http://medium.com'</a>);<br/>})</span><span id="351f" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="714e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们向上面的路线发出请求时，我们将看到<a class="ae kf" href="http://medium.com" rel="noopener">http://medium.com</a>的内容。</p><h2 id="00b8" class="mq lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">资源状态</h2><p id="676d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">res.status</code>让我们发送状态代码响应。我们可以通过在调用<code class="fe mv mw mx mm b">status</code>之后调用<code class="fe mv mw mx mm b">end</code>、<code class="fe mv mw mx mm b">send</code>或<code class="fe mv mw mx mm b">sendFile</code>方法来使用它。</p><p id="ca89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5661" class="mq lf it mm b gy mr ms l mt mu">const express = require('express')<br/>const app = express()</span><span id="ce00" class="mq lf it mm b gy my ms l mt mu">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="453e" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.status(403).end();<br/>})</span><span id="1d58" class="mq lf it mm b gy my ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="997e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到一个403响应。</p><h1 id="594a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="6e12" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用Express添加路线很简单。我们只需要告诉它要监听的URL和方法，以及处理与之匹配的请求的路由处理器。</p><p id="7e05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用请求对象获得查询字符串和URL参数。</p><p id="18a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以根据自己的偏好用响应对象发送状态、文本或文件。</p></div></div>    
</body>
</html>