<html>
<head>
<title>Parsing JSON with Circe — Beyond the Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用喀尔刻解析JSON超越基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/parsing-json-with-circe-beyond-the-basics-334014de393e?source=collection_archive---------9-----------------------#2020-07-22">https://levelup.gitconnected.com/parsing-json-with-circe-beyond-the-basics-334014de393e?source=collection_archive---------9-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/11706541d05e467685c7b578450a4cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IY6ExZeqpEt3d0I5"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">原载于</em><a class="ae kg" href="https://edward-huang.com/circe/2020/07/21/parsing-json-with-circe-beyond-the-basics/" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://edward-huang.com</em></a><em class="kf">。</em></figcaption></figure><p id="2fb7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">喀尔刻一直是Scala中解析Json库的首选。喀尔刻的强大之处在于它可以将Json字符串多态地派生为ADT。然而，我第一次使用喀尔刻时遇到了挫折——部分原因是我刚接触Scala编程语言，接触了函数式编程的世界。有时，错误消息是不透明的，或者有一些特定的配置需要通过源代码来实现特定的目标。</p><p id="3ed5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">本文是文章<a class="ae kg" href="https://medium.com/@edwardgunawan880/6-quick-tips-to-parse-json-with-circe-9bbe51ce5778" rel="noopener"> 7用喀尔刻解析Json的快速技巧</a>的继续。</p><p id="d78e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">随着我用Scala开发了越来越多的应用程序，并对函数式编程范式有了更多的了解，我想分享我在用喀尔刻解析Json时遇到的所有问题。这些是我在工作场所遇到的用例，以及我是如何解决它们的。</p><h1 id="817f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">ADT中的编码/解码余积(和)类型</h1><p id="51fd" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">有时，我们希望在ADT中用不同于余积类型的字符串表示来解码余积。</p><p id="dcdf" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">例如，我们在《哈利·波特》中的<a class="ae kg" href="https://en.wikipedia.org/wiki/Hogwarts" rel="noopener ugc nofollow" target="_blank">霍格沃茨魔法学校</a>有4所房子。</p><p id="31da" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们希望将四个房屋建模为ADT的联产品类型，并能够对各自的<code class="fe mi mj mk ml b">case object</code>进行多形态编码/解码:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="659f" class="mu lg it ml b gy mv mw l mx my">case class House(`type` : HouseType)<br/><br/>sealed trait HouseType<br/>case object GodricGryffindor extends Houses<br/>case object SalazarSlyntherin extends Houses<br/>case object RowenaRavenclaw extends Houses<br/>case object HelgaHufflepuff extends Houses</span></pre><p id="deb1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然而，在与其他团队讨论了合同之后，他们决定将<code class="fe mi mj mk ml b">Houses</code>类型作为Snake_Case发送。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="a00d" class="mu lg it ml b gy mv mw l mx my">"Godric_Gryffindor" =&gt; GodricGryffindor</span></pre><p id="6127" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果我们使用<code class="fe mi mj mk ml b">circe.generic.semiauto.{deriveEncoder,deriveDecoder}</code>，JSON类型的结果将是<code class="fe mi mj mk ml b">GodricGryffindor</code>。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8f3c" class="mu lg it ml b gy mv mw l mx my">{<br/>  "type" : "GodricGryffindor"<br/>}</span></pre><p id="0fb4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先，为<code class="fe mi mj mk ml b">House</code>定义编码器和解码器实例。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="fb0e" class="mu lg it ml b gy mv mw l mx my">import io.circe.generic.semiauto.{deriveEncoder, deriveDecoder}<br/><br/>implicit val houseEncoder:encoder[Houses] = deriveEncoder<br/>implicit val houseDecoder:encoder[Houses] = deriveDecoder</span></pre><p id="b127" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">对传入的Json进行快速转换，并将它们转换成一个<code class="fe mi mj mk ml b">case object</code>。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="959d" class="mu lg it ml b gy mv mw l mx my">implicit val housesEncoder: Encoder[HouseType] = (obj: HouseType) =&gt; obj match {<br/>    case HelgaHufflepuff =&gt; Json.fromString("Helga_Hufflepuff")<br/>    case RowenaRavenclaw =&gt; Json.fromString("Rowena_Ravenclaw")<br/>    case GodricGryffindor =&gt; Json.fromString("Godric_Gryffindor")<br/>    case SalazarSlyntherin =&gt; Json.fromString("Salazar_Slyntherin")<br/>  }<br/><br/>  implicit val housesDecoder: Decoder[HouseType] = (hcursor:HCursor) =&gt; for {<br/>    value &lt;- hcursor.as[String]<br/>    result &lt;- value match {<br/>      case "Helga_Hufflepuff" =&gt; HelgaHufflepuff.asRight<br/>      case "Rowena_Ravenclaw" =&gt; RowenaRavenclaw.asRight<br/>      case "Godric_Gryffindor" =&gt; GodricGryffindor.asRight<br/>      case "Salazar_Slyntherin" =&gt; SalazarSlyntherin.asRight<br/>      case s =&gt; DecodingFailure(s"Invalid house type ${s}", hcursor.history).asLeft<br/>    }<br/>  } yield result</span></pre><p id="2aeb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可以通过定义编码器和解码器来实现“类型”字段成员的不同。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8ef4" class="mu lg it ml b gy mv mw l mx my">val gryffindor = (Houses(`type` = GodricGryffindor)).asJson<br/>println(gryffindor.spaces2)<br/><br/><em class="mz">// {</em><br/><em class="mz">//  "type" : "Godric_Gryffindor"</em><br/><em class="mz">// }</em></span></pre><h1 id="95cb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在产品类型ADT中将EpochMillis转化为Instant</h1><p id="0cc4" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">您想要创建一个具有字段<code class="fe mi mj mk ml b">createdDate</code>的<code class="fe mi mj mk ml b">Currency</code>类。</p><p id="e001" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">样品<code class="fe mi mj mk ml b">Currency</code>类:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="40c7" class="mu lg it ml b gy mv mw l mx my">case class Currency(id: Int, name:String, description:String, isoCodeAlphabetic:String, createdDate:Instant)</span></pre><p id="03ed" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">JSON字符串作为EpochMillis传递<code class="fe mi mj mk ml b">createdDate</code>。但是，您希望将其转换为一个瞬间，以便更容易在<code class="fe mi mj mk ml b">createdDate</code>上进行任何操作。</p><p id="c216" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">样本<code class="fe mi mj mk ml b">Currency</code> JSON字符串:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="cb82" class="mu lg it ml b gy mv mw l mx my">{<br/>  "id" : 1,<br/>  "name" : "US Dollars",<br/>  "description" : "United States Dollar",<br/>  "isoCodeAlphabetic" : "USD",<br/>  "createdDate" : 1595270691417<br/>}</span></pre><p id="8e77" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果您想在喀尔刻转换<code class="fe mi mj mk ml b">case class</code>的特定成员，创建另一个编码/解码实例。</p><p id="8f48" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您只需要在隐式作用域中创建另一个实例，用于从<code class="fe mi mj mk ml b">Long</code>，EpochMillis到<code class="fe mi mj mk ml b">Instant</code>的转换。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4fbe" class="mu lg it ml b gy mv mw l mx my">implicit val encoder:Encoder[Instant] = Encoder.instance(time =&gt; Json.fromLong(time.toEpochMilli))<br/> implicit val decoder:Decoder[Instant] = Decoder.decodeLong.emap(l =&gt; Either.catchNonFatal(Instant.ofEpochMilli(l)).leftMap(t =&gt; "Instant"))</span></pre><p id="5c45" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，为<code class="fe mi mj mk ml b">Currency</code>创建一个编码器/解码器:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="d65f" class="mu lg it ml b gy mv mw l mx my">implicit val encoderCurrency: Encoder[Currency] = deriveEncoder<br/>implicit val deoderCurrency: Decoder[Currency] = deriveDecoder</span></pre><p id="a84c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">喀尔刻将查看隐式作用域，检查从一个值到另一个值是否有编码器/解码器实例。使用隐式解析，如果您提供一种类型的编码器/解码器实例，喀尔刻可以从该类型派生到另一种类型。</p><h1 id="b600" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">编码/解码多态ADT</h1><p id="e88a" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">让我们定义您想要在这个用例中派生的JSON字符串:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="ce20" class="mu lg it ml b gy mv mw l mx my">{<br/>  "houseType" : {<br/>    "type" : "Rowena_Ravenclaw",<br/>    "characteristics" : [<br/>      "Loyal"<br/>    ],<br/>    "animalRepresentation" : "eagle"<br/>  },<br/>  "number" : 12<br/>}</span></pre><p id="eb70" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们想把它转换成:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="377e" class="mu lg it ml b gy mv mw l mx my">House(RowenaRavenclaw(List(Loyal),eagle),12)</span></pre><p id="3c98" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">注意到<code class="fe mi mj mk ml b">type</code>表示您希望JSON字符串转换成什么构造函数名(在本例中，它是RowenaRavenclaw)。</p><p id="728b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">用常规CirceDecoder解码将返回下面的case类。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="b144" class="mu lg it ml b gy mv mw l mx my">House(houseType(`type`: "Rowena_Ravenclaw", List(Loyal),eagle),12)</span></pre><p id="a4b3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如何通过将JSON字符串的字段成员与构造函数名称进行匹配来对JSON字符串进行多态解码？</p><p id="edca" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">有两种方法。第一个将是常规编码和解码，第二个将使用<code class="fe mi mj mk ml b">Circe.extras</code>。</p><h1 id="78ba" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">常规编码和解码</h1><p id="a927" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">构建ADT的方式有很大的不同。为了解释上述用例的解决方法，我将使用<code class="fe mi mj mk ml b">@JsonCodec</code>自动派生一个常规case类的编码器和解码器。</p><p id="92f5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">定义<code class="fe mi mj mk ml b">House</code>和<code class="fe mi mj mk ml b">HouseType</code>的型号类型:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="59cd" class="mu lg it ml b gy mv mw l mx my">@JsonCodec<br/>case class House(houseType: HousesTypes, number:Int)<br/><br/>trait House<br/>object House {<br/>    @JsonCodec<br/>    case class GodricGryffindor(characteristics:List[String]) extends HousesTypes<br/><br/>    object GodricGryffindor{<br/>      val typeId: String = "Godric_Gryffindor"<br/>    }<br/>    <br/>    case object SalazarSlyntherin extends HousesTypes {<br/>      val typeId: String = "Salazar_Slyntherin"<br/>    }<br/><br/>    @JsonCodec<br/>    case class RowenaRavenclaw(characteristics:List[String], animalRepresentation:String) extends HousesTypes<br/><br/>    object RowenaRavenclaw{<br/>       val typeId: String = "Rowena_Ravenclaw"<br/>    }<br/><br/>    @JsonCodec<br/>    case class HelgaHufflepuff(animalRepresentation:String, colours:String) extends HousesTypes<br/><br/>    object HelgaHufflepuff{<br/>      val typeId: String = "Helga_Hufflepuff"<br/>    }<br/>  <br/>}</span></pre><p id="9ac2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在上面的ADT定义中，我们希望为<code class="fe mi mj mk ml b">HouseType</code>提供一个隐式编码器和解码器。</p><p id="a6b2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在对特定的<code class="fe mi mj mk ml b">HouseType</code>进行编码的过程中，我们希望在JSON字符串中添加一个<code class="fe mi mj mk ml b">type</code>字段。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="1c4a" class="mu lg it ml b gy mv mw l mx my">{<br/>  "houseType" : {<br/>    "type" : "Rowena_Ravenclaw", &lt;&lt; - We want to append this based on the specific HouseType<br/>    "characteristics" : [<br/>      "Loyal"<br/>    ],<br/>    "animalRepresentation" : "eagle"<br/>  },<br/>  "number" : 12<br/>}</span></pre><p id="5e41" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">喀尔刻编码实例:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e5fd" class="mu lg it ml b gy mv mw l mx my">implicit val encoder:Encoder[HousesTypes] =  {<br/>    <em class="mz">// deepMerge - insert the encoded Json with another field `type`</em><br/>    <em class="mz">// Basically overriding the current encoder with the `type`</em><br/>    case obj: GodricGryffindor =&gt; obj.asJson deepMerge(Json.obj("type" -&gt; Json.fromString(GodricGryffindor.typeId)))<br/>    case obj: RowenaRavenclaw =&gt; obj.asJson deepMerge(Json.obj("type" -&gt; Json.fromString(RowenaRavenclaw.typeId)))<br/><br/>    case obj: HelgaHufflepuff =&gt; obj.asJson deepMerge(Json.obj("type" -&gt; Json.fromString(HelgaHufflepuff.typeId)))<br/>    case obj: HousesTypes =&gt; Json.obj("type" -&gt; Json.fromString(SalazarSlyntherin.typeId))<br/>  }</span></pre><p id="eb6c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们希望检索<code class="fe mi mj mk ml b">houseType</code> JSON字符串中的<code class="fe mi mj mk ml b">type</code>字段，并在解码过程中基于该类型解码整个JSON字符串。例如，<code class="fe mi mj mk ml b">Rowena_Ravenclaw</code>将指向<code class="fe mi mj mk ml b">RowenaRavenclaw</code>案例类。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4d63" class="mu lg it ml b gy mv mw l mx my">implicit val decoder:Decoder[HousesTypes] = (cursor:HCursor) =&gt; for {<br/>    tpe &lt;- cursor.get[String]("type")<br/>    result &lt;- tpe match {<br/>      case GodricGryffindor.typeId =&gt; cursor.as[GodricGryffindor]<br/>      case RowenaRavenclaw.typeId =&gt; cursor.as[RowenaRavenclaw]<br/>      case HelgaHufflepuff.typeId =&gt; cursor.as[HelgaHufflepuff]<br/>      case SalazarSlyntherin.typeId =&gt; SalazarSlyntherin.asRight<br/>      case s =&gt; DecodingFailure(s"Invalid house type ${s}", cursor.history).asLeft<br/>    }<br/>  } yield result</span></pre><h1 id="11ce" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用Circe.extras</h1><p id="28a0" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">喀尔刻有一个专门的库，<code class="fe mi mj mk ml b">circe.extras</code>，解决了编码/解码多态ADT。</p><p id="78f1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先，让我们通过将HouseType更改为<code class="fe mi mj mk ml b">sealed trait</code>来重写我们的模型:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="be6d" class="mu lg it ml b gy mv mw l mx my">sealed trait HouseType {<br/>    def `type`: String<br/>  }<br/><br/>  object HouseType {<br/>    case class GodricGryffindor(characteristics:List[String]) extends HouseType {<br/>      override def `type`: String = "Godric_Gryffindor"<br/>    }<br/>    case object SalazarSlyntherin extends HouseType {<br/>      override def `type`: String = "Salazar_Slyntherin"<br/>    }<br/>    case class RowenaRavenclaw(characteristics:List[String], animalRepresentation:String) extends HouseType {<br/>      override def `type`: String = "Rowena_Ravenclaw"<br/>    }<br/>    case class HelgaHufflepuff(animalRepresentation:String, colours:String) extends HouseType {<br/>      override def `type`: String = "Helga_Hufflepuff"<br/>    }<br/>  }</span></pre><p id="b62b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您可以将JSON字符串中的<code class="fe mi mj mk ml b">type</code>设置为鉴别符，在配置中指示构造函数，并隐式声明配置。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7914" class="mu lg it ml b gy mv mw l mx my">implicit val houseTypeConfig = Configuration.default.withDiscriminator("type").copy(<br/>      transformConstructorNames = {<br/>        case "GodricGryffindor" =&gt; "Godric_Gryffindor" <em class="mz">// from `type` on the right transform the case changes to the left</em></span><span id="abe7" class="mu lg it ml b gy na mw l mx my">        case "SalazarSlyntherin" =&gt; "Salazar_Slyntherin"</span><span id="bb18" class="mu lg it ml b gy na mw l mx my">        case "RowenaRavenclaw" =&gt; "Rowena_Ravenclaw"</span><span id="6092" class="mu lg it ml b gy na mw l mx my">        case "HelgaHufflepuff" =&gt; "Helga_Hufflepuff"</span><span id="fe70" class="mu lg it ml b gy na mw l mx my">      }<br/>    )</span></pre><p id="25e5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我正在设置转换构造函数名称的配置。我想基于其中一个字段<code class="fe mi mj mk ml b">type</code>转换整个JsonString。JSON字段<code class="fe mi mj mk ml b">type</code>包含case语句右侧的值(" Godric_Gryffindor "，" Salazar_Slyntherin "，...).我想把JSON字符串转换成case语句左边的case类(“godrick格兰芬多”、“SalazarSlyntherin”)。case语句的左侧将与我们上面定义的模型相匹配。</p><p id="81ae" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，在编码/解码过程中，使用<code class="fe mi mj mk ml b">circe.generic.extras</code>中的<code class="fe mi mj mk ml b">deriveConfiguredEncoder</code>和<code class="fe mi mj mk ml b">deriveConfiguredDecoder</code>对JSON字符串进行多态编码/解码:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="f9e6" class="mu lg it ml b gy mv mw l mx my">implicit val house2Encoder = {<br/>    implicit val config = houseTypeConfig<br/>    deriveConfiguredEncoder[HouseType]<br/>}<br/><br/>implicit val house2Decoder = {<br/>  implicit val config = houseTypeConfig<br/>  deriveConfiguredDecoder[HouseType]<br/>}</span></pre><p id="68ed" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">测试并运行上面的命令:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="1e13" class="mu lg it ml b gy mv mw l mx my">val ravenClaw: HouseType = RowenaRavenclaw(characteristics = List("Loyal"), animalRepresentation = "eagle")</span><span id="2198" class="mu lg it ml b gy na mw l mx my">val ravenClawJson = ravenClaw.asJson</span><span id="abdb" class="mu lg it ml b gy na mw l mx my">val ravenClawStr = ravenClawJson.noSpaces</span><span id="321a" class="mu lg it ml b gy na mw l mx my">println(ravenClaw.asJson.spaces2)<br/>println(decode[HouseType](ravenClawStr).right.get)</span></pre><h1 id="671f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">外卖食品</h1><ul class=""><li id="7b54" class="nb nc it kj b kk md ko me ks nd kw ne la nf le ng nh ni nj bi translated">您可以通过提供这些类型的编码器/解码器实例来编码和解码特定的Json字段。喀尔刻利用编译器隐式解析将JsonString转换为所需的ADT。</li><li id="3aa6" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ng nh ni nj bi translated">通过使用<code class="fe mi mj mk ml b">circe.generic.extras.Configuration</code>，使用CirceExtra对联产品类型ADT进行编码/解码。</li><li id="0d1d" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ng nh ni nj bi translated">使用<code class="fe mi mj mk ml b">deepMerge</code>将一个JSON对象合并到另一个JSON对象，并注入您想要的任何特定字段。</li></ul><p id="5714" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这就是喀尔刻ADT的编码和解码！</p><p id="f1dd" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我希望这篇文章可以帮助你开始你的下一个项目，用喀尔刻编码/解码ADT类型。</p><p id="c0ea" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">所有源代码都是<a class="ae kg" href="https://github.com/edwardGunawan/Blog-Tutorial/blob/master/ScalaTutorial/parsejsonwithcircetutorial/src/main/scala/DecodingComplexCoproduct.scala" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="0a97" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="mz">最初发表于</em><a class="ae kg" href="https://edward-huang.com/circe/2020/07/21/parsing-json-with-circe-beyond-the-basics/" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://edward-huang.com</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>