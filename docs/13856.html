<html>
<head>
<title>Write Efficient Python Code for Data Scientists: Optimizing Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为数据科学家编写高效的Python代码:优化您的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-efficient-python-code-for-data-scientists-optimizing-your-code-2dbb717f610e?source=collection_archive---------2-----------------------#2022-10-12">https://levelup.gitconnected.com/write-efficient-python-code-for-data-scientists-optimizing-your-code-2dbb717f610e?source=collection_archive---------2-----------------------#2022-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="833d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">作为一名数据科学家，了解如何优化您的python代码并提高其效率</h2></div><p id="f661" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">作为一名数据科学家，你应该把大部分时间花在从数据中获得洞察力上，而不是等待你的代码完成运行。编写高效的Python代码有助于减少运行时间和节省计算资源，最终让您腾出时间去做更有影响力的事情。</p><p id="d96d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本系列的前一篇文章“<a class="ae ln" href="https://medium.com/geekculture/write-efficient-python-code-defining-measuring-code-efficiency-e33a5bd9f7ca?source=your_stories_page-------------------------------------" rel="noopener">编写高效的python代码:定义&amp;测量代码效率</a>中，我讨论了什么是Python高效代码，以及如何使用不同的Python内置数据结构、函数和模块来编写更干净、更快、更高效的代码。我还探索了如何对代码进行计时和分析，以便找到瓶颈。</p><div class="lo lp gp gr lq lr"><a href="https://medium.com/geekculture/write-efficient-python-code-defining-measuring-code-efficiency-e33a5bd9f7ca" rel="noopener follow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd iu gy z fp lw fr fs lx fu fw is bi translated">编写高效的Python代码:定义和衡量代码效率</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">了解如何衡量Python代码的效率</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">medium.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf mg lr"/></div></div></a></div><p id="b2ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将使用数据科学家最常用的Python库来练习消除这些瓶颈和其他不好的设计模式:<strong class="kk iu"> NumPy </strong>和<strong class="kk iu"> pandas </strong>。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/d7981b4e9993c3586e91ae182defa556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0LEG1X6S__MRUA2I"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Alessandro Bianchi 在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="9f52" class="mw mx it bd my mz na dn nb nc nd dp ne kr nf ng nh kv ni nj nk kz nl nm nn no bi translated">目录:</h2><ol class=""><li id="9334" class="np nq it kk b kl nr ko ns kr nt kv nu kz nv ld nw nx ny nz bi translated">提高代码效率<br/> 1.1。有效地组合、计数和迭代<br/> 1.2。集合论简介<br/> 1.3。消除循环<br/> 1.4。编写更好的循环</li><li id="08a8" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld nw nx ny nz bi translated">熊猫优化简介<br/> 2.1。熊猫数据帧迭代<br/> 2.2。熊猫替代打圈<br/> 2.3。最优熊猫迭代</li><li id="a3f7" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld nw nx ny nz bi translated">参考</li></ol><p id="6b4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">本文中使用的所有代码和数据集都可以在这个GitHub资源库中找到:</strong></p><div class="lo lp gp gr lq lr"><a href="https://github.com/youssefHosni/Advanced-Python-Programming-Tutorials-" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd iu gy z fp lw fr fs lx fu fw is bi translated">GitHub-youssefHosni/高级-Python-编程-教程-</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">github.com</p></div></div><div class="ma l"><div class="of l mc md me ma mf mg lr"/></div></div></a></div></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="4d1d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如果你想免费学习数据科学和机器学习，看看这些资源:</strong></p><ul class=""><li id="73ea" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated">免费互动路线图，自学数据科学和机器学习。从这里开始:<a class="ae ln" href="https://aigents.co/learn/roadmaps/intro" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn/roadmaps/intro</a></li><li id="04fc" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated">数据科学学习资源搜索引擎(免费)。将你最喜欢的资源加入书签，将文章标记为完整，并添加学习笔记。<a class="ae ln" href="https://aigents.co/learn" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn</a></li><li id="0fb9" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated">想要在导师和学习社区的支持下从头开始学习数据科学吗？免费加入这个学习圈:【https://community.aigents.co/spaces/9010170/】T2</li></ul><p id="c335" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如果你想在数据科学&amp; AI领域开始职业生涯，但你不知道如何开始。我提供数据科学指导课程和长期职业指导:</strong></p><ul class=""><li id="e675" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated">长期师徒:<a class="ae ln" href="https://lnkd.in/dtdUYBrM" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dtdUYBrM</a></li><li id="b1f0" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated">辅导课程:<a class="ae ln" href="https://lnkd.in/dXeg3KPW" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dXeg3KPW</a></li></ul><p id="2fa6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">加入</em> </strong> <a class="ae ln" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="kk iu"> <em class="or">中等会员</em> </strong> </a> <strong class="kk iu"> <em class="or">计划，只需5美元，继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em> </strong></p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="3bb6" class="os mx it bd my ot ou ov nb ow ox oy ne jz oz ka nh kc pa kd nk kf pb kg nn pc bi translated">1.使您的代码高效</h1><p id="edeb" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr pd kt ku kv pe kx ky kz pf lb lc ld im bi translated">在这一部分，我们将介绍更多的效率技巧和诀窍。您将学习一些有用的内置模块来编写高效的代码，并练习使用集合论。然后，您将了解Python中的循环模式，以及如何使它们更有效。</p><h2 id="19d5" class="mw mx it bd my mz na dn nb nc nd dp ne kr nf ng nh kv ni nj nk kz nl nm nn no bi translated">1.1.有效地组合、计数和迭代</h2><p id="e588" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr pd kt ku kv pe kx ky kz pf lb lc ld im bi translated"><strong class="kk iu"> <em class="or">组合对象</em> </strong></p><p id="3f4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一小节中，我们将讨论在python中有效地组合、计数和迭代对象。假设我们有两个列表:一个是名字，另一个是每个人的年龄。我们想合并这些列表，这样每个名字都存储在它的年龄旁边。我们可以使用enumerate遍历姓名列表，并使用index变量获取每个姓名对应的年龄。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="9b20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是Python的内置函数<strong class="kk iu"> zip </strong>提供了一个更优雅的解决方案。“zip”这个名字描述了这个函数是如何将像夹克上的拉链这样的对象组合在一起的(将两个独立的东西变成一个)。zip返回一个zip对象，它必须被解压到一个列表中并打印出来才能看到内容。每个条目都是原始列表中的一组元素。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/c82a972dd913ee568820457ed5e2c7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*aYTmFgt_xVo824uNTmuIDg.png"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/777381efea91a31c2730a0c8967c3c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*oeetYR5kFeruF5RfKtdqaA.png"/></div></figure><p id="9cbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python还附带了许多高效的内置模块。collections模块包含专门的数据类型，可用作标准字典、列表、集合和元组的替代。几个值得注意的专门化数据类型是:</p><ul class=""><li id="9e4e" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated"><strong class="kk iu">命名元组</strong>:具有命名字段的元组子类</li><li id="903d" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu"> deque </strong>:列表式容器，可快速追加和弹出</li><li id="615c" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu">计数器</strong>:计数易碎物品的字典</li><li id="a145" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu"> OrderedDict </strong>:保留条目顺序的字典</li><li id="53fc" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu"> defaultdict </strong>:调用工厂函数来提供缺失值的dict</li></ul><p id="4304" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">清点物件</em> </strong></p><p id="9a7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们更深入地研究一下<strong class="kk iu">计数器</strong>对象。首先，我们将上传口袋妖怪数据集<a class="ae ln" href="https://github.com/youssefHosni/Advanced-Python-Programming-Tutorials-/blob/main/Datasets/pokemon.csv" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"/></a>并打印它的前五行，然后我们将使用for循环计算每种类型口袋妖怪的数量，然后使用Counter函数。</p><ul class=""><li id="1391" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated">让我们加载pokemon数据集并打印前五行:</li></ul><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pk"><img src="../Images/6c6a5424eafe3a04e03f92c7ddc5db56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pc7-4Vhpx8Z-hsqX-p2Ebw.png"/></div></div></figure><ul class=""><li id="80f3" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated">现在，我们将使用循环来计算每种类型的口袋妖怪数量，并计算执行时间:</li></ul><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pl"><img src="../Images/3a8491afd01ac95ef80ffec4315c9b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eROz-n4ShJpJrXwu0p0KGA.png"/></div></div></figure><ul class=""><li id="a769" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated">最后，我们将使用<strong class="kk iu">计数器</strong>功能计算每种类型的口袋妖怪数量，并比较时间:</li></ul><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pm"><img src="../Images/e3cc738f56f41d310cf1151cf39edbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiEnWTCbHw_nvv7LKYxVYA.png"/></div></div></figure><p id="afad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，使用<strong class="kk iu">集合</strong>模块中的<strong class="kk iu">计数器</strong>函数<strong class="kk iu"> </strong>是一种更有效的方法。只需导入<strong class="kk iu">计数器</strong>并提供要计数的对象。不需要循环！Counter返回键值对的计数器字典。打印时，它是按最高计数到最低计数排序的。如果比较运行时间，我们会发现使用计数器比使用标准字典方法花费的时间更少！</p><p id="72a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or"> itertools </em> </strong></p><p id="c914" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个内置模块<strong class="kk iu"> itertools </strong>，包含使用迭代器的功能工具。这些工具的一个子集是:</p><ul class=""><li id="2a8f" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated"><strong class="kk iu">无限迭代器:</strong>计数、循环、重复</li><li id="2430" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu">有限迭代器:</strong> accumulate，chain，zip_longest等。</li><li id="c57f" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu">组合生成器:</strong>乘积、排列、组合</li></ul><p id="33b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将关注<strong class="kk iu">组合生成器。</strong>这些生成器有效地产生对象的笛卡尔乘积、排列和组合。我们来探讨一个例子。</p><p id="3bb5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">组合</em> </strong></p><p id="2e07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想收集所有可能的神奇宝贝组合。我们可以使用嵌套的for循环来实现这一点，该循环在poke_types列表上迭代两次。请注意，条件语句用于跳过两次具有相同类型的对。比如x是‘Bug’，y是‘Bug’，我们要跳过这一对。因为我们对组合感兴趣(顺序不重要)，所以在追加之前，使用另一个语句来确保组合列表中不存在该对的顺序。例如，对(' Bug '，' Fire ')与对(' Fire '，' Bug ')相同。我们要这双鞋中的一双，不要两双。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pn"><img src="../Images/4e12615a3efe5ebd7ef91da15d540032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGJmAWQh2COo3RyoAlZ-zw.png"/></div></div></figure><p id="ed05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">itertools 的组合生成器提供了更有效的解决方案。首先，我们导入组合，然后通过提供<strong class="kk iu"> poke_types </strong>列表和我们想要的组合长度来创建一个组合对象。组合返回一个组合对象，我们将其解包到一个列表中并打印出来以查看结果。如果比较运行时，我们会发现使用组合要比嵌套循环快得多。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="73cf" class="mw mx it bd my mz na dn nb nc nd dp ne kr nf ng nh kv ni nj nk kz nl nm nn no bi translated">1.2.集合论导论</h2><p id="a734" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr pd kt ku kv pe kx ky kz pf lb lc ld im bi translated">通常，我们想要比较两个对象，以观察它们内容之间的相似性和差异。当进行这种类型的比较时，最好利用一个叫做集合论的数学分支。众所周知，Python自带了一个内置的<strong class="kk iu"> set </strong>数据类型。集合提供了一些我们可以用来比较的简便方法，例如:</p><ul class=""><li id="6d6d" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated"><strong class="kk iu"> intersection() </strong>:两个集合中的所有元素</li><li id="7860" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu"> difference(): </strong>一个集合中的所有元素，而不是另一个集合中的所有元素</li><li id="ed6d" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu">symmetric _ difference():</strong>所有元素正好在一个集合中</li><li id="e30d" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated"><strong class="kk iu"> union(): </strong>任一集合中的所有元素</li></ul><p id="71ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们想要多次以不同的方式比较对象时，我们应该考虑将数据存储在集合中，以使用这些有效的方法。Python集合的另一个很好的特性是能够快速检查成员中是否存在值。我们称之为使用操作符中的<strong class="kk iu">的成员测试。我们将介绍如何将</strong>操作符中的<strong class="kk iu">用于集合比用于列表或元组要快得多。</strong></p><p id="2757" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有两个神奇宝贝名字的列表:list_a和list_b，我们想比较这两个列表，看看哪个神奇宝贝同时出现在两个列表中。我们可以首先使用一个嵌套的for循环来比较list_a中的每一项和list_b中的每一项，并只收集那些同时出现在两个列表中的项。但是，遍历两个列表中的每一项是非常低效的。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi po"><img src="../Images/9cefb5919d10cabea2caf46b8e0579da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*wmRYdYXIjCLxd82gtHvwYg.png"/></div></figure><p id="1645" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，更好的方法是使用Python的<strong class="kk iu"> set </strong>数据类型来比较这些列表。通过将每个列表转换为一个集合，我们可以使用点交方法来收集两个集合之间共享的神奇宝贝。一行简单的代码，不需要循环！</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/b9fecf4d0d24aae6d2c7da5cbc747e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*JgUGA9mO-CCR9YAaMTabdA.png"/></div></figure><p id="a61f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用少得多的代码行得到了相同的答案，我们还可以比较运行时，看看使用集合比使用循环快多少。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/f42c568a56ecc433f756c5c39252fdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*U2lEghTEHFVppILFcrpxow.png"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/bfbad003dd60cd1af378467bbbd1140d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*u2-NpWqM4wf8TogxiQyzvQ.png"/></div></figure><p id="faf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，使用集合比使用for循环要快得多。我们还可以使用set方法来查看存在于一个集合中而不存在于另一个集合中的神奇宝贝。要收集存在于set_a中但不存在于set_b中的神奇宝贝，请使用set_a.difference(set_b)。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/769ac9bf4ef0c26a63b7c76790ad2230.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*NyiZGHsI7XIMYzQ8FhS14g.png"/></div></figure><p id="2417" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们希望神奇宝贝在set_b中，而不是在set_a中，我们使用set_b.difference(set_a)。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/93c2267ce554dcbb0dd799e743b26c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*e2zxySE17DuevybwN9nmEQ.png"/></div></figure><p id="ada3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要收集恰好存在于其中一个集合中的神奇宝贝(而不是两个集合)，我们可以使用一种叫做对称差的方法。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/c5172dff1ad514660f8d6f6b59041144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*fpzMYnECAa3yC_3GBolLzw.png"/></div></figure><p id="56f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以使用<strong class="kk iu">来组合这些集合。联合</strong>法。这将收集出现在其中一个或两个集合中的所有独特神奇宝贝。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="0d1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用集合的另一个很好的效率提升是能够快速检查一个特定的项目是否是集合元素的成员。考虑一下我们的720个神奇宝贝名称的集合，它们被存储为一个列表、元组和集合。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="88e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要检查超音蝠这个字符是否在每个数据结构中，并打印每个数据类型的执行时间:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/75b52b6cef8c35da11dbf3645eb6fba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*9Peq__-3hgvHUpvc7JiUhg.png"/></div></figure><p id="91d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在比较运行时时，很明显，使用集合进行成员测试要比使用列表或元组快得多。</p><p id="0a06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用集合的最后一个效率提升来自集合本身的定义。集合被定义为不同元素的集合。因此，我们可以使用集合从现有对象中收集唯一的项目。让我们定义一个<strong class="kk iu"> primary_types </strong>列表，它包含每个神奇宝贝的主要类型。如果我们想收集这个列表中唯一的神奇宝贝类型，我们可以编写一个for循环来迭代这个列表，并且只追加那些还没有被添加到<strong class="kk iu"> unique_types </strong>列表中的神奇宝贝类型。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pw"><img src="../Images/4580ec2b2c14be8a2aaab404abb9fec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiwI8dWA3LfX1gQnsy2TuQ.png"/></div></div></figure><p id="02e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用一套使这变得容易得多。我们所要做的就是将primary_types列表转换成一个集合，这样我们就有了解决方案:一组不同的神奇宝贝类型。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi px"><img src="../Images/2a7b6ee3271d4786f13f2ae3facd7401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9C-Bbe-jQBgnAIuBsFXMg.png"/></div></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="edfe" class="mw mx it bd my mz na dn nb nc nd dp ne kr nf ng nh kv ni nj nk kz nl nm nn no bi translated">1.3.消除循环</h2><p id="cab8" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr pd kt ku kv pe kx ky kz pf lb lc ld im bi translated">尽管在编写Python代码时使用循环并不一定是一种糟糕的设计模式，但是使用额外的循环可能效率低下且成本高昂。让我们探索一些工具，它们可以帮助我们消除在代码中使用循环的需要。Python提供了一些循环模式，当我们想要迭代一个对象的内容时，可以使用这些模式:</p><ul class=""><li id="de06" class="np nq it kk b kl km ko kp kr on kv oo kz op ld oq nx ny nz bi translated">For循环逐段迭代序列中的元素。</li><li id="6c30" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated">只要满足某个布尔条件，While循环就会重复执行一个循环。</li><li id="0ff6" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld oq nx ny nz bi translated">嵌套循环在彼此内部使用多个循环。</li></ul><p id="22a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管Python支持所有这些循环模式，但我们在使用它们时应该小心。因为大多数循环都是以一段一段的方式进行评估的，所以它们通常是低效的解决方案。</p><p id="9e8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在编写高效的代码时，我们应该尽量避免循环。消除循环通常会减少更容易解释的代码行。pythonic代码的一个习惯用法是“<strong class="kk iu">扁平比嵌套</strong>好。”努力消除代码中的循环将有助于我们遵循这个习语。</p><p id="9b5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个名为poke_stats的列表列表，其中包含每个神奇宝贝的统计值。每行对应一个神奇宝贝，每列对应一个神奇宝贝的具体统计值。在这里，列代表一个神奇宝贝的生命点，攻击，防御和速度。我们希望对这些行进行简单的求和，以便收集每个神奇宝贝的总统计数据。如果我们要使用一个循环来计算行总和，我们就必须遍历每一行，并将该行的总和追加到总计列表中。我们可以用更少的代码，通过列表理解来完成同样的任务。或者，我们可以使用我们在之前的<a class="ae ln" href="https://medium.com/geekculture/write-efficient-python-code-defining-measuring-code-efficiency-e33a5bd9f7ca" rel="noopener"> <strong class="kk iu">文章</strong> </a>中讨论过的内置地图功能。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi py"><img src="../Images/1460632aacaa925391d524a73d1546ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvoX0xhZ850N0_F_J0Y6Lw.png"/></div></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pz"><img src="../Images/831064a35b7626ed273b55e3c9c5f84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdBpPWDY8lrt7xgldwrugQ.png"/></div></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qa"><img src="../Images/eb4c13578d1120eff12a63323a6056ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gm0mo1Klns-lolvclAYxIw.png"/></div></div></figure><p id="666b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些方法都将返回相同的列表，但是使用列表理解或map函数只需要一行代码，运行时间更快。</p><p id="84d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前一篇文章中，我们还介绍了一些内置模块，它们可以帮助我们消除循环。除了使用嵌套的for循环，我们可以使用itertools模块中的组合来获得更简洁、更高效的解决方案。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="75a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个消除循环的强大技术是使用NumPy包。假设我们有与上一个例子相同的统计数据集合，但是存储在一个NumPy数组中，而不是一个list列表。</p><p id="86ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望收集数组中每个神奇宝贝(或行)的平均统计值。我们可以使用一个循环来迭代数组并收集行平均值。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qb"><img src="../Images/e1f5eba06dc4be1e33ab22a66a8e917e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlS7Ck9ne9qhsg8qk0Doeg.png"/></div></div></figure><p id="93e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">用NumPy </em> </strong>消除循环</p><p id="650f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，NumPy数组允许我们一次对整个数组进行计算。这里，我们使用点平均法，并指定一个等于1的轴来计算每行的平均值(这意味着我们计算列值的平均值)。这消除了对循环的需要，并且效率更高。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qc"><img src="../Images/c4c0f91b898cd4daa02cc419ffb013c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnDvdD91kdQJN1zgtPHstQ.png"/></div></div></figure><p id="58ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在比较运行时时，我们看到在整个数组上使用点平均法并指定一个轴比使用循环要快得多。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="1281" class="mw mx it bd my mz na dn nb nc nd dp ne kr nf ng nh kv ni nj nk kz nl nm nn no bi translated">1.4.编写更好的循环</h2><p id="d13f" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr pd kt ku kv pe kx ky kz pf lb lc ld im bi translated">我们已经讨论了循环是如何变得昂贵和低效的。但是，有时你不能消除一个循环。在这一节中，我们将探讨当循环不可避免时，如何使循环更有效。在深入讨论之前，我们将讨论的一些循环可以使用前面课程中介绍的技术来消除。出于演示的目的，我们假设这里显示的用例是循环不可避免的情况。</p><p id="7983" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提高循环效率的最好方法是分析循环中正在做的事情。我们希望确保我们在每次迭代中不做不必要的工作。如果对循环的每次迭代都执行计算，但是它的值不随每次迭代而改变，那么最好将这个计算移到循环之外(或之上)。如果一个循环在每次迭代中转换数据类型，那么这种转换可以在循环之外(或之下)使用map函数来完成。任何可以一次完成的事情都应该移到循环之外。让我们探讨几个例子。</p><p id="2356" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">移动计算上面一个循环</em> </strong></p><p id="3205" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个神奇宝贝名字的列表和一个每个神奇宝贝对应攻击值的数组。我们希望打印出每个攻击值大于所有攻击值平均值的神奇宝贝的名字。为此，我们将使用一个循环来迭代每个神奇宝贝及其攻击值。对于每次迭代，通过找到所有攻击的平均值来计算总攻击平均值。然后，评估每个神奇宝贝的攻击值，看是否超过总平均值。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qd"><img src="../Images/ca59723972919ea3964276319871233b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzAmL5xr_YRiTjG2vM_9fg.png"/></div></div></figure><p id="e100" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个循环的低效之处在于，每次循环迭代都会创建total_attack_avg变量。但是，这个计算在迭代之间不会改变，因为它是一个整体平均值。我们只需要计算这个值一次。通过将这种计算移到循环之外(或之上),我们只计算一次总攻击平均值。我们得到相同的输出，但这是一个更有效的方法。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="3b35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们比较一下这两种方法的运行时间:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qe"><img src="../Images/e43fb0ce83f19bbe9cd1c2877ca4a30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gaHB_mksiSWXnWC1JNVTnw.png"/></div></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qf"><img src="../Images/b61fabc604848d4920707241c0a0220b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JwxE8YsnouojqgEuW7NcQ.png"/></div></div></figure><p id="a397" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到，将total_attack_avg计算保持在循环中需要120多微秒。</p><p id="4e6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">整体转换</em> </strong></p><p id="14b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种提高循环效率的方法是在循环之外(或之下)使用<strong class="kk iu">整体转换</strong>。在下面的例子中，我们有来自720个神奇宝贝数据集的三个列表:每个神奇宝贝的名字列表，一个与神奇宝贝是否具有传奇地位相对应的列表，以及每个神奇宝贝的世代列表。我们希望组合这些对象，以便每个名称、状态和层代都存储在一个单独的列表中。为此，我们将使用一个循环来迭代zip函数的输出。记住，zip返回元组的集合，所以我们需要将每个元组转换成一个列表，因为我们想要创建一个列表的列表作为我们的输出。然后，我们将每个单独的poke_list附加到poke_data输出变量中。通过打印结果，我们可以看到我们想要的列表。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qg"><img src="../Images/c78ba882d1e26716c4817f546abccbbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DvcCBCSnCaw-271GL9nDQ.png"/></div></div></figure><p id="8237" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在循环内将每个元组转换成一个列表并不是非常高效。相反，我们应该收集所有的poke _ tuples，并使用map函数将每个tuple转换成一个列表。循环不再在每次迭代中将元组转换为列表。相反，我们将这个元组移动到循环之外(或之下)的列表转换。这样，我们一次转换所有的数据类型(或整体地)，而不是在每次迭代中转换。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qh"><img src="../Images/c98fb09f6ab183512d97e09db8a0d152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oqgv639rPe90okZi3DIFdA.png"/></div></div></figure><p id="0a0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行时显示，在循环之外将每个元组转换为一个列表更有效。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="19e6" class="os mx it bd my ot ou ov nb ow ox oy ne jz oz ka nh kc pa kd nk kf pb kg nn pc bi translated">2.熊猫优化简介</h1><h2 id="50ee" class="mw mx it bd my mz na dn nb nc nd dp ne kr nf ng nh kv ni nj nk kz nl nm nn no bi translated">2.1.熊猫数据框架迭代</h2><p id="6bf9" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr pd kt ku kv pe kx ky kz pf lb lc ld im bi translated">Pandas是一个用于数据分析的库。pandas的主要构造是DataFrame，这是一种带有标记行和列的表格数据结构。我们将关注迭代数据帧的最佳方法。让我们从分析一个<a class="ae ln" href="https://github.com/youssefHosni/Advanced-Python-Programming-Tutorials-/blob/main/Datasets/baseball_stats.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">美国职业棒球大联盟数据集</strong> </a>开始。它包含了从1962年到2012年每个美国职业棒球大联盟球队的统计数据，这些数据存储在一个名为<strong class="kk iu"> baseball_df </strong>的熊猫数据帧中。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qi"><img src="../Images/a5f0e4a53c1d87684185020d38912bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5K8KNlrrNAnQ48PtbeXpw.png"/></div></div></figure><p id="9828" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将关注W列，它指定了一支球队在一个赛季中的获胜次数，而G列包含了一支球队在一个赛季中的比赛次数。</p><p id="ff9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">计算&amp;相加胜率</em> </strong></p><p id="e7d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个用来评估球队在某个赛季表现的流行统计数据是球队的胜率。该指标的计算方法是将球队的总胜率除以比赛次数。这里有一个简单的函数来执行这个计算。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="9131" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们想在我们的<strong class="kk iu"> baseball_df </strong>数据框架中创建一个新列，存储每个球队在一个赛季中的胜率。为此，我们需要迭代DataFrame的行，并应用我们的<strong class="kk iu"> calc_win_perc </strong>函数。首先，我们创建一个空的win_perc_list来存储我们将计算的所有成功率。然后，我们编写一个循环，遍历数据帧的每一行。请注意，我们使用的索引变量(I)的范围是从零到数据帧内存在的行数。然后我们使用<strong class="kk iu">。iloc </strong>方法，使用索引变量查找数据帧中的每一行。</p><p id="124a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过引用W和G列来获取每个团队的胜利和比赛。接下来，我们将团队的胜利和比赛传递给calc_win_perc，以计算胜利百分比。最后，我们将win_perc追加到win_perc_list并继续循环。我们通过将列值设置为等于win_perc_list，在DataFrame中创建我们想要的列，称为WP。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qj"><img src="../Images/2481b7cfac8d4b1eef729c6e1d9e4cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6lrbrF2LbgohdMJX-9B1w.png"/></div></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qk"><img src="../Images/81626201682f6ed5b8f3c70260021538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8WxDTS07DAreMdGXEAApg.png"/></div></div></figure><p id="4410" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<strong class="kk iu">在数据帧上循环。iloc </strong>给了我们想要的输出，但是效率低吗？估计运行时时。iloc方法需要660毫秒，效率相当低。</p><p id="9e82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">不断重复着。ITER rows()</em>T5】</strong></p><p id="ed32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">熊猫有一些有效的方法来循环数据帧。我们要介绍的第一个方法是<strong class="kk iu">。iterrows </strong>方法。这个类似于<strong class="kk iu">。iloc </strong>方法，但<strong class="kk iu">。iterrows </strong>将每个DataFrame行作为(index，pandas Series)对的元组返回。这意味着从<strong class="kk iu">返回的每个对象。iterrows </strong>包含每一行的索引作为第一个元素，每一行中的数据作为熊猫系列作为第二个元素。</p><p id="1b1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们仍然创建空的<strong class="kk iu"> win_perc_list </strong>，但是现在我们不必创建索引变量来查找数据帧中的每一行。<strong class="kk iu">。iterrows </strong>为我们处理索引！for循环的其余部分保持不变，在baseball_df数据帧中创建新的win percentage列。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ql"><img src="../Images/a4f4d3740c5c479d04e61513d416c610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyW8dhFbS9srcdfLGLNRRQ.png"/></div></div></figure><p id="e5f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用。iterrows大约需要一半的时间。iloc需要迭代我们的数据帧。</p><p id="e5a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or">迭代着。itertuples() </em> </strong></p><p id="5537" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">熊猫还带来了另一种叫做<strong class="kk iu">的迭代方法。itertuples </strong>通常比<strong class="kk iu">更有效。iterrows </strong>。让我们继续使用我们的棒球数据集来比较这两种方法。假设我们有一个名为team_wins_df的熊猫数据帧，其中包含每个队在一个赛季中的总胜场数。</p><p id="bd2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们用<strong class="kk iu">。iterrows </strong>循环遍历我们的<strong class="kk iu"> team_wins_df </strong> DataFrame并打印每一行的元组，我们看到每一行的值都存储为一个pandas系列。记住，<strong class="kk iu">。iterrows </strong>将每个DataFrame行作为(index，pandas Series)对的元组返回，因此我们必须使用方括号索引来访问行的值。</p><p id="e98a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们可以使用<strong class="kk iu">。itertuples </strong>来循环我们的DataFrame行。<strong class="kk iu">。itertuples </strong>方法将每个DataFrame行作为一种称为namedtuple的特殊数据类型返回。namedtuple是我们之前讨论过的集合模块中存在的一种专用数据类型。这些数据类型的行为就像Python元组一样，但是具有可使用属性查找访问的字段。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/cacdb2c282aea3780d076d64fcbfd753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*XdMBem6Kitzu6EFBphTiYw.png"/></div></figure><p id="fe8b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，在输出中，每个打印的row_namedtuple都有一个索引属性，team_wins_df中的每一列都有一个属性。这意味着我们可以使用点方法通过查找来访问这些属性。这里，我们可以使用<strong class="kk iu"> row_namedtuple打印最后一个row_namedtuple的索引。索引</strong>。我们可以用<strong class="kk iu"> row_namedtuple打印这个row_namedtuple的团队。团队</strong>，年与<strong class="kk iu">排名双位数。年份</strong>以此类推。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/2f1fe309fc6ded0c7cb33005a592c9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*5keL210SoqTiKDc7Ht29mQ.png"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/1a635529b734f572f7dd5ad9af4c9c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*dJfJ5bR_uVSwsM9Pq_W3wQ.png"/></div></figure><p id="171d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们对比<strong class="kk iu">的时候。项目编号</strong>至<strong class="kk iu">。itertuples </strong>，我们看到有相当多的改进！</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qp"><img src="../Images/7db9250f8305be2d3839263d9c965ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IyUj5bmdu6YHKdPnnkfq4Q.png"/></div></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qq"><img src="../Images/0b9e8bc04beb318370ab60d272f176ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_0GaScvwaPtc-lQ_FcCOQ.png"/></div></div></figure><p id="879c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原因<strong class="kk iu">。itertuples </strong>比<strong class="kk iu">更高效。iterrows </strong>是由于每个方法存储其输出的方式。自<strong class="kk iu">起。iterrows </strong>以熊猫系列的形式返回每一行的值，这有一点额外的开销。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="0a61" class="mw mx it bd my mz na dn nb nc nd dp ne kr nf ng nh kv ni nj nk kz nl nm nn no bi translated">2.2.熊猫替代打圈</h2><p id="5e1b" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr pd kt ku kv pe kx ky kz pf lb lc ld im bi translated">为了编写高效的代码，我们希望尽可能避免循环。因此，现在我们将探索使用<strong class="kk iu">的替代方案。ITER row</strong>和<strong class="kk iu">。itertuples </strong>在数据帧上执行计算。</p><p id="6ddb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将继续使用棒球数据集。我们将首先创建<strong class="kk iu"> calc_run_diff </strong>函数。该函数通过从一个赛季的总得分中减去球队允许的总得分来计算球队在给定年份的得分差异。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="339e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望在baseball_df数据帧中创建一个名为RD的新列，用于存储每支球队多年来的跑步差异。以前我们用for循环使用<strong class="kk iu">来做这个。ITER row</strong>或<strong class="kk iu">。itertuples </strong>。在这里，我们将使用<strong class="kk iu">。iterrows </strong>为例。注意，我们使用for循环迭代baseball_df，将每一行的RS和RA列传递给calc_run_diff函数，然后将每一行的结果追加到run_diffs_iterrows列表中。这给了我们想要的输出，但不是我们最有效的选择。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qr"><img src="../Images/bf803507cf8f5e24a7efecaf3716e599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0uO7N4YAP8uayOta-nZ7og.png"/></div></div></figure><p id="26f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="or"> Pandas.apply()方法</em> </strong></p><p id="4e18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用循环迭代数据帧的一种替代方法是使用<strong class="kk iu"> pandas.apply </strong>方法。该函数的作用类似于map函数。它接受一个函数作为输入，并将这个函数应用于整个数据帧。因为我们使用的是表格数据，所以我们必须指定一个我们希望函数作用的轴。使用0作为轴参数将对列应用我们的函数，而使用1作为轴参数将对所有行应用我们的函数。就像map函数一样，<strong class="kk iu"> pandas.apply </strong>方法可以与匿名函数或lambdas一起使用。</p><p id="be01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看如何使用<strong class="kk iu">。应用</strong>方法计算我们的运行差异。首先，我们称之为<strong class="kk iu">。在baseball_df数据帧上应用</strong>。然后，我们使用lambda函数迭代数据帧的行。注意，我们的lambda参数是row(因为我们应用于DataFrame的每一行)。对于每一行，我们获取RS和RA列，并将它们传递给calc_run_diff函数。最后，我们指定我们的轴来告诉dot-apply我们想要迭代行而不是列。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qs"><img src="../Images/7461968e1255708f7ce2175aa1fde21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3f8M7pTJKYdzZdklMblgQ.png"/></div></div></figure><p id="34fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们使用<strong class="kk iu">时。应用</strong>方法来计算我们的运行微分，我们不需要使用一个for循环。我们可以将我们的运行差异直接收集到一个名为<strong class="kk iu"> run_diffs_apply的对象中。</strong></p><p id="9b3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到<strong class="kk iu">。iterrows </strong>方法花了大约321毫秒完成。但是，使用点应用方法只需要45.2毫秒。绝对的进步！</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="397c" class="mw mx it bd my mz na dn nb nc nd dp ne kr nf ng nh kv ni nj nk kz nl nm nn no bi translated">2.3.最优熊猫迭代</h2><p id="c368" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr pd kt ku kv pe kx ky kz pf lb lc ld im bi translated">从我们的第一部<strong class="kk iu">开始，我们已经走过了漫长的道路。iloc </strong>迭代数据帧的方法。我们讨论的每种方法都真正提高了性能。但是，这些方法侧重于对数据帧的每一行单独进行计算。现在，我们将探索一些panda的内部机制，使我们能够更有效地执行计算。</p><p id="a81f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为熊猫是一个建立在NumPy上的图书馆。这意味着我们使用的每个pandas数据帧都可以利用前面的<a class="ae ln" href="https://medium.com/geekculture/write-efficient-python-code-defining-measuring-code-efficiency-e33a5bd9f7ca" rel="noopener"> <strong class="kk iu">文章</strong> </a>中讨论的NumPy数组的高效特性。我们讨论了广播，以及它是如何允许NumPy数组向量化操作的，所以它们是一次在一个对象的所有元素上执行的。这使我们能够高效地对整个数组执行计算。就像NumPy一样，pandas旨在对计算进行矢量化，以便它们可以一次对整个数据集进行操作(而不仅仅是逐行操作)。让我们用一些例子来探讨这个概念。</p><p id="dc10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将继续使用我们在本章中一直使用的baseball_df数据帧。因为pandas构建在NumPy之上，所以我们可以使用点值方法将这些DataFrame列的任何值作为NumPy数组。这里，我们将W列的值收集到一个名为wins_np的NumPy数组中。当我们打印wins_np的类型时，我们看到它实际上是一个NumPy数组。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi qt"><img src="../Images/f50d6d5a1a89b26ae59a95d4b3ab8882.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*uUY67fCg8EDbxn9Bio-H9g.png"/></div></figure><p id="38b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过打印数组并验证它是否与数据帧中的W列相同来查看数组的内容。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi qu"><img src="../Images/6ba147cfbcce02611f2b5fced0f2f311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*yUmrpBdl4d9YwfaY2X8WhQ.png"/></div></figure><p id="724f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当利用NumPy阵列的广播能力时，可以看到知道熊猫是建立在NumPy上的好处。请记住，这意味着我们可以向量化我们的计算，并立即在整个数组上执行它们！而不是循环遍历一个数据帧，并单独处理每一行，就像我们对<strong class="kk iu">所做的那样。iterrows </strong>，<strong class="kk iu">。itertuples </strong>和<strong class="kk iu">。应用</strong>，我们可以在baseball_df数据帧的底层NumPy数组上执行计算。在这里，我们将数据帧中的RS和RA列收集为NumPy数组，并使用广播一次性计算游程差分！</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi qv"><img src="../Images/0206dae60c8c6d9dde2e321ebfc0cc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aoatd3h_Qrtb_xJV_Om6EQ.png"/></div></div></figure><p id="b89a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们使用NumPy数组来执行游程差分计算时，我们可以看到我们的代码变得更具可读性。在这里，我们可以清楚地看到我们的运行差异是如何计算的。此外，当我们对NumPy数组方法计时时，我们看到我们的运行差分计算需要几微秒！所有其他方法都以毫秒为单位进行报告。我们的阵列方法比所有以前的方法快几个数量级！很明显，使用DataFrame的底层NumPy数组来执行计算可以帮助我们获得巨大的效率。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="e8ad" class="os mx it bd my ot ou ov nb ow ox oy ne jz oz ka nh kc pa kd nk kf pb kg nn pc bi translated">3.参考</h1><ol class=""><li id="861c" class="np nq it kk b kl nr ko ns kr nt kv nu kz nv ld nw nx ny nz bi translated"><a class="ae ln" href="https://app.datacamp.com/learn/courses/writing-efficient-python-code" rel="noopener ugc nofollow" target="_blank">编写高效的Python代码</a></li><li id="9501" class="np nq it kk b kl oa ko ob kr oc kv od kz oe ld nw nx ny nz bi translated">代码和数据集可以在这个GitHub资源库中找到</li></ol><div class="lo lp gp gr lq lr"><a href="https://github.com/youssefHosni/Advanced-Python-Programming-Tutorials-" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd iu gy z fp lw fr fs lx fu fw is bi translated">GitHub-youssefHosni/高级-Python-编程-教程-</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">github.com</p></div></div><div class="ma l"><div class="of l mc md me ma mf mg lr"/></div></div></a></div></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><div class="mi mj mk ml gt lr"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd iu gy z fp lw fr fs lx fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="ma l"><div class="qw l mc md me ma mf mg lr"/></div></div></a></div><p id="20ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="or">感谢阅读！如果你喜欢这篇文章，一定要鼓掌(高达50！)并在</em><a class="ae ln" href="https://www.linkedin.com/in/youssef-hosni-b2960b135/" rel="noopener ugc nofollow" target="_blank"><em class="or">LinkedIn</em></a><em class="or">上与我联系，并在</em><a class="ae ln" href="https://youssefraafat57.medium.com/" rel="noopener"><em class="or">Medium</em></a><em class="or">上关注我以了解我的新文章</em></p></div></div>    
</body>
</html>