<html>
<head>
<title>GitLab CI/CD How-to</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitLab CI/CD操作指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/gitlab-ci-cd-how-to-706159edc997?source=collection_archive---------6-----------------------#2021-02-05">https://levelup.gitconnected.com/gitlab-ci-cd-how-to-706159edc997?source=collection_archive---------6-----------------------#2021-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e0ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">克里夫为想要实现这一飞跃的老前辈们写了笔记</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d8d0046340da11f5a98b0e7caa776d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tTCQPKc51PvIBLX6"/></div></div></figure><p id="6670" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如今要成为一名工程师，不与<a class="ae lq" href="https://en.wikipedia.org/wiki/Git" rel="noopener ugc nofollow" target="_blank"> Git </a>亲密接触几乎是不可能的；分布式版本控制的彻底改变者。当然，事情并不总是这样。当<a class="ae lq" href="https://en.wikipedia.org/wiki/Version_control" rel="noopener ugc nofollow" target="_blank"> CVS和Subversion </a>仍然流行的时候，我做了我职业生涯的一部分。事实上，我可以追溯到工程师们压缩他们的代码库，通过软盘面对面地互相分享的时候…..但是我跑题了。</p><p id="5cb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">多年来，围绕Git构建的许多协作套件已经浮出水面，但三个最强有力的竞争者仍然存在，<a class="ae lq" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae lq" href="https://bitbucket.org/product/" rel="noopener ugc nofollow" target="_blank"> Bitbucket </a>和<a class="ae lq" href="https://gitlab.com" rel="noopener ugc nofollow" target="_blank"> GitLab </a>。虽然我在GitHub上托管了很多开源项目，只是因为那里的社区，但我一直更喜欢将GitLab作为工作项目的解决方案。当然，GitLab在任何特定领域都做得不太好，相比之下，像吉拉这样专注于功能的产品在问题管理方面做得更好，但它最全面地覆盖了管理和跟踪软件开发项目所需的所有基本功能，这也是我更喜欢它的部分原因。换句话说，它为我的团队提供了一种方式，使他们不必仅仅为了一个项目而登录到多个站点，因此，资产自然地落入一个单一的地方，以便更容易地引用。与此同时，如果你真的超出了GitLab功能所能提供的范围，它足够灵活，可以轻松地与其他工具集成，例如吉拉，这使得用GitLab扩展项目变得毫不费力。然后是我比其他人更喜欢GitLab的更大原因。它基本上是CI/CD的始祖，它允许在维护人员将新代码合并到特定的预定义分支时，自动构建、测试和部署更新。正如您从它听起来的方式可以看出的那样，CI/CD为开发人员或devops工程师节省了大量的时间，因为他们不再需要手动构建、测试和部署更新，特别是对于那些必须频繁更新的人员。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/ba6519c64bc754c865deef1c87b578fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7rsDMLDjWp8LeMhPSzRxw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">解释什么是Ci/CD的官方GitLab文档…</figcaption></figure><p id="5cda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在CI/CD成为现实之前，我是一名具有基础设施背景的工程师，与开发人员密切合作，管理发布和部署超过15年，我花了一些额外的努力来掌握如何将这一新概念实际应用到现有项目中。当然，这并没有阻止我采用它，只是为了享受这个美妙的自动化工具，我付出了比我希望的更多的努力。所以今天，我决定写“快速入门教程”可能会很有趣，鉴于我的“老前辈”背景，也因为当我可以使用一个愚蠢的简单例子来贯穿整个过程时，我会学得更快，所以我可以在深入挖掘每个组件的细节之前获得大的图片。</p><p id="e438" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了满足我自己的兴趣来写这篇教程之外，也许这对那些还没有完全理解CI/CD的经验丰富的老手来说也是有用的。它甚至可以提供一些关于如何将CI/CD用于更多遗留环境的想法，因为大多数现有的教程都是面向现代架构的(例如k8s，docker ),这给人一种错误的感觉，即它不适合较小规模或较旧的生产环境。</p><p id="c6e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我假设您已经非常精通编写bash脚本和操纵Linux服务器。我还假设您已经在您的工作站上安装了<a class="ae lq" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> GoLang </a>，并且非常了解Git/GitLab的基础知识。</p><p id="ba49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以让我们开始吧！</p><h2 id="a43b" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">在GitLab上创建一个项目</h2><p id="31b5" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">首先，让我们在GitLab上创建一个名为“ci-cd-demo”的项目来托管一个超级简单的Go http应用程序的repo:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/c353aff0f30f6387071ae246af030e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfuPQTrYIstqCGnwnWpeWQ.png"/></div></div></figure><p id="7a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将README.md添加到主分支，提交并推送:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/cdf690d810f7011bba5050393990b853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*troPTCtj0viKPkWcbFjPYw.png"/></div></div></figure><h2 id="7d39" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">创建发展分支</h2><p id="1481" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在我们有了一个带有主分支的项目，让我们创建一个“开发”分支，这样我们就可以开始创建示例应用程序了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/30ed22b930cce94e1d290f6e84b6e26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kInDgu1IAMF3gIbWV6sswQ.png"/></div></div></figure><h2 id="fe6a" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">创建一个示例应用程序</h2><p id="ab41" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">接下来，签出develop分支并创建一个main.go文件。那么，让我们从这篇<a class="ae lq" href="https://www.sohamkamani.com/golang/how-to-build-a-web-application/" rel="noopener ugc nofollow" target="_blank">博文</a>中借用一些代码保存下来:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="4a84" class="lw lx it my b gy nc nd l ne nf">package main</span><span id="4bac" class="lw lx it my b gy ng nd l ne nf">import (<br/> // Import the gorilla/mux library we just installed<br/> "fmt"<br/> "net/http"</span><span id="da2b" class="lw lx it my b gy ng nd l ne nf">"github.com/gorilla/mux"<br/>)</span><span id="cb9f" class="lw lx it my b gy ng nd l ne nf">func main() {<br/> // Declare a new router<br/> r := mux.NewRouter()</span><span id="3423" class="lw lx it my b gy ng nd l ne nf">// This is where the router is useful, it allows us to declare methods that<br/> // this path will be valid for<br/> r.HandleFunc("/hello", handler).Methods("GET")</span><span id="df4e" class="lw lx it my b gy ng nd l ne nf">// We can then pass our router (after declaring all our routes) to this method<br/> // (where previously, we were leaving the second argument as nil)<br/> http.ListenAndServe(":8080", r)<br/>}</span><span id="69ab" class="lw lx it my b gy ng nd l ne nf">func handler(w http.ResponseWriter, r *http.Request) {<br/> fmt.Fprintf(w, "Hello World!")<br/>}</span></pre><p id="930b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你很好奇该应用是否工作，可以在电脑上手动编译，运行，用浏览器查地址，<a class="ae lq" href="https://localhosts:8080/hello" rel="noopener ugc nofollow" target="_blank">https://localhosts:8080/hello</a>。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="91ca" class="lw lx it my b gy nc nd l ne nf">$ go get<br/>$ go build<br/>$ ./ci-cd-demo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8bb2d201073a02cca8522e03f989edd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*8mjE1-VR1Or80xKD3K5SSg.png"/></div></figure><p id="e5fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，让我们添加一个. gitignore文件，这样任何本地构建都不会被推送到repo，对于我来说，因为我使用vim，所以我也会选择ignore *。swp文件也是如此:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="fb98" class="lw lx it my b gy nc nd l ne nf">*.swp<br/>ci-cd-demo</span></pre><p id="553c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，现在我们有了一个简单的http应用程序，它打印出“Hello World！”经过测试，浏览器内部工作正常，我们现在可以开始部署了。</p><p id="a6f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我有一个临时的web服务器，设置如下，nginx反向代理已经配置好，并指向localhost:8080:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a90cf50a43978ba9ed04285714d4f7f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*gjwKGW9NXX4RAkkXvp1WXw.png"/></div></figure><p id="66b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，要部署它，我只需将二进制文件scp到服务器的/home/demo中，然后运行它，瞧！https://demo.3df.io/hello正在播放“你好，世界！”：</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/18f5640d404a0a5df1d32a90cf270d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUChd5qu5OQnF654PSMVqw.png"/></div></div></figure><p id="f3de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，这很好，但是如果我不得不继续在这个网站上工作，不得不做各种回归测试，然后不得不频繁地反复向服务器部署新的更新，那该怎么办呢？这需要很多时间和工作，对吗？这就是我们可以依靠CI/CD来扭转局面的地方！</p><h2 id="2bb5" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">准备CI/CD</h2><p id="2cab" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">要让CI/CD运转起来，其实超级简单。实际上，您只需编写一些bash脚本，在repo根目录下的. gitlab-ci.yml文件中定义所有自动化任务，并在GitLab web UI上进行一些小的配置步骤，您就可以进入DevOps天堂了。</p><p id="3b43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么构成GitLab的CI/CD更重要的基础组件是什么呢？</p><ul class=""><li id="280c" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><strong class="kw iu">。gitlab-ci.yml </strong> —定义需要做什么的文件</li><li id="12d0" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><strong class="kw iu"> Runner </strong> —运行Gitlab Runner“代理”来构建、测试和部署的机器或容器</li><li id="aa6b" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><strong class="kw iu">变量</strong> —构建、测试和部署环境的环境变量</li></ul><p id="cc54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经熟悉了GitLab CI/CD的基本组件，让我们列出我们希望如何自动构建、测试和部署应用程序，这样我就不再需要自己手动完成了:</p><ul class=""><li id="957e" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><strong class="kw iu">构建</strong> —自动编译main.go的最新合并</li><li id="53f2" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><strong class="kw iu">测试</strong> —运行一个测试脚本，确保二进制代码返回200并输出“Hello World！”</li><li id="1bd7" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><strong class="kw iu">部署</strong> —终止服务器上正在运行的二进制文件，用新的二进制文件替换服务器的二进制文件，然后运行二进制文件</li></ul><h2 id="c7e9" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">自动化脚本</h2><p id="1bc1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在让我们自动化构建、测试和部署这个应用程序的步骤。</p><p id="17c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构建很容易，因为在任何新的Linux环境中它实际上只有两个命令，但是让我们把它放在一个名为“build.sh”的bash脚本中:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="85ec" class="lw lx it my b gy nc nd l ne nf">#!/bin/bash</span><span id="c1d1" class="lw lx it my b gy ng nd l ne nf">go get<br/>go build</span></pre><p id="efa3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，测试稍微复杂一点，所以让我们编写一个名为test.sh的快速bash脚本来为我们自动测试:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="f6af" class="lw lx it my b gy nc nd l ne nf">#!/bin/bash</span><span id="1f90" class="lw lx it my b gy ng nd l ne nf"># Test to make sure the application is returning code 200<br/>CODE=$(curl -s -w "%{http_code}" "<a class="ae lq" href="http://localhost:8080/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello</a>" -o /dev/null)</span><span id="8de5" class="lw lx it my b gy ng nd l ne nf">if [ $CODE == '200' ]; then<br/> echo "Yay! Application returned code 200"<br/>else<br/> echo "Argh! Application returned error code: $CODE..."<br/> exit 1<br/>fi</span><span id="5ce8" class="lw lx it my b gy ng nd l ne nf"># Test to make sure the application is returning the string "Hello World!"<br/>MSG=$(curl -s "<a class="ae lq" href="http://localhost:8080/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello</a>")</span><span id="3f9c" class="lw lx it my b gy ng nd l ne nf">if [ "$MSG" = "Hello World!" ]; then<br/> echo "Yay! Application Works!"<br/>else<br/> echo "No! Application Failed! Code: $MSG"<br/> exit 1<br/>fi</span></pre><p id="12e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们已经有了一个测试脚本，我们可能还应该为名为“deploy.sh”的部署编写一个脚本:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="122f" class="lw lx it my b gy nc nd l ne nf">#/bin/bash</span><span id="147f" class="lw lx it my b gy ng nd l ne nf">## Find the PID of existing binary running on server<br/>PID=$(ssh <a class="ae lq" href="mailto:demo@demo.3df.io" rel="noopener ugc nofollow" target="_blank">demo@demo.3df.io</a> "ps -eaf |pgrep ci-cd-demo")</span><span id="1add" class="lw lx it my b gy ng nd l ne nf">## If PID is empty, then we can just move ahead<br/>## but if not, then kill the process<br/>if [ "$PID" = "" ]; then<br/> echo "ci-cd-demo is not running on this server"<br/>else<br/> ## Kill existing process<br/> ssh <a class="ae lq" href="mailto:demo@demo.3df.io" rel="noopener ugc nofollow" target="_blank">demo@demo.3df.io</a> "kill -9 $PID"<br/> echo "Killing ci-cd-demo process"<br/>fi</span><span id="c0d3" class="lw lx it my b gy ng nd l ne nf">## Upload new binary<br/>echo "Uploading new binary..."<br/>scp /builds/hkdb/ci-cd-demo/ci-cd-demo <a class="ae lq" href="mailto:demo@demo.3df.io" rel="noopener ugc nofollow" target="_blank">demo@demo.3df.io</a>:/home/demo/<br/>echo  "done..."</span><span id="6ce5" class="lw lx it my b gy ng nd l ne nf">## Run new binary on server<br/>echo "Run binary..."<br/>ssh <a class="ae lq" href="mailto:demo@demo.3df.io" rel="noopener ugc nofollow" target="_blank">demo@demo.3df.io</a> "nohup /home/demo/ci-cd-demo &amp;&gt; /dev/null &amp; exit"<br/>echo "Deployment complete..."</span></pre><p id="a790" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">剧本到此为止！</p><h2 id="a07f" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">SSH认证</h2><p id="51c9" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">您现在可能在想，在部署阶段，运行人员如何访问服务器，您是完全正确的。</p><p id="82d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们专门为CI/CD制作一个ssh密钥对，这样我们就能够让runner访问我们的服务器。请确保创建不带密码的密钥，因为不支持带密码的密钥:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="aa17" class="lw lx it my b gy nc nd l ne nf">$ ssh-keygen<br/>Generating public/private rsa key pair.<br/>Enter file in which to save the key (/home/hkdb/.ssh/id_rsa): /home/hkdb/.ssh/ci-cd-demo<br/>Enter passphrase (empty for no passphrase): <br/>Enter same passphrase again:<br/>...</span></pre><p id="21a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上面可以看出，我生成了一个名为ci-cd-demo(.pub) in ~/。ssh/。然后我们复制公钥并把它放在~/中。服务器上的ssh/authorized_keys。</p><h2 id="f93f" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">变量</h2><p id="8a33" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在，这就是上面提到的“变量”出现的地方。接下来，我们将复制私钥，前往我们在GitLab.com的项目，进入设置→ CI / CD，然后单击“扩展”按钮。然后，会出现一个“添加变量”按钮。单击它并在KEY字段中输入“SSH_PRIVATE_KEY ”,然后将您复制的私有密钥粘贴到value字段中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/66dd12d540e3ddb2e52c6b593928e274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*rzxI93ju0L0Mn45KBT1vPg.png"/></div></figure><p id="f0ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其余的可以保持默认，所以你只需点击“添加变量”。不过有一点要注意，屏蔽你的私钥本质上是一个好主意，但不幸的是，屏蔽私钥有一个问题。所以我想我最好的建议是，如果你真的要这么做的话，用一个已经安装好的钥匙来设置你自己的跑步器，但是为了这个教程，我们还是继续吧。</p><p id="db4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，只需添加另一个变量“SSH_KNOWN_HOSTS”，就可以为runner设置known_hosts。首先，从您的工作站执行以下命令，以便您可以复制SSH_KNOWN_HOST值的输出:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="4f6d" class="lw lx it my b gy nc nd l ne nf">ssh-keyscan -t rsa demo.3df.io</span></pre><p id="88a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，返回GitLab.com web用户界面，添加另一个变量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/05cd69fb67a1185839cdabb0347f6d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*GPAaNGFpuG1wn2h9-jJh1A.png"/></div></figure><h2 id="172b" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">定义CI/CD</h2><p id="c4a3" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">好了，我们现在已经涵盖了构建、测试和部署。现在我们只需要告诉GitLab CI/CD，在每次将代码合并到主分支时，按照我们想要的顺序运行它们。出于简化本教程的目的，我们将在GitLab.com上使用默认的“共享runner ”,而不是构建我们自己的。另外，作为旁注，每个阶段都创建了一个新的环境，所以除非您指定了“工件”，否则您不能期望编译后的二进制文件会被带到下一个阶段。也就是说，是时候把。gitlab-ci.yml文件。我们想要的如下:</p><ul class=""><li id="c0c5" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">仅对主分支自动运行</li><li id="9f9b" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">在每个阶段安装所有必要的软件包</li><li id="a91f" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">在每个阶段运行各自的bash脚本</li><li id="5afb" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">使构建在一周内可用(aritifact)</li><li id="0c6d" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">进行手动部署——这允许我们在点击按钮进行部署之前审查构建和测试</li><li id="ecc7" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">使用变量为部署阶段正确设置ssh验证</li></ul><p id="4ba5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基于以上所述。gitlab-ci.yml文件将如下所示:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="3199" class="lw lx it my b gy nc nd l ne nf">build-job:<br/>  stage: build<br/>  ## Install necessary packages and compile code<br/>  script:<br/>    - apt-get update -y<br/>    - apt-get install golang -y<br/>    - ./build.sh<br/>  ## Upload binary to GitLab and make available for 1 week and also to make accessible to test job to run and test<br/>  artifacts:<br/>    paths:<br/>      - ci-cd-demo<br/>    expire_in: 1 week<br/>  ## Only when code merges into master<br/>  only: <br/>    - master</span><span id="1fdc" class="lw lx it my b gy ng nd l ne nf">test-job:<br/>  stage: test<br/>  script:<br/>    - apt-get update -y &amp;&amp; apt-get install curl<br/>    ## Run Binary<br/>    ## Builds are stored in /builds/&lt;gitlab user&gt;/&lt;project name&gt;/<br/>    - /builds/hkdb/ci-cd-demo/ci-cd-demo &amp;<br/>    - ./test.sh<br/>  ## Only when code merges into master<br/>  only:<br/>    - master</span><span id="5704" class="lw lx it my b gy ng nd l ne nf">deploy-prod:<br/>  stage: deploy<br/>  when: manual<br/>  script:<br/>    ## Install ssh-client and load ssh key<br/>    - 'command -v ssh-agent &gt;/dev/null || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )'<br/>    - eval $(ssh-agent -s)<br/>    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -<br/>    - mkdir -p ~/.ssh<br/>    - chmod 700 ~/.ssh<br/>    ## Add known server to known hosts<br/>    - echo "$SSH_KNOWN_HOSTS" &gt;&gt; ~/.ssh/known_hosts<br/>    - chmod 644 ~/.ssh/known_hosts<br/>    - ./deploy.sh<br/>  only: <br/>    - master</span></pre><p id="0240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧啊。我们现在准备给它一个机会。</p><h2 id="6727" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">真正行动的时间到了</h2><p id="1fcb" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在让我们提交并推送所有这些新代码，然后合并到master中。一旦你合并到主分支，回到GitLab.com的web用户界面，点击你的项目页面左侧栏上的CI/CD→“Pipelines”。您会注意到一个新的渠道已经启动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/89be145f18605f17f6a6cfd3dc4bddbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cckIg1DisXLVtxDCQvM6yQ.png"/></div></div></figure><p id="57f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">点击蓝色的“正在运行”徽章，您将看到更详细的管道视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/e1a38e531e1e935d731e235254321114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*00PPG9TJvIBJsAn1tLjdZg.png"/></div></figure><p id="1853" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以通过单击它们来查看每个阶段内部发生了什么，因此让我们单击正在运行的构建作业:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/79aea9d69830d1817b0bc315a963ae66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6__JsM5g-z3q-sNYm6FlQ.png"/></div></div></figure><p id="9ac9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了！生成作业成功！现在让我们回过头来看看管道视图，我们会注意到测试作业已经自动启动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/77d1e2731476ed7e257db1b3103ef951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*d2xLuLlbrtH1LFrTFdyNWg.png"/></div></figure><p id="6091" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们点击进入测试作业:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/949d676dbbdd961af8ba51ff31f767f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ze_6HJpSlpmV-6DPQlcXmg.png"/></div></div></figure><p id="f8af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">厉害！看来我们的测试工作也通过了！我们现在会在pipeline视图中注意到，部署作业尚未开始，我们还会看到一个play按钮，我们可以单击它来启动它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/6487be917e0e0dbf3b332a50048a8770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAYm67_HmDJJGY3t6IfxcQ.png"/></div></div></figure><p id="db7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">单击“播放”按钮后，让我们单击进入部署作业:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ccb13b2f45c3b4bed73fb7fa16433928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wqq5DL2UnKlHXH6wHxbhLg.png"/></div></div></figure><p id="8f7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅仅几分钟后…砰！成功部署，仅此而已！</p><h2 id="aba4" class="lw lx it bd ly lz ma dn mb mc md dp me ld mf mg mh lh mi mj mk ll ml mm mn mo bi translated">推送更新</h2><p id="9342" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在我们已经正确地设置了CI/CD，让我们尝试做一些更改，并再次合并到master中。也许改变“你好，世界！”到“你好CI/CD世界！”？</p><p id="4b7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以让我们更新main.go:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="5bf1" class="lw lx it my b gy nc nd l ne nf">- 27         fmt.Fprintf(w, "Hello World!")<br/>+ 27         fmt.Fprintf(w, "Hello CI/CD World!")</span></pre><p id="bb58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后相应地更改test.sh:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="bb64" class="lw lx it my b gy nc nd l ne nf">- 16 if [ "$MSG" = "Hello World!" ]; then<br/>+ 16 if [ "$MSG" = "Hello CI/CD World!" ]; then</span></pre><p id="d6b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，提交，推动，合并，然后喝杯咖啡。回来后，检查构建和测试工作，然后点击play on deploy。几分钟后，我们将看到管道已经完成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a7d88d42c0789df664b5a997920972e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*Y3YdMIJ49OInwUifd2CQTw.png"/></div></figure><p id="de88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们只有看到对了才会相信？所以让我们去看看这个网站:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8b132f053478c1bbe5f2567828fe814e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*85V-hAeswUsuS1JDCHl2KQ.png"/></div></figure><p id="1e74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你知道了。我们刚刚在GitLab上为一个超级简单的Go http应用程序设置了CI/CD，一切正常。当然，我在这篇文章中简化了一切，但我的想法是，第一次从头到尾获得完整的画面对我们学习更强大的功能产生了奇迹，因为我们现在已经在我们的脑海中准备好了整个过程，可以在我们更深入地进入CI/CD世界时进行交叉引用。</p></div></div>    
</body>
</html>