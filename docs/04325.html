<html>
<head>
<title>Reducers in Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clojure中的Reducers</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reducers-in-clojure-c088a5627412?source=collection_archive---------5-----------------------#2020-06-21">https://levelup.gitconnected.com/reducers-in-clojure-c088a5627412?source=collection_archive---------5-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b6687ea37432fe961b759c7b2725ad45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cOdyaPiPMO1_NCIJ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@noahbuscher?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺亚·布舍尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c781" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们将探索reducer和Clojure的高性能reducer库。当第一次接触Clojure时，很容易忽略学习或使用reducers，因为递归性质、高阶函数和通用术语一开始可能会令人望而生畏。</p><p id="bd83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让事情变得更容易理解的关键是了解主reduce函数如何遍历集合来产生一个值。从那里，我们可以看到一些要减少的参数，看看我们如何利用高阶函数来分离和抽象转换操作，使多个转换链接在一起。</p><p id="f187" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是在我们继续学习本教程之前，我认为我们应该首先看看为什么如果我们想提高性能，那么努力去真正理解并在代码中使用reducers是值得的。</p><h2 id="b81c" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">为什么要费心学习如何使用减速器？</h2><p id="094c" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">学习如何正确使用reducers的主要原因是，它为您提供了一套强大的工具，通常可以帮助您更快地并行执行代码。</p><p id="dbd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缩减器也构成了<em class="mc">转换器</em>的基础，后者是从一个缩减函数到另一个缩减函数的转换，并提供了与其输入和输出源的上下文无关的更高级别的可组合转换。我们将在以后的文章中探讨转换器，但本质上它们利用reducers使您的处理函数更具可重用性和灵活性，这样您就可以在许多不同的东西上使用相同的转换器，如core.async通道或集合，而不必为每个输入数据类型提供特定的实现。</p><p id="23e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用reducers而不是核心序列处理函数消除了处理过程中需要的一些中间集合，并且它们还消除了一些由懒惰引起的处理开销，最终使您的代码对于一些问题运行得更快。</p><p id="1d7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，您可能已经熟悉了基本的序列函数，比如<code class="fe md me mf mg b">map </code>和<code class="fe md me mf mg b">filter</code>，但是您知道它们是clojure.core.reducers名称空间中这些函数<code class="fe md me mf mg b">r/map</code>和<code class="fe md me mf mg b">r/filter</code>的基于reducer的版本吗？</p><p id="a1ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解这些函数是如何工作的并不重要，但一个关键的见解是要认识到像map和filter这样的函数可以写成reducing操作。</p><p id="d086" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以<code class="fe md me mf mg b">clojure.core</code>中的<code class="fe md me mf mg b">map </code>为例:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="3aec" class="le lf it mg b gy mp mq l mr ms">(defn map                        <br/> "Returns a lazy sequence consisting of the result of applying f to                         the set of first items of each coll, followed by applying f to the                         set of second items in each coll, until any one of the colls is                         exhausted.  Any remaining items in other colls are ignored. Function                         f should accept number-of-colls arguments. Returns a transducer when                         no collection is provided."                         <br/>{:added "1.0" :static true}                         </span><span id="fd35" class="le lf it mg b gy mt mq l mr ms">([f] <br/> (fn [rf] <br/>  (fn ([] (rf)) <br/>    ([result] (rf result))<br/>    ([result input] (rf result (f input))) <br/>    ([result input &amp; inputs] (rf result (apply f input inputs))))))</span><span id="162f" class="le lf it mg b gy mt mq l mr ms">  ([f coll] (lazy-seq (when-let [s (seq coll)]<br/>      (if (chunked-seq? s)<br/>         (let [c (chunk-first s)<br/>               size (int (count c))<br/>               b (chunk-buffer size)]       <br/>            (dotimes [i size]<br/>              (chunk-append b (f (.nth c i))))<br/>               (chunk-cons (chunk b) (map f (chunk-rest s))))<br/>            (cons (f (first s)) (map f (rest s)))))))   </span><span id="263e" class="le lf it mg b gy mt mq l mr ms">   ([f c1 c2] <br/>       (lazy-seq <br/>          (let [s1 (seq c1) s2 (seq c2)]<br/>           (when (and s1 s2)<br/>             (cons (f (first s1) (first s2))<br/>                   (map f (rest s1) (rest s2)))))))    </span><span id="2db5" class="le lf it mg b gy mt mq l mr ms">    ([f c1 c2 c3] <br/>         (lazy-seq <br/>            (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]<br/>               (when (and  s1 s2 s3)<br/>                   (cons (f (first s1) (first s2) (first s3))<br/>                         (map f (rest s1) (rest s2) (rest s3)))))))  </span><span id="fd80" class="le lf it mg b gy mt mq l mr ms">    ([f c1 c2 c3 &amp; colls]<br/>        (let [step (fn step [cs] <br/>          (lazy-seq <br/>            (let [ss (map seq cs)] <br/>              (when (every? identity ss)  <br/>                    (cons (map first ss) (step (map rest ss)))))))]<br/>          (map #(apply f %) (step (conj colls c3 c2 c1))))))</span></pre><p id="5b21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然map确实是一个有用的函数，但它充满了处理不同类型的实现细节，看起来有点复杂。现在让我们看看<code class="fe md me mf mg b">r/map</code>是如何在我们的<code class="fe md me mf mg b">clojure.core.reducers</code>名称空间中定义的:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="c470" class="le lf it mg b gy mp mq l mr ms">(defcurried map                         <br/>"Applies f to every value in the reduction of coll. Foldable."                         {:added "1.5"}<br/>[f coll] <br/>(folder coll <br/>  (fn [f1]<br/>    (rfn [f1 k]<br/>      ([ret k v](f1 ret (f k v)))))))</span></pre><p id="2331" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">整个代码更简单、更通用，并尽可能利用文件夹进行并行操作。酷的是，我们也可以使用这些基于reducer的版本，语法与我们使用基于序列的转换器相似，主要的警告是我们必须对它们进行约简以获得最终值，因为reducer总是返回一个<code class="fe md me mf mg b">reducable</code>而不是一个集合。</p><p id="6f12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个人为的例子；一个使用顺序处理功能<code class="fe md me mf mg b">map</code>、<code class="fe md me mf mg b">filter </code>和<code class="fe md me mf mg b">reduce</code>:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="ed2b" class="le lf it mg b gy mp mq l mr ms">(time (-&gt;&gt; (range 100000000)<br/>           (map #(* % 10))<br/>           (filter odd?)<br/>           (reduce *)))<br/>"Elapsed time: 3533.9617 msecs"</span></pre><p id="573b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过切换到这些函数的简化版本，我们可能会获得一些适度的性能提升。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b152" class="le lf it mg b gy mp mq l mr ms">(require '[clojure.core.reducers :as r])<br/>(time (-&gt;&gt; (range 100000000)<br/>           (r/map #(* % 10))<br/>           (r/filter odd?)<br/>           (r/reduce *)))<br/>"Elapsed time: 2966.89 msecs"</span></pre><p id="d043" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于勇敢和真实的人来说，Clojure中可能有更好的性能提升的例子，但是我想指出的要点是，上面的语法看起来很相似，并且获得了相同的结果。然而，我们基于序列的处理链中的<code class="fe md me mf mg b">map </code>和<code class="fe md me mf mg b">filter </code>步骤导致在每一步之后产生中间集合，而reducers不产生集合，而是在每一步返回一个<code class="fe md me mf mg b">reducable</code>。</p><p id="5ef6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把一个<code class="fe md me mf mg b">reducable</code>想象成一个食谱或者一套关于如何执行任务的指令。这很有帮助，因为<code class="fe md me mf mg b">reducables</code>可以很好地组合在一起，而不必实现每个中间步骤的输出。最后，当我们将可还原的值还原或折叠成最终值时，就产生了一个集合。</p><p id="c7ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想并行执行reducables，我们必须使用r/fold或r/foldcat和一个可折叠的集合(vector或map)。或者，我们可以只调用reduce或into(在内部调用reduce)来将reducables实现为一个集合。</p><p id="5384" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">reduce、r/reduce和r/fold的性能将取决于我们正在解决的特定问题，但一般原则是，使用reducer编写集合处理函数通常会使您的代码更具性能，尤其是在处理大型集合或计算密集型任务时。</p><h2 id="03ed" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">减速器的解剖</h2><p id="45b9" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Clojure的创建者Rich Hickey之前在一篇名为<a class="ae kf" href="https://clojure.org/news/2012/05/15/anatomy-of-reducer" rel="noopener ugc nofollow" target="_blank">Reduer剖析</a>的优秀文章中写过关于reducer的博客。我发现这个帖子真的很有趣，但是要完全掌握reducer库背后的思想仍然需要一点点的实验。</p><p id="f872" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在本教程的剩余部分，我们将通过提供一些相关的信息和示例，尝试遵循Rich Hickey在reducers及其工作方式背后的一些基本原理。为了从本教程中获得最大收益，你应该在此之后立即阅读Rich的文章，看看你是否能跟上。我的希望是，在两篇文章之间，我们应该能够填补一些空白，以解释reducers背后的一些核心思想和推导。毕竟，学习一个新思想或概念的最好方法是从许多不同的来源阅读它。</p><p id="801c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经尽了最大努力来解释和扩展Rich最初的想法，并提供了额外的见解，但我会添加一个小小的免责声明，这只是我的解释。Rich是一个聪明的家伙，对这个主题有着深刻的理解，所以Rich Hickey对x的看法的唯一来源最终应该是Rich Hickey。每当我在本文的其余部分提到Rich、他的想法或意图时，请记住这一点。</p><h2 id="4c20" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">那么，到底什么是减速器呢？</h2><p id="84b3" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在高层次上，reduce函数是一个接受两个参数并传递给名为reduce的函数的函数。reduce函数的行为由函数体本身决定，但reduce调用它的方式永远不会改变。我们的归约函数的第一个参数称为结果或累加器。它被称为<em class="mc">结果</em>,因为它通常包含最后一次归约调用的结果，当您对某种值求和或累加时，它也被称为<em class="mc">累加器</em>。</p><p id="5f56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是要减少的源的新输入值。reduce函数将为集合中的每一项调用该函数，直到返回最终结果或者集合中不再有项。</p><p id="ed79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看reduce的行为:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="63b6" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce (fn [result input] (println input)) [1 2 3 4 5])<br/>2<br/>3<br/>4<br/>5</span></pre><p id="9902" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果仔细观察这个输出，您会注意到集合中的第一项1没有作为输入参数传入。这是因为我们的归约函数应该被设计成从第一个元素开始，将两个或更多的元素归约为一个值。因此，如果我们没有传递要减少的初始化值，第一个元素最初总是作为结果传入，如下所示:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="8b2c" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce (fn [result input] (println result)) [1 2 3 4 5])<br/>1<br/>nil<br/>nil<br/>nil</span></pre><p id="dd45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以通过传入一个初始化值来改变这种行为，这样我们就可以遍历集合中的每一项:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="d62a" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce (fn [result input] (println input)) 0 [1 2 3 4 5])<br/>1<br/>2<br/>3<br/>4<br/>5<br/>=&gt; nil</span></pre><p id="58f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这些基本的例子中，我们可以看到我们的函数被调用了(n-1)次或n次，这取决于初始值。对于后续的调用，返回值将被填充上一次调用reducer的结果。如果我们从函数中返回一个值，我们可能会更清楚地看到这一点:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="a68f" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce (fn [result input] <br/>            (println result) <br/>            "apple") [1 2 3 4 5])<br/>1<br/>apple<br/>apple<br/>apple</span></pre><p id="09b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们让我们的减速器做一些更有用的事情:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="ca00" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce (fn [result input] <br/>            (println result) <br/>            (+ result input)) [1 2 3 4 5])<br/>;; It might be helpful to see the [result input] args:<br/>1  ;; args = [1 2], result = 3<br/>3  ;; args = [3 3], result = 6<br/>6  ;; args = [6 4], result = 10<br/>10 ;; args = [10 5], result = 15<br/>=&gt; 15</span></pre><p id="7324" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仔细想想，调用reduce的reduce函数有点傻。它一直以下面的模式用两个参数调用我们的reducer，直到我们的集合为空(或者返回一个<em class="mc"> reduced </em>集合):</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="e5ba" class="le lf it mg b gy mp mq l mr ms">[1 2] =&gt; result1<br/>[result1 3] =&gt; result2<br/>[result2 4] =&gt; result3<br/>[result3 5] =&gt; result4</span></pre><p id="0f5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，任何设计用来处理两个参数并返回值的函数都可以与reduce一起使用。例如，我们可以使用+或字符串:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="7e07" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce + [1 2 3 4 5])<br/>=&gt; 15<br/>&gt; (reduce str [1 2 3 4 5])<br/>=&gt; "12345"</span></pre><p id="9ef5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者我们可以在单个arity函数上使用&amp;运算符:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="6e80" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce (fn [&amp; args] (println "args =" args)) [1 2 3 4 5])<br/>args = (1 2)<br/>args = (nil 3)<br/>args = (nil 4)<br/>args = (nil 5)<br/>=&gt; nil</span></pre><p id="5733" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Reduce不仅适用于vectors，我们还可以将它用于map，从而减少每个键值MapEntry对:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b7cd" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce (fn [result input]<br/>          (println "[" result ", " input "]")) <br/>{:name "Frank" :surname "Sinatra" :age 67 :description "Artist"})</span><span id="6d71" class="le lf it mg b gy mt mq l mr ms">[ [:name Frank] ,  [:surname Sinatra] ]<br/>[ nil ,  [:age 67] ]<br/>[ nil ,  [:description Artist] ]</span></pre><p id="5822" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经牢牢掌握了reduce，我们还应该知道reducer如何通过显式调用<em class="mc"> reduced </em>来简化reducer:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="daff" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce (fn [result input]<br/>          (println "[" result "," input "]")<br/>          (if (= input 5)<br/>            (reduced "reduced")<br/>            (+ result input))) [1 2 3 4 5 6 7 8 9 10])<br/>[ 1 , 2 ]<br/>[ 3 , 3 ]<br/>[ 6 , 4 ]<br/>[ 10 , 5 ]<br/>=&gt; "reduced"</span></pre><p id="403f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于处理无限惰性序列特别有帮助，因为没有它，缩减永远不会结束！</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="60ee" class="le lf it mg b gy mp mq l mr ms">Try crashing your repl with:<br/>(reduce println (range))</span><span id="123f" class="le lf it mg b gy mt mq l mr ms">Or use reduce to terminate an infinite lazy-sequence reduction early:</span><span id="d071" class="le lf it mg b gy mt mq l mr ms">(reduce (fn [result input] <br/>   (if (&lt; input 5) <br/>       (println input)<br/>       (reduced "finished"))) (range))<br/>1<br/>2<br/>3<br/>4<br/>=&gt; "finished"</span></pre><p id="ed0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">写reducer的时候，我们也可以用reduced？fn来查看一个值是否已经在reduced函数中包装过。</p><h2 id="0401" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">转换减速器…</h2><p id="81b1" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在本文的第一部分中，我们已经看到了reduce如何使用一个简单的reduce函数，递归地应用它来转换一个集合。我们可能希望将许多不同类型的转换函数应用于数据集合，例如<code class="fe md me mf mg b">map </code>和<code class="fe md me mf mg b">filter</code>。酷的是，这些也可以被定义为减速器。</p><p id="0d3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经了解了什么是减速器，以及它是如何工作的，我们可以回到Rich Hickey的博客文章，来研究下一个想法:改造减速器。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="7dd5" class="le lf it mg b gy mp mq l mr ms">(xf reducing-fn) -&gt; reducing-fn</span></pre><p id="bf64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Rich在他的文章中告诉我们，转换reducer是reducer库中许多核心集合操作背后的概念。例如，他告诉我们想象一个新的高阶映射函数，它返回一个缩减器。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="e27e" class="le lf it mg b gy mp mq l mr ms">(defn mapping [f]<br/>  (fn [f1]<br/>    (fn [result input]<br/>      (f1 result (f input)))))</span></pre><p id="78c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们查看上面的映射函数，我们会注意到我们有一个函数<code class="fe md me mf mg b">f</code>，它对每个新输入进行操作，还有一个函数<code class="fe md me mf mg b">f1</code>，它对结果进行操作。请注意，高阶函数是如何根据函数定义的，并且不包含硬编码的映射函数。</p><p id="915c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们用它来创建一个函数，该函数增加每个输入并对结果求和:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="7b12" class="le lf it mg b gy mp mq l mr ms">(reduce ((mapping inc) +) 0 [1 2 3 4])</span></pre><p id="ddcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，<code class="fe md me mf mg b">f </code>是<code class="fe md me mf mg b">inc </code>函数，它将递增每个后续输入，<code class="fe md me mf mg b">f1 </code>是我们的<code class="fe md me mf mg b">+</code>操作符，它将结果值添加到我们现有的结果中。如果你以前没有用过高阶函数，那么试着把它分解一下，以理解它是如何工作的。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="940e" class="le lf it mg b gy mp mq l mr ms">;; Our main format is<br/>(reduce reducer-fn initial-value coll)</span><span id="d6dd" class="le lf it mg b gy mt mq l mr ms">;; When we call <!-- -->(mapping inc) we get back a new function:<br/>(fn [f1]<br/>    (fn [result input]<br/>      (f1 result (inc input))))<br/>;; When we call ((mapping inc) +), we pass + into our previous function to give our final reducer function:<br/>    (fn [result input]<br/>      (+ result (inc input))</span></pre><p id="f20e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将其与之前的reduce示例进行比较，我们可以看到，我们已经用对<code class="fe md me mf mg b">mapping </code>的调用消除了对<em class="mc"> map </em>的显式调用，我们的函数只包含+和inc操作。该逻辑也不包括任何集合或顺序的概念。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="ed40" class="le lf it mg b gy mp mq l mr ms">;; Previous form<br/>(reduce + 0 (map inc [1 2 3 4]))<br/>;; new form<br/>(reduce ((mapping inc) +) 0 [1 2 3 4])</span></pre><p id="87d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这可能看起来不太令人印象深刻，但是通过使用我们的高阶映射函数返回一个reducer并对每个输入应用一个转换，我们可以将收集的数据与转换分开。我们也可以对返回reducers的其他高阶函数使用相同的模式，例如:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="e36e" class="le lf it mg b gy mp mq l mr ms">(reduce ((my-filtering even?) +) 0 [1 2 3 4])</span></pre><p id="1eb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意我们的<code class="fe md me mf mg b">mapping </code>和<code class="fe md me mf mg b">my-filtering </code>函数是如何与收集数据本身分离的。</p><p id="1682" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个改进，但是<code class="fe md me mf mg b">((mapping inc) +)</code>语法有点笨拙，我们的reducer生成函数作为第一个参数出现。如果我们想使用最后线程操作符<code class="fe md me mf mg b">-&gt;&gt;</code>将这些线程连接在一起，这将是一个问题。</p><p id="a1aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Rich还指出这有点奇怪，因为我们操作的是reducing操作，而不是collection操作。在我们的序列处理世界<code class="fe md me mf mg b">map</code>、<code class="fe md me mf mg b">filter </code>等中，我们习惯于对集合进行操作——所以我们需要以某种方式修改东西，以便我们的转换函数也对集合起作用，而不仅仅是对归约函数起作用。</p><p id="6a99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，Rich包含了一个名为<code class="fe md me mf mg b">reducer </code>的额外函数，它减少了集合并应用了一个转换函数xf。</p><p id="1f37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，为了理解<code class="fe md me mf mg b">reducer</code>中发生了什么，让我们快速看一下<code class="fe md me mf mg b">clojure.core.reducers.</code>中的<code class="fe md me mf mg b">reduce </code>函数</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="62dc" class="le lf it mg b gy mp mq l mr ms">(defn reduce<br/>"Like core/reduce except:                           <br/>  When init is not provided, (f) is used. <br/>  Maps are reduced with reduce-kv"     <br/>([f coll] (reduce f (f) coll))                         <br/>([f init coll]                            <br/>  (if (instance? java.util.Map coll)<br/>    (clojure.core.protocols/kv-reduce coll f init)<br/>    (clojure.core.protocols/coll-reduce coll f init))))</span></pre><p id="2ef7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将看到reduce最终调用<code class="fe md me mf mg b">kv-reduce</code>(对于地图)或<code class="fe md me mf mg b">coll-reduce</code>来减少集合。这些辅助函数基本上执行不同类型的归约。</p><p id="c88d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们检查来自clojure.core.protocols的CollReduce协议:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="e29d" class="le lf it mg b gy mp mq l mr ms">(defprotocol CollReduce                         <br/>"Protocol for collection types that can implement reduce faster than                         first/next recursion. Called by clojure.core/reduce. Baseline                         implementation defined in terms of Iterable."                         (coll-reduce [coll f] [coll f val]))</span></pre><p id="feff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从CollReduce协议的定义中看到，它为不同的类型提供了比第一次/下一次递归更快的归约方式，在clojure.core.protocols文件中，我们可以看到CollReduce的定义扩展到了类似于<code class="fe md me mf mg b">Objects</code>、<code class="fe md me mf mg b">LazySeq</code>和<code class="fe md me mf mg b">PersistentVector</code>的东西。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="040b" class="le lf it mg b gy mp mq l mr ms">;; n.b Some extensions of CollReduce are hidden for brevity<br/>(extend-protocol CollReduce <br/> nil <br/> (coll-reduce <br/>   ([coll f] (f)) <br/>   ([coll f val] val))</span><span id="78d0" class="le lf it mg b gy mt mq l mr ms">Object <br/> (coll-reduce <br/>    ([coll f] (seq-reduce coll f))<br/>    ([coll f val] (seq-reduce coll f val)))</span><span id="4cec" class="le lf it mg b gy mt mq l mr ms">;;for range                        <br/> clojure.lang.LazySeq                     <br/>   (coll-reduce                          <br/>      ([coll f] (seq-reduce coll f))    <br/>      ([coll f val] (seq-reduce coll f val)))</span><span id="b250" class="le lf it mg b gy mt mq l mr ms">;;vector's chunked seq is faster than its iter                         clojure.lang.PersistentVector                         <br/>  (coll-reduce                         <br/>     ([coll f] (seq-reduce coll f))                          <br/>     ([coll f val] (seq-reduce coll f val)))</span></pre><p id="3004" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们再来看看Rich介绍的新减速器功能:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="6e26" class="le lf it mg b gy mp mq l mr ms">(defn reducer                         <br/>"Given a reducible collection, and a transformation function xf,                         returns a reducible collection, where any supplied reducing                         fn will be transformed by xf. xf is a function of reducing fn to                         reducing fn."                         <br/>{:added "1.5"}                        <br/> ([coll xf]                           <br/>    (reify <br/>      clojure.core.protocols/CollReduce<br/>      (coll-reduce [this f1]<br/>         (clojure.core.protocols/coll-reduce this f1 (f1)))<br/>      (coll-reduce [_ f1 init]<br/>         (clojure.core.protocols/coll-reduce coll (xf f1) init)))))</span></pre><p id="0fbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">敏锐的观察者可能会注意到，<code class="fe md me mf mg b">reducer </code>函数包含对<code class="fe md me mf mg b">coll-reduce</code>的调用，就像我们最初的<code class="fe md me mf mg b">reduce </code>函数一样。您还会看到，在调用<code class="fe md me mf mg b">coll-reduce</code>之前，转换函数<code class="fe md me mf mg b">xf </code>被应用于缩减函数。</p><p id="f993" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个<code class="fe md me mf mg b">reducer </code> fn现在可以和我们的映射函数一起使用，返回一个应用了适当变换的reducer:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="2341" class="le lf it mg b gy mp mq l mr ms">(reduce + 0 (reducer [1 2 3 4] (mapping inc)))</span></pre><p id="2fd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，reducer将接受一个集合<em class="mc"> coll </em>和一个转换函数<em class="mc"> xf </em>，并返回一个为reduce函数提供数据的<em class="mc"> reducer </em>。这看起来像是更多的工作，但是它给了我们轻松链接reducers的能力，我们有了操作集合而不是reducing函数本身的语法。这对于保持良好的解耦非常重要。</p><p id="58a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们已经通过在调用reduce之前对集合本身执行reducing转换，有效地预处理了集合。如果你仔细观察，你会发现我们在一个reducing函数+上调用reduce，我们的转换结果(<code class="fe md me mf mg b">mapping</code>)在我们的集合上减少了。这也是有益的，因为这意味着我们可以改变我们的减速器的工作方式，而不必修改任何其他的减速功能变压器。</p><p id="ca9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看是否可以通过修改我们的reducer和映射函数来理解我们的函数是如何工作的，以便在调用它们时打印一些调试输出。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="4314" class="le lf it mg b gy mp mq l mr ms">(require '[clojure.core.reducers :as r])<br/>(require '[clojure.core.protocols :as p])</span><span id="17ac" class="le lf it mg b gy mt mq l mr ms">(defn my-reducer<br/>  "Given a reducible collection, and a transformation function xf,<br/>  returns a reducible collection, where any supplied reducing<br/>  fn will be transformed by xf. xf is a function of reducing fn to<br/>  reducing fn."<br/>  ([coll xf]<br/>   (println "my-reducer: called with coll " (str coll))<br/>   (reify<br/>     clojure.core.protocols/CollReduce<br/>     (p/coll-reduce [this f1]<br/>         (clojure.core.protocols/coll-reduce this f1 (f1)))<br/>     (p/coll-reduce [_ f1 init]<br/>       (clojure.core.protocols/coll-reduce coll (xf f1) init)))))<br/><br/>(defn my-mapping [f]<br/>  (fn [f1]<br/>    (fn [result input]<br/>      (println "my-mapping: calling f1 on the result and f on our input for [" (str result) "," (str input)"]")<br/>      (f1 result (f input)))))</span></pre><p id="b61a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们现在像Rich Hickey的例子一样使用自定义映射和reduce函数，那么我们应该能够看到正在发生的事情:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b5fa" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce + 0 (my-reducer [1 2 3 4] (my-mapping inc)))<br/>my-reducer: called with coll  [1 2 3 4]<br/>my-mapping: calling f1 on the result and f on our input for [0,1]<br/>my-mapping: calling f1 on the result and f on our input for [2,2]<br/>my-mapping: calling f1 on the result and f on our input for [5,3]<br/>my-mapping: calling f1 on the result and f on our input for [9,4]<br/>=&gt; 14</span></pre><p id="b33b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对my-mapping的每次调用都将inc应用于每个输入，然后将它添加到上一次调用的结果中。所以我们得到:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="7421" class="le lf it mg b gy mp mq l mr ms">[0, 1] =&gt; (+ 0 (inc 1)) == 2<br/>[2, 2] =&gt; (+ 2 (inc 2)) == 5<br/>[5, 3] =&gt; (+ 5 (inc 3)) == 9<br/>[0, 4] =&gt; (+ 9 (inc 4)) == 14</span></pre><p id="b6f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般模式如下:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="9ec1" class="le lf it mg b gy mp mq l mr ms">(reduce f init coll)<br/>f - The function that takes two inputs [result input] and produces the result for each step in the result<br/>init - The initial result value<br/>coll - The collection to reduce</span><span id="09ce" class="le lf it mg b gy mt mq l mr ms">With our reducer function, we are calling:<br/>(reducer coll f)<br/>f - The function which will reduce over the collection coll<br/>coll - The collection to operate on</span></pre><p id="175e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在迄今为止的例子中，我们一直使用映射函数通过<code class="fe md me mf mg b">reducer</code>来转换我们的集合。但是我们也可以使用任何其他的reducer转换，只要它返回一个reducer函数。</p><p id="98d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Rich的例子中，我们可以看到如何用不同的函数调用reducer来生成不同的转换。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b2c4" class="le lf it mg b gy mp mq l mr ms">(defn rmap [f coll]<br/>  (reducer coll (mapping f)))<br/><br/>(defn rfilter [pred coll]<br/>  (reducer coll (filtering pred)))<br/><br/>(defn rmapcat [f coll]<br/>  (reducer coll (mapcatting f)))</span></pre><p id="52ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们来看看过滤:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="dd89" class="le lf it mg b gy mp mq l mr ms">(defn my-filtering [pred]<br/>  (println "my-filtering called with predicate " (str pred))<br/>  (fn [f1]<br/>    (fn [result input]<br/>      (println "my-filtering now operating on [result, input] [" (str result)"," (str input)"]")<br/>      (if (pred input)<br/>        (f1 result input)<br/>        result))))</span></pre><p id="4712" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们用my-filtering替换my-mapping fn，我们可以看到我们的过滤函数是如何工作的:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="07d2" class="le lf it mg b gy mp mq l mr ms">&gt; (reduce + 0 (my-reducer [1 2 3 4] (my-filtering even?)))<br/>my-filtering called with predicate  clojure.core$even_QMARK_@61dc54a9<br/>my-reducer: called with coll  [1 2 3 4 5 6]<br/>my-filtering now operating on [result, input] [ 0 , 1 ]<br/>my-filtering now operating on [result, input] [ 0 , 2 ]<br/>my-filtering now operating on [result, input] [ 2 , 3 ]<br/>my-filtering now operating on [result, input] [ 2 , 4 ]<br/>my-filtering now operating on [result, input] [ 6 , 5 ]<br/>my-filtering now operating on [result, input] [ 6 , 6 ]</span></pre><p id="32ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看这个例子我们可以看到。应用于每个输入，如果为真，则修改结果。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b5e8" class="le lf it mg b gy mp mq l mr ms">[0, 1] =&gt; (even? 1) == false, so return result 0<br/>[0, 2] =&gt; (even? 2) == true, so return (+ result 2) = 2<br/>[2, 3] =&gt; (even? 3) == false, so return result 2<br/>[2, 4] =&gt; (even? 4) == true, so return (+ result 4) = 6<br/>[6, 5] =&gt; (even? 5) == false, so return result<br/>[6, 6] =&gt; (even? 6) == true, so return (+ result 6) = 12</span></pre><p id="8c42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">酷，所以我们的reducer函数my-reducer与map和filter操作一起工作，返回一个由f:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="4489" class="le lf it mg b gy mp mq l mr ms">(my-reducer coll f)<br/>(my-reducer [1 2 3 4 5 6] (my-mapping inc))<br/>(my-reducer [1 2 3 4 5 6] (my-filtering even?))</span></pre><p id="e22f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有趣的是，我们可以通过使用另一个my-reducer调用来代替coll:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="0aa0" class="le lf it mg b gy mp mq l mr ms">(reduce + 0 <br/>  (my-reducer <br/>    (my-reducer [1 2 3 4 5 6] <br/>       (my-filtering even?))<br/>  (my-mapping inc)))</span><span id="f773" class="le lf it mg b gy mt mq l mr ms">(reduce + 0 (my-reducer (my-reducer [1 2 3 4 5 6] (my-filtering even?)) (my-mapping inc)))</span><span id="83ac" class="le lf it mg b gy mt mq l mr ms">my-filtering called with predicate  clojure.core$even_QMARK_@61dc54a9<br/>my-reducer: called with coll  [1 2 3 4 5 6]<br/>my-reducer: called with coll  app.core$my_reducer$reify__2320@263c9337<br/>my-filtering now operating on [result, input] [0 , 1]<br/>my-filtering now operating on [result, input] [0 , 2]<br/>my-mapping: calling f1 on the result and f on our input for [0 , 2]<br/>my-filtering now operating on [result, input] [3 , 3]<br/>my-filtering now operating on [result, input] [3 , 4]<br/>my-mapping: calling f1 on the result and f on our input for [3 , 4]<br/>my-filtering now operating on [result, input] [8 , 5]<br/>my-filtering now operating on [result, input] [8 , 6]<br/>my-mapping: calling f1 on the result and f on our input for [8 , 6]<br/>=&gt; 15</span></pre><p id="9363" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还记得我们的线程宏吗？</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b834" class="le lf it mg b gy mp mq l mr ms">(reduce + 0 (-&gt; [1 2 3 4 5 6]                <br/>                (reducer (my-filtering even?))<br/>                (reducer (my-mapping inc))))</span></pre><p id="7634" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是可行的，但是当我们使用集合时，如果我们能使用thread-last会更好。让我们定义一些助手函数:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="58b5" class="le lf it mg b gy mp mq l mr ms">(defn rmap [f coll]<br/>  (my-reducer coll (my-mapping f)))<br/><br/>(defn rfilter [pred coll]<br/>  (my-reducer coll (my-filtering pred)))</span></pre><p id="349c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">酷，现在我们可以这样做了:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="dbb6" class="le lf it mg b gy mp mq l mr ms">(reduce + 0 (-&gt;&gt; [1 2 3 4 5 6]<br/>                 (rfilter even?)<br/>                 (rmap inc)))</span><span id="439d" class="le lf it mg b gy mt mq l mr ms">my-filtering called with predicate  clojure.core$even_QMARK_@61dc54a9<br/>my-reducer: called with coll  [1 2 3 4 5 6]<br/>my-reducer: called with coll  app.core$my_reducer$reify__2320@47376c50<br/>my-filtering now operating on [result, input] [0 , 1]<br/>my-filtering now operating on [result, input] [0 , 2]<br/>my-mapping: calling f1 on the result and f on our input for [0 , 2]<br/>my-filtering now operating on [result, input] [3 , 3]<br/>my-filtering now operating on [result, input] [3 , 4]<br/>my-mapping: calling f1 on the result and f on our input for [3 , 4]<br/>my-filtering now operating on [result, input] [8 , 5]<br/>my-filtering now operating on [result, input] [8 , 6]<br/>my-mapping: calling f1 on the result and f on our input for [8 , 6]<br/>=&gt; 15</span></pre><p id="1156" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是怎么回事？使用这些基于reducer的函数，我们获得了一些很好的性质。</p><ul class=""><li id="59d1" class="mu mv it ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated">我们得到了与地图、过滤函数相同的基本行为</li><li id="ab47" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">高阶助手函数抽象出了实现细节，因此我们的函数参数只需要基本操作</li><li id="df9e" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">我们现在可以将这些转换串联起来</li><li id="1450" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">我们最终要求我们正在处理的集合减少它们自己，所以我们的转换减少器不需要知道关于它们的任何事情</li><li id="d2c2" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">没有中间集合，一切都是一个缩减，reducer将与任何缩减函数转换器一起工作</li><li id="b7a3" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">我们现在可以利用使用r/fold的并行处理，这是我们的转换操作现在使用的默认方法，除非我们需要顺序处理，例如take。</li><li id="a708" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">我们的代码现在具有与基于seq的函数相似的语义，例如<code class="fe md me mf mg b">(reduce + 0 (rmap inc [1 2 3 4]))</code></li></ul><blockquote class="ni nj nk"><p id="1bcf" class="kg kh mc ki b kj kk kl km kn ko kp kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated">多种多样的集合转换可以被表示为缩减函数转换，并且跨多种多样的数据结构应用于顺序和并行上下文中。—里奇·希基</p></blockquote><h2 id="659f" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">我们什么时候应该使用Reducer转换？</h2><p id="bd5b" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">一个很好的经验是，当您有可以从并行化中获益的转换时，考虑使用基于reducer的转换操作。请记住，它们可以帮助您节省内存，并且在处理大型集合或进行大量复杂的计算密集型处理时可以快几个数量级。</p><p id="fcb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">序列转换和基于reducer的转换之间的一个很大的区别是序列转换通常是延迟应用的，所以这也可能成为您决策的一个因素。</p><p id="e75e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">有用资源:</strong></p><div class="no np gp gr nq nr"><a href="https://clojure.org/news/2012/05/15/anatomy-of-reducer" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">减速器的解剖</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">虽然寻找另一种定义核心集合操作的基本方法是一项有趣的工作，但最终…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">clojure.org</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jz nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://www.braveclojure.com/quests/reducers/know-your-reducers/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">了解你的减压器</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">您已经看到，在大多数情况下，您可以像seq函数一样使用reducers。例如，这会产生相同的…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">www.braveclojure.com</p></div></div></div></a></div><div class="no np gp gr nq nr"><a href="https://medium.com/formcept/performance-optimization-in-clojure-using-reducers-and-transducers-a-formcept-exclusive-375955673547" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">使用减速器和传感器优化Clojure的性能——form cept独有</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">为什么是减速器</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of jz nr"/></div></div></a></div></div></div>    
</body>
</html>