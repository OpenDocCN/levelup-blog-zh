<html>
<head>
<title>Improving Minimax performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Minimax性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improving-minimax-performance-fc82bc337dfd?source=collection_archive---------8-----------------------#2021-11-30">https://levelup.gitconnected.com/improving-minimax-performance-fc82bc337dfd?source=collection_archive---------8-----------------------#2021-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5bfab17b36385a1d5ab1e3c9a9e375b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ap3pewgrJb43PdnRFvUhLQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/photos/HUJDz6CJEaM" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/HUJDz6CJEaM</a></figcaption></figure><p id="f62c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Minimax" rel="noopener ugc nofollow" target="_blank"> Minimax </a>算法，也称为MinMax，是一种流行的算法，用于计算玩家在零和游戏(如井字游戏或国际象棋)中的最佳可能棋步。它利用开发者提供的评估函数来分析给定的游戏板。在执行过程中，Minimax会构建一个可能会变得很大的博弈树。这导致算法的运行时间非常长。</p><p id="e465" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将介绍10种方法来提高极大极小算法的性能并优化其运行时间。有些影响较大，有些影响较小。将来我会尝试添加新的方法。关于算法是如何工作的，我就不多说了。只是优化一下而已。查看上面的链接，了解算法实际上是如何工作的。</p><p id="b622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文中讨论的所有技术的快速概述:</p><ol class=""><li id="43d6" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">阿尔法-贝塔剪枝</li><li id="9e95" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">预分类移动</li><li id="f307" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">比特板</li><li id="911a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">换位表</li><li id="b5c2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">棋盘对称性</li><li id="91e9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">减少可能的移动</li><li id="a50d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">即时获胜</li><li id="cb58" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">提高。hasPlayerWon()函数</li><li id="35f6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">提高。evaluate()函数</li><li id="1e89" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">降低搜索深度</li></ol><h1 id="69f9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">1.阿尔法-贝塔剪枝</h1><p id="8a1d" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">最广为人知的改进之一是<a class="ae kc" href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning" rel="noopener ugc nofollow" target="_blank">阿尔法-贝塔修剪</a>，也被称为阿尔法-贝塔切割或阿尔法-贝塔搜索。这个稍加修改的Minimax版本可以大幅减少算法的运行时间。这里的关键思想是通过删除来减少游戏树中的节点数量。因此，沿着树传递两个值α和β。这些值代表了每个玩家的最坏情况。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/ab0424cb11115f7acc545217a7e9ec04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8NwqslREd8EFnAf-PHgGA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning#/media/File:AB_pruning.svg" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Alpha % E2 % 80% 93 beta _ pruning #/media/File:AB _ pruning . SVG</a></figcaption></figure><p id="1a09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看一下第二排(<code class="fe mx my mz na b">3 6 3</code>)。这里的α值是6，这是对前两个节点(<code class="fe mx my mz na b">3 6</code>)进行评估后<code class="fe mx my mz na b">MAX</code>将达到的最低分数。在评估第三个节点<code class="fe mx my mz na b">MIN</code>时，请记住<code class="fe mx my mz na b">MAX</code>至少会获得<code class="fe mx my mz na b">6</code>的分数。如果<code class="fe mx my mz na b">MIN</code>找到小于α的值，这里是<code class="fe mx my mz na b">5</code>，则另一个节点<code class="fe mx my mz na b">8</code>可以被切断。原因:无论<code class="fe mx my mz na b">MIN</code>选择什么，<code class="fe mx my mz na b">MAX</code>都会选择α值<code class="fe mx my mz na b">6</code>。而<code class="fe mx my mz na b">MIN</code>会选择一个肯定是&lt; = <code class="fe mx my mz na b">5</code>的值。</p><p id="d92d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更详细的解释请看上面的链接。</p><h1 id="b1f0" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.预分类移动</h1><p id="a899" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">当使用Alpha-Beta修剪时，尝试从最好的移动开始对可能的移动列表进行预排序。在这种情况下，有更高的机会在游戏树中切割节点，因为算法在每一关开始时以高alpha值或低beta值开始。</p><h1 id="3ba3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">3.比特板</h1><p id="b5b7" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Bitboard" rel="noopener ugc nofollow" target="_blank"> Bitboards </a>是一种用比特表示游戏棋盘的方式。在这种情况下，每一位代表棋盘上的一个位置。而且，两个玩家都有自己的棋盘。</p><p id="d6e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">井字游戏的位棋盘示例:</p><pre class="mt mu mv mw gt nb na nc bn nd ne bi"><span id="fde5" class="nf lq iq na b be ng nh l ni nj">const board = [<br/>    0b000_000_000,  // Player 1 Board (X)<br/>    0b000_000_000   // Player 2 Board (O)<br/>]</span></pre><p id="b8c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">bitboards的一个主要优势是它们允许在评估中有很大的灵活性。使用像<code class="fe mx my mz na b">AND</code>、<code class="fe mx my mz na b">OR</code>、<code class="fe mx my mz na b">XOR</code>和short这样的按位操作，你可以在很短的时间内检查获胜条件、玩&amp;验证移动或旋转游戏板。它们对于计算用于转置表的电路板散列也很有用。</p><p id="63e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据游戏的复杂程度，bitboards可能会在性能方面产生显著的差异。查看此<a class="ae kc" href="https://github.com/denkspuren/BitboardC4/blob/master/BitboardDesign.md" rel="noopener ugc nofollow" target="_blank">链接</a>以查看使用bitboards的Connect Four实现。</p><h1 id="66f1" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">4.换位表</h1><p id="a67a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Transposition_table" rel="noopener ugc nofollow" target="_blank">转置表</a>用于存储已经分析过的板卡的结果。这可防止算法多次评估同一块电路板，并从存储器(转置表)中读取。</p><p id="ffb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，转置表被实现为一个<code class="fe mx my mz na b">HashMap</code>,其中的关键字是散列板。您可以将转置表存储在内存中，并在Minimax执行期间构建它，或者将其存储在非易失性内存中，例如文本文件。</p><p id="68ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转置表可能如下所示:</p><pre class="mt mu mv mw gt nb na nk nl aw nm bi"><span id="85b5" class="nn lq iq na b gy no np l nq nj">8063104835353205054 2 -8534.0 -1<br/>3522504971336218492 1 1082.0 -1<br/>9207316698546002515 5 2705.0 1</span></pre><p id="01b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每行包含以下信息:</p><ul class=""><li id="9325" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nr lh li lj bi translated">董事会杂凑</li><li id="f25c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated">玩过的招式</li><li id="75e2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated">移动的评估分数</li><li id="e635" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated">移动的玩家</li></ul><p id="478b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Minimax中，你可以在转置表中搜索当前的棋盘散列，并返回相应的条目。</p><pre class="mt mu mv mw gt nb na nc bn nd ne bi"><span id="4106" class="nf lq iq na b be ng nh l ni nj">function minimax(storage, game) {<br/>    // recursion anchor ...<br/><br/>    const storedMove = storage.get(game.calcBoardHash());<br/>    if(storedMove) return storedMove;<br/><br/>    // evaluation ...<br/>}</span></pre><p id="8068" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果未找到条目，则必须首先评估电路板。在极小极大结束时，您可以在评估的移动返回之前将其推送到换位表:</p><pre class="mt mu mv mw gt nb na nc bn nd ne bi"><span id="c56c" class="nf lq iq na b be ng nh l ni nj">function minimax(storage, game) {<br/>    const bestMove; // evaluation ...<br/>    storage.set(game.calcBoardHash(), bestMove);<br/>    return bestMove;<br/>}</span></pre><h1 id="4bf9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">5.棋盘对称性</h1><p id="a10d" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">关键的想法是，你把一个对称应用到你当前检查的电路板上，并从内存中读取它的对应物，如果存在的话。这极大地减少了董事会评估的次数。对称是非常强大的，尤其是在与比特板结合的时候。</p><p id="2504" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据你的游戏，你可以利用不同的对称。例如:</p><ul class=""><li id="58e7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nr lh li lj bi translated">翻转电路板</li><li id="ce88" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated">旋转棋盘(并反转)= &gt;井字游戏，旋转</li><li id="4def" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated">在x/y轴上镜像棋盘(并反转)= &gt;连接四个棋子</li></ul><p id="33b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Bitboards，您可以使用二进制操作轻松旋转和镜像电路板。看看这个GitHub Gist，看看Kotlin中的井字游戏。</p><h2 id="d1e2" class="nn lq iq bd lr ns nt dn lv nu nv dp lz ko nw nx md ks ny nz mh kw oa ob ml oc bi translated">翻转电路板</h2><p id="6eb0" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">井字游戏</p><pre class="mt mu mv mw gt nb na nk nl aw nm bi"><span id="7fef" class="nn lq iq na b gy no np l nq nj">1)          2)<br/><br/>X . .       O . .<br/>X O O       O X X<br/>. . .       . . .</span></pre><p id="6daf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一个场景中，玩家<code class="fe mx my mz na b">X</code>的最佳选择是占据位置<code class="fe mx my mz na b">7</code>(左下角)。第二种情况同样适用于玩家<code class="fe mx my mz na b">O</code>。如果Minimax已经计算出了棋盘#1的最佳可能移动，并将其存储在转置表中，您可以在棋盘#2的情况下反转棋盘，得到棋盘#1，并从内存中读取并应用棋盘#1的最佳可能移动。请记住，这只适用于第二局的玩家<code class="fe mx my mz na b">O</code>。</p><h2 id="89f0" class="nn lq iq bd lr ns nt dn lv nu nv dp lz ko nw nx md ks ny nz mh kw oa ob ml oc bi translated">旋转棋盘</h2><p id="ca0d" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">井字游戏</p><pre class="mt mu mv mw gt nb na nk nl aw nm bi"><span id="dda9" class="nn lq iq na b gy no np l nq nj">1)          2)<br/><br/>X . .       . X X<br/>X O O       . O .<br/>. . .       . O .</span></pre><p id="6853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，玩家<code class="fe mx my mz na b">X</code>的最佳行动是在第一个场景中选择位置<code class="fe mx my mz na b">7</code>。第二块板与第一块板相同，但顺时针旋转了90°。这一次，如果Minimax已经评估了棋盘#1，您可以将棋盘#2旋转90 °,这将得到棋盘#1，并再次从内存中读取棋盘#1的最佳可能移动。在这种情况下，你必须稍微修改一下走法:因为棋盘顺时针旋转了90度，所以你必须逆时针旋转90度。对180°和270°重复此程序。</p><p id="a2b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且，你可以把这个方法和上面的倒板结合起来。</p><h2 id="6291" class="nn lq iq bd lr ns nt dn lv nu nv dp lz ko nw nx md ks ny nz mh kw oa ob ml oc bi translated">镜像电路板</h2><p id="1f18" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">连接四个</p><pre class="mt mu mv mw gt nb na nk nl aw nm bi"><span id="04a1" class="nn lq iq na b gy no np l nq nj">1)                  2)<br/><br/>. . . . . . .       . . . . . . .<br/>. . . . . . .       . . . . . . .<br/>. . . . . . .       . . . . . . .<br/>. X . . . . .       . . . . . X .<br/>. X . O O . .       . . O O . X .<br/>. X O X O . .       . . O X O X .</span></pre><p id="79b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，玩家<code class="fe mx my mz na b">X</code>的最佳行动是在第一个场景中玩列<code class="fe mx my mz na b">2</code>。第二块板与第一块板相同，但镜像在中心y轴上。这一次，在评估了棋盘#1之后，你可以镜像给你棋盘#1的棋盘#2，并应用它的最佳移动。别忘了也要模仿这个动作。</p><p id="06a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再一次，你可以把这种技术和翻转板结合起来。</p><h1 id="60c0" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">6.减少可能的移动</h1><p id="2214" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">请记住，每次移动都会产生一个新的子节点，必须对其进行递归计算。因此，很简单:每个棋盘可能的走法越少，游戏树中的节点和评估就越少。这意味着:删除不必要的和不相关的举动。例如，在连四中，不要玩任何肯定不会在未来导致连续4的移动。小心不要移动任何可能阻止对手获胜的移动。</p><h1 id="d17c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">7.即时获胜</h1><p id="62b8" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在评估所有可能的移动之前，您可以检查其中是否有任何一个会为当前玩家带来即时胜利。如果是这样的话，你可以直接退回这步棋，而不必评估其他的棋。</p><pre class="mt mu mv mw gt nb na nc bn nd ne bi"><span id="f9ea" class="nf lq iq na b be ng nh l ni nj">function minimax(game) {<br/>    // recursion anchor ...<br/><br/>    for(const move of game.getPossibleMoves())<br/>        if(game.doMove(move).hasPlayerWon(game.currentPlayer))<br/>            return [1_000_000, move];<br/><br/>    // evaluation ...<br/>}</span></pre><p id="977c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，确保返回一个高分，因为这是一个双赢的举动。</p><h1 id="18bf" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">8.提高。hasPlayerWon()函数</h1><p id="71b8" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated"><code class="fe mx my mz na b">.hasPlayerWon()</code>功能检查玩家是否获胜。当评估游戏板时，它通常用于递归锚点。在这里，我们可以优化两件事:</p><ol class=""><li id="a1e6" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">在可能赢之前不要过牌</li><li id="e178" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">不要同时检查两个玩家</li></ol><pre class="mt mu mv mw gt nb na nc bn nd ne bi"><span id="15ad" class="nf lq iq na b be ng nh l ni nj">game.hasPlayerWon = function(player) {<br/>    if(this.playedMoves &lt; 5) return false;<br/>    // check if the given player has won ...<br/>}</span></pre><p id="a804" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在井字游戏中，玩家至少要走5步才能赢。这就是为什么当少于5步棋时，我们立即返回<code class="fe mx my mz na b">false</code>。</p><p id="d8a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们只需要检查一个玩家是否赢了，而不是两个都赢。下最后一步棋的玩家是唯一可能赢的人，所以我们不必检查另一个。</p><pre class="mt mu mv mw gt nb na nc bn nd ne bi"><span id="9c4d" class="nf lq iq na b be ng nh l ni nj">function minimax(nodeHeight, game) {<br/>    // recursion anchor<br/>    if (<br/>         nodeHeight == 0 ||<br/>         game.isDraw() ||<br/>         game.hasPlayerWon(-game.currentPlayer)<br/>    )<br/>        return [game.evaluate(), null];<br/>    // ...<br/>}</span></pre><p id="525a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，当调用<code class="fe mx my mz na b">game.hasPlayerWon()</code>时，我们检查前一个玩家(下最后一步棋的那个)是否已经赢了。如果玩家A被存储为<code class="fe mx my mz na b">1</code>而玩家B被存储为<code class="fe mx my mz na b">-1</code>，你可以很容易地在它们之间切换。</p><h1 id="83af" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">9.提高。evaluate()函数</h1><p id="087a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在Minimax的执行过程中，评估函数被调用了很多次。那就是说:改进这个功能，让它尽可能快。将它与Bitboards结合起来，快速检查玩家的获胜情况。</p><p id="7310" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果您的评估函数返回的分数很好地反映了棋盘，则没有必要深入博弈树。仅仅是游戏树中的一个下降就可以导致更长的运行时间。</p><p id="8c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个提示:在评估分数中包含当前节点高度。在游戏树中位置较高的棋会有更好的分数，算法会选择最快获胜的棋。</p><pre class="mt mu mv mw gt nb na nc bn nd ne bi"><span id="d15e" class="nf lq iq na b be ng nh l ni nj">game.evaluate = function(nodeHeight) {<br/>    const score; // calc score ...<br/>    return score + nodeHeight;<br/>}<br/><br/>function minimax(nodeHeight, game) {<br/>    // recursion anchor<br/>    if (<br/>         nodeHeight == 0 ||<br/>         game.isDraw() ||<br/>         game.hasPlayerWon(-game.currentPlayer)<br/>    )<br/>        return [game.evaluate(nodeHeight), null];<br/>    // evaluation ...<br/>}</span></pre><h1 id="f3a8" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">10.降低搜索深度</h1><p id="a28c" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">最后一个选项可能是最明显的:减少算法的最大搜索深度。你的游戏树真的有那么深吗？你必须向前看9或10步吗？提前5分钟还不够吗？根据游戏的不同，我猜大多数人类玩家最多只能预测3到4步。正如我上面已经说过的，每一个单独的树级都会导致更长的运行时间。想想吧。</p><h1 id="353d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">更多资源</h1><p id="4d3f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">最后但并非最不重要的一个列表，其中包含一些有用的资源。</p><ul class=""><li id="ecf8" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nr lh li lj bi translated">我们的博客:<a class="ae kc" href="https://blog.theofekfoundation.org/artificial-intelligence/2015/12/18/minimax-improvements/" rel="noopener ugc nofollow" target="_blank">极大极小改进</a></li><li id="6a81" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated">棋盘编程:<a class="ae kc" href="https://www.chessprogramming.org/Bitboards" rel="noopener ugc nofollow" target="_blank">棋盘</a></li><li id="9128" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated">维基百科:<a class="ae kc" href="https://en.wikipedia.org/wiki/Transposition_table" rel="noopener ugc nofollow" target="_blank">换位表</a></li></ul><p id="7e33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请查看我的示例项目:</p><ul class=""><li id="de82" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nr lh li lj bi translated"><a class="ae kc" href="https://github.com/larswaechter/connect-four-kotlin" rel="noopener ugc nofollow" target="_blank">连接科特林的四个</a></li><li id="a81f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated"><a class="ae kc" href="https://gist.github.com/larswaechter/9426ac46cfea79cc8ca5f06f0ca6f486" rel="noopener ugc nofollow" target="_blank">科特林的TTT比特棋盘</a></li><li id="0477" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated">科特林的<a class="ae kc" href="https://gist.github.com/larswaechter/595f5f63df3de5579e8dbe47b69ede4e" rel="noopener ugc nofollow" target="_blank">极小极大</a></li><li id="ab7f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nr lh li lj bi translated"><a class="ae kc" href="https://gist.github.com/larswaechter/2c007c00904822b68331fe26736d92a8" rel="noopener ugc nofollow" target="_blank">佐布里斯特哈希</a>在科特林</li></ul></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="e11d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">本文最初发表在我的博客上。看一看。</strong></p><div class="ok ol gp gr om on"><a href="https://larswaechter.dev/blog/minimax-performance-improvements/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">提高Minimax性能</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">2021年11月29日最小最大算法，也称为最小最大，是一种流行的算法，用于计算最佳可能…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">拉斯瓦切特.德夫</p></div></div></div></a></div></div></div>    
</body>
</html>