<html>
<head>
<title>Refactoring Imperative to Declarative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将命令性重构为声明性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/refactoring-imperative-to-declarative-7b3e9a532f7c?source=collection_archive---------16-----------------------#2021-02-07">https://levelup.gitconnected.com/refactoring-imperative-to-declarative-7b3e9a532f7c?source=collection_archive---------16-----------------------#2021-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cbaa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是一次旅程，看看我如何能把一个换成另一个</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15bbe7b1675743f3261ee67e6e15c727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VNq4rMMyDwzr-N-hgf7ow.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安托万·道特里在<a class="ae ky" href="https://unsplash.com/s/photos/math?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019年，苹果发布了两个声明性框架SwiftUI和Combine。这让我在这个月开始思考，并确实发表了几篇关于这个主题的文章，就像这样。让联合收割机工作很有趣，真的。也许没有SwiftUI那么激动人心，但我保证这很有趣，也很有意义。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/integrating-combine-in-swiftui-f3ffa2e170ba" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">在SwiftUI中集成联合收割机</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在SwiftUI代码中直接使用消费者和操作者</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="e36d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个相关但不同的问题是——如果你觉得文章有时有些学术性，我肯定你知道我在说什么——充满了你似乎无法融入现实世界的例子。让我们一石二鸟。</p><p id="20a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，考虑到这一点，让我们尝试将一些用命令式编码编写的代码重新分解为反应式/声明式代码。对我来说是一次有用的学习练习，希望对你来说也是一次有趣的旅程。加入我吧。</p><h2 id="2cab" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">案情摘要</h2><p id="07fe" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我有一个单词列表，法语动词，我想在我的应用程序上创建一个搜索字段，这将帮助我使用类似lookup的浏览器找到一个。你知道当你开始打字的时候，你的浏览器是如何提示你可能正在寻找的网站的。我想这么做。事实上，在我完成之后，我会用反应式/声明式编码来重构它。尽管在我们开始之前，让我来回答你需要问的问题。更改代码对我有什么好处？</p><h2 id="73de" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">收益</h2><p id="2113" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">反应式编码的一个主要优点是，我可以很容易地取消我在其中启动的操作。这是反应式编码的理想选择，因为——想象一下，我希望所有动词都以a开头。我键入a，然后立即在代码中启动一个查询，查找所有以<strong class="lb iu"> a </strong>开头的动词。但是等我说完我就打a <strong class="lb iu"> d </strong>。现在你要停止寻找以<strong class="lb iu"> a </strong>开头的动词，开始寻找以<strong class="lb iu"> ad </strong>开头的动词。你需要可以启动和停止的代码，实时响应你的请求的代码，反应式代码。</p><h2 id="8d0b" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">代码</h2><p id="e7cb" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我从一个单例类开始，它将保存我的动词表、我的搜索字段和找到的动词子集。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3f0d" class="mn mo it nm b gy nq nr l ns nt">let changePublisher = PassthroughSubject&lt;String,Never&gt;()<br/>var subscriptionsV = Set&lt;AnyCancellable&gt;()</span><span id="11d7" class="mn mo it nm b gy nu nr l ns nt">class Verbs: ObservableObject {<br/>  @Published var name: String = "" {<br/>    willSet {<br/>      changePublisher.send(newValue)<br/>    }<br/>  }<br/>@Published var table:[String] = []<br/>@Published var verbs:[String] = []<br/>static var shared = Verbs()<br/>}</span></pre><p id="a574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里真的没有火箭科学。名称变量是搜索字段。当我更改它的值时，它将触发一个组合发布器，我将在界面中捕获该发布器，并使用正则表达式启动一个查询来匹配我的表中的动词。我加载在verbs变量中找到的动词[这也是一个表]。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然也是你需要的代码。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1b0d" class="mn mo it nm b gy nq nr l ns nt">extension String {<br/>  func beginning(with: String) -&gt; Bool {<br/>    if self.range(of:with, options: .regularExpression) != nil { return true }<br/>  return false<br/>  }<br/>}</span></pre><p id="751a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这不会像现在这样工作，你遗漏了downLoadVerbsV方法，我将在这里发布。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ce6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及调用它的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ef29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后还有一件事，这是我使用的动词表的一小部分。存储在应用程序内的文本文件，称之为“动词. txt”。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2f51" class="mn mo it nm b gy nq nr l ns nt">7,parler,0,easy,avoir,parlé,parl<br/>15,créer,0,easy,avoir,créé,cré<br/>25,finir,0,easy,avoir,fini,fin<br/>26,haïr,0,easy,avoir,haï,ha<br/>31,assaillir,0,easy,avoir,assailli,assaill<br/>34,battre,0,easy,avoir,battu,batt<br/>39,conclure,0,easy,avoir,conclu,conclu<br/>43,courir,0,easy,avoir,couru,cour</span></pre><p id="9e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把所有这些放在一起，它应该工作。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="c568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">邦。但是我们还没有完成，不，我们实际上还没有开始——你看最后一个方法，下载动词有一些有趣的/挑战性的重构机会，我还没有包括在内。解析数据文件的循环，我们开始吧。</p><p id="9421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的第一次传球是这样的。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="7f5c" class="mn mo it nm b gy nq nr l ns nt">for lines in content! {<br/>  Just(lines)<br/>    .filter { $0.contains(",") }<br/>    .sink(receiveValue: {<br/>      let verb = $0.split(separator: ",")<br/>      verbsUploaded.append(String(verb[1]))<br/>    })<br/>    .store(in: &amp;subscriptionsV)<br/>}</span></pre><p id="c91f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们像以前一样使用相同的循环，发布每一行，同时过滤掉空白的行，解析行中的CSV并保存它。还可以，但是我想我可以做得更好。第二个解析如下所示。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="9322" class="mn mo it nm b gy nq nr l ns nt">for lines in content! {<br/>  Just(lines)<br/>    .filter { $0.contains(",") }<br/>    .compactMap { $0.singleWord(no: 1) }<br/>    .sink(receiveValue: {<br/>       newVerb = $0<br/>    })<br/>  .store(in: &amp;subscriptionsV)<br/>}</span></pre><p id="ed58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一篇中，我介绍了另一个扩展——我将在下面展示，实际上，这是您在下载方法中已经有的willSet安排。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="9302" class="mn mo it nm b gy nq nr l ns nt">extension String {<br/>  func singleWord(no: Int) -&gt; String {<br/>    let words = self.split(separator: ",")<br/>    return String(words[no])<br/>  }<br/>}</span></pre><p id="1940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个更好，但是我们能不能把那个循环去掉？您需要使用flatMap来实现这一点。开始了，这是第三版。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fdde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然它是原来的两倍大，但是记住这个理论上你可以取消，原来的你不能。</p><p id="ea92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是好了，我们已经完成了。让我们回到SwiftUI代码。这里有一个循环，我也可以重构。这一个。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="fdce" class="mn mo it nm b gy nq nr l ns nt">for verb in searches.table {<br/>  if verb.beginning(with: searchString) {<br/>    searches.verbs.append(verb)<br/>  }<br/>}</span></pre><p id="5170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯——老实说，这是“循环”。这里我们开始搜索动词，如果我的搜索参数中途改变，这是我可能想要重新开始的代码。现在我的第一步是直接进入这一行。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5e74" class="mn mo it nm b gy nq nr l ns nt">searches.verbs = searches.table.filter { $0.beginning(with: searchString) }</span></pre><p id="b16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它非常高效，是声明式的；但我没有使用联合收割机，我不能重新启动它。我需要第二次机会。这是我需要的。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="f9a6" class="mn mo it nm b gy nq nr l ns nt">searches.table.publisher<br/>  .filter { $0.beginning(with: searchString) }<br/>  .sink(receiveValue: { searches.verbs.append(String($0)) })<br/>  .store(in: &amp;subscriptionsV)</span></pre><p id="f3e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我担心我需要停止，因为我已经达到了我的字数限制。对应用程序进行更改并试用。我只需要再做一件事。下次我要想办法取消搜索。跟随我在medium.com获得更多的文件，实际上读一些我的旧的，像这一个，另一个联合的旅程。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/validate-passwords-in-swiftui-forms-using-combine-a6f2ba4fd83b" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用Combine验证SwiftUI表单中的密码</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">验证凭证的声明式编程</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="oe l mj mk ml mh mm ks ly"/></div></div></a></div><p id="5a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持冷静，继续编码。</p></div></div>    
</body>
</html>