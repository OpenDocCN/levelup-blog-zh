<html>
<head>
<title>JavaScript Tips — Pausing or Stopping Programs, Accessing Script Elements, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript提示—暂停或停止程序、访问脚本元素等等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-tips-pausing-or-stopping-programs-accessing-script-elements-e9bc994e33b8?source=collection_archive---------24-----------------------#2020-07-09">https://levelup.gitconnected.com/javascript-tips-pausing-or-stopping-programs-accessing-script-elements-e9bc994e33b8?source=collection_archive---------24-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2e7a6044c87e5adf5e1aadbca3f5af6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*haoM0cJQhECm0NaG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">TS谢尔盖在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3205" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="092d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将参数传递给addEventListener侦听器函数</h1><p id="8728" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有几种方法可以将参数传递给事件侦听器函数。</p><p id="3d60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一种方法是创建另一个函数并调用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="318e" class="mq lf it mm b gy mr ms l mt mu">element.addEventListener("click", () =&gt; {<br/>  foo(someVar);<br/>}, false);</span></pre><p id="9156" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是用我们的参数在函数内部调用<code class="fe mv mw mx mm b">foo</code>。</p><p id="b277" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以在元素上设置一个属性，并通过编写以下内容来访问它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fefe" class="mq lf it mm b gy mr ms l mt mu">const listener = (evt) =&gt; {<br/>  window.alert(evt.currentTarget.foo);<br/>}</span><span id="14d8" class="mq lf it mm b gy my ms l mt mu">element.addEventListener('click', listener, false);<br/>element.foo = 'bar';</span></pre><p id="08b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们获得了具有<code class="fe mv mw mx mm b">currentTarget</code>属性的元素对象。</p><p id="52c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用<code class="fe mv mw mx mm b">bind</code>返回一个传入了一些参数的函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="aab7" class="mq lf it mm b gy mr ms l mt mu">function listener(foo, ev) {<br/>  //...<br/>}<br/>element.addEventListener("click", listener.bind(null, foo), false);</span></pre><p id="d979" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mv mw mx mm b">foo</code>作为<code class="fe mv mw mx mm b">bind</code>的第二个参数传递给函数。</p><h1 id="1010" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">停止JavaScript执行</h1><p id="a5a5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有几种方法可以停止JavaScript程序。</p><p id="f59b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一种方法是抛出一个错误。</p><p id="7098" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ef91" class="mq lf it mm b gy mr ms l mt mu">class <!-- -->FatalError extends Error {}<br/>throw new FatalError('fatal error');</span></pre><p id="f9b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以在函数中使用<code class="fe mv mw mx mm b">return</code>关键字来阻止它运行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e7f2" class="mq lf it mm b gy mr ms l mt mu">const foo = () =&gt; {<br/>  <!-- -->if(someEventHappened) {<br/>     return;<br/>  }<br/>  //...<br/>}</span></pre><h1 id="aa3e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript中延期、承诺和未来的区别</h1><p id="c7ab" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">延迟的是实现<code class="fe mv mw mx mm b">resolve</code>、<code class="fe mv mw mx mm b">reject</code>和<code class="fe mv mw mx mm b">then</code>的对象。</p><p id="ed5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建调用<code class="fe mv mw mx mm b">resolve</code>、<code class="fe mv mw mx mm b">reject</code>的承诺，并返回一个调用<code class="fe mv mw mx mm b">then</code>的对象。</p><p id="bdb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Promise是一个代理对象，用于存储将来要给出的结果。</p><p id="40f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还公开了一个接受另一个目标并返回新承诺的<code class="fe mv mw mx mm b">then</code>方法。</p><p id="e936" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对这两者来说，未来是一个过时的术语。</p><h1 id="338f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript中子节点和子节点的区别</h1><p id="bd29" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">children</code>是JavaScript中元素的属性。它只返回子元素。</p><p id="02d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">childNodes</code>是节点的属性，可以包含任何节点。</p><h1 id="97bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">async、await和setTimeout的组合</h1><p id="07be" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mv mw mx mm b">setTimeout</code>创建一个承诺，然后我们可以使用async并等待它。</p><p id="f4f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3c07" class="mq lf it mm b gy mr ms l mt mu">const timeout = (ms) =&gt; {<br/>  return new Promise(resolve =&gt; setTimeout(resolve, ms));<br/>}</span><span id="3cdd" class="mq lf it mm b gy my ms l mt mu">const foo = async () =&gt; {<br/>  await timeout(3000);<br/>  //...<br/>}</span></pre><p id="5804" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mv mw mx mm b">Promise</code>构造函数创建了一个承诺，它调用<code class="fe mv mw mx mm b">resolve</code>来实现这个承诺。</p><p id="5b9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">ms</code>是以毫秒为单位的延迟持续时间。</p><p id="a536" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用<code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>在其他任何地方使用。</p><p id="dab3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在节点应用程序中，我们也可以通过编写以下代码来使用<code class="fe mv mw mx mm b">util</code>包:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bc7f" class="mq lf it mm b gy mr ms l mt mu">const sleep = require('util').promisify(setTimeout)</span></pre><h1 id="2e1b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在JavaScript中将整数转换成二进制</h1><p id="253a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用补零右移运算符将整数转换成二进制。</p><p id="b3fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fb22" class="mq lf it mm b gy mr ms l mt mu">(dec &gt;&gt;&gt; 0).toString(2);</span></pre><p id="d7e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mv mw mx mm b">&gt;&gt;&gt;</code>运算符将十进制数<code class="fe mv mw mx mm b">dec</code>转换成二进制数，这将给定的位数向右移动。</p><p id="b52e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们向右移动0位，使其成为无符号整数。</p><p id="847b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用带参数2的<code class="fe mv mw mx mm b">toString</code>把它转换成字符串，把它转换成二进制字符串。</p><p id="734b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有一个正整数，那么我们可以调用这个数字的<code class="fe mv mw mx mm b">toString(2)</code>。</p><h1 id="4529" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">引用加载当前正在执行的脚本的脚本标签</h1><p id="a75b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">document.currentScript</code>返回当前正在处理的脚本元素。</p><p id="0476" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单可靠。</p><p id="03c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不需要修改脚本标签。</p><p id="946d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也适用于具有<code class="fe mv mw mx mm b">defer</code>或<code class="fe mv mw mx mm b">async</code>属性的异步脚本。</p><p id="ed68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它与动态插入的脚本一起工作。</p><p id="cae5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它不适用于IE和类型为<code class="fe mv mw mx mm b">module</code>的脚本。</p><p id="3bda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以按ID选择脚本:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7090" class="mq lf it mm b gy mr ms l mt mu">&lt;script id="someScript"&gt;<br/>const currentScript = document.getElementById('someScript');<br/>&lt;/script&gt;</span></pre><p id="a9ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它具有与<code class="fe mv mw mx mm b">document.currentScript</code>相同的优势，并且得到了普遍支持。</p><p id="aa2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们必须添加一个ID，在极少数情况下可能会导致奇怪的行为。</p><p id="ebc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以添加自定义数据属性。</p><p id="9540" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d4e3" class="mq lf it mm b gy mr ms l mt mu">&lt;script data-name="someScript"&gt;<br/>const currentScript = document.querySelector('script[data-name="someScript"]');<br/>&lt;/script&gt;</span></pre><p id="35ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过<code class="fe mv mw mx mm b">data-name</code>属性获取脚本。</p><p id="f306" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它很简单，可以动态插入脚本。</p><p id="4db7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是它没有<code class="fe mv mw mx mm b">id</code>属性得到广泛的支持。</p><p id="831d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们还可以通过<code class="fe mv mw mx mm b">src</code>值得到一个脚本。</p><p id="0808" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3089" class="mq lf it mm b gy mr ms l mt mu">const scriot = document.querySelector('script[src="//example.com/script.js"]');</span></pre><p id="e36d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这在本地脚本上不起作用。</p><p id="1bdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是它与<code class="fe mv mw mx mm b">defer</code>和<code class="fe mv mw mx mm b">async</code>一起工作，并且在那些情况下是可靠的。</p><p id="5203" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还可以处理动态插入的脚本。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/b425f38758d548dd8aabab756b174039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mwxGzoSTnmNOLiIF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kambaniramano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">坎巴尼·拉马诺</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="9393" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="192e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有几种方法可以获得页面上的脚本元素。</p><p id="a95f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mv mw mx mm b">bind</code>或调用另一个函数将参数传递给事件监听器。</p><p id="4d57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几种方法可以暂停或停止JavaScript程序的执行。</p></div></div>    
</body>
</html>