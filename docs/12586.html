<html>
<head>
<title>Working with XML Serialization in Java and Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Java和Kotlin中使用XML序列化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/working-with-xml-serialization-in-java-and-kotlin-42b0f8a6b385?source=collection_archive---------4-----------------------#2022-06-21">https://levelup.gitconnected.com/working-with-xml-serialization-in-java-and-kotlin-42b0f8a6b385?source=collection_archive---------4-----------------------#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6a175460a2fe2e07c6deaeae8a21f70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXrsJ70ljfmNnzshmgmbfg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><p id="f4a8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在基于Java/Kotlin的应用程序中，您可能遇到过必须使用XML的情况。您需要操作XML并返回对请求的响应或写入文件。您可能有一个旧的应用程序，它仍然支持一些需要序列化XML字符串的遗留API。使用XML的方法有很多。在本文中，我将分享一些使用XML的更好的方法。</p><h2 id="ba3f" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">先决条件</h2><ul class=""><li id="a2fa" class="lx ly jj ki b kj lz kn ma kr mb kv mc kz md ld me mf mg mh bi translated">爪哇LTS 17岁以上</li><li id="8432" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">[可选] Kotlin 1.6+，几个例子将在Kotlin</li><li id="90cb" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">[可选]智能，您可以使用您喜欢的IDE</li></ul><h2 id="2556" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak">设置</strong></h2><p id="22c0" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我的编码示例也包括Kotlin示例。因此，我将创建一个也支持科特林的跳趾。选择什么样的框架完全取决于你自己。给定的样品也没有跳靴工作。对于这个演示，您可以从<a class="ae jg" href="https://start.spring.io/#!type=maven-project&amp;language=kotlin&amp;platformVersion=2.7.0&amp;packaging=jar&amp;jvmVersion=17&amp;groupId=dev.dechipher.xml&amp;artifactId=xml-demo&amp;name=xml-demo&amp;description=Demo%20app%20for%20xml%20writing%20in%20Kotlin%20and%20Java&amp;packageName=dev.dechipher.xml.xml-demo&amp;dependencies=web" rel="noopener ugc nofollow" target="_blank">这个链接</a>生成一个启动项目。只需下载<a class="ae jg" href="https://start.spring.io/#!type=maven-project&amp;language=kotlin&amp;platformVersion=2.7.0&amp;packaging=jar&amp;jvmVersion=17&amp;groupId=dev.dechipher.xml&amp;artifactId=xml-demo&amp;name=xml-demo&amp;description=Demo%20app%20for%20xml%20writing%20in%20Kotlin%20and%20Java&amp;packageName=dev.dechipher.xml.xml-demo&amp;dependencies=web" rel="noopener ugc nofollow" target="_blank"> xml-demo </a> zip文件并解压到某个地方。通常，提取大约需要1-2分钟。下载完成后，您可以删除<strong class="ki jk"><em class="mq">xmldemoapplication . kt</em></strong>或将其重命名为<strong class="ki jk"><em class="mq">XmlDemoApplication.java。</em>T19】</strong></p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mr"><img src="../Images/ad8d2d7d381179f0efd03f3f8e2db9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ckmFaLkGy38vQXE"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@giabyte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gia Oris </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5f8f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们添加第一个代码。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="556c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">说明:</strong>在上面的代码中，我刚刚用<code class="fe my mz na nb b">@RequestMappping</code>创建了一个<code class="fe my mz na nb b">@RestController</code>。</p><p id="3440" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">输出:</strong>尝试检索<strong class="ki jk"> </strong>数据</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="87f1" class="le lf jj nb b gy ng nh l ni nj">curl http://localhost:8080/xml?name=Deepak</span><span id="2bb8" class="le lf jj nb b gy nk nh l ni nj">&lt;name&gt;Deepak&lt;/name&gt;</span></pre><p id="303f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个Kotlin文件<strong class="ki jk">XML demkt . kt .</strong>在Kotlin文件中添加下面的代码</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fbf3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">输出:</strong></p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="cdcb" class="le lf jj nb b gy ng nh l ni nj">curl http://localhost:8080/kt/xml?name=Deepak</span><span id="9a58" class="le lf jj nb b gy nk nh l ni nj">&lt;name&gt;Deepak&lt;/name&gt;</span></pre><h2 id="a5fa" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">1.使用文本块或字符串模板</h2><p id="0e66" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在Java 15中，Java引入了一个新特性<a class="ae jg" href="https://docs.oracle.com/en/java/javase/15/text-blocks/index.html" rel="noopener ugc nofollow" target="_blank">文本块</a>。如果使用Java 15及以上版本，可以使用TextBlock编写多行字符串。这是编写XML模板的良好开端。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5635" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TextBlock面临的最大挑战是它不支持文本块中的模板。我的意思是你不能在TextBlock中使用变量和值。所以你必须使用像<strong class="ki jk">格式化</strong>这样的实用方法来给变量赋值。科特林的情况并非如此。让我们来看看科特林代码。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6fb8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">请求:</strong></p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="9517" class="le lf jj nb b gy ng nh l ni nj">## Java</span><span id="15be" class="le lf jj nb b gy nk nh l ni nj">curl -X POST http://localhost:8080/xml -H 'Content-Type: application/json' -d '{    "age": 20,    "name": "Stefanie Sampson",    "company": "INTERFIND",    "email": "stefaniesampson@interfind.com",    "address": {      "street": "Coleman Street, 683",      "city": "Spelter",      "state": "Marshall Islands",      "zip": 3748    }  }'</span><span id="3081" class="le lf jj nb b gy nk nh l ni nj">## Kotlin URL<br/>http://localhost:8080/kt/xml</span></pre><h2 id="057a" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">2.使用模板引擎</h2><p id="5d42" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">编写和操作模板字符串既耗时又冗长。你可以通过使用模板引擎来避免这种情况，比如<a class="ae jg" href="https://github.com/spullara/mustache.java" rel="noopener ugc nofollow" target="_blank">小胡子</a>或<a class="ae jg" href="https://www.thymeleaf.org/" rel="noopener ugc nofollow" target="_blank">百里香叶</a>。任何模板引擎的工作原理都是一样的。您需要首先解析模板并编译它。稍后，您可以使用编译后的对象来生成字符串值。<br/>我将展示小胡子引擎中的工作示例。设置小胡子引擎比百里香简单得多。</p><p id="a3bd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> Mustache模板:</strong>在resource文件夹中创建一个<code class="fe my mz na nb b">person-response.mustache</code>文件。在Mustache中，从资源文件夹中读取模板非常简单。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e505" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">科特林版本:</strong></p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0d8d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> Java版本:</strong></p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fed9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">请求:</strong></p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="bcb9" class="le lf jj nb b gy ng nh l ni nj">## Kotlin </span><span id="574f" class="le lf jj nb b gy nk nh l ni nj">curl -X POST http://localhost:8080/kt/template -H 'Content-Type: application/json' -d '{    "age": 20,    "name": "Stefanie Sampson",    "company": "INTERFIND",    "email": "<a class="ae jg" href="mailto:stefaniesampson@interfind.com" rel="noopener ugc nofollow" target="_blank">stefaniesampson@interfind.com</a>",    "address": {      "street": "Coleman Street, 683",      "city": "Spelter",      "state": "Marshall Islands",      "zip": 3748    }  }'</span><span id="8fff" class="le lf jj nb b gy nk nh l ni nj">## Java URL<br/>http://localhost:8080/template</span></pre><p id="a98e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经注意到，现在的代码看起来非常类似于Java和Kotlin。使用模板引擎使代码更易读、更简单。然而，同时维护模板和POJOs可能是乏味和多余的。如果数据或模板发生任何变化，我们必须同时更改模板和POJO。模板引擎解析整个模板，也会降低应用程序的性能。</p><h2 id="dcec" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">3.使用Jackson序列化</h2><p id="c5df" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">您可能已经注意到Springboot提供了现成的JSON序列化。Springboot内部使用<a class="ae jg" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank"> FasterXml </a> Jackson模块。Jackson模块是一个非常方便的框架，可以与JSON和XML数据类型一起使用。我们可以轻松地配置Springboot应用程序来返回XML响应。为此，我们只需要在<code class="fe my mz na nb b">@RequestMapping</code>注释中添加一个<strong class="ki jk">生产</strong>标签。要将POJO标记为XML响应，我们还需要用<code class="fe my mz na nb b">@JacksonXmlRootElement</code>注释标记根类。</p><p id="97d0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong> Java不需要任何额外的配置。但是，如果您使用的是Kotlin数据类。您需要在对象映射器中注册Kotlin模块。</p><p id="ed53" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> Java示例:</strong></p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2b0a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">科特林样本:</strong></p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="32c2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有使用Springboot框架，可以直接使用XML mapper将POJO转换成XML字符串。</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="a8df" class="le lf jj nb b gy ng nh l ni nj">// Java</span><span id="3a27" class="le lf jj nb b gy nk nh l ni nj">person.name = "[Updated] %s".formatted(person.name);<br/>return new XmlMapper().writeValueAsString(person);</span><span id="85a9" class="le lf jj nb b gy nk nh l ni nj">// Kotlin</span><span id="2d1f" class="le lf jj nb b gy nk nh l ni nj">XmlMapper().writeValueAsString(p.copy(name = "[Updated] ${p.name}"))</span></pre><p id="0997" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong>您应该创建XmlMapper的单个实例，以避免内存泄漏。</p><h2 id="7fc5" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="d310" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这些是处理XML字符串的几种方法。如果您正在寻找一种更具创新性和声明性的方式来编写XML。你可以看看Kotlin DSL库，比如<a class="ae jg" href="https://github.com/redundent/kotlin-xml-builder" rel="noopener ugc nofollow" target="_blank"> kotlin-xml-builder </a>。与其他XML相比，我更喜欢使用Jackson XML。因为它非常易于使用和理解。</p><h2 id="a57e" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">源代码</h2><p id="0fc4" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">您可以从我的要点页面<a class="ae jg" href="https://gist.github.com/deepakshrma/b7ef7d9a9ccf94ff6150bd1ddd9cdd8b" rel="noopener ugc nofollow" target="_blank">下载所有文件，使用Java和Kotlin </a>处理XML序列化和响应。</p></div></div>    
</body>
</html>