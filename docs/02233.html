<html>
<head>
<title>Event-driven Servers: An Intuitive Study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件驱动服务器:直观的研究</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/event-driven-servers-a-intuitive-study-6d1677818d2a?source=collection_archive---------5-----------------------#2020-02-28">https://levelup.gitconnected.com/event-driven-servers-a-intuitive-study-6d1677818d2a?source=collection_archive---------5-----------------------#2020-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bf5d20aa9a65eb4b2fe71784413874a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VOgMs1YYQbHKmqh4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">不要阻塞循环。克里斯·阿洛克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9f5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一篇关于事件驱动服务器的简短说明，旨在帮助读者对事件循环有一个直观的理解。在以下情况下，它会很有用:</p><ul class=""><li id="e5b8" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">为Apache HTTP服务器选择不同的<a class="ae kc" href="https://httpd.apache.org/docs/2.4/mpm.html" rel="noopener ugc nofollow" target="_blank">MPM</a></li><li id="58fd" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Apache HTTP Server和NGINX的比较</li><li id="0b8d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">为gunicorn选择并发模型</li><li id="003f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">事件循环故障排除</li></ul><h1 id="8012" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">并发服务器</h1><p id="7d9d" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在传统的客户端-服务器架构中，服务器接受来自客户端的连接，在新的套接字上接收数据，将其转发给应用程序进行处理，然后在同一套接字上将数据发送回客户端。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/50fb9cae8a06c019356977538409861b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ELAvK68JV19PrslsIMkQg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">MVP:单线程服务器。我们准备好了一些风险投资。</figcaption></figure><p id="a7de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现并发性，最简单的多线程实现可以为每个新连接创建一个新线程。一旦创建，线程就被绑定到连接上，按顺序处理这个连接上的所有请求和响应。然后，当连接关闭时，线程被销毁并释放。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a9a5cd2ea179e91d8c70632db8c4da03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*-04-d-Es16LfX2OeniOuEg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">为了减少这种创建-销毁模式的开销，服务器可以使用线程池。</figcaption></figure><p id="8b71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这描述了流行的Apache HTTP服务器的<code class="fe my mz na nb b">worker</code> <a class="ae kc" href="https://httpd.apache.org/docs/2.4/misc/perf-tuning.html#compiletime" rel="noopener ugc nofollow" target="_blank">多处理模块</a>。</p><p id="8ce6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据每个实现的具体情况，这种模型可能有一些缺点，包括每个连接产生的内存开销。这在期望大量并发客户端的部署中伸缩性很差，每个客户端维护持久连接(例如<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive" rel="noopener ugc nofollow" target="_blank"> HTTP/1.1 Keep-Alive </a>，长轮询，或者重用TLS套接字)。宝贵的系统资源会浪费在大部分时间处于空闲状态的线程上。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/e4392ad2d781e5ed9acb461637c944a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAqWfpV-CGd5qS7jqLAtsw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">线程可能正在等待来自数据库的结果或来自客户端的数据。</figcaption></figure><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="a7f3" class="nh lq iq nb b gy ni nj l nk nl">memory required = memory required per thread * number of connections</span></pre><p id="9f73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了进一步推动这种直觉，考虑这个例子:如果使用这种1:1模型实现的服务器为每个连接分配1 MB的内存，那么它将需要10 GB的内存来服务1万个并发连接。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">1 MB是一个好的估计吗？一个PyMySQL客户端大约占用0.37 MB。参见<a class="ae kc" href="https://pypi.org/project/memory-profiler/" rel="noopener ugc nofollow" target="_blank">内存分析器</a>。</figcaption></figure><p id="2a06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是C10K问题的要点，我们希望实现的资源消耗配置文件能够随着并发连接数的增长而呈亚线性增长。</p><h1 id="ca8b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">走向事件驱动的实现</h1><p id="2242" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">为了在处理大量空闲连接时节省内存和CPU，我们可以通过执行以下操作来改进上述实现:</p><ol class=""><li id="c406" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la no lh li lj bi translated">通过允许主线程处理多个连接，减少每个新连接所需的内存量，以及</li><li id="19c8" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la no lh li lj bi translated">当套接字准备好被读/写时，使用来自内核的事件通知来触发回调，从而减少轮询所浪费的CPU周期。</li></ol><p id="124f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在没有进入精确定义的情况下，步骤1向我们介绍了<em class="np">异步编程</em>，其中每个线程不再绑定到单个连接，而是在多个连接上多路复用。为了成功，主线程需要知道每个套接字的准备情况和状态，一旦套接字准备好被读取，就从套接字读取，并在有数据要发送时快速写入套接字。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/5fa699d9cad507e5541867fa077eb42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VZXx1dJ3hNAIMaUfNFLPA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接c0、c1和c2上的多路复用，一个线程上有一个事件循环。</figcaption></figure><p id="cf53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，由于我们在许多客户端之间共享主线程，应用程序需要确保没有单个请求会阻塞整个线程，从而浪费其他客户端的时间。任何正在使用主线程的东西都需要尽快放弃它的控制权。</p><p id="a5af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤2向我们介绍了<em class="np">内核事件通知</em>，比如I/O就绪、UNIX信号和超时。这些可以通过BSD中的<code class="fe my mz na nb b">kqueue</code>或Linux中的<code class="fe my mz na nb b">epoll</code>来使用。下面的例子集成了<code class="fe my mz na nb b">libevent</code>，它是一个独立于OS的库，支持<code class="fe my mz na nb b">kqueue</code>、<code class="fe my mz na nb b">epoll</code>和<code class="fe my mz na nb b">select</code>等。</p><h1 id="5939" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">一个小例子</h1><p id="f185" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated"><a class="ae kc" href="https://github.com/jimjh/event-proxy" rel="noopener ugc nofollow" target="_blank"> event-proxy </a>是我编写的一个小程序，用来演示基于事件的服务器的基本原理，以及<a class="ae kc" href="https://libevent.org/" rel="noopener ugc nofollow" target="_blank"> libevent </a>的使用。这是最小的设计，以帮助教学和学习。它也是用C写的，我发现C是学习系统工程最好的语言。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8f963061fd0baa518d9b53168f88f20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*HMyCYlrP_OwWpy2DvLckEg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用带有cURL的<a class="ae kc" href="https://github.com/jimjh/event-proxy" rel="noopener ugc nofollow" target="_blank">事件代理</a>。</figcaption></figure><p id="6433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是事件代理的一个简短演示:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/4e35f94a987821ec2483929b5f6930ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jtCuEbVV7I0sKEHIB6vC-w.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">构建和运行事件代理。注意它是如何接收请求并将其转发给代理服务器的。</figcaption></figure><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/b22086786fd821fb19106fa52550b223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HZIR7L3qfc3I7Qf16IjLPA.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卷曲本地代理；将这张gif与之前的gif并排观看。</figcaption></figure><p id="f991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事件代理的结构如下:</p><ul class=""><li id="468c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe my mz na nb b">main.c</code>，提供程序的入口点，初始化记录器，调用<code class="fe my mz na nb b">proxy.c#proxy</code>启动代理；</li><li id="e907" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe my mz na nb b">proxy.c</code>，创建监听套接字，初始化事件循环，阻塞直到循环退出；</li><li id="0b61" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe my mz na nb b">io.c</code>，为<code class="fe my mz na nb b">proxy.c</code>提供接受连接的<code class="fe my mz na nb b">do_accept</code>回调；和</li><li id="9f2f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe my mz na nb b">client.c</code>，创建一个套接字并连接到代理服务器。</li></ul><h1 id="f0d4" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">proxy.c</h1><p id="b606" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在<code class="fe my mz na nb b">proxy.c#proxy</code>中，我们首先创建一个TCP套接字，将其绑定到一个IP地址和端口号，并使用<a class="ae kc" href="https://beej.us/guide/bgnet/html/#listen" rel="noopener ugc nofollow" target="_blank"> listen </a>系统调用来等待传入的连接。我们到目前为止还没有做什么独特的东西，这些步骤被分割成<code class="fe my mz na nb b">_init_listen_fd</code>，可以重点放在<code class="fe my mz na nb b">_init_event_loop</code>上。</p><p id="dc3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了开始使用libevent，我们首先使用<a class="ae kc" href="http://www.wangafu.net/~nickm/libevent-book/Ref2_eventbase.html" rel="noopener ugc nofollow" target="_blank"> event_base_new </a>分配一个<code class="fe my mz na nb b">event_base</code>结构。这个结构将用于保存我们感兴趣的事件，以及注册指向回调的指针。稍后，它用于启动事件循环。为简单起见，我们创建了一个默认的<code class="fe my mz na nb b">event_base</code>，没有任何定制配置:</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="c968" class="nh lq iq nb b gy ni nj l nk nl">ev_base = event_base_new();</span></pre><p id="ef3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们针对<code class="fe my mz na nb b">listen_fd</code>上的读取事件注册<code class="fe my mz na nb b">do_accept</code>回调，这是之前的监听套接字。这告诉事件循环，只要在那个套接字上有新的传入连接，就调用<code class="fe my mz na nb b">do_accept</code>。</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="e8dc" class="nh lq iq nb b gy ni nj l nk nl">ev_listen = event_new(ev_base, listen_fd, EV_READ|EV_PERSIST, do_accept, …);<br/>event_add(ev_listen, NULL);<br/>// NULL here means no timeout<br/>// without EV_PERSIST, this event will be triggered at most once</span></pre><p id="771d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们根据<code class="fe my mz na nb b">SIGQUIT</code>信号注册<code class="fe my mz na nb b">quit_cb</code>回调。</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="d03a" class="nh lq iq nb b gy ni nj l nk nl">ev_quit = evsignal_new(ev_base, SIGQUIT, quit_cb, ev_base);<br/>event_add(ev_quit, NULL);<br/>// NULL here means no timeout</span></pre><p id="6d7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们开始事件循环并无限期阻塞:</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="cdfe" class="nh lq iq nb b gy ni nj l nk nl">event_base_dispatch(ev_base);</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/11f44236eb82270e115c433d57c494cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*i6Hg-BV5Zq5lIMyEbG0YoA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">` event_base_new '和` event_add '设置说明` event_base_dispatch '使用的设置。</figcaption></figure><p id="ea93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概来说，<code class="fe my mz na nb b">event_base_dispatch</code>开始并阻塞一个无限循环，该循环一直等到至少一个事件被触发，并调用被激活事件的注册回调。这些回调是在同一个线程上调用的，如下所示:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">do_accept与<code class="fe my mz na nb b"><em class="nv">_init_event_loop</em></code>运行在同一个堆栈上，同一个线程中。</figcaption></figure><p id="10c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">花费太长时间返回的回调会惩罚整个事件循环并破坏公平性。因此，回调必须尽快返回，并将主线程的控制权交还给事件循环。因此，基于事件的编程通常需要避免阻塞调用，例如I/O等待、显式休眠和互斥等待。</p><p id="9203" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，<code class="fe my mz na nb b">event_new</code>和<code class="fe my mz na nb b">evsignal_new</code>的最后一个参数在回调函数被调用时被传递给它们。例如，当<code class="fe my mz na nb b">SIGQUIT</code>被发送给程序时，我们将<code class="fe my mz na nb b">ev_base</code>传递给<code class="fe my mz na nb b">quit_cb</code>，这样它就可以告诉事件循环退出。不幸的是，由于我们是在C语言中工作，参数的类型是<code class="fe my mz na nb b">void *</code>，一些转换是必要的:</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="4e5d" class="nh lq iq nb b gy ni nj l nk nl">struct event_base *ev_base = arg;<br/>event_base_loopexit(ev_base, NULL);<br/>// NULL here means exit after all current events are complete</span></pre><h1 id="67af" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">io.c</h1><p id="8e91" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated"><code class="fe my mz na nb b">io.c</code>提供<code class="fe my mz na nb b">do_accept</code>，每当监听器套接字接收到新的传入连接时都会调用这个回调。调用时，我们首先使用<a class="ae kc" href="https://beej.us/guide/bgnet/html/#acceptthank-you-for-calling-port-3490." rel="noopener ugc nofollow" target="_blank">接受系统调用</a>为每个连接创建一个新的套接字(名为<code class="fe my mz na nb b">accept_fd</code>)。然后，我们连接到代理服务器，创建名为<code class="fe my mz na nb b">client_fd</code>的新套接字。我们还没有做任何新的东西，新鲜感从<code class="fe my mz na nb b">_init_bufferevents</code>开始。</p><p id="496b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至此，我们已经创建了:</p><ul class=""><li id="9bb5" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe my mz na nb b">accept_fd</code>，可用于对连接的客户端读写字节的套接字，以及</li><li id="3c17" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe my mz na nb b">client_fd</code>，一个套接字，可以用来对代理服务器读写字节。</li></ul><p id="e5f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩下的任务是:</p><ul class=""><li id="eb18" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">从<code class="fe my mz na nb b">accept_fd</code>读取字节，并将其写入<code class="fe my mz na nb b">client_fd</code></li><li id="bf55" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">从<code class="fe my mz na nb b">client_fd</code>读取字节，并将其写入<code class="fe my mz na nb b">accept_fd</code></li></ul><p id="fb88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可以通过在两个套接字上注册一个针对read事件的回调来实现。为此，我们使用libevent的<a class="ae kc" href="http://www.wangafu.net/~nickm/libevent-book/Ref6_bufferevent.html" rel="noopener ugc nofollow" target="_blank"> bufferevent </a> API，它提供了一个使用缓冲区和流套接字的方便接口。我们首先创建一个与主事件循环和新套接字相关联的<code class="fe my mz na nb b">bufferevent</code>结构:</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="eefb" class="nh lq iq nb b gy ni nj l nk nl">bev = bufferevent_socket_new(ev_base, fd, BEV_OPT_CLOSE_ON_FREE);<br/>// create a bufferevent structure</span></pre><p id="bd29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们注册读取回调和错误回调:</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="07ef" class="nh lq iq nb b gy ni nj l nk nl">bufferevent_setcb(bev, readcb, NULL, errorcb, arg);</span></pre><p id="05d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，新的<code class="fe my mz na nb b">bufferevent</code>允许写入，但不允许读取，以下是必需的:</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="2783" class="nh lq iq nb b gy ni nj l nk nl">bufferevent_enable(bev, EV_READ | EV_WRITE);</span></pre><p id="effa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">拼图的最后一块是<code class="fe my mz na nb b">readcb</code>的实现，看起来像:</p><pre class="mt mu mv mw gt nd nb ne nf aw ng bi"><span id="9f2d" class="nh lq iq nb b gy ni nj l nk nl">static void readcb (struct bufferevent *bev, …) {<br/>    …<br/>    input = bufferevent_get_input(bev);<br/>    …<br/>    bufferevent_write_buffer(output, input);<br/>    …<br/>}</span></pre><p id="d0fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们像以前一样重用同一个<code class="fe my mz na nb b">ev_base</code>，这让我们可以插入同一个事件循环。新注册的回调将由在<code class="fe my mz na nb b">proxy.c#proxy</code>中调度的同一个事件循环调用，并且在同一个线程上。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">readcb运行在与<code class="fe my mz na nb b"><em class="nv">_init_event_loop</em></code>相同的堆栈上，在相同的线程中。</figcaption></figure><h1 id="38ff" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">超越服务器</h1><p id="49e2" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">批处理作业的设计也可以从线程和事件循环的讨论中受益。</p><p id="9761" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设我们有一个批处理作业运行在一台机器上，它从许多数据库中检索大量记录并聚合数据。为了实现并发性，我们可以使用多线程来实现这个批处理作业，每个数据库一个线程。这个设置看起来很熟悉，除了我们的批处理作业充当连接到多个数据库服务器的客户机。</p><p id="faa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种实现也有上述缺点:每个新线程都会消耗相当多的内存。此外，如果我们假设SELECT查询在数据库主机上花费了很长时间，那么我们也管理了大量的空闲线程和连接。</p><p id="c403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，事件循环可能是一种有用的优化。在创建了所有数据库连接之后，我们可以注册来自它们的I/O事件的回调。然后，事件循环将在一个主线程上运行，当来自数据库的结果可以在各自的套接字上读取时，调用相关的回调。每个调用的回调都会将查询结果拉入进程内存进行聚合。</p><p id="56fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个模型中，我们将大量的空闲线程减少到一个充分利用的主线程；然而，我们也丧失了在机器上利用多个内核的能力。通过将工作分配给每台机器上的多个进程来进一步优化可能是有利的:每个内核一个进程，每个进程都有自己的事件循环。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="f6f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的下一篇文章中，我将探索Linux如何调度等待I/O的线程和进程的细节，并讨论使用事件驱动实现的一些缺点。</p><p id="f2e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢<a class="ae kc" href="https://gabbi.fish/" rel="noopener ugc nofollow" target="_blank">加比·费希尔</a>审阅了初稿。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h1 id="18e5" class="lp lq iq bd lr ls od lu lv lw oe ly lz ma of mc md me og mg mh mi oh mk ml mm bi translated">进一步阅读</h1><ul class=""><li id="fa5d" class="lb lc iq kf b kg mn kk mo ko oi ks oj kw ok la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/jimjh/event-proxy" rel="noopener ugc nofollow" target="_blank">GitHub上的事件代理</a></li><li id="c744" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">StackOverflow:什么是事件驱动服务器？</li><li id="00f6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://stackoverflow.com/a/2625565" rel="noopener ugc nofollow" target="_blank">堆栈溢出:异步vs非阻塞</a></li><li id="7c56" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">丹·凯格尔的C10K问题</li><li id="0be7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">【NGINX内部:我们如何设计性能&amp;规模</li><li id="2131" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">【NGINX内部:信息图</li><li id="e733" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">开源应用的架构:安德鲁·阿莱克谢耶夫的NGINX</li><li id="8019" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">辛迪·斯里达哈兰的《埃波尔的疯狂》</li><li id="1f6c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction" rel="noopener ugc nofollow" target="_blank">Eli bender sky的并发服务器</a></li></ul></div></div>    
</body>
</html>