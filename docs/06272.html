<html>
<head>
<title>Implementing Messaging Queue NSQ in Golang using Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker在Golang中实现消息队列NSQ</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-messaging-queue-nsq-in-golang-using-docker-99b402293b12?source=collection_archive---------2-----------------------#2020-11-10">https://levelup.gitconnected.com/implementing-messaging-queue-nsq-in-golang-using-docker-99b402293b12?source=collection_archive---------2-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/73711cd6c2c612dafcd36599d1b11841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7m6flrVyhkTV5tJk5c0IHQ.jpeg"/></div></div></figure><p id="5552" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">消息队列为服务相互通信提供了一种新的异步方式。与API相比，消息队列有许多优点，例如:</p><ul class=""><li id="9728" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">优化性能</strong> <br/>生产者不需要等待消费者完成他们的工作，从而优化了性能</li><li id="780b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">可靠性</strong> <br/>消息队列中的持久性级别有助于在部分系统停机时最大限度地减少数据丢失</li><li id="61aa" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">可伸缩性</strong> <br/>分别伸缩生产者和消费者，以满足您的需求</li></ul><h1 id="0483" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">1.NSQ简介</h1><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/a145b6eecc7bf2452cb9d11d1443acf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/0*FwQtq2eC-4m_kmCQ.gif"/></div></figure><p id="864a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NSQ是一个开源的实时分布式消息平台，它是简单队列的继承者。</p><p id="39fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NSQ的核心组件包括:</p><ul class=""><li id="4bf2" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><em class="mn"> nsqd </em>是接收、排队和向客户端传递消息的守护程序。</li><li id="fd86" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><em class="mn"> nsqlookupd </em>是管理拓扑信息的守护程序。<br/>客户端查询<em class="mn"> nsqlookupd </em>以发现特定主题的nsqd生产者和<em class="mn"> nsqd </em>节点广播主题和频道信息。</li><li id="2f39" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><em class="mn"> nsqadmin </em>是一个Web UI，用于实时查看聚合的集群统计信息并执行各种管理任务。</li></ul><p id="8b3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单个<em class="mn"> nsqd </em>实例被设计成一次处理多个数据流。流被称为“主题”，一个主题有一个或多个“通道”。每个通道接收一个主题的所有消息的副本。</p><p id="4968" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主题和频道都不是预先配置的。主题是在命名主题首次发布时创建的，或者是通过订阅命名主题的频道创建的。频道是在第一次使用订阅命名频道时创建的。并且两者相互独立地缓冲数据。</p><p id="cc4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个通道通常有多个连接的客户端，每个消息将被传递给一个随机的客户端</p><h1 id="110b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">2.代码和NSQAdmin</h1><p id="904a" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">所以在这里，我想通过在消息队列中传递struct对象并显示NSQAdmin，使用基于<em class="mn">github.com/nsqio/go-nsq</em>的Docker在Golang中尝试一个简单的NSQ实现</p><ul class=""><li id="f157" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">docker-compose.yml</li></ul><pre class="mj mk ml mm gt mt mu mv mw aw mx bi"><span id="903f" class="my ll iq mu b gy mz na l nb nc"># docker-compose.yml<br/>version: '3'<br/>services:<br/>  nsqlookupd:<br/>    image: nsqio/nsq<br/>    command: /nsqlookupd<br/>    ports:<br/>      - "4160:4160"<br/>      - "4161:4161"<br/>  nsqd:<br/>    image: nsqio/nsq<br/>    command:  /nsqd --broadcast-address=nsqd --lookupd-tcp-address=nsqlookupd:4160<br/>    depends_on:<br/>      - nsqlookupd<br/>    ports:<br/>      - "4151:4151"<br/>      - "4150:4150"<br/>  nsqadmin:<br/>    image: nsqio/nsq<br/>    command: /nsqadmin --lookupd-http-address=nsqlookupd:4161<br/>    depends_on:<br/>      - nsqlookupd  <br/>    ports:<br/>      - "4171:4171"</span></pre><p id="6560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:不要忘记在<em class="mn"/>your<em class="mn">/etc/hosts<br/></em>中添加<em class="mn"> nsqd </em>作为127.0.0.1，因为我们的生产者和消费者位于我们的本地主机中，而NSQ环境在docker中运行，这将提供一个变通办法，因此docker端和本地主机端都可以访问docker中的<em class="mn"> nsqd </em>服务。</p><ul class=""><li id="1130" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">制作人.去吧</li></ul><pre class="mj mk ml mm gt mt mu mv mw aw mx bi"><span id="def7" class="my ll iq mu b gy mz na l nb nc">package main</span><span id="67a8" class="my ll iq mu b gy nd na l nb nc">import (<br/> "encoding/json"<br/> "github.com/nsqio/go-nsq"<br/> "log"<br/> "time"<br/>)</span><span id="de1d" class="my ll iq mu b gy nd na l nb nc">type Message struct {<br/> Name      string<br/> Content   string<br/> Timestamp string<br/>}</span><span id="6e72" class="my ll iq mu b gy nd na l nb nc">func main() {</span><span id="05b7" class="my ll iq mu b gy nd na l nb nc">//The only valid way to instantiate the Config<br/> config := nsq.NewConfig()</span><span id="24a2" class="my ll iq mu b gy nd na l nb nc">//Creating the Producer using NSQD Address<br/> producer, err := nsq.NewProducer("127.0.0.1:4150", config)<br/> if err != nil {<br/>  log.Fatal(err)<br/> }</span><span id="6565" class="my ll iq mu b gy nd na l nb nc">//Init topic name and message<br/> topic := "Topic_Example"<br/> msg := Message{<br/>  Name:      "Message Name Example",<br/>  Content:   "Message Content Example",<br/>  Timestamp: time.Now().String(),<br/> }</span><span id="bba5" class="my ll iq mu b gy nd na l nb nc">//Convert message as []byte<br/> payload, err := json.Marshal(msg)<br/> if err != nil {<br/>  log.Println(err)<br/> }</span><span id="235f" class="my ll iq mu b gy nd na l nb nc">//Publish the Message<br/> err = producer.Publish(topic, payload)<br/> if err != nil {<br/>  log.Println(err)<br/> }<br/>}</span></pre><ul class=""><li id="6d72" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">消费者. go</li></ul><pre class="mj mk ml mm gt mt mu mv mw aw mx bi"><span id="7446" class="my ll iq mu b gy mz na l nb nc">package main</span><span id="f575" class="my ll iq mu b gy nd na l nb nc">import (<br/> "encoding/json"<br/> "github.com/nsqio/go-nsq"<br/> "log"<br/> "os"<br/> "os/signal"<br/> "syscall"<br/> "time"<br/>)</span><span id="9561" class="my ll iq mu b gy nd na l nb nc">type messageHandler struct{}</span><span id="3bd0" class="my ll iq mu b gy nd na l nb nc">type Message struct {<br/> Name      string<br/> Content   string<br/> Timestamp string<br/>}</span><span id="5ab8" class="my ll iq mu b gy nd na l nb nc">func main() {<br/> //The only valid way to instantiate the Config<br/> config := nsq.NewConfig()</span><span id="f0c1" class="my ll iq mu b gy nd na l nb nc">//Tweak several common setup in config<br/> // Maximum number of times this consumer will attempt to process a message before giving up<br/> config.MaxAttempts = 10</span><span id="a6fb" class="my ll iq mu b gy nd na l nb nc">// Maximum number of messages to allow in flight<br/> config.MaxInFlight = 5</span><span id="2b62" class="my ll iq mu b gy nd na l nb nc">// Maximum duration when REQueueing<br/> config.MaxRequeueDelay = time.Second * 900<br/> config.DefaultRequeueDelay = time.Second * 0</span><span id="f60f" class="my ll iq mu b gy nd na l nb nc">//Init topic name and channel<br/> topic := "Topic_Example"<br/> channel := "Channel_Example"</span><span id="2132" class="my ll iq mu b gy nd na l nb nc">//Creating the consumer<br/> consumer, err := nsq.NewConsumer(topic, channel, config)<br/> if err != nil {<br/>  log.Fatal(err)<br/> }</span><span id="0e08" class="my ll iq mu b gy nd na l nb nc">// Set the Handler for messages received by this Consumer.<br/> consumer.AddHandler(&amp;messageHandler{})</span><span id="3bda" class="my ll iq mu b gy nd na l nb nc">//Use nsqlookupd to find nsqd instances<br/> consumer.ConnectToNSQLookupd("127.0.0.1:4161")</span><span id="c1f4" class="my ll iq mu b gy nd na l nb nc">// wait for signal to exit<br/> sigChan := make(chan os.Signal, 1)<br/> signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)<br/> &lt;-sigChan</span><span id="983a" class="my ll iq mu b gy nd na l nb nc">// Gracefully stop the consumer.<br/> consumer.Stop()<br/>}</span><span id="9864" class="my ll iq mu b gy nd na l nb nc">// HandleMessage implements the Handler interface.<br/>func (h *messageHandler) HandleMessage(m *nsq.Message) error {</span><span id="e1f6" class="my ll iq mu b gy nd na l nb nc">//Process the Message<br/> var request Message<br/> if err := json.Unmarshal(m.Body, &amp;request); err != nil {<br/>  log.Println("Error when Unmarshaling the message body, Err : ", err)<br/>  // Returning a non-nil error will automatically send a REQ command to NSQ to re-queue the message.<br/>  return err<br/> }</span><span id="2382" class="my ll iq mu b gy nd na l nb nc">//Print the Message<br/> log.Println("Message")<br/> log.Println("--------------------")<br/> log.Println("Name : ", request.Name)<br/> log.Println("Content : ", request.Content)<br/> log.Println("Timestamp : ", request.Timestamp)<br/> log.Println("--------------------")<br/> log.Println("")</span><span id="6ee6" class="my ll iq mu b gy nd na l nb nc">// Will automatically set the message as finish<br/> return nil<br/>}</span></pre><p id="8da0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有代码完成后，我们继续执行:</p><ul class=""><li id="c3fe" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">使用命令<br/> <code class="fe ne nf ng mu b"> <em class="mn">docker-compose up -d</em></code>启动对接器</li><li id="2863" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">构建producer.go和consumer.go <br/> <code class="fe ne nf ng mu b"><em class="mn">go build producer.go<br/>go build consumer.go</em></code></li><li id="18e2" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">首先执行消费者二进制文件，然后多次执行生产者二进制文件<br/> <em class="mn">。/消费者<br/>。/制片人</em></li></ul><p id="6bcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注:消费者有时需要查询<em class="mn"> nsqlookupd </em></p><p id="c163" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是结果截图</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/214d3a033a1ff47aefbc10a637078c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*6tZyUqH79deJHpqVQMZAGQ.png"/></div></figure><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/048736efff81386b8509d398b10e8549.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*OzI85wm4Jks_wlRHkeclBg.png"/></div></figure><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8e7f953dd9bcbea0b95b477e98827d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*9vZ69-YPQBj6Nw1pssIvnw.png"/></div></figure><p id="1f8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过以下方式检查<em class="mn"> NSQadmin </em>:</p><ul class=""><li id="aa30" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在浏览器中打开<a class="ae nk" href="http://localhost:4171" rel="noopener ugc nofollow" target="_blank"><em class="mn">http://localhost:4171</em></a><em class="mn"/><br/>它会列出所有可用的主题</li></ul><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/9bce77458994f6421597c2c67db396d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3tYlgz57PMjP19qcyv2Dw.png"/></div></div></figure><ul class=""><li id="7e65" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">点击所选的<em class="mn">主题<br/> </em>将显示<em class="mn">主题</em>的概述，包括总消息、频道列表、每个频道的进行中消息、每个频道的延迟消息等</li></ul><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/d0e4b7c7bde2f9756a1e0811fb3e7b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQ8I5NhtlpjTDix_gUp2-w.png"/></div></div></figure><ul class=""><li id="1d42" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">点击选定的<em class="mn">频道</em> <br/>，将显示与上面相同的概览，但在频道级别</li></ul><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/e0dca24d5231c9ec463d2157eccc83b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJ47V4x-cfHipia-WXSuCA.png"/></div></div></figure><ul class=""><li id="a0f0" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">你可以在<a class="ae nk" href="https://nsq.io/components/nsqadmin.html" rel="noopener ugc nofollow" target="_blank">https://nsq.io/components/nsqadmin.html</a>查看关于nsqadmin更深入的解释</li></ul><h1 id="5ce4" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">3.概括起来</h1><p id="0c11" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">用golang实现NSQ很容易，提供的大部分功能都可以自己解释，并且有很多与这个主题相关的文档，对于初学者来说，<a class="ae nk" href="https://godoc.org/github.com/nsqio/go-nsq" rel="noopener ugc nofollow" target="_blank">https://godoc.org/github.com/nsqio/go-nsq</a>也很容易理解，可以通过nsq和Golang学习消息队列的基本功能。</p><p id="0ea7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像往常一样，我们在东京有一个空缺。我们是一家印度尼西亚科技公司，我们的使命是通过技术实现商业民主化，帮助每个人实现更多。与我们一起在东京找到你梦想的工作！<br/><a class="ae nk" href="https://www.tokopedia.com/careers/" rel="noopener ugc nofollow" target="_blank">https://www.tokopedia.com/careers/</a></p><p id="6801" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nk" href="https://godoc.org/github.com/nsqio/go-nsq" rel="noopener ugc nofollow" target="_blank">https://godoc.org/github.com/nsqio/go-nsq</a><br/><a class="ae nk" rel="noopener ugc nofollow" target="_blank" href="/messaging-platform-comparison-nsq-and-apache-kafka-60f96f7466b1">https://level up . git connected . com/messaging-platform-comparison-nsq-and-Apache-Kafka-60f 96 f 7466 B1</a><br/><a class="ae nk" href="https://nsq.io/" rel="noopener ugc nofollow" target="_blank">https://nsq.io/</a></p></div></div>    
</body>
</html>