<html>
<head>
<title>Adopt Async-Await in your Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你的项目中采用异步等待</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adopt-async-await-in-your-project-d1117bf305be?source=collection_archive---------4-----------------------#2022-11-07">https://levelup.gitconnected.com/adopt-async-await-in-your-project-d1117bf305be?source=collection_archive---------4-----------------------#2022-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ba5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">逐步地</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b6443d610522d77ac9f7eaee3e4fc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*059mb2FEkA-jUHnIQ7x6rw.png"/></div></div></figure><p id="7369" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Swift并发中最相关和最新的变化之一是Async-Await及其与iOS13的向后兼容性。</p><p id="0ada" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除此之外，Xcode提供了几个工具来从基于闭包的代码重构到这种新方法，允许我们逐步更新我们的项目。</p><p id="7ce5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有很多设备可以开始迁移。因此，在本文中，我们将学习如何使用Xcode选项采用异步等待。</p><h1 id="1180" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">开始前…</h1><p id="67e0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">你应该知道这个语言扩展的基础。但是，如果您是异步等待领域的新手，请不要担心。</p><p id="80f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下资源很好地介绍了所有这些概念，因此您可以理解我们在这里做什么:</p><div class="mn mo gp gr mp mq"><a href="https://developer.apple.com/videos/play/wwdc2021/10132/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">在Swift-wwdc 21-Videos-Apple Developer中遇到异步/等待</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">Swift现在支持异步功能——这种模式通常被称为async/await。了解新语法如何能够…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">developer.apple.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">主apple上的swift-evolution/0296-async-await . MD/swift-evolution</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">现代Swift开发涉及大量使用闭包和完成的异步(或“async”)编程…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne ks mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://developer.apple.com/documentation/swift/updating_an_app_to_use_swift_concurrency" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">Apple开发者文档</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">编辑描述</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">developer.apple.com</p></div></div></div></a></div><h1 id="c6db" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">为什么我应该在我的项目中采用Async-Await？</h1><p id="ca6a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">任何应用程序开发都很容易涉及大量异步(或“async”)编程。这意味着使用闭包和完成处理程序。</p><p id="d882" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，网络层是包含更多并发性的应用程序的一部分。所以想象一下，我们正在开发一个应用程序，使用它的<a class="ae ng" href="https://rickandmortyapi.com/" rel="noopener ugc nofollow" target="_blank"> API </a>来查阅关于Rick和Morty系列的数据。</p><p id="475e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，负责调用字符端点和处理数据的Swift方法如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="634d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这个简单的异步任务序列，我们可以发现一些<strong class="kw iu">的缺点</strong>:</p><ul class=""><li id="5ec0" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">闭包<strong class="kw iu">更难阅读和调试</strong>，如果它们是嵌套的就更难了。事实上，丢失运行代码的轨迹是很常见的。</li><li id="5c29" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><strong class="kw iu">错误处理</strong>又是个问题。我们必须检查每次回调的结果，这增加了代码的复杂性。</li><li id="3b69" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><strong class="kw iu">易犯错误</strong>。注意，对于每个可能的方法出口，我们必须调用完成闭包来提供结果。</li><li id="465e" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">如果我们不这样做，app就会陷入无休止的状态。编译器不会将其标记为错误，因此<strong class="kw iu">更难发现</strong>。</li><li id="5f19" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">此外，我们<strong class="kw iu">必须使用自身的弱引用</strong>来避免保留循环。</li></ul><p id="4f76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">新的Async-Await模式解决了所有这些问题。这基本上就是调整你当前代码库的动机。</p><h1 id="2553" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">几个重构选项</h1><p id="e79b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在这一点上，想象我们想要重构这样的应用程序的网络层，开始使用异步函数。我们将使用真实的功能示例，一步一步地了解如何做到这一点。</p><p id="e3e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来看看前面<code class="fe nx ny nz oa b">findCharacter</code>的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4213" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">属性<code class="fe nx ny nz oa b">commonComponents</code>和<code class="fe nx ny nz oa b">createRequest(queryItems:) method</code>为我们提供了获取角色信息所需的请求。</p><p id="c554" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们感兴趣的是与<code class="fe nx ny nz oa b">dataTask</code>方法的完成闭包相关的<strong class="kw iu">异步任务</strong>。再次注意，我们之前看到的关于为什么闭包不是最优的观点。</p><p id="8049" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">了解了这些，我们就可以开始重构了。为此:</p><ul class=""><li id="19c0" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">做<em class="ob">在方法名上右击</em>。</li><li id="659d" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">选择<em class="ob"> Refactor </em>，你会看到Xcode为我们提供的选项。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f446cbda70544f66ec518eba37b4d370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gkshrk0M7GIlqs0pIDqoFA.png"/></div></div></figure><h1 id="7cee" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">异步包装器</h1><p id="d3dd" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们从简单的开始，这是<em class="ob">添加异步包装器。</em>如果你想在你的项目中采用async-await，但是你<strong class="kw iu">没有时间进行大的重构</strong>，这是一个<strong class="kw iu">极好的选择</strong>。</p><p id="1918" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择此选项，您将看到Xcode如何保持您的代码不变，它只是包含了一个充当异步包装器的新函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7f3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，<strong class="kw iu">创建的包装器是一个异步函数</strong>本身，它返回一个<code class="fe nx ny nz oa b">String</code>并可以抛出。这与为我们的非异步功能提供的<code class="fe nx ny nz oa b">Result</code>相对应。</p><p id="c832" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的魔力都来自于<code class="fe nx ny nz oa b">withCheckedThrowingContinuation</code>函数。让我们回顾一下文档，以了解这是如何工作的:</p><ul class=""><li id="9eab" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">(结构)<a class="ae ng" href="https://developer.apple.com/documentation/swift/checkedcontinuation" rel="noopener ugc nofollow" target="_blank">检查延续</a>。</li><li id="3726" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">(功能)<a class="ae ng" href="https://developer.apple.com/documentation/swift/withcheckedthrowingcontinuation(function:_:)" rel="noopener ugc nofollow" target="_blank">witheckedthrowcontinuation</a>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a6b907b0e80d3209465fcb8637a1d7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3Vmtz425QqmsJyewqRTyw.png"/></div></div></figure><p id="ef43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总之，这个函数允许我们<strong class="kw iu">将基于闭包的方法转换成异步函数</strong>。该方法将<strong class="kw iu">暂停当前任务，直到给定的闭包返回</strong>并触发async-await方法的继续，以这种方式提供结果。</p><p id="69ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了恢复暂停的任务并提供结果，您必须使用<code class="fe nx ny nz oa b">resume(with:)</code>，其中参数类型是<code class="fe nx ny nz oa b">Result&lt;T,E&gt;</code>。这与我们基于闭包的函数返回的类型相同。</p><ul class=""><li id="d730" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">所以我们可以做:<code class="fe nx ny nz oa b">continuation.resume(with: result)</code></li><li id="49ac" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">其中<code class="fe nx ny nz oa b">result</code>是<code class="fe nx ny nz oa b">Result&lt;String, Error&gt;</code></li></ul><p id="ffe9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相关的东西，你只需要调用一次。调用此方法后，控制权立即返回给调用方。此外，您可以使用<code class="fe nx ny nz oa b">resume(throwing:)</code>来抛出额外的错误。</p><p id="ee8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">知道了这是如何工作的，我们可以调用新的异步函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2c11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的另一个细节是<code class="fe nx ny nz oa b">Task</code>。我们用它来创建一个异步任务，以便能够从同步函数中调用这样的函数。重构时你会经常用到它，你可以把它看作两种范式之间的桥梁。</p><p id="097a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有关详细信息，请查看文档:</p><ul class=""><li id="c60c" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><a class="ae ng" href="https://developer.apple.com/documentation/swift/task/init(priority:operation:)-5ltye" rel="noopener ugc nofollow" target="_blank">任务初始化器</a></li></ul><h1 id="09d3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">异步替代</strong></h1><p id="0b74" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">下一个重构选项是<em class="ob">添加异步选择</em>。选择它，Xcode将完成大部分工作，但很可能您必须清理和修改结果代码。之后，重构的方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7234" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，前面的方法包装了整个原始方法，以提供异步等待支持。然而，当前选项将<strong class="kw iu">修改方法本身，在需要时暂停任务</strong>。</p><p id="34de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，这是涉及所有与网络调用相对应的闭包逻辑的部分。</p><p id="25b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，Xcode将使用<code class="fe nx ny nz oa b">withCheckedThrowingContinuation</code>函数。因此，只要得到回调，就必须确保调用<code class="fe nx ny nz oa b">continuation</code>闭包。要么抛出一个错误，要么返回一个您可以看到的结果。</p><p id="df9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，Xcode维护基于闭包的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4c14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nx ny nz oa b">available</code>属性是这些选项之间的共享特性。当你想逐步采用异步等待时，这非常有用。</p><p id="90f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有必要在变更后调整所有的项目。此外，您可以很容易地回到旧的实现，以检查一切都按预期工作。</p><h2 id="1c9f" class="oe lr it bd ls of og dn lw oh oi dp ma ld oj ok mc lh ol om me ll on oo mg op bi translated">改进异步替代方案</h2><p id="032b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">提议的解决方案确实支持异步等待，但是注意方法结构和以前非常相似。我们调用的<code class="fe nx ny nz oa b">continuation</code>闭包与最初实现中调用的<code class="fe nx ny nz oa b">completion</code>闭包一样多。</p><p id="9a85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，我们可以使用新的Async-Await API来简化这一切。</p><p id="d9ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nx ny nz oa b">URLSession</code>就是一个例子，所以不使用<code class="fe nx ny nz oa b">withCheckedThrowingContinuation</code>函数，而是使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2236" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，异步函数就像同步代码一样被写成了直线。除了极大地简化代码之外，这使得它的演讲更加容易。在这种情况下<strong class="kw iu">我们保存了21行代码</strong>。</p><h2 id="d32c" class="oe lr it bd ls of og dn lw oh oi dp ma ld oj ok mc lh ol om me ll on oo mg op bi translated">兼容性要求</h2><p id="e055" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">一个相关的注释。异步向后兼容性仅适用于Swift语言功能。换句话说，你可以使用async-await编写代码，但是所有使用它的基础API仍然需要iOS15。</p><h1 id="1abf" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">将函数转换为异步</h1><p id="b8c2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">最后一个选项代表了最激进的方法。它直接将我们旧代码转换成异步代码，而无需维护非异步替代代码。</p><p id="70c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择<em class="ob">将功能转换为异步</em>并像之前一样修改代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="806a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想尽快迁移到async-await，这是一个<strong class="kw iu">的好选择，因为它不提供中间步骤。</strong></p><p id="27ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这适用于中小型项目，但如果我们谈论更大的代码库，事情就不同了。这种方法修改了调用旧函数的每一个点，这意味着大量的修改。请记住这一点。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="b59d" class="lq lr it bd ls lt ox lv lw lx oy lz ma jz oz ka mc kc pa kd me kf pb kg mg mh bi translated">是时候重构你的项目了</h1><p id="5970" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">正如我们已经看到的，async-await解决了这些由基于闭包的代码引起的问题。除了简化代码和提高可读性。</p><p id="8d69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择哪一个重构选项取决于几个因素，比如项目规模或可用时间。但是有一点是清楚的，那就是你应该开始使用async-await。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="e09b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢我的内容，想看更多，记得<strong class="kw iu">拍拍</strong>和<strong class="kw iu">分享</strong>🙂</p></div></div>    
</body>
</html>