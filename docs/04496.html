<html>
<head>
<title>Nested Classes in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的嵌套类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nested-classes-in-java-3ce15ee0f2ef?source=collection_archive---------22-----------------------#2020-06-29">https://levelup.gitconnected.com/nested-classes-in-java-3ce15ee0f2ef?source=collection_archive---------22-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e1c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">4种不同类型的快速介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39e48a4cd6f92f26e6d118a62ad89047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hgs8lY-W2euj16E3tNajfw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Alberto Triano 在<a class="ae ky" href="/s/photos/nesting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在面向对象的语言中，嵌套类或内部类是完全在另一个类中声明的类。</p><p id="87f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们将逻辑上绑定在一起的类组合在一起，以增加封装，从而获得更简洁和可维护的代码。</p><p id="7524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是对4种嵌套类的快速、非深入的概述。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="6ba1" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">TABLE OF CONTENTS</strong></span><span id="6819" class="mh mi it md b gy mn mk l ml mm">-  <a class="ae ky" href="#b6c5" rel="noopener ugc nofollow">Static Nested Classes</a><br/>-  <a class="ae ky" href="#7bc6" rel="noopener ugc nofollow">Non-Static Classes / Inner Classes</a><br/>-  <a class="ae ky" href="#10d1" rel="noopener ugc nofollow">Local Classes</a><br/>-  <a class="ae ky" href="#85cf" rel="noopener ugc nofollow">Anonymous Classes</a><br/>-  <a class="ae ky" href="#7c10" rel="noopener ugc nofollow">Shadowing</a><br/>-  <a class="ae ky" href="http://63e0" rel="noopener ugc nofollow" target="_blank">Conclusion</a></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b6c5" class="mo mi it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">静态嵌套类</h1><p id="bb01" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">嵌套类的定义与任何其他类一样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ae47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe nm nn no md b">static</code>成员一样，<code class="fe nm nn no md b">static</code>嵌套类被绑定到类本身，而不是它的实例。这意味着我们可以实例化它，而不用先创建一个<code class="fe nm nn no md b">Outer</code>的中间实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的行为就像任何其他类一样，并遵循相同的规则:</p><ul class=""><li id="563f" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">支持所有的<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html" rel="noopener ugc nofollow" target="_blank">访问修饰符</a></li><li id="3547" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">可以定义<code class="fe nm nn no md b">static</code>和非<code class="fe nm nn no md b">static</code>成员</li><li id="c57f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">无法访问其封闭类的非<code class="fe nm nn no md b">static</code>成员</li></ul><p id="4506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更简单的用法，我们甚至可以<code class="fe nm nn no md b">import</code>嵌套类去掉外部类前缀:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="b6ae" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">何时使用</h2><p id="79e3" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">嵌套类的行为就像任何其他顶级类一样，也应该如此对待。主要优点是包装方便。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7bc6" class="mo mi it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">非静态嵌套类/内部类</h1><p id="46ae" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">非<code class="fe nm nn no md b">static</code>嵌套类也称为<em class="oo">内部类:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="301d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内部的<code class="fe nm nn no md b">Nested</code>类被绑定到其封闭类的实例，而不是与<code class="fe nm nn no md b">Outer</code>类类型相关联。</p><p id="8acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这种关系，它可以访问封闭类的所有成员，而不仅仅是<code class="fe nm nn no md b">static</code>成员。但是内部类本身不能定义任何<code class="fe nm nn no md b">static</code>成员。</p><p id="be29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实例化内部类，我们现在需要其封闭类的一个实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ff97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不再只有一种类型，即“仅仅”嵌套在另一个类下。内部类与其封闭类的实际实例紧密绑定，不能再独立存在。</p><h2 id="face" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">序列化</h2><p id="a6b5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">仅仅因为封闭类可能是可序列化的，并不意味着嵌套类也是自动可序列化的。</p><p id="e39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与任何其他成员一样，我们必须确保他们也执行<code class="fe nm nn no md b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html" rel="noopener ugc nofollow" target="_blank">java.io.Serializable</a></code>。或者我们可能以一个<code class="fe nm nn no md b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/io/NotSerializableException.html" rel="noopener ugc nofollow" target="_blank">java.io.NotSerializableException</a></code>结束。</p><h2 id="31d4" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">何时使用</h2><p id="b28b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">内部类的优势在于与它们的封闭类有更深的联系，包括对其所有成员的完全访问。但是这种联系会导致不明显的记忆保持。在嵌套实例垃圾收集之前，封闭类也不能垃圾收集。</p><h2 id="3a95" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">资源</h2><p id="add0" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3" rel="noopener ugc nofollow" target="_blank">内部类和封闭实例</a> (JLS)</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10d1" class="mo mi it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">本地课程</h1><p id="fa28" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">局部类是内部类的一种特殊形式。</p><p id="ea92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在任何类型的块(例如方法)中定义一个<em class="oo">局部类</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="41e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像内部类一样，我们可以访问封闭类的所有成员。但是我们不能给类提供访问修饰符，因为它只能“本地”使用。</p><h2 id="38f8" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">何时使用</h2><p id="d5e5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们可以用内部类实现同样的行为。但是它不会像局部类那样将逻辑强有力地绑定到特定的块。</p><p id="befd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的工具，可以更好地将逻辑分组在一起，并且对于本地类，我们可以使用尽可能小的内存占用。</p><h2 id="3e5b" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">资源</h2><p id="f71a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.3" rel="noopener ugc nofollow" target="_blank">局部类声明</a> (JLS)</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="85cf" class="mo mi it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">匿名类</h1><p id="278e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><em class="oo">匿名类</em>不是定义一个嵌套类，而是通过实例化一个预先存在的类型来创建一个新类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚基于接口<code class="fe nm nn no md b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" rel="noopener ugc nofollow" target="_blank">Runnable</a></code>创建了一个新类，因为它没有名字，所以它是<em class="oo">匿名的</em>。</p><p id="f70b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不仅接口可以用于创建匿名类。我们还可以扩展其他非<code class="fe nm nn no md b">final</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="698a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个专门的<code class="fe nm nn no md b">List&lt;String&gt;</code>实现，完全不需要创建一个单独的类，非常简洁！</p><p id="2c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建语法总是遵循相同的结构:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="3d2a" class="mh mi it md b gy mj mk l ml mm"><strong class="md iu">new</strong> &lt;&lt;Type&gt;&gt;(&lt;&lt;constructor arguments&gt;&gt;) {<br/>    // declarations / overrides<br/>};</span></pre><p id="7135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">匿名类声明是表达式，并且<strong class="lb iu"> <em class="oo">必须</em> </strong>是语句的一部分，要么在块中，要么作为成员声明本身。</p><h2 id="d388" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">匿名类对Lambdas</h2><p id="a24b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">随着λ表达式的出现，我们终于有了一种更简单的方法来当场实现类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个谓词的功能是相同的，所以我们可能认为lambdas只是匿名类的语法糖。生成的字节码有所不同，表明它可能以相同的方式运行，但不是以完全相同的方式完成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="618a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lambda使用操作码<code class="fe nm nn no md b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/multiple-language-support.html#invokedynamic" rel="noopener ugc nofollow" target="_blank">invokedynamic</a></code>，这允许JVM进行更动态的方法调用。</p><h2 id="63f8" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">何时使用</h2><p id="c948" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">匿名类非常适合小型的、特定的现场实现。即使λ可能就足够了。</p><p id="e74a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它们的简单性，与局部类或内部类相比也有许多缺点:</p><ul class=""><li id="e288" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">没有名字会让stacktraces更难追踪</li><li id="3daf" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">只能使用单一类型，没有额外的接口等。</li><li id="29cb" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">更复杂的语法</li></ul><h2 id="2c1a" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">资源</h2><ul class=""><li id="b789" class="np nq it lb b lc nf lf ng li op lm oq lq or lu nu nv nw nx bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.9.5" rel="noopener ugc nofollow" target="_blank">匿名阶级宣言</a> (JLS)</li><li id="4dc1" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">虚拟机中的匿名类(Oracle)</li><li id="77ff" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">Java函数式编程:语法suga(中等)</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7c10" class="mo mi it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak">遮蔽</strong></h1><p id="b439" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在软件开发中，<em class="oo">隐藏</em>是在更深的范围内对成员的重新声明。这意味着我们可以在嵌套类中重用变量名，还可以通过在调用前添加前缀来访问隐藏成员:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="63e0" class="mo mi it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="e75f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们可以逻辑地将类分组在一起，或者当场创建匿名实例，这很好。但是我们需要仔细决定我们真正想要和需要的嵌套类的类型。特别是对于<a class="ae ky" href="https://medium.com/@benweidig/best-of-java-8-e5aa8cbed673#f751" rel="noopener">功能接口</a>来说，lambda可能是一个更简洁的解决方案。</p><h2 id="9790" class="mh mi it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">额外资源</h2><ul class=""><li id="bdbb" class="np nq it lb b lc nf lf ng li op lm oq lq or lu nu nv nw nx bi translated">Java教程:嵌套类(甲骨文)</li><li id="d4cd" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Inner_class" rel="noopener ugc nofollow" target="_blank">内部类</a>(维基百科)</li><li id="ea4a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://www.baeldung.com/java-nested-classes" rel="noopener ugc nofollow" target="_blank">Java中的嵌套类</a> (Baeldung)</li><li id="ac0c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://www.tutorialspoint.com/java/java_innerclasses.htm" rel="noopener ugc nofollow" target="_blank"> Java内部类</a> (Tutorialspoint)</li></ul></div></div>    
</body>
</html>