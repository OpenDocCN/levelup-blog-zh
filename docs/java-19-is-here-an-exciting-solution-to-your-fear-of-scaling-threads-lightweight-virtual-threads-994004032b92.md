# Java 19 来了:这是一个令人兴奋的解决方案，它解决了您对扩展线程的恐惧——轻量级虚拟线程！

> 原文：<https://levelup.gitconnected.com/java-19-is-here-an-exciting-solution-to-your-fear-of-scaling-threads-lightweight-virtual-threads-994004032b92>

> Java 19 引入了令人兴奋的预览特性，虚拟线程！在这里，您将了解 java 线程的内部结构，以及为什么我们甚至需要虚拟线程，以及它们是如何工作的！

![](img/c5aa80d000b2e3defeb449d4590e806f.png)![](img/b51f328ec52ff8c3f03c5a3ea8cbf472.png)

JJ·英在 Unsplash 上的照片，[杰米·霍顿](https://unsplash.com/@haughters?utm_source=medium&utm_medium=referral)在 [Unsplash 上的照片](https://unsplash.com?utm_source=medium&utm_medium=referral)

我稍后将回到那个猴子，让我们从理解现有的 Java 线程开始，好吗？

# 什么是 Java 线程？

1.  Java 中的线程相当于操作系统线程(平台线程)
2.  那是什么意思？我们先来了解一下线程。

线程只是在 CPU 内核上执行的指令的 T4 序列，将指令的这个*序列分配给 CPU 内核是由调度程序完成的。所以一个线程可以被认为是一系列指令和一个调度器的组合。指令序列*是指令序列*的延续*。**

> J *VM 使用底层操作系统提供的*延续*和*调度器*的实现，因此 Java 线程被视为等同于平台线程。*

# 平台线程有什么不好的地方？

> 规模

1.  一个服务器可以处理一百万个并发用户请求，但是 JVM 使用操作系统的线程来实现 Java 线程，不能有效地处理几千个以上的请求。

但是为什么我们不能扩展平台线程呢？

1.  创建和管理平台线程必须进行系统调用，这很慢(这就是我们使用线程池的原因)
2.  操作系统只能管理有限数量的线程。
3.  平台线程的存在会占用大量内存。
4.  每当出现阻塞 I/O(输入/输出)操作(如网络调用或存储读取)时，线程必须等待，直到它从网络或存储获得响应，此时线程不需要 CPU 核心，它们进入等待状态，直到接收到数据，这就是上下文切换。当您有大量 I/O 时，线程只是在等待数据，CPU 没有得到充分利用。
5.  将线程状态从*运行*更改为*等待*意味着将线程上下文(CPU 寄存器+程序计数器+堆栈)从 CPU 内核中取出，存储该状态，并将另一个线程分配给 CPU(这就是上下文切换)**需要大量时间和内存。**

所以，

> 1.平台线程的上下文切换在资源方面是昂贵的。
> 
> 2.平台线程只是在那里等待数据，什么也不做，这些数据本可以用于其他 CPU 相关的操作。
> 
> 3.如果您有很多 I/o，CPU 就没有得到充分利用。

# 好吧，但是像 Project Reactor 这样的反应式框架难道不能解决这些问题吗？

1.  是也不是，反应式编程通过让正在运行的线程进行阻塞调用，然后立即执行程序的其余部分，而不等待来自存储或网络的数据，从而提供非阻塞 I/O。

但是那跳过的阻塞代码(网络调用或存储读取)怎么办？

1.  它保持一个事件循环，不断检查套接字是否从网络/存储接收到数据，一旦接收到数据，它将由另一个线程处理，因此运行的线程在这里不会被阻塞。
2.  **但是，但是，但是**如果你从事过反应式代码的工作，你就会知道它很难阅读，很难调试，很难进行单元测试，编码风格不适合现有的同步代码风格，还需要来自数据源的反应式模型支持。

# 那么，什么是虚拟线程呢？

1.  它是由 JVM 调度程序管理的线程，不同于由 OS 调度程序管理的平台线程。它扩展了 *java.lang.Thread* 类，但不受操作系统调度程序的管理。
2.  虚拟线程由 JVM 实现的*延续*和*调度器*组成。*延续*是由 JVM 调度器分配给*平台线程*的指令*序列。目前，JVM 使用 ForkJoinPool 作为调度程序。*
3.  虚拟线程可以使用多个平台线程来完成工作。平台线程在 Java 文档中也被称为**载体线程**。

> 您将任务分配给虚拟线程→ Java scheduler 将虚拟线程分配给平台线程→虚拟线程要求平台线程完成工作。

3.**关键点是**，如果一个虚拟线程有阻塞 I/O 操作，它将从平台线程中分离出来，另一个虚拟线程将被分配给平台线程，使平台线程保持运行状态。虚拟线程的上下文将存储在堆本身，因此阻塞和恢复虚拟线程是廉价的。

4.值得注意的是，这里阻塞的是虚拟线程，而不是平台线程。因为虚拟线程在应用程序上下文中，所以阻塞虚拟线程比阻塞平台线程便宜得多。

5.因此，具有**高并发请求**和较少 CPU 操作的**线程** **花费大量时间等待**的应用程序将具有**更高的吞吐量**和**虚拟线程。**并发请求将由虚拟线程处理，它们将进入等待状态**，无需**繁重的上下文切换，同时平台线程将充分利用 CPU。

6.仅阻塞调用的应用程序(比如说 API，它只是结合了两个其他网络调用的结果)可以很好地扩展虚拟线程，因为虚拟线程将进入等待状态，直到它们接收到数据，而平台线程将继续使用 CPU。

> 因为创建、阻塞和恢复虚拟线程更便宜，所以它们是轻量级的！

## 虚拟线程如何解除阻塞/暂停？

1.  当虚拟线程阻塞 I/O 时，会有一个 JVM 范围的 Read-Poller(*sun . nio . ch . Poller*)线程，它会在被阻塞的虚拟线程和将接收数据的相应套接字之间创建一个映射。
2.  轮询器线程是一个连续的事件循环，它不断检查映射到特定线程的套接字是否接收到数据，如果是，它唤醒相应的虚拟线程，虚拟线程从最后停止的指令开始继续执行。
3.  *Java . internal . VM . continuation*是一个在虚拟线程中使用的公共低级 API，它可以在任何需要的时候产生并继续。

## 如何创建虚拟线程？

用于测试的示例代码:

# 虚拟线程的优势是什么？

1.  以简单的每请求线程风格编写的应用程序可以通过优化资源利用来扩展。您可以为每个传入的请求生成一个虚拟线程。
2.  如果用 *java.lang.Thread* 写现有代码，集成虚拟线程很容易。
3.  您不需要为虚拟线程创建一个池，因为创建、暂停和恢复虚拟线程的成本很低。
4.  使用现有的 JDK 工具，轻松对虚拟线程进行故障排除、调试和分析。
5.  您可以编写同步和阻塞代码，因为阻塞操作对于虚拟线程来说是廉价的。

**虚拟线程的当前限制:**

1.  当虚拟线程在`synchronized`块或方法中时，它不能从相关的平台线程中分离，因为同步块在内部使用堆栈的地址，目前这是一个限制，但根据官方文件，这可能会被删除。使用可重入锁而不是同步块可以很容易地解决这个问题。

它是作为一个预览功能推出的，所以请尝试一下，分享您的反馈，并报告错误，我很高兴看到它成为语言的一部分，请在评论中自由表达您的想法。

*就这样。感谢 Project Loom 多年来在虚拟线程方面的工作，感谢阅读！*

如果您从这篇文章中学到了一些新东西，请点击关注和订阅按钮获取这些内容！

***还对那只猴子感兴趣？***

> 在我最疯狂的想象中，我认为虚拟线程是骑着大象(沉重的平台线程)完成工作的猴子。它们可以从一只大象跳到另一只大象，当没有工作要做时(阻塞 I/O)，就下来让其他大象骑，这样大象就永远不会坐着。

查看我关于流式 API 的另一篇文章，

[](/8-years-of-java-stream-api-understand-streams-through-8-questions-bd9e5d9d8bc) [## 8 年 Java Stream API，通过 8 个问题了解 Streams！

### 是的，自从 Java SE 8 发布流 API、函数接口、时间 API 等等以来，已经有 8 年了…

levelup.gitconnected.com](/8-years-of-java-stream-api-understand-streams-through-8-questions-bd9e5d9d8bc)