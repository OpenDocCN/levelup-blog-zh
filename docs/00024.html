<html>
<head>
<title>componentDidMakeSense — React Component Lifecycle Explanation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">componentidmakesense—反应组件生命周期解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/componentdidmakesense-react-lifecycle-explanation-393dcb19e459?source=collection_archive---------0-----------------------#2017-10-16">https://levelup.gitconnected.com/componentdidmakesense-react-lifecycle-explanation-393dcb19e459?source=collection_archive---------0-----------------------#2017-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a6bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解React生命周期方法以及何时/如何使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d7d67d29fc4975f0130a3067bbe97d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8hTumGAPQMYZIvfgQMfPA.jpeg"/></div></div></figure><p id="bf2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React令人难以置信，因为它允许您使用声明性API来构建UI。您告诉React您希望界面是什么样子，它会处理其余的事情。</p><div class="lq lr gp gr ls lt"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">学习React -最佳React教程(2018) | gitconnected</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">React的前48门课程。教程由开发者提交并投票，让你找到最好的反应…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">gitconnected.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh ks lt"/></div></div></a></div><p id="7933" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当用户与应用程序交互时，状态会发生变化，从而导致DOM更新。React提供了一组方法，可以在更新过程中的任何时候无缝地拦截更改，并控制UI。组件生命周期通常是真正掌握React的最后一部分，本文将确保您牢牢掌握。</p><p id="7f3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件的生命周期可以定义为从组件第一次被插入DOM开始的时间，组件在DOM中的整个时间，以及组件从DOM中被移除的时间。代码中的每个React组件都有唯一的生命周期。</p><h2 id="7aa8" class="mi mj it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">生命周期概述</h2><p id="1b58" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">生命周期方法是允许你读取状态变化和控制UI更新的钩子。生命周期可以分为3类:</p><ol class=""><li id="4c11" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated"><strong class="kw iu">挂载:</strong>组件正在被添加到DOM中。</li><li id="bcc1" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated"><strong class="kw iu">更新:</strong>组件接收改变属性或状态，并在组件被重新渲染时被调用。</li><li id="b327" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated"><strong class="kw iu">卸载:</strong>正在从DOM中删除组件。</li></ol><p id="9c34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生命周期方法提供了接管这些步骤的切入点。任何以<code class="fe nu nv nw nx b">componentWill</code>开头的方法都意味着您在事件发生之前访问它，任何以<code class="fe nu nv nw nx b">componentDid</code>开头的方法都意味着您在事件发生之后捕获它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/b2dd7a3eb37c52d6cd856eb5e03b7a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjHABzqbwHBPBP_xPRP_4A.png"/></div></div></figure><h2 id="beb3" class="mi mj it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">增加</h2><ul class=""><li id="0e78" class="ng nh it kw b kx nb la nc ld nz lh oa ll ob lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">constructor()</code></li><li id="8568" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">componentWillMount()</code></li><li id="5112" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">render()</code></li><li id="e847" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">componentDidMount()</code></li></ul><h2 id="88ed" class="mi mj it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">更新</h2><ul class=""><li id="7015" class="ng nh it kw b kx nb la nc ld nz lh oa ll ob lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">componentWillReceiveProps()</code></li><li id="63ff" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">shouldComponentUpdate()</code></li><li id="3f48" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">componentWillUpdate()</code></li><li id="cfbc" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">render()</code></li><li id="0054" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">componentDidUpdate()</code></li></ul><h2 id="cfe7" class="mi mj it bd mk ml mm dn mn mo mp dp mq ld mr ms mt lh mu mv mw ll mx my mz na bi translated">卸载</h2><ul class=""><li id="443e" class="ng nh it kw b kx nb la nc ld nz lh oa ll ob lp oc nm nn no bi translated"><code class="fe nu nv nw nx b">componentWillUnmount()</code></li></ul><h1 id="da07" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">构造器</h1><p id="2733" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在创建组件时和挂载(添加到DOM中)之前调用这个方法。它的主要用途是为组件的方法初始化状态和<code class="fe nu nv nw nx b">.bind(this)</code>。如果你没有做到这两点，那么就不需要构造函数了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="8bf1" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">组件将安装</h1><p id="ee70" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">这个方法在组件被添加到DOM / <code class="fe nu nv nw nx b">render()</code>之前执行。通常建议您使用<code class="fe nu nv nw nx b">constructor</code>，但是这个方法仍然包含在API中，主要是为了向后兼容。</p><p id="33c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你应该避免在这个方法中调用任何引起副作用的函数，因为<code class="fe nu nv nw nx b">setState</code>不会触发一个变化，也没有DOM可以与之交互。</p><p id="194d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oq">注意，这也是在服务器上调用的唯一生命周期方法。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><div class="lq lr gp gr ls lt"><a href="https://gitconnected.com/portfolio-api" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">组合API —轻松发展您的编码事业| gitconnected</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">消除在每个单独位置手动更新您的详细信息的痛苦。只需在您的中更改一次数据…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">gitconnected.com</p></div></div><div class="mc l"><div class="os l me mf mg mc mh ks lt"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h1 id="7e26" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">组件安装</h1><p id="c431" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">您的组件现在已经呈现并存在于DOM中。这是您应该启动AJAX请求、添加事件监听器和执行任何需要DOM的设置的时候。在此方法期间或之后的任何时间调用<code class="fe nu nv nw nx b">setState</code>将导致重新渲染。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="e836" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">componentWillReceiveProps</h1><p id="4093" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">当你的组件从它的父组件收到新的道具时，<code class="fe nu nv nw nx b">componentWillReceiveProps(nextProps)</code>被触发。这是一个伟大的时间来检查是否有变化，在即将到来的道具相比，你目前的道具，并触发一个新的价值为基础的状态变化。一个常见的用例是根据变化重置状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="f0e5" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">shouldComponentUpdate</h1><p id="8fa4" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">这种方法纯粹是为了提高性能。渲染和<a class="ae ot" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">协调</a>在React中开销很大。<code class="fe nu nv nw nx b">shouldComponentUpdate(nextProps, nextState)</code>为开发人员提供了从该方法返回布尔值<code class="fe nu nv nw nx b">true/false</code>的能力，该方法控制React是否应该执行协调操作和DOM更新。</p><p id="9a56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认行为是让React呈现每个更新，这在大多数情况下都有效。如果<code class="fe nu nv nw nx b">shouldComponentUpdate()</code>返回<code class="fe nu nv nw nx b">false</code>，那么<code class="fe nu nv nw nx b">componentWillUpdate()</code>、<code class="fe nu nv nw nx b">render()</code>和<code class="fe nu nv nw nx b">componentDidUpdate()</code>将不会被调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="8369" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">组件将更新</h1><p id="1271" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">当接收到新的道具或状态时，React会在渲染之前立即调用此方法。<code class="fe nu nv nw nx b">componentWillUpdate(nextProps, nextState)</code>用处不大，大概应该避免(类似于<code class="fe nu nv nw nx b">componentWillMount</code>)。此时你不应该做任何会改变状态的事情——如果你需要在渲染前做任何事情，请使用<code class="fe nu nv nw nx b">componentWillReceiveProps</code>。</p><p id="91b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oq">注意，在初始渲染时不会调用这个方法。</em></p><h1 id="de77" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">componentDidUpdate</h1><p id="4eb6" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">React为您构建了一个全新的UI后，<code class="fe nu nv nw nx b">componentDidUpdate(prevProps, prevState)</code>会立即被调用。这是与DOM交互或根据新接口的外观实例化新网络请求的好时机。</p><h1 id="821b" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">组件将卸载</h1><p id="0f78" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">您的组件曾经有过辉煌的一生，现在是它离开UI的时候了。这是清理与添加和维护组件相关的一切的时刻，而组件是在UI上存在的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="d075" class="od mj it bd mk oe of og mn oh oi oj mq jz ok ka mt kc ol kd mw kf om kg mz on bi translated">奖励:componentDidCatch</h1><p id="5971" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated"><code class="fe nu nv nw nx b">componentDidCatch(error, info)</code>是React 16中新增的一个生命周期。React臭名昭著，因为如果React应用程序中出现JavaScript错误，整个应用程序就会崩溃。它破坏了React的内部状态，破坏了应用程序并产生了神秘的错误消息。<code class="fe nu nv nw nx b">componentDidCatch</code>通过为实现该方法的组件的子组件捕获组件树中发生的任何JavaScript错误来解决这个问题。它能够捕获错误并显示回退UI。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><p id="0905" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oq">如果您觉得这篇文章有帮助，请点击</em>👏<em class="oq">。</em> <a class="ae ot" href="https://medium.com/@treyhuffine" rel="noopener"> <em class="oq">关注我</em> </a> <em class="oq">了解更多关于React、Node.js、JavaScript和开源软件的文章！你也可以在</em><a class="ae ot" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="oq">Twitter</em></a><em class="oq">或者</em><a class="ae ot" href="https://gitconnected.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="oq">git connected</em></a><em class="oq">上找到我。</em></p></div></div>    
</body>
</html>