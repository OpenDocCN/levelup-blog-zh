<html>
<head>
<title>Build your own self-hosted CI/CD workflow with GitHub actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作构建您自己的自托管CI/CD工作流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-your-own-self-hosted-ci-cd-workflow-with-github-actions-ec9ee1dcd800?source=collection_archive---------5-----------------------#2021-06-15">https://levelup.gitconnected.com/build-your-own-self-hosted-ci-cd-workflow-with-github-actions-ec9ee1dcd800?source=collection_archive---------5-----------------------#2021-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/27d231c7c9777704530e69a8b3f70f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__-SQljOXwab7mF_PulWtg.png"/></div></div></figure><p id="fb6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GitHub引入了<strong class="kd iu"> GitHub Actions </strong>，这使得开发者能够直接从他们的GitHub库自动化工作流。软件开发生命周期(SLDC)工作流，如构建、单元测试、端到端测试，可以通过GitHub快速完成，无需使用任何第三方工具或专用资源。您可以自定义GitHub操作或使用GitHub Marketplace中提供的标准模板。此外，GitHub actions提升了操作系统环境(Windows、OSX、Linux)，使用户能够执行或运行任何使用操作系统相关工作的工作流。</p><p id="d321" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章将集中在创建我们的工作流托管在我们的专用服务器(自托管)。与GitHub托管的运行程序相比，自托管的运行程序提供了对硬件、操作系统和软件工具的更多控制。例如，您可以选择创建具有更多处理能力或内存的自定义硬件配置，以使用自托管运行程序运行更大的作业。自托管runners还允许我们安装您本地网络上可用的软件，并选择GitHub托管runners不提供的操作系统。此外，这种自托管工作流可以进行功能扩展，以创建我们的CI/CD工作流。</p><h1 id="0cc8" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Github操作入门</h1><p id="3301" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">为此，让我们考虑一个使用MySQL作为数据库的小型express应用程序。我们将使用PM2，它是JavaScript runtime Node.js的进程管理器</p><p id="cf06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GitHub使用<strong class="kd iu"> YAML </strong>来配置动作，所以我们必须在应用程序中添加YAML来定义你的工作流配置。我们应该将这个YAML配置文件添加到<strong class="kd iu">中。github/workflows </strong>目录，我们应该将它添加到项目的根目录中。姑且称之为<strong class="kd iu"> nodejs.yaml. </strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f68f" class="ml la it mh b gy mm mn l mo mp">name: My CI-CD </span><span id="13a9" class="ml la it mh b gy mq mn l mo mp">on:<br/>  push: <br/>    branches: [master]</span><span id="fc5b" class="ml la it mh b gy mq mn l mo mp">jobs: <br/>  build: <br/>    runs-on: <strong class="mh iu">ubuntu-latest</strong><br/>   <br/>    steps: <br/>      — uses: actions/checkout@v2 <br/>      — run: | <br/>          cd my-express-app &amp;&amp; pwd<br/>          npm i<br/>          export DB_HOST=${{ <strong class="mh iu">secrets.DB_HOST</strong> }} <br/>          export DB_NAME=${{ <strong class="mh iu">secrets.DB_NAME</strong> }} <br/>          export DB_USER=${{ <strong class="mh iu">secrets.DB_USER</strong> }} <br/>          export DB_PASS=${{ <strong class="mh iu">secrets.DB_PASS</strong> }} <br/>          export APP_PORT=${{ <strong class="mh iu">secrets.APP_PORT</strong> }} <br/>          <strong class="mh iu">pm2 </strong>delete all — || : <br/>          <strong class="mh iu">pm2 </strong>start index.js — name express-api -i 2</span></pre><p id="0dc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您保存并提交该文件，并将其推送到您的GitHub存储库，它将自动检测工作流目录下的YAML文件并创建一个操作。在触发一个动作或将新的变更推送到存储库之前，让我们来看一下YAML配置。YAML被配置为触发对主分支的推送(或合并拉取请求)操作，该作业将在最新版本的ubuntu中运行。您可以在按键<strong class="kd iu">run-on下看到此信息。</strong>这个键是做自托管动作运行器时最重要的，在<strong class="kd iu">步骤下，</strong>我们使用action<a class="ae mr" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">actions/check out @ v2</strong></a><strong class="kd iu">，</strong>从库中拉下代码。</p><p id="ed26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">YAML的另一个独特之处是使用像<strong class="kd iu"> secrets这样的密钥。DB_HOST。我们可以将这些秘密密钥</strong>存储在GitHub中，这可以通过导航到<strong class="kd iu">设置下的<strong class="kd iu">秘密</strong>来完成。</strong>要创建新的密钥，请点击新密钥按钮并添加必要的密钥。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/6ae53919430bade4872c2488b886daaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4bO_wG5WBqGrhMDek38Cg.png"/></div></div></figure><p id="05be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们触发这个动作，它将在GitHub中启动一个Ubuntu环境，并运行YAML文件中提到的任务。但是我们想要的是在我们自己的环境/服务器中运行它。为了让这个动作在我们的服务器上工作，我们需要再做一些配置。首先，我们需要ssh到我们的服务器，并在服务器中安装自托管的runner。</p><h1 id="0858" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">走向自主托管</h1><p id="e88c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">对于这个例子，我们将使用Ubuntu 20.04服务器。“设置”-&gt;“操作”下提供了以下命令。在这里，您必须选择与您的服务器相同的操作系统。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/3e5497bda68f600b5b79eac537807ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2KKtHGayPXtu5hk34eERA.png"/></div></div></figure><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e1cb" class="ml la it mh b gy mm mn l mo mp">// Create a folder<br/>$ mkdir actions-runner &amp;&amp; cd actions-runner</span><span id="6384" class="ml la it mh b gy mq mn l mo mp">// Download the latest runner package<br/>$ curl -O -L <a class="ae mr" href="https://github.com/actions/runner/releases/download/v2.263.0/actions-runner-linux-x64-2.263.0.tar.gz//" rel="noopener ugc nofollow" target="_blank">https://github.com/actions/runner/releases/download/v2.263.0/actions-runner-linux-x64-2.263.0.tar.gz</a></span><span id="6f9d" class="ml la it mh b gy mq mn l mo mp"><a class="ae mr" href="https://github.com/actions/runner/releases/download/v2.263.0/actions-runner-linux-x64-2.263.0.tar.gz//" rel="noopener ugc nofollow" target="_blank">//</a> Extract the installer<br/>$ tar xzf ./actions-runner-linux-x64–2.263.0.tar.gz<br/></span><span id="f7ea" class="ml la it mh b gy mq mn l mo mp">// Create the runner and start the configuration experience<br/>$ ./config.sh --url <a class="ae mr" href="https://github.com/TRomesh/sathsara" rel="noopener ugc nofollow" target="_blank">https://github.com/&lt;username&gt;/</a>&lt;reponame&gt; --token &lt;given key&gt;</span><span id="d117" class="ml la it mh b gy mq mn l mo mp">// Last step, run it!<br/>$ ./run.sh</span></pre><p id="290c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将启动自托管运行程序。现在，您必须编辑YAML文件，以表明我们正在运行一个自托管的运行程序。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="421a" class="ml la it mh b gy mm mn l mo mp"><br/>runs-on: <strong class="mh iu">self-hosted</strong></span></pre><p id="5b11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在是运行/触发动作的时候了。首先，您必须提交一些更改并进行推送，这将触发操作。如果一切顺利，你最终会得到这样的结果。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/24f4416aa4bb9ab8a5983f78266bf389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-4HyHGea9scT7AMO7YWnw.png"/></div></div></figure><p id="d60f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您ssh到您的服务器，您可以注意到您的代码已经被拉入您的服务器。另外，请注意，服务器是用给定的密钥启动的，这些密钥可以在Github keys上找到。这个工作流可以通过为自托管运行程序提供服务来进行改进，这样当您重新启动服务器时，您就不必手动启动自托管运行程序。我们可以通过以下步骤实现这一点。</p><ol class=""><li id="3894" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">如果自托管runner应用程序当前正在运行，请将其停止。</li><li id="dea2" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">使用以下命令安装服务:<br/> <code class="fe nj nk nl mh b">sudo ./svc.sh install</code></li></ol><p id="e4d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.使用以下命令启动服务:<br/> <code class="fe nj nk nl mh b">sudo ./svc.sh start</code></p><p id="657b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将启动自托管runner作为服务。您可以通过以下命令检查该服务的状态。</p><p id="425b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nj nk nl mh b">sudo ./svc.sh status</code></p><p id="7ec0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将输出类似这样的内容</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/76bd8449156b7b15e745d7da23bf9312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ec1o0PfD9IZOSl2g0x14lQ.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">Github自托管runner服务</figcaption></figure><p id="08b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Feather可以通过告诉GitHub actions仅在引入对特定目录路径的更改时触发构建来改进上述工作流。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="555e" class="ml la it mh b gy mm mn l mo mp">name: My CI-CD<br/>on:  <br/>  push:<br/>    <strong class="mh iu">paths</strong>:<br/>      - <strong class="mh iu">"api/**"</strong><br/>      - <strong class="mh iu">"mobile/**"</strong><br/>    branches: [master, staging]</span></pre><p id="bf4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过上面的YAML配置，您可以看到我们只为特定的路径配置了动作，如<strong class="kd iu"> api </strong>和<strong class="kd iu"> mobile。</strong>因此，每当您将更改推送到上述两个目录时，runner将开始在您的服务器中进行拉取和构建。</p><h1 id="d34c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">自动发布移动应用程序</h1><p id="1f37" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">正如你所看到的，GitHub动作允许你灵活地通过你的配置和插件/动作运行器提供的特性来扩展特性。在这一部分，让我们看看如何自动化我们的移动应用程序的发布工作流。</p><p id="98ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个例子，我将使用一个名为<a class="ae mr" href="https://github.com/expo/expo-github-action" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">expo-github-action</strong></a><strong class="kd iu"/>的特定动作工作流，因为我有一个使用Expo平台的react-native应用程序。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="31ab" class="ml la it mh b gy mm mn l mo mp"><strong class="mh iu">publish</strong>:    <br/>  name: Mobile Publish<br/>  runs-on: ubuntu-latest    <br/>  steps:      <br/>    - uses: actions/checkout@v2<br/>    - uses: actions/setup-node@v1<br/>      with:      <br/>        node-version: 14.x<br/>    - uses: <strong class="mh iu">expo/expo-github-action@v5</strong><br/>        with:          <br/>          expo-version: 4.x<br/>          expo-token: ${{ <strong class="mh iu">secrets.EXPO_TOKEN</strong> }}<br/>    - run: |         <br/>        rm -rf client  <br/>        rm -rf api  <br/>        mv mobile/* . <br/>        rm -rf mobile  <br/>    - run: yarn install    <br/>    - run: <strong class="mh iu">expo publish  </strong><br/>    - run: <strong class="mh iu">expo build:android</strong></span></pre><p id="c958" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将上面的publish部分添加到node.js.yml文件将使您能够将应用程序发布到expo平台。请注意，我们已经将<strong class="kd iu"> EXPO_TOKEN </strong>添加到github密钥中，EXPO将需要它来发布您的应用程序。您也可以通过这种配置构建您的应用程序。配置的最后一行说要构建应用程序的android版本。该构建所需的依赖项和其他相关应用程序由<strong class="kd iu">Expo/Expo-github-action @ V5</strong>动作工作流<strong class="kd iu">提供。</strong></p><h1 id="0463" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="56f8" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">总之，Github Actions是实现CI/CD工作流的最好和最简单的方法之一。Github Actions非常灵活，它允许您自定义动作工作流，直到您可以在专用服务器上运行。对于不同类型的应用程序和不同的CI/CD工作流，有许多可用的操作工作流。所有这些都是免费的，无需使用任何第三方服务，如<a class="ae mr" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> Circle CI </a>等等。</p><p id="3b1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Github操作的简单性也使它成为初学者开始使用CI/CD工作流和自动化的一个很好的选择。最后，感谢您花时间阅读本文。我想看看你下面的问题和评论。</p><p id="2079" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">干杯！</p><h1 id="72d0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">了解更多信息</h1><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/jotai-atom-based-state-management-for-react-1ce8fd380296"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">jotai:React的基于原子的状态管理</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">在过去的几年里，国家管理有了很大的发展。有很多库和方法可以让你…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="od l"><div class="oe l of og oh od oi jz nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/hookstate-the-simplest-state-management-tool-b02f7d3b01a4"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">最简单的状态管理工具</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">小型、最小、简洁、可扩展、基于钩子的状态管理库</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="od l"><div class="oj l of og oh od oi jz nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://medium.com/swlh/intro-to-recoil-d689a77c5f04" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">反冲介绍</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">反冲是一个反应的状态管理库，是由脸书的实验和开放源码…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="ok l of og oh od oi jz nu"/></div></div></a></div></div></div>    
</body>
</html>