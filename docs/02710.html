<html>
<head>
<title>JavaScript Interview Questions — Functions and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试问题—函数和对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-interview-questions-functions-and-objects-74694bd90a8e?source=collection_archive---------17-----------------------#2020-03-30">https://levelup.gitconnected.com/javascript-interview-questions-functions-and-objects-74694bd90a8e?source=collection_archive---------17-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/51e2f4c14409b4c2f0ca1b50db10dce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ENaqjrMH1Kz3fCt6"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">保罗·布兰道在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f3b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="4750" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看一些函数和宾语问题。</p><h1 id="81d5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是箭头函数？</h1><p id="c545" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">箭头函数是JavaScript中定义函数的一种新方法。从ES2015开始提供。</p><p id="5a16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它消除了与<code class="fe mh mi mj mk b">this</code>的混淆，因为它没有绑定到<code class="fe mh mi mj mk b">this</code>，所以它们不能用作构造函数。</p><p id="7fe7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们也不能被提升，所以它们只能在被定义后使用。</p><p id="6045" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它们没有绑定到<code class="fe mh mi mj mk b">arguments</code>对象，所以我们不能像在<code class="fe mh mi mj mk b">function</code>声明中那样将参数传递给箭头函数。</p><p id="d87e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了从arrow函数中获取参数，我们使用rest语法，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1650" class="mt lf it mk b gy mu mv l mw mx">const getArgs = (...rest) =&gt; rest</span></pre><p id="24ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下定义箭头函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cf72" class="mt lf it mk b gy mu mv l mw mx">const currentDate = () =&gt; new Date();</span></pre><p id="d13e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mh mi mj mk b">=&gt;</code>定义了箭头函数，并返回<code class="fe mh mi mj mk b">new Date()</code>来返回当前日期。</p><p id="1500" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想在多行箭头函数中返回一些东西，我们必须像其他函数一样显式地编写<code class="fe mh mi mj mk b">return</code>。</p><p id="c11c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6725" class="mt lf it mk b gy mu mv l mw mx">const currentDate = () =&gt; {<br/>  return new Date();<br/>}</span></pre><p id="b8db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在多行箭头函数中显式返回<code class="fe mh mi mj mk b">new Date()</code>。</p><p id="e976" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像传递其他函数一样传递参数，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8286" class="mt lf it mk b gy mu mv l mw mx">const identity = (obj) =&gt; {<br/>  return obj;<br/>}</span></pre><h1 id="8084" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是类？</h1><p id="bf77" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，类是构造函数的语法糖。它用于创建一个类的实例，但是从我们的角度隐藏了原型操作。</p><p id="a313" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本质上，它仍然使用它一直使用的原型继承模型。</p><p id="c4c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的类链:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cb98" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.lastName = lastName;<br/>    this.firstName = firstName;<br/>  }</span><span id="5bda" class="mt lf it mk b gy my mv l mw mx">  fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</span><span id="f0be" class="mt lf it mk b gy my mv l mw mx">class Employee extends Person {<br/>  constructor(firstName, lastName, title) {<br/>    super(firstName, lastName);<br/>    this.title = title;<br/>  }</span><span id="97be" class="mt lf it mk b gy my mv l mw mx">  getTitle() {<br/>    return this.title;<br/>  }<br/>}</span></pre><p id="0600" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个带有构造函数和获取全名的方法的<code class="fe mh mi mj mk b">Person</code>类。</p><p id="3aae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有了扩展了<code class="fe mh mi mj mk b">Person</code>类的<code class="fe mh mi mj mk b">Employee</code>类，正如我们用<code class="fe mh mi mj mk b">extends</code>关键字指出的那样。</p><p id="28b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在构造函数中，我们调用了<code class="fe mh mi mj mk b">Person</code>类的构造函数，还设置了<code class="fe mh mi mj mk b">title</code>字段，该字段是<code class="fe mh mi mj mk b">Employee</code>专有的。</p><p id="0dcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还添加了一个<code class="fe mh mi mj mk b">getTitle</code>方法。</p><p id="ea40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们忘记调用<code class="fe mh mi mj mk b">super</code>函数，JavaScript解释器会给我们一个错误。</p><p id="1ab9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与下面用构造函数编写的代码相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="020d" class="mt lf it mk b gy mu mv l mw mx">function Person(firstName, lastName) {<br/>  this.lastName = lastName;<br/>  this.firstName = firstName;<br/>}</span><span id="426b" class="mt lf it mk b gy my mv l mw mx">Person.prototype.fullName = function() {<br/>  return `${this.firstName} ${this.lastName}`;<br/>}</span><span id="2124" class="mt lf it mk b gy my mv l mw mx">function Employee(firstName, lastName, title) {<br/>  Person.call(this, firstName, lastName);   <br/>  this.title = title;<br/>}<br/> <br/>Employee.prototype = Object.create(Person.prototype);</span><span id="24d0" class="mt lf it mk b gy my mv l mw mx">Employee.prototype.getTitle = function() {<br/>  return this.title;<br/>}</span></pre><p id="325a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码与我们在类中使用的代码相同，除了如果<code class="fe mh mi mj mk b">Person.call</code>或<code class="fe mh mi mj mk b">Object.create</code>丢失，我们不会得到错误。</p><p id="6c63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还必须在函数之外给每个构造函数的<code class="fe mh mi mj mk b">prototype</code>添加东西。</p><p id="b0de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使我们不使用构造函数语法，我们也必须知道类语法只是构造函数的语法糖。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c5d8b75f2589b201f16d775def5d5c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eiGoQEs-nu0w5Hrj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安迪·奇尔顿在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="6862" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是对象析构？</h1><p id="5688" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对象析构是一种将数组条目或对象属性赋给它们自己的变量的干净方式。</p><p id="27dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用它将数组条目分解为单独的变量，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f8ae" class="mt lf it mk b gy mu mv l mw mx">const [one, two] = [1, 2];</span></pre><p id="b67e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">one</code>是1，<code class="fe mh mi mj mk b">two</code>是2。</p><p id="9536" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码与以下代码相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="287d" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2];<br/>const one = arr[0];<br/>const two = arr[1];</span></pre><p id="8954" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以对对象做同样的事情，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a58c" class="mt lf it mk b gy mu mv l mw mx">const {<br/>  one,<br/>  two<br/>} = {<br/>  one: 1,<br/>  two: 2<br/>}</span></pre><p id="a5df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后将<code class="fe mh mi mj mk b">one</code>属性的值赋给<code class="fe mh mi mj mk b">one</code>，将<code class="fe mh mi mj mk b">two</code>的值赋给<code class="fe mh mi mj mk b">two</code>。</p><p id="cdae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码与以下代码相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7c15" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  one: 1,<br/>  two: 2<br/>}<br/>const one = obj.one;<br/>const two = obj.two;</span></pre><p id="2ba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，对象和数组的析构比老方法要干净得多。</p><p id="dfcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以通过编写以下内容将变量设置为默认值:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a695" class="mt lf it mk b gy mu mv l mw mx">const [one, two, three = 3] = [1, 2];</span></pre><p id="287e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么由于<code class="fe mh mi mj mk b">three</code>没有被分配数组条目，<code class="fe mh mi mj mk b">three</code>的值为3。</p><h1 id="81fc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="6d28" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">箭头函数对于创建非构造函数的函数很有用。它们不绑定到<code class="fe mh mi mj mk b">this</code>。此外，它更短，因为我们不必写<code class="fe mh mi mj mk b">return</code>来返回一行代码。</p><p id="1cfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的类是构造函数的语法糖。它让我们更容易继承和创建实例方法，因为我们不必直接操作原型，如果我们遗漏了什么，JavaScript解释器会给我们错误。</p><p id="b246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对象和数组的析构让我们以一种简洁的方式将对象或数组条目赋给变量。</p></div></div>    
</body>
</html>