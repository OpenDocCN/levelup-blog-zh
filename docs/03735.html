<html>
<head>
<title>Force users to update your application in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强制用户在React Native中更新你的应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/force-users-to-update-your-application-in-react-native-c232ee348954?source=collection_archive---------1-----------------------#2020-05-25">https://levelup.gitconnected.com/force-users-to-update-your-application-in-react-native-c232ee348954?source=collection_archive---------1-----------------------#2020-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ab45ab4d2652c4d614db0058c88ae2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idkbCRSbkMIicwJF60J2dg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">体育应用中的碰撞分析</figcaption></figure><p id="034e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我最近开发了一款手机应用程序，在发布的第一周就被下载了90000多次(这是一款追踪体育赛事直播的应用程序)。由于它与实时数据的紧密联系以及在移动世界中的一点经验，我们知道我们的应用程序的第一个版本不会没有错误。出于安全原因，我们必须找到一种直观的解决方案，在出现会导致应用程序崩溃的错误时，迫使用户更新应用程序。</p><h1 id="33e1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">🛠我们的期望</h1><p id="f900" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">然而，我们的解决方案必须满足某些标准:</p><ul class=""><li id="f032" class="md me iq ke b kf kg kj kk kn mf kr mg kv mh kz mi mj mk ml bi translated">在第一个屏幕开始时阻止应用程序(以防止加载服务再次导致崩溃，这将使应用程序不可用)</li><li id="c194" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">通知并重定向用户到他们的应用商店(下载和升级应用)</li><li id="377f" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">可远程配置(能够选择在哪个版本的应用程序上激活我们的解决方案)</li><li id="fe16" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">可定制的设计和“用户友好”</li></ul><p id="7c9b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了满足这些期望，我们决定在应用程序加载时(甚至在闪屏期间)使用阻塞模式。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/d40be3bbcefbbbfd52b44164145cef6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qAbCrovZN1KxIIAfQiUXw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">阻止弹出窗口的建议</figcaption></figure><h1 id="39ad" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">🧰设计</h1><p id="3437" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在发布时，一个<a class="ae mw" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>开始初始化我们应用程序的不同服务(比如firebase，或者我们的新解决方案)。然后我们的modal通过检查应用程序的版本和最低推荐版本来初始化。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/eb7fa908a8580c353d56b08c83ba4ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azZ04fz2Fax9FlglEAGflw.png"/></div></div></figure><p id="272c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，我已经规划了一个<strong class="ke ir">web服务</strong>，但是我强烈建议你(这是我们在产品中使用的)使用<a class="ae mw" href="https://firebase.google.com/docs/remote-config" rel="noopener ugc nofollow" target="_blank"> Firebase远程配置</a>，它允许存储一个JSON配置，当Firebase加载时下载。这允许你控制你的应用程序的行为(比如这里存储最低要求的版本)，而不必在商店中发布更新(或者<a class="ae mw" href="https://github.com/Microsoft/react-native-code-push" rel="noopener ugc nofollow" target="_blank">推送代码</a>)。</p><h1 id="c092" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">⏳设置</h1><p id="8f2e" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">为此，我使用:</p><ul class=""><li id="99c6" class="md me iq ke b kf kg kj kk kn mf kr mg kv mh kz mi mj mk ml bi translated">虚拟代码</li><li id="193d" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">反应16.9</li><li id="7a3d" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">反应原生0.61.5</li><li id="e271" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">打字稿3.8.3</li><li id="8d51" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated"><a class="ae mw" href="https://styled-components.com/docs/basics#react-native" rel="noopener ugc nofollow" target="_blank">样式-组件</a> 5.1.0</li><li id="712e" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">世博会37.0.3</li><li id="880f" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">一台MacBook和我的iPhone …😎</li></ul><h1 id="8559" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">👨🏼‍💻代码，代码，代码！</h1><p id="c39c" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">首先，让我们创建我们的服务加载器！</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="dd34" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们创建一个<a class="ae mw" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">自定义挂钩</a>来与我们的<strong class="ke ir">web服务</strong>通信，以便获得启动应用程序的最小版本。(在Firebase远程配置的情况下，此挂钩将被替换为<a class="ae mw" href="https://rnfirebase.io/remote-config/usage" rel="noopener ugc nofollow" target="_blank"> this </a>)</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2866" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们把我们的钩子添加到我们的上下文中。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="df13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，让我们将我们的应用程序与我们的上下文包含在一起！</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2224" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了一个看起来像这样的架构:</p><pre class="ms mt mu mv gt na nb nc nd aw ne bi"><span id="18d2" class="nf lb iq nb b gy ng nh l ni nj">├───src/<br/>│   └───modules/<br/>│       ├───app/<br/>│          ├───hooks/<br/>│          │   └───useGetMinimumAvailableVersion.tsx<br/>│          └───AppContext.tsx<br/>├───App.tsx</span></pre><h1 id="70c8" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">📲模态</h1><p id="667f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">为了保持一定的结构，让我们在模块目录中添加一个模态文件夹:</p><pre class="ms mt mu mv gt na nb nc nd aw ne bi"><span id="10f4" class="nf lb iq nb b gy ng nh l ni nj">├───src/<br/>│   └───modules/<br/>│       └───modal/<br/>│           └───AppVersionModal.tsx</span></pre><p id="a698" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们初始化我们的模态。你可以随意定制。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="91f7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我在等一个<code class="fe nk nl nm nb b">loadingComponent</code>道具在模态打开的时候显示在模态后面。</p><p id="1022" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，如果我们在我们的<code class="fe nk nl nm nb b">App.tsx</code>中调用这个组件，模态仍然可以在屏幕上看到。因此，有必要添加一些逻辑。首先，让我们从上下文中调用方法来获取应用程序的最小版本:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6bc7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后让我们使用React生命周期来调用我们的方法。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="29c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意:依赖数组为空的<code class="fe nk nl nm nb b">useEffect</code>对应的是<code class="fe nk nl nm nb b"><a class="ae mw" href="https://reactjs.org/docs/react-component.html#componentdidmount" rel="noopener ugc nofollow" target="_blank">componentDidMount()</a></code>。</p><p id="8a8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了比较版本的所有必要信息，让我们稍微修改一下模态组件的逻辑。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c0b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，让我们添加方法，以便在打开模式时重定向到商店。然后让我们比较一下应用程序的版本。(我使用一个小的npm包来完成这项工作)。</p><p id="1558" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在有3种不同的回报:</p><ul class=""><li id="ac44" class="md me iq ke b kf kg kj kk kn mf kr mg kv mh kz mi mj mk ml bi translated">服务正在加载:我们返回加载屏幕</li><li id="3c8b" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">这个版本是不正确的:我们用</li><li id="291b" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">这个版本很好:我们返回子组件</li></ul><p id="444f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">加到我们的<code class="fe nk nl nm nb b">App.tsx</code>就行了。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b71b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就对了。我们现在可以阻止从我们的<strong class="ke ir">web服务</strong>直接访问应用程序，并将用户重定向到商店，强迫他更新。</p><p id="9deb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于完整的项目:我的<a class="ae mw" href="https://github.com/Trobyss/react-native-modal-force-update" rel="noopener ugc nofollow" target="_blank"> Github </a></p><p id="9881" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">(ps:我已经移除了样式组件块。你可以直接从我的<a class="ae mw" href="https://github.com/Trobyss/react-native-modal-force-update" rel="noopener ugc nofollow" target="_blank"> Github </a>获取。</p><h1 id="8d8e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">🌟更进一步</h1><p id="70ab" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">也可以通过<code class="fe nk nl nm nb b">Error Boundaries</code>保护代码，从源头解决问题。</p><p id="31e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae mw" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank"> React文档</a> &amp; <a class="ae mw" href="https://www.npmjs.com/package/react-native-error-boundary" rel="noopener ugc nofollow" target="_blank">包例</a></p></div></div>    
</body>
</html>