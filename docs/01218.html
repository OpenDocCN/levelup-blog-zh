<html>
<head>
<title>Micro Frontend Architecture: Import chunks from another Webpack bundle at runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端架构:在运行时从另一个Webpack包导入块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/micro-frontend-architecture-dynamic-import-chunks-from-another-webpack-bundle-at-runtime-1132d8cb6051?source=collection_archive---------0-----------------------#2019-11-30">https://levelup.gitconnected.com/micro-frontend-architecture-dynamic-import-chunks-from-another-webpack-bundle-at-runtime-1132d8cb6051?source=collection_archive---------0-----------------------#2019-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在运行时从其他Webpack包导入块，使用它们，就好像它们一直存在一样——交叉应用程序</h2></div><p id="e244" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更新:这个项目正在重写，将被纳入Webpack 5！</p><div class="le lf gp gr lg lh"><a href="https://medium.com/@ScriptedAlchemy/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">Webpack 5:模块联合。Javascript架构的游戏改变者。解锁微前端</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">模块联合——相当于Apollo对GraphQL所做的Javascript工作。多个Webpack版本一起工作，就像…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv lw lh"/></div></div></a></div><div class="le lf gp gr lg lh"><a href="https://github.com/webpack/webpack/issues/10352" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">合并提议:捆绑包之间的模块联合和代码共享。许多构建作为一个问题…</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">这是一个将我现有的工作合并到Webpack核心功能request @sokra的提议，应您的要求，我已经打开了一个…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="lx l ls lt lu lq lv lw lh"/></div></div></a></div></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="4bd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文描述了我如何编写一个Webpack插件，它在运行时从其他Webpack包导入块。It <em class="mf"> </em>是关于微前端应用和管理它们的技术的更大系列的一部分。</p><p id="4e8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章在某些地方是低级的，它的目的是记录开发交错工具的旅程。我将撰写围绕使用该工具的更高层次的文章，提供代码示例和用例。</p><h1 id="cbd0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">语境</h1><p id="66f9" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">构建现代分布式JavaScript应用程序是复杂的。管理多个存储库、构建和代码共享是一项具有挑战性的手工工作。我想建立独立的微前端应用程序，在浏览器中作为一个整体工作。</p><blockquote class="nd ne nf"><p id="cbf8" class="ki kj mf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">https://github.com/webpack/webpack/issues/8524<a class="ae nj" href="https://github.com/webpack/webpack/issues/8524" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a></p></blockquote><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nk"><img src="../Images/5602ca965817f6b5ae46661d88fea6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AAUG5KTeZawlLRbP.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">交叉存取的挑战</figcaption></figure><blockquote class="nz"><p id="80fd" class="oa ob it bd oc od oe of og oh oi ld dk translated">许多webpack构建时在浏览器中作为一个整体运行，没有构建时的上下文</p></blockquote><p id="c578" class="pw-post-body-paragraph ki kj it kk b kl oj ju kn ko ok jx kq kr ol kt ku kv om kx ky kz on lb lc ld im bi translated">我一直在使用LOSA架构、monolith绞杀和定制微前端设置——一直困扰这些平台设计的问题是管理宝贵的客户端运行时性能和软件包大小。在浏览器中，关注点的规模和分离有一些缺点。</p><div class="le lf gp gr lg lh"><a rel="noopener  ugc nofollow" target="_blank" href="/micro-frontend-architecture-replacing-a-monolith-from-the-inside-out-61f60d2e14c1"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">微前端架构:从内到外取代整体架构</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">如何利用微前端技术实现遗留应用的现代化</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lq l"><div class="oo l ls lt lu lq lv lw lh"/></div></div></a></div><blockquote class="nd ne nf"><p id="4fae" class="ki kj mf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated"><strong class="kk iu"> <em class="it"> Javascript编排</em> </strong></p><p id="f637" class="ki kj mf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">通用微应用的可扩展管理。</p></blockquote><h1 id="dbad" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">交错运行时</h1><p id="2eff" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">简单地说，我想在运行时合并两个Webpack清单，让它们一起工作，就好像从一开始就被编译成一个SPA。有点像<a class="ae nj" href="https://webpack.js.org/plugins/dll-plugin/" rel="noopener ugc nofollow" target="_blank"> DLLPlugin </a>，但是不需要在构建时传递上下文——而是在运行时传递上下文</p><blockquote class="nd ne nf"><p id="8e92" class="ki kj mf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated"><strong class="kk iu"><em class="it"/></strong><br/>in(t)ərˈlēv—<em class="it">动词<br/> 1) </em>在书页之间插入书页，通常是空白页。2)通过交替混合(两个或多个数字信号)。</p></blockquote><figure class="nl nm nn no gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi op"><img src="../Images/17bc76470e1e11e5e5aad20e5f79d367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qD4FSFZCoDPrn7hexrP1UA.jpeg"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">扎克·杰克逊</figcaption></figure><p id="18f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将使微前端(或MFE，我称之为微前端)无缝地协同工作。</p><p id="8b00" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">构建之间的智能代码分割</strong>。<strong class="kk iu"> </strong> <a class="ae nj" href="https://webpack.js.org/plugins/dll-plugin/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动态导入网址，无页面重载</strong> </a></p><h1 id="3b64" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">目标</h1><p id="596a" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">交错需要实现以下目标</p><ul class=""><li id="6d13" class="oq or it kk b kl km ko kp kr os kv ot kz ou ld ov ow ox oy bi translated">当路由到另一个MFE时没有页面刷新，多个应用应该像一个SPA一样路由</li><li id="8640" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">不要重新下载页面上另一个Webpack版本已经提供的供应商代码。(不要捆绑同一个依赖项的多个副本)</li><li id="f7d0" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">每个MFE应该是完全独立的，没有集中的依赖关系。我不想通过管理Webpack externals或commons供应商块来共享代码。</li><li id="f0fd" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">前端资源应该具有常青的能力，不需要消费者重新安装。</li><li id="75f2" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">我不需要因为共享组件或其他团队管理的东西的变化而重新部署整个团队(比如导航，我不想在他们推出新的更新时重新部署我的全部)</li><li id="ca9d" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">编排应该完全由用户管理，允许根据页面上加载的JavaScript包进行动态调整。除了像包本身一样添加静态JavaScript之外，应该不需要任何远程逻辑或调用。</li></ul></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="93ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了防止事情变得太混乱，让我们假设你有两个微前端或两个独立的应用程序。他们有自己的Webpack版本，由自己的服务器驱动，完全独立。姑且称之为<code class="fe pe pf pg ph b"><strong class="kk iu">App1</strong></code>和<code class="fe pe pf pg ph b"><strong class="kk iu">App2</strong></code> <strong class="kk iu">。我想用</strong> <code class="fe pe pf pg ph b"><strong class="kk iu">Nav</strong></code> <strong class="kk iu">从</strong><code class="fe pe pf pg ph b"><strong class="kk iu">App1</strong></code><strong class="kk iu"/><code class="fe pe pf pg ph b"><strong class="kk iu">App2</strong></code><strong class="kk iu">里面。</strong></p><p id="fc49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以把Nav做成一个npm包，然后重新安装到<code class="fe pe pf pg ph b">App1</code>和<code class="fe pe pf pg ph b">App2</code>中，共享问题就解决了。但是每次更新Nav的时候还是要重新部署多个应用。</p><h2 id="3d12" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">制定解决方案</h2><p id="ddca" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">利用内置的代码分割原理，我想从另一个构建中动态<code class="fe pe pf pg ph b">import()</code>一个块，因为这是最合理的方式，Webpack已经可以处理导入块。但是，您目前只能从它自己的构建中执行此操作。Webpack并不真正知道如何处理<em class="mf">外部导入</em>或来自外部包的一大块。<code class="fe pe pf pg ph b">App2</code>如何从<code class="fe pe pf pg ph b">App1</code>导入<code class="fe pe pf pg ph b">Nav.chunk.js</code>？</p><h1 id="98b0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">挑战1:自动代码分割</h1><h2 id="fa7a" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">魔法出口</h2><p id="8f06" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我需要一种方法将文件标记为我打算在另一个应用程序中使用的文件。Webpack需要确保任何<strong class="kk iu"> <em class="mf">【外部化】</em> </strong>的东西都是代码分割的，不管<code class="fe pe pf pg ph b">App1</code>实际上是否动态导入——为了使交错高效，我需要尽可能少地导入，而不是<code class="fe pe pf pg ph b">main.bundle.js</code>或<code class="fe pe pf pg ph b">vendor.chunk.js</code>。大多数没有进行代码分割的内容最终会变成一个巨大的块，因此需要一种方法来对文件进行代码分割，而不必强制动态导入文件，这可能会改变开发人员的流程并引入非常抽象的规则。我们该如何处理？</p><p id="f0b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用魔法出口，就是这样！我将放入<code class="fe pe pf pg ph b">/*externalize:Nav*/</code>，我将在构建时用Webpack解析它，然后以不同的方式处理这些文件。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="841d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">魔法输出可能会导致同一个建筑内的冲突。我正在考虑一个替代方案，它类似于c等其他语言中的接口。该定义将被实现到<code class="fe pe pf pg ph b">package.json</code>中，并且将防止意外地调用两个块相同的东西</p><pre class="nl nm nn no gt pw ph px py aw pz bi"><span id="1ff0" class="pi mh it ph b gy qa qb l qc qd">"interface": {<br/>  './src/components/Menu.js': "Nav"<br/>},</span></pre><h2 id="7dfb" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">利用splitChunks API</h2><p id="26ae" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">用<code class="fe pe pf pg ph b">cacheGroups</code>自动化代码分割。无论同步还是异步导入，所有标记的文件都会自动代码分割到它们自己的缓存组中。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="ab2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，标记的文件可以被识别，并自动分割成自己的块。<code class="fe pe pf pg ph b">App2</code>能够<code class="fe pe pf pg ph b">import("someUrl/js/Nav.chunk.js")</code>并且它会存在。</p><h1 id="b26a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">挑战2:散列模块id</h1><h2 id="a82f" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">默认情况下Webpack如何分配模块</h2><p id="d0f7" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">默认情况下，Webpack生成一个数字形式的模块ID。<code class="fe pe pf pg ph b">__webpack_modules__</code>包含一个大规模数组，每个模块ID是数组中的一个位置。</p><p id="a87f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将不会为交错工作，我需要知道模块是什么。</p><h2 id="f1de" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">hashedModuleID优化选项？</h2><p id="ede2" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">Webpack有一个内部的<code class="fe pe pf pg ph b">hashedModuleIDs</code>选项，但是，这个散列约定不起作用。Webpack哈希模块<em class="mf">路径</em>交叉使用不同文件结构的应用程序会导致相同的模块具有不同的id</p><p id="7546" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe pe pf pg ph b">App2</code>使用yarn工作空间，是monorepo的一部分。<code class="fe pe pf pg ph b">App1</code>是普通包装。</p><p id="a5b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe pe pf pg ph b">App2</code>进口从<code class="fe pe pf pg ph b"> ../../node_modules</code>开始反应<code class="fe pe pf pg ph b">App1</code>进口从<code class="fe pe pf pg ph b">../node_modules</code>开始反应</p><p id="e3f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管版本是否相同，当交叉存取<code class="fe pe pf pg ph b">Nav</code>时，Webpack不会知道它已经有了<code class="fe pe pf pg ph b">React (../node_modules/react)</code>，因为<code class="fe pe pf pg ph b">Nav</code>会因为依赖于文件路径的散列而请求不同的散列模块。在这种情况下，<code class="fe pe pf pg ph b">App2</code>将下载<code class="fe pe pf pg ph b">App1</code>的包含<code class="fe pe pf pg ph b">React (../../node_modules/react)</code>的块，以便为<code class="fe pe pf pg ph b">Nav</code>提供它正在寻找的<code class="fe pe pf pg ph b">module.id</code>。</p><h2 id="3a08" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated"><code class="fe pe pf pg ph b">[contenthash]</code>对于模块id</h2><p id="3ee1" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">基于内容的散列模块确保了我可以获得跨任何Webpack构建的依赖项的匹配版本，而不管它的文件结构如何。没有代码重复，因为我有一个可靠的方法来检查是否有跨任何其他已经加载到页面上的Webpack构建所需的依赖关系<code class="fe pe pf pg ph b">Nav</code>的精确副本。如果Webpack找不到它所需要的依赖项，它将从产生<code class="fe pe pf pg ph b">Nav</code>的原始构建中获取依赖项。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="42f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然基于内容的散列模块适用于依赖关系，但是<em class="mf">外化的</em>模块需要一个可预测的、人为指定的名称，以便在交叉存取时可以在另一个应用程序中引用。就像神奇的导入注释一样，我通过神奇的导出注释来设置模块名称。</p><p id="ce10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">交错时，<code class="fe pe pf pg ph b">App2</code>可以<code class="fe pe pf pg ph b">__webpack_require__("Nav")</code>并且应该可以在<code class="fe pe pf pg ph b">__webpack_modules__</code>内找到。重要的是我们知道它存储的密钥。如果我们无法在Webpack清单中找到交错导出，我们就无法调用它，即使它已经加载到清单中。</p><blockquote class="nz"><p id="cbf4" class="oa ob it bd oc od qe qf qg qh qi ld dk translated">将外来块放入webpack清单只是成功的一半。你需要能够通过一个已知的引用来调用这个块</p></blockquote><p id="a546" class="pw-post-body-paragraph ki kj it kk b kl oj ju kn ko ok jx kq kr ol kt ku kv om kx ky kz on lb lc ld im bi translated"><strong class="kk iu">结合这两部分:</strong></p><p id="330c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1)我现在能够在浏览器中检查所有应用程序，并依赖任何和所有依赖项，不管它们源自哪个版本</p><p id="b07a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2)我可以找到注入到Webpack清单中的外部化块，并按名称调用它，就像dynamic <code class="fe pe pf pg ph b">import()</code>的工作方式一样</p><p id="a0a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结合在一起，像这样的设施可以被建造。</p><pre class="nl nm nn no gt pw ph px py aw pz bi"><span id="1359" class="pi mh it ph b gy qa qb l qc qd">const ExternalComponent = (props) =&gt; {<br/>  const {<br/>    src, module, export: exportName, cors, ...rest<br/>  } = props;<br/>  let Component = null;<br/>  const [loaded, setLoaded] = useState(false);<br/>  const importPromise = useCallback(<br/>    () =&gt; {<br/>      if (!src) return <strong class="ph iu"><em class="mf">Promise</em></strong>.reject();<br/>      if (cors) {<br/>        return <strong class="ph iu"><em class="mf">require</em></strong>("./corsImport").default(src);<br/>      }<br/>      return new <strong class="ph iu"><em class="mf">Promise</em></strong>((resolve) =&gt; {<br/>        resolve(new <strong class="ph iu"><em class="mf">Function</em></strong>(`return import("${src}")`)());<br/>      });<br/>    },<br/>    [src, cors]<br/>  );<br/><br/>  useEffect(() =&gt; {<br/>    <strong class="ph iu"><em class="mf">require</em></strong>("./polyfill");<br/>    if (!src) {<br/>      throw new <strong class="ph iu"><em class="mf">Error</em></strong>(`interleaving error: ${<strong class="ph iu"><em class="mf">JSON</em></strong>.stringify(props, null, 2)}`);<br/>    }<br/><br/>    importPromise(src).then(() =&gt; {<br/>      const requiredComponent = __webpack_require__(module);<br/>      Component = requiredComponent.default ? requiredComponent.default : requiredComponent[exportName];<br/>      setLoaded(true);<br/>    }).catch((e) =&gt; {<br/>      throw new <strong class="ph iu"><em class="mf">Error</em></strong>(`dynamic-import: ${e.message}`);<br/>    });<br/>  }, []);<br/><br/>  if (!loaded) return null;<br/>  return (<br/>    &lt;Component {...rest} /&gt;<br/>  );<br/>};</span></pre><div class="le lf gp gr lg lh"><a href="https://github.com/ScriptedAlchemy/webpack-external-import/blob/master/src/react.js" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">ScriptedAlchemy/web pack-外部-导入</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="qj l ls lt lu lq lv lw lh"/></div></div></a></div><h1 id="6ab8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">挑战3:缓存破坏</h1><p id="3dc2" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我们需要一种方法来加载缓存损坏的哈希文件。大多数构建都是通过散列捆绑包和块名来破坏缓存的，但是如果它的名字像<code class="fe pe pf pg ph b">Nav.chunk.[contenthash].js</code>一样被散列，就很难加载<code class="fe pe pf pg ph b">Nav.chunk.js</code></p><p id="5f5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我选择生成一个Javascript文件，它可以用一个查询字符串(每次)缓存。JavaScript文件没有CORS问题，所以跨应用程序嵌入清单更容易。如果你使用CSP ，你需要配置它。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="9919" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个都有一个名称空间。否则app之间碰撞的风险太高。</p><h1 id="eea4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">挑战4:缺少依赖解析</h1><p id="622a" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">如果一个程序块被插入到一个应用程序中，而这个应用程序没有这个程序块所需要的依赖项，会发生什么呢？如上所示，清单映射不能解决依赖关系跟踪。我需要知道在原始构建中最小的文件在哪里，包含缺失的依赖项</p><p id="bebe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">增强清单映射稍微改进了反向依赖查找和解析。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="ea1c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">在Webpack插件中查找模块所依赖的内容。</strong></p><p id="c836" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能有更好的方法来做到这一点。</p><p id="646a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在emit钩子中，我遍历stats图，跟踪任何外部化的文件，然后遍历该块中的所有模块，最后搜索依赖项被发送到的文件。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="6ca0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要测试更复杂的依赖关系和嵌套依赖关系解析。像外部化组件加载其他外部化组件这样的情况仍然需要测试。</p><h1 id="444a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">挑战5:树摇动和死代码消除</h1><p id="8302" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">团队给我指出了一些我还没有测试过的东西，范围提升、树抖动和缺少导出。</p><p id="b672" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，Webpack在树抖动之前散列module.ids <em class="mf">，所以我的<code class="fe pe pf pg ph b">[contenthash]</code>模块不可靠。哈希基于安装的内容，而不是捆绑的内容。我需要一种方法来一个案例一个案例地管理树摇动</em></p><p id="7f3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择是有限的，关闭摇树将会爆炸一捆的大小。</p><p id="2722" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个示例场景，<code class="fe pe pf pg ph b">App1</code>树抖动一个仅由<code class="fe pe pf pg ph b">App2</code>使用的导出</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="c813" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我的依赖链可能有也可能没有它们的导出，交错就没有多大用处，除此之外<em class="mf">外化的</em>文件可能有也可能没有它们的导出。因为当散列发生时，我真的不能确定一个bundle是否拥有一个交错块所需的所有功能和输出。版本匹配，导出可能不匹配。</p><h2 id="eed3" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">控制Webpack如何摇动树</h2><p id="c5f4" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">Webpack DLL插件使用了一个函数来标记一个正在以未知方式使用的模块。通过将这个函数应用于任何外部化的文件，也许还有它们的依赖项，树抖动不会危及稳定性。</p><figure class="nl nm nn no gt np"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="d164" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还发现了如何以更详细的方式来做这件事。当循环模块时，您可以将<code class="fe pe pf pg ph b">module.buildMeta.usedExports</code>设置为与<code class="fe pe pf pg ph b">module.providedExports</code>相同</p><blockquote class="nz"><p id="e935" class="oa ob it bd oc od qe qf qg qh qi ld dk translated">想象一下，能够下载另一个应用程序供应商作为一个丢失的大块的后备！</p></blockquote><h1 id="e066" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz qk ka ms kc ql kd mu kf qm kg mw mx bi translated">未来状态</h1><p id="a1b3" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">它要去哪里？</p><h2 id="bb7e" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">自愈</h2><p id="623b" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">实现允许独立运行时之间的查询功能的通信总线。如果某个依赖项加载失败，或者由于某种原因某个构建中缺少依赖项块。如果可以在另一个交错构建中找到依赖关系，它应该尝试查询页面上可能存在的任何和所有其他Webpack构建。它可以从交叉下行链路下载数据块，并使用其供应商提供的数据块，而这些数据块实际上并未被供体使用。想象一下，可以下载其他应用程序供应商的软件作为退路！部署新的缓存损坏的文件不会破坏当前用户的下载。</p><h2 id="7a42" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">SSR中间件</h2><p id="4fbd" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">这个项目在客户端工作，但是服务器端更难。Eval可能有用，但听起来非常危险。我想到了两个可以缓解这个问题的解决方案。可以编写一些中间件来与集群中的其他MFE通信，并中继它们的独立段。</p><p id="8dc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">最终一致性:</strong>适用于页眉或页脚。可能由一个工作流拥有，但需要在一组MFE之间共享的东西。团队可以将他们的MFE作为npm包发布。消费者SSR它，但是客户端，浏览器将直接从原点交错。其可能比消费者安装的SSR副本部署得更近。</p><p id="a3c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这并不理想，但确实有效。</p><p id="576a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">分布式渲染:</strong>消费者通过一个渲染API到达另一个MFE，该API提供包含HTML、CSS、JS、初始状态的JSON。有了这个，Node可以把它作为道具传递给<code class="fe pe pf pg ph b">&lt;App&gt;</code>，并呈现其余的部分。有了react-dom中的片段缓存，渲染变得非常快。</p><p id="9247" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还可以利用HTTP2流，并从分布式MFE渲染集群中实际传输SSR。或者可以仅在服务器之间流式传输以获得低延迟。</p><p id="3380" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">交错可以解决许多问题，这些问题目前需要不正规的、非性能的或复杂的解决方法。</p><blockquote class="nd ne nf"><p id="ade9" class="ki kj mf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">悬疑实现！到时候了</p></blockquote><pre class="nl nm nn no gt pw ph px py aw pz bi"><span id="342d" class="pi mh it ph b gy qa qb l qc qd">server.get(path, (req, res) =&gt;<br/>  serveFragment(<br/>    req,<br/>    res,<br/>    fragmentID =&gt; require(`./components/${fragmentID}`).default) <br/>);</span></pre><h2 id="fe2a" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">一个新的路由平台</h2><p id="8a77" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">路由仍然是一个需要改进的地方。与动态导入一样，交叉存取路由器对象也是必需的。添加一些实用程序和JSX将使它变得简单一些，并抽象掉许多复杂性。</p><h2 id="8822" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated"><strong class="ak">可合并出口</strong></h2><p id="57dd" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">禁用树抖动对一个模块接一个模块起作用。但是这可能导致包的大小变大，特别是如果依赖链也被排除在树抖动之外的话。</p><p id="e612" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">合并导出的能力将允许<code class="fe pe pf pg ph b">node_modules</code>的树摇动，一个外部块可以检查消费者构建在一个依赖内是否有<em class="mf">权限</em>导出。如果没有，它会将自己的树动摇版本的同一个依赖项与消费者构建中的导出合并。确保下载最少的代码，但所有功能都可用。</p><h2 id="a30f" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">改进的效用函数和内在化清单</h2><p id="e1dc" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">将所有部分，如导入清单和实用函数，移到<code class="fe pe pf pg ph b">webpackJsonP</code></p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="ff7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回购链接:<a class="ae nj" href="https://github.com/ScriptedAlchemy/webpack-external-import" rel="noopener ugc nofollow" target="_blank">https://github.com/ScriptedAlchemy/webpack-external-import</a></p><p id="f8be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请随意打开一个PR，或者如果您想合作，请在Twitter上给我发消息。和任何OSS项目一样，社区的投入是有价值的，有助于项目的繁荣</p><p id="eb90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">疑问？在推特上抓住我</strong></p><div class="le lf gp gr lg lh"><a href="https://twitter.com/ScriptedAlchemy" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">扎克·杰克逊</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">扎克·杰克逊的最新推文(@ScriptedAlchemy)。首席工程师@lululemon。JavaScript编排位于…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">twitter.com</p></div></div><div class="lq l"><div class="qn l ls lt lu lq lv lw lh"/></div></div></a></div><p id="0392" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">或GitHub </strong></p><div class="le lf gp gr lg lh"><a href="https://github.com/ScriptedAlchemy" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">ScriptedAlchemy -概述</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">在GitHub上注册您自己的个人资料，这是托管代码、管理项目和与40…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="qo l ls lt lu lq lv lw lh"/></div></div></a></div><h2 id="0349" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">下一个</h2><ul class=""><li id="cdf4" class="oq or it kk b kl my ko mz kr qp kv qq kz qr ld ov ow ox oy bi translated">创建交叉应用程序外壳。</li><li id="9cc0" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">交错两个应用程序—实际例子</li><li id="47de" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">通过应用外壳同步和自定义挂钩，轻松管理多个微前端</li><li id="4ae0" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">交错next.js区域</li><li id="87af" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">交叉管理堆栈的完整示例— FOSA体系结构</li><li id="47ca" class="oq or it kk b kl oz ko pa kr pb kv pc kz pd ld ov ow ox oy bi translated">视频系列，解释了在一个更容易消化的媒体低水平</li></ul><h2 id="3431" class="pi mh it bd mi pj pk dn mm pl pm dp mq kr pn po ms kv pp pq mu kz pr ps mw pt bi translated">系列的前一篇文章</h2><p id="6e54" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated"><a class="ae nj" rel="noopener ugc nofollow" target="_blank" href="/micro-frontend-architecture-replacing-a-monolith-from-the-inside-out-61f60d2e14c1">https://level up . git connected . com/micro-frontend-architecture-replacing-a-monolith-from-inside-out-61f 60 D2 e14 c 1</a></p></div></div>    
</body>
</html>