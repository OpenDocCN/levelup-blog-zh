<html>
<head>
<title>Method Resolution Order in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的方法解析顺序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/method-resolution-order-in-python-5afbaecc25e0?source=collection_archive---------4-----------------------#2021-08-03">https://levelup.gitconnected.com/method-resolution-order-in-python-5afbaecc25e0?source=collection_archive---------4-----------------------#2021-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8054" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python如何使用C3线性化支持多重继承，以及为什么基类的顺序至关重要。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0b48751520279f868b75b938c7b00f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YYZ5rlP6byPlxAY9"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">安德烈·泰森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fdd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">致命的死亡钻石——最广为人知的多重继承问题，当类<code class="fe ls lt lu lv b">A</code>从两个类<code class="fe ls lt lu lv b">B</code>和<code class="fe ls lt lu lv b">C</code>继承时出现，这两个类都从基类<code class="fe ls lt lu lv b">D</code>继承。对于类<code class="fe ls lt lu lv b">D</code>中的方法<code class="fe ls lt lu lv b">foo()</code>，类<code class="fe ls lt lu lv b">A</code>将继承它的两个副本——每个父类一个。那么当一个人调用<code class="fe ls lt lu lv b">a.foo()</code>时，将为类<code class="fe ls lt lu lv b">A</code>的对象<code class="fe ls lt lu lv b">a</code>调用哪个副本呢？答案取决于线性化算法。</p><p id="ebdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法解析顺序(MRO)是一种用于构建线性化的算法——一个类的所有祖先的列表，包括该类本身，从最近到最远排序。这是查找方法和属性的顺序。虽然线性化对于单一继承来说是微不足道的，但是对于多重继承来说就变得复杂了。</p><p id="db02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MRO的一个关键要求是单调性:如果在类<code class="fe ls lt lu lv b">A</code>的线性化中类<em class="lw"> </em> <code class="fe ls lt lu lv b">B</code>出现在类<code class="fe ls lt lu lv b">C</code>之前，那么在从<code class="fe ls lt lu lv b">A</code>派生的任何类的线性化中<code class="fe ls lt lu lv b">B</code>应该出现在<code class="fe ls lt lu lv b">C</code>之前。否则，创建子类可能会改变解析顺序，并引入令人讨厌的错误。在2.3版本之前，Python使用了一种原生算法，但是发现它并不单调。在Python 2.3中，本地算法被忽略了，取而代之的是学术上发展起来的C3线性化，它转移到了Python 3。</p><p id="5fc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获取类<code class="fe ls lt lu lv b">A</code>的对象<code class="fe ls lt lu lv b">a</code>的MRO就像调用<code class="fe ls lt lu lv b">a.mro()</code>一样简单，但是，如果您对计算实际上是如何执行的感兴趣，请继续阅读。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="f245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">C3应用分治法以如下方式计算线性化:让<code class="fe ls lt lu lv b">A</code>成为从基类<code class="fe ls lt lu lv b">B1</code>、<code class="fe ls lt lu lv b">B2</code>、… <code class="fe ls lt lu lv b">Bn</code>继承的类。<code class="fe ls lt lu lv b">A</code>的线性化是<code class="fe ls lt lu lv b">A</code>加上双亲的线性化和双亲列表的合并的和:</p><p id="bbd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">L[<em class="lw">A</em>(<em class="lw">B1</em>…<em class="lw">Bn</em>)]=<em class="lw">A</em>+merge(L[<em class="lw">B1</em>]…L[<em class="lw">Bn</em>]，<em class="lw"> B1 </em> … <em class="lw"> Bn </em>)</p><p id="b85a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要执行合并，请执行以下操作:</p><ul class=""><li id="d175" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated">看第一个列表的头:L[ <em class="lw"> B1 </em> ][0]</li><li id="556c" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">如果这个头是一个“好头”，意味着它没有出现在任何其他列表的尾部——将其添加到<em class="lw"> A </em>的线性化中，并将其从合并的所有列表中移除。</li><li id="95f0" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">否则，查看下一个列表的头，如果它是一个“好头”，将其添加到线性化中</li><li id="8159" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">重复，直到所有的类都被删除或没有好的头了。在后一种情况下，构造失败。</li></ul><p id="3445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">听起来晦涩难懂？让我们用下面的例子来澄清一下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/98232115eaf189b86f59296d4330b9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*TXUv__LXl2FRC_5k2JkeEQ.png"/></div></figure><p id="8fca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用C3算法对此等级进行的线性化计算如下所示:</p><p id="b63a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">L[<em class="lw">A</em>]=<em class="lw">A</em>+merge(L[<em class="lw">B</em>]，L[ <em class="lw"> C </em>，<em class="lw"> BC </em>)</p><p id="a848" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了计算L[<em class="lw">A</em>，我们首先要计算它的分量:L[<em class="lw">B</em>和L[<em class="lw">C</em>]:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="63fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">L[C]的计算类似:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f2f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在可以计算L[A]:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cea3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，就像在大多数情况下一样，线性化“有意义”:在层次结构中，较低的、更专门化的类比较高的、更普通的类出现得更早。然而，情况并非总是如此。为了说明这一点，让我们在前面的例子中引入一个微小的变化，并将基类的顺序换成类<code class="fe ls lt lu lv b">B</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d42d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们计算修改后的层次结构的L[A]，从重新计算L[B]开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="eae8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不仅整个层次结构的顺序发生了变化，现在一个更一般的类<code class="fe ls lt lu lv b">E</code>出现在一个更具体的类<code class="fe ls lt lu lv b">C</code>之前！这强调了在设计复杂的多重继承层次结构时应该特别注意。</p><p id="9dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，致命的死亡钻石呢？在Python中，这种结构是不可避免的，并且出现在每个多重继承层次中，因为所有的类都从object类继承。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/f8379523827f875428efaf835a0f89d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*c3-XKDaDgfD4ZPwkzJNtPg.png"/></div></figure><p id="57c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，C3协助巧妙地解决了这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0f6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，并不是每个可能的层次都可以线性化，同时保持单调性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3fa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将导致:<code class="fe ls lt lu lv b">TypeError: Cannot create a consistent method resolution order (MRO) for bases X, Y</code>。这是因为类别<code class="fe ls lt lu lv b">C</code>的方法解析顺序不明确:在<code class="fe ls lt lu lv b">C</code>的线性化中<code class="fe ls lt lu lv b">X </code>和<code class="fe ls lt lu lv b">Y</code>的顺序不明确。C3算法无法线性化层次，Python阻止了它的创建。这是基类顺序重要性的另一个例子。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h2 id="202a" class="mw mx iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">资源:</h2><ol class=""><li id="34c1" class="me mf iq ky b kz np lc nq lf nr lj ns ln nt lr nu mk ml mm bi translated">Michele Simionato撰写的一篇详细文章成为Python 2.3文档的一部分，详细解释了过渡到C3的原因以及算法:</li></ol><div class="nv nw gp gr nx ny"><a href="https://www.python.org/download/releases/2.3/mro/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">Python 2.3方法解析顺序</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">米歇尔·西米奥纳托。摘要:这篇文档是为想理解C3方法的Python程序员而写的…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.python.org</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><p id="9cc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.吉多·范·罗苏姆在《Python的历史》中的帖子:</p><div class="nv nw gp gr nx ny"><a href="https://python-history.blogspot.com/2010/06/method-resolution-order.html" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">方法解析顺序</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">在使用多重继承的语言中，查找方法时基类的搜索顺序是…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">python-history.blogspot.com</p></div></div></div></a></div></div></div>    
</body>
</html>