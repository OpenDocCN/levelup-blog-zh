<html>
<head>
<title>Kubernetes Canary Deployment #1 Gitlab CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes金丝雀部署#1 Gitlab CI</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-canary-deployment-1-gitlab-ci-518f9fdaa7ed?source=collection_archive---------4-----------------------#2020-01-05">https://levelup.gitconnected.com/kubernetes-canary-deployment-1-gitlab-ci-518f9fdaa7ed?source=collection_archive---------4-----------------------#2020-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="64f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们使用GitlabCI和手动GitOps方法来实现和执行Canary Kubernetes部署</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/af6e77a339ad0575d50e6f5e2aa1bc56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HyzxV_D-fCAWfYsA7-L-Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">https://unsplash.com/photos/V41PulGL1z0<a class="ae ky" href="https://unsplash.com/photos/V41PulGL1z0" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h2 id="6eef" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">部件</h2><ol class=""><li id="7eac" class="lv lw it lx b ly lz ma mb li mc lm md lq me mf mg mh mi mj bi translated">(本文)</li><li id="ee53" class="lv lw it lx b ly mk ma ml li mm lm mn lq mo mf mg mh mi mj bi translated"><a class="ae ky" href="https://codeburst.io/kubernetes-canary-deployment-2-argo-rollouts-5e68e99b4fa3?source=friends_link&amp;sk=58557d4fa81ff77382e59e1258c06d61" rel="noopener" target="_blank">用ArgoCI部署金丝雀</a></li><li id="d16c" class="lv lw it lx b ly mk ma ml li mm lm mn lq mo mf mg mh mi mj bi translated"><a class="ae ky" href="https://medium.com/@wuestkamp/kubernetes-istio-canary-deployment-5ecfd7920e1c?source=friends_link&amp;sk=2be48393ac175a2199bf5d486cb91acf" rel="noopener">使用Istio部署金丝雀</a></li><li id="b4e3" class="lv lw it lx b ly mk ma ml li mm lm mn lq mo mf mg mh mi mj bi translated"><a class="ae ky" href="https://medium.com/@wuestkamp/jenkins-x-istio-flagger-canary-deployment-9d5e187c2334?source=friends_link&amp;sk=fa0cf82c7051958b0a98e205375cba86" rel="noopener">使用Jenkins-X Istio Flagger部署金丝雀</a></li></ol><p id="1448" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">我们将使用手动方法并更改/创建core-Kubernetes资源来执行Canary部署。<strong class="lx iu">这主要是为了理解</strong>Canary部署是如何工作的，有更好的自动化方法，我们将在以后的文章中探讨。</p><h1 id="9ee9" class="ne la it bd lb nf ng nh le ni nj nk lh jz nl ka ll kc nm kd lp kf nn kg lt no bi translated">金丝雀部署</h1><p id="b3cc" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">在Canary部署中，新的变更首先被部署到用户的子集。通过监控、记录、手动测试或其他反馈渠道，在向所有用户推广之前对发布进行测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/821a4fd8be6fde28b895946486c42fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r--VsyTkg9R-V6suuFFz_A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.norberteder.com/canary-deployment/" rel="noopener ugc nofollow" target="_blank">https://www.norberteder.com/canary-deployment/</a></figcaption></figure><h1 id="fb1e" class="ne la it bd lb nf ng nh le ni nj nk lh jz nl ka ll kc nm kd lp kf nn kg lt no bi translated">Kubernetes部署(滚动更新)</h1><p id="5307" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">Kubernetes部署的默认策略是滚动更新，即启动一定数量的带有新映像版本的pod。如果创建时没有问题，旧映像版本的窗格将被终止，同时会创建新的窗格。</p><h1 id="b645" class="ne la it bd lb nf ng nh le ni nj nk lh jz nl ka ll kc nm kd lp kf nn kg lt no bi translated">GitOps</h1><p id="e7a3" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">我们在本例中使用GitOps是因为我们:</p><ul class=""><li id="ec7a" class="lv lw it lx b ly mr ma mt li nt lm nu lq nv mf nw mh mi mj bi translated">使用Git作为事实的单一来源</li><li id="9167" class="lv lw it lx b ly mk ma ml li mm lm mn lq mo mf nw mh mi mj bi translated">使用git操作进行构建和部署(除了Git标记/合并之外，部署不需要任何操作)</li></ul><h1 id="8cc6" class="ne la it bd lb nf ng nh le ni nj nk lh jz nl ka ll kc nm kd lp kf nn kg lt no bi translated">例子</h1><p id="36b7" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">一个存储库用于应用程序代码，一个用于基础设施，这是很好的实践。</p><h2 id="ddd8" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">应用程序报告</h2><div class="nx ny gp gr nz oa"><a href="https://gitlab.com/wuestkamp/k8s-deployment-example-app" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Kim Wuestkamp/k8s-部署-示例-应用程序</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">GitLab.com</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">gitlab.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><p id="93a1" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">这是一个非常简单的Python+Flask api，它返回一个JSON响应。我们使用GitlabCI构建包，并将结果推入Gitlab注册表。在注册表中发布了两个不同的版本:</p><ul class=""><li id="4fdc" class="lv lw it lx b ly mr ma mt li nt lm nu lq nv mf nw mh mi mj bi translated"><code class="fe op oq or os b">wuestkamp/k8s-deployment-example-app:v1</code></li><li id="58b9" class="lv lw it lx b ly mk ma ml li mm lm mn lq mo mf nw mh mi mj bi translated"><code class="fe op oq or os b">wuestkamp/k8s-deployment-example-app:v2</code></li></ul><p id="0cdf" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">两个版本之间唯一的区别是返回的JSON发生了变化。我们使用这个应用程序来非常简单地可视化我们正在谈论的版本。</p><h2 id="541d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">基础设施回购</h2><div class="nx ny gp gr nz oa"><a href="https://gitlab.com/wuestkamp/k8s-deployment-example-canary-infrastructure" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Kim Wuestkamp/k8s-部署-示例-canary-基础设施</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">GitLab.com</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">gitlab.com</p></div></div><div class="oj l"><div class="ot l ol om on oj oo ks oa"/></div></div></a></div><p id="4efc" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">在这个报告中，我们使用GitlabCI进行Kubernetes部署，<code class="fe op oq or os b">.gitlab-ci.yml</code>看起来像:</p><pre class="kj kk kl km gt ou os ov ow aw ox bi"><span id="c64c" class="kz la it os b gy oy oz l pa pb"><strong class="os iu">image</strong>: traherom/kustomize-docker<br/><br/><strong class="os iu">before_script</strong>:<br/>    - printenv<br/>    - kubectl version<br/><br/><strong class="os iu">stages</strong>:<br/>  - deploy<br/><br/><strong class="os iu">deploy test</strong>:<br/>    <strong class="os iu">stage</strong>: deploy<br/>    <strong class="os iu">before_script</strong>:<br/>      - echo $KUBECONFIG<br/>    <strong class="os iu">script</strong>:<br/>      - kubectl get all<br/>      - kubectl apply -f i/k8s<br/><br/>    <strong class="os iu">only</strong>:<br/>      - master</span></pre><p id="3360" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">要自己运行，首先需要一个集群，可以使用Gcloud:</p><pre class="kj kk kl km gt ou os ov ow aw ox bi"><span id="aa2a" class="kz la it os b gy oy oz l pa pb">gcloud container clusters create canary --num-nodes 3 --zone europe-west3-b</span><span id="b48f" class="kz la it os b gy pc oz l pa pb">gcloud compute firewall-rules create incoming-80 --allow tcp:80</span></pre><p id="d2b5" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">您需要派生<a class="ae ky" href="https://gitlab.com/wuestkamp/k8s-deployment-example-canary-infrastructure" rel="noopener ugc nofollow" target="_blank">https://git lab . com/wuestkamp/k8s-deployment-example-canary-infra structure</a>并创建一个名为<code class="fe op oq or os b">KUBECONFIG</code>(类型文件)的GitlabCI变量，该变量应该包含对集群的<code class="fe op oq or os b">kubectl</code>访问配置。</p><p id="33e5" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated"><a class="ae ky" href="https://medium.com/faun/manually-connect-to-your-kubernetes-cluster-from-the-outside-d852346a7f0a" rel="noopener">阅读本</a>了解如何获得您的(Gcloud)集群证书。</p><h2 id="b7d2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">基础设施Yaml</h2><p id="37e9" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">在基础设施回购中，我们有一项服务:</p><pre class="kj kk kl km gt ou os ov ow aw ox bi"><span id="ab2b" class="kz la it os b gy oy oz l pa pb"><strong class="os iu">apiVersion</strong>: v1<br/><strong class="os iu">kind</strong>: Service<br/><strong class="os iu">metadata</strong>:<br/>  <strong class="os iu">labels</strong>:<br/>    <strong class="os iu">id</strong>: app<br/>  <strong class="os iu">name</strong>: app<br/><strong class="os iu">spec</strong>:<br/>  <strong class="os iu">ports</strong>:<br/>  - <strong class="os iu">port</strong>: 80<br/>    <strong class="os iu">protocol</strong>: TCP<br/>    <strong class="os iu">targetPort</strong>: 5000<br/>  <strong class="os iu">selector</strong>:<br/>    <strong class="os iu">id</strong>: app<br/>  <strong class="os iu">type</strong>: LoadBalancer</span></pre><p id="fcf2" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">还有一个部署<code class="fe op oq or os b">deploy.yaml</code>:</p><pre class="kj kk kl km gt ou os ov ow aw ox bi"><span id="e293" class="kz la it os b gy oy oz l pa pb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: app<br/>spec:<br/><strong class="os iu">  replicas: 10</strong><br/>  selector:<br/>    matchLabels:<br/>      id: app<br/><strong class="os iu">      type: main</strong><br/>  template:<br/>    metadata:<br/>      labels:<br/>        id: app<br/><strong class="os iu">        type: main</strong><br/>    spec:<br/>      containers:<br/><strong class="os iu">      - image: registry.gitlab.com/wuestkamp/k8s-deployment-example-app:v1</strong><br/>        name: app<br/>        resources:<br/>          limits:<br/>            cpu: 100m<br/>            memory: 100Mi</span></pre><p id="3b32" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">还有另一个部署<code class="fe op oq or os b">deploy-canary.yaml</code>:</p><pre class="kj kk kl km gt ou os ov ow aw ox bi"><span id="ffc1" class="kz la it os b gy oy oz l pa pb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: app-canary<br/>spec:<br/><strong class="os iu">  replicas: 0</strong><br/>  selector:<br/>    matchLabels:<br/>      id: app<br/><strong class="os iu">      type: canary</strong><br/>  template:<br/>    metadata:<br/>      labels:<br/>        id: app<br/><strong class="os iu">        type: canary</strong><br/>    spec:<br/>      containers:<br/><strong class="os iu">      - image: registry.gitlab.com/wuestkamp/k8s-deployment-example-app:v2</strong><br/>        name: app<br/>        resources:<br/>          limits:<br/>            cpu: 100m<br/>            memory: 100Mi</span></pre><p id="193f" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">注意到<code class="fe op oq or os b">app-deploy</code>到目前为止还没有定义副本。</p><h1 id="5c99" class="ne la it bd lb nf ng nh le ni nj nk lh jz nl ka ll kc nm kd lp kf nn kg lt no bi translated">执行初始部署</h1><p id="6043" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">要执行初始部署，您可以为主分支手动运行GitlabCI管道。在此之后<code class="fe op oq or os b">kubectl</code>应该会导致:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/88e8e8ad1380c4078e8fe449962231f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IbLNAu-KQUNKhb9naQiyNg.png"/></div></div></figure><p id="f146" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">我们看到<code class="fe op oq or os b">app</code>部署有10个副本，而<code class="fe op oq or os b">app-deployment</code>部署有0个副本。还有一个负载平衡器，我们可以在外部IP上<code class="fe op oq or os b">curl</code>:</p><pre class="kj kk kl km gt ou os ov ow aw ox bi"><span id="deb8" class="kz la it os b gy oy oz l pa pb">while true; do curl -s 35.198.149.232 | grep label; sleep 0.1; done</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/903f662bc504c774dad25e8a6b69c652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mw0q85NQ7gPfWuLueudNnQ.png"/></div></div></figure><p id="9c83" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">我们看到我们的测试应用程序只返回“v1”。</p><h1 id="b0c7" class="ne la it bd lb nf ng nh le ni nj nk lh jz nl ka ll kc nm kd lp kf nn kg lt no bi translated">执行金丝雀部署</h1><h2 id="2186" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤1:向用户子集发布新版本</h2><p id="b9f6" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">我们在文件<code class="fe op oq or os b">deploy-canary.yaml</code>中将副本数量设置为1，并将映像设置为新版本:</p><pre class="kj kk kl km gt ou os ov ow aw ox bi"><span id="67ab" class="kz la it os b gy oy oz l pa pb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: app-canary<br/>spec:<br/><strong class="os iu">  replicas: 1</strong><br/>  selector:<br/>    matchLabels:<br/>      id: app<br/>      type: canary<br/>  template:<br/>    metadata:<br/>      labels:<br/>        id: app<br/>        type: canary<br/>    spec:<br/>      containers:<br/><strong class="os iu">      - image: registry.gitlab.com/wuestkamp/k8s-deployment-example-app:v2</strong><br/>        name: app<br/>        resources:<br/>          limits:<br/>            cpu: 100m<br/>            memory: 100Mi</span></pre><p id="4fde" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">在<code class="fe op oq or os b">deploy.yaml</code>中，我们将副本更改为9:</p><pre class="kj kk kl km gt ou os ov ow aw ox bi"><span id="327c" class="kz la it os b gy oy oz l pa pb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: app<br/>spec:<br/><strong class="os iu">  replicas: 9</strong><br/>  selector:<br/>    matchLabels:<br/>      id: app<br/>...</span></pre><p id="a149" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">我们将这一变更推进到将部署(通过GitlabCI)的repo中，结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/a49d1a02aebb5a66d66da2a687f6488f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7izMXL3Rs2FzpTxqY9J-w.png"/></div></div></figure><p id="757e" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">我们的服务将指向两个部署，因为只有一个选择器标签<code class="fe op oq or os b">id: app</code>。由于Kubernetes默认的随机请求分布，我们应该在大约10%的请求中看到不同的响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/3136867303b6db3910f9f64bf0fcd511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snByJtsq1KTXwOdLtUQbCQ.png"/></div></div></figure><p id="14e3" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">我们的应用程序(GitOps，致力于将Git作为真实的单一来源)的当前状态是，我们有两个带有活动副本的部署，每个版本一个。</p><p id="1758" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">~10%的用户接触到新版本，不由自主地进行测试。现在是检查错误、日志和监控以查找问题的时候了。</p><h2 id="95f9" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤2:向所有用户发布新版本</h2><p id="2076" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">我们认为一切进展顺利，并将向所有用户部署新版本。为此，我们只需将<code class="fe op oq or os b">deploy.yaml</code>更新为新的镜像版本，并将副本设置为10。在<code class="fe op oq or os b">deploy-canary.yaml</code>中，我们将副本设置回0。部署后的结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/1e3090720537511ee8c140750ab60b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYEmxgenup-PRURKghGjiw.png"/></div></div></figure><h1 id="4f3d" class="ne la it bd lb nf ng nh le ni nj nk lh jz nl ka ll kc nm kd lp kf nn kg lt no bi translated">概述</h1><p id="0c63" class="pw-post-body-paragraph mp mq it lx b ly lz ju ms ma mb jx mu li np mw mx lm nq mz na lq nr nc nd mf im bi translated">对我来说，手动运行这种部署有助于理解使用k8s进行配置是多么容易。因为Kubernetes允许通过API更新一切，所以这些步骤也可以通过脚本自动化。</p><p id="cd57" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">要实现的另一件事是一个测试入口点(LoadBalancer或via Ingress ),它只公开新版本。这可用于人工审查。</p><p id="9b89" class="pw-post-body-paragraph mp mq it lx b ly mr ju ms ma mt jx mu li mv mw mx lm my mz na lq nb nc nd mf im bi translated">在接下来的文章中，我们将检查其他自动化解决方案，它们处理了我们所做的大部分工作。</p></div></div>    
</body>
</html>