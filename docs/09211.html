<html>
<head>
<title>Building a Basic Website with Flask and SQLAlchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Flask和SQLAlchemy构建一个基本网站</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-basic-website-with-flask-and-sqlalchemy-2f66ea6c02dc?source=collection_archive---------0-----------------------#2021-07-16">https://levelup.gitconnected.com/building-a-basic-website-with-flask-and-sqlalchemy-2f66ea6c02dc?source=collection_archive---------0-----------------------#2021-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="75c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建最小后端的快速教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b5f99af72d46d30c5ac5c393c5bdeb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R69OGJPYwEWyP-i6"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ee2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://flask.palletsprojects.com/en/2.0.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>是一个轻量级的、非常灵活的框架，用于用Python创建网站后端。除了抽象复杂的web概念，如路由、呈现HTML文档和处理静态文件，还可以很容易地与Python的许多库集成。</p><p id="3153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了展示它的威力，本教程将开发一个简单的网站来维护电影及其<a class="ae ky" href="https://www.imdb.com/chart/top/" rel="noopener ugc nofollow" target="_blank"> IMDb评分</a>。这个网站将是一个CRUD，代表创建、读取、更新和删除，这是数据库的基本操作。这是一个很好的介绍，因为几乎每个网站，从最基本的形式来看，都是一个CRUD。甚至像脸书和YouTube这样的巨头也在记录和修改数据库中的记录。</p><p id="d954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于将执行数据库操作，因此将使用<a class="ae ky" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>。这个库被命名为toolkit和<a class="ae ky" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">Object Relational Mapper(ORM)</a>，它将允许Python代码直接修改数据库，而不是编写原始SQL。虽然本教程将使用<a class="ae ky" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> SQLite </a>进行演示，但大部分代码只需稍加修改就可以适用于更具可伸缩性的数据库，如MySQL或PostgreSQL。</p><h1 id="9098" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置数据库</h1><p id="3270" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在使用后端的任何其他部分被创建之前，需要初始化一个数据库。为了保持有序，创建一个名为“Project”的目录，并在其中创建一个名为“MovieDB”的子目录，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0f73" class="mx lw it mt b gy my mz l na nb">Project<br/>├──<!-- -->MovieDB</span></pre><p id="d7ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在MovieDB目录中，创建一个名为“SetupDB.py”的Python文件。这将是我们用来建立数据库的文件。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="29a1" class="mx lw it mt b gy my mz l na nb"># Imports<br/>from sqlalchemy import Column, Integer, String, Float<br/>from sqlalchemy.ext.declarative import declarative_base<br/>from sqlalchemy.orm import sessionmaker<br/>from sqlalchemy import create_engine</span></pre><p id="f389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件的前几行将导入SQLAlchemy库的强制组件。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9f57" class="mx lw it mt b gy my mz l na nb"># Pass a declarative base and create a object to correspond with a table in the database<br/>Base = declarative_base()<br/>    <br/>class Movie(Base):<br/>    <br/>    __tablename__ = 'movie'</span><span id="eaab" class="mx lw it mt b gy nc mz l na nb">    movie_id = Column(Integer, primary_key=True)<br/>    title = Column(String(250), nullable=False)<br/>    rating = Column(Float)</span></pre><p id="1b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将base声明为声明性Base之后，将创建一个新的类，其属性将与movies数据库中的列相关联。movie_id属性是一个整数值，它将作为该表的主键。标题是一个简单的字符串，最多250个字符。最后，评级是一个简单的浮动值。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bec9" class="mx lw it mt b gy my mz l na nb"># Connect to and create the movie table<br/>engine = create_engine("sqlite:///movies_database.db")<br/>Base.metadata.create_all(engine)</span></pre><p id="d1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一段代码连接到“movies_database.db”的任何SQLite实例。如果没有任何实例，它将创建一个新的数据库文件。最后一行实际上创建了一个对应于电影类的表。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="52de" class="mx lw it mt b gy my mz l na nb"># Start a session with the database<br/>Session = sessionmaker(bind=engine)<br/>session = Session()</span><span id="2540" class="mx lw it mt b gy nc mz l na nb"># create a new movie and enter it into the database<br/>new_movie = Movie(title = "The Shawshank Redemption", rating = 9.2)<br/>session.add(new_movie)<br/>session.commit()<br/>session.close()</span></pre><p id="d0d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的几行只是创建一个与数据库交互的新会话。为了验证它的有效性，从movie类创建了一个名为new_movie的对象，使用<em class="nd"> The Shawshank Redemption </em>来测试它的模板。</p><p id="b768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后调用会话将new_movie对象添加到数据库中，并调用commit保存它。</p><p id="42bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入下一节之前，创建一个名为“__init__”的新Python文件。py”并将其留空。这有助于使刚刚编写的代码成为一个以后可能会被调用的模块。如果使用SQLite，最终的文件结构应该如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4ecc" class="mx lw it mt b gy my mz l na nb">Project<br/>├──<!-- -->MovieDB<br/>    <!-- -->├──__init__.py<br/>    ├──<!-- -->SetupDB.py<br/>    <!-- -->├──<!-- -->movies_database.db</span></pre><h1 id="ba83" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建记录</h1><p id="e9e4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">回到主项目目录，创建一个名为“templates”的新子目录，并在其中创建一个名为“create.html”的新HTML文件</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8da3" class="mx lw it mt b gy my mz l na nb">Project<br/>├──<!-- -->MovieDB<br/>    <!-- -->├──__init__.py<br/>    ├──<!-- -->SetupDB.py<br/>    <!-- -->├──<!-- -->movies_database.db<br/>├──templates<br/>    ├──create.html</span></pre><p id="94ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个HTML文件将作为输入新电影和分级的主要表单。由于本教程主要关注后端，HTML本身将会非常简单。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8568" class="mx lw it mt b gy my mz l na nb">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;<br/>  &lt;form action = "/createmovie" method = "POST"&gt;<br/>    &lt;label for="name"&gt;Movie Name:&lt;/label&gt;<br/>    &lt;input type = "text" name = "name"&gt;<br/>    &lt;label for="rating"&gt;Movie Rating:&lt;/label&gt;<br/>    &lt;input type = "number" min = "0" max = "10" step = "0.1" name = "rating"&gt; <br/>    &lt;input type = "submit" value = "Submit"&gt;<br/>  &lt;/form&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="0087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有输入标签都封装在一个form元素中，该元素的action设置为“/createmovie”。这将是表单调用来创建记录的最终URL。输入元素相当简单。文本输入捕获标题，数字输入用于评级。后者通过设置0-10之间的范围和0.1的步长来进一步修改，以确保正确设置评级。</p><p id="24b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终结果将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/b5ba1767d53fa4a2192b92e8f4cf6b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihUvZ65FnvfzaY5U9UdJ-w.png"/></div></div></figure><p id="dd05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到主项目目录，创建一个名为“MovieApp.py”的新Python文件。这将是网站实际服务的主要文件。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7aee" class="mx lw it mt b gy my mz l na nb">from sqlalchemy.orm import sessionmaker<br/>from sqlalchemy import create_engine</span><span id="d21c" class="mx lw it mt b gy nc mz l na nb"># Import from your custom module<br/>from MovieDB.SetupDB import Movie</span></pre><p id="a00f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，从SQLAlchemy进行相同的导入。此外，从MovieDB进行导入，movie db是在上一节中创建的定制模块。从这个模块中，导入类Movie。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="17e0" class="mx lw it mt b gy my mz l na nb"># Connect to the database<br/>engine = create_engine("sqlite:///MovieDB//movies_database.db")</span></pre><p id="5318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，必须创建到数据库的连接。请注意，路径no包含了MovieDB文件夹。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f0f0" class="mx lw it mt b gy my mz l na nb"># Basic Flask imports<br/>from flask import Flask, request, redirect, url_for, render_template<br/># Initialize Flask<br/>app = Flask(__name__)</span></pre><p id="352a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的几行导入Flask库的基本部分并初始化应用程序。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7982" class="mx lw it mt b gy my mz l na nb"># routing for creating new records (the 'C' in CRUD)<br/><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/create")<br/>def create():<br/>    return render_template("create.html")</span></pre><p id="3ea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些行只是路由一个URL来服务create.html。当正确运行时，这将创建一个新的网页，但它实际上并没有在数据库中创建任何新的记录。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="aa58" class="mx lw it mt b gy my mz l na nb"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/createmovie", methods = ["POST", "GET"])<br/>def createMovie():<br/>    <br/>    if request.method == "POST":<br/>        # Get the data from the form and placed into a variable. <br/>        input_data = request.form<br/>        <br/>        # A new session will have to be created in every function<br/>        Session = sessionmaker(bind=engine)<br/>        session = Session()<br/>        <br/>        # create a new movie and enter it into the database<br/>        new_movie = Movie(title = input_data["name"], rating = input_data["rating"])<br/>        session.add(new_movie)<br/>        session.commit()<br/>        session.close()</span><span id="2be3" class="mx lw it mt b gy nc mz l na nb">return redirect(url_for("read"))<br/>    <br/>    else:<br/>        return redirect(url_for("create"))</span></pre><p id="de76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回想一下，在编写HTML时，表单上的动作被设置为“/createmovie”。这个代码块表示按下提交按钮时的后端操作。请注意，在route方法中，methods参数必须包含POST。</p><p id="2f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求对象将保存表单中的所有信息。因此，可以调用request.method来确保它实际上是一个POST方法。此外，可以从request.form调用表单的实际属性，即电影标题及其分级，并将其存储在变量input_data中。</p><p id="5e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQLAlchemy中创建了一个新会话，并使用input_data中的输入从movie类中创建了一个新对象new_movie。会话添加新电影并提交更改。</p><p id="1ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在演示中直接在数据库中传递输入是好的，但实际上，应该执行某种形式的验证。应该采取额外的步骤来确保输入是正确的数据类型或者在正确的范围内。在最坏的情况下，它可以防止垃圾数据，在最好的情况下，它可以阻止恶意攻击。</p><p id="1888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结尾的重定向将把用户带到阅读页面，该页面将在下一节中创建。</p><h1 id="fa29" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">读取数据</h1><p id="47e3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">添加记录没有多大作用，除非这些记录可以被查看。因此，必须在templates子目录下创建一个新的HTML文件来显示电影。文件结构现在应该如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2a3d" class="mx lw it mt b gy my mz l na nb">Project<br/>├──<!-- -->MovieDB<br/>    <!-- -->├──__init__.py<br/>    ├──<!-- -->SetupDB.py<br/>    <!-- -->├──<!-- -->movies_database.db<br/>├──templates<br/>    ├──create.html<br/>    ├──read.html<br/>├──MovieApp.py</span></pre><p id="7498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">read.html不会使用纯HTML，而是利用jinja模板引擎以编程方式将电影及其评级输入到网页中。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a1d5" class="mx lw it mt b gy my mz l na nb">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;<br/>  &lt;table border = 1&gt;<br/>    {% for movie in query %}<br/>      &lt;tr&gt;<br/>        &lt;th&gt;<br/>        &lt;a href = "/movie/{{ movie.movie_id }}"&gt; {{ movie.title }}&gt; <br/>        &lt;/a&gt;<br/>        &lt;/th&gt;<br/>        &lt;td&gt; {{ movie.rating }} &lt;/td&gt;<br/>      &lt;/tr&gt;<br/>    {% endfor %}<br/>  &lt;/table&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然上面的大部分代码显示为普通的HTML，但是花括号介绍了jinja模板语言。在这种情况下，名为query的对象将被传递到HTML中。对于查询中的每一项，表中的一行将添加标题和评级。</p><p id="2f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，将在电影的标题上创建一个链接，指向电影的编辑页面，该页面将在下一部分中生成。</p><p id="d20c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，回到MovieApp文件，这个页面需要得到适当的服务。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0a68" class="mx lw it mt b gy my mz l na nb"># Routing for simply reading the database (the 'R' in CRUD)<br/><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/read")<br/>def read():<br/>    <br/>    # Start this page's session<br/>    Session = sessionmaker(bind=engine)<br/>    session = Session()<br/>    <br/>    # Query all results from the database<br/>    query = session.query(Movie).all()<br/>    <br/>    # render the template and pass the query into the html<br/>    return render_template("read.html", query = query)</span></pre><p id="c38a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上一节相比，这里使用了更简单的路由方案。启动一个新的会话，并对电影表进行查询。</p><p id="bdfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，查询将从表中检索所有电影。这很好，因为这个数据库很小，但是在表可能包含数百万条记录的环境中，这是一个非常糟糕的主意。应该应用某种过滤器来代替。</p><p id="fede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用同一个render_template函数，该函数返回read.html，但请注意query的附加参数。查询变量被传递给参数，参数会在HTML呈现之前将其自身注入到HTML中。最终结果应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7782dd5eac7b091739ab0cd26290d91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*r5yRnBw1vPbgQ8ZNuX4ARg.png"/></div></figure><h1 id="856a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">编辑和删除记录</h1><p id="38b8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">创建CRUD的最后一步是更新和删除记录。像以前一样，在模板子目录中创建一个名为edit.html的新HTML文件。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6157" class="mx lw it mt b gy my mz l na nb">Project<br/>├──<!-- -->MovieDB<br/>    <!-- -->├──__init__.py<br/>    ├──<!-- -->SetupDB.py<br/>    <!-- -->├──<!-- -->movies_database.db<br/>├──templates<br/>    ├──create.html<br/>    ├──read.html<br/>    ├──edit.html<br/>├──MovieApp.py</span></pre><p id="2d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与之前创建的HTML非常相似，edit.html将包含一个表单，用于将通信和Jinja格式传递回服务器。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5bb3" class="mx lw it mt b gy my mz l na nb">&lt;html&gt;<br/>&lt;body&gt;<br/>  &lt;form action = "/editmovie/{{ query.movie_id }}" method = "POST"&gt;<br/>    &lt;label for="name"&gt;Movie Name:&lt;/label&gt;<br/>    &lt;input type = "text" name = "name" value = "{{ query.title }}"&gt;<br/>    &lt;label for="rating"&gt;Movie Rating:&lt;/label&gt;<br/>    &lt;input type = "number" min = "0" max = "10" step = "0.1" name = "rating" value = "{{ query.rating }}"&gt; <br/>    &lt;input type = "submit" value = "Update"&gt;<br/>  &lt;/form&gt;<br/>  &lt;form action = "/deletemovie/{{ query.movie_id }}" method = "POST"&gt;<br/>    &lt;input type = "submit" value = "Delete"&gt;<br/>  &lt;/form&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d4c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍微复杂一点，这个edit.html实际上有两个窗体部分。第一个看起来非常类似于create.html，但一些关键的区别突出。首先，这个动作不是硬编码的，而是使用Jinja模板调用带有特定电影ID的URL。这将在烧瓶部分进行。接下来，输入标签有默认值，也是用Jinja模板创建的。</p><p id="11fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任一种情况下，查询对象都将被调用，其属性title和rating将填充空白。</p><p id="4cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种形式调用删除电影的URL操作。这个表单中的一个输入就创建了一个删除按钮。</p><p id="d4b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到MovieApp.py，需要创建到三个新URL的路由。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="77f0" class="mx lw it mt b gy my mz l na nb"># Routing for editing a movie, including deletion (the 'U' and 'D' in CRUD)<br/><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/movie/&lt;movie_id&gt;")<br/>def edit(movie_id):<br/>    <br/>    # Start this page's session<br/>    DBSession = sessionmaker(bind=engine)<br/>    session = DBSession()<br/>    <br/>    # Query the movie based on the id<br/>    query = session.query(Movie).filter(Movie.movie_id == movie_id).one()    <br/>    <br/>    session.close()<br/>    <br/>    # Render the html with the query passed through it<br/>    return render_template("edit.html", query = query)</span></pre><p id="19d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在路由中，尖括号(“&lt;&gt;”)表示附加到URL的变量。在这种情况下，一旦它运行，www。{base}。com/movie/1会将电影ID 1传递给该函数，并返回相应电影的详细信息。</p><p id="0c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，创建了一个新的会话，查询调用了具有指定ID的电影的单个结果。这个信息然后被传递给HTML。</p><p id="136c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这呈现了页面，但还没有做出任何更改。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="978d" class="mx lw it mt b gy my mz l na nb"># Routing to actually update the movie<br/><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/editmovie/&lt;movie_id&gt;", methods = ["POST", "GET"])<br/>def editMovie(movie_id):<br/>    <br/>    if request.method == "POST":<br/>        # Get the data from the form and placed into a variable. <br/>        input_data = request.form<br/>        <br/>        # A new session will have to be created in every function<br/>        DBSession = sessionmaker(bind=engine)<br/>        session = DBSession()<br/>        <br/>        # Search for the movie to change based on the movie id<br/>        query = session.query(Movie).filter(Movie.movie_id == movie_id).one()  <br/>        <br/>        # Write the changes to the database<br/>        query.title = input_data["name"]<br/>        query.rating = input_data["rating"]<br/>        session.commit()<br/>        session.close()</span><span id="1953" class="mx lw it mt b gy nc mz l na nb">return redirect(url_for("read"))<br/>    <br/>    else:<br/>        return redirect(url_for("read"))</span></pre><p id="3a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编辑电影的路线没有引入任何新的东西。利用相同的尖括号，传递相同的电影ID，创建会话，并运行查询。惟一新颖的部分是使用从表单请求中提取的input_data变量对查询进行了更改。在此步骤之后，会话被提交并关闭。</p><p id="b0d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与创建新记录一样，还应该执行额外的输入验证。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="82d8" class="mx lw it mt b gy my mz l na nb"># Routing for deleting a movie<br/><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/deletemovie/&lt;movie_id&gt;", methods = ["POST", "GET"])<br/>def deleteMovie(movie_id):<br/>    if request.method == "POST":<br/>        <br/>        # A new session will have to be created in every function<br/>        DBSession = sessionmaker(bind=engine)<br/>        session = DBSession()<br/>        <br/>        # Search for the movie to change based on the movie id<br/>        query = session.query(Movie).filter(Movie.movie_id == movie_id).one()<br/>        <br/>        # Delete the row<br/>        session.delete(query)<br/>        session.commit()<br/>        session.close()<br/>        <br/>        return redirect(url_for("read"))<br/>        <br/>    else:<br/>        return redirect(url_for("read"))</span></pre><p id="72b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删除电影的路径几乎相同。唯一的区别是delete方法是在session对象上调用的。</p><p id="ad4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的唯一代码是实际运行应用程序:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9558" class="mx lw it mt b gy my mz l na nb">if __name__ == '__main__':<br/>    app.run()</span></pre><h1 id="4138" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">把所有的放在一起</h1><p id="0340" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果一切顺利，所有的部分都在一起，一个功能齐全的网站将允许用户创建一个带评级的新电影，在主表上阅读，编辑，甚至删除它。</p><p id="7f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，它应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/17c5b25f78a4a0affbff4c2d1908e370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*L9OEoGzUyJeVcMM7HZQw0Q.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">网站演示。作者制作的Gif。</figcaption></figure><p id="a854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的演示中，一部评级为9.1的新电影<em class="nd">教父</em>被添加到数据库中。电影将被添加到下一页的表格中。之后，按下桌上的链接，分数更新为9.2。结果再次显示在桌面上。最后，同一个页面的同一个链接可以跟随到删除按钮，当按下该按钮时，从数据库中删除电影。</p><p id="ee85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个基本的垃圾。它缺少很多关键特性，比如验证用户输入或前端样式，但是这两个概念都超出了本教程的范围。相反，它是实际网站创建的基本蓝图。</p><h1 id="14e4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="48e5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Flask和SQL Alchemy的结合可以创建健壮的CRUD应用程序。Flask将许多困难的web概念抽象成单行代码，SQL Alchemy允许使用数据库，而不用担心连接或手动编写查询。总的来说，它们允许有更多的时间实际创建后端，而不是担心小细节。</p><p id="e089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然为了简洁起见，本教程排除了输入验证等重要特性，但实际的结构就像一个网站的骨架一样，只需要非常少的几行代码。</p></div></div>    
</body>
</html>