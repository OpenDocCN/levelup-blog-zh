# 专业版之路-特别版:仿制药

> 原文：<https://levelup.gitconnected.com/road-to-go-pro-special-edition-generics-88d6ac2b5b6c>

*在我们开始之前，你可以在这个* [*资源库*](https://github.com/songx23/RoadToGoPro) *中找到本教程使用的代码。你可以在这里* *找到 Road to Go Pro* [*的全部内容。如果你错过了最后一个，你可以通过这个*](https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad) [*链接*](/road-to-go-pro-async-part-3-locks-8bf60c476b12) *找到。*

欢迎来到 Road to Go Pro 特别版。我开始这个新的 Go stories 分支是因为 Go 1.18 终于发布了。这个版本带来了一些令人兴奋的新功能，我迫不及待地想与你分享。我将创建 3 个故事来回顾 1.18 中的主要特性，即泛型、模糊化和工作空间。让我们从泛型开始。

# 无商标消费品

![](img/2b6d5e67f93d4520145bb17c218a6efa.png)

照片由[赵家伟](https://unsplash.com/@jiaweizhao?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在 Go 于 2012 年发布后，开发者们只花了 30 分钟就请求将泛型作为一种语言特性包含进来。10 年后，这一期待已久的功能终于推出。尽管这是最受欢迎的特性之一，但我并不希望 Go 能支持更多的通用代码。我们在没有它的情况下生存了 10 年，所以我们可以再这样做 10 年？开玩笑的。

泛型仍然很有价值，它解决了 Go 中的一个常见问题。在我的日常工作中，我编写了一个简单的函数来多次检查一个字符串片段是否包含一个特定的字符串。

该函数检查字符串片段是否包含特定的字符串

这可能是最容易编写的函数之一。由于函数参数中指定的类型，我们只能使用这个函数来检查字符串切片。如果我们需要检查整数切片，我们就不走运了。由于 Go 不支持泛型，我们必须编写另一个函数。

该函数检查 int 切片是否包含特定的 int

哎哟，这里有很多重复，这让“懒惰”的工程师很不舒服。这两个函数的函数体**完全**相同。唯一的区别是函数参数的类型。想象一下，如果我们需要对 floats 或任何其他结构做同样的事情，我们将会写一堆“重复的”函数。没有人喜欢做那件事。

泛型可以帮助我们解决这个问题。它有助于从函数中去掉类型因素。我们只需要编写一个通用函数，它可以处理我们想要的任何类型。听起来很棒。现在，让我们看看 Go 中的泛型语法是什么样子的。

通用包含函数

泛型函数体仍然和它的非泛型表亲完全一样。我们改变函数签名，使其通用。

除了正常的函数参数，通用函数需要额外的类型约束(可以有一个或多个)，这些约束用方括号`[]`括起来。

## 类型约束

与函数参数类似，声明类型约束需要类型名和约束类型。有两种方法可以指定约束类型。

最简单的方法是内联指定它。由于这是一个类型约束，我们需要为通用函数指定所有可接受的类型，并用`|`将它们连接起来。例如，如果我们想编写一个通用的`contains`函数来检查`int`和`string`类型，我们可以将其类型约束声明为`[TypeName int | string]`。一个约束中的类型数量可以从一个到多个不等。如果列表太长，最好使用另一种方式来获得更好的可读性。

另一种方法是将约束声明为一个`interface{}`。如上面的示例代码所示，我们可以将内联约束声明移动到一个接口中。然后使用这个接口作为函数签名中的类型。它不仅可以使代码更容易阅读，还可以使类型约束可重用。

我们也可以使用普通接口(用函数签名代替链式类型)作为约束类型。这意味着泛型函数接受任何实现该接口的结构。这里有一个例子:

接口类型约束

`Magic`和`CustomError`结构都实现了`Stringer`接口。因此，它们都被`GenericsToString`函数接受。

使用接口约束调用通用函数

运行 main 函数后，我们可以看到程序正确地打印出了咒语和客户错误。“昂贵的石油”！哦，对不起，我的意思是“期待守护神”！

```
This is a Protection Spell. Repeat after me: Expecto Patronum
This is a meme. Repeat after me: Expensive Petroleum
Error: status code 501, error message Panic! Your code is on fire!
```

我希望以上解释了如何声明泛型函数以及如何使用它们。当我在写示例函数的时候，一个问题突然出现在我的脑海里。泛型功能比它的非泛型表亲慢吗？当上帝打开一扇窗时，他会关上一扇门。泛型是好的，但它可能会带来性能损失。

## 表演

在这个[之前的故事](/road-to-go-pro-async-part-2-channels-12645a160f73)中，我们学习了 Go 基准测试工具。在这里，我们也可以用它来测试泛型函数和非泛型函数的性能。我们将使用`contains`函数作为我们的目标。下面的测试函数用字符串类型对`contains`函数进行了基准测试。为了公平竞争，我们给他们同样的参数。

通用和非通用函数的基准函数

这是在 M1 Macbook 上运行的结果。

```
# Non-generic function
BenchmarkStringSliceContains-10     145600888          8.138 ns/op# Generic function
BenchmarkSliceContains_String-10     145776253          8.228 ns/op
```

我很高兴看到这两个函数的性能结果非常相似。我想当上帝打开一扇窗时，他也能打开一扇门。泛型在不牺牲性能的情况下增加了泛型代码支持。向 Go 开发团队致敬。

你对这个新功能有什么看法？你喜欢还是不喜欢？请在下面留下评论，我很想听听你的看法。

# 下一步是什么？

![](img/3228c2c2651ca66f20e5c36b04c737b4.png)

在这个故事中，我们探索了 Go 1.18 闪亮的新泛型特性。我敢肯定，相当多的开发人员都在庆祝这一功能终于来了。对于下一个特别版的故事，我们将检查另一个新功能:起毛。这是添加到已经很棒的测试工具包中的一个方便的测试工具。敬请期待！

**如果你遇到任何问题或者需要帮助，请在下面留下你的评论。随时欢迎反馈。感谢您的阅读！**

如果你想支持我，你可以通过这个推荐链接成为一个中等会员。谢谢你。

[](https://songx.medium.com/membership) [## 用我的推荐链接加入 Medium 宋 x。

### 作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…

songx.medium.com](https://songx.medium.com/membership)