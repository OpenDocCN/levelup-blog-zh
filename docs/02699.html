<html>
<head>
<title>Laying the Rails from AWS API Gateway to ECS Fargate | Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">铺设从AWS API网关到ECS Fargate的轨道|第二部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/laying-the-rails-from-aws-api-gateway-to-ecs-fargate-part-ii-7b9294ead2e4?source=collection_archive---------6-----------------------#2020-03-30">https://levelup.gitconnected.com/laying-the-rails-from-aws-api-gateway-to-ecs-fargate-part-ii-7b9294ead2e4?source=collection_archive---------6-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b5d02ee679be06352199bf39e4da8376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSruvb9Fm65k6QO5G-pirg.png"/></div></div></figure><p id="29e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前情提要，我描述了从API网关到VPC链接的集成线路。</p><div class="la lb gp gr lc ld"><a href="https://medium.com/@lucjross/laying-the-rails-from-aws-api-gateway-to-ecs-fargate-part-i-debf754d6a8b" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">铺设从AWS API Gateway到ECS Fargate的轨道|第一部分</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">在两个不兼容的资源之间建立网络路径的指南</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">medium.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jz ld"/></div></div></a></div><p id="cd35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二部分将涵盖其余部分，从网络负载平衡器到ECS任务。让我们跳进来。</p><h1 id="eb5c" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">网络负载平衡器</h1><h2 id="d425" class="mq lt it bd lu mr ms dn ly mt mu dp mc km mv mw mg kq mx my mk ku mz na mo nb bi translated">基本原理</h2><p id="1a48" class="pw-post-body-paragraph kb kc it kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">为什么将API Gateway连接到网络负载平衡器，而不是直接连接到应用程序负载平衡器？基本上，这是因为VPC服务端点只连接到NLB，而VPC服务端点是API Gateway的——呃，是我们VPC的网关。</p><p id="177d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设，如果我们希望API Gateway通过互联网访问我们的服务，我们可以使用一个带有公共DNS名称的面向互联网的ALB，但是我们不希望从互联网访问我们的ALB。如果是的话，我们会有另一个潜在的安全漏洞，特别是考虑到我们没有将身份验证与ALB集成，而只是与网关集成。所以，我把负载平衡器做成了内部的，这样就避免了给它们附加公共IP。这使得VPC(或对等VPC)之外的任何设备都无法访问它们。但是，VPC服务端点可以连接到NLB，而不考虑其子网关联。</p><p id="834e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果Amazon做了一件小事，我们的实现可能会简单得多:在应用程序负载平衡器侦听器规则中允许Cognito客户端凭证认证。据我所知，它只与“授权代码授权”和“隐式授权”流集成，这是为使用web浏览器的人设计的。从图中可以看到，内部ALB直接与ECS任务接口。如果ALB支持简单的客户端凭证OAuth流，我们将只使用一个外部ALB来代替，然后，API Gateway就不必添加太多。</p><h2 id="694f" class="mq lt it bd lu mr ms dn ly mt mu dp mc km mv mw mg kq mx my mk ku mz na mo nb bi translated">基础设施实施</h2><p id="f800" class="pw-post-body-paragraph kb kc it kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">让我们创建NLB及其非特定于服务的资源。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="f7f7" class="mq lt it nm b gy nq nr l ns nt">resource "aws_lb" "network" {<br/>  name = "${var.stage}-nlb"<br/>  load_balancer_type = "network"<br/>  enable_cross_zone_load_balancing = true<br/>  internal = true<br/>  subnets = var.private_subnet_ids<br/>  access_logs {<br/>    enabled = true<br/>    bucket = var.nlb_logs_bucket_id<br/>    prefix = ""<br/>  }<br/>}<br/><br/>resource "aws_lb_target_group" "nlb_80" {<br/>  name = "nlb-80"<br/>  protocol = "TCP"<br/>  port = 80<br/>  target_type = "ip"<br/>  vpc_id = var.vpc_id<br/>  proxy_protocol_v2 = false<br/>}<br/><br/>resource "aws_lb_target_group" "nlb_443" {<br/>  name = "nlb-443"<br/>  protocol = "TLS"<br/>  port = 443<br/>  target_type = "ip"<br/>  vpc_id = var.vpc_id<br/>  proxy_protocol_v2 = false<br/>}<br/><br/>resource "aws_lb_listener" "nlb_80" {<br/>  load_balancer_arn = aws_lb.network.arn<br/>  protocol = "TCP"<br/>  port = 80<br/>  default_action {<br/>    type = "forward"<br/>    target_group_arn = aws_lb_target_group.nlb_80.arn<br/>  }<br/>}<br/><br/>resource "aws_lb_listener" "nlb_443" {<br/>  load_balancer_arn = aws_lb.network.arn<br/>  protocol = "TLS"<br/>  port = 443<br/>  certificate_arn = var.server_certificate_arn<br/>  default_action {<br/>    type = "forward"<br/>    target_group_arn = aws_lb_target_group.nlb_443.arn<br/>  }<br/>}</span></pre><p id="39cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们已经创建了两个目标组，一个用于端口80上的TCP，另一个用于端口443上带有TLS的TCP。API Gateway实际上不允许不安全的HTTP流量，但是我认为对于内部负载平衡器来说，提供一个非TLS路径对于VPC内部与我们的示例服务(<em class="kz"> ice-station-zebra </em>)的集成是很好的。此外，这是我最初的错误观念的残余，即API Gateway确实允许端口80，我是一个LB侦听器贮藏者——我还有数百个，只是收集网络灰尘。</p><p id="2a4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些监听器没有<em class="kz">监听器规则</em>，因为每个监听器的<code class="fe nu nv nw nm b">default_action</code>将足以路由到目标组。此外，<code class="fe nu nv nw nm b">nlb_443</code>监听器的服务器证书可以是自签名的，也可以是真实证书颁发机构签名的。它不像公共网站，当他们出示自签名或其他可疑的SSL证书时，应该被视为非法。来自已经在API网关端接受证书的客户端的流量应该能够假设网关后面的任何东西都是可信的，因此对于内部组件来说，证书只是一个逻辑需求。</p><h1 id="08cc" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">应用负载平衡器</h1><p id="67cd" class="pw-post-body-paragraph kb kc it kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">您可能想知道，当NLB可以直接针对ECS任务时，我们为什么还要使用ALB。ALB支持更复杂的路由规则，可以在多个端口上转发流量。NLB提供了更高的性能，因为它们在较低的级别上运行，但它们不提供我们进行这种集成所需的基于路径的路由功能，无论如何，Amazon推荐并支持ALB与ECS Fargate进行负载平衡。</p><h2 id="90b9" class="mq lt it bd lu mr ms dn ly mt mu dp mc km mv mw mg kq mx my mk ku mz na mo nb bi translated">基础设施</h2><p id="536d" class="pw-post-body-paragraph kb kc it kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">在调配ALB时，我们需要为其指定一个安全组，这与NLB不同，后者不适用安全组。我们可以简单地允许所有端口上的所有出口和端口80上的所有入口，因为它是VPC的内部端口。默认的目标组不是必须使用的，但是我们需要一个用于监听器的默认动作。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="9e89" class="mq lt it nm b gy nq nr l ns nt">resource "aws_security_group" "alb_internal" {<br/>  vpc_id = var.vpc_id<br/>  name = "alb-internal"<br/>}<br/><br/>resource "aws_security_group_rule" "alb_internal_egress" {<br/>  type = "egress"<br/>  from_port = "0"<br/>  to_port = "0"<br/>  protocol = "-1"<br/>  cidr_blocks = ["0.0.0.0/0"]<br/>  security_group_id = aws_security_group.alb_internal.id<br/>}<br/><br/>resource "aws_security_group_rule" "alb_internal_http_ingress" {<br/>  type = "ingress"<br/>  from_port = 80<br/>  to_port = 80<br/>  protocol = "tcp"<br/>  cidr_blocks = ["0.0.0.0/0"]<br/>  security_group_id = aws_security_group.alb_internal.id<br/>}<br/><br/>resource "aws_lb" "internal" {<br/>  name = local.internal_alb_name<br/>  internal = true<br/>  load_balancer_type = "application"<br/>  security_groups = [<br/>    aws_security_group.vpc.id,<br/>    aws_security_group.alb_internal.id,<br/>  ]<br/>  subnets = var.private_subnet_ids<br/>  idle_timeout = 60<br/>  ip_address_type = "ipv4"<br/>  access_logs {<br/>    enabled = true<br/>    bucket = var.alb_internal_access_logs_bucket_id<br/>    prefix = ""<br/>  }<br/>}<br/><br/>resource "aws_lb_target_group" "alb_internal_default" {<br/>  name = "alb-internal-default"<br/>  port = 80<br/>  protocol = "HTTP"<br/>  vpc_id = var.vpc_id<br/>  target_type = "ip"<br/>  deregistration_delay = 10<br/>  lifecycle {<br/>    create_before_destroy = true<br/>  }<br/>}<br/><br/>resource "aws_lb_listener" "alb_internal_http" {<br/>  load_balancer_arn = aws_lb.internal.arn<br/>  port = 80<br/>  protocol = "HTTP"<br/>  default_action {<br/>    target_group_arn = aws_lb_target_group.alb_internal_default.arn<br/>    type = "forward"<br/>  }<br/>}<br/><br/>resource "aws_lb_listener" "alb_internal_http_443" {<br/>  count = local.nlb_count<br/>  load_balancer_arn = aws_lb.internal.arn<br/>  port = 443<br/>  protocol = "HTTPS"<br/>  certificate_arn = var.server_certificate_arn<br/>  default_action {<br/>    target_group_arn = aws_lb_target_group.alb_internal_default.arn<br/>    type = "forward"<br/>  }<br/>}</span></pre><p id="4d85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我的图表所示，这个负载平衡器是TLS的终点。读者对终止的需求可能会有所不同，或者可以在NLB或在ECS任务中完成。我选择终止于ALB，因为它尽可能地靠近服务，而没有在服务上安装证书的复杂性。</p><h2 id="d808" class="mq lt it bd lu mr ms dn ly mt mu dp mc km mv mw mg kq mx my mk ku mz na mo nb bi translated">静态IPs</h2><p id="216a" class="pw-post-body-paragraph kb kc it kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">为了在NLB之后直接引入ALB，我们必须解决它们之间的不兼容性。ALB的IP地址是动态的，这对于用DNS CNAME记录引用它们的通常情况来说是很好的，但是NLB没有办法自己跟上这些变化。为了解决这个问题，我将提供AWS博客文章<a class="ae nx" href="https://aws.amazon.com/blogs/networking-and-content-delivery/using-static-ip-addresses-for-application-load-balancers/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">的一个实现，为应用程序负载平衡器使用静态IP地址</em> </a>。</p><p id="0ee4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们将创建“IP列表”桶。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="17cc" class="mq lt it nm b gy nq nr l ns nt">resource "aws_s3_bucket" "internal_alb_static_ips" {<br/>  bucket = "${var.stage}-internal-alb-static-ips"<br/>  acl = "private"<br/>  region = data.aws_region.this.name<br/><br/>  versioning {<br/>    enabled = true<br/>  }<br/>}</span></pre><p id="8c70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们将向Lambda提供IAM资源。它需要访问CloudWatch、S3和弹性负载平衡。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="c77e" class="mq lt it nm b gy nq nr l ns nt">data "aws_iam_policy_document" "lambda_assume_role" {<br/>  statement {<br/>    actions = ["sts:AssumeRole"]<br/>    principals {<br/>      type = "Service"<br/>      identifiers = ["lambda.amazonaws.com"]<br/>    }<br/>  }<br/>}<br/><br/>resource "aws_iam_role" "nlb_tg_to_alb_lambda" {<br/>  name = "nlb-tg-to-alb-lambda"<br/>  assume_role_policy = data.aws_iam_policy_document.lambda_assume_role.json<br/>}<br/><br/>data "aws_iam_policy_document" "nlb_tg_to_alb_lambda" {<br/>  statement {<br/>    actions = [<br/>      "logs:CreateLogGroup",<br/>      "logs:CreateLogStream",<br/>      "logs:PutLogEvents",<br/>    ]<br/>    resources = ["arn:aws:logs:*:*:*"]<br/>  }<br/>  statement {<br/>    actions = [<br/>      "s3:GetObject",<br/>      "s3:PutObject",<br/>    ]<br/>    resources = ["${aws_s3_bucket.internal_alb_static_ips.arn}/*"]<br/>  }<br/>  statement {<br/>    actions = [<br/>      "elasticloadbalancing:RegisterTargets",<br/>      "elasticloadbalancing:DeregisterTargets",<br/>    ]<br/>    resources = [<br/>      aws_lb_target_group.nlb_80.arn,<br/>      aws_lb_target_group.nlb_443.arn,<br/>    ]<br/>  }<br/>  statement {<br/>    actions = ["elasticloadbalancing:DescribeTargetHealth"]<br/>    resources = ["*"]<br/>  }<br/>  statement {<br/>    actions = ["cloudwatch:putMetricData"]<br/>    resources = ["*"]<br/>  }<br/>}<br/><br/>resource "aws_iam_role_policy" "nlb_tg_to_alb_lambda" {<br/>  role = aws_iam_role.nlb_tg_to_alb_lambda.name<br/>  policy = data.aws_iam_policy_document.nlb_tg_to_alb_lambda.json<br/>}</span></pre><p id="aebb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，从AWS教程中的链接下载Lambda函数，并将其解压缩到您的基础设施项目中。</p><p id="6d34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们用Terraform创建Lambda函数之前，我们可能需要对Lambda代码做一点小小的修改。如果您的NLB只使用端口443，您不需要这样做。如果您希望端口80上的流量也从NLB路由，则需要修改Lambda，以便它保存其IP列表，其中包含特定于目标组而不仅仅是ALB的对象名称。为此，根据这个Git diff进行更改。(图片为上下文，文字为复制+粘贴。Medium并不是共享代码的最佳媒介。)</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/793af14fb49b585eed7803fa6352385a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFcppAMVVwgoPVqpccQJqQ.png"/></div></div></figure><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="663e" class="mq lt it nm b gy nq nr l ns nt">PENDING_DEREGISTRATION_FILENAME = 'Pending deregistration IP list of {}.json'.format(ALB_DNS_NAME)<br/>ACTIVE_IP_LIST_KEY = "{}/{}/{}"\<br/>       .format(NLB_TG_ARN, ALB_DNS_NAME, ACTIVE_FILENAME)<br/>PENDING_IP_LIST_KEY = "{}/{}/{}"\<br/>       .format(NLB_TG_ARN, ALB_DNS_NAME, PENDING_DEREGISTRATION_FILENAME)</span></pre><p id="8604" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用这个shell脚本来打包Lambda，我这样做只是为了重现性——它可能只需要运行一次。执行<code class="fe nu nv nw nm b">cd</code>是为了让<code class="fe nu nv nw nm b">zip</code>只打包内容，因为如果处理程序代码不在包的根目录下，Lambda不会欣赏上传。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="2960" class="mq lt it nm b gy nq nr l ns nt"><strong class="nm iu">#!/bin/sh<br/></strong>set -e<br/><br/>(cd populate_NLB_TG_with_ALB &amp;&amp; zip -r -FS ../package/nlb-tg-to-alb-lambda.zip .)</span></pre><p id="41e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，一旦运行了shell脚本，我们就可以创建Lambdas了。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="dced" class="mq lt it nm b gy nq nr l ns nt">locals {<br/>  alb_static_ips_lambda_zip_path = "${path.module}/package/nlb-tg-to-alb-lambda.zip"<br/>}<br/><br/>resource "aws_lambda_function" "nlb_tg_to_alb_80" {<br/>  filename = local.alb_static_ips_lambda_zip_path<br/>  function_name = "nlb-tg-to-alb-80"<br/>  role = aws_iam_role.nlb_tg_to_alb_lambda.arn<br/>  handler = "populate_NLB_TG_with_ALB.lambda_handler"<br/><br/>  source_code_hash = filebase64sha256(local.alb_static_ips_lambda_zip_path)<br/><br/>  runtime = "python2.7"<br/>  memory_size = 128<br/>  timeout = 300<br/><br/>  environment {<br/>    variables = {<br/>      ALB_DNS_NAME = aws_lb.internal.dns_name<br/>      ALB_LISTENER = "80"<br/>      S3_BUCKET = aws_s3_bucket.internal_alb_static_ips.id<br/>      NLB_TG_ARN = aws_lb_target_group.nlb_80.arn<br/>      MAX_LOOKUP_PER_INVOCATION = 50<br/>      INVOCATIONS_BEFORE_DEREGISTRATION = 10<br/>      CW_METRIC_FLAG_IP_COUNT = true<br/>    }<br/>  }<br/>}<br/><br/>resource "aws_lambda_function" "nlb_tg_to_alb_443" {<br/>  filename = local.alb_static_ips_lambda_zip_path<br/>  function_name = "nlb-tg-to-alb-443"<br/>  role = aws_iam_role.nlb_tg_to_alb_lambda.arn<br/>  handler = "populate_NLB_TG_with_ALB.lambda_handler"<br/><br/>  source_code_hash = filebase64sha256(local.alb_static_ips_lambda_zip_path)<br/><br/>  runtime = "python2.7"<br/>  memory_size = 128<br/>  timeout = 300<br/><br/>  environment {<br/>    variables = {<br/>      ALB_DNS_NAME = aws_lb.internal.dns_name<br/>      ALB_LISTENER = "443"<br/>      S3_BUCKET = aws_s3_bucket.internal_alb_static_ips.id<br/>      NLB_TG_ARN = aws_lb_target_group.nlb_443.arn<br/>      MAX_LOOKUP_PER_INVOCATION = 50<br/>      INVOCATIONS_BEFORE_DEREGISTRATION = 10<br/>      CW_METRIC_FLAG_IP_COUNT = true<br/>    }<br/>  }<br/>}</span></pre><p id="b2b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CloudWatch cron作业触发Lambdas的调用，CloudWatch事件服务被允许调用它们。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d43c" class="mq lt it nm b gy nq nr l ns nt">resource "aws_cloudwatch_event_rule" "nlb_tg_to_alb_cron" {<br/>  name = "nlb-tg-to-alb-cron"<br/>  schedule_expression = "rate(1 minute)"<br/>  is_enabled = true<br/>}<br/><br/>resource "aws_cloudwatch_event_target" "nlb_tg_to_alb_cron_80" {<br/>  rule = aws_cloudwatch_event_rule.nlb_tg_to_alb_cron.name<br/>  target_id = "TriggerStaticPort80"<br/>  arn = aws_lambda_function.nlb_tg_to_alb_80.arn<br/>}<br/><br/>resource "aws_cloudwatch_event_target" "nlb_tg_to_alb_cron_443" {<br/>  rule = aws_cloudwatch_event_rule.nlb_tg_to_alb_cron.name<br/>  target_id = "TriggerStaticPort443"<br/>  arn = aws_lambda_function.nlb_tg_to_alb_443.arn<br/>}<br/><br/>resource "aws_lambda_permission" "allow_cloudwatch_80" {<br/>  statement_id = "AllowExecutionFromCloudWatch"<br/>  action = "lambda:InvokeFunction"<br/>  function_name = aws_lambda_function.nlb_tg_to_alb_80.function_name<br/>  principal = "events.amazonaws.com"<br/>  source_arn = aws_cloudwatch_event_rule.nlb_tg_to_alb_cron.arn<br/>}<br/><br/>resource "aws_lambda_permission" "allow_cloudwatch_443" {<br/>  statement_id = "AllowExecutionFromCloudWatch"<br/>  action = "lambda:InvokeFunction"<br/>  function_name = aws_lambda_function.nlb_tg_to_alb_443.function_name<br/>  principal = "events.amazonaws.com"<br/>  source_arn = aws_cloudwatch_event_rule.nlb_tg_to_alb_cron.arn<br/>}</span></pre><p id="0e28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总结一下ALB的讨论:我们已经创建了一个应用程序负载平衡器，它有两个监听器(443和80)和一个让网络负载平衡器保持与ALB连接的机制。</p><h2 id="2877" class="mq lt it bd lu mr ms dn ly mt mu dp mc km mv mw mg kq mx my mk ku mz na mo nb bi translated">服务</h2><p id="6589" class="pw-post-body-paragraph kb kc it kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">在这一点上，我们可以把我们的焦点带回到个体服务的领域。您需要为每一个创建负载平衡器目标组。如果LB提供的服务不超过50个左右，这应该没问题<a class="ae nx" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-limits.html" rel="noopener ugc nofollow" target="_blank">，假设每个服务使用一对目标组(用于HTTP和HTTPS)。更多服务，添加更多LBs。</a></p><p id="c4a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个Terraform配置至少创建一个目标组，每个目标组都用服务名和一个随机的六字符十六进制后缀命名。我使用了一个<code class="fe nu nv nw nm b">blue_green</code>布尔变量来支持AWS CodeDeploy，它通过将流量(或部分流量)从一个目标组切换到另一个目标组来完成ECS任务的蓝绿色/金丝雀式部署。这就是我使用随机TG名称而不是“蓝色”/“绿色”或小整数的原因——我想避免认为它们有任何自然顺序，或者将它们与活动/不活动相关联，因为它们中的任何一个都可能在任何时候提供流量，如果不查看侦听器规则，您是不会知道的。我不会在这里讨论部署问题，所以就假装你没有看到<code class="fe nu nv nw nm b">count</code>的论点，但是对于你的生产环境来说，这是值得考虑的。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="9178" class="mq lt it nm b gy nq nr l ns nt">resource "random_id" "target_group_http_80" {<br/>  count = var.blue_green ? 2 : 1<br/>  byte_length = 3<br/>}</span><span id="6c1d" class="mq lt it nm b gy nz nr l ns nt">resource "aws_alb_target_group" "http_80" {<br/>  count = var.blue_green ? 2 : 1<br/>  name = "${substr(var.name, 0, 20)}-${random_id.target_group_http_80[count.index].hex}"<br/>  protocol = "HTTP"<br/>  port = 80<br/>  vpc_id = var.vpc_id<br/>  slow_start = 30<br/>  stickiness {<br/>    type = "lb_cookie"<br/>  }<br/>  target_type = "ip"<br/>  health_check {<br/>    path = local.health_checks.path<br/>    port = 8080<br/>    timeout = local.health_checks.timeout<br/>    interval = local.health_checks.interval<br/>    matcher = "200-299"<br/>  }<br/>}</span></pre><p id="f3a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为<em class="kz"> infra </em>在另一个根模块中，我们需要对我们设置的ALB进行推断。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="a32f" class="mq lt it nm b gy nq nr l ns nt">data "aws_alb_listener" "http_80" {<br/>  load_balancer_arn = var.internal_alb_arn<br/>  port = 80<br/>}</span><span id="1ce6" class="mq lt it nm b gy nz nr l ns nt">data "aws_alb_listener" "https_443" {<br/>  load_balancer_arn = var.internal_alb_arn<br/>  port = 443<br/>}</span></pre><p id="1f5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将为端口80创建一个监听器规则，并定义特定的行为:</p><ul class=""><li id="a2eb" class="oa ob it kd b ke kf ki kj km oc kq od ku oe ky of og oh oi bi translated">如果是以“http://API . abq . com/ice-station-zebra/”开头的URL，它将匹配一个请求。注意，如果您还需要精确地提供根路径“/ice-station-zebra”，那么您将需要另一个具有该路径模式的侦听器规则(在一个规则中，每种条件类型只允许一个)。</li><li id="e1d3" class="oa ob it kd b ke oj ki ok km ol kq om ku on ky of og oh oi bi translated">如果请求匹配，ALB将使用301进行响应，并将用户重定向到相同的URL，但在端口443上。</li></ul><p id="aa2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，为了与API Gateway集成，并不真正需要端口80，所以这只是一种保护措施。如果我们希望VPC中的另一个服务通过端口80监听器调用<em class="kz"> ice-station-zebra </em>，那么我们可以创建另一个监听器规则。它不会有重定向，但需要另一个条件来允许VPC内部的流量，比如一个带有VPC CIDR阻塞的<code class="fe nu nv nw nm b">source-ip</code>。</p><p id="dcb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还将为端口443创建一个侦听器规则，该端口具有相同的请求条件，但是会将流量传递给目标组。443规则转发到端口80目标组，这使其成为TLS终止符(😎).</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="0eb0" class="mq lt it nm b gy nq nr l ns nt">resource "aws_alb_listener_rule" "http_80" {<br/>  listener_arn = data.aws_alb_listener.http_80.arn</span><span id="37c3" class="mq lt it nm b gy nz nr l ns nt">  action {<br/>    type = "redirect"<br/>    redirect {<br/>      port = data.aws_alb_listener.https_443.port<br/>      protocol = data.aws_alb_listener.https_443.protocol<br/>      status_code = "HTTP_301"<br/>    }<br/>  }<br/>  <br/>  condition {<br/>    host_header {<br/>      values = ["api.abq.com"]<br/>    }<br/>  }<br/>  <br/>  condition {<br/>    path_pattern {<br/>      values = ["/ice-station-zebra/*"]<br/>    }<br/>  }<br/>}</span><span id="58a2" class="mq lt it nm b gy nz nr l ns nt">resource "aws_alb_listener_rule" "http_443" {<br/>  listener_arn = data.aws_alb_listener.http_443.arn</span><span id="c5f2" class="mq lt it nm b gy nz nr l ns nt">  action {<br/>    type = "forward"<br/>    target_group_arn = aws_alb_target_group.http_80.arn<br/>  }<br/>  <br/>  condition {<br/>    host_header {<br/>      values = ["api.abq.com"]<br/>    }<br/>  }<br/>  <br/>  condition {<br/>    path_pattern {<br/>      values = ["/ice-station-zebra/*"]<br/>    }<br/>  }<br/>}</span></pre><h1 id="4650" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">弹性集装箱服务…服务</h1><p id="2dca" class="pw-post-body-paragraph kb kc it kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">现在，在不涉及ECS的太多细节的情况下，让我们为自己创建一个服务，并将其与我们的ALB相关联。假设我们已经有了一个ECS集群、任务定义和任何适当的安全组。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="1cfd" class="mq lt it nm b gy nq nr l ns nt">resource "aws_ecs_service" "non_blue_green" {<br/>  name = "ice-station-zebra"<br/>  task_definition = local.task_definition<br/>  desired_count = local.desired_task_instance_count<br/>  deployment_maximum_percent = 200<br/>  deployment_minimum_healthy_percent = 100<br/>  launch_type = "FARGATE"<br/>  platform_version = "1.3.0"<br/>  scheduling_strategy = "REPLICA"<br/><br/>  load_balancer {<br/>    container_name = "app"<br/>    container_port = 8080<br/>    elb_name = null<br/>    target_group_arn = aws_alb_target_group.http_80.arn<br/>  }<br/><br/>  cluster = var.ecs_cluster_arn<br/>  propagate_tags = "TASK_DEFINITION"<br/><br/>  deployment_controller {<br/>    type = "ECS"<br/>  }<br/><br/>  network_configuration {<br/>    security_groups = compact(concat(var.ecs_security_group_ids, [<br/>      aws_security_group.ecs_service.id,<br/>    ]))<br/>    subnets = var.private_subnet_ids<br/>    assign_public_ip = false<br/>  }<br/><br/>  depends_on = [aws_alb_listener_rule.http_80, aws_alb_listener_rule.https_443]<br/>}</span></pre><p id="5968" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们刚刚…是这样吗？我想是的！</p><h1 id="fc6f" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="501f" class="pw-post-body-paragraph kb kc it kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">请求将通过“https://API . abq . com/ice-station-zebra/*”进入API Gateway，并将通过VPC服务端点(我在第一部分中介绍了所有这些)。然后，流量将通过NLB和ALB，最终到达我们的ECS任务。任务的响应将采取相反方向的相同路径。</p><p id="749f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这对你有所帮助。一如既往，我很高兴听到您的反馈，并感谢您的阅读。</p></div></div>    
</body>
</html>