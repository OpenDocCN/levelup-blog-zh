<html>
<head>
<title>How to manage icons in your UI library (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何管理用户界面库中的图标(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-manage-icons-in-your-ui-library-part-1-49c6f875fb5d?source=collection_archive---------7-----------------------#2022-07-21">https://levelup.gitconnected.com/how-to-manage-icons-in-your-ui-library-part-1-49c6f875fb5d?source=collection_archive---------7-----------------------#2022-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8537" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为你的图标创建一个有弹性的Web组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f1a440d4e25abdfbad1dc11823f78970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GiW7JSvKlt1b4WTQ.jpg"/></div></div></figure><h1 id="7b24" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="fd10" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在过去的几个月里，我一直在开发一个名为<a class="ae mf" href="https://a2000.netlify.app/" rel="noopener ugc nofollow" target="_blank"> A2k </a>的小型UI库。</p><p id="9a8e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">当我有时间的时候，我已经逐渐地做了一些改变，但是还没有考虑到图书馆架构的某些方面。</p><p id="af6b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">对于一些小而杂乱的东西，比如原型或概念验证，快速测试一个想法比完美地编码要好。对于其他项目，重要的是要考虑项目的架构如何随着时间的推移对项目产生积极或消极的影响。</p><p id="f51a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">很多小项目，比如A2k，都是有机增长的。随着一个有机项目变得越来越大，一些不想要的模式开始出现。对于A2k处理图标的方式，我发现了一种不可取的模式。</p><p id="f43c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">对于添加的每个图标，我会用web组件样板SVG的内容创建一个文件。我还需要创建另一个文件来注册组件。这相当于每个图标有两个文件和大量共享代码。</p><p id="daa1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">以下是将首批SVG图标添加到A2k后的文件夹结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/fa05a3b2d8413418c64898b46702a9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*abPzAnpmAjWBwnRU.png"/></div></div></figure><p id="1e20" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">只有半打图标，这种方法已经变得笨拙。此外，<a class="ae mf" href="https://backlight.dev/blog/naming-conventions-for-design-systems" rel="noopener ugc nofollow" target="_blank">命名惯例</a> (Logo vs Icon有人知道吗？).第三，添加一个新图标需要一堆样板文件。</p><p id="c5d4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这种方法不仅会影响开发体验和代码复杂性，还会影响那些使用A2k的人。因为每个图标都是一个组件，所以消费者需要注册他们打算使用的所有图标。如果没有显式导入图标，它将不会呈现。</p><p id="7547" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这种方法不适合A2k。我想要:</p><ul class=""><li id="b1b3" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">一个简单的API，一个自定义元素来管理它们。</li><li id="c566" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">最终用户不必明确注册他们想要使用的图标。</li><li id="9c15" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">我们所有的SVG图标都来自一个文件，这意味着我们只发出一个网络请求。</li><li id="23df" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">保证所有图标的约束，因为单个图标增加了熵的可能性。</li></ul><p id="3ee5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我的方法？重构库，以便最终用户只需注册一个web组件。他们想要使用的图标将被指定为该组件的一个属性。</p><p id="cefb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我也有兴趣了解其他库和作者是如何解决这个问题的。这些库中的大多数都有不同的需求和约束，因此理解不同的观点将有助于我们批判性地思考哪种选择最适合我们给定的情况。</p><p id="c59b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">因此，我将把这个系列文章分成两部分。</p><p id="8957" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">第1部分将遵循A2k的重构，涵盖如下概念:</p><ul class=""><li id="9143" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">使用SVG的<code class="fe na nb nc nd b">use</code>元素</li><li id="acf1" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">使用<code class="fe na nb nc nd b">em</code> s调整图标大小</li><li id="3a51" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">使用<code class="fe na nb nc nd b">import.meta</code>导入资产</li></ul><p id="9c09" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">第2部分将分享更多已建立的组件库和作者使用的可选图标策略。</p><h1 id="4ac2" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">第1部分:图标剖析和重构</h1><p id="7283" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我在介绍中提到，每个组件都需要标准的web组件样板文件。当我使用Lit编写web组件时，每个图标组件看起来都像这样:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="3048" class="ni ks iq nd b gy nj nk l nl nm">import { LitElement, svg } from 'lit';</span><span id="dd50" class="ni ks iq nd b gy nn nk l nl nm">export class HelpIcon extends LitElement {<br/>  render() {<br/>    return svg`<br/>      &lt;svg<br/>	      viewBox="0 0 24 24"<br/>	      fill="none"<br/>    &gt;<br/>      {all the child SVG elements}<br/>    &lt;/svg&gt;<br/>    `;<br/>  }<br/>}</span></pre><p id="b761" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这在浏览器中表现得非常好:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b35b30645054f162f2e91724a001840e.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/0*VINrthTsG748Aj_6.png"/></div></figure><p id="8e94" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">它看起来不错，代码足够简单。主要问题是样板文件与其他图标组件相同。所以，让我们开始把我们的图标整合成一个单一的组件。</p><p id="565f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">要做到这一点，我们需要了解我们所掌握的实现这一目标的工具。</p><h1 id="19bd" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">SVG使用</h1><p id="1c72" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了将图标web组件从SVG图像中分离出来，我们需要引用一个外部文件中的SVG图像。我们可以通过使用SVG的<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/use" rel="noopener ugc nofollow" target="_blank"> use </a>元素来实现这一点。</p><p id="ef9e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe na nb nc nd b">use</code>元素允许我们引用一个SVG图像，并在使用<code class="fe na nb nc nd b">use</code>元素的地方克隆它。如果同一个图像在几个地方使用，这是减少重复SVG逻辑的极好方法。</p><p id="c947" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">对于我们的用例来说，<code class="fe na nb nc nd b">use</code>是一种方便的分离关注点的方法。我们的图标组件只关心渲染，而一个外部的<code class="fe na nb nc nd b">.svg</code>文件存放了我们所有的图标。</p><p id="240e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们重构后的代码看起来有点像这样:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="3793" class="ni ks iq nd b gy nj nk l nl nm"><em class="np">// More on this statement later</em><br/>const url = new URL('../../a2k-icons.svg', import.meta.url).href;</span><span id="d2c7" class="ni ks iq nd b gy nn nk l nl nm">export class A2kIcon extends LitElement {<br/>  <em class="np">// More on these styles later</em><br/>  static styles = css`<br/>    :host {<br/>      display: flex;<br/>      align-items: center;<br/>      justify-content: center;<br/>      font-size: 2em;<br/>    }<br/>  `;</span><span id="9f9c" class="ni ks iq nd b gy nn nk l nl nm">  @property({ type: String })<br/>  icon = '';</span><span id="49ff" class="ni ks iq nd b gy nn nk l nl nm">  render() {<br/>    if (!this.icon) {<br/>      console.warn(<br/>        "This icon is a missing a 'name', please specify the 'name' of the icon you want to display"<br/>      );<br/>    }</span><span id="f5e7" class="ni ks iq nd b gy nn nk l nl nm">    return svg`<br/>			// More on these styles later<br/>      &lt;svg height="1em" width="1em"&gt;<br/>        &lt;use href="${url}#${this.icon}"&gt;&lt;/use&gt;<br/>      &lt;/svg&gt;<br/>    `;<br/>  }<br/>}</span></pre><p id="d646" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">你可以看到我们仍然用顶级的<code class="fe na nb nc nd b">svg</code>元素包装我们的标记。</p><p id="d6ef" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然后我们使用<code class="fe na nb nc nd b">use</code>来克隆位于<code class="fe na nb nc nd b">href</code>路径的SVG映像。传递给<code class="fe na nb nc nd b">href</code>的值是文件的绝对路径和对特定图标<code class="fe na nb nc nd b">id</code>的引用的组合。</p><p id="5f42" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们现在需要移到SVG图标所在的<code class="fe na nb nc nd b">a2k-icons.svg</code>。这是我们在SVG上迁移后的<code class="fe na nb nc nd b">a2k-icons.svg</code>的样子:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="6b8a" class="ni ks iq nd b gy nj nk l nl nm">&lt;svg &gt;<br/>  &lt;symbol id="help" width="1em" height="1em" viewBox="0 0 24 24"&gt;<br/>    {/*<em class="np">&lt;!-- SVG nodes like &lt;rect /&gt; --&gt;</em>*/}<br/>  &lt;/symbol&gt;</span><span id="0b2e" class="ni ks iq nd b gy nn nk l nl nm">  &lt;symbol id="documents" width="1em" height="1em" viewBox="0 0 24 24"&gt;<br/>    {/*<em class="np">&lt;!-- SVG nodes like &lt;rect /&gt; --&gt;</em>*/}<br/>  &lt;/symbol&gt;</span><span id="9c27" class="ni ks iq nd b gy nn nk l nl nm">  {/*<em class="np">&lt;!-- Other SVG icons --&gt;</em>*/}<br/>&lt;/svg&gt;</span></pre><p id="397e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这个文件有一个顶级的<code class="fe na nb nc nd b">svg</code>元素，但是我们的单个图标被包装在一个<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/symbol" rel="noopener ugc nofollow" target="_blank">符号</a>元素中。元素用于定义一个可以通过元素<code class="fe na nb nc nd b">use</code>克隆的元素。幸运的是，<code class="fe na nb nc nd b">symbol</code>接受像<code class="fe na nb nc nd b">viewBox</code>、<code class="fe na nb nc nd b">height</code>、<code class="fe na nb nc nd b">width</code>等属性。，让我们可以轻松地将图片从web组件转移到<code class="fe na nb nc nd b">a2k-icons</code>文件中。</p><p id="36c4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">此时，我们的最终用户将能够显示图标，通过属性提供图标的名称，如下所示:</p><p id="b175" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe na nb nc nd b">&lt;a2k-icon icon="help"&gt;&lt;/a2k-icon&gt;</code></p><p id="563f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，我们可以将所有的SVG从其他单独的图标组件迁移到<code class="fe na nb nc nd b">a2k-icons.svg</code>文件中。一旦我们这样做了，我们可以删除所有未使用的组件(这非常令人满意)。这是我们的文件夹结构现在的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/761c0425062943d2239422b95e0ec92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gY4JCfhZrP8p5Wrf.png"/></div></div></figure><p id="9b34" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这种方法并不是没有警告，通过将所有的SVG捆绑到一个文件中，我们通过一个网络请求将所有的SVG提供给我们的最终用户。对于导出1000个以上图标的库，这将导致更长的加载时间和更差的用户体验。正如我们将在第2部分中看到的，不同的方法都有其优点和缺点。</p><h1 id="f942" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">等等艾米。你是说莱姆斯吗？！</h1><p id="3ccf" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">web开发界的共识是我们通常应该选择使用<code class="fe na nb nc nd b">rem</code>单元而不是<code class="fe na nb nc nd b">em</code>单元。我百分之百同意。基本原理超出了本文的范围，但是如果你有兴趣了解何时使用最常见的CSS单元，那么我不能推荐Josh Comeau的精彩文章“<a class="ae mf" href="https://www.joshwcomeau.com/css/surprising-truth-about-pixels-and-accessibility/" rel="noopener ugc nofollow" target="_blank">关于像素和可访问性的惊人真相</a>”。</p><p id="518a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这些是我们在这里将要讨论的单位:</p><ul class=""><li id="f8ba" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">em —相对CSS单位，其值基于元素的字体大小</li><li id="51a8" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">rem相对CSS单位，其值基于根的字体大小</li></ul><p id="e57f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">以下列元素为例:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="6da1" class="ni ks iq nd b gy nj nk l nl nm">&lt;div style="font-size: 21px"&gt;<br/>  &lt;p style="font-size: 1rem"&gt;This is rem text&lt;/p&gt;<br/>  &lt;p style="font-size: 1em"&gt;This is em text&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="658e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">假设文档的根的字体大小为16px，那么我们的第一段将以16px显示，而我们的第二段将以21px显示。</p><p id="6a88" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">上面的标记将在浏览器中呈现如下:那么为什么我选择使用<code class="fe na nb nc nd b">em</code> s来调整图标大小呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1ea9fd97dce9f71c5eb952844c861306.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/0*e8sA96gwaXQWaIwW.png"/></div></figure><p id="612a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是我从<a class="ae mf" href="https://every-layout.dev/layouts/icon/" rel="noopener ugc nofollow" target="_blank"> Every Layout </a>电子书中学到的东西。如果你打算给你的图标配上文字，使用<code class="fe na nb nc nd b">em</code>会是一个特别方便的技巧。正如我们在上面的例子中看到的，第二个段落的字体大小是相对于从其父段落继承的字体大小的。这是确保两个紧密联系的元素同步增长和收缩的简便方法。</p><p id="d81a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">通过编写以下组件，您可以看到这一点:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="4007" class="ni ks iq nd b gy nj nk l nl nm">export class A2kTextIcon extends LitElement {<br/>  static styles = css`<br/>    :host {<br/>      font-size: 24px;<br/>    }<br/>  `;</span><span id="3789" class="ni ks iq nd b gy nn nk l nl nm">  render() {<br/>    return html`<br/>      &lt;div&gt;<br/>        &lt;a2k-icon icon="help"&gt;&lt;/a2k-icon&gt;<br/>        &lt;p&gt;Help&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    `;<br/>  }<br/>}</span></pre><p id="532a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们所做的只是创建一个新的组件，该组件呈现我们先前存在的图标组件，但添加了一些伴随的文本。在<code class="fe na nb nc nd b">a2k-icon</code>组件中使用<code class="fe na nb nc nd b">em</code>和在<code class="fe na nb nc nd b">A2kTextIcon</code>的样式属性中使用显式的<code class="fe na nb nc nd b">font-size: 24px</code>，意味着段落和图标都将相对于其父级的大小进行缩放。</p><p id="c924" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果您对将图标与文本结合起来不感兴趣，那么您可以显式地设置图标的大小，或者让图标占据其容器的整个宽度。对于某些用例来说，这两种方法都是有效的选择，但是超出了本文的范围。</p><p id="caa1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果你想了解更多关于构建弹性图标布局的知识，那么<a class="ae mf" href="https://every-layout.dev/" rel="noopener ugc nofollow" target="_blank"> Every Layout </a>这本书是一个很好的资源。它涵盖了很多有趣的领域，比如垂直对齐你的图标，感知匹配文本的高度，以及使用逻辑属性来应用间距。</p><h1 id="be9b" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">import.meta</h1><p id="5bae" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">所以现在我们已经创建了<code class="fe na nb nc nd b">a2k-icons.svg</code>文件，重要的是我们可以正确地引用它。</p><p id="46d4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">你会发现通过相对URL引用一个静态文件就像这样…</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="1abe" class="ni ks iq nd b gy nj nk l nl nm">&lt;use href="../../svg-icons.svg" /&gt;</span></pre><p id="1d59" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">…行不通。</p><p id="3fec" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是因为web组件中的路径是相对于根文档的，所以您需要创建一个直接指向静态文件的绝对路径。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/c71b8c232ca7f0737507d192afa96574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yHNulkLPZ9UoBrRd.png"/></div></div></figure><p id="cfc5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现代Web的优秀人员对这种行为进行了更深入的研究，他们建议用<code class="fe na nb nc nd b">import.meta.url</code>引用可重用资产。</p><p id="0b4f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">下面是我们如何在我们的<code class="fe na nb nc nd b">A2kIcon</code>组件中使用它:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="30d3" class="ni ks iq nd b gy nj nk l nl nm">const url = new URL('../../a2k-icons.svg', import.meta.url).href;</span></pre><p id="7b1f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了理解这里发生的事情，让我们将这个声明分成三个部分:</p><ul class=""><li id="9eda" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated"><code class="fe na nb nc nd b">import.meta.url</code></li><li id="8d84" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated"><code class="fe na nb nc nd b">../../a2k-icons.svg</code></li><li id="1a9c" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated"><code class="fe na nb nc nd b">new URL(...).href</code></li></ul><p id="8e5c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">首先，<code class="fe na nb nc nd b">import.meta.url</code>返回当前ES模块的绝对URL，本例中为<code class="fe na nb nc nd b">A2kIcon.ts</code>。</p><p id="bda1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果您运行一个开发服务器，并记录<code class="fe na nb nc nd b">import.meta.url</code>，您将看到如下内容:</p><p id="f16a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe na nb nc nd b"><a class="ae mf" href="http://localhost:3000/@fs/Users/Repos/andricos-2000/packages/icons/lib/src/A2kIcon.js" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/@fs/Users/Repos/andricos-2000/packages/icons/lib/src/A2kIcon.js</a></code></p><p id="af23" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">其次，我们有<code class="fe na nb nc nd b">../../a2k-icons.svg</code>，它是我们想要访问的文件的相对路径。这个路径相对于<code class="fe na nb nc nd b">A2kIcon</code>在文件系统中的位置。</p><p id="3fde" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">最后，我们可以使用<code class="fe na nb nc nd b">URL()</code>构造函数来生成目标文件<code class="fe na nb nc nd b">a2k-icons.svg</code>的绝对路径。</p><p id="d0e3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们将传递给<code class="fe na nb nc nd b">URL()</code>的第一个参数是目标文件的相对路径。第二个参数是我们的基本URL，它是从<code class="fe na nb nc nd b">import.meta.url</code>获得的。</p><p id="f102" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">下面的表达式:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="a54e" class="ni ks iq nd b gy nj nk l nl nm">const url = new URL('../../a2k-icons.svg', import.meta.url).href;</span></pre><p id="df88" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">…为我们提供了<code class="fe na nb nc nd b">a2k-icons.svg</code>的绝对URL:</p><p id="0fcf" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe na nb nc nd b"><a class="ae mf" href="http://localhost:3000/@fs/Users/Repos/andricos-2000/packages/icons/a2k-icons.svg" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/@fs/Users/Repos/andricos-2000/packages/icons/a2k-icons.svg</a></code></p><p id="3010" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">因此，当在本地服务器上运行我们的站点时，这很好，但是一旦包被捆绑，它还能工作吗？</p><p id="3ff1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我不能代表所有捆绑商发言，但Vite支持我们对<code class="fe na nb nc nd b">URL()</code>开箱即用的呼吁。它将确保URL指向正确的位置，即使在捆绑和资产散列之后。不幸的是，这种方法不适用于在服务器上呈现的组件，也不适用于在运行时生成URL。要了解关于这些限制的更多信息，请查看<a class="ae mf" href="https://vitejs.dev/guide/assets.html#new-url-url-import-meta-url" rel="noopener ugc nofollow" target="_blank"> Vite文档</a>。</p><p id="d358" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Vite使用<code class="fe na nb nc nd b">import.meta</code>有一个<a class="ae mf" href="https://github.com/vitejs/vite/issues/7287" rel="noopener ugc nofollow" target="_blank">已知问题</a>，会让消耗你的图标库的开发者头疼。Vite优化依赖关系的方式在运行开发服务器时会导致问题，组件不再能够访问它的<code class="fe na nb nc nd b">import.meta.url</code>值。这将破坏使用<code class="fe na nb nc nd b">new URL()</code>生成的任何URL。如果您遇到这个问题，您需要将以下内容添加到您的<code class="fe na nb nc nd b">vite.config.js</code></p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="6778" class="ni ks iq nd b gy nj nk l nl nm">export default {<br/>  optimizeDeps: {<br/>    exclude: ['@a2000/icons'], <em class="np">// or whatever dependency you're having trouble with</em><br/>  },<br/>};</span></pre><h1 id="e110" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">这是一个合适的方法吗？</h1><p id="c934" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在文章的开始，我分享了转向这种方法的基本原理。概括来说，它们是:</p><ul class=""><li id="8f32" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">针对单个组件的简单API。</li><li id="9e1a" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">最终用户只需要注册一个图标。</li><li id="b27d" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">所有图标都通过一个文件提供。</li><li id="04fe" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">改进了DX，因为我们可以保证所有图标都有相同的约束。</li></ul><p id="b0c2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们通过使用一些有趣的浏览器概念实现了这一点，例如:</p><ul class=""><li id="2018" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">SVG的<code class="fe na nb nc nd b">use</code>元素</li><li id="fdcb" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">何时使用<code class="fe na nb nc nd b">ems</code>而非<code class="fe na nb nc nd b">rems</code></li><li id="2362" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">使用<code class="fe na nb nc nd b">import.meta</code>构建绝对URL</li></ul><p id="2392" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们的方法也有缺点，包括:</p><ul class=""><li id="dc33" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">最终用户将会下载他们不使用的图标。</li><li id="6feb" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">根据我们库中图标的数量，包的大小可能会变大。正如我们将在第2部分中讨论的，一些库的图标总数超过1000个。</li><li id="55b0" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">最终用户不能通过我们的图标组件使用他们的图标库。</li></ul><p id="2954" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">根据您的库，这些缺点可能是微不足道的，也可能会导致最终用户体验的降低。那么，其他图书馆是如何处理这个问题的，有什么缺点呢？我们将在第2部分中讨论这个问题。敬请关注。</p><p id="427b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果你有一个图标库，采用一种新颖的方法来管理你不同的图标，那么请留下评论，或者在Twitter上联系我。我正在为第2部分构建一个图标库列表进行比较，并且很乐意了解任何在野外使用的有趣方法。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="47e2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="np">原载于</em><a class="ae mf" href="https://backlight.dev/blog/how-to-manage-icons-in-your-UI-library-part-1" rel="noopener ugc nofollow" target="_blank"><em class="np">https://back light . dev</em></a><em class="np">撰写于2022年7月7日</em><a class="ae mf" href="https://twitter.com/AndricoKaroulla" rel="noopener ugc nofollow" target="_blank">@ AndricoKaroulla</a><em class="np">。</em></p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="0c8c" class="kr ks iq bd kt ku oa kw kx ky ob la lb jw oc jx ld jz od ka lf kc oe kd lh li bi translated">分级编码</h1><p id="7e8b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="fc66" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="21e1" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">📰查看<a class="ae mf" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="5a37" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">🔔关注我们:<a class="ae mf" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae mf" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mf" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li><li id="54a9" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">🚀👉<a class="ae mf" href="https://jobs.levelup.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir">软件工程师的顶级工作</strong> </a></li></ul></div></div>    
</body>
</html>