<html>
<head>
<title>Graph data analysis with Cypher and Spark SQL on Cloud Dataproc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cloud Dataproc上基于Cypher和Spark SQL的图形数据分析</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graph-data-analysis-with-cypher-and-spark-sql-on-cloud-dataproc-861ba6b7b648?source=collection_archive---------9-----------------------#2020-06-21">https://levelup.gitconnected.com/graph-data-analysis-with-cypher-and-spark-sql-on-cloud-dataproc-861ba6b7b648?source=collection_archive---------9-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b10b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何读入BigQuery数据并使用Spark SQL和Morpheus库进行图形数据分析</h2></div><p id="8e82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在Morpheus库为Spark 3中的图形数据分析提供了插件Cypher支持，您可以使用Cloud data proc(Google Cloud上的托管Hadoop和Spark服务)以可扩展的分布式方式进行图形数据分析。因为Dataproc有一个Spark连接器，所以您可以从BigQuery数据开始进行图形数据分析。</p><h2 id="657e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Cloud Dataproc上的Spark 3和Scala</h2><p id="1105" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae lz" href="https://neo4j.com/developer/cypher-query-language/" rel="noopener ugc nofollow" target="_blank"> Cypher </a>是一种图形查询语言。如果您想以事务方式进行图形处理，可以在Neo4J上使用它；如果您想进行图形数据分析，可以在Spark上使用它。允许你使用Cypher的Spark库叫做<a class="ae lz" href="https://github.com/opencypher/morpheus" rel="noopener ugc nofollow" target="_blank"> Morpheus </a>。Morpheus非常新，它在Scala中工作得最好(要使用PySpark，您必须不断调用JVM包装器，这很快就会过时)。</p><p id="dda9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要跟随我，请到https://console.cloud.google.com/dataproc<a class="ae lz" href="https://console.cloud.google.com/dataproc" rel="noopener ugc nofollow" target="_blank">创建一个新的集群，但一定要打开“高级”选项并选择一个Spark 3.0映像:</a></p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/726d28cc9969166830403d97c2885c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*0kZhT87jSlWIaULoZzmNUg.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">确保启动Spark 3.0 Dataproc集群</figcaption></figure><p id="67af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦集群启动并运行，转到集群详细信息并找到SSH按钮。使用它通过SSH进入集群的主节点:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/49dd46711cdc94787629449d5dbb566c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*A32ba_0uEhyC055WFwIjLw.png"/></div></figure><p id="ba29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将允许我们交互式地运行代码。一旦代码开始工作，就可以简单地将整个Scala文件作为一个作业提交。</p><p id="c524" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="mn">注意:使用GitHub上的这个文件(</em></strong><a class="ae lz" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/graphdb/find_routes.scala" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mn">find _ routes . Scala</em></strong></a><strong class="kh ir"><em class="mn">)来复制粘贴代码片段——这将帮助您确保换行正确，并且在滚动时不会遗漏一两行...</em>T19】</strong></p><p id="d2ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在SSH窗口中，启动一个Scala会话，如下所示:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="326d" class="lb lc iq mp b gy mt mu l mv mw">spark-shell --jars=gs://spark-lib/bigquery/spark-bigquery-latest_2.12.jar --packages=org.opencypher:morpheus-spark-cypher:0.4.2</span></pre><p id="8bd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将启动Spark interactive shell(“REPL”)并告诉它加载两个包:BigQuery连接器和Morpheus Maven包。</p><p id="1371" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦得到spark提示，您就可以开始尝试图形数据分析了！</p><h2 id="2c71" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">BigQuery数据集</h2><p id="94ca" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">为了说明这一点，我将采用旧金山公共公交出行数据集。您可以通过在BigQuery控制台中运行该查询来快速浏览一下:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="49ee" class="lb lc iq mp b gy mt mu l mv mw">SELECT<br/>  stop_id, arrival_time, stop_sequence<br/>FROM `bigquery-public-data.san_francisco_transit_muni.stop_times`<br/>WHERE trip_id = 8951406<br/>ORDER BY stop_sequence ASC</span></pre><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d3fd2657a9c71fbec0ade24b54a72c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*vwcc5FvQ6gTUk1FqxwCvYg.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">行程#8951406的旧金山巴士站</figcaption></figure><h2 id="c9f2" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">在Scala中读取BigQuery数据集</h2><p id="f56f" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在Scala提示符下，键入:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="0e3d" class="lb lc iq mp b gy mt mu l mv mw">val BUCKET = "ai-analytics-solutions-kfpdemo"     // CHANGE as needed<br/>spark.conf.set("temporaryGcsBucket", BUCKET)<br/>spark.conf.set("spark.sql.legacy.allowUntypedScalaUDF", true) // https://github.com/opencypher/morpheus/issues/948<br/><br/>val stopTimesDF = (spark.read.format("bigquery")<br/>  .option("table", "bigquery-public-data:san_francisco_transit_muni.stop_times")<br/>  .option("filter", "arrives_next_day = false AND dropoff_type = 'regular'")<br/>  .load().cache())<br/>stopTimesDF.createOrReplaceTempView("stopTimes")<br/>stopTimesDF.printSchema()</span></pre><p id="2842" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将公交车停靠时间的BigQuery表读入Spark数据帧(当然是延迟的)，在Spark SQL中将其注册为视图stopTimes，然后打印模式。您将获得以下内容:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0ce69b547357349003e8e9bf9977b0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*1JW81HEgzKN4JgGdoGIuvQ.png"/></div></figure><h2 id="6136" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">构建图表</h2><p id="3992" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们使用这个数据集来构建一个相当简单的图表。行程包含停靠站。每个行程都有行程编号，每个站点都有站点编号。Trip包含多个站点，因此，我们向contains关系添加一个名为stop_sequence的属性。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/fe85c8e184d5792e197a2dab8753ea2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPwma2lmY4qXImvRAq4vyA.png"/></div></div></figure><p id="d996" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建此图的一种方法是创建两个节点表(一个用于行程，另一个用于停靠点)和一个包含关系的关系表。每个表的每一行都必须有一个惟一的id，称为“id”。</p><p id="adb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从使用Spark SQL构建三个数据框架开始，这三个数据框架将用于创建节点和关系:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="a7e0" class="lb lc iq mp b gy mt mu l mv mw">val stopsDF = spark.sql("SELECT DISTINCT stop_id AS id, stop_id AS stop_number FROM stopTimes")<br/>val tripsDF = spark.sql("SELECT DISTINCT trip_id AS id, trip_id AS trip_number FROM stopTimes")<br/>val containsDF = spark.sql("SELECT DISTINCT trip_id AS source, stop_id AS target, stop_sequence, " +<br/>   "CONCAT(trip_id, stop_id) AS id FROM stopTimes")</span></pre><p id="ec00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令人恼火的是，你必须为每一行提供一个id。我使用了stop_id、trip_id，并将这两者连接起来用于contains关系。</p><p id="5ead" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">准备好数据帧后，我们可以在Morpheus中构建节点和关系表:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="4aeb" class="lb lc iq mp b gy mt mu l mv mw">import org.opencypher.morpheus.api.MorpheusSession<br/>import org.opencypher.morpheus.api.io.{MorpheusNodeTable, MorpheusRelationshipTable}<br/>import spark.sqlContext.implicits._</span><span id="8097" class="lb lc iq mp b gy ne mu l mv mw">val stopTable = MorpheusNodeTable(Set("Stop"), stopsDF)<br/>val tripTable = MorpheusNodeTable(Set("Trip"), tripsDF)<br/>val containsTable = MorpheusRelationshipTable("CONTAINS", containsDF)</span></pre><p id="6cc3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，表已经准备好了，我们可以创建图表了:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="8b09" class="lb lc iq mp b gy mt mu l mv mw">implicit val morpheus: MorpheusSession = MorpheusSession.local()<br/>val graph = morpheus.readFrom(stopTable, tripTable, containsTable)</span></pre><p id="3d96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在它有了行程节点、停止节点和包含边。让我们看看如何查询图形。</p><h2 id="7d53" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">简单密码查询</h2><p id="7489" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">作为一个简单的查询，让我们找出哪些行程包含特定的停靠站编号。这是一个密码查询，可以让我们做到这一点:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="d8bf" class="lb lc iq mp b gy mt mu l mv mw">MATCH<br/>  (s1:Stop {stop_number: 15104})&lt;-[c1:CONTAINS]-(t1:Trip)<br/>RETURN t1.trip_number AS trip, c1.stop_sequence AS seq</span></pre><p id="d69a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要求Cypher匹配一个Stop (s1)包含在(注意GitHub 上箭头</p><p id="8d74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Here’s the code to call that query, convert the result back into a Spark Data Frame and show it:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="a5f3" class="lb lc iq mp b gy mt mu l mv mw">// Query: which trips include stop number 15104?<br/>val result = graph.cypher("""<br/>  |MATCH<br/>  | (s1:Stop {stop_number: 15104})&lt;-[c1:CONTAINS]-(t1:Trip)<br/>  |RETURN t1.trip_number AS trip, c1.stop_sequence AS seq<br/>""".stripMargin)<br/>result.records.table.df.toDF("trip", "seq").createOrReplaceTempView("results")<br/>val resultsTable = spark.sql("SELECT * FROM results")<br/>resultsTable.show()</span></pre><p id="2526" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">The result looks like this:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="042d" class="lb lc iq mp b gy mt mu l mv mw">+-------+---+<br/>|   trip|seq|<br/>+-------+---+<br/>|8962068| 59|<br/>|8962069| 59|<br/>|8962074| 59|<br/>|8962075| 59|</span></pre><p id="4dee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">As you can see, there are multiple trips (at different times), but this stop seems to always be stop #59. It’s quite obvious that San Francisco buses follow fixed routes.</p><h2 id="a4af" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">More complex queries</h2><p id="42f5" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Let’s find the route that trip 8962069 takes (Complete code is in <a class="ae lz" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/graphdb/find_routes.scala" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mn">find _ routes . Scala</em></strong></a><em class="mn">的方向):</em></p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="4a19" class="lb lc iq mp b gy mt mu l mv mw">  |MATCH<br/>  | (s1:Stop)&lt;-[c1:CONTAINS]-(t1:Trip)<br/>  <strong class="mp ir">|WHERE t1.trip_number = 8962069</strong><br/>  |RETURN s1.stop_number AS stop, c1.stop_sequence AS seq<br/>  |ORDER BY c1.stop_sequence ASC</span></pre><p id="f49f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我没有使用属性匹配语法，而是使用了显式的WHERE子句和ORDER BY。这对于SQL人员来说应该很熟悉。这将返回:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="dc07" class="lb lc iq mp b gy mt mu l mv mw">+-----+---+<br/>| stop|seq|<br/>+-----+---+<br/>|13093|  1|<br/>|15992|  2|<br/>|15988|  3|<br/>|15990|  4|<br/>|16004|  5|</span></pre><p id="4df0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用上面的思路来寻找“下一站”。现在，我们需要进行两场比赛:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="f3a6" class="lb lc iq mp b gy mt mu l mv mw">  |MATCH<br/>  | (s1:Stop)&lt;-[c1:CONTAINS]-(t1:Trip)<br/>  |MATCH<br/>  | (s2:Stop)&lt;-[c2:CONTAINS]-(t1)<br/>  |WHERE t1.trip_number = 8962069 AND<br/>  |      <strong class="mp ir">c2.stop_sequence = c1.stop_sequence+1</strong><br/>  |RETURN s1.stop_number AS stop, s2.stop_number AS next, c1.stop_sequence AS seq<br/>  |ORDER BY c1.stop_sequence ASC</span></pre><p id="51bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们说同一行程(t1)必须包含两个停靠点s1和s2，这样c2的停靠点序列(包含关系)比c1的停靠点序列多一个。这将返回:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="e725" class="lb lc iq mp b gy mt mu l mv mw">+-----+-----+---+<br/>| stop| next|seq|<br/>+-----+-----+---+<br/>|13093|15992|  1|<br/>|15992|15988|  2|<br/>|15988|15990|  3|<br/>|15990|16004|  4|<br/>|16004|15984|  5|<br/>|15984|16007|  6|</span></pre><p id="3443" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很好，但是图形处理的要点是发现和创建新的关系。</p><h2 id="c081" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">创造新的关系</h2><p id="4f9b" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们使用上面的想法为每个站点添加一个“下一个”节点，这样我们的图就变成了:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nf"><img src="../Images/b79f96bb8cc743ecd07a28c5ee87a567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgUNC79d6xkiOq9be7bE0A.png"/></div></div></figure><p id="b67c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法是首先注册我们的图表:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="7fae" class="lb lc iq mp b gy mt mu l mv mw">morpheus.catalog.store("stopsGraph", graph)</span></pre><p id="8293" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在图上构造新边:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="2cb7" class="lb lc iq mp b gy mt mu l mv mw">  |MATCH<br/>  | (s1:Stop)&lt;-[c1:CONTAINS]-(t1:Trip)<br/>  |MATCH<br/>  | (s2:Stop)&lt;-[c2:CONTAINS]-(t1)<br/>  |WHERE c2.stop_sequence = c1.stop_sequence+1<br/>  |<strong class="mp ir">CONSTRUCT on stopsGraph<br/>  |  CREATE (s1)-[:NEXT {trip_number: t1.trip_number, stop_seq: c2.stop_sequence}]-&gt; (s2)</strong><br/>  |RETURN GRAPH. </span></pre><p id="71fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这条语句返回一个图形，所以Scala代码略有不同:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="c4bf" class="lb lc iq mp b gy mt mu l mv mw"><strong class="mp ir">val routeGraph</strong> = graph.cypher("""<br/>  |MATCH<br/>  | (s1:Stop)&lt;-[c1:CONTAINS]-(t1:Trip)<br/>  |MATCH<br/>  | (s2:Stop)&lt;-[c2:CONTAINS]-(t1)<br/>  |WHERE c2.stop_sequence = c1.stop_sequence+1<br/>  |CONSTRUCT<br/>  |  CREATE (s1)-[:NEXT {trip_number: t1.trip_number, stop_seq: c2.stop_sequence}]-&gt; (s2)<br/>  |RETURN GRAPH<br/>""".stripMargin)<strong class="mp ir">.graph</strong></span></pre><p id="8d1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以向这个routeGraph发送Cypher查询，就像我们从Spark数据帧创建的图表一样:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="bf95" class="lb lc iq mp b gy mt mu l mv mw">  |MATCH<br/>  | <strong class="mp ir">(s1:Stop)&lt;-[n1:NEXT]-(s2:Stop)</strong><br/>  |MATCH<br/>  | <strong class="mp ir">(s2)-[n2:NEXT]-&gt;(s3:Stop)</strong><br/>  |WHERE n1.trip_number = 8962069 AND n2.trip_number = n1.trip_number<br/>  |RETURN s1.stop_number AS prev, s2.stop_number AS curr, s3.stop_number AS next, n1.stop_seq AS seq<br/>  |ORDER BY n1.stop_seq ASC</span></pre><p id="6256" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们寻找上一站和下一站，结果是:</p><pre class="mb mc md me gt mo mp mq mr aw ms bi"><span id="bb64" class="lb lc iq mp b gy mt mu l mv mw">+-----+-----+-----+---+<br/>| prev| curr| next|seq|<br/>+-----+-----+-----+---+<br/>|15992|13093|15992|  2|<br/>|15988|15992|15988|  3|<br/>|15990|15988|15990|  4|<br/>|16004|15990|16004|  5|<br/>|15984|16004|15984|  6|</span></pre><h2 id="aed9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">摘要</h2><p id="9ff6" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在本文中，您看到了如何使用Morpheus和Spark 3在Cloud Dataproc上对BigQuery数据进行图形数据分析:</p><ol class=""><li id="a979" class="ng nh iq kh b ki kj kl km ko ni ks nj kw nk la nl nm nn no bi translated">将BigQuery表读入Scala数据帧</li><li id="c94b" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">使用Spark SQL创建一个初始图形</li><li id="984c" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">使用密码查询图表</li><li id="9415" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">在图形中创建新边</li><li id="aa2c" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">使用密码查询丰富的图形</li></ol><p id="6f86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽情享受吧！</p><h2 id="8e49" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">后续步骤</h2><ol class=""><li id="17be" class="ng nh iq kh b ki lu kl lv ko nu ks nv kw nw la nl nm nn no bi translated">在GitHub上看我的完整代码(<a class="ae lz" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/graphdb/find_routes.scala" rel="noopener ugc nofollow" target="_blank"> find_routes.scala </a>)。</li><li id="a4f9" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">阅读<a class="ae lz" href="https://www.oreilly.com/library/view/google-bigquery-the/9781492044451/" rel="noopener ugc nofollow" target="_blank"> BigQuery:权威指南</a>。每隔六个月左右，我会把这些博文折叠成书。</li><li id="5ad9" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">Morpheus还是很新的，所以关于Morpheus的文档并不多。我发现这个<a class="ae lz" href="https://www.slideshare.net/databricks/neo4j-morpheus-interweaving-table-and-graph-data-with-sql-and-cypher-in-apache-spark" rel="noopener ugc nofollow" target="_blank">幻灯片</a>和这些<a class="ae lz" href="https://github.com/opencypher/morpheus/tree/master/morpheus-examples/src/main/scala/org/opencypher/morpheus/examples" rel="noopener ugc nofollow" target="_blank">例子</a>非常有帮助。</li></ol></div></div>    
</body>
</html>