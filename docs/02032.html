<html>
<head>
<title>RxJS Filtering Operators — Sample, Skip, and Single</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS过滤运算符—样本、跳过和单个</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxjs-filtering-operators-sample-skip-and-single-b3d11fe3ad49?source=collection_archive---------8-----------------------#2020-02-13">https://levelup.gitconnected.com/rxjs-filtering-operators-sample-skip-and-single-b3d11fe3ad49?source=collection_archive---------8-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9ef9c5f2a4267ddc3195579dde93084e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K6iZ9JJuFw0N6Rnk"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@mrthetrain?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Joshua Hoehne </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9da9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="da06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看一些过滤操作符，包括<code class="fe le lf lg lh b">sample</code>、<code class="fe le lf lg lh b">sampleTime</code>、<code class="fe le lf lg lh b">skip</code>、<code class="fe le lf lg lh b">single</code>和<code class="fe le lf lg lh b">skipLast</code>操作符。</p><h1 id="b108" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">sample</code></h1><p id="4261" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">sample</code>操作符返回一个可观察对象，当<code class="fe le lf lg lh b">notifier</code>可观察对象发出时，该可观察对象发出来自源可观察对象的值。</p><p id="4db4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要一个参数，即<code class="fe le lf lg lh b">notifer</code>可观测值。</p><p id="cec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ee1a" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { sample } from "rxjs/operators";</span><span id="3d16" class="mt lj it lh b gy my mv l mw mx">const seconds = interval(1000);<br/>const result = seconds.pipe(sample(interval(5000)));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="9c01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有每秒发出一个数字的<code class="fe le lf lg lh b">seconds</code> Observable。然后我们将它的结果<code class="fe le lf lg lh b">pipe</code>给<code class="fe le lf lg lh b">sample</code>操作符，在这里我们设置<code class="fe le lf lg lh b">notifier</code>可观察值为<code class="fe le lf lg lh b">interval(5000)</code>，它每5秒发出一次。</p><p id="8fa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们有了一个新的可观察对象，它每5秒钟从<code class="fe le lf lg lh b">seconds</code>发出一次值。</p><p id="2929" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该会看到从<code class="fe le lf lg lh b">seconds</code>记录的每几个值。</p><h1 id="3549" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">采样时间</h1><p id="b186" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">sampleTime</code>运算符以周期性间隔从可观测的源中发出最近发出的值。</p><p id="df49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它最多需要两个参数。第一个是<code class="fe le lf lg lh b">period</code>，这是等待从源可观测值发出一个值的时间段。以毫秒或可选<code class="fe le lf lg lh b">scheduler</code>的时间单位计量。</p><p id="be58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是可选的<code class="fe le lf lg lh b">scheduler</code>，默认为<code class="fe le lf lg lh b">async</code>。</p><p id="570f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回一个新的可观察对象，该对象在指定的时间间隔内从源可观察对象发出值。</p><p id="8394" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3efd" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { sampleTime } from "rxjs/operators";</span><span id="51ea" class="mt lj it lh b gy my mv l mw mx">const seconds = interval(1000);<br/>const result = seconds.pipe(sampleTime(5000));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="978f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将从<code class="fe le lf lg lh b">seconds</code>观察器发出的值和<code class="fe le lf lg lh b">pipe</code>发送到<code class="fe le lf lg lh b">sampleTime</code>操作器，操作器将每5秒从<code class="fe le lf lg lh b">seconds</code>发出值。</p><p id="d398" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果将是我们每隔5秒钟从<code class="fe le lf lg lh b">result</code>可观测值中获取值，从<code class="fe le lf lg lh b">seconds</code>可观测值中获取值。</p><p id="18a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该会看到一些来自<code class="fe le lf lg lh b">console.log</code>的数字。</p><h1 id="efa1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">单一的</h1><p id="6064" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">single</code>返回一个可观察对象，它从源可观察对象中发出与<code class="fe le lf lg lh b">predicate</code>函数返回的给定条件相匹配的单个项目。</p><p id="e1cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果源可观察对象发出一个以上这样的项目或没有项目，那么我们分别得到IllegalArgumentException或NoSuchElementException。</p><p id="aa6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果源可观察对象发出项目，但没有一个符合<code class="fe le lf lg lh b">predicate</code>函数中的条件，则发出<code class="fe le lf lg lh b">undefined</code>。</p><p id="0195" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它接受一个参数，即<code class="fe le lf lg lh b">predicate</code>函数，该函数返回匹配从源可观察对象发出的项目的条件。</p><p id="b94b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="23fa" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { single } from "rxjs/operators";</span><span id="2bb6" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1).pipe(single());<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="aeda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录了1。</p><p id="bcd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="93e5" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { single } from "rxjs/operators";</span><span id="479d" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1, 2).pipe(single());<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="fc32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录了错误“序列包含多个元素”。</p><p id="a6e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="93ef" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { single } from "rxjs/operators";</span><span id="aa58" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1, 2).pipe(single(x =&gt; x % 2 === 0));<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="f4f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录了2个，因为2个匹配条件<code class="fe le lf lg lh b">x =&gt; x % 2 === 0</code>。</p><h1 id="991d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">跳跃</h1><p id="ee20" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">skip</code>操作符返回一个可观察对象，它跳过源可观察对象发出的第一个<code class="fe le lf lg lh b">count</code>项，并发出其余的项。</p><p id="2667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用必需的<code class="fe le lf lg lh b">count</code>参数，这是要跳过的来自源可观察项的数量。</p><p id="676d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="65bf" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { skip } from "rxjs/operators";</span><span id="9c1c" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1, 2, 3, 4, 5).pipe(skip(2));<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="8f73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3811" class="mt lj it lh b gy mu mv l mw mx">3<br/>4<br/>5</span></pre><p id="c8e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记录是因为我们指定要跳过从<code class="fe le lf lg lh b">of(1, 2, 3, 4, 5)</code>发出的前2个值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/4439bbc68199b6bcfa4ef78022064388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gq7MAwBPFaaixLdE"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">舒米洛夫·卢德米拉在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f0b8" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">skipLast</h1><p id="6cd0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">skipLast</code>运算符返回一个可观察对象，它跳过了从源可观察对象发出的最后一个<code class="fe le lf lg lh b">count</code>值。</p><p id="b94f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用必需的<code class="fe le lf lg lh b">count</code>参数，即从源可观察对象的末尾跳过的项目数。</p><p id="da8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="14b3" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { skipLast } from "rxjs/operators";</span><span id="2b2d" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1, 2, 3, 4, 5).pipe(skipLast(2));<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="b4ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f8ec" class="mt lj it lh b gy mu mv l mw mx">1<br/>2<br/>3</span></pre><p id="1da1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自从我们指定要跳过最后两个发出的值后，就记录了日志。</p><p id="0726" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">sample</code>和<code class="fe le lf lg lh b">sampleTime</code>运算符分别在<code class="fe le lf lg lh b">notifier</code>可观察对象发出时或在指定的时间间隔返回一个从源可观察对象发出值的可观察对象。</p><p id="2f1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">single</code>返回一个可观察对象，该可观察对象从源可观察对象中发出与给定条件匹配的单个项目。</p><p id="d650" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">skip</code>操作符返回一个可观察对象，该可观察对象在开始从可观察对象发出值时跳过项目的数量。</p><p id="56a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<code class="fe le lf lg lh b">skipLast</code>操作符返回一个可观察对象，它跳过了源可观察对象发出的最后几个值。</p></div></div>    
</body>
</html>