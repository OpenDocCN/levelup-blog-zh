<html>
<head>
<title>Understand Heap Memory Allocation: A Hands-on Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解堆内存分配:实践方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understand-heap-memory-allocation-a-hands-on-approach-775151caf2ea?source=collection_archive---------3-----------------------#2022-10-19">https://levelup.gitconnected.com/understand-heap-memory-allocation-a-hands-on-approach-775151caf2ea?source=collection_archive---------3-----------------------#2022-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="256a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="0424" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我看来，与使用高级编程语言开发应用程序相比，使用C和C++等低级语言进行系统编程的最大区别之一是，你必须自己管理内存。因此，您调用类似于<code class="fe lj lk ll lm b">malloc</code>和<code class="fe lj lk ll lm b">free</code>的API来根据您的需要分配内存，并在不再需要资源时释放内存。它不仅是系统编程中<a class="ae ln" href="https://developers.redhat.com/articles/2021/11/01/debug-memory-errors-valgrind-and-gdb" rel="noopener ugc nofollow" target="_blank">bug</a>最常见的原因之一；而且还会导致许多<a class="ae ln" href="https://en.wikipedia.org/wiki/Memory_safety" rel="noopener ugc nofollow" target="_blank">安全问题</a>。</p><p id="941d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">不难理解像<code class="fe lj lk ll lm b">malloc</code>、<code class="fe lj lk ll lm b">free</code>这样的API的正确用法。但是你有没有想过它们是如何工作的，例如:</p><ul class=""><li id="f278" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">当你调用<code class="fe lj lk ll lm b">malloc</code>时，它会触发系统调用并将任务委托给内核还是有其他机制？</li><li id="6a68" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">当你调用<code class="fe lj lk ll lm b">malloc(10)</code>并试图分配10字节堆内存时，你得到多少字节的内存？10字节或更多？</li><li id="80e1" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">分配内存时，堆对象的确切位置在哪里？</li><li id="4029" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">当你调用<code class="fe lj lk ll lm b">free</code>时，内存是直接返回内核吗？</li></ul><p id="125b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">本文将尝试回答这些问题。</p><p id="9c7e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">注意，内存是一个超级复杂的话题，所以我不可能在一篇文章中涵盖关于它的所有内容(其实这篇文章涵盖的内容非常有限)。本文将重点介绍<code class="fe lj lk ll lm b">userland memory(heap) allocation</code>。</p><h1 id="16d2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">进程内存管理概述</h1><h2 id="237e" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">进程虚拟内存</h2><p id="521b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">每次我们启动一个程序，都会为该程序保留一个内存区域，这就是<code class="fe lj lk ll lm b">process virtual memory</code>，如下图所示:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/69bb41696f46633336b8d5b68e18bb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/0*PzPOOqkzlw1Bm-04.png"/></div></figure><p id="0cd4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">您可以注意到，每个进程都有一个<strong class="kn ir">不可见的</strong>内存段，其中包含内核代码和数据结构。这个看不见的记忆片段很重要；因为它与内核用于内存管理的<code class="fe lj lk ll lm b">virtual memory</code>直接相关。在我们深入其他不同的部分之前，让我们先了解一下虚拟内存。</p><h2 id="2507" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">虚拟存储技术</h2><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/64a7ffcd1f797307d74738a056019f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vnlHd2qevdYjjbq9.png"/></div></div></figure><p id="1892" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">为什么我们需要虚拟内存？虚拟内存是内核以抽象的形式提供的服务。如果没有虚拟内存，应用程序将需要管理它们的物理内存空间，与计算机上运行的所有其他进程进行协调。虚拟内存通过创建允许在虚拟内存和物理内存之间转换的映射，将管理工作留给了内核。内核制造了一个假象，每个进程都占据了整个物理内存空间。我们还可以基于虚拟内存实现<a class="ae ln" href="https://en.wikipedia.org/wiki/Process_isolation" rel="noopener ugc nofollow" target="_blank">进程隔离</a>来增强安全性。</p><p id="d92c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">虚拟内存超出了本文的范围，如果您感兴趣，请看看核心技术:<a class="ae ln" href="https://en.wikipedia.org/wiki/Memory_paging" rel="noopener ugc nofollow" target="_blank">分页</a>和<a class="ae ln" href="https://linuxhint.com/linux-memory-management-swap-space/" rel="noopener ugc nofollow" target="_blank">交换</a>。</p><h2 id="ac1b" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">静态与动态内存分配</h2><p id="dda0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我们仔细看看上面的进程内存布局，了解它们来自哪里。一般来说，有两种方法可以分配内存来存储数据:<code class="fe lj lk ll lm b">static</code>和<code class="fe lj lk ll lm b">dynamic</code>。静态内存分配发生在<code class="fe lj lk ll lm b">compile time</code>，而动态内存分配发生在<code class="fe lj lk ll lm b">runtime</code>。</p><p id="23b9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">当一个程序启动时，可执行文件(在Linux系统上，它被称为一个<code class="fe lj lk ll lm b">ELF</code>文件)将作为一个<code class="fe lj lk ll lm b">Process Image</code>被加载到内存中。该<code class="fe lj lk ll lm b">ELF</code>文件包含以下片段:</p><ul class=""><li id="a91f" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">。文本:包含程序的可执行部分以及所有机器代码。</li><li id="3f5e" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">。数据:包含<code class="fe lj lk ll lm b">initialized</code>静态和全局变量。</li><li id="2a98" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">。BSS:是<code class="fe lj lk ll lm b">block started by symbol</code>的简称，包含<code class="fe lj lk ll lm b">uninitialized</code>静态和全局变量。</li></ul><p id="a892" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">内核将加载<code class="fe lj lk ll lm b">ELF</code>文件，并创建一个进程映像。并且这些静态数据将被映射到虚拟存储器的相应段中。精灵加载器也是一个有趣的话题，我会在以后写另一篇关于它的文章。请继续关注我的博客！</p><p id="5dee" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">memory-mapped region</code>段用于存储<a class="ae ln" href="https://organicprogrammer.com/2019/08/25/how-to-write-linux-c-program-with-external-library/" rel="noopener ugc nofollow" target="_blank">共享库</a>。</p><p id="acbc" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">最后，<code class="fe lj lk ll lm b">stack</code>和<code class="fe lj lk ll lm b">heap</code>段在运行时动态产生，用于存储和操作程序执行过程中使用的临时变量。之前曾经写过一篇关于<a class="ae ln" href="https://organicprogrammer.com/2020/08/19/stack-frame/" rel="noopener ugc nofollow" target="_blank">栈</a>的文章，想了解详情可以参考一下。</p><p id="3c8b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">唯一剩下的我们没有提到的部分是<code class="fe lj lk ll lm b">heap</code>，这是本文的重点！</p><p id="a937" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">您可以通过检查文件<code class="fe lj lk ll lm b">/proc/{pid}/maps</code>来检查一个进程的内存布局，如下所示:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ng"><img src="../Images/1136be07c97e7a3172535e0f5698b2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*auDTmEANUv1BTBWL.png"/></div></div></figure><p id="8742" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">注意，上面的调查没有考虑多线程。多线程的进程内存布局会更复杂，请参考其他在线<a class="ae ln" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="f0dd" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在这一节中，我们从上到下大致了解了内存管理。希望你能看到大局，知道我们在哪里。接下来，让我们深入研究一下<code class="fe lj lk ll lm b">heap</code>部分，看看它是如何工作的。</p><h1 id="8b9b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">存储分配器</h1><p id="ce2f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们需要首先理解内存管理领域的一些术语:</p><ul class=""><li id="7883" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><strong class="kn ir"> mutator </strong>:修改堆中对象的程序，简单来说就是用户应用。但在本文中我将使用术语<code class="fe lj lk ll lm b">mutator</code>。</li><li id="e4fb" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><strong class="kn ir">分配器</strong>:<code class="fe lj lk ll lm b">mutator</code>不会自己分配内存，它会将这个普通任务委托给<code class="fe lj lk ll lm b">allocator</code>。在代码层面上，<code class="fe lj lk ll lm b">allocator</code>通常被实现为一个库。详细的分配行为完全由实现决定，在本文中，我将重点关注<code class="fe lj lk ll lm b">glibc</code>库中的内存分配器。</li></ul><p id="93ba" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">mutator</code>和<code class="fe lj lk ll lm b">allocator</code>的关系如下图所示:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/61f3abfb9d0d10c75ac6e859141a7c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/0*Yd4-PbYeo-VpzEsW.png"/></div></figure><p id="540d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">内存管理领域还有第三个组件:<code class="fe lj lk ll lm b">garbage collector(GC)</code>。<code class="fe lj lk ll lm b">GC</code>自动回收记忆。由于本文讨论的是系统编程中的手动堆内存分配，我们暂时忽略<code class="fe lj lk ll lm b">GC</code>。<code class="fe lj lk ll lm b">GC</code>是一个很有意思的技术挑战，我以后会考察。请继续关注我的博客！</p><h1 id="1eff" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">动手演示</h1><p id="2308" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将使用<code class="fe lj lk ll lm b">gdb</code>和<code class="fe lj lk ll lm b">pwndbg</code>(这是一个gdb <a class="ae ln" href="https://github.com/pwndbg/pwndbg" rel="noopener ugc nofollow" target="_blank">插件</a>)并闯入堆内存，看看它是如何工作的。<code class="fe lj lk ll lm b">gdb</code>提供了通过<code class="fe lj lk ll lm b">Python</code>插件来扩展它的功能。<code class="fe lj lk ll lm b">pwndbg</code>是应用最广泛的。</p><p id="4883" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">演示代码如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4ffd" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">上面的演示代码只是分配一些内存，设置内存的内容，稍后再释放。然后再次分配其他内存块。很简单，好吗？</p><h2 id="5817" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">分配区块</h2><p id="90b5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，在第7行设置一个<code class="fe lj lk ll lm b">breakpoint</code>(第一个<code class="fe lj lk ll lm b">malloc</code>调用)并运行<code class="fe lj lk ll lm b">gdb</code>中的程序。然后从<code class="fe lj lk ll lm b">pwndbg</code>运行<code class="fe lj lk ll lm b">vmmap</code>命令，可以得到如下的进程内存布局:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nk"><img src="../Images/e829f6941c176324d50115772b73a4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JwcP0Qg5jH412y-Y.png"/></div></div></figure><p id="1d66" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">注意，在发出第一个<code class="fe lj lk ll lm b">malloc</code>调用之前，还没有<code class="fe lj lk ll lm b">heap</code>段。在<code class="fe lj lk ll lm b">gdb</code>中跳过一行后，再次检查布局:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nl"><img src="../Images/f79486ba6c0bdc0546b57d1c7ac44ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B5dIKoiiA6WMuhb6.png"/></div></div></figure><p id="fa63" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在<code class="fe lj lk ll lm b">heap</code>段被创建，大小为<code class="fe lj lk ll lm b">132KB</code>(十六进制为21000)。如上所述，内核将132KB的物理内存映射到这个进程的虚拟内存，并将这个132KB的物理内存块标记为用于隔离其他进程。这个映射程序是通过系统调用如<code class="fe lj lk ll lm b">brk</code>、<code class="fe lj lk ll lm b">sbrk</code>和<code class="fe lj lk ll lm b">mmap</code>完成的。请自行调查这些系统调用。</p><p id="9920" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">132KB比100B大很多(传递给<code class="fe lj lk ll lm b">malloc</code>的大小)。这个行为可以回答本文开头的一个问题。不需要每次调用<code class="fe lj lk ll lm b">malloc</code>时都触发系统调用。这种设计旨在降低性能开销。现在132KB堆内存由<code class="fe lj lk ll lm b">allocator</code>维护。下次应用程序再次调用<code class="fe lj lk ll lm b">malloc</code>时，<code class="fe lj lk ll lm b">allocator</code>会为它分配内存。</p><p id="0a92" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，在<code class="fe lj lk ll lm b">gdb</code>中再执行一行，将值(“AAAABBBBCCCCDDDD”)分配给分配的块。让我们用<code class="fe lj lk ll lm b">heap</code>命令检查这个132KB堆段的内容，如下所示:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/92ffae4f78857259aa8976d2de67b430.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/0*bPN2ScoUku29mwcp.png"/></div></figure><p id="ece5" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">有三大块。让我们一个一个地检查这些组块。</p><p id="deb8" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">top</code>块包含所有尚未分配的剩余内存。在我们的例子中，内核将132KB的物理内存映射到这个进程。而100B内存是通过调用<code class="fe lj lk ll lm b">malloc(100)</code>来分配的，所以剩下的内存在<code class="fe lj lk ll lm b">top</code>块中。<code class="fe lj lk ll lm b">top</code>块停留在堆段的边界上，它可以随着进程分配更多内存或释放未使用的内存而增长和收缩。</p><p id="ac0d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">然后我们来看大小为0x291的组块。<code class="fe lj lk ll lm b">allocator</code>使用这个块来存储堆管理结构。对我们的分析不重要，跳过就好。</p><p id="f332" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们关心的是中间那块大小为<code class="fe lj lk ll lm b">0x71</code>的。它应该是我们请求的块，包含字符串“AAAABBBBCCCCDDDD”。我们可以通过检查其内容来验证这一点:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nn"><img src="../Images/3fcb2444448e84a1cc0e1217b63a00a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2YrKOlOJdL7kwWmg.png"/></div></div></figure><p id="bec4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">gdb的<code class="fe lj lk ll lm b"><a class="ae ln" href="https://visualgdb.com/gdbreference/commands/x" rel="noopener ugc nofollow" target="_blank">x</a></code>命令可以使用指定的格式显示给定地址的内存内容。<code class="fe lj lk ll lm b">x/40wx 0x555555559290</code>以十六进制格式从0x555555559290开始打印40个字(每个字32位)的内存。</p><p id="b39a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们可以看到字符串“AAAABBBBCCCCDDDD”在那里。所以我们的猜测是正确的。但问题是为什么这一大块的大小是<code class="fe lj lk ll lm b">0x71</code>。为了理解这一点，我们需要首先分析一下<code class="fe lj lk ll lm b">allocator</code>是如何存储<code class="fe lj lk ll lm b">chunk</code>的。内存块由以下结构表示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="3cbc" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">prev_size</code>:仅当前一个块空闲时，当前一个块的大小，否则当前一个块正在使用时，存储前一个块的用户数据。</li><li id="671c" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">size</code>:当前块的大小。</li><li id="9fcd" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">fd</code>:仅当当前块空闲时，指向下一个空闲块的指针，否则当当前块在使用中时，它存储用户数据。</li><li id="9205" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">bk</code>:指向前一个空闲块的指针。行为方式与指针<code class="fe lj lk ll lm b">fd</code>相同。</li></ul><p id="5484" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">基于以上描述，下图说明了分配的<code class="fe lj lk ll lm b">chunk</code>的确切结构:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi no"><img src="../Images/c0f1af8ccd8fcf79e007e86ea4c0a802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDRhoRWqhGBYY3nw2EEX7A.png"/></div></div></figure><ul class=""><li id="ca1e" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">chunk:表示对象在堆内存中的实际起始地址。</li><li id="adbd" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">mem:通过<code class="fe lj lk ll lm b">malloc</code>指示返回的地址。</li></ul><p id="46bf" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">中间的内存是为上面提到的元数据预留的:<code class="fe lj lk ll lm b">prev_size</code>和<code class="fe lj lk ll lm b">size</code>。在64位系统中，它们的长度是8字节。</p><p id="68d6" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">对于<code class="fe lj lk ll lm b">size</code>字段，值得注意的是:</p><ul class=""><li id="3185" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">它包括元数据的大小和实际用户数据的大小。</li><li id="944c" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">它通常与16字节的倍数对齐。你可以自己调查一下<a class="ae ln" href="https://stackoverflow.com/questions/381244/purpose-of-memory-alignment" rel="noopener ugc nofollow" target="_blank">内存对齐</a>的目的。</li><li id="f3ae" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">它在三个最低有效位包含三个特殊标志(<code class="fe lj lk ll lm b">A|M|P</code>)。我们现在可以忽略其他两位，但最后一位表示前一个块是否在使用中(设置为1)或不在使用中(设置为0)。</li></ul><p id="583d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">据此，我们再来回顾一下这一大块的内容:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi np"><img src="../Images/08c0102d0770b1ae3dd307b2c8556134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*22g_6FoNWnJFBpZM.png"/></div></div></figure><p id="5f92" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我在图像上加了标记来帮助你理解。让我们做一些简单的计算。<code class="fe lj lk ll lm b">100 + 8 = 108</code>，100是我们请求的内存大小，8是元数据的大小(对于<code class="fe lj lk ll lm b">size</code>字段)。然后<code class="fe lj lk ll lm b">108</code>作为16字节的倍数与<code class="fe lj lk ll lm b">112</code>对齐。最后，由于特殊标志P设置为1，那么我们得到<code class="fe lj lk ll lm b">112 + 1 = 113(0x71)</code>(这就是为什么大小是<code class="fe lj lk ll lm b">0x71</code>而不是<code class="fe lj lk ll lm b">0x70</code>的原因)。</p><p id="1435" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在这一节中，我们将进入堆段，看看分配的块是如何工作的。接下来，我们将检查如何释放一个块。</p><h2 id="7404" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated"><strong class="ak">空闲块</strong></h2><p id="cda9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">以前，我们分配一块内存，并将数据放入其中。下一行将释放这个块。在运行指令和展示演示结果之前，让我们先讨论一下理论。</p><p id="c6f5" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在调用<code class="fe lj lk ll lm b">free</code>之后，释放的块不会立即返回给内核。相反，堆<code class="fe lj lk ll lm b">allocator</code>在<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">linked list</a></code>数据结构中跟踪释放的块。因此，当应用程序再次请求新的分配时，可以重用链表中被释放的块。这可以通过避免过多的系统调用来降低性能开销。</p><p id="9243" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">allocator</code>可以将所有释放的块存储在一个长链表中，这是可行的，但是性能会很慢。相反，<code class="fe lj lk ll lm b">glibc</code>维护一系列被称为<code class="fe lj lk ll lm b">bins</code>的自由链表，这可以加速分配和释放。我们稍后将研究<code class="fe lj lk ll lm b">bins</code>是如何工作的。</p><p id="65f4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">值得注意的是，每个空闲组块都需要将<code class="fe lj lk ll lm b">pointers</code>存储到其他组块中，形成链表。这就是我们上一节讨论的，在<code class="fe lj lk ll lm b">malloc_chunk</code>结构中有两点:<code class="fe lj lk ll lm b">fd</code>和<code class="fe lj lk ll lm b">bk</code>，对吗？因为被释放块的<code class="fe lj lk ll lm b">user data</code>区域可供<code class="fe lj lk ll lm b">allocator</code>使用，所以它将<code class="fe lj lk ll lm b">user data</code>区域重新用作存储指针的地方。</p><p id="648b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">根据以上描述，下图说明了已释放区块的确切结构:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nq"><img src="../Images/0a2768db59a2da4a8fdbb2c0dc6b3b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kYD3r3B4eGUNM5imKaI1iw.png"/></div></div></figure><p id="463e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在遍历<code class="fe lj lk ll lm b">gdb</code>中的一行，检查堆中的块，如下所示:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/cfcde5cba2effa54547dc17fb00da625.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*AfD8AnoTGkz_LoeH.png"/></div></figure><p id="0aaf" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">您可以看到变化:分配的块被标记为<code class="fe lj lk ll lm b">Free chunk (tcache)</code>并且设置了指针<code class="fe lj lk ll lm b">fd</code>(这表明这个被释放的块被插入到一个链表中)。</p><p id="37c1" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">tcache</code>是<code class="fe lj lk ll lm b">glibc</code>提供的<code class="fe lj lk ll lm b">bins</code>的一种。gdb <code class="fe lj lk ll lm b">pwndbg</code>插件允许您通过运行命令<code class="fe lj lk ll lm b">bins</code>来检查<code class="fe lj lk ll lm b">bins</code>的内容，如下所示:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/33f8cf54725d9622d3ddecea4221d936.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*MbDtKUBtY6R2i_Fs.png"/></div></figure><p id="fd68" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">注意，被释放的块(在0x5555555592a0处)被插入到<code class="fe lj lk ll lm b">tcache bins</code>中作为喜欢列表头。</p><p id="e521" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">注意有5种类型的箱子:<code class="fe lj lk ll lm b">small bins</code>、<code class="fe lj lk ll lm b">large bins</code>、<code class="fe lj lk ll lm b">unsorted bins</code>、<code class="fe lj lk ll lm b">fast bins</code>和<code class="fe lj lk ll lm b">tcache bins</code>。如果您不知道，不要担心，我将在接下来的部分中研究它们。</p><p id="ea86" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">根据定义，第二个<code class="fe lj lk ll lm b">malloc(100)</code>被调用后，<code class="fe lj lk ll lm b">allocator</code>要重用<code class="fe lj lk ll lm b">bins</code>中被释放的chunk。下图可以证明这一点:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3569a01c5a5719586c4792af4306a238.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/0*SFVKNsRuctW5wSlQ.png"/></div></figure><p id="e346" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">0x555555559290处被释放的块再次被使用，并且在从链表中移除该块之后，所有的<code class="fe lj lk ll lm b">bins</code>都是空的。好吧！</p><h1 id="2ac2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">用垃圾箱回收内存</h1><p id="6a30" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我想花一点时间来研究我们为什么需要<code class="fe lj lk ll lm b">bins</code>以及<code class="fe lj lk ll lm b">bins</code>如何优化块分配和释放。</p><p id="2358" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果<code class="fe lj lk ll lm b">allocator</code>在一个长链表中跟踪所有被释放的块。对于分配器来说，通过从头到尾遍历来找到合适大小的空闲块的时间复杂度是<code class="fe lj lk ll lm b">O(N)</code>。如果<code class="fe lj lk ll lm b">allocator</code>想要保持块有序，那么至少需要<code class="fe lj lk ll lm b">O(NlogN)</code>时间来按大小排序列表。这个缓慢的过程会对程序的整体性能产生不良影响。这就是为什么我们需要箱子来优化这个过程。综上所述，优化从以下两个方面进行:</p><ul class=""><li id="4fc1" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">高性能数据结构</li><li id="003f" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">无锁争用的每线程缓存</li></ul><h2 id="480e" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">高性能数据结构</h2><p id="7626" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">以<code class="fe lj lk ll lm b">small bins</code>和<code class="fe lj lk ll lm b"><a class="ae ln" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1686" rel="noopener ugc nofollow" target="_blank">large bins</a></code>为参考，定义如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="47b4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">它们被一起定义在一个链表数组中，每个链表(或bin)存储的块都是<code class="fe lj lk ll lm b">the same fixed size</code>。从<code class="fe lj lk ll lm b">bins[2] to bins[63]</code>开始是<code class="fe lj lk ll lm b">small bins</code>，它跟踪小于1024字节的释放块，而<code class="fe lj lk ll lm b">large bins</code>用于更大的块。<code class="fe lj lk ll lm b">small bins</code>和<code class="fe lj lk ll lm b">large bins</code>可以表示为下图所示的<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Doubly_linked_list" rel="noopener ugc nofollow" target="_blank">double-linked list</a></code>:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/91098c90cb920f47893e98dc7c55ed5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/0*gitJf8lzSatn5VQR.png"/></div></figure><p id="3a23" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">glibc</code>提供了一个<a class="ae ln" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1686" rel="noopener ugc nofollow" target="_blank">函数</a>，根据请求的<code class="fe lj lk ll lm b">size</code>计算数组中相应小(或大)仓的<code class="fe lj lk ll lm b">index</code>。由于<a class="ae ln" href="https://en.wikipedia.org/wiki/Array_(data_structure)" rel="noopener ugc nofollow" target="_blank">阵列</a>的<code class="fe lj lk ll lm b">index</code>操作在<code class="fe lj lk ll lm b">O(1)</code>时间内。此外，每个bin包含相同大小的块，因此向列表中插入或从列表中删除一个块也需要花费<code class="fe lj lk ll lm b">O(1)</code>时间。因此，整个分配时间被优化为<code class="fe lj lk ll lm b">O(1)</code>。</p><p id="3de7" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">bins</code>是<code class="fe lj lk ll lm b">LIFO(Last In First Out)</code>的数据结构。插入和移除操作如下所示:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/e951a6cf7959d0ace62563bf120db3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/0*mfxEyw8TugoNrdfp.png"/></div></figure><p id="fe16" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">此外，对于<code class="fe lj lk ll lm b">small bins</code>和<code class="fe lj lk ll lm b">large bins</code>，如果当前块的邻居是空闲的，则它们被<code class="fe lj lk ll lm b">merged</code>成更大的块。这就是为什么我们需要一个<code class="fe lj lk ll lm b">double-linked list</code>来允许向前和向后快速移动。</p><p id="71ba" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">与<code class="fe lj lk ll lm b">small bins</code>和<code class="fe lj lk ll lm b">large bins</code>不同，<code class="fe lj lk ll lm b">fast bins</code>和<code class="fe lj lk ll lm b">tcache bins</code>组块是与它们的邻居<code class="fe lj lk ll lm b">never merged</code>在一起的。实际上，glibc <code class="fe lj lk ll lm b">allocator</code>不会在下一个块开始时设置<code class="fe lj lk ll lm b">P</code>特殊标志。这可以避免合并块的开销，以便在请求相同大小的块时，可以立即重用释放的块。此外，由于<code class="fe lj lk ll lm b">fast bins</code>和<code class="fe lj lk ll lm b">tcache bins</code>从不合并，它们被实现为<code class="fe lj lk ll lm b"><a class="ae ln" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1678" rel="noopener ugc nofollow" target="_blank">single-linked list</a></code>。</p><p id="d9bc" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这可以通过运行演示代码中的第二个<code class="fe lj lk ll lm b">free</code>方法来证明，并检查堆中的块，如下所示:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6fe74e3f174f7684472541f5845070ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*4nPD6RrKR7ej2nrt.png"/></div></figure><p id="ccf6" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">首先，<code class="fe lj lk ll lm b">top</code>块的大小仍然是<code class="fe lj lk ll lm b">0x20d01</code>而不是<code class="fe lj lk ll lm b">0x20d00</code>，这表明<code class="fe lj lk ll lm b">P</code>位等于1。第二，<code class="fe lj lk ll lm b">Free chunk</code>只有一个指针:<code class="fe lj lk ll lm b">fd</code>。如果它在一个双向链表中，那么<code class="fe lj lk ll lm b">fd</code>和<code class="fe lj lk ll lm b">bk</code>都应该指向一个有效的地址。</p><h2 id="29a0" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">无锁争用的每线程缓存</h2><p id="cd3f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b">tcache bins</code>中的字母<code class="fe lj lk ll lm b">t</code>代表<code class="fe lj lk ll lm b">thread</code>，用于优化多线程程序的性能。在多线程编程中，防止<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank">race condition</a></code>问题的最常见方法是使用<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Lock_(computer_science)" rel="noopener ugc nofollow" target="_blank">lock or mutex</a></code>。类似地，<code class="fe lj lk ll lm b">glibc</code>在每个堆的数据结构中维护一个<code class="fe lj lk ll lm b">lock</code>。但是这种设计有一个性能代价:<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Lock_(computer_science)#:~:text=lock%20contention%3A%20this%20occurs%20whenever,lock%20held%20by%20the%20other." rel="noopener ugc nofollow" target="_blank">lock contention</a></code>，当一个线程试图获取另一个线程持有的锁时就会发生这种情况。这意味着线程不能执行任何任务。</p><p id="9247" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">tcache bins</code>是每个线程的bin。这意味着如果线程在它的<code class="fe lj lk ll lm b">tcache bins</code>上有一个块，它可以服务于分配而不需要等待堆锁！</p><h1 id="c4d5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="a8d3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我们通过使用gdb调试堆内存，研究了userland堆分配器是如何工作的。讨论完全基于<code class="fe lj lk ll lm b">glibc</code>实现。<code class="fe lj lk ll lm b">glibc</code>堆分配器的设计和行为很复杂，但是很有趣，我们在这里讨论的只是冰山一角。可以自己多探索。</p><p id="e238" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">此外，我计划为学习和教学目的编写一个简单版本的堆分配器。请继续关注我的博客！</p></div></div>    
</body>
</html>