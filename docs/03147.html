<html>
<head>
<title>Jupyter Notebook Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jupyter笔记本最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/jupyter-notebook-best-practices-fc326eb5cd22?source=collection_archive---------1-----------------------#2020-04-22">https://levelup.gitconnected.com/jupyter-notebook-best-practices-fc326eb5cd22?source=collection_archive---------1-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f2cc6f5df5a630d0d283c2f87e57e8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbVFEGKZFKPa6IsUn7zcbw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马克·瑟尼斯在<a class="ae kf" href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="18f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当涉及到数据科学解决方案时，总是需要快速原型开发。无论是复杂的人脸识别算法还是简单的回归模型，拥有一个可以让你轻松测试和验证想法的模型都是非常有价值的。</p><p id="03c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于问题的性质，许多数据科学问题需要<strong class="ki iu">特制的解决方案</strong>。这意味着处理这些问题的数据科学家最终将需要<strong class="ki iu">在这个问题上随机应变</strong>，这意味着<strong class="ki iu">不必在每次执行脚本时等待</strong>计算数据集上的一些附加特征列，这在生产率方面是一个至关重要的收益。由于这是编程界的一个长期存在的问题，社区实际上已经为这个问题建立了一个解决方案:进入<a class="ae kf" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Project Jupyter </a>。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/a0ef2b0b3ae235c9fd6aa32b9cacf45d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6e7bBoPib-DJNz-aToXfg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank">Jupyter项目</a></figcaption></figure><h1 id="ff2b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">朱庇特是什么？</h1><p id="2586" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">Jupyter源于IPython项目，是一个交互式编程环境，主要关注数据科学和科学编程。尽管Project Jupyter包括许多在某些情况下非常有用的组件，但最著名的Jupyter组件是笔记本。Jupyter Notebook是一个开源的网络应用程序，它允许<strong class="ki iu">将代码与文本、可视化、等式和分析</strong>结合起来。事实证明，它在各种情况下都很有用，比如用嵌入式交互式小工具共享数据分析结果，或者围绕各种复杂的主题构建教程。</p><h1 id="1b49" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Jupyter笔记本的优势</h1><p id="093f" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">由于其简单的界面，笔记本电脑为许多复杂项目的发展提供了一个很好的起点。笔记本本质上由称为“输入”的单元组成，笔记本中的每个输入单元都有一个对应的称为“输出”的单元。下图以非常基本的形式展示了它的外观:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/2dcec50df6bb80f53a3010220b7e86c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8_jjEgG9Fxu2F-wfh3bng.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一个非常简单的Jupyter笔记本电池。</figcaption></figure><h2 id="a8c2" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">快速数据探索</h2><p id="3d77" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">Jupyter笔记本电脑最重要的优势之一来自笔记本电脑的逐单元特性，这意味着<strong class="ki iu">拆分每个可能的逻辑步骤</strong>允许以非常互动的方式探索手头的数据:</p><ul class=""><li id="63f1" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated">每个小单元格都可以被删除或修改，而不会对其余分析产生任何影响。</li><li id="7c02" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">单元格<strong class="ki iu">上的任何变化都可以被还原</strong>，因此它允许自信地快速移动，而不用过多考虑代码的后果。</li><li id="87df" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">在前面的步骤中，某个单元格的任何输入和输出都是<strong class="ki iu">高度可见的</strong>，可以在开始研究数据之前很容易地显示出来。</li></ul><p id="daef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于这些优势，无需处理外部影响或输入输出匹配，就可以非常简单地将激光聚焦于分析的特定部分。</p><h2 id="ef94" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">数据缓存</h2><p id="d6fa" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">由于每个单元格只对自己负责，这允许自动保存单元格数据以供将来参考，而不需要运行整个脚本来到达某个点。</p><p id="0d36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一下，您对一个外部服务进行了一个缓慢的API调用，然后您在可以开始处理数据之前进行了一堆数据清理操作；您可以在<code class="fe nn no np nq b">Cell 3</code>中提取数据，对其进行处理，直到在<code class="fe nn no np nq b">Cell 4</code> <strong class="ki iu">中完全完成数据清理，而无需从API中重新下载数据</strong>，并且仍然能够从<code class="fe nn no np nq b">Cell 18</code>中引用清理后的数据，能够以非常强大的方式提高生产力<strong class="ki iu">，一旦您习惯了，您将开始到处寻找它。</strong></p><h2 id="e44a" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">独立文档</h2><p id="9640" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">Jupyter笔记本本质上是<strong class="ki iu"> HTML页面</strong>；这意味着，在常见情况下，当您需要共享您的工作成果时，生成的分析笔记本文件可以简单地<strong class="ki iu">呈现为HTML文件</strong>，一旦您有了文件，您可以直接与接收者共享它，或者您可以简单地通过远程主机提供文件，无需在远程主机中设置Python或任何编程环境。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/fb980564bea820e817d349436dd8b98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*bUW4nGTxj-37ra3ODum_ew.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Jupyter笔记本电脑的各种出口选项</figcaption></figure><p id="9d4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了HTML格式，Jupyter笔记本还可以导出许多其他格式，如AsciiDoc、LaTeX或Markdown。</p><h2 id="a43c" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">嵌入式文档</h2><p id="ccbc" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">Jupyter Notebook的一个非常简单但有效的特性是它的<strong class="ki iu"> </strong>简单的<strong class="ki iu">文档弹出</strong>。一旦你有了一个函数并打开括号，点击<code class="fe nn no np nq b">Shift + Tab</code>就会打开一个弹出窗口，显示该函数的文档。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6ac89c215d24561736ee005cc2cec720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*s1wJeUw2QyjCI7-qDVCfhg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Jupyter笔记本的弹出文档</figcaption></figure><h1 id="4c00" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">最佳实践</h1><p id="76f1" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">就像任何其他工具一样，Jupyter笔记本也有最佳实践，使数据科学家的生活更加轻松，并使他们能够毫无困难地从事复杂的项目。一如既往，这些不是硬性规定，可能会根据项目而变化；他们在那里用以前的经验提供指导。</p><h2 id="3e1e" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">使用版本控制系统</h2><p id="94a3" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">对于常规的软件开发生命周期来说，这可能是非常基本的最佳实践；然而，在数据科学家中，像Git这样的版本控制系统的采用率似乎仍然很低，这可能是一个非常容易实现的成果，肯定会给<strong class="ki iu">带来生产力的提升</strong>。版本控制系统:</p><ul class=""><li id="510b" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated">允许你在不同版本的代码之间进行时间旅行</li><li id="78fd" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">启用更改内容<strong class="ki iu">而不用担心丢失代码</strong></li><li id="0844" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">启用<strong class="ki iu">与员工一起审查</strong>项目</li><li id="a8c4" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="ki iu">及时跟踪变更</strong>与所有权</li></ul><p id="5842" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于所有这些优点，版本控制系统已经成为软件开发项目中的基本要素之一，在开发Jupyter笔记本分析时也应该使用它们。</p><h2 id="0c85" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">尝试使用新的变量</h2><p id="013a" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">Jupyter笔记本支持在逐个单元格的结构中处理数据，这意味着您可以使用前一个单元格中定义的变量，并在这些值的基础上<strong class="ki iu">构建，但有一点要小心，不要重写该变量。这种最佳实践主要取决于手头的问题，可能不适用于处理无法多次放入内存的大型数据集，但一般来说这是一种很好的实践。</strong></p><p id="8909" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑从笔记本电脑的远程服务器下载一个CSV文件，并将其存储在一个名为<code class="fe nn no np nq b">data_csv</code>的变量中。此时，您想要对该数据进行一些修改，并改变其结构，使其更适合您的分析。有两种方法可以做到这一点，你可以转换数据并再次将所有内容存储在<code class="fe nn no np nq b">data_csv</code>变量上，或者你可以在另一个变量<code class="fe nn no np nq b">formatted_data </code>上运行所有转换。</p><p id="039f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一种方法的优点是<strong class="ki iu">更有效的内存使用</strong>，因为在进一步的分析中，您可能需要格式化的数据，而不是原始的CSV数据；然而，这种方法有一个重要的缺点:每当你出错并需要重置数据时，<strong class="ki iu">你需要重新下载CSV并再次运行所有步骤，直到你到达笔记本中的当前点。</strong>由于这个限制，如果你遵循第二种方法，你只需要重新设置你的<code class="fe nn no np nq b">formatted_data</code>变量的赋值就可以了；无需再次下载CSV，无需从头开始运行所有细胞。</p><h2 id="e853" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">学习键盘快捷键</h2><p id="0144" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">在任何学科中，学习您的工具总是大有帮助，在数据科学中也是如此。除了了解Jupyter笔记本的一般功能之外，了解<strong class="ki iu">键盘快捷键</strong>和<strong class="ki iu">也非常有用，了解得越多，使用笔记本的速度就越快</strong>。</p><p id="8aae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了查看键盘快捷键，使用<code class="fe nn no np nq b">Help &gt; Keyboard Shortcuts</code>菜单项，这将打开一个显示快捷键的弹出窗口。除此之外，您还可以通过<code class="fe nn no np nq b">Help &gt; Edit Keyboard Shortcuts</code>菜单项更改快捷方式。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/74ca8cee9ceecc377f86d0a07edb798f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8i4E-h-bGB5haL3cslhVJg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">键盘快捷键弹出菜单示例</figcaption></figure><h2 id="0045" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">记录您的分析</h2><p id="f117" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">笔记本应该是一个交互式环境，在这里你可以将代码和纯文本结合起来。笔记本单元格还允许你<strong class="ki iu">写markdown </strong>，这使你能够写你想写的所有文档，然后以一种漂亮的文本格式呈现。编写文档时，<strong class="ki iu">遵循由<strong class="ki iu">专有标题</strong>、解释以及代码块和示例支持的逻辑层次</strong>。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f71958f79ef2c8f1f662eba2b78abcf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*k_VUP_D1rSXfZOtEz2bcag.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在渲染之前，这是你如何在单元格中写markdown。</figcaption></figure><p id="44e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过选择<code class="fe nn no np nq b">Cell &gt; Cell Type</code>菜单中的<code class="fe nn no np nq b">Markdown</code>选项，可以启用单元格的降价模式。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/91791af43180fb483802247e281b07a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*smxcRBBBrnHivhs6Q54JsA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这是细胞被执行时的样子。</figcaption></figure><p id="c293" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记录分析将使跟踪变得容易，并为修改提供进一步的指导。</p><h2 id="b5ed" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">JupyterLab代替普通笔记本</h2><p id="796c" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">JupyterLab是Jupyter的下一代基于网络的界面。除了笔记本，它还支持各种文件类型，文本编辑器，终端和其他自定义查看器。你可以把它想象成一个强大的笔记本环境，它有文件资源管理器，允许你把你的工作分成几个标签，不用离开你的笔记本就可以在浏览器上运行进一步的分析和执行。</p><p id="50d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了运行Jupyter实验室，只需在您的终端中运行<code class="fe nn no np nq b">jupyter lab</code>，这将启动实验室界面。</p><h2 id="f4c1" class="mn lk it bd ll mo mp dn lp mq mr dp lt kr ms mt lx kv mu mv mb kz mw mx mf my bi translated">保持笔记本简单</h2><p id="c32e" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">尽管笔记本本身应该是完整的分析，但是继续利用一般的软件开发实践是明智的，尤其是在管理复杂性方面。对某个主题的分析可能会变得非常复杂，包括各种数据获取操作、操作、清理和可视化；然而，保持笔记本整洁有序是很重要的。笔记本鼓励探索，但是任何严肃的分析和模型都需要适当的测试和组织。有一些建议可以遵循:</p><ul class=""><li id="0612" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><strong class="ki iu">用</strong> <a class="ae kf" href="https://docs.python.org/3/tutorial/modules.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> Python模块</strong> </a> <strong class="ki iu">让你的代码井井有条。</strong>理想情况下，笔记本不应该包含复杂的逻辑，应该易于理解。不要把所有的代码都记在笔记本上，而是把它们提取到模块中，然后从你的笔记本上使用这些模块。</li><li id="2d47" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="ki iu">编写测试。编写测试不是一个容易养成的习惯，但是一旦你掌握了它，你会注意到它在多大程度上提高了工作质量。您不必从测试开始，但是一旦您有了一个稳定的功能或模块，编写一个简单的测试来涵盖该行为将会大有帮助，并且它还将允许在将来使用该功能，包括与模型一起投入使用。</strong></li><li id="132a" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="ki iu">删除死代码。</strong>这个死代码可能是被遗忘的<code class="fe nn no np nq b">print</code>语句、旧模型的注释掉的版本或未使用的循环；不管是什么，如果代码不再相关，就删除它。<strong class="ki iu">笔记本中的每一行代码都有数据科学家</strong>需要记录的精神开销，这意味着代码越少，你的精神负担就越少。</li><li id="7af3" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="ki iu">利用广泛接受的编码标准，如</strong><a class="ae kf" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">pep 8</strong></a><strong class="ki iu">。有了一个合适的标准，你就可以轻松地在不同的项目间导航，也可以减少在这里和那里决定使用何种风格的认知负担。</strong></li></ul><h1 id="84fd" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="6af9" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">尽管这里的建议足够通用，可以在许多项目中实现，但是您自己的工作方式也会对这些实践产生影响；有些可能对你有用，而有些可能会拖你的后腿。总的来说，利用Jupyter笔记本电脑的强大功能，您可以节省大量时间，并将更多精力放在核心业务上，而不是小细节上。</p><h1 id="fec0" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">进一步阅读</h1><ul class=""><li id="ea5b" class="mz na it ki b kj mh kn mi kr nw kv nx kz ny ld ne nf ng nh bi translated"><a class="ae kf" href="https://www.thoughtworks.com/insights/blog/coding-habits-data-scientists" rel="noopener ugc nofollow" target="_blank">https://www . thoughtworks . com/insights/blog/coding-habits-data-scientists</a></li><li id="1f17" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae kf" href="https://florianwilhelm.info/2018/11/working_efficiently_with_jupyter_lab/" rel="noopener ugc nofollow" target="_blank">https://florianwilhelm . info/2018/11/working _ efficient _ with _ jupyter _ lab/</a></li><li id="f86a" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae kf" href="https://codeburst.io/jupyter-notebook-tricks-for-data-science-that-enhance-your-efficiency-95f98d3adee4" rel="noopener" target="_blank">https://code burst . io/jupyter-notebook-tricks-for-data-science-that-enhanced-your-efficiency-95f 98 D3 ade 4</a></li><li id="2bb0" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae kf" href="https://www.geeksforgeeks.org/jupyter-notebook-tips-and-tricks/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/jupyter-notebook-tips-and-tricks/</a></li></ul></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><div class="lf lg lh li gt og"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">编写面试问题</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">技术开发</p></div></div><div class="op l"><div class="oq l or os ot op ou jz og"/></div></div></a></div></div></div>    
</body>
</html>