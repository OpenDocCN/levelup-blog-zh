<html>
<head>
<title>Dependency Injection in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-in-typescript-2f66912d143c?source=collection_archive---------0-----------------------#2021-04-27">https://levelup.gitconnected.com/dependency-injection-in-typescript-2f66912d143c?source=collection_archive---------0-----------------------#2021-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9381" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用Typescript在Node.js中进行依赖注入</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7ee1be29c731d3c27d75cd01f32af243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EjOezZWFJ92qj8bt"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Anthony DELANOIX 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="ce21" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="8e47" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">每个软件程序都有基本的构建模块。在面向对象编程中，我们使用类来构建复杂的体系结构。像构建一个结构一样，我们在我们的模块之间建立被称为<strong class="lq ir">依赖</strong>的关系。其他类通过提供代表我们做复杂操作来支持我们的类。</p><p id="19a6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一个类可能有引用其他类的字段。那么，我们要问这些问题:这些参照物是如何构建的？是<strong class="lq ir">我们</strong>组装这些对象，还是<strong class="lq ir">其他</strong>负责实例化？如果实例化一个类<strong class="lq ir">太复杂</strong>，并且我们想要避免意大利面条式的代码，该怎么办？所有这些问题构成了<strong class="lq ir">依赖注入原理</strong>试图解决的问题集。</p><p id="3dba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们开始举例之前，我们必须理解一些关于依赖注入的概念。依赖注入原则告诉我们，一个类应该<strong class="lq ir">接收</strong>它的依赖，而不是实例化它们。委托对象初始化可以通过处理复杂的操作来减轻设计类的压力。您从代码中去掉了复杂的部分，并通过其他方式重新引入了依赖关系。你怎么做到这个<em class="mp">“带走”</em><em class="mp">“重新引入它们”</em>就是管理依赖的问题。您可以手动处理所有的初始化和注入，但是这会导致复杂的系统，这是我们试图避免的。相反，你可以把你的建设责任移交给一个国际奥委会的集装箱。</p><p id="dbf1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">控制反转</strong>是反转整个程序流，让一个容器管理所有的程序依赖。您创建了一个容器，这个容器负责构造每个对象。当一个类需要一个对象来实例化时，IoC容器提供所需的依赖。</p><p id="cf5f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">IoC <strong class="lq ir">只是</strong>表达了一种方法论，并不是具体的实现。为了应用依赖注入原则，你需要一个<strong class="lq ir"> DI框架</strong>。几个例子是:</p><ul class=""><li id="1aba" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated"><strong class="lq ir">弹簧</strong>和<strong class="lq ir">匕首</strong>为<strong class="lq ir">爪</strong></li><li id="6067" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">刀柄</strong>为<strong class="lq ir">科特林</strong></li><li id="07f3" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">统一</strong>为<strong class="lq ir"> C# </strong></li><li id="6df2" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">将</strong>、<strong class="lq ir"> Nest.js </strong>、<strong class="lq ir"> TypeDI </strong>转化为<strong class="lq ir"> TypeScript </strong></li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="028e" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">概述和角色</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/165a695173d9ca433e51e01fd45b1a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*Wk4iA2XNAOl4pAF5cYbU3w.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">依赖注入概述</figcaption></figure><p id="32c7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在依赖注入原理中，我们需要了解<strong class="lq ir">四个</strong>不同类型的<strong class="lq ir">角色</strong>:</p><ul class=""><li id="8a15" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated"><strong class="lq ir">客户端</strong></li><li id="217f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">服务</strong></li><li id="80ff" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">界面</strong></li><li id="971d" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">喷油器</strong></li></ul><p id="9f53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">服务是我们暴露出来的东西。这些类由IoC容器实例化和使用。一个<strong class="lq ir">客户端</strong>通过IoC容器使用这些服务。客户不应该被细节所困扰，所以<strong class="lq ir">接口</strong>确保客户和服务和谐相处。一个客户端询问依赖关系，一个<strong class="lq ir">注入器</strong>提供实例化的服务。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="d775" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">依赖注入的类型</h1><p id="a38a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我们谈到如何设法将依赖关系注入到一个类中时，我们可以通过三种不同的方式来实现:</p><ul class=""><li id="2c35" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">我们可以通过<strong class="lq ir">属性</strong>(字段)提供依赖关系。在类上定义一个属性，然后将一个具体的对象注入到该属性中，这称为属性注入。通过向外部公开一个属性，你<strong class="lq ir">违反了面向对象的</strong>封装<strong class="lq ir">原则；因此，你可能要避免这种类型的注射。</strong></li><li id="9e8f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">我们可以通过<strong class="lq ir">方法</strong>提供依赖关系。对象<strong class="lq ir">的一个<strong class="lq ir">状态</strong>应该是私有的</strong>，当一个局外人想要改变那个状态时，它应该使用该类的<strong class="lq ir"> getter/setter方法</strong>。所以当你使用setter方法初始化类中的私有字段时，你使用了<strong class="lq ir">方法注入</strong>。</li><li id="d416" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">我们可以通过一个<strong class="lq ir">构造器</strong>来提供依赖关系。由于构造函数方法的基本性质，它们与对象构造高度交织在一起。我们通常<strong class="lq ir">喜欢</strong>通过构造函数进行注入<strong class="lq ir">，因为我们的目的和构造函数方法相似。</strong></li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="3811" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">使用TypeDI</h1><p id="44be" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦我们理解了底层的原则，我们使用什么样的框架或库就没什么区别了。对于本文，我选择了TypeScript语言和TypeDI库来演示基本概念。</p><p id="3ae8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">初始化Yarn和添加TypeScript需要一点努力。因为我不想用没有额外信息的众所周知的项目配置来烦你，所以我将给出开始的代码并简单地浏览一下。你可以从<a class="ae kv" href="https://github.com/mertturkmenoglu/typescript-dependency-injection" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>查看和下载代码。</p><p id="e3fc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">任何TypeScript项目都可以作为演示DI的例子，但是我为本文选择了Node/Express应用程序。我假设使用TypeScript的人要么直接使用Node/Express服务器，要么对它们有所了解。</p><p id="09c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您检查<code class="fe nr ns nt nu b">package.json</code>时，您可以看到几个依赖项。让我简单介绍一下:</p><ul class=""><li id="4f97" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated"><strong class="lq ir"> express </strong> : Express是一个用于编写Node.js RESTful服务器的流行框架。</li><li id="7a9f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir"> reflect-metadata </strong>:元数据反射API的Polyfill库。这个库允许其他库通过decorators使用元数据。</li><li id="20bc" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir"> ts-node: </strong> Node.js不能运行TypeScript文件。在运行代码之前，需要将TypeScript编译成JavaScript。ts-node为您处理这个过程。</li><li id="f5c0" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir"> typedi: </strong> TypeDI是TypeScript的依赖注入库。我们很快就会看到用例。</li><li id="91b7" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir"> typescript: </strong>我们正在为这个项目使用typescript，所以我们需要将它添加为一个依赖项。</li><li id="6d7f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">@ types/Express:</strong>Express库的类型定义。</li><li id="1f10" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">@ types/node</strong>:node . js的类型定义</li><li id="4352" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir"> ts-node-dev: </strong>这个库允许您运行TypeScript文件并观察某些文件的变化。</li></ul><p id="37b4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您需要注意几个重要的编译器选项。如果你看一下<strong class="lq ir"><em class="mp">ts config . JSON</em></strong>，你可以看到编译过程的选项:</p><ul class=""><li id="ddf2" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">我们指定类型为<strong class="lq ir"> <em class="mp">反射-元数据</em> </strong>和<strong class="lq ir"> <em class="mp">节点</em> </strong>。</li><li id="96ff" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">我们必须将<strong class="lq ir"><em class="mp">emitedecoratormeta data</em></strong>和<strong class="lq ir"><em class="mp">experimental decorators</em></strong>标志设置为真。</li></ul><p id="5e98" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们所有的源代码都在<strong class="lq ir"> <em class="mp"> src </em> </strong>文件夹里。<strong class="lq ir"> <em class="mp"> src/index.ts </em> </strong>是我们的切入点。该文件包含服务器的所有引导步骤:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3b4d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这段代码是一个只有一个端点的最小Express服务器。当你向<strong class="lq ir">/用户</strong>路由发送一个<strong class="lq ir"> GET </strong>请求时，它会返回一个用户列表。<strong class="lq ir">主</strong>函数的关键部分是“<em class="mp"> Container.ge </em> t”方法。请注意，我们没有使用new关键字或实例化一个对象。我们只是请求IoC容器返回一个UserController实例。然后我们绑定路由和控制器方法。</p><p id="faa5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的应用程序是一个虚拟的RESTful服务器，但是我不希望它完全没有意义。我添加了四个不同的文件夹来代表一个完整后端的基础部分。这些是<strong class="lq ir">控制器</strong>、<strong class="lq ir">模型</strong>、<strong class="lq ir">存储库</strong>和<strong class="lq ir">服务</strong>。现在，让我们逐一查看:</p><ul class=""><li id="95ee" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated"><strong class="lq ir">控制器</strong>文件夹包含我们的<strong class="lq ir">剩余控制器</strong>。他们负责协调用户和服务之间的通信。它们接收请求并返回响应。</li><li id="0362" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir"> Models </strong>文件夹包含我们的<strong class="lq ir">数据库实体</strong>。我们没有数据库连接，也不需要，但是建立一个合适的项目结构对学习有很大的影响。让我们假设它们是真实的数据库实体，并继续我们的旅程。</li><li id="ed0f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir">服务</strong>文件夹包含我们的<strong class="lq ir">服务</strong>。它们负责通过访问不同的存储库来满足REST控制器的需求。</li><li id="5ad5" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><strong class="lq ir"> Repositories </strong>文件夹包含我们的<strong class="lq ir">数据库访问类</strong>。我们使用数据映射器模式来执行数据库操作。在这个模式中，我们使用存储库类来访问数据库并进行操作。</li></ul><p id="fefb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们不会在一节课上做所有的事情。请求和响应之间有许多层。这叫做<strong class="lq ir">分层架构</strong>。通过在类之间进行工作分担，我们使得依赖注入变得更加容易。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1280" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">UserController只有一个方法。“getAllUsers”方法负责从用户服务获取结果并传送。我们向UserController类添加了一个<strong class="lq ir">服务</strong>装饰器，因为我们希望这个类由IoC容器管理。在构造函数方法内部，我们可以看到这个类需要一个UserService实例。同样，我们不必控制这种依赖关系，因为TypeDI容器将为UserService创建一个实例，当它生成UserController实例时，它将注入UserService。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="afa1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">UserService与UserController非常相似。我们向类中添加一个服务装饰器，并在构造函数方法中指定我们想要的依赖关系。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bec3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">用户存储库是我们的最后一站。我们用服务注释这个类，但是我们没有任何依赖。因为我们没有数据库连接，所以我只是将硬编码的用户列表作为私有属性添加到class中。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="3002" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">结论</h1><p id="7649" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">依赖注入是管理复杂对象初始化的便利工具。做手工依赖注入总比什么都不做好，但是使用TypeDI要简单得多，也更简洁。当你开始一个新的项目时，你一定要检查一下DI原则并尝试一下。</p><p id="7d3f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可以在GitHub库找到本文中的代码。</p><p id="f89a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可以在<a class="ae kv" href="https://github.com/mertturkmenoglu" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae kv" href="https://www.linkedin.com/in/mert-turkmenoglu/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae kv" href="https://twitter.com/capreaee" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上找到我。</p><p id="75f7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">谢谢你的时间。祝你愉快。</p><h1 id="a678" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><ul class=""><li id="7194" class="mq mr iq lq b lr ls lu lv lx nx mb ny mf nz mj mv mw mx my bi translated"><a class="ae kv" href="https://www.tutorialsteacher.com/ioc/dependency-injection" rel="noopener ugc nofollow" target="_blank"/><a class="ae kv" href="https://www.tutorialsteacher.com/ioc/dependency-injection" rel="noopener ugc nofollow" target="_blank">【https://www.tutorialsteacher.com/ioc/dependency-injection】</a></li><li id="6e6d" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">[2]<a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Dependency_injection</a></li><li id="0837" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated"><a class="ae kv" href="https://developer.android.com/training/dependency-injection" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/training/dependency-injection</a></li><li id="ab07" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">[4]<a class="ae kv" href="https://stackoverflow.com/questions/21288/which-net-dependency-injection-frameworks-are-worth-looking-into" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/21288/which-net-dependency-injection-frameworks-was-looking-into</a></li><li id="7cfc" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">[5]<a class="ae kv" href="https://docs.typestack.community/typedi/v/develop/01-getting-started" rel="noopener ugc nofollow" target="_blank">https://docs . typestack . community/typedi/v/develop/01-入门</a></li></ul></div></div>    
</body>
</html>