<html>
<head>
<title>Generics in Go: Viva La Revolution!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的仿制药:革命万岁！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/generics-in-go-viva-la-revolution-e27898bf5495?source=collection_archive---------0-----------------------#2021-11-30">https://levelup.gitconnected.com/generics-in-go-viva-la-revolution-e27898bf5495?source=collection_archive---------0-----------------------#2021-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="bcef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个特性可以改变所有这些。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1d947e97dddb5e361ec5a12bc7104c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ShivnRbwoGquNo3"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">安特·罗泽茨基在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="05d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们选择的编程语言中，我们多久经历一次彻底的改变？有些语言更频繁地引入变化，但有些比<a class="ae le" href="https://www.wimbledon.com/" rel="noopener ugc nofollow" target="_blank">温布尔登</a>更传统。</p><p id="2031" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样的语言是过时的。有时候对我来说，它看起来太死板了。“这不是该走的路！”是我梦寐以求的一句话。大多数新的Go版本都是同一方向的改进。</p><p id="1598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一开始，我不会说我喜欢这样的道路。当没有刺激的时候，做一些事情就开始变得无聊。以至于有时候我宁愿看<em class="lf">跟上卡戴珊</em>。</p><p id="5213" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(<em class="lf">我是开玩笑的。我没有电视的原因之一是为了避免这些电视节目污染我美丽的眼睛。</em>)</p><p id="f39d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后…它<a class="ae le" href="https://go.dev/blog/12years" rel="noopener ugc nofollow" target="_blank">发生了</a>。Go团队宣布了一个消息，Go中的泛型正在成为我们的现实。它不仅仅是关于我们是否应该做和如何做的窃窃私语和无限阐述。</p><p id="ffb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">振作起来，革命就要来了。</p><div class="lg lh gp gr li lj"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">blog.ompluscator.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx ky lj"/></div></div></a></div><h1 id="2dd5" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">那么，什么是泛型呢？</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/423e125dc091b3b3ae737cf6796cb083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f8V2g9LdLEiutZYz"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">桑迪·米勒在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><blockquote class="mx my mz"><p id="67cf" class="jq jr lf js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">泛型使我们能够在定义接口、函数、结构时参数化类型。</p></blockquote><p id="b77c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仿制药<a class="ae le" href="https://en.wikipedia.org/wiki/Generic_programming" rel="noopener ugc nofollow" target="_blank">与新概念</a>相去甚远。从Ada的第一个版本，到C++中的模板，再到Java和C#中的现代实现，我们都在使用它。</p><p id="073e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了避免任何复杂的定义，让我们检查一下真实的例子——在这里，它给我们一个机会，而不是像这样的许多<code class="fe nd ne nf ng b">Max</code>或<code class="fe nd ne nf ng b">Min</code>函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="735a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只声明一个方法，就像这样:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fd14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">等等，刚刚发生了什么？我们没有为Go中的每种类型定义一个方法，而是使用了泛型——我们使用泛型类型，参数<code class="fe nd ne nf ng b">T</code>，作为方法的参数。通过这个小小的调整，我们支持所有可订购的类型。</p><p id="f246" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参数<code class="fe nd ne nf ng b">T</code>代表满足<code class="fe nd ne nf ng b">Ordered</code>约束的任何类型(稍后，我们将触及约束的主题)。所以，最初，我们需要定义<code class="fe nd ne nf ng b">T</code>是哪种类型。</p><p id="b796" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们定义在哪里使用参数化类型。这里，我们确定输入参数和输出都是<code class="fe nd ne nf ng b">T</code>类型。如果我们通过将<code class="fe nd ne nf ng b">T</code>定义为整数来执行该方法，那么这里的所有内容都是整数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3cca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而且不止于此。我们可以提供尽可能多的参数化类型。我们可以把它们分配给不同的输入和输出参数，只要我们喜欢:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="038d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们有三个参数，<code class="fe nd ne nf ng b">R</code>、<code class="fe nd ne nf ng b">S</code>和<code class="fe nd ne nf ng b">T</code>。正如我们从约束<code class="fe nd ne nf ng b">any</code>(其行为类似于<code class="fe nd ne nf ng b">interface{}</code>)中看到的，这些类型可以是任何类型。</p><p id="9714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">所以，直到现在，我们都应该清楚什么是泛型，以及在Go中如何使用泛型。让我们专注于更令人兴奋的结果。</em></p><h2 id="8388" class="nj lz it bd ma nk nl dn me nm nn dp mi kb no np mm kf nq nr mq kj ns nt mu nu bi translated">如何在本地环境中启用泛型？</h2><p id="e740" class="pw-post-body-paragraph jq jr it js b jt nv jv jw jx nw jz ka kb nx kd ke kf ny kh ki kj nz kl km kn im bi translated"><em class="lf">当这篇文章公之于众时，泛型还不是Go的任何稳定版本的一部分。因此，一些调整是必要的，这样我们可以在本地测试它们。</em></p><p id="5836" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了支持泛型的使用，我使用了Jetbrains的Goland。我在他们的网站上找到了一篇有用的文章，是关于在Goland建立一个环境来运行un代码的。</p><p id="b690" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与那篇文章唯一的不同是，我使用了带有<code class="fe nd ne nf ng b">master</code>分支的Go源代码(<a class="ae le" href="https://go.googlesource.com/go" rel="noopener ugc nofollow" target="_blank">https://go.googlesource.com/go</a>)而不是文章中的那个。</p><p id="2620" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe nd ne nf ng b">master</code>分支上，我们可以在新的包中享受来自标准围棋库的<a class="ae le" href="https://go.googlesource.com/go/+/refs/heads/master/src/constraints/constraints.go" rel="noopener ugc nofollow" target="_blank">约束</a>。</p><h1 id="614e" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">斯比德，给我我想要的。</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/a169d233b3f3c27364ecfebe397e85c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xHQoOmXm658nLlEf"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@spencerdavis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯潘塞·戴维斯</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><blockquote class="mx my mz"><p id="c8e1" class="jq jr lf js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">Go中的泛型和反射不一样。</p></blockquote><p id="bbb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在跳到一些复杂的例子之前，检查一下泛型的基准分数是很重要的。从逻辑上讲，我们不期望性能接近<a class="ae le" href="https://gist.github.com/nfisher/a9aa2d34fedb338667bf" rel="noopener ugc nofollow" target="_blank">反射</a>，因为在这种情况下，我们不需要泛型。</p><p id="7510" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，泛型无论如何都不接近反射。这也不是我的本意。如果有什么不同的话，至少在某些用例中，泛型是生成代码的一种替代方法。</p><p id="b447" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，这意味着我们的期望是，基于泛型的代码与“传统”执行的代码具有相同的基准测试结果。因此，让我们检查一个基本情况:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e6a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是将一种类型转换成另一种类型的小方法。<code class="fe nd ne nf ng b">Number</code>我们的约束是建立在来自Go标准库的<code class="fe nd ne nf ng b">Integer</code>和<code class="fe nd ne nf ng b">Float</code>约束之上的吗(同样，我们将处理这个主题)。</p><p id="ee87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf ng b">Number</code>可以是围棋中的任意数值类型:从<code class="fe nd ne nf ng b">int</code>的任意导数，到<code class="fe nd ne nf ng b">uint</code>、<code class="fe nd ne nf ng b">float</code>等等。方法<code class="fe nd ne nf ng b">Trasforms</code>期望以第一个参数化数值类型<code class="fe nd ne nf ng b">S</code>作为切片基的切片，并将其转换为以第二个参数化类型<code class="fe nd ne nf ng b">T</code>作为切片基的切片。</p><p id="2dd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，如果我们想将<code class="fe nd ne nf ng b">ints</code>的一部分转换成<code class="fe nd ne nf ng b">floats</code>的一部分，我们可以像在<code class="fe nd ne nf ng b">main</code>函数中那样调用这个方法。</p><p id="646a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们的函数来说，非泛型的替代方法应该是期望一部分整型数并返回一部分浮点型数的方法。这就是我们将在基准测试中测试的内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7ba7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有惊喜。这两种方法的执行时间实际上是一样的，所以使用泛型不会影响我们应用程序的性能。但是，对结构有什么影响吗？</p><p id="e8a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试试。现在，我们将使用结构并给它们附加方法。任务是相同的—将一个切片转换成另一个切片:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4050" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，没有惊喜。使用泛型或经典实现不会给Go代码的性能带来任何影响。是的，事实是我们没有测试太复杂的情况，但是如果有显著的差异，我们已经体验到了。</p><p id="02cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，我们可以安全地走了。</p><h1 id="688d" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">限制</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/2926a62df0eb99a792d387795850cd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AteuVH-qHevExqmj"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@amadorloureiroblanco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿玛多·洛雷罗</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><blockquote class="mx my mz"><p id="63c3" class="jq jr lf js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">如果我们想测试更复杂的例子，添加任何参数化的类型并运行应用程序是不够的。</p></blockquote><p id="56c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们决定对一些变量做一个简单的例子而不进行任何复杂的计算，那么我们就不需要添加任何特殊的东西:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="163f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了我们的方法<code class="fe nd ne nf ng b">Max</code>不计算它的输入的最大值，而是返回它们，在上面的例子中没有什么奇怪的。为此，我们使用一个参数化类型<code class="fe nd ne nf ng b">T</code>，定义为<code class="fe nd ne nf ng b">interface{}</code>。</p><p id="cfb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，我们不应该把<code class="fe nd ne nf ng b">interface{}</code>看作一个类型，而是一个约束。我们使用约束来定义参数化类型的规则，并给Go编译器一些背景知识。</p><p id="e9f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重复一下:我们在这里不使用<code class="fe nd ne nf ng b">interface{}</code>作为类型，而是作为约束。我们为参数化类型定义规则，在这种情况下，该类型必须支持<code class="fe nd ne nf ng b">interface{}</code>所做的一切。因此，实际上，我们也可以在这里使用<code class="fe nd ne nf ng b">any</code>约束。</p><p id="4b05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">(老实说，在所有的例子中，我更倾向于使用</em> <code class="fe nd ne nf ng b"><em class="lf">interface{}</em></code> <em class="lf">而不是</em> <code class="fe nd ne nf ng b"><em class="lf">any</em></code> <em class="lf">，因为我的Goland IDE不支持新的保留字(</em> <code class="fe nd ne nf ng b"><em class="lf">any</em></code> <em class="lf">，</em> <code class="fe nd ne nf ng b"><em class="lf">comparable</em></code> <em class="lf">)，然后我的IDE中出现了大量的错误消息，并破坏了自动完成功能。)</em></p><p id="b742" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在编译时，编译器可以接受一个约束，并使用它来检查参数化类型是否支持我们希望在下面的代码中执行的操作符和方法。</p><p id="ab83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于编译器在运行时进行大部分优化(因此，我们不会影响运行时，正如我们在基准测试中看到的)，它只允许为特定约束定义的操作符和函数。</p><p id="f81f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，为了了解约束的重要性，让我们完成<code class="fe nd ne nf ng b">Max</code>方法的实现，并尝试比较<code class="fe nd ne nf ng b">a</code>和<code class="fe nd ne nf ng b">b</code>变量:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b1f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们试图触发应用程序时，我们得到一个错误— <em class="lf">操作符&gt;没有在T </em>上定义。因为我们将<code class="fe nd ne nf ng b">T</code>类型定义为<code class="fe nd ne nf ng b">any</code>，所以最终类型可以是任何类型。从那时起，编译器不知道如何处理这个操作符。</p><p id="5682" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们需要将参数化类型<code class="fe nd ne nf ng b">T</code>定义为允许这种操作符的约束。感谢漂亮的围棋团队，我们已经有了包<a class="ae le" href="https://go.googlesource.com/go/+/refs/heads/master/src/constraints/constraints.go" rel="noopener ugc nofollow" target="_blank">约束</a>，有这样的约束。</p><p id="9274" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想要使用的约束的名称是<code class="fe nd ne nf ng b">Ordered</code>，经过修改后，我们的代码非常好用:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b218" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用<code class="fe nd ne nf ng b">Ordered</code>约束，我们得到了我们的结果。这个例子中的好处是我们可以看到编译器如何解释最终的类型T，这取决于我们传递给方法的值。</p><p id="f0e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不需要像前两种情况那样在方括号中定义实际类型，编译器就可以识别用于参数的类型——在Go的情况下，应该是<code class="fe nd ne nf ng b">int</code>和<code class="fe nd ne nf ng b">float64</code>。</p><p id="dd39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，如果我们想使用一些非默认类型，比如<code class="fe nd ne nf ng b">int64</code>或<code class="fe nd ne nf ng b">float32</code>，我们应该严格地将这些类型放在方括号中。然后我们给编译器确切的信息，告诉它要做什么。</p><p id="732d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果需要，我们可以扩展函数<code class="fe nd ne nf ng b">Max</code>中的功能，以支持在数组中搜索最大值:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9140" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，我们可以看到两个有趣的点:</p><ol class=""><li id="793f" class="oc od it js b jt ju jx jy kb oe kf of kj og kn oh oi oj ok bi translated">在方括号中定义了类型T之后，我们可以在函数签名中以许多不同的方式使用它:简单类型、切片类型，甚至是映射的一部分。</li><li id="ec8d" class="oc od it js b jt ol jx om kb on kf oo kj op kn oh oi oj ok bi translated">当我们想要返回一个特定类型的零值时，我们可以使用<code class="fe nd ne nf ng b">T(0)</code>。Go编译器足够聪明，可以将零值转换成所需的类型，就像第一种情况下的空字符串一样。</li></ol><p id="bdf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有机会看到比较某种类型的值是一种什么样的约束。有了<code class="fe nd ne nf ng b">Ordered</code>约束，我们可以使用在整数、浮点和字符串上定义的任何操作符。</p><p id="830b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想使用操作符<code class="fe nd ne nf ng b">==</code>，我们可以使用一个新的保留字<code class="fe nd ne nf ng b">comparable</code>，这是一个唯一的约束，只支持这样的操作符，不支持其他操作符:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6075" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，我们可以看到我们应该如何使用<code class="fe nd ne nf ng b">comparable</code>约束。同样，编译器可以识别实际类型，即使没有在方括号中严格定义它们。</p><p id="5672" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在示例中要提到的一点是，我们在两种不同的方法<code class="fe nd ne nf ng b">Equal</code>和<code class="fe nd ne nf ng b">Dummy</code>中对两种参数化类型使用了同一个字母<em class="lf"> T </em>。</p><p id="4810" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个<code class="fe nd ne nf ng b">T</code>类型只在方法的作用域(或结构及其方法)中定义，我们不谈论其作用域之外的同一个<code class="fe nd ne nf ng b">T</code>类型。我们可以用不同的方法重复同一个字母，类型仍然是相互独立的。</p><h2 id="e61b" class="nj lz it bd ma nk nl dn me nm nn dp mi kb no np mm kf nq nr mq kj ns nt mu nu bi translated">自定义约束</h2><p id="af29" class="pw-post-body-paragraph jq jr it js b jt nv jv jw jx nw jz ka kb nx kd ke kf ny kh ki kj nz kl km kn im bi translated">我们可以定义自定义约束，这非常简单。约束可以是我们想要的任何类型，但是最好的选择可能是使用接口:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e324" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义了一个接口Greeter，这样我们就可以在Greetings方法中使用它作为约束。在这里，我们可以直接使用Greeter类型的变量，而不是泛型，但这对于演示来说是可以接受的。</p><h2 id="8a1d" class="nj lz it bd ma nk nl dn me nm nn dp mi kb no np mm kf nq nr mq kj ns nt mu nu bi translated">类型集</h2><blockquote class="mx my mz"><p id="51d9" class="jq jr lf js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">每种类型都有一个关联的类型集。一个普通的非接口类型<code class="fe nd ne nf ng b">T</code>的类型集合就是只包含<code class="fe nd ne nf ng b">T</code>本身的集合<code class="fe nd ne nf ng b">{T}</code>。接口类型的类型集(在这一节我们只讨论普通的接口类型，没有类型列表)是声明接口所有方法的所有类型的集合。</p></blockquote><p id="f4bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述定义来自<a class="ae le" href="https://github.com/golang/go/issues/45346" rel="noopener ugc nofollow" target="_blank">类型组</a>的建议。它已经存在于Go源代码中，所以我们可以在任何我们喜欢的地方使用它。</p><p id="c60d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个显著的变化为我们带来了新的可能性:我们的接口类型也可以嵌入基本类型，像<code class="fe nd ne nf ng b">int</code>、<code class="fe nd ne nf ng b">float64</code>、<code class="fe nd ne nf ng b">byte</code>而不仅仅是其他接口。这个特性使我们能够定义更灵活的约束。</p><p id="8b25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看下面的例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2308" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义了我们的<code class="fe nd ne nf ng b">Comparable</code>约束。那种类型看起来有点奇怪，对吗？</p><p id="087a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go中使用类型集的新方法允许我们定义一个应该是类型联合的接口。为了描述两个类型之间的联合，我们应该将它们放在接口中，并在它们之间放置一个操作符<code class="fe nd ne nf ng b">|</code>。</p><p id="5662" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，在我们的例子中，可比接口是类型的并集:<code class="fe nd ne nf ng b">rune</code>、<code class="fe nd ne nf ng b">float64</code>和……我猜是<code class="fe nd ne nf ng b">int</code>？是的，它的确是<code class="fe nd ne nf ng b">int</code>，但是这里定义为<em class="lf">近似元素</em>。</p><p id="99f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在类型集的建议中看到的，近似元素<code class="fe nd ne nf ng b">T</code>的类型集是类型<code class="fe nd ne nf ng b">T</code>的类型集，以及所有底层类型为<code class="fe nd ne nf ng b">T.</code>的类型</p><p id="5032" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，仅仅因为我们使用了<code class="fe nd ne nf ng b">~int</code>近似元素，我们就可以向比较方法提供我们的<code class="fe nd ne nf ng b">customInt</code>类型的变量。如您所见，我们将<code class="fe nd ne nf ng b">customInt</code>定义为自定义类型，其中<code class="fe nd ne nf ng b">int</code>是底层类型。</p><p id="10fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们不添加一个操作符<code class="fe nd ne nf ng b">~</code>，编译器会抱怨，不执行应用程序。</p><p id="75c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">所以，这就开始严重了。</em></p><h1 id="b4ca" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">我们能走多远？</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/ece7726689111abed4e64c7d6e00f30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D153T77x8guSSomP"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@yucar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> YUCAR FotoGrafik </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="mx my mz"><p id="fc4c" class="jq jr lf js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">我们想去哪就去哪。</p></blockquote><p id="b3e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说真的，这个特性彻底改变了语言。我是说，很多新代码<a class="ae le" href="https://github.com/golang/go/issues/45955" rel="noopener ugc nofollow" target="_blank">不断出现</a>。这可能会对依赖代码生成的包产生重大影响，比如<a class="ae le" href="https://entgo.io/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> Ent </a>。</p><p id="0629" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从标准库开始，我已经可以看到许多代码在未来版本中被重构以使用泛型。泛型甚至可能导致一些ORM的发展，我们过去在理论中看到的，例如<a class="ae le" href="https://www.doctrine-project.org/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="dd4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，让我们考虑一个来自<a class="ae le" href="https://gorm.io/index.html" rel="noopener ugc nofollow" target="_blank"> Gorm </a>包的模型:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ac18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想在Go中为两个模型(<code class="fe nd ne nf ng b">ProductGorm</code>和<code class="fe nd ne nf ng b">UserGorm</code>)实现<a class="ae le" href="https://deviq.com/design-patterns/repository-pattern" rel="noopener ugc nofollow" target="_blank">存储库</a>模式。对于目前稳定版的Go，我们只能做以下一种解决方案:</p><ol class=""><li id="4aa7" class="oc od it js b jt ju jx jy kb oe kf of kj og kn oh oi oj ok bi translated">编写两个独立的存储库结构</li><li id="2160" class="oc od it js b jt ol jx om kb on kf oo kj op kn oh oi oj ok bi translated">编写应该使用模板来创建这两个存储库结构的代码生成器</li><li id="1faa" class="oc od it js b jt ol jx om kb on kf oo kj op kn oh oi oj ok bi translated">决定不使用存储库</li></ol><p id="828b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，有了泛型，horizon with opportunities转向了更灵活的方法，我们可以这样做:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="433d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，我们有我们的<code class="fe nd ne nf ng b">Repository</code>结构，带有参数化类型<code class="fe nd ne nf ng b">T</code>，可以是任何东西。注意，我们只在<code class="fe nd ne nf ng b">Repository</code>类型定义中定义了<code class="fe nd ne nf ng b">T</code>，并且我们只是传递了它的指定函数。</p><p id="ecb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们只能看到两种方法，<code class="fe nd ne nf ng b">Create</code>和<code class="fe nd ne nf ng b">Get</code>，只是为了演示。为了便于演示，让我们创建两个独立的方法来初始化不同的<code class="fe nd ne nf ng b">Repositories</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e410" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两个方法返回预定义类型的存储库实例，就像快捷方式一样。让我们对我们的小应用程序进行最后的测试:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f460" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，这很有效。一个存储库实现，支持两种模型。零反射，零代码生成。我以为在围棋里再也看不到这样的东西了。</p><p id="449e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">我好开心。我想我会哭。</em></p><h1 id="0fc2" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">结论</h1><p id="af60" class="pw-post-body-paragraph jq jr it js b jt nv jv jw jx nw jz ka kb nx kd ke kf ny kh ki kj nz kl km kn im bi translated">毫无疑问，泛型在Go中是一个巨大的变化。能够迅速改变Go使用方式的变化，以及能够在短期内在Go社区中引起许多重构的变化。</p><p id="f47b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然我几乎每天都在玩泛型，试图看看我们可以期待更多的东西，但我已经迫不及待地想在稳定的Go版本中看到它们了。革命万岁！</p></div></div>    
</body>
</html>