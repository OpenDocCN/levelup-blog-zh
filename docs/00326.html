<html>
<head>
<title>A journey through ReactDOM.render — An explanation of how React manages the DOM and state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactDOM.render之旅React如何管理DOM和状态的解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-journey-through-reactdom-render-e8fc5edc11fd?source=collection_archive---------1-----------------------#2019-01-09">https://levelup.gitconnected.com/a-journey-through-reactdom-render-e8fc5edc11fd?source=collection_archive---------1-----------------------#2019-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="14dd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中使用的纤程架构的概述，以及如何使用它来管理DOM</h2></div><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="31bf" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">ReactDOM是一个对象，它公开了许多顶级API来与浏览器DOM进行交互。根据文档，它提供了“<em class="li">特定于DOM的方法，可以在应用程序的顶层使用，如果需要的话，可以作为脱离React模型的出口。其中一种方法是<code class="fe lj lk ll lm b">render()</code>。</em></p><h1 id="2547" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">一些背景说明</h1><p id="55c4" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">在继续之前，有必要对React的内部工作方式有一个总体的了解。在React 15中，更新是以同步方式完成的。这造成了更新运行速度低于计算所需的16ms(每秒1000毫秒/ 60帧)的风险，导致janky UIs。React 16引入了fiber，这是React的协调算法的重写，允许异步调度更新并区分优先级。这是通过重新实现浏览器的内置调用堆栈来实现的。这样做可以中断调用堆栈，并以一种专门为React组件定制的方式手动操作堆栈框架。</p><p id="9d38" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">重写的核心是一个叫做<strong class="ko ir">纤程</strong>的数据结构，它是一个可变的对象，包含组件状态和DOM表示。它也可以被认为是一个虚拟堆栈框架。Fiber的架构分为两个阶段:<strong class="ko ir">协调/渲染</strong>和<strong class="ko ir">提交</strong>。在这篇文章的过程中，我们将触及它的一些方面，但更广泛的解释可以在这里找到:</p><ul class=""><li id="f286" class="mk ml iq ko b kp kq ks kt kv mm kz mn ld mo lh mp mq mr ms bi translated"><a class="ae mt" href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e" rel="noopener">React中对账的深入概述</a></li><li id="7e39" class="mk ml iq ko b kp mu ks mv kv mw kz mx ld my lh mp mq mr ms bi translated"><a class="ae mt" href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" rel="noopener">React如何以及为什么使用链表来更新组件</a></li><li id="64a8" class="mk ml iq ko b kp mu ks mv kv mw kz mx ld my lh mp mq mr ms bi translated"><a class="ae mt" href="https://github.com/acdlite/react-fiber-architecture" rel="noopener ugc nofollow" target="_blank">React光纤架构说明</a></li><li id="e203" class="mk ml iq ko b kp mu ks mv kv mw kz mx ld my lh mp mq mr ms bi translated"><a class="ae mt" href="https://www.youtube.com/watch?v=ZCuYPiUIONs" rel="noopener ugc nofollow" target="_blank"> Mozilla员工工程师林克拉克关于React Fiber的演讲</a></li><li id="27c7" class="mk ml iq ko b kp mu ks mv kv mw kz mx ld my lh mp mq mr ms bi translated"><a class="ae mt" href="https://github.com/facebook/react/issues/7942#issue-182373497" rel="noopener ugc nofollow" target="_blank"> React核心成员Sebastian Markbage对React Fiber背后原理的解释</a></li></ul><h1 id="1dee" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">旅程开始了</h1><p id="59eb" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated"><code class="fe lj lk ll lm b">ReactDOM.render()</code>实际上包装了另一个函数，并用两个额外的参数调用它，所以它的声明很简单。下面是包装的函数:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="5b44" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">React做的第一件事是为我们的应用程序创建<strong class="ko ir">纤程树</strong>。否则，它无法处理任何用户更新或事件。该树是通过调用<code class="fe lj lk ll lm b">legacyCreateRootFromDOMContainer</code>创建的，它返回以下对象:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="c2ca" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这被称为<strong class="ko ir">纤维根对象</strong>。每个React应用程序都有一个或多个充当容器的DOM元素，并且为每个容器创建一个对象。在这个对象上，我们通过<code class="fe lj lk ll lm b">current</code>属性找到了对纤程树的引用，它的值是:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="0ae6" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这是一个<strong class="ko ir">纤程节点</strong>，它位于每个React纤程树的根处(<a class="ae mt" href="https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiber.js#L85" rel="noopener ugc nofollow" target="_blank">这个</a>是创建这个对象的函数)。这个节点实际上是一种特殊类型的纤程节点，称为<code class="fe lj lk ll lm b">HostRoot</code>节点，它充当我们应用程序中最上层组件的父节点。我们知道它是一个<code class="fe lj lk ll lm b">HostRoot</code>节点，因为它的<code class="fe lj lk ll lm b">tag</code>属性的值是<strong class="ko ir"> 3 </strong>(你可以在这里找到纤程节点类型<a class="ae mt" href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/shared/ReactWorkTags.js#L34" rel="noopener ugc nofollow" target="_blank">的完整列表)。注意在这个阶段，很多属性，尤其是<code class="fe lj lk ll lm b">child</code>，都是<code class="fe lj lk ll lm b">null</code>。我们稍后将回到这一点。</a></p><p id="f5e0" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">创建树之后，React检查我们是否提供了回调作为render调用的第三个参数。如果是这样的话，它获取对我们应用程序的根组件实例的引用(在我们的例子中，它是<code class="fe lj lk ll lm b">&lt;h1&gt;</code>元素),然后确保我们的回调将在稍后在这个实例上被调用。</p><h1 id="6fc8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">深入其中</h1><p id="e9b4" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">在此之前发生的所有事情都是为将我们的应用程序呈现在屏幕上的工作做准备。到目前为止，我们有一个树，但它不像我们的用户界面。以下代码解决了这个问题:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="b21b" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe lj lk ll lm b">Root</code>是一个只有一个属性的对象(属性<code class="fe lj lk ll lm b">_internalRoot</code>保存了对根<strong class="ko ir"> </strong>纤程对象的引用)。它是通过调用<code class="fe lj lk ll lm b"><a class="ae mt" href="https://github.com/facebook/react/blob/v16.7.0/packages/react-dom/src/client/ReactDOM.js#L364" rel="noopener ugc nofollow" target="_blank">ReactRoot</a></code>函数上的<code class="fe lj lk ll lm b">new</code>创建的，所以如果你查看它的内部<code class="fe lj lk ll lm b">[[Prototype]]</code>链，你会发现下面的方法:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="05f0" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">还记得我们前面的<code class="fe lj lk ll lm b">HostRoot</code>纤程节点和所有的<code class="fe lj lk ll lm b">null</code>值吗？在上面的函数中，我们可以通过<code class="fe lj lk ll lm b">root.current</code>来访问它。<code class="fe lj lk ll lm b">updateContainer()</code>完成工作后，它看起来是这样的:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="4ff7" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">并且<code class="fe lj lk ll lm b">child</code>属性中的值现在是<code class="fe lj lk ll lm b">&lt;h1&gt; </code>元素的纤程节点:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="86b1" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如您所见，纤维树现在反映了我们想要呈现的UI。那是怎么发生的？下面是为了让我们达到这一阶段而采取的步骤的总结:</p><h2 id="a81f" class="mz lo iq bd lp na nb dn lt nc nd dp lx kv ne nf lz kz ng nh mb ld ni nj md nk bi translated">计划更新</h2><p id="d236" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">React有一个内部的<a class="ae mt" href="https://github.com/facebook/react/tree/v16.7.0/packages/scheduler" rel="noopener ugc nofollow" target="_blank">调度器</a>，用于在浏览器环境中处理<a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API" rel="noopener ugc nofollow" target="_blank">协作调度</a>。这个包包括一个用于<code class="fe lj lk ll lm b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback" rel="noopener ugc nofollow" target="_blank">window.requestIdleCallback</a></code>的<a class="ae mt" href="https://github.com/facebook/react/blob/v16.7.0/packages/scheduler/src/Scheduler.js#L415" rel="noopener ugc nofollow" target="_blank"> polyfill </a>，它是React如何协调UI更新的核心。在此过程中，每个纤程节点都有一个<strong class="ko ir">到期时间</strong>。这是一个值，表示正在进行的<strong class="ko ir">工作</strong>(对帐期间发生的所有活动的名称)将在未来某个时间完成。</p><p id="8dd8" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种计算包括检查是否有优先级更高的未决工作以及当前正在进行的工作的性质。在我们的例子中，它是同步更新，但在其他场景中，它可以是交互式的或异步的。低优先级更新的例子包括网络响应或点击按钮改变颜色。高优先级更新包括用户输入和动画。</p><h2 id="1d9b" class="mz lo iq bd lp na nb dn lt nc nd dp lx kv ne nf lz kz ng nh mb ld ni nj md nk bi translated">创建更新队列</h2><p id="a3a7" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">在我们的例子中，我们只有一个纤程树，因为它没有更新队列，所以必须创建一个并分配给<code class="fe lj lk ll lm b">updateQueue</code>属性。这个队列是用<code class="fe lj lk ll lm b"><a class="ae mt" href="https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactUpdateQueue.js#L152" rel="noopener ugc nofollow" target="_blank">createUpdateQueue</a></code> <a class="ae mt" href="https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactUpdateQueue.js#L152" rel="noopener ugc nofollow" target="_blank"> </a>函数创建的，它将纤程节点的<strong class="ko ir"> memoizedState </strong>作为其参数。记忆状态是指用于创建节点输出的状态。队列是一个优先更新的链表，像纤程树一样，它也是成对出现的。<strong class="ko ir">当前</strong>队列代表UI的可见状态。</p><h2 id="199c" class="mz lo iq bd lp na nb dn lt nc nd dp lx kv ne nf lz kz ng nh mb ld ni nj md nk bi translated">创建工作进展树并对其进行处理</h2><p id="c98b" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">当工作被实际执行时，React检查它的内部堆栈，以确定它是从一个新的堆栈开始还是继续以前产生的工作。在这个检查之后不久，它使用一种被称为<a class="ae mt" href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics" rel="noopener ugc nofollow" target="_blank">双缓冲</a>的技术来<a class="ae mt" href="https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiber.js#L346" rel="noopener ugc nofollow" target="_blank">创建</a>工作进程<strong class="ko ir">树。React使用两个纤程树——一个名为<strong class="ko ir"> current </strong>的纤程树保存UI的当前状态，另一个名为<strong class="ko ir"> workInProgress </strong>的纤程树反映未来状态。当前<strong class="ko ir">树中的每个节点在<strong class="ko ir">工作进程</strong>树中都有一个对应的节点，该节点是在渲染过程中根据数据创建的。</strong></strong></p><p id="a0e3" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">一旦<strong class="ko ir"> workInProgress </strong>被渲染到屏幕上，它就成为新的<strong class="ko ir">当前树</strong>。workInProgress树也有一个更新队列，但是它可以在渲染之前被变异和异步处理。</p><h2 id="fae0" class="mz lo iq bd lp na nb dn lt nc nd dp lx kv ne nf lz kz ng nh mb ld ni nj md nk bi translated">DOM元素创建</h2><p id="631b" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated"><code class="fe lj lk ll lm b">&lt;h1&gt;</code>元素的<strong class="ko ir">纤程节点</strong>是在<strong class="ko ir"> workInProgress </strong>树上工作期间创建的。几个调用之后，<a class="ae mt" href="https://github.com/facebook/react/blob/c954efa70f44a44be9c33c60c57f87bea6f40a10/packages/react-dom/src/client/ReactDOMComponent.js#L374" rel="noopener ugc nofollow" target="_blank">这个</a>函数使用DOM API来创建我们的<code class="fe lj lk ll lm b">&lt;h1&gt;</code>元素，到目前为止它一直是一个React element对象。当应用程序呈现后，您可以通过键入<code class="fe lj lk ll lm b">document.querySelector('h1')</code>来访问元素。如果你检查它的属性，你会发现一个以<code class="fe lj lk ll lm b">__reactInternalInstance$</code>开头的。该属性保存对元素纤程节点的引用。React】也给分配元素的文本内容，然后<a class="ae mt" href="https://github.com/facebook/react/blob/c954efa70f44a44be9c33c60c57f87bea6f40a10/packages/react-dom/src/client/ReactDOMHostConfig.js#L361" rel="noopener ugc nofollow" target="_blank">将它附加到我们的根DOM元素中。在追加之前，React已经进入了提交阶段。</a></p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/6853f78351839d706d56cd49bba6366e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7c0TpJmlhZES7ltPtMwZaQ.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">通过查看该属性的值，可以查看在React中创建的任何HTML元素的纤程节点</figcaption></figure><h1 id="8f60" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">这就是它的全部</h1><p id="1923" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">在我们的例子中，我们已经呈现了最基本的ui，但是React已经做了大量的工作来准备和显示它。像大多数为构建复杂应用程序而创建的框架一样，它做这项工作是为了应对与此任务相关的所有可能发生的情况。由于示例应用程序是静态的，所以我们没有涉及到状态更新、生命周期挂钩以及其他方面的任何代码。</p><p id="3f79" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">由于这是我第一次深入研究React，我确信我遗漏了一些东西或者错误地解释了其他人，所以请在下面留下您的反馈！</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><div class="kf kg kh ki gt od"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">React是一个现代JavaScript库，前端web开发人员使用它来构建用户界面(UI)。它用于…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">gitconnected.com</p></div></div><div class="om l"><div class="on l oo op oq om or nq od"/></div></div></a></div></div></div>    
</body>
</html>