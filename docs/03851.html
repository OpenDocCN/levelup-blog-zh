<html>
<head>
<title>Stack in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stack-in-c-50b1a19d4c98?source=collection_archive---------16-----------------------#2020-05-29">https://levelup.gitconnected.com/stack-in-c-50b1a19d4c98?source=collection_archive---------16-----------------------#2020-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84ad4f1f1f1fcb033188c52bebe106d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JzghhrMKthHY0-59"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="29ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">欢迎读者，在这个博客中，我们将学习堆栈的基础知识和它们的编码实现。还将简要介绍内置函数和方法。因此，让我们立即开始我们关于堆栈的学习之旅。</p><h1 id="2d9c" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">什么是堆栈？</h1><p id="37ef" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">堆栈是一种线性数据结构，具有以连续方式存储的数据元素。它遵循<strong class="kf ir"> LIFO顺序，即后进先出顺序</strong>，其中插入到末尾的元素首先弹出。只能从顶部推动或弹出一个元素。如果你把它和一摞书比较一下，你会对stack有更好的理解。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/218f0a9bd7b1f5c6620b74ec38220f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lSu1IlCejX_AEkSP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kaimantha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Claudia Wolff </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="04a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看一下上面的图片，放在书库最后的书在书库的最上面，可以很容易地从书库中取出来。另一方面，放在书架第一位的书在底部，是最后一个弹出的。</p><p id="a447" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个非常简单的数据结构，但有很好的应用，有些事情只能用栈来完成。</p><h1 id="959b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">堆栈的应用</h1><ul class=""><li id="0b78" class="ms mt iq kf b kg mi kk mj ko mu ks mv kw mw la mx my mz na bi translated">符号的平衡。</li><li id="6f23" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">中缀到后缀/前缀的转换。</li><li id="72e1" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">重做-撤销许多地方的功能。</li><li id="a9db" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">web浏览器中的向前和向后功能。</li><li id="621d" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">用于算法，如汉诺塔，树遍历，股票跨度问题，直方图问题。</li><li id="f371" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">在像拓扑排序和强连通分支这样的图形算法中。</li></ul><h1 id="112f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">流动</h1><p id="055b" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在继续讨论堆栈的实现之前，我们将首先讨论在执行堆栈操作时最常出现的两个词，它们是:</p><h2 id="0248" class="ng ll iq bd lm nh ni dn lq nj nk dp lu ko nl nm ly ks nn no mc kw np nq mg nr bi translated">下溢</h2><p id="ddea" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在下溢情况下，堆栈的所有元素都被移除，即堆栈中没有元素，堆栈为空。如果有人试图从这个空堆栈中再移除一个元素，这种情况称为下溢。</p><h2 id="0a22" class="ng ll iq bd lm nh ni dn lq nj nk dp lu ko nl nm ly ks nn no mc kw np nq mg nr bi translated">泛滥</h2><p id="4ef8" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">溢出情况发生在固定大小的堆栈中。在这种情况下，堆栈变满，即所有空间都被占用，如果在堆栈中再插入一个元素，则无法完成，堆栈将因数据超过其容量而溢出。</p><h1 id="8089" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">建筑堆栈</h1><p id="3521" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在我们来看看堆栈是如何构成的。我将使用一个类而不是结构，我将使用一个向量来实现一个堆栈，因为它使我们的工作容易得多，如果你曾经尝试过使用简单的数组来实现堆栈，你就会看到这一点。如果不是，只要看看代码，你就会明白你自己。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a962b94d32eaede9f219c4920831a11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/0*L17ufGQ00AZQwxDN.jpg"/></div></figure><pre class="mo mp mq mr gt nt nu nv nw aw nx bi"><span id="99e2" class="ng ll iq nu b gy ny nz l oa ob">class stack{<br/>	private:<br/>	vector&lt;int&gt; v;<br/><br/>	public:<br/>	void push(int data){<br/>		v.push_back(data);<br/>	}<br/><br/>	bool isEmpty(){<br/>		return v.size() == 0;<br/>	}<br/><br/>	int top(){<br/>		return v[v.size()-1];<br/>	}<br/>	void pop(){<br/>		if(!isEmpty()){<br/>			v.pop_back();<br/>		}<br/>	}<br/>};</span></pre><p id="c650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用了一个vector v，并声明它是私有的，这样就没有人可以直接访问它。我们已经制定了使用访问堆栈的方法。有四种基本的堆栈操作。</p><h2 id="25f1" class="ng ll iq bd lm nh ni dn lq nj nk dp lu ko nl nm ly ks nn no mc kw np nq mg nr bi translated">推送()</h2><p id="a567" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">推入操作用于在堆栈顶部插入。我们已经使用vector的push_back方法在stack vector的末尾添加了一个新元素，显然这是我们栈的顶部。现在你可以看到使用vector，我们的工作变得简单多了。</p><h2 id="63dd" class="ng ll iq bd lm nh ni dn lq nj nk dp lu ko nl nm ly ks nn no mc kw np nq mg nr bi translated">流行()</h2><p id="cd6d" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">弹出操作用于弹出堆栈的最顶层元素。我们使用了vector的pop_back方法来实现。要弹出，我们首先检查堆栈是否为空，如果不为空，则元素可以弹出，否则满足<strong class="kf ir">下溢</strong>条件。</p><h2 id="36d6" class="ng ll iq bd lm nh ni dn lq nj nk dp lu ko nl nm ly ks nn no mc kw np nq mg nr bi translated">顶部()</h2><p id="ed64" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">Top是指栈顶的元素。此方法用于获取位于堆栈顶部的元素。在一个数组实现中，我们必须更新top的值，当调用这个方法时，返回索引top处的元素，但是在我们的例子中，返回vector的最后一个元素将完成我们的工作，我们不需要保留top变量或更新它。这里使用向量有一个明显的优势。</p><h2 id="fc88" class="ng ll iq bd lm nh ni dn lq nj nk dp lu ko nl nm ly ks nn no mc kw np nq mg nr bi translated">isEmpty()</h2><p id="784c" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在这个方法中，我们检查堆栈是否为空，并在弹出操作中使用它来避免“下溢”情况。无论向量的大小是否为零，它都返回一个bool结果。</p><p id="4c89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个方法，<strong class="kf ir"> IsFull()。</strong>它与数组一起使用，检查堆栈是否已满，但对于vector，我们没有预定义任何大小，因此没有大小上限，如10或10000。这就是我们在实现中没有使用它的原因。</p><h1 id="86d5" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">另一个实现</h1><p id="f105" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">还有另一个使用链表的实现。栈顶由head表示，所有的插入将是insertion_at_head，删除也将从头开始，如果下一个节点指向NULL，将满足下溢条件，并且将不存在isFull条件。</p><p id="d484" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议你自己尝试用链表实现stack。理解这些概念会对你有很大帮助，而且非常简单，我已经给了你一些足够多的提示。</p><h1 id="621f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">堆栈STL</h1><p id="108a" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这些库有非常高效的代码，具有更好的空间和时间复杂度。要使用stack STL，你需要包含stack头，然后你可以声明任何你想要的数据类型的stack。</p><pre class="mo mp mq mr gt nt nu nv nw aw nx bi"><span id="f04a" class="ng ll iq nu b gy ny nz l oa ob">#include&lt;stack&gt;  // To include stack library<br/>stack&lt;int&gt; s; // stack of integers.</span></pre><p id="ee8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可以直接使用stack的所有方法，而不需要事先编码。基本方法是:</p><p id="181d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">按下</strong> →在堆栈顶部插入元素。</p><p id="2466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">弹出</strong> →移除栈顶元素。</p><p id="f910" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> top → </strong> Top方法用于访问栈顶元素。</p><p id="ed54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">清空→ </strong>检查底层容器是否为空</p><pre class="mo mp mq mr gt nt nu nv nw aw nx bi"><span id="07cc" class="ng ll iq nu b gy ny nz l oa ob">#include &lt;iostream&gt;       <br/>#include &lt;stack&gt;          </span><span id="c6bb" class="ng ll iq nu b gy oc nz l oa ob">using namespace std;<br/>int main (){<br/>  stack&lt;int&gt; m;</span><span id="a00d" class="ng ll iq nu b gy oc nz l oa ob">  for (int i=0; i&lt;5; ++i) <br/>       m.push(i);           <strong class="nu ir">//Using Push operation to insert element</strong></span><span id="48d9" class="ng ll iq nu b gy oc nz l oa ob">  cout &lt;&lt; "Element at top is " &lt;&lt; m.top() &lt;&lt; endl;</span><span id="2443" class="ng ll iq nu b gy oc nz l oa ob">  cout &lt;&lt; "Popping out elements...";<br/>  while (!m.empty()){       <strong class="nu ir">//using empty method </strong></span><span id="2cbd" class="ng ll iq nu b gy oc nz l oa ob">     cout &lt;&lt;' '&lt;&lt; mystack.top();<strong class="nu ir">//top to see the element at top</strong><br/>     m.pop();               <strong class="nu ir">//Using pop to pop out elements</strong><br/>  }</span><span id="aced" class="ng ll iq nu b gy oc nz l oa ob">  return 0;<br/>}</span><span id="e819" class="ng ll iq nu b gy oc nz l oa ob"><strong class="nu ir">Output:</strong></span><span id="dd80" class="ng ll iq nu b gy oc nz l oa ob">Element at top is 15<br/>Popping out elements... 4 3 2 1 0</span></pre><p id="4269" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> size → </strong>返回堆栈中元素的数量。</p><pre class="mo mp mq mr gt nt nu nv nw aw nx bi"><span id="09b2" class="ng ll iq nu b gy ny nz l oa ob">#include &lt;iostream&gt;       <br/>#include &lt;stack&gt;          <br/><br/>using namespace std;<br/>int main (){</span><span id="45e1" class="ng ll iq nu b gy oc nz l oa ob">  stack&lt;int&gt; m;<br/>  cout &lt;&lt; "size: " &lt;&lt; m.size() &lt;&lt; endl;<br/><br/>  for (int i=0; i&lt;5; i++) <br/>       m.push(i);<br/>  cout &lt;&lt; "size: " &lt;&lt; m.size() &lt;&lt; endl;<br/><br/>  return 0;<br/>}</span><span id="8f1c" class="ng ll iq nu b gy oc nz l oa ob"><strong class="nu ir">Output:</strong></span><span id="5a47" class="ng ll iq nu b gy oc nz l oa ob">size: 0<br/>size: 5<br/></span></pre><p id="1959" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">放置</strong> →在栈顶就地构造元素。</p><pre class="mo mp mq mr gt nt nu nv nw aw nx bi"><span id="10a8" class="ng ll iq nu b gy ny nz l oa ob">#include &lt;iostream&gt;      <br/>#include &lt;stack&gt;          <br/>#include &lt;string&gt;  </span><span id="5f1e" class="ng ll iq nu b gy oc nz l oa ob">using namespace std;     <br/>int main (){</span><span id="ebfc" class="ng ll iq nu b gy oc nz l oa ob">  stack&lt;string&gt; m;<br/><br/>  m.emplace ("First sentence");<br/>  m.emplace ("Second sentence");<br/><br/>  cout &lt;&lt; "m contains: "&lt;&lt;endl;<br/>  while (!m.empty()){<br/>    cout &lt;&lt; m.top() &lt;&lt; endl;<br/>    m.pop();<br/>  }<br/><br/>  return 0;<br/>}</span><span id="6449" class="ng ll iq nu b gy oc nz l oa ob"><strong class="nu ir">Output</strong>:</span><span id="ea74" class="ng ll iq nu b gy oc nz l oa ob">mystack contains:<br/>Second sentence<br/>First sentence</span></pre><p id="bea5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">交换</strong> →交换堆栈的内容。</p><pre class="mo mp mq mr gt nt nu nv nw aw nx bi"><span id="a279" class="ng ll iq nu b gy ny nz l oa ob">#include &lt;iostream&gt;  <br/>#include &lt;stack&gt;       </span><span id="85ad" class="ng ll iq nu b gy oc nz l oa ob">using namespace std;<br/>int main (){</span><span id="aaa1" class="ng ll iq nu b gy oc nz l oa ob">stack&lt;int&gt; stack1, stack2;<br/>  stack1.push(10); <br/>  stack1.push(20); <br/>  stack1.push(30);<br/>  <br/>  stack2.push(40); <br/>  stack2.push(50);<br/><br/>  stack1.swap(stack2);<br/><br/>  cout &lt;&lt; "Elements of stack1: " &lt;&lt; endl;<br/>  while (!stack1.empty()){<br/>    cout &lt;&lt; stack1.top() &lt;&lt; endl;<br/>    stack1.pop();<br/>  }</span><span id="be2d" class="ng ll iq nu b gy oc nz l oa ob">cout &lt;&lt; "Elements of stack2: " &lt;&lt; endl;<br/>  while (!stack2.empty()){<br/>    cout &lt;&lt; stack2.top() &lt;&lt; endl;<br/>    stack2.pop();<br/>  } </span><span id="cbed" class="ng ll iq nu b gy oc nz l oa ob">  return 0;<br/>}</span><span id="5d3f" class="ng ll iq nu b gy oc nz l oa ob"><strong class="nu ir">Output:<br/></strong>Elements of <!-- -->stack<!-- -->1: <br/>50<br/>40<br/>Elements of <!-- -->stack<!-- -->2: <br/>30<br/>20<br/>10<br/></span></pre><p id="634d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以自己看看STL让我们的工作变得有多简单，正如我之前告诉你的，这些是非常有效的。</p><h1 id="acc6" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结束了</h1><p id="cd45" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们已经看到了堆栈的基础知识，它的内置方法，以及在C++中的实现。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/1a76ac6556e1e5df5cf23078ffd92111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JUIC6U2DumRlbLmx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Adi Goldstein 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4a53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你已经理解了所讨论的内容，如果你喜欢这篇文章，请留下你的掌声。<br/>继续编码，快乐编程:——)</p></div></div>    
</body>
</html>