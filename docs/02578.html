<html>
<head>
<title>Confusing Terms in the Git Terminology</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git术语中令人困惑的术语</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/confusing-terms-in-the-git-terminology-c7115d6febc7?source=collection_archive---------10-----------------------#2020-03-23">https://levelup.gitconnected.com/confusing-terms-in-the-git-terminology-c7115d6febc7?source=collection_archive---------10-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="809e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Git </strong>和<a class="ae ko" href="http://github.com/" rel="noopener ugc nofollow" target="_blank">T3】GitHubT5】是当今编程界开源的核心。然而，有许多令人困惑的术语看起来很相似，但却有着相互冲突的含义和用法。让我们通过解读这些令人困惑的术语的潜在含义来揭开它们的神秘面纱。</a></p><p id="f8b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注</strong> : <em class="kp">本文期望对Git和GitHub有所了解。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/7103e76d7d8fb43443428603566cb985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZIrFsOM49UJ7dlmATwkzIg.gif"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://cdn.dribbble.com/" rel="noopener ugc nofollow" target="_blank">https://dribbble.com/</a></figcaption></figure></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="3b78" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">起点和上游</strong></h1><p id="7d6e" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">来自<a class="ae ko" href="https://git-scm.com/doc" rel="noopener ugc nofollow" target="_blank"> Git文档</a>:</p><blockquote class="mq mr ms"><p id="0cb1" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">当您派生一个repo并在本地克隆它时，会有一个名为origin的默认遥控器指向您在GitHub上的派生，而不是派生它的原始repo。</p><p id="866a" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">为了跟踪原始回购，您需要添加另一个名为upstream的远程</p></blockquote><p id="3a88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你在克隆一个分叉的回购协议时，就会产生这种困惑。<strong class="js iu">上游</strong>是您将用来<strong class="js iu">从原始回购</strong>中获取的内容，以保持您的本地副本与您想要参与的项目同步。同时，<strong class="js iu"> Origin </strong>是您将用来<strong class="js iu">拉和推代码到您的fork </strong>的地方，然后您可以通过发出拉请求向上游回购做出贡献。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi mw"><img src="../Images/b048ca7a67e4947cd98af10929cf3b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VsgQel00bwqhvKN8qHNCA.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">资料来源:https://github.com/sf-wdi-21/notes</figcaption></figure><ul class=""><li id="bf5d" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated"><strong class="js iu">*记住** </strong>:像“upstream”和“origin”这样的远程只是存储存储库URL的别名。它们可以被命名为任何名称，但是将原始回购的远程设置为上游是一个惯例。</li></ul></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="9264" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">取和拉</strong></h1><p id="d379" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">来自<a class="ae ko" href="https://git-scm.com/doc" rel="noopener ugc nofollow" target="_blank"> Git文档</a>:</p><blockquote class="mq mr ms"><p id="6fa6" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">git fetch可以从单个命名的存储库或URL获取，也可以同时从几个存储库获取。</p><p id="f8d5" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">git pull将远程存储库中的更改合并到当前分支中。</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4af6b6585caef49ffa118002f304bba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*b50bU2iCz4fCf3ZuOn-yfw.jpeg"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://educba.com/" rel="noopener ugc nofollow" target="_blank">https://educba.com/</a></figcaption></figure><p id="da47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> git fetch </strong>命令告诉您的本地git从原始文件中检索最新的元数据信息，但不进行任何文件传输。这更像是检查是否有任何可用的更改。<strong class="js iu"> git pull </strong>，另一方面，<strong class="js iu"> git fetch </strong>和<strong class="js iu">将变更从远程库应用到本地库</strong>。</p><p id="5201" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">* *记住** </strong> : git pull是git fetch后跟git merge FETCH_HEAD的简写。</p><p id="45f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单地说，<strong class="js iu"> git fetch </strong>可用于了解自上次拉操作以来远程回购/分支中发生的变化。这有助于在执行<strong class="js iu"> git pull </strong>之前进行检查，这可能会更改您当前分支和工作副本中的文件，并可能丢失您的更改，等等。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ba622dca78530b8b1563ac24c8c30477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*lIGZ2jFMwVcp0-q12Ba2FA.png"/></div></figure><p id="054c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">git fetch 在几个场景中会有帮助，其中之一就是稍微优化你的工作流以减少网络访问。每个git pull都涉及一个git fetch，所以如果您想在五个不同的分支上获得pull，您有四个多余的git fetch调用。</p><p id="2117" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，<strong class="js iu"> git fetch </strong>通常可以在您离线工作或在旅途中工作(可能是在火车上)的情况下节省您的时间，但是您希望确保在远程工作时可以获得每个分支的所有更改。当你在网络上时，你可以简单地获取一次，然后离开。以后，在没有网络连接的情况下，可以手动git结帐分支；git merge origin/branch合并您之前获取的更改。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="b401" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">开关和检测</strong></h1><p id="9d61" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">来自<a class="ae ko" href="https://git-scm.com/doc" rel="noopener ugc nofollow" target="_blank"> Git文档</a>:</p><blockquote class="mq mr ms"><p id="ee83" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">git switch切换到指定的分支。工作树和索引被更新以匹配分支。</p><p id="b3f5" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">git checkout更新工作树中的文件，以匹配索引或指定树中的版本。</p></blockquote><p id="c4ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">git switch不是一个新特性，而是一个额外的切换/更改分支特性的命令，在重载的git checkout命令中已经有了。因此，为了分离功能，<strong class="js iu"> Git 2.23 </strong>引入了新的git switch branch命令，试图在不破坏向后兼容性的情况下开始缩减责任。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ni"><img src="../Images/a7c591bf444052563a102eaf2e2c2def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyLV6rtidWqF8oQZtajJ-w.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://bluecast.tech" rel="noopener ugc nofollow" target="_blank"> https://bluecast.tech </a></figcaption></figure><p id="a499" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">git checkout命令对三个不同的实体进行操作:文件、提交和分支。简而言之，如果你修改了一个文件，但没有进行修改，那么<strong class="js iu">git check out&lt;filename&gt;</strong>将放弃修改，你将留在同一个分支上，而<strong class="js iu">git check out&lt;commit hash&gt;</strong>让你回滚到旧的提交，而<strong class="js iu">git check out&lt;branch&gt;</strong>将切换分支，因此，为了避免这种混淆，引入了<strong class="js iu"> git switch </strong>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/98338cce41d2c1cb20c4fa67360b99f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*sHJdaHsRpAzCk_ib4x4gCA.jpeg"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://www.slideshare.net/" rel="noopener ugc nofollow" target="_blank">https://slideshare.net/</a></figcaption></figure><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e1c04e3ced5415efdde9507d6c3bbf9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*kODKf_nR0rwv3ZOr98cEhg.jpeg"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:https://slideshare.net/</figcaption></figure><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a1bb0b4a8cea32af6b3123e974c17ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*JwsbBKmfqWuyadWCK275Ag.jpeg"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:https://slideshare.net/<a class="ae ko" href="https://www.slideshare.net/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><ul class=""><li id="1a01" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated"><strong class="js iu">头~和HEAD^ </strong></li></ul><p id="7d1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> ~(波浪号)</strong>和<strong class="js iu"> ^(caret) </strong>符号用于指向相对于特定提交的位置。这些符号与提交引用一起使用，通常是<strong class="js iu">头</strong>(表示分支的当前快照)或提交散列。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/593a28274703adb70de52bbfe78289df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*hxjscRxtC0YpXdNf-9YmoA.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://backlog.com" rel="noopener ugc nofollow" target="_blank">https://backlog.com</a></figcaption></figure><p id="9fc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">~n指第n个祖父母。HEAD~1指的是提交的第一个父级。HEAD~2指的是提交的第一个父对象的第一个父对象。</p><p id="9c6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">^n指的是第n个父母。HEAD是指提交的第一个父级。HEAD是指提交的第二个父级。在合并提交中，一个提交可以有两个父提交。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="9f8b" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">恢复和复位</strong></h1><p id="c64f" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">来自<a class="ae ko" href="https://git-scm.com/doc" rel="noopener ugc nofollow" target="_blank"> Git文档</a>:</p><blockquote class="mq mr ms"><p id="35f5" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">git revert用于记录一些新的提交，以逆转一些早期提交的影响(通常只是一个错误的提交)。</p><p id="0136" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">git-reset将当前磁头复位到指定状态。</p></blockquote><p id="dbb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> git revert </strong>命令用于撤销对存储库提交历史的更改。它用于反转由特定提交引入的更改，并将结果反转内容附加到新的提交中。这对于跟踪由单次提交引入的bug非常有用，这样可以通过git revert命令自动修复它。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/2073937fd6cefcbcda2b7f35ddd218c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*gwwLoCvrGdTPk6QfX7PZfQ.jpeg"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://blog.nakulrajput.com/" rel="noopener ugc nofollow" target="_blank">https://blog.nakulrajput.com/</a></figcaption></figure><p id="557b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> git reset </strong>是另一个用于撤销更改的复杂且通用的git命令，然而，git reset会移动HEAD ref指针和当前分支ref指针，而<strong class="js iu"> git revert </strong>命令不会移动HEAD ref指针。</p><p id="900a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，如果你已经把你的分支推到了某个地方，或者有人从你的分支中撤出，你唯一的选择就是<strong class="js iu"> git revert </strong>来撤销更改。同时，如果您已经将提交完全保持在本地和私有，您可以简单地使用<strong class="js iu"> git reset </strong>来撤销更改。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nm"><img src="../Images/850a39e0a4d3a02455e3a56ad4792a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8q5OTBysupIfkpROkbH_qg.jpeg"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://ohi-science.org/" rel="noopener ugc nofollow" target="_blank">https://ohi-science.org/</a></figcaption></figure></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="d474" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">合并和重设基础</strong></h1><p id="eb6e" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">来自<a class="ae ko" href="https://git-scm.com/doc" rel="noopener ugc nofollow" target="_blank"> Git文档</a>:</p><blockquote class="mq mr ms"><p id="f352" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">git merge将来自命名提交的更改(自从它们的历史从当前分支中分离出来)合并到当前分支中。</p><p id="aeb8" class="jq jr kp js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">git-rebase在另一个基础技巧之上重新应用提交。</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nn"><img src="../Images/0bdc310fef432eb79793b70fb24027b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1C7Rysd6vNCq2DGXaR1zuw.jpeg"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:https://miro.medium.com/</figcaption></figure><p id="ca0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两个命令都是为了将一个分支中的变更集成到另一个分支中而设计的，不同之处在于它们执行的方式。<strong class="js iu">重设基础</strong>是将一系列提交移动或合并到一个新的基础提交的过程，而<strong class="js iu">合并</strong>绑定了两个分支的历史，并且总是一个向前移动的变更记录，因此，不会以任何方式改变现有的分支。</p><p id="27f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重定基础的主要好处是您可以获得一个更加清晰的项目历史，因为它消除了git merge所需要的不必要的合并提交。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi no"><img src="../Images/1ac031d14954061eda868db38ea815bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9vhZ0Arc0ViAnl9ksy_Ew.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://jeffkreeftmeijer.com/" rel="noopener ugc nofollow" target="_blank">https://jeffkreeftmeijer.com/</a></figcaption></figure><p id="642d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将每个本地提交一次一个地转移到更新后的主分支，来进行重新定基。这意味着您在逐个提交的基础上捕获合并冲突，而不是在一次大规模的合并提交中解决所有冲突。</p><p id="44d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，重定基础可以更容易地找出哪里引入了bug，如果有必要，可以回滚对项目影响最小的更改。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/806de6b6053bfd51fa7bcb6a4f6fc255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*W9s_gHZjepce-xOtXRwQ6w.gif"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来源:<a class="ae ko" href="https://cdn.dribbble.com/" rel="noopener ugc nofollow" target="_blank">https://dribbble.com/</a></figcaption></figure><p id="9be3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文到此为止。我希望它能帮助你解开与git和GitHub相关的一些令人困惑的术语。请提出您的宝贵建议和反馈。</p><p id="11c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想和我联系，请点击下面的链接:</p><p id="9357" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://www.linkedin.com/in/pragati-verma-b22a1b17b/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ko" href="https://github.com/PragatiVerma18" rel="noopener ugc nofollow" target="_blank">GitHub</a>|<a class="ae ko" href="https://twitter.com/Pragati56242726" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ko" href="https://medium.com/@itispragativerma" rel="noopener">Medium</a></p></div></div>    
</body>
</html>