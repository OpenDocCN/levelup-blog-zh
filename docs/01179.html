<html>
<head>
<title>Regularization in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习中的正则化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/regularization-in-machine-learning-59c619da4537?source=collection_archive---------3-----------------------#2019-11-23">https://levelup.gitconnected.com/regularization-in-machine-learning-59c619da4537?source=collection_archive---------3-----------------------#2019-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d85b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文介绍了机器学习中使用的正则化技术及其各种类型。执行正则化是为了对模型进行概化，以便它能够对看不见的数据输出更准确的结果。本文将进一步探讨正则化机器学习模型的必要性、它的机制，以及它如何将泛化带到机器学习模型中。</p><h2 id="7eaf" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">什么是正规化？</strong></h2><p id="6642" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">在机器学习模型中，我们有两个重要的属性，即误差项(损失函数)和模型参数(权重)。我们的目标是最小化损失函数。有时发生的情况是，为了使损失太小，或者换句话说，为了使精确度接近完美，模型不从数据中学习，而是记忆数据。这个模型不符合数据，它实际上过度拟合了数据。这导致参数值的幅度很大。</p><p id="d4b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正则化是一种方法，其中我们将随着我们的权重变大而变大的<em class="lj">惩罚项</em>添加到损失中，以便我们可以正则化大量的参数。现在我们的目标变成了最小化总损失——<strong class="jp ir">误差项加惩罚项</strong>。我们越重视惩罚项，就越不鼓励我们的模型获得大的权重。正则化对具有高数量级的权重不利。使用的主要正则化类型有——L1&amp;L2正则化。</p><h2 id="d4a3" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">为什么需要正规化？</strong></h2><ol class=""><li id="82b7" class="lk ll iq jp b jq le ju lf jy lm kc ln kg lo kk lp lq lr ls bi translated"><strong class="jp ir">回归示例<br/> </strong>我使用图1左图所示的玩具数据集构建了三个模型。我使用了scikit-learn实现线性回归。<br/> * <a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html#sklearn-linear-model-linearregression" rel="noopener ugc nofollow" target="_blank">线性回归</a><br/>* L1-正则化线性回归(<a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html#sklearn-linear-model-lasso" rel="noopener ugc nofollow" target="_blank">拉索回归</a>)<br/>* L2-正则化线性回归(<a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html#sklearn-linear-model-ridge" rel="noopener ugc nofollow" target="_blank">岭回归</a>)</li></ol><div class="lu lv lw lx gt ab cb"><figure class="ly lz ma mb mc md me paragraph-image"><img src="../Images/584dcf21e6b7b005403818d2139a8af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*Z1-fPQ-rIs1sZTOYf9atdQ.png"/></figure><figure class="ly lz ma mb mc md me paragraph-image"><img src="../Images/bea5dff7c63c68fbda307213a931c8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*X9UgD72mLYHUlqZG_FbP8w.png"/><figcaption class="mh mi gj gh gi mj mk bd b be z dk ml di mm mn translated"><strong class="bd kn">图1:数据集(左)&amp;拟合线(右)</strong></figcaption></figure></div><p id="4343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用每个模型的系数值来验证简单线性回归和正则化线性回归之间的性能差异。</p><figure class="lu lv lw lx gt lz gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/6101f66224dd919576df3f19c0622158.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*_9VuLEgQRP86sMgijhQNdQ.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated"><strong class="bd kn">图2:回归—正则化线性回归—性能</strong></figcaption></figure><p id="69c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以清楚地看到，简单的线性回归过度拟合了数据，因为训练和测试得分之间存在显著差异。在正则化回归的情况下，训练分数会下降，但模型在测试(看不见的)数据时会提高其性能。当我们应用正则化时，我们会稍微降低模型的拟合度，以使其更具普遍性。</p><p id="257c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的一点是，<em class="lj"> alpha </em>是一个超参数，<em class="lj"> </em>我已经手动选择了它的值来说明正则化的效果，但是在实践中，我们使用交叉验证来为<em class="lj"> alpha找到合适的值。</em></p><p id="433a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">分类示例<br/> </strong>再次，我使用scikit-learn中的<a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html#sklearn-datasets-load-breast-cancer" rel="noopener ugc nofollow" target="_blank">乳腺癌</a>数据集构建了三个模型。为了执行分类，我使用了scikit-learn实现的<a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn-linear-model-logisticregression" rel="noopener ugc nofollow" target="_blank">逻辑回归</a>。</p><p id="e831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在scikit-learn中，<code class="fe mp mq mr ms b"><a class="ae lt" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html" rel="noopener ugc nofollow" target="_blank">LogisticRegression</a></code>类有3个驱动正则化的参数— <code class="fe mp mq mr ms b">C</code>、<code class="fe mp mq mr ms b">penalty</code>、<code class="fe mp mq mr ms b">l1_ratio</code>。</p><p id="afd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a) <code class="fe mp mq mr ms b"><strong class="jp ir">C</strong></code> <strong class="jp ir"> : </strong>其值代表正则化强度的倒数。这意味着<code class="fe mp mq mr ms b">C</code>的值越大，正则化越弱。<code class="fe mp mq mr ms b">C</code>的较小值将对模型参数值(即系数和截距)施加更多限制，这反过来将导致参数的较小幅度。</p><p id="c398" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b) <strong class="jp ir"> </strong> <code class="fe mp mq mr ms b"><strong class="jp ir">penalty</strong></code> : <strong class="jp ir"> </strong>它表示我们想要执行的正则化类型，例如——L1、L2和elasticnet，即L1和L2的组合。</p><p id="c660" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">c) <code class="fe mp mq mr ms b"><strong class="jp ir">l1_ratio</strong></code>:当惩罚被指定为elasticnet时，使用它的值。它代表L1和L2之间的正规化比率。</p><figure class="lu lv lw lx gt lz gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/80d67f257d58ef3c418602293175dbe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*gUqQT-uiAG6DE2bg67DQXQ.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated"><strong class="bd kn">图3:分类—正则化逻辑回归—性能</strong></figcaption></figure><p id="b61f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图2和图3显示了正则化和非正则化模型的比较分数。为了在测试数据上提供良好的准确性，具有L2罚函数的模型往往拟合度较低。此外，L1正则化模型通过将一些系数的值设置为零来进一步抑制训练分数，并提供可比较的测试分数。</p><p id="a325" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们必须记住，这些结果是特定于超参数的选定值的，这些超参数是使用交叉验证调整的<strong class="jp ir"><em class="lj"/></strong>和<strong class="jp ir"> <em class="lj"> C </em> </strong>。根据超参数的不同值，结果可能会有所不同。</p><p id="3162" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3 <strong class="jp ir">。离群值— </strong>存在离群值时，线性模型往往会偏离最佳拟合线。我们可以在图4(右)中看到，简单的线性回归模型受到数据集(左)中异常值的干扰，无法给出最佳拟合线。另一方面，L2正则化线性回归通过使系数值更小并且更不适合数据来克服这个问题，以便提供非常接近最佳拟合线的解决方案。</p><div class="lu lv lw lx gt ab cb"><figure class="ly lz ma mb mc md me paragraph-image"><img src="../Images/bcb46c78dd92f334a3086960e4938241.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*GcxtiTgeIj9bl8zACSf33A.png"/></figure><figure class="ly lz ma mb mc md me paragraph-image"><img src="../Images/b8c97f473b1fcc18cb61a4ed1c7d35fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*-BmVIXxV0DiLIFwTW6OoIw.png"/><figcaption class="mh mi gj gh gi mj mk bd b be z dk ml di mm mn translated"><strong class="bd kn">图4:异常值的正则化</strong></figcaption></figure></div><p id="cced" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过到目前为止的讨论，我们可以得出结论，需要正则化来拟合比没有正则化的模型更简单的模型，以便最终我们可以得到在测试数据上概括得更好的模型。</p><h2 id="c0ee" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">正规化是做什么的？</strong></h2><figure class="lu lv lw lx gt lz"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated"><strong class="ak">图5:回归系数</strong></figcaption></figure><figure class="lu lv lw lx gt lz"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated"><strong class="ak">图6:分类—系数</strong></figcaption></figure><p id="555d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过观察图5和图6中的曲线，我们可以说正则化使系数变小。L2正则化试图降低参数值，L1使其中一些等于零。这样，L1正则化有助于特征选择并创建稀疏模型。</p><p id="abb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在没有正则化的情况下，我们最大化训练分数，因此我们的模型在训练数据上表现良好。当我们添加正则化时，我们实质上修改了原始损失函数来惩罚大的系数。在Scikit-learn的LogisticRegression类中，<code class="fe mp mq mr ms b"><strong class="jp ir">C</strong></code>的值越小，正则化就越强。因此，我们的模型将相应地不太符合数据，这反过来降低了训练分数。</p><p id="230d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是为什么正规化会提高测试分数呢？假设我们不想在培训中使用某个特定的功能。这相当于将该特征的相应系数值设置为零。正则化并因此使系数值更小在完全不使用该特征，即正则化系数(<code class="fe mp mq mr ms b"><strong class="jp ir">C=0</strong></code>)和完全使用它，即非正则化系数(<code class="fe mp mq mr ms b"><strong class="jp ir">penalty='none'</strong></code>)之间进行折衷。如果模型使用导致过度拟合的特征，则正则化缩小其系数值，因此模型不会受到大系数值的影响，并且预测更加准确的结果，这反过来提高了测试分数。</p></div></div>    
</body>
</html>