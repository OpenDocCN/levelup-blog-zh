<html>
<head>
<title>Safe Recursion with Trampoline in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中使用蹦床的安全递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/safe-recursion-with-trampoline-in-javascript-dbec2b903022?source=collection_archive---------5-----------------------#2020-05-11">https://levelup.gitconnected.com/safe-recursion-with-trampoline-in-javascript-dbec2b903022?source=collection_archive---------5-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4b87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JavaScript中使用递归是不安全的——考虑一下蹦床。这将递归转换为一个<code class="fe kl km kn ko b">while</code>循环，以避开JavaScript的限制并防止溢出。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/970653f063e4bacbd9a2e2e6da5f5aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9Sxt2ppwVpNELxC0"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">查尔斯·程在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1568" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">递归函数的一个惯用示例是阶乘计算。我们调用<code class="fe kl km kn ko b">factorial</code>函数<code class="fe kl km kn ko b">n</code>次来得到一个结果。每次调用都会在调用栈中增加一个<code class="fe kl km kn ko b">factorial</code>函数。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="07d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript中的递归大多是代码味道的标志，通常应该避免。原因是JavaScript是基于栈的语言，还没有尾部调用优化。如果您执行下面的代码片段，您将获得一个<code class="fe kl km kn ko b">RangeError: Maximum call stack size exceeded</code>。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="926b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，还是有需要使用递归函数的情况。一个现实的方法是遍历一棵<code class="fe kl km kn ko b">DOM</code>树或任何其他类似树的结构。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lg lh l"/></div></figure><h2 id="d047" class="li lj iq bd lk ll lm dn ln lo lp dp lq jy lr ls lt kc lu lv lw kg lx ly lz ma bi translated">trampoline——在JavaScript中使用递归的安全方式。</h2><p id="4fd0" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">使用<code class="fe kl km kn ko b">trampoline</code>，您将递归函数转换成一个<code class="fe kl km kn ko b">while</code>循环:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="3bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们重写<code class="fe kl km kn ko b">factorial</code>函数来使用<code class="fe kl km kn ko b">trampoline</code>。我们需要:</p><p id="8a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.在基本情况下返回值。</p><p id="97e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.返回一个在其他情况下调用的函数。</p><p id="25bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还为内部实现<code class="fe kl km kn ko b">_factorial</code>添加了累加器参数。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="7884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe kl km kn ko b">recursiveFn</code>可以像<code class="fe kl km kn ko b">factorial</code>一样重写，但是我们不需要累加器来跟踪状态。这种实现甚至可以安全地运行数百万次迭代。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="b6d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次你想使用递归的时候，试试<code class="fe kl km kn ko b">trampoline</code>！</p><p id="b9d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以试试下面CodePen里的<code class="fe kl km kn ko b">trampoline</code>。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mg lh l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="ba35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">蹦床不是一种受欢迎的技术。即使在拉姆达和洛达什，也没有蹦床帮手。</p><p id="7d2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢凯尔·辛普森关于蹦床的灵感。</p></div></div>    
</body>
</html>