# 了解如何在 Spring Boot 应用程序中创建作业调度程序

> 原文：<https://levelup.gitconnected.com/learn-how-to-create-job-schedulers-in-spring-boot-application-8def2c476424>

嘿伙计们，怎么了？在这篇博客中，我们将通过一个独特的例子来学习如何在 Spring Boot 应用程序中创建一个作业调度程序。

和往常一样，我们将从 [start.spring.io](https://start.spring.io/) 创建一个项目。只需对 Spring Boot 应用程序进行简单的设置，我们就可以创建任意多的调度程序。下图显示了所需的依赖关系。

![](img/4b1edbdc25d5ac942ec5aed0fd3bc839.png)

假设我们有一个微服务，可以导出一些数据，如 zip 文件或任何类型的文件，存储在数据库中。一种显而易见的方法是通过 REST 端点启动流程，并等待文件生成。如果数据不复杂，并且大小很小，您可以在几秒钟内得到您期望的结果。这称为同步作业。但是，如果数据很复杂，涉及许多数据库查询和其他内部操作，并且需要更多时间来生成，该怎么办呢？结果是糟糕的用户体验。当然，我们可以通过增加客户端和服务器之间的超时来解决这个问题。同样，这不是一个有效的解决方案。

我们的日程表来了。我们仍将使用相同的端点来启动流程。但是这一次，我们没有等待它完成，而是启动并立即返回一个带有元数据的 200 OK。小心，我们现在处理的是一个状态；你以后就知道了，为什么。下面是这个过程。为了简单起见，我只是模拟了启动-导出过程。

![](img/7b448bfd424a6fb1a37b294526251e5d.png)

FileExportController.java

上述 API 的响应如下图所示。

![](img/8cdf625637e49801816f59653512c422.png)

response.json

现在是时候编写我们的作业调度程序了。用 Spring 的方式，我们会写一个组件。我喜欢 Spring boot 的原因是它的自动配置概念。只需一个名为 *@EnableScheduling* 的注释，我们就可以编写简单的调度程序。在下面的代码中，我没有添加这个注释。你可以在这里或主类中添加它。

![](img/c96a1c83246b46444fc2bc83c6159278.png)

FileExportScheduler.java

让我们浏览一下文件。我们需要的只是一个运行作业和 Java 的 ExecutorService 的方法，以及一个处理并发性的映射。这样我们可以确保线程安全。Spring 提供了不同类型的调度器，比如 cron 作业、固定延迟类型的作业等等。但是现在，我们将看到固定延迟类型。这种类型与固定费率类型的唯一区别在于，后者不会等待之前的唤醒呼叫结束。所以固定延迟类型在作业之间有更多的控制。

使用注释 *@Scheduled，*我们将 *wakeUp()* 方法标记为调度程序。Spring 会处理剩下的事情，我们可以专注于我们的逻辑。在上一步中，我们通过将状态保存为 PENDING 来启动作业。我们将在后面看到，为什么 IN_PROGRESS 也被考虑。为了避免在*执行程序*中重复提交作业，我们有一个*并发哈希表*。也就是说，只有当作业不在地图上时，我们才会提交它。现在你可能会想，为什么我们需要在地图上保持这种状态？这让我想到了另一个场景。假设我们有其他资源可以调用这个方法。说到底， *wakeUp()* 方法是一个公共方法。状态被保存在一个地方(这个调度器类),而不是复制，无论应用程序中有多少个源试图做同样的工作，映射都会处理好。与 *SynchronizedMap* 相比，更喜欢这个 map 的一个小技巧是，前者将在其 bucket 级别锁定。更多信息可在此[链接](https://stackoverflow.com/a/20417527/6487148)中找到。

我们会将当前状态标记为进行中。一旦流程成功完成，我们会将作业标记为已完成，如果出现异常，则会将其标记为失败。我们还通过任何通知机制通知客户。为了更好的可读性和类型安全性，这些状态值可以作为枚举来维护。

这个概念实现的主要问题是，“当服务突然停止或任何其他可能干扰过程的技术故障时，如何处理”。因为整个过程都是在后台完成的。用户永远不知道幕后发生了什么。这就是我们在选择查询中包含 IN_PROGRESS 的原因。一旦服务启动并运行，在灾难发生后，将在初始延迟 30 秒后执行 *wakeUp()* 方法，其余的将再次执行。当然，IO 清理是必需的，您可以将其作为“后处理”来完成。

所以，我想就这样了。你可以自己试试这个。您可以将它与 Spring Boot 现成的事件监听器结合使用。端点将发布事件，侦听器方法将使用事件对象并触发文件导出方法。所有这些步骤都可以异步执行。调度程序将负责灾难恢复。

谢谢，祝您愉快！