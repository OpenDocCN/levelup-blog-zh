<html>
<head>
<title>Rust: Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust:二叉树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rust-binary-tree-30efdd355b60?source=collection_archive---------5-----------------------#2020-10-30">https://levelup.gitconnected.com/rust-binary-tree-30efdd355b60?source=collection_archive---------5-----------------------#2020-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="670a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建和折叠表达式树</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f3d8568829c89d5c9f520ed80e02a052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tnPK-JCLmPQky4sz"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alexperri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯·佩里</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="c965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Rust变得如此受欢迎，并且积累了如此忠实的追随者，我决定放下我心爱的JS，最近学习Rust。我必须说，这不是一个心脏衰弱的旅程。幸运的是(尽管在一些罕见的情况下会产生误导),编译器是你最好的朋友——它几乎总是会告诉你哪里做错了，甚至会提供有用的解决方案。在你花了一段时间使用它并且克服了陡峭的初始学习曲线之后，你会开始喜欢Rust——我喜欢！</p><p id="c9a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我想实现我最喜欢的数据结构:二叉树。二叉树是一种典型的树——它由保存其(潜在深度)嵌套值的节点组成。二叉树的特殊之处在于它的节点只有两个子值:左边的<em class="lv">和右边的<em class="lv">和</em>。通常，二叉树用于表示数学表达式之类的东西，但也可以用于处理轻量级语法的解析。对于我们的实现，让我们的节点知道它们代表什么类型的操作也很方便。我们将努力使它通用，从而使底层结构类型不可知。下面是二叉树的一个简单表示:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/99ae11273f77575c27c193dc38ce5584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gusO4HuHWiGfP97F3qcWKQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一棵异常标记的二叉树…</figcaption></figure><p id="9b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此图中，终端节点带有数字。值得注意的是，二叉树是左偏的，深度优先。这意味着当您折叠一个二叉树时，在移动到右边的节点之前，评估将尽可能深入到第一个左边的节点，并且这些节点的左边的节点在其右边的节点之前，等等。，递归。我会边走边解释。</p><p id="7136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们想象一个表示节点数据的最小结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/9113f3281d2e811a11857e202f3bccc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kECUoYz_zdQwwtUu-AjsMg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">递归类型会让编译器生气。</figcaption></figure><p id="bc01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…编译器马上就对我们发火了。结构不能直接包含对自身的引用(它变成了递归类型，这在Rust中是非法的)。但是方便的是，我们可以将递归节点放在一个<code class="fe ly lz ma mb b">Box</code>中。“盒子”只是一种奇特的说法，“这是一个引用堆上对象的指针”。让我们看看这是否能解决我们的问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/facf6134a5dd67145cb6ee04f916b983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sORiJjg3JTxsgIUbsNfCZA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">盒子给了我们一层间接性。</figcaption></figure><p id="7f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就行了。我们的盒子增加了一个间接层，只存储一个指向我们的<code class="fe ly lz ma mb b">BTNode</code>的<em class="lv">指针</em>，允许我们避开递归类型。那么Op呢？Op将是一个<code class="fe ly lz ma mb b">enum</code>，表示可以在我们的节点上执行的可能操作。对于这个例子，我们将坚持使用简单的算法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/206eb3e462c72710033240d3b31763da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04tb7HllTntI1CyLK5gYag.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">表示一些简单算术运算的枚举。</figcaption></figure><p id="c7cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。我们已经有了一些基本算术运算的变体。通知<code class="fe ly lz ma mb b">Id(T)</code>？那个很特别。因为我们需要二叉树中的值是<code class="fe ly lz ma mb b">BTNode</code>结构的实例，所以没有办法直接把<code class="fe ly lz ma mb b">i32</code>放入我们的树中。这是一个问题，因为原始数据是我们期望的最终值。想象一下表情<code class="fe ly lz ma mb b">(3 + 4) * (5 * 2)</code>。我们可以认为这是一棵有三个节点的二叉树。头节点是一个具有左右节点值的<code class="fe ly lz ma mb b">Mul</code>节点。头部的左边节点是一个<code class="fe ly lz ma mb b">Add</code>节点，左右值分别为3和4。右边是5和2的一个<code class="fe ly lz ma mb b">Mul</code>节点。这些原始数字就是我们所说的<em class="lv">终值</em>。</p><p id="3256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它被称为终值，因为它在末端。其中常规节点类似于<em class="lv">分支</em>，终端节点是<em class="lv">叶子。</em>当您到达一个时，在您的代码所经过的路径上没有更多嵌套层次可以下降，并且其中的值可以被解释为原始值而不是节点。为了从我们的节点获得终端值，我们必须利用我们的<code class="fe ly lz ma mb b">Op::Id(T)</code>变量来存储数据。当我们这样做的时候，我们可能应该考虑我们的左右框中的节点在一个终端节点中可能是未赋值的。我们应该将它们分别包装在选项中，以说明这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/b4b52cb846f28d265b6c206a6612adc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAkhfORc0ZnBTq-KLJ_o7g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">T节点框选项…</figcaption></figure><p id="5f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经定义了我们的节点，使得它们的子节点可以是一些装箱的值，或者没有。虽然看起来确实有点滑稽。不过，我们可以通过使用类型别名使它看起来更好一些:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/db247910c517254bf727c8ace29a99e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THA5YK-ubndncNdTddmA9A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">为我们的子节点声明类型别名。</figcaption></figure><p id="3daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将它放在代码的顶部，并在我们的<code class="fe ly lz ma mb b">BTNode</code>中替换长版本。既然我们已经彻底考虑了如何定义一个节点，让我们定义一个树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/abb91c9bb4c01e97a762415d0fe71b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gWoEdFOCXlKYeC-liEpICg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个非常简单的结构。</figcaption></figure><p id="f9b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们已经花时间很好地定义了节点，所以这一部分很简单。我们的树要么是空的<em class="lv"> </em>要么头是一些节点值。因为嵌套的节点是指向子节点的指针值，所以这就是我们描述树所需要的。现在我们已经处理了树的数据部分，让我们开始一些实现。我们从节点开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/89fc790cf2490aecb333f32256d39e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGY20iOyhjk4KfQgvurDug.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">节点的构造函数。</figcaption></figure><p id="dcbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。我把它纵向展开，这样我们就有了一种方法来创建节点结构的实例。但是想象一下为每个节点声明“new”——这需要大量的输入！让我们抽象一下，创建一些专门的构造函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ca"><img src="../Images/9ede3bb39a5ae197cefaa11b0b659395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4hE7mfTNi0sMB718insbdQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">节点的专用构造函数。</figcaption></figure><p id="660c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些函数中的每一个都构造了一个专门的<code class="fe ly lz ma mb b">BTNode</code>版本，这将使得以后声明它们更加简单。它们都利用了原始的<code class="fe ly lz ma mb b">BTNode::new</code>构造函数，除了<code class="fe ly lz ma mb b">IdNode</code>——直接构造一个<code class="fe ly lz ma mb b">BTNode</code>，因为它的左右节点值并不重要，它只关心它的<code class="fe ly lz ma mb b">i32</code>值。</p><p id="07b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们考虑为二叉树实现一些功能。它需要有一个主要功能——将其节点折叠成一个值。现在让我们来写这个函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/a21f78bde9c0bb35e5b16cb8772c5096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Qawdvneys7hv__DIwmWdA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">二叉树的崩溃。</figcaption></figure><p id="bf2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还包含了一个简单的构造函数。让我们浏览一下代码。查看我们的<code class="fe ly lz ma mb b">i32</code>实现的签名，我们可以看到它采用一个指向节点的指针引用并返回一个<code class="fe ly lz ma mb b">i32</code>。我们做的第一件事是声明一对可变的左和右<code class="fe ly lz ma mb b">Option&lt;i32&gt;</code>值，并将其初始化为None——我们可以在折叠子节点时重新分配这些值。我们在子节点上递归调用collapse来重新分配我们的左值或右值，当且仅当这些值中的任何一个都是非终端节点(不是<code class="fe ly lz ma mb b">IdNodes</code>的节点)。然后我们使用<code class="fe ly lz ma mb b">if let</code>和我们的左右值将值提取到<code class="fe ly lz ma mb b">i32</code>中。在这个过程中，我们将变量<code class="fe ly lz ma mb b">l</code>和<code class="fe ly lz ma mb b">r</code>重新赋值为不可变的(当我们用<code class="fe ly lz ma mb b">let</code>重新声明它们时)。最后，我们匹配节点的操作，组合并返回值(或者如果我们不小心被零除，则返回)。</p><p id="5113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从这张图片创建一棵树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/2985065c3c9e40ca31c98366b5186fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41YzlgMUjBJcFkHc-rImNA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个糟糕的符号(用我的手指写的)二叉树。</figcaption></figure><p id="5fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这代表了表达式<code class="fe ly lz ma mb b">(10 - (2 * 2)) + (8 + (10 / 2))</code>。绿色数字表示我们的算法到达每个节点的顺序。红色符号是我们将要使用的节点值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/035c89cc2cae856d669330c3ffe6198b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmLrkI-041a7qAAFhBT-Zg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">构建和折叠二叉树。</figcaption></figure><p id="26bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台应打印出<code class="fe ly lz ma mb b">19</code>。正如我们所料，如果我们自己走过它。</p><p id="3b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这里有一个</strong> <a class="ae ky" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1ed66ba070c1c4990525fe5fae9a5699" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">链接</strong> </a> <strong class="lb iu">到铁锈操场，你可以黑进去。</strong></p><p id="25cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的例子，但是想象一下我们的Op <code class="fe ly lz ma mb b">enum</code>代表了不同的东西。我们可以为除了<code class="fe ly lz ma mb b">i32</code>之外的东西实现二叉树，并将它用于不同的目的。比如解析一个简单的脚本语法或者在视频游戏中积累特效。在计算机科学领域，它们是特别有用的数据结构。</p><p id="b796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你喜欢另一篇Rust文章。下次见，FP on，读者！</p></div></div>    
</body>
</html>