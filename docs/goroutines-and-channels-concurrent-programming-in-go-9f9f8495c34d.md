# Goroutines 和 channels——go 中的并发编程

> 原文：<https://levelup.gitconnected.com/goroutines-and-channels-concurrent-programming-in-go-9f9f8495c34d>

## 为什么 golang 在并发性方面如此独特和强大？

![](img/6163683245027694ce336d950a3cabcf.png)

真实机构在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的

Golang 是一种并行语言。它包含了许多工具和语言特性，使得创建并发程序变得简单明了。在分析这些之前，让我们回顾几个概念。

## 并发性与并行性

关于这件事有令人惊奇的材料。我不会在这上面花太多时间。我们只需要在开始之前弄清楚。如果你有兴趣了解更多关于这个主题的内容，我会在最后留下一个链接，里面有 Rob Pike 的精彩演讲。

**并发**是一种构建程序的方式，它独立自主地执行几个不同的部分(称之为功能、方法、过程、任务、活动)。创建并发程序就是设计程序来独立执行各个部分。他们是否会一次执行每一部分并不重要。

**并行**另一方面与执行部分有关。并行就是同时执行多件事情。这些事情可能有关联，也可能没有。这其实并不重要。为了执行多项任务，您确实需要多个处理器。

正如 Rob Pike(golang 的创始人之一)在[这个演讲](https://www.youtube.com/watch?v=cN_DpYBzKso)中精辟地指出的:

> 并发是指**同时处理**很多事情，而并行是指**同时做**很多事情。

## Go 的并发模型

go 的并发模型背后的大多数想法来自东尼·霍尔发表的论文“沟通顺序过程”(CSP)。本文介绍了一种设计并发程序的语言。然而，这种语言是不可执行的，这意味着用这种语言编写的程序不能实际执行。Go 在语言上用这个思路创建了主要的并发工具: ***Goroutines、*** 和 ***select 语句*** 。

## 戈鲁廷斯

Goroutines 与 CSP 上的过程是等价的。你可以把它们想象成一个非常轻量级的结构，使 go 运行时能够并发地执行事情。Go scheduler 将在必要时负责创建操作系统线程，以及选择要执行的内容，因此您不必太担心它在内部是如何执行的。创建和执行 goroutine 的方法是在调用函数之前添加一个`go` 关键字。这里有一个例子:

您可以注意到`printSomething`函数没有什么特别之处。当我们用`go function()`调用任何函数时，goroutine 都是并发创建和执行的。这意味着潜在的任何功能都可以并发执行。一旦你用关键字`go`调用了一个函数，你就不需要等待这个函数完成来执行剩下的代码。它将同时运行。如果您执行上面的例子，您可以看到它可能不会打印“0 ”,因为执行可能会在该函数执行之前结束。如果我们在等待用户输入或者代码一直运行，那么“0”最终会被打印出来。

Web 服务器在处理 web 请求时使用这种方法。每个请求都在自己的 goroutine 中运行。这使得服务器可以同时运行每个请求。

## 频道

大多数情况下，我们需要在不同的团队之间进行交流。如果我们通过在两个 goroutines 之间共享一个变量来做到这一点，它们将不会真正独立，我们可能会遇到竞争条件或其他类型的问题。这也是 go 引入*通道*概念的原因。通道是不同 goroutines 之间的通信方式。类似的机制是 unix 系统中的管道(`|`)功能，您可以通过管道命令将一个命令的输出作为后续命令的输入。除此之外，一个很好的补充是通道是类型化的，这使得它们非常强大。因为这是一种通信方式，所以您希望在通道上执行两个主要操作:**发送**和**接收**。

由于它们是 golang 语言中的一种类型，所以您可以将它们赋给变量，将它们作为参数传递，将它们用作函数的返回值，等等。使用它们的基本设置是，一个 goroutine 将在通道上发送值，而另一个 goroutine 将从通道接收值。如果你不这样做，你的程序可能会停滞不前，等待事情发生。

基本上有两种类型的通道，无缓冲通道和缓冲通道。

**无缓冲通道**

这些通道一次处理一个值。这意味着，如果一个值已经存在于通道上，它会阻止正在尝试发送值的 goroutine 的执行。这同样适用于 goroutine 试图从通道接收值的情况。在有值可用之前，执行将被阻止。不要认为这是一件坏事。实际上这是一个非常聪明的设计。我用一个简单的例子来解释:

在本例中，我们已经创建了一个通道，并将其分配给函数`main`中的变量`c`(第 6 行),然后将它传递给一个函数，该函数生成数字并通过该通道发送它们。在第 10 行，我们`range`通过通道，这意味着我们试图从通道接收一个值，直到通道关闭(第 20 行发生了什么)。范围在内部执行`i := <-c`(接收)。在这个例子中，main 函数的执行将被阻塞，并且将等待直到在线路 10 上的通道上接收到某些东西。同样的情况也会发生在第 18 行的函数`generateInts`上。一旦在通道上发送了第一个值(0 ),执行将被阻塞，直到主 goroutine 从通道接收到该值。

**缓冲通道**

缓冲通道包含一个内部缓冲器，用于存储值，直到缓冲器满为止。这意味着大小为 10 的缓冲通道将接受 10 个发送操作，而不会阻塞执行，即使没有执行接收操作。当第 11 次发送操作被触发时，执行将被阻止。当你和一群工人一起工作时，这种类型的渠道是很常见的。这里有一个简单的例子:

现在我们使用大小为 3 的缓冲通道。这是因为我们有 3 个工人使用同一个通道，哪个工人首先收到的值将打印出来。打印后，工人睡一会儿，因为打印数字不是一件容易的事，工人需要休息。`generateInts`函数与前面的例子非常相似，只是这次我们打印的是我们在通道上发送的内容。值得一提的是，生成一个数字比打印它要快得多(你可以看到睡眠时间)。当工人都忙着睡觉时，生产者将发送 3 个数字，执行将被阻止，因为将达到通道大小。如果没有人接收，我们不想把东西放在频道上。下面是运行该程序的输出(您可以看到，在阻塞执行之前似乎发送了 4 个值，但这是因为`stdout`是一个共享资源，所有事情都发生得非常快):

```
$ go run main.go
Sent value 0
Worker 1 received value 0
Sent value 1
Worker 3 received value 1
Sent value 2
Worker 2 received value 2
Sent value 3
Sent value 4
Sent value 5
Sent value 6
Worker 1 received value 3
Sent value 7
Worker 3 received value 4
Worker 2 received value 5
Sent value 8
Worker 1 received value 6
Sent value 9
Worker 3 received value 7
Worker 2 received value 8
Worker 1 received value 9
```

因为通道是语言结构的一部分，你可以根据需要使用它们，它们可以被初始化、关闭、作为参数传递等等。在我工作过的一个生产系统中，我们为收到的每个 web 请求创建了一个通道。在那个频道上，我们发送了一些需要存储在数据库中的数据。负责保存的函数作为一个 goroutine 被解雇。这样，保存操作在后台运行，不会阻塞或延迟对客户端的响应。这是我们的目标。为了清楚起见，下面是实际代码的简化。每个生产者和每个消费者一个通道(记住，HTTP 服务器使用 goroutine 调用`handleHTTPRequests`)。

我在生产系统中使用的另一种方法是创建一个通道，让多个生产者在该通道上发送数据。在这种情况下，我们对一个 SQL 数据库同时运行多个查询，每个查询返回多个行，这些行被解析并通过中央通道发送到内存缓存。这里有另一段代码，只是为了显示这个问题的主要逻辑。

您可以注意到，这里我们使用了一个`WaitGroup`来等待所有的生产者完成他们的工作。

关于使用 goroutines、channels 和 select 语句的更高级的例子，请查看我写的关于[对冲请求](https://medium.com/@ricardo.linck/hedged-requests-tackling-tail-latency-9cea0a05f577) out 的文章！

## 参考

围棋编程语言—【http://www.gopl.io/ 

罗布·派克的并发不是并行——[https://www.youtube.com/watch?v=cN_DpYBzKso](https://www.youtube.com/watch?v=cN_DpYBzKso)