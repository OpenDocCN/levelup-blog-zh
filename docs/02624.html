<html>
<head>
<title>Building a TODO API in Golang with Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes在Golang中构建TODO API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-todo-api-in-golang-with-kubernetes-1ec593f85029?source=collection_archive---------2-----------------------#2020-03-26">https://levelup.gitconnected.com/building-a-todo-api-in-golang-with-kubernetes-1ec593f85029?source=collection_archive---------2-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0d9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章的目标读者是Kubernetes的新用户，他们希望通过一个实际的例子来学习如何编写一个Go API来管理你的待办事项列表，以及如何将它部署到Kubernetes。</p><blockquote class="ko kp kq"><p id="7bf9" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">最后更新于2022年</p></blockquote><blockquote class="kv"><p id="3f01" class="kw kx it bd ky kz la lb lc ld le kn dk translated">每个开发人员都喜欢好的待办事项列表，对吗？否则我们怎么能完成任何事情。</p></blockquote><figure class="lg lh li lj lk ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lf"><img src="../Images/4d474f284277417c28e8290125e1bf1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKKH0QyfhEAM2ImvQCQZUg.jpeg"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">每个开发人员都喜欢一个好的TODO应用程序，对吗？</figcaption></figure><p id="6882" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将从材料清单开始，然后继续配置Kubernetes，提供Postgresql数据库，然后安装一个应用程序框架，该框架可以帮助我们轻松地将Go APIs部署到Kubernetes，而不会陷入混乱。</p><p id="cd78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将在API中创建两个端点——一个创建新的TODO项，另一个选择所有TODO项。</p><p id="af71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本教程的完整代码示例可从GitHub获得:<a class="ae lw" href="https://github.com/alexellis/kubernetes-todo-go-app" rel="noopener ugc nofollow" target="_blank">https://github.com/alexellis/kubernetes-todo-go-app</a></p><h2 id="3c12" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">开始之前</h2><p id="96f6" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">你会从对围棋的实际理解中受益。<a class="ae lw" href="https://openfaas.gumroad.com/l/everyday-golang" rel="noopener ugc nofollow" target="_blank">我的电子书《日常生活》(T3)涵盖了所有的基础知识和一些更高级的话题。</a></p><p id="6076" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">阅读人们在Gumroad上对它的评论:</p><div class="mv mw gp gr mx my"><a href="https://openfaas.gumroad.com/l/everyday-golang" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">日常Golang</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">“日常生活”是从生产中使用的真实工具中学习工具、技术和模式的快捷方式。这本书是一本…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">openfaas.gumroad.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm lq my"/></div></div></a></div><h2 id="4c7e" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">材料清单:</h2><ul class=""><li id="7b9e" class="nn no it js b jt mq jx mr kb np kf nq kj nr kn ns nt nu nv bi translated">本地安装的Docker</li></ul><p id="f848" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes在容器映像中运行代码，所以您需要在您的计算机上安装Docker。</p><p id="2726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在安装Docker:【https://www.docker.com】T4</p><p id="b2a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注册一个Docker Hub账户来储存你的Docker图片:<a class="ae lw" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a></p><ul class=""><li id="e608" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated">库伯内特星团</li></ul><p id="02d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以选择本地集群或远程集群，但是哪一个是最好的呢？像k3d这样的轻量级选项可以在任何可以运行Docker的计算机上运行，因此运行本地集群不再需要大量的RAM。远程集群也是一种非常有效的工作方式，但是请记住，每次更改都需要上传和下载所有Docker映像。</p><p id="4e97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装k3d:<a class="ae lw" href="https://github.com/k3d-io/k3d" rel="noopener ugc nofollow" target="_blank">https://github.com/k3d-io/k3d</a></p><p id="7e80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">k3d不会安装kubectl(这是Kubernetes的CLI)，所以从这里单独安装:<a class="ae lw" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/tasks/tools/install-kubectl</a></p><ul class=""><li id="76a8" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated">Go又名Golang</li></ul><p id="5599" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你需要在电脑上安装Go和IDE。Go是免费的，您可以在此下载适用于MacOS、Windows或Linux的go:</p><p id="68ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">立即安装Go:<a class="ae lw" href="https://golang.org/dl/" rel="noopener ugc nofollow" target="_blank">https://golang.org/dl</a></p><ul class=""><li id="0bf6" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated">IDE</li></ul><p id="0edb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我会推荐使用Visual Studio代码，它有一组插件，你可以为Go添加，而且是免费的。有些人更喜欢Jetbrains的Goland，如果你是一名Java程序员，你可能会更喜欢为Goland付费，因为它会让你想起他们的其他产品。</p><p id="731b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在安装VSCode或Goland:<a class="ae lw" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank">https://code.visualstudio.com</a>或<a class="ae lw" href="https://www.jetbrains.com/go/" rel="noopener ugc nofollow" target="_blank">https://www.jetbrains.com/go</a></p><h1 id="77c9" class="nz ly it bd lz oa ob oc mc od oe of mf og oh oi mi oj ok ol ml om on oo mo op bi translated">构建集群</h1><p id="3e29" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">您需要安装上一节中的所有软件。</p><h2 id="fd3e" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">使用k3d创建新的集群:</h2><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="7845" class="lx ly it ov b gy oz pa l pb pc">k3d cluster create</span></pre><p id="8faf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe pd pe pf ov b">kubectl</code>的配置现在将指向k3d集群，您可以用<code class="fe pd pe pf ov b">kubectl config get-clusters</code>来验证它。</p><p id="6b63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查群集是否至少有一个节点，您可以在这里看到我有Kubernetes 1.17，这是一个相对较新的版本:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="6708" class="lx ly it ov b gy oz pa l pb pc">kubectl get node</span><span id="9c90" class="lx ly it ov b gy pg pa l pb pc">NAME                     STATUS   ROLES    AGE   VERSION<br/>k3d-k3s-default-server   Ready    master   48s   v1.17.0+k3s.1</span></pre><p id="524e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将在数据库表中存储我们的TODO项，所以我们现在需要安装一个数据库。Postgresql是一个流行的关系数据库，我们可以使用它的helm chart将它安装到集群中。</p><h2 id="4346" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">安装arkade</h2><p id="cfcf" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">arkade是一个Go CLI，类似于“brew”或“apt-get ”,但用于Kubernetes应用程序。它使用Helm、kubectl或项目的CLI将项目或产品安装到您的集群中。</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="c4fc" class="lx ly it ov b gy oz pa l pb pc">curl -sLS <a class="ae lw" href="https://dl.get-arkade.dev" rel="noopener ugc nofollow" target="_blank">https://get.arkade.dev</a> | sudo sh</span></pre><p id="a169" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你愿意，你可以在没有sudo的情况下运行上面的程序，但是你应该在之后自己把下载的二进制文件移动到<code class="fe pd pe pf ov b">/usr/local/bin</code>。</p><p id="c3e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在安装<a class="ae lw" href="https://www.postgresql.org" rel="noopener ugc nofollow" target="_blank"> Postgresql </a>来存储我们的待办事项列表项:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="2fe6" class="lx ly it ov b gy oz pa l pb pc">arkade install postgresql</span><span id="cdc7" class="lx ly it ov b gy pg pa l pb pc">===================================================================== = PostgreSQL has been installed.                                    =<br/>=====================================================================</span></pre><p id="ddef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还将看到打印出的连接字符串信息，以及如何通过集群内的Docker映像运行Postgresql CLI。</p><p id="4c38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用<code class="fe pd pe pf ov b">arkade info postgresql</code>可以随时获取这些信息。</p><p id="b5ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设计一个表模式</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="593d" class="lx ly it ov b gy oz pa l pb pc">CREATE TABLE todo (<br/>  id              INT GENERATED ALWAYS AS IDENTITY,<br/>  description     text NOT NULL,<br/>  created_date    timestamp NOT NULL,<br/>  completed_date  timestamp NOT NULL<br/>);</span></pre><p id="c99e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行<code class="fe pd pe pf ov b">arkade info postgresql</code>再次获取连接信息，应该类似于:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="957b" class="lx ly it ov b gy oz pa l pb pc">export POSTGRES_PASSWORD=$(kubectl get secret --namespace default postgresql -o jsonpath="{.data.postgresql-password}" | base64 --decode)</span><span id="a6e2" class="lx ly it ov b gy pg pa l pb pc">kubectl run postgresql-client --rm --tty -i --restart='Never' --namespace default --image docker.io/bitnami/postgresql:11.6.0-debian-9-r0 --env="PGPASSWORD=$POSTGRES_PASSWORD" --command -- psql --host postgresql -U postgres -d postgres -p 5432</span></pre><p id="ed68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在您有一个提示，如:<code class="fe pd pe pf ov b">postgres=#</code>，您可以通过粘贴创建表格，然后运行<code class="fe pd pe pf ov b">\dt</code>显示表格:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="95d8" class="lx ly it ov b gy oz pa l pb pc">postgres=# \dt<br/>List of relations<br/>Schema | Name | Type  |  Owner<br/>--------+------+-------+----------<br/>public | todo | table | postgres<br/>(1 row)</span></pre><h2 id="3146" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">安装应用程序框架</h2><p id="29c9" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">就像PHP开发人员通过使用LAMP (Linux Apache + Mysql + PHP)加速他们的工作流，Rails开发人员通过预先构建的堆栈加速他们的工作流一样，Kubernetes开发人员也可以利用应用程序框架。</p><p id="9a6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PLONK栈代表普罗米修斯、Linux、OpenFaaS、NATS和Kubernetes。</p><ul class=""><li id="9a47" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated">Prometheus提供指标、自动扩展和可观察性来检查您的系统的健康状况，并允许它响应需求高峰，并通过提供有关零扩展决策的指标来节省成本。</li><li id="6eab" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">虽然Linux不是在Kubernetes上运行工作负载的唯一选择，但它是默认的，也是最容易使用的。</li><li id="64a9" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">OpenFaaS最初开始为开发人员提供可移植的功能，但在部署API和微服务时也能很好地工作。它的多功能性意味着任何带有HTTP服务器的Docker容器都可以被部署和管理。</li><li id="825c" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">NATS是一个流行的CNCF项目，用于消息传递和发布/订阅。在PLONK栈中，它提供了异步运行请求和排队的能力。</li><li id="a300" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">库伯内特是我们在这里的原因。它提供了横向扩展、自我修复和声明式基础架构。如果你不需要大部分，它的API通过OpenFaaS变得很简单。</li></ul><p id="8e4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过arkade安装PLONK堆栈:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="08a9" class="lx ly it ov b gy oz pa l pb pc">arkade install openfaas</span></pre><p id="1d31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">阅读信息消息并运行每个命令:</p><ul class=""><li id="79e3" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated">安装faas-cli</li><li id="26ea" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">获取您的密码</li><li id="e1da" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">端口转发OpenFaaS网关UI(通过端口8080)</li><li id="9b50" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">并通过CLI登录</li></ul><p id="b8a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像以前一样，您可以通过<code class="fe pd pe pf ov b">arkade info openfaas</code>获得信息消息。</p><h2 id="a6d2" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">部署您的第一个Go API</h2><p id="a3d3" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">用PLONK创建Go API有多种方法。第一种选择是使用docker文件，手动定义TCP端口、健康检查、HTTP服务器等等。这可以通过<code class="fe pd pe pf ov b">faas-cli new --lang dockerfile API_NAME</code>完成，但是有一种更简单、更少人工的方法。</p><p id="b9d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二种方法是利用函数商店提供的预建模板:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="8c1f" class="lx ly it ov b gy oz pa l pb pc">faas-cli template store list | grep go</span><span id="9816" class="lx ly it ov b gy pg pa l pb pc">go                       openfaas           Classic Golang template<br/>golang-http              openfaas-incubator Golang HTTP template<br/>golang-middleware        openfaas-incubator Golang Middleware template</span></pre><p id="30df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们想要创建一个传统的HTTP风格的API，golang中间件模板将是最合适的。</p><p id="f38d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程的开始，您注册了一个Docker Hub帐户来存储您的Docker图像。Kubernetes中的每个工作负载在部署之前都需要构建到Docker映像中。</p><p id="89fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">拉入特殊模板:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="3236" class="lx ly it ov b gy oz pa l pb pc">faas-cli template store pull golang-middleware</span></pre><p id="120b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用golang中间件和您的Docker Hub用户名搭建API:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="31bc" class="lx ly it ov b gy oz pa l pb pc">export PREFIX=alexellis2<br/>export LANG=golang-middleware<br/>export API_NAME=todo</span><span id="6710" class="lx ly it ov b gy pg pa l pb pc">faas-cli new --lang $LANG --prefix $PREFIX $API_NAME</span></pre><p id="d2c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将看到生成了两个文件:</p><ul class=""><li id="a7b8" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated"><code class="fe pd pe pf ov b">./todo.yml</code> —提供一种配置部署以及设置其模板和名称的方法</li><li id="b419" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated"><code class="fe pd pe pf ov b">./todo/handler.go</code> —这是您编写代码和添加您需要的任何其他文件或包的地方</li></ul><p id="eaf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们快速编辑一下，然后部署代码。</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="9222" class="lx ly it ov b gy oz pa l pb pc">package function</span><span id="1383" class="lx ly it ov b gy pg pa l pb pc">import (<br/>    "net/http"<br/>    "encoding/json"<br/>)</span><span id="d515" class="lx ly it ov b gy pg pa l pb pc">type Todo struct {<br/>    Description string `json:"description"`<br/>}</span><span id="6839" class="lx ly it ov b gy pg pa l pb pc">func Handle(w http.ResponseWriter, r *http.Request) {<br/>    todos := []Todo{}<br/>    todos = append(todos, Todo{Description: "Run faas-cli up"})</span><span id="0723" class="lx ly it ov b gy pg pa l pb pc">    res, _ := json.Marshal(todos)</span><span id="a079" class="lx ly it ov b gy pg pa l pb pc">    w.WriteHeader(http.StatusOK)<br/>    w.Header().Set("Content-Type", "application/json")</span><span id="ff7a" class="lx ly it ov b gy pg pa l pb pc">    w.Write([]byte(res))<br/>}</span></pre><p id="4b0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您没有使用VScode及其插件来编辑和格式化代码，那么在每次更改后运行它以确保文件被正确格式化。</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="767d" class="lx ly it ov b gy oz pa l pb pc">gofmt -w -s ./todo/handler.go</span></pre><p id="47cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，通过构建一个新的映像来部署代码，将其推送到Docker Hub，并通过OpenFaaS API将其部署到集群:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="93fd" class="lx ly it ov b gy oz pa l pb pc">Invoke your endpoint when ready:</span><span id="39bd" class="lx ly it ov b gy pg pa l pb pc">curl <a class="ae lw" href="http://127.0.0.1:8080/function/todo" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/todo</a></span><span id="2c43" class="lx ly it ov b gy pg pa l pb pc">{<br/> "description": "Run faas-cli up"<br/>}</span></pre><h2 id="8706" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">允许用户创建新的待办事项</h2><p id="affc" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">现在允许用户在其待办事项列表中创建新项目。首先，您需要为Go向Postgresql库添加一个引用或“依赖项”。</p><p id="199e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过销售或Go 1.11中引入的Go模块来实现这一点，这些模块在Go 1.13中被设置为默认设置。</p><p id="16e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编辑<code class="fe pd pe pf ov b">handler.go</code>并添加我们访问Postgresql所需的模块:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="5a8c" class="lx ly it ov b gy oz pa l pb pc">import (<br/>    "database/sql"<br/>    _ "github.com/lib/pq"<br/>...</span></pre><p id="83c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让Go模块检测到依赖关系，我们必须在文件中声明一些东西，我们将在后面使用，如果我们不这样做，那么VSCode将在保存时删除这些行。</p><p id="a66f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将此添加到导入下的文件中</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="be9e" class="lx ly it ov b gy oz pa l pb pc">var db *sql.DB</span></pre><p id="9d44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总是在<code class="fe pd pe pf ov b">handler.go</code>所在的<code class="fe pd pe pf ov b">todo</code>文件夹中运行这些命令，而不是在有<code class="fe pd pe pf ov b">todo.yml</code>的根目录下。</p><p id="3aed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">初始化新的Go模块:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="4d57" class="lx ly it ov b gy oz pa l pb pc">cd todo/<br/>ls<br/>handler.go</span><span id="66b5" class="lx ly it ov b gy pg pa l pb pc">export GO111MODULE=on<br/>go mod init</span></pre><p id="bead" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在用pq库更新文件:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="b50a" class="lx ly it ov b gy oz pa l pb pc">go get<br/>go mod tidy</span><span id="f8a0" class="lx ly it ov b gy pg pa l pb pc">cat go.mod</span><span id="79ff" class="lx ly it ov b gy pg pa l pb pc">module github.com/alexellis/todo1/todo</span><span id="a6a7" class="lx ly it ov b gy pg pa l pb pc">go 1.17</span><span id="aa4c" class="lx ly it ov b gy pg pa l pb pc">require github.com/lib/pq v1.3.0</span></pre><p id="8838" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论你在<code class="fe pd pe pf ov b">go.mod</code>里看到什么内容，把它们复制到<code class="fe pd pe pf ov b">GO_REPLACE.txt</code></p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="abbf" class="lx ly it ov b gy oz pa l pb pc">cat go.mod &gt; GO_REPLACE.txt</span></pre><p id="0bcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在为insert添加额外的代码之前，让我们检查一下构建是否仍然有效。</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="fc86" class="lx ly it ov b gy oz pa l pb pc">faas-cli build -f todo.yml --build-arg GO111MODULE=on</span></pre><p id="0f03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到我们现在传递了一个<code class="fe pd pe pf ov b">--build-arg</code>来告诉模板使用Go模块。</p><blockquote class="ko kp kq"><p id="51c0" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">截至2022年，你不再需要为这个OpenFaaS模板添加<code class="fe pd pe pf ov b">--build-arg GO111MODULE=on</code>，因为这是一个新的默认设置。</p></blockquote><p id="e372" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在构建过程中，您会看到这些模块是根据需要从互联网上下载的。</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="7ef5" class="lx ly it ov b gy oz pa l pb pc">Step 16/29 : RUN go test ./... -cover<br/> ---&gt; Running in 9a4017438500<br/>go: downloading github.com/lib/pq v1.3.0<br/>go: extracting github.com/lib/pq v1.3.0<br/>go: finding github.com/lib/pq v1.3.0<br/>?       github.com/alexellis/todo1/todo [no test files]<br/>Removing intermediate container 9a4017438500</span></pre><h2 id="9852" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">配置密码以访问Postgresql</h2><p id="e459" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">我们可以在<code class="fe pd pe pf ov b">init()</code>方法中建立一个连接池，它在程序启动时只运行一次。</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="37e0" class="lx ly it ov b gy oz pa l pb pc">// init establishes a persistent connection to the remote database<br/>// the function will panic if it cannot establish a link and the<br/>// container will restart / go into a crash/back-off loop<br/>func init() {</span><span id="f30e" class="lx ly it ov b gy pg pa l pb pc">        if _, err := os.Stat("/var/openfaas/secrets/password"); err == nil {<br/>                password, _ := sdk.ReadSecret("password")<br/>                user, _ := sdk.ReadSecret("username")<br/>                host, _ := sdk.ReadSecret("host")<br/>                dbName := os.Getenv("postgres_db")<br/>                port := os.Getenv("postgres_port")<br/>                sslmode := os.Getenv("postgres_sslmode")</span><span id="00c8" class="lx ly it ov b gy pg pa l pb pc">                connStr := "postgres://" + user + ":" + password + "@" + host + ":" + port + "/" + dbName + "?sslmode=" + sslmode</span><span id="9d5e" class="lx ly it ov b gy pg pa l pb pc">var err error<br/>                db, err = sql.Open("postgres", connStr)</span><span id="a702" class="lx ly it ov b gy pg pa l pb pc">                if err != nil {<br/>                        panic(err.Error())<br/>                }</span><span id="fb20" class="lx ly it ov b gy pg pa l pb pc">                err = db.Ping()<br/>                if err != nil {<br/>                        panic(err.Error())<br/>                }<br/>        }<br/>}</span></pre><p id="7f44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到一些信息是从<code class="fe pd pe pf ov b">os.Getenv</code>环境中读取的。这些值是我认为非机密的，它们在todo.yml文件中设置。</p><p id="b5e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于其他的，比如密码和主机，这些都是保密的，存储在<a class="ae lw" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> Kubernetes secrets </a>中。</p><p id="2bd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过<code class="fe pd pe pf ov b">faas-cli secret create</code>或<code class="fe pd pe pf ov b">kubectl create secret generic -n openfaas-fn</code>创建这些。</p><p id="a742" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">行<code class="fe pd pe pf ov b">sdk.ReadSecret</code>来自OpenFaaS Cloud SDK，具有以下导入:<code class="fe pd pe pf ov b">github.com/openfaas/openfaas-cloud/sdk</code>。它从磁盘中读取秘密文件并返回一个值或一个错误。</p><p id="7de0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从<code class="fe pd pe pf ov b">arkade info postgresql</code>获取秘密值。</p><p id="0bb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，对每个密码运行以下命令:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="329d" class="lx ly it ov b gy oz pa l pb pc">export POSTGRES_PASSWORD=$(kubectl get secret --namespace default postgresql -o jsonpath="{.data.postgresql-password}" | base64 --decode)</span><span id="f04a" class="lx ly it ov b gy pg pa l pb pc">export USERNAME="postgres"<br/>export PASSWORD=$POSTGRES_PASSWORD<br/>export HOST="postgresql.default"</span><span id="2efc" class="lx ly it ov b gy pg pa l pb pc">faas-cli secret create username --from-literal $USERNAME<br/>faas-cli secret create password --from-literal $PASSWORD<br/>faas-cli secret create host --from-literal $HOST</span></pre><p id="b45c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查机密是否如预期的那样存在:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="56c7" class="lx ly it ov b gy oz pa l pb pc">faas-cli secret ls<br/>NAME<br/>username<br/>password<br/>host</span><span id="deab" class="lx ly it ov b gy pg pa l pb pc"># And via kubectl:</span><span id="0439" class="lx ly it ov b gy pg pa l pb pc">kubectl get secret -n openfaas-fn<br/>NAME                  TYPE                                  DATA   AGE<br/>username              Opaque                                1      13s<br/>password              Opaque                                1      13s<br/>host                  Opaque                                1      12s</span></pre><p id="b5a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编辑您的YAML文件，并添加以下内容:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="76f0" class="lx ly it ov b gy oz pa l pb pc">secrets:<br/>    - host<br/>    - password<br/>    - username<br/>    environment:<br/>      postgres_db: postgres<br/>      postgres_sslmode: "disable"<br/>      postgres_port: 5432</span></pre><p id="636e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，更新Go模块并再次运行构建:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="a538" class="lx ly it ov b gy oz pa l pb pc">cd todo<br/>go get<br/>go mod tidy</span><span id="0372" class="lx ly it ov b gy pg pa l pb pc">cd ..</span><span id="ff99" class="lx ly it ov b gy pg pa l pb pc">faas-cli build -f todo.yml --build-arg GO111MODULE=on</span><span id="81ef" class="lx ly it ov b gy pg pa l pb pc">Successfully built d2c609f8f559<br/>Successfully tagged alexellis2/todo:latest<br/>Image: alexellis2/todo:latest built.<br/>[0] &lt; Building todo done in 22.50s.<br/>[0] Worker done.</span><span id="2e89" class="lx ly it ov b gy pg pa l pb pc">Total build time: 22.50s</span></pre><p id="b0c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建按预期工作，所以使用相同的参数运行<code class="fe pd pe pf ov b">faas-cli up</code>来推送和部署映像。如果凭据和SQL配置是正确的，我们将不会在日志中看到错误，但是如果它们是错误的，我们将在init()中显示紧急代码。</p><p id="7a97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查日志:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="bff7" class="lx ly it ov b gy oz pa l pb pc">faas-cli logs todo</span><span id="0e08" class="lx ly it ov b gy pg pa l pb pc">2020-03-26T14:10:03Z Forking - ./handler []<br/>2020-03-26T14:10:03Z 2020/03/26 14:10:03 Started logging stderr from function.<br/>2020-03-26T14:10:03Z 2020/03/26 14:10:03 Started logging stdout from function.<br/>2020-03-26T14:10:03Z 2020/03/26 14:10:03 OperationalMode: http<br/>2020-03-26T14:10:03Z 2020/03/26 14:10:03 Timeouts: read: 10s, write: 10s hard: 10s.<br/>2020-03-26T14:10:03Z 2020/03/26 14:10:03 Listening on port: 8080<br/>2020-03-26T14:10:03Z 2020/03/26 14:10:03 Metrics listening on port: 8081<br/>2020-03-26T14:10:03Z 2020/03/26 14:10:03 Writing lock-file to: /tmp/.lock</span></pre><p id="3418" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止一切正常，现在尝试调用端点:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="5563" class="lx ly it ov b gy oz pa l pb pc">echo | faas-cli invoke todo -f todo.yml</span><span id="71ff" class="lx ly it ov b gy pg pa l pb pc">2020-03-26T14:11:02Z 2020/03/26 14:11:02 POST / - 200 OK - ContentLength: 35</span></pre><p id="7627" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们现在已经成功建立了数据库连接，可以执行插入操作了。我们怎么知道的？因为<code class="fe pd pe pf ov b">db.Ping()</code>返回一个错误，否则会抛出一个异常:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="5f87" class="lx ly it ov b gy oz pa l pb pc">err = db.Ping()<br/>if err != nil {<br/>    panic(err.Error())<br/>}</span></pre><p id="4d13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参见<a class="ae lw" href="https://golang.org/pkg/database/sql/" rel="noopener ugc nofollow" target="_blank">数据库/sql包</a>的完整参考。</p><h2 id="7582" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">编写插入代码</h2><p id="1f7c" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">这段代码将一个新的tow插入到<code class="fe pd pe pf ov b">todo</code>表中，并使用一种特殊的语法，其中的值没有被引用，而是被db替换。查询代码。在LAMP编程的“旧时代”,导致许多系统不安全的一个常见错误是没有对输入进行净化，没有将用户输入直接连接到SQL语句中。</p><p id="2d2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一下有人有一个<code class="fe pd pe pf ov b">; drop table todo</code>的描述输入，那就不好玩了。</p><p id="db6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们运行<code class="fe pd pe pf ov b">db.Query</code>，然后传入SQL语句，对每个值使用<code class="fe pd pe pf ov b">$1, $2</code>等，然后可以检索结果和/或错误。我们还应该关闭这个结果，因此使用defer。</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="8ecc" class="lx ly it ov b gy oz pa l pb pc">func insert(description string) error {<br/>        res, err := db.Query(`insert into todo (id, description, created_date) values (DEFAULT, $1, now());`,<br/>                description)</span><span id="04a9" class="lx ly it ov b gy pg pa l pb pc">        if err != nil {<br/>                return err<br/>        }</span><span id="02f8" class="lx ly it ov b gy pg pa l pb pc">        defer res.Close()<br/>        return nil<br/>}</span></pre><p id="5613" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们把它加入到代码中。</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="49c9" class="lx ly it ov b gy oz pa l pb pc">func Handle(w http.ResponseWriter, r *http.Request) {<br/>        if r.Method == http.MethodPost &amp;&amp; r.URL.Path == "/create" {<br/>                defer r.Body.Close()<br/>                body, _ := ioutil.ReadAll(r.Body)</span><span id="d3ad" class="lx ly it ov b gy pg pa l pb pc">                if err := insert(string(body)); err != nil {<br/>                        http.Error(w, fmt.Sprintf("unable to insert todo: %s", err.Error()), http.StatusInternalServerError)<br/>                }<br/>        }<br/>}</span></pre><p id="d0a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们部署并试用它？</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="3dc7" class="lx ly it ov b gy oz pa l pb pc">echo | faas-cli invoke todo -f todo.yml</span><span id="ab92" class="lx ly it ov b gy pg pa l pb pc">curl <a class="ae lw" href="http://127.0.0.1:8080/function/todo/create" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/todo/create</a> --data "faas-cli build"<br/>curl <a class="ae lw" href="http://127.0.0.1:8080/function/todo/create" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/todo/create</a> --data "faas-cli push"<br/>curl <a class="ae lw" href="http://127.0.0.1:8080/function/todo/create" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/todo/create</a> --data "faas-cli deploy"</span></pre><p id="c48c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查API的日志:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="5a39" class="lx ly it ov b gy oz pa l pb pc">faas-cli logs todo</span><span id="8e65" class="lx ly it ov b gy pg pa l pb pc">2020-03-26T14:35:29Z 2020/03/26 14:35:29 POST /create - 200 OK - ContentLength: 0</span></pre><p id="cbd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用pgsql检查表格内容:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="94c1" class="lx ly it ov b gy oz pa l pb pc">export POSTGRES_PASSWORD=$(kubectl get secret --namespace default postgresql -o jsonpath="{.data.postgresql-password}" | base64 --decode)</span><span id="0bbd" class="lx ly it ov b gy pg pa l pb pc">kubectl run postgresql-client --rm --tty -i --restart='Never' --namespace default --image docker.io/bitnami/postgresql:11.6.0-debian-9-r0 --env="PGPASSWORD=$POSTGRES_PASSWORD" --command -- psql --host postgresql -U postgres -d postgres -p 5432</span><span id="7f82" class="lx ly it ov b gy pg pa l pb pc">postgres=# select * from todo;<br/>id |   description   |        created_date        | completed_date<br/>----+-----------------+----------------------------+----------------<br/>1 | faas-cli build  | 2020-03-26 14:36:03.367789 |<br/>2 | faas-cli push   | 2020-03-26 14:36:03.389656 |<br/>3 | faas-cli deploy | 2020-03-26 14:36:03.797881 |</span></pre><p id="2851" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">恭喜，您现在有了一个todo API，它可以通过<code class="fe pd pe pf ov b">curl</code>或任何其他HTTP客户端接受传入的请求，并将它们记录在数据库表中。</p><h2 id="70ae" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">查询待办事项</h2><p id="8d90" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">让我们创建一个新函数来查询表中的todo项:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="881a" class="lx ly it ov b gy oz pa l pb pc">func selectTodos() ([]Todo, error) {<br/>    var error err<br/>    var todos []Todo</span><span id="a696" class="lx ly it ov b gy pg pa l pb pc">    return todos, err<br/>}</span></pre><p id="2294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不能调用这个方法select，因为那是一个保留的关键字，用于处理go例程。</p><p id="5958" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在将该方法挂接到主处理程序中:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="f811" class="lx ly it ov b gy oz pa l pb pc">} else if r.Method == http.MethodGet &amp;&amp; r.URL.Path == "/list" {<br/>    todos, err := selectTodos()</span><span id="ef66" class="lx ly it ov b gy pg pa l pb pc">    if err != nil {</span><span id="afa9" class="lx ly it ov b gy pg pa l pb pc">        http.Error(w, fmt.Sprintf("unable to get todos: %s", err.Error()), http.StatusInternalServerError)</span><span id="7426" class="lx ly it ov b gy pg pa l pb pc">    }</span><span id="5750" class="lx ly it ov b gy pg pa l pb pc">    out, _ := json.Marshal(todos)<br/>    w.Header().Set("Content-Type", "application/json")<br/>    w.Write(out)<br/>}</span></pre><p id="2e87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的数据模式中有了额外的日期字段，更新Todo结构:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="ab1d" class="lx ly it ov b gy oz pa l pb pc">type Todo struct {<br/>    ID int `json:"id"`<br/>    Description   string `json:"description"`<br/>    CreatedDate   *time.Time `json:"created_date"`<br/>    CompletedDate *time.Time `json:"completed_date"`<br/>}</span></pre><p id="a4e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们用查询代码更新我们的<code class="fe pd pe pf ov b">selectTodos()</code>方法:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="0b0f" class="lx ly it ov b gy oz pa l pb pc">func selectTodos() ([]Todo, error) {<br/>        rows, getErr := db.Query(`select id, description, created_date, completed_date from todo;`)</span><span id="d22f" class="lx ly it ov b gy pg pa l pb pc">    if getErr != nil {<br/>        return []Todo{}, errors.Wrap(getErr, "unable to get from todo table")<br/>    }</span><span id="ec82" class="lx ly it ov b gy pg pa l pb pc">    todos := []Todo{}<br/>    defer rows.Close()<br/>    for rows.Next() {<br/>        result := Todo{}<br/>        scanErr := rows.Scan(&amp;result.ID, &amp;result.Description, &amp;result.CreatedDate, &amp;result.CompletedDate)<br/>        if scanErr != nil {<br/>            log.Println("scan err:", scanErr)<br/>        }<br/>        todos = append(todos, result)<br/>    }<br/>    return todos, nil<br/>}</span></pre><p id="6c05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像以前一样，我们需要推迟查询行的关闭。每个值都通过行插入到一个新的结构中。扫描方法。在方法的末尾，我们有一部分Todo项。</p><p id="2f2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尝试一下:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="fa15" class="lx ly it ov b gy oz pa l pb pc">faas-cli up -f todo.yml --build-arg GO111MODULE=on</span><span id="199c" class="lx ly it ov b gy pg pa l pb pc">curl http://127.0.0.1:8080/function/todo/list</span></pre><p id="a6d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果如下:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="a068" class="lx ly it ov b gy oz pa l pb pc">[<br/>  {<br/>    "id": 2,<br/>    "description": "faas-cli build",<br/>    "created_date": "2020-03-26T14:36:03.367789Z",<br/>    "completed_date": null<br/>  },<br/>  {<br/>    "id": 3,<br/>    "description": "faas-cli push",<br/>    "created_date": "2020-03-26T14:36:03.389656Z",<br/>    "completed_date": null<br/>  },<br/>  {<br/>    "id": 4,<br/>    "description": "faas-cli deploy",<br/>    "created_date": "2020-03-26T14:36:03.797881Z",<br/>    "completed_date": null<br/>  }<br/>]</span></pre><p id="5f9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了移除空值，我们可以更新结构的注释来添加<code class="fe pd pe pf ov b">omitempty</code>:</p><pre class="oq or os ot gt ou ov ow ox aw oy bi"><span id="5e9e" class="lx ly it ov b gy oz pa l pb pc">CompletedDate *time.Time `json:"completed_date,omitempty"`</span></pre><h1 id="ff31" class="nz ly it bd lz oa ob oc mc od oe of mf og oh oi mi oj ok ol ml om on oo mo op bi translated">结束本次会议</h1><p id="945c" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">我们还没有完成，但这是一个停下来回顾我们迄今为止所取得的成就的好时机。</p><ul class=""><li id="d273" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated">安装了Go、Docker、kubectl和VSCode(一个IDE)</li><li id="67f3" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">在我们的本地机器上部署Kubernetes</li><li id="0945" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">使用arkade和helm3安装Postgresql</li><li id="51b2" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">为Kubernetes应用程序开发人员安装了OpenFaaS和PLONK堆栈</li><li id="1318" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">使用Go和OpenFaaS <code class="fe pd pe pf ov b">golang-middleware </code>模板构建了一个初始的静态REST API</li><li id="4d8f" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">在我们的TODO API中添加了“插入”功能</li><li id="8f83" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">在我们的TODO API中添加了“选择”功能</li></ul><p id="3552" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的GitHub帐户上有我们迄今为止构建的完整代码示例:</p><div class="mv mw gp gr mx my"><a href="https://github.com/alexellis/kubernetes-todo-go-app" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">alexellis/kubernetes-todo-go-app</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">一个用go写的Kubernetes的TODO API。为alexellis/kubernetes-todo-go-app开发做出贡献，创建一个…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">github.com</p></div></div><div class="nh l"><div class="pm l nj nk nl nh nm lq my"/></div></div></a></div><p id="2509" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以做更多的事情，例如:</p><ul class=""><li id="e863" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated">使用静态承载令牌添加身份验证</li><li id="d822" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">使用静态HTML模板创建网页，或者React呈现待办事项列表并创建新项目</li><li id="709b" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated">向API添加多用户支持</li></ul><p id="a7bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有更多。我们还可以深入到PLONK栈中，部署一个Grafana仪表板，开始观察我们的API，了解Kubernetes仪表板或metrics-server(通过<code class="fe pd pe pf ov b">arkade install</code>安装)使用了多少资源</p><ul class=""><li id="c1dc" class="nn no it js b jt ju jx jy kb nw kf nx kj ny kn ns nt nu nv bi translated">在 GitHub上主演<a class="ae lw" href="https://arkade.dev/" rel="noopener ugc nofollow" target="_blank"> arkade</a></li><li id="1b41" class="nn no it js b jt ph jx pi kb pj kf pk kj pl kn ns nt nu nv bi translated"><a class="ae lw" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank">探索OpenFaaS </a></li></ul><p id="f64f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能还会喜欢<a class="ae lw" href="https://openfaas.gumroad.com/l/everyday-golang" rel="noopener ugc nofollow" target="_blank">我的电子书《天天向上》</a>——里面有很多例子，你可以在本教程的基础上使用和扩展:</p><div class="mv mw gp gr mx my"><a href="https://openfaas.gumroad.com/l/everyday-golang" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">日常Golang</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">“日常生活”是从生产中使用的真实工具中学习工具、技术和模式的快捷方式。这本书是一本…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">openfaas.gumroad.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm lq my"/></div></div></a></div></div></div>    
</body>
</html>