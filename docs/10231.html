<html>
<head>
<title>How To Make Your Pytest Tests as DRY as Bone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让你的Pytest测试像骨头一样干燥</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-make-your-pytest-tests-as-dry-as-bone-e9c1c35ddcb4?source=collection_archive---------7-----------------------#2021-11-09">https://levelup.gitconnected.com/how-to-make-your-pytest-tests-as-dry-as-bone-e9c1c35ddcb4?source=collection_archive---------7-----------------------#2021-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c1d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用固定物并将其参数化，让您和您的评审者都满意</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/46379700363267a7a8db885a7d3fe28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fgSDahSIOMGujb6t"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mparente?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米凯拉父母</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="9901" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="3a3e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Pytest附带了一系列不错的语法特性，所有Python开发人员都应该了解并经常使用这些特性。为什么会这样？因为，当你使用它们时，你将会极大地提高你的测试代码的质量，甚至更重要的是，当你写测试时，你的心情。在之前的文章中，我谈到了参数化Pytest测试。今天，我们来看看<em class="mn">固定装置</em>以及如何充分利用它们。你准备好了吗？让我们深入问题！</p><h1 id="e91d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">问题是</h1><p id="872c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Pytest中编写测试时，我使用最多的一个特性是<a class="ae ky" href="https://docs.pytest.org/en/6.2.x/fixture.html" rel="noopener ugc nofollow" target="_blank">fixture</a>。你现在可能会说:等等，什么是<em class="mn">夹具</em>？这里有一个简单的介绍。</p><p id="bb19" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Fixtures是允许您可靠地、可重复地安排您的测试所依赖的或者可以利用的东西的构造。有了fixtures，你还可以让你的代码更简洁，可读性更强。我最常使用夹具的情况如下:</p><ol class=""><li id="b793" class="mt mu it lt b lu mo lx mp ma mv me mw mi mx mm my mz na nb bi translated">执行复杂的测试设置，比如启动和结束测试所依赖的服务。</li><li id="a141" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">创建可以在测试中使用的复杂对象。</li></ol><p id="1e71" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这听起来可能有点抽象，但是它们的用法非常简单，最好用一些代码来解释，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="976b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">那么，我们在这里做了什么？我们定义了两个函数<code class="fe nj nk nl nm b">medium_dict</code>和<code class="fe nj nk nl nm b">setup_some_service.</code>，它们都用<code class="fe nj nk nl nm b">pytest.fixture</code>来修饰，这将一个无辜的函数变成了一个夹具:)。</p><p id="c940" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">要使用fixture或其返回值，您所要做的就是向您的测试函数添加一个与fixture同名的参数。在我们的例子中，那就是<code class="fe nj nk nl nm b">medium_dict</code>和<code class="fe nj nk nl nm b">setup_some_service</code>。正如您所看到的，您可以向您的测试函数传递任意多的fixtures。您还可以将一个fixture传递给一个fixture，并在那里使用它。所以它们非常灵活。</p><p id="7204" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">超级棒的是，你可以从固定装置上<code class="fe nj nk nl nm b">yield</code>。这样，<code class="fe nj nk nl nm b">yield</code>关键字之前的所有内容都会在测试函数执行之前运行。测试完成后，<code class="fe nj nk nl nm b">yield</code>关键字之后的所有内容都会被执行。这是一种简单的测试设置和拆卸方法。</p><p id="e721" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">顺便提一下，如果您在测试的顶层添加一个conftest.py文件，并在其中定义fixture，那么您的所有测试都将能够使用这些fixture。自动地。没有任何显式导入。这一方面有点怪异，但也很方便:)。</p><p id="ae94" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在我们知道了什么是夹具以及如何利用它们，我们来看实际问题:如何使夹具更加灵活？或者换句话说，我们如何参数化一个fixture来改变它的行为？</p><h1 id="469e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">解决方案</h1><p id="4bb0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要参数化一个fixture，我们实际上只需要三样东西。首先，我们必须向<code class="fe nj nk nl nm b">pytest.fixture</code>装饰器添加一个名为<code class="fe nj nk nl nm b"><em class="mn">params</em></code>的参数。其次，我们必须给fixture的函数参数添加一个名为<code class="fe nj nk nl nm b"><em class="mn">request</em></code>的参数。第三，使用<code class="fe nj nk nl nm b">pytest.mark.parameterize</code>和indirect关键字来设置实际的参数值。</p><p id="20f1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">同样，这可能不是非常清楚，所以下面的代码应该能更清楚地说明这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7a96" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在这里，我向您展示了一个名为<code class="fe nj nk nl nm b">complex_object</code>的fixture，它有一个名为<em class="mn"> request </em>的参数。通过<em class="mn">请求</em>，您可以使用其<em class="mn"> param </em>属性访问分配的参数。</p><p id="c11e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">此外，我已经向fixture装饰器添加了参数<em class="mn"> params </em>。这样，您可以为参数化夹具定义默认值。正如您从测试函数<code class="fe nj nk nl nm b">test_with_complex_object_default_value</code>中看到的，这允许您使用那种夹具，而无需任何额外的代码。注意，您必须<em class="mn">为params参数</em>分配一个iterable。这样，您就可以拥有多个默认值，并且对于这些值中的每一个，都会生成一个测试。如果你只需要一个，那么你的iterable的长度必须是1。</p><p id="2fe4" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在，如果您对fixture的默认参数不满意，您可以使用<code class="fe nj nk nl nm b">pytest.mark.parameterize</code>装饰器来更改它们。这里您所要做的就是添加您想要修饰的fixture的名称作为第一个参数，添加新的值作为第二个参数，并将关键字参数<code class="fe nj nk nl nm b">indirect</code>设置为True。这就是你在<code class="fe nj nk nl nm b">test_with_complex_object</code>函数中看到的。在这个例子中，您将得到两个测试，其中<code class="fe nj nk nl nm b">complex_object</code>分别用["a"]和["a "，" b"]参数化。</p><p id="6e15" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">很简单，不是吗？</p><h1 id="ab4a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="8ade" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇简短的帖子中，我向您展示了如何编写fixtures，更重要的是，您如何对它们进行参数化。如果您在您的测试代码中应用了这一点，我相信您可以减少测试代码的行数，同时进行更多的测试。</p><p id="8bbe" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">感谢您关注这篇文章。和往常一样，你可以在<a class="ae ky" href="https://www.linkedin.com/in/simon-hawe-75832057/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上随意联系。</p></div></div>    
</body>
</html>