<html>
<head>
<title>A Better Way to use GraphQL Fragments in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中使用GraphQL片段的更好方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-better-way-to-use-graphql-fragments-in-react-4f54bf862062?source=collection_archive---------5-----------------------#2020-05-12">https://levelup.gitconnected.com/a-better-way-to-use-graphql-fragments-in-react-4f54bf862062?source=collection_archive---------5-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb37" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在呈现数据的组件中定义片段有很多好处。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2223f4452fbb011b8f3eaf1f19f6e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDn52T71hdnNV2WTpkca2w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae ky" href="https://unsplash.com/s/photos/reaching?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用基于组件的框架(React，Vue)的一个重要原因是它允许更隔离的组件设计，这有助于解耦和单元测试。另一个好处是使用展示应用，如<a class="ae ky" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank">故事书</a>。这些延续了隔离的理念，允许在主应用程序之外进行设计和原型制作。</p><p id="b8c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当组件数量开始增长并且我们开始获取数据时，我们需要一个新的模式，<a class="ae ky" href="https://learn.co/lessons/react-container-components" rel="noopener ugc nofollow" target="_blank">容器组件模式</a>。如果使用GraphQL进行数据传输，我们希望继续使用这种模式，但是有了新的变化。创建独立组件时，他们应该定义需要呈现的数据。这可以通过每个组件来更好地实现，甚至是表示性的组件，定义它们需要用自己的GraphQL片段来呈现的数据。</p><h1 id="7cab" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">显示时间</strong></h1><p id="d3c6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们有一个组件来呈现一个显示标题的Github问题列表。在容器组件模式中，我们有一个“容器”组件<code class="fe ms mt mu mv b">GithubIssueListContainer</code>，它处理查询的运行。之后，它将数据传递给需要它呈现的表示组件<code class="fe ms mt mu mv b">GithubIssueInfoCard</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cf14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题是，<code class="fe ms mt mu mv b">GithubIssueInfoCard</code>依赖于它的父组件来了解GraphQL图中的数据来自哪里。</p><p id="e0d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想从图中呈现一个新的字段，例如<code class="fe ms mt mu mv b">labels</code>，我们需要将它添加到<code class="fe ms mt mu mv b">GithubIssueListContainer</code>中的查询中，并通过props传递给<code class="fe ms mt mu mv b">GithubIssueInfoCard</code>。这需要修改<code class="fe ms mt mu mv b">GithubIssueListContainer</code>中的查询和<code class="fe ms mt mu mv b">GithubIssueInfoCard</code>中的属性。</p><h1 id="4f7e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">就是这条路</strong></h1><p id="dd78" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">按照我们的隔离原则，如果<code class="fe ms mt mu mv b">GithubIssueInfoCard</code>定义了它需要从GraphQL图中呈现什么数据，那会怎么样？这样，当我们改变这个组件的数据时，只有这个组件需要改变。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这似乎很奇怪，但好处是值得的。就像编程中的任何事情一样，它不会没有取舍。</p><h1 id="d22f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">好处</strong></h1><h2 id="65d5" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated"><strong class="ak">少母组件耦合</strong></h2><p id="1c90" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当组件定义了它需要呈现的数据时，它将组件与其父组件解耦。例如，如果您想在另一个页面上显示<code class="fe ms mt mu mv b">GithubIssueInfoCard</code>,将片段导入容器组件以获取正确的数据。例如</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="edfb" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated"><strong class="ak">类型变得更容易维护</strong></h2><p id="d400" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果使用TypeScript，您可能会从GraphQL查询中生成类型。我们的新模式的一大好处是在组件中定义道具。您可以从我们生成的类型文件中将它需要呈现的数据定义为一个类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="aa87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当片段改变时，在你生成类型之后，不需要任何修改！</p><h2 id="61c3" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated"><strong class="ak">首先开发组件时更改的机会较少</strong></h2><p id="5d10" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">随着Storybook变得流行，许多开发人员开始首先在Storybook中开发组件，然后在稍后的时间将它们集成到应用程序中。可能出现的情况是，app集成过程中，道具定义错误。</p><p id="a201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义该组件需要呈现的GraphQL图形的片段，由于迫使开发人员知道需要呈现的数据的确切形状，因此在集成时更改代码的机会较少。当然，这只有在预先定义API的情况下才有可能，但有时情况并非总是如此。</p><h1 id="e31b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">取舍</strong></h1><p id="a02e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当然，像编程中的所有事情一样，这种方法也有权衡。值不值得，就看你自己了。</p><h2 id="a247" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated"><strong class="ak">表示性组件不通用</strong></h2><p id="3032" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">糟糕的是，我们的表示组件变得更加耦合到应用程序和API数据模型。如果我们想迁移到一个组件库供其他人使用，这些组件将需要被重构以移除它们的片段。这不是太多的工作，但它比选择更多的工作。</p><h2 id="8b5d" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated"><strong class="ak">碎片有时会变得难以管理</strong></h2><p id="7231" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将许多片段导入到一个GraphQL查询中并不是最好的体验。如果我们在一个容器组件中有许多表示组件，将它们全部导入可能会很麻烦。有时您可能会忘记导入片段，Apollo会返回一些无用的消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="6cd0" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated"><strong class="ak">结论</strong></h2><p id="d9e7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们在Yolk使用这种模式已经有一段时间了，每个人都喜欢它。我们首先在Storybook中开发组件，这迫使开发人员了解数据来自哪里，并询问有关数据模型及其用法的问题。</p></div></div>    
</body>
</html>