<html>
<head>
<title>JavaScript Interview Questions — Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试问题—运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-interview-questions-operators-37c8c35d5eeb?source=collection_archive---------7-----------------------#2020-04-02">https://levelup.gitconnected.com/javascript-interview-questions-operators-37c8c35d5eeb?source=collection_archive---------7-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5667f0da6255f2c033d00dc1c9a9e45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YsOwmDxpS3mIZksw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@johannabuguet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约翰娜·布盖</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e1b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="1044" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些JavaScript操作符问题。</p><h1 id="9cf7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">&amp;&amp;</code>操作符是做什么的？</h1><p id="2692" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">&amp;&amp;</code>操作符是逻辑AND操作符，在其操作数中找到第一个falsy表达式并返回它。</p><p id="b87c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="83eb" class="mt lf it mf b gy mu mv l mw mx">console.log(0 &amp;&amp; 1 &amp;&amp; "foo");</span></pre><p id="cf57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录0，因为0是操作数中的第一个falsy表达式。</p><h1 id="ab3d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">||</code>操作员做什么？</h1><p id="4c49" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">||</code>操作符是逻辑or操作符，在其操作数中找到第一个真值表达式并返回它。</p><p id="0b50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="d7f0" class="mt lf it mf b gy mu mv l mw mx">console.log("" || "foo" || false);</span></pre><p id="51c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录下<code class="fe mc md me mf b">'foo'</code>,因为它是表达式中的第一个真值操作数。</p><p id="d722" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果在它之前的值是假的，它对于提供一个默认值也是有用的。</p><h1 id="226c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">+运算符是做什么的？</h1><p id="67e8" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">+</code>操作符将后面的内容转换成数字，如果它放在表达式前面的话。所以如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="caf3" class="mt lf it mf b gy mu mv l mw mx">console.log(+"1");</span></pre><p id="8a1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录了1。</p><p id="88e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="042f" class="mt lf it mf b gy mu mv l mw mx">console.log(+("1" + 2));</span></pre><p id="99f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录了12次。</p><p id="8f83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所知，它也可以作为括号内字符串的连接操作符。</p><p id="6137" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果所有操作数都是数字，它也是加法运算符。</p><p id="3621" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="778b" class="mt lf it mf b gy mu mv l mw mx">console.log(1 + 2 + 3);</span></pre><p id="60d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到6。</p><h1 id="c18e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这是什么！接线员做什么？</h1><p id="fd30" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">!</code>运算符将操作数转换为布尔值，并对其求反。它会将假值<code class="fe mc md me mf b">true</code>和真值转化为<code class="fe mc md me mf b">false</code>。</p><p id="d47e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="417b" class="mt lf it mf b gy mu mv l mw mx">console.log(!0);<br/>console.log(!"");<br/>console.log(!false);<br/>console.log(!NaN);<br/>console.log(!undefined);<br/>console.log(!null);</span></pre><p id="d2ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后都登录<code class="fe mc md me mf b">true</code>。</p><p id="f854" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mc md me mf b">!</code>放在真值表达式之前，那么它将记录<code class="fe mc md me mf b">false</code>。</p><p id="3637" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="8cd9" class="mt lf it mf b gy mu mv l mw mx">console.log(!<!-- -->1<!-- -->);</span></pre><p id="c5b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会看到<code class="fe mc md me mf b">false</code>被记录。</p><h1 id="473b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这是什么！！接线员做什么？</h1><p id="a36b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">!!</code>是双非运算符，将操作数强制为布尔值。它会将真值转换为<code class="fe mc md me mf b">true</code>，将假值转换为<code class="fe mc md me mf b">false</code>。</p><p id="dea3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="d4ae" class="mt lf it mf b gy mu mv l mw mx">console.log(!!0);<br/>console.log(!!'');<br/>console.log(!!false);<br/>console.log(!!NaN);<br/>console.log(!!undefined);<br/>console.log(!!null);</span></pre><p id="0f7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们会记录<code class="fe mc md me mf b">false</code>。</p><p id="203c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在任何真值表达式之前应用<code class="fe mc md me mf b">!!</code>应返回<code class="fe mc md me mf b">true</code>。</p><p id="09ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="603e" class="mt lf it mf b gy mu mv l mw mx">console.log(!!{});</span></pre><p id="f2b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">日志<code class="fe mc md me mf b">true</code>。</p><h1 id="c0ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">rest运算符是什么？</h1><p id="1ad7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">扩展操作符由<code class="fe mc md me mf b">...</code>表示。</p><p id="6af4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它将析构过程中没有赋值的对象或数组条目赋值给一个包含剩余值数组的变量。</p><p id="122b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果对象是一个变量，我们可以使用rest操作符将没有分配给对象的属性分配给包含原始对象剩余属性的变量。</p><p id="4456" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="f8ea" class="mt lf it mf b gy mu mv l mw mx">const [one, two, ...rest] = [1, 2, 3, 4, 5, 6];<br/>console.log(one);<br/>console.log(two);<br/>console.log(rest);</span></pre><p id="56ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mc md me mf b">one</code>是1<code class="fe mc md me mf b">two</code>是2，<code class="fe mc md me mf b">rest</code>有<code class="fe mc md me mf b">[3, 4, 5, 6]</code>。</p><p id="4b1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还可以用于将对象分散到变量中。例如，我们可以这样做:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="ed5b" class="mt lf it mf b gy mu mv l mw mx">const { foo, bar, ...rest } = { foo: 1, bar: 2, a: 3, b: 4, c: 5 };<br/>console.log(foo);<br/>console.log(bar);<br/>console.log(rest);</span></pre><p id="04e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mc md me mf b">foo</code>是1，<code class="fe mc md me mf b">bar</code>是2，<code class="fe mc md me mf b">rest</code>有<code class="fe mc md me mf b">{a: 3, b: 4, c: 5}</code>。</p><p id="e421" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以用它来获取传递给函数的参数，这个函数没有作为数组赋给它自己的参数。例如，我们可以写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="81b3" class="mt lf it mf b gy mu mv l mw mx">const foo = (a, b, ...rest) =&gt; console.log(rest);<br/>console.log(foo(1, 2, 3, 4, 5));</span></pre><p id="92b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mc md me mf b">console.log</code>应该为<code class="fe mc md me mf b">rest</code>记录<code class="fe mc md me mf b">[3, 4, 5]</code>。</p><h1 id="6bb7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是传播算子？</h1><p id="5aa7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">展开操作符也由<code class="fe mc md me mf b">...</code>操作符指示。它会将一个对象的属性传播到另一个对象，并将数组条目传播到另一个数组。</p><p id="b4a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="b6c1" class="mt lf it mf b gy mu mv l mw mx">const foo = [1, 2, 3];<br/>const bar = [...foo];<br/>console.log(bar);</span></pre><p id="fd44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mc md me mf b">[1, 2, 3]</code>作为<code class="fe mc md me mf b">bar</code>的值，因为我们复制了<code class="fe mc md me mf b">foo</code>并用spread操作符将其分配给<code class="fe mc md me mf b">bar</code>。</p><p id="3b4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它对于合并数组也很有用。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="6cbe" class="mt lf it mf b gy mu mv l mw mx">const foo = [1, 2, 3];<br/>const bar = [3, 4, 5];<br/>const baz = [...foo, ...bar];<br/>console.log(baz);</span></pre><p id="289a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mc md me mf b">baz</code>将会是<code class="fe mc md me mf b">[1, 2, 3, 3, 4, 5]</code>，因为我们将<code class="fe mc md me mf b">foo</code>和<code class="fe mc md me mf b">bar</code>数组的条目合并到了<code class="fe mc md me mf b">baz</code>数组中。</p><p id="8613" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“扩展”操作符也适用于对象。它将制作一个对象的浅拷贝或将多个对象合并成一个。如果两个对象在合并时具有相同的属性，那么后来合并的对象将覆盖第一个对象。</p><p id="abe1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="63f2" class="mt lf it mf b gy mu mv l mw mx">const foo = { a: 1, b: 2, c: 3 };<br/>const bar = { a: 2, d: 4, e: 5 };<br/>const baz = { ...foo, ...bar };<br/>console.log(baz);</span></pre><p id="d89b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mc md me mf b">baz</code>就是<code class="fe mc md me mf b">{a: 2, b: 2, c: 3, d: 4, e: 5}</code>，因为<code class="fe mc md me mf b">bar</code>后来被合并了，所以属性<code class="fe mc md me mf b">a</code> us 2。</p><p id="3962" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">spread运算符也用于将数组扩展到函数中的参数列表中。</p><p id="8339" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="6feb" class="mt lf it mf b gy mu mv l mw mx">const add = (a, b) =&gt; a + b;<br/>console.log(add(...[1, 2, 3, 3, 4, 5]));</span></pre><p id="3c5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mc md me mf b">console.log</code>将显示3，因为数组中的1和2被spread操作符分配给了<code class="fe mc md me mf b">a</code>和<code class="fe mc md me mf b">b</code>参数。</p><h1 id="f978" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="8224" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">&amp;&amp;</code>、<code class="fe mc md me mf b">||</code>、<code class="fe mc md me mf b">!</code>和<code class="fe mc md me mf b">!!</code>是逻辑运算符。</p><p id="34bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">&amp;&amp;</code>操作符是逻辑AND操作符，在操作数中找到第一个falsy表达式并返回它。</p><p id="ad92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">||</code>操作符是逻辑or操作符，在其操作数中找到第一个真值表达式并返回。</p><p id="a617" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">!</code>操作符将一个表达式强制转换为布尔值，然后对其求反。</p><p id="25e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">!!</code>操作符将一个表达式强制转换为没有否定的布尔值。</p><p id="c3a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">+</code>操作符可以将表达式转换为数字，将数字相加，或者连接字符串。</p><p id="362d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">rest操作符对于获取数组或对象的剩余部分很有用。</p><p id="7714" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">spread运算符对于合并对象和数组或制作它们的副本非常有用。它还可以用来将数组作为参数传递给函数。</p></div></div>    
</body>
</html>