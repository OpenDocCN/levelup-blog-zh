<html>
<head>
<title>A Kotlin multi-platform parser usable from a JVM or JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可从JVM或JavaScript使用的Kotlin多平台解析器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-kotlin-multi-platform-parser-usable-from-a-jvm-or-javascript-59e870832a79?source=collection_archive---------10-----------------------#2020-04-09">https://levelup.gitconnected.com/a-kotlin-multi-platform-parser-usable-from-a-jvm-or-javascript-59e870832a79?source=collection_archive---------10-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1397" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当一个正则表达式还不够时，动态的、按需扫描的、GLR解析</h2></div><p id="2d17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AGL的一个目的是为小规模DSL的快速开发提供支持，包括当一个正则表达式不够用，而一个解析器生成器又超出您的需要时的用例。</p><p id="4cc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想要一个能够处理数千行和数百万行代码的成熟编程语言的解析器，那么这个不适合你。试试<a class="ae le" href="https://www.antlr.org/" rel="noopener ugc nofollow" target="_blank"> ANTLR </a>。<a class="ae le" href="https://www.eclipse.org/Xtext/" rel="noopener ugc nofollow" target="_blank"> Xtext </a>、<a class="ae le" href="https://en.wikipedia.org/wiki/Yacc" rel="noopener ugc nofollow" target="_blank"> Yacc </a>等。</p><p id="3200" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您想要一个满足以下要求的解析器，那么AGL就是您想要的。</p><ol class=""><li id="2a13" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">解析器应该在运行时构建(动态地)。<br/>即没有单独的生成代码步骤或单独的工具来生成解析器。</li><li id="fac0" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">书写语法规则应该尽可能直观。<br/>也就是说，我们想写语法而不必担心关于左、右或隐藏递归的限制。即解析器应该处理任何有效的类似EBNF的语法，没有限制。</li><li id="e65c" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">关于保留字没有限制。<br/>即可以定义一个语法，其中关键字可以用作变量名。</li><li id="f85a" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">解析器应该支持语言家族。<br/>即语法作文。</li><li id="8cf7" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">解析器应该既可以在JVM (Java)平台上使用，也可以在浏览器或其他JavaScript平台上使用。</li><li id="917e" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">解析器必须有足够的性能才可用。<br/>也就是说，对于明确的语法，应该能够在1秒钟内解析至少一页文本。</li></ol><p id="eb50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AGL是开源的，<a class="ae le" href="https://github.com/dhakehurst/net.akehurst.language" rel="noopener ugc nofollow" target="_blank">可在github </a>上获得。这是我多年反复试验的结果，因为我了解了解析算法的复杂性。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/ea8254472c53cafb620edb68054317ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*2LfB9yhhINJLuTUCf8-BQA.png"/></div></figure><p id="8142" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然AGL的主要目标是解析，但在处理语言时，其他相关操作也很有用。AGL为语法分析、格式化和代码完成提供了一些基本支持。</p><h2 id="3898" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">其他文章</h2><p id="4f3f" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated"><a class="ae le" href="https://medium.com/javascript-in-plain-english/agl-your-dsl-in-the-web-c9f54595691b" rel="noopener">为文本输入验证创建自定义的领域特定语言</a></p><h1 id="6e7a" class="mz mc it bd md na nb nc mg nd ne nf mj jz ng ka mm kc nh kd mp kf ni kg ms nj bi translated">入门指南</h1><p id="0444" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">该项目是开源的，在github 上有Apache 2.0许可<a class="ae le" href="https://github.com/dhakehurst/net.akehurst.language" rel="noopener ugc nofollow" target="_blank">。科特林模块是在jcenter </a>上发布的<a class="ae le" href="https://jcenter.bintray.com/net/akehurst/language/" rel="noopener ugc nofollow" target="_blank">。另外，</a><a class="ae le" href="https://www.npmjs.com/package/net.akehurst.language-agl-processor" rel="noopener ugc nofollow" target="_blank">Javascript模块在npmjs.com</a>发布。</p><h2 id="7894" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">格拉德勒</h2><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="20c4" class="mb mc it nl b gy np nq l nr ns">dependencies {<br/>  commonMainApi("net.akehurst.language:agl-processor:$version_agl")<br/>}</span><span id="7870" class="mb mc it nl b gy nt nq l nr ns">or</span><span id="5d9b" class="mb mc it nl b gy nt nq l nr ns">dependencies {<br/>  implementation("net.akehurst.language:agl-processor:$version_agl")<br/>}</span></pre><h2 id="6e0c" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">NPM /纱线</h2><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="2999" class="mb mc it nl b gy np nq l nr ns">npm install net.akehurst.language-agl-processor</span><span id="5bb3" class="mb mc it nl b gy nt nq l nr ns">yarn add net.akehurst.language-agl-processor</span></pre><h2 id="47f6" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">科特林</h2><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="10da" class="mb mc it nl b gy np nq l nr ns">import net.akehurst.language.processor.Agl<br/>import net.akehurst.language.api.analyser.AsmElementSimple</span><span id="052f" class="mb mc it nl b gy nt nq l nr ns">...</span><span id="7c63" class="mb mc it nl b gy nt nq l nr ns">val grammarStr = ...<br/>val sentence = ...<br/>val proc = Agl.processor(grammarStr)<br/>val asm = proc.process&lt;AsmElementSimple&gt;(sentence)</span></pre><h2 id="233a" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="92a4" class="mb mc it nl b gy np nq l nr ns">import net.akehurst.language.agl.processor.Agl;<br/>import net.akehurst.language.api.processor.LanguageProcessor;<br/>import net.akehurst.language.api.analyser.AsmElementSimple;</span><span id="ba49" class="mb mc it nl b gy nt nq l nr ns">...</span><span id="57e6" class="mb mc it nl b gy nt nq l nr ns">String grammarStr = ...<br/>String sentence = ...<br/>LanguageProcessor proc =<br/>                  Agl.<em class="nu">INSTANCE</em>.processor(grammarStr,null,null);<br/>AsmElementSimple asm = proc.process(sentence);</span></pre><h2 id="01cd" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">Java Script语言</h2><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="e7e6" class="mb mc it nl b gy np nq l nr ns">const agl_module = require('net.akehurst.language-agl-processor');<br/>const Agl = agl_module.net.akehurst.language.agl.processor.Agl;</span><span id="5ae3" class="mb mc it nl b gy nt nq l nr ns">const grammarStr = ...<br/>const sentence = ...<br/>const proc = Agl.processorFromString(grammarStr);<br/>const asm = proc.process(sentence).toArray();</span></pre><h1 id="80c0" class="mz mc it bd md na nb nc mg nd ne nf mj jz ng ka mm kc nh kd mp kf ni kg ms nj bi translated">例子</h1><p id="a027" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">有一个<a class="ae le" href="https://info.itemis.com/demo/agl/editor" rel="noopener ugc nofollow" target="_blank">在线演示</a>，集成了Ace和Monaco编辑器，github库中有一些<a class="ae le" href="https://github.com/dhakehurst/net.akehurst.language/tree/master/examples" rel="noopener ugc nofollow" target="_blank">小例子。此外，对主agl处理器模块的测试还有许多其他的例子。</a></p><h1 id="2258" class="mz mc it bd md na nb nc mg nd ne nf mj jz ng ka mm kc nh kd mp kf ni kg ms nj bi translated">创建语言处理器</h1><p id="fd61" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">AGL是用Kotlin编写的多平台模块。因此，它可以在Java(或其他JVM语言)、基于JavaScript的语言(包括TypeScript等)中使用，甚至可以在本机代码中使用……尽管这还没有得到很好的测试。</p><blockquote class="nv nw nx"><p id="e329" class="ki kj nu kk b kl km ju kn ko kp jx kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">本文中的代码示例用Kotlin给出。但是等价的Java或JavaScript代码也可以工作。关于如何从这些其他语言调用Kotlin代码，请参见Kotlin文档。</p></blockquote><p id="edc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AGL模块(库)在<a class="ae le" href="https://bintray.com/bintray/jcenter" rel="noopener ugc nofollow" target="_blank"> jcenter </a>发布(Javascript版本也在<a class="ae le" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>发布)。使用你最喜欢的构建工具来获得它。我推荐<a class="ae le" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> gradle </a>。</p><p id="dcac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">API入口点是<code class="fe ob oc od nl b">Agl</code>对象。它包含了许多从AGL语法的定义创建语言处理器的有用方法。例如，</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="ab18" class="mb mc it nl b gy np nq l nr ns">val grammarStr = ...<br/>val myProcessor = Agl.processor(grammarStr)</span></pre><p id="b6f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦你创建了一个<code class="fe ob oc od nl b">LanguageProcessor</code>，你就可以用你的语言扫描、解析、处理等句子。</p><blockquote class="nv nw nx"><p id="d98f" class="ki kj nu kk b kl km ju kn ko kp jx kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">它被称为语言处理器(而不是语言解析器)，因为它可以做的不仅仅是解析。它还可以执行扫描(如果您想简单地扫描)、格式化和语法分析(将解析结果转换成AST抽象语法树)。</p></blockquote><h2 id="95a4" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">扫描</h2><p id="3d6e" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">尽管Agl提供了一个按需扫描解析器，但有时您确实想简单地扫描一个句子，并返回一个与您的语言语法中的终止符号相匹配的标记列表。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="a478" class="mb mc it nl b gy np nq l nr ns">val grammarStr = ...<br/>val myProcessor = Agl.processor(grammarStr)<br/>val tokens = myProcessor.scan("some nice sentence")</span></pre><h2 id="7c6c" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">从语法上分析</h2><p id="7273" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">为了解析一个句子，你可以定义目标规则，也就是你想要用来匹配句子的语法规则。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="3a37" class="mb mc it nl b gy np nq l nr ns">val grammarStr = ...<br/>val myProcessor = Agl.processor(grammarStr)<br/>val sppt = myProcessor.parse("goalRule", "some nice sentence")</span></pre><p id="708d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，如果您省略了goalRule，解析器将简单地使用您在语法中定义的第一个规则(参见下面如何定义语法)。</p><p id="0860" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解析的结果不仅仅是一棵解析树。Agl使用基于GLR的解析算法。如果你定义了一个不明确的语法，可能会有多个解析树结果，这取决于你所解析的句子。</p><p id="0a1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解析的结果被称为共享打包解析树(SPPT)。该树只有一个根节点。节点可以是分支节点，也可以是叶节点。</p><p id="6d53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">叶节点是“令牌”的表示，包含从句子中匹配的简单字符串。(scan函数返回代表令牌的SPPT叶节点列表)。</p><p id="2547" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分支节点是与简单解析树(PT)不同的地方。在简单的解析树中，分支节点包含一系列子节点。在SPPT中，分支节点包含多个(可选)子列表。如果你的语法是明确的，所有的分支节点将只包含一个孩子的列表，SPPT将相当于一个简单的解析树。</p><h2 id="5161" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">处理</h2><p id="74f8" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">通常，解析器提供选项来编写用于构建抽象语法树(AST)的“语义动作”。从PT构造AST的过程被称为语法分析。</p><p id="dbfb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AGL将使用默认的简单语法分析器进行语法分析。或者你可以在构建语言处理器时给它一个定制的语法分析器。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="78df" class="mb mc it nl b gy np nq l nr ns">val grammarStr = ...<br/>val analyser = MySyntaxAnalyser()<br/>val myProcessor = Agl.processor(grammarStr, analyser)</span><span id="3c42" class="mb mc it nl b gy nt nq l nr ns">val ast = myProcessor.process&lt;AstType&gt;("a nice sentence")</span></pre><h2 id="cdc7" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">格式化</h2><p id="7400" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">类似地，如果您将一个格式化程序传递给处理器，那么您可以要求它格式化一个AST或一个句子。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="56b2" class="mb mc it nl b gy np nq l nr ns">val grammarStr = ...<br/>val analyser = MySyntaxAnalyser()<br/>val formatter = MyFormatter()<br/>val myProcessor = Agl.processor(grammarStr, analyser, formatter)</span><span id="bce7" class="mb mc it nl b gy nt nq l nr ns">val formattedSentence = myProcessor.formatText("a nice sentence")</span></pre><h2 id="4ec7" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">代码完成</h2><p id="77d2" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">还提供了基本的代码完成支持。如果你给处理器一些文本和文本中的一个位置，它可以告诉你下一步它期望找到什么。即</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="73cd" class="mb mc it nl b gy np nq l nr ns">val grammarStr = ...<br/>val myProcessor = Agl.processor(grammarStr)<br/>val sentence = ...<br/>val pos = 5<br/>val next = myProcessor.expectedAt(sentence, pos)</span></pre><h1 id="73e8" class="mz mc it bd md na nb nc mg nd ne nf mj jz ng ka mm kc nh kd mp kf ni kg ms nj bi translated">定义语法的语言</h1><p id="3a38" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">要创建一个语言处理器，你需要定义一个语法。定义语法的AGL语言是基于EBNF的。</p><h2 id="cee6" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">规则</h2><p id="df9d" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">规则是用LHS名称和RHA集合的终端和非终端符号以及操作符定义的。例如，一对用于解析非常简单的属性声明的规则可能看起来像:</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="c6f9" class="mb mc it nl b gy np nq l nr ns">propertyDeclaration = NAME ':' NAME ;<br/>NAME = "[a-zA-Z][a-zA-Z0-9]*" ;</span></pre><p id="e2fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">LHS为非终端定义了一个名称，该名称可用于其他规则。第一个规则的RHS定义了非终结符<code class="fe ob oc od nl b">NAME</code>、文字值<code class="fe ob oc od nl b">:</code>和非终结符<code class="fe ob oc od nl b">NAME</code>的连接。第二个规则用RHS定义了<code class="fe ob oc od nl b">NAME</code>，RHS是一个单独的条目，它是一个正则表达式，匹配符合简单标识符的字符串。</p><p id="c717" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RHS规则项目可以是以下三种情况之一:</p><ul class=""><li id="b747" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld oe ll lm ln bi translated">非终结符(其他规则的名称)</li><li id="638e" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld oe ll lm ln bi translated">用单引号括起来的终端文字值</li><li id="3810" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld oe ll lm ln bi translated">终止模式值，用双引号括起来的正则表达式</li></ul><p id="a8ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RHS规则项可以通过多种不同的方式进行组合，如以下部分所述。</p><h2 id="f50b" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">串联</h2><p id="92fb" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">上面的例子显示了最简单的组合，连接。</p><h2 id="94e9" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">选择</h2><p id="58f4" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们还可以用一个简单的选择操作符来组合项目，</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="e5a6" class="mb mc it nl b gy np nq l nr ns">boolean = 'true' | 'false' ;</span></pre><p id="e2b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，由于AGL是一个按需扫描的解析器，所以考虑选择的顺序是很重要的。</p><blockquote class="nv nw nx"><p id="dc77" class="ki kj nu kk b kl km ju kn ko kp jx kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">按需扫描并不意味着不进行扫描，只是意味着在解析器之前没有单独的扫描器(或词法分析器)执行。当解析器需要一个令牌时，扫描按需进行。<br/>这提供了能够使用关键字作为标识的优势，但是以可能额外的模糊性为代价。</p></blockquote><p id="e1a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个不同的例子说明了这一点。typeReference可以是builtInType或userDefinedType。以下语法在解析<code class="fe ob oc od nl b">int</code>时给出错误的结果。虽然<code class="fe ob oc od nl b">builtInType</code>规则匹配字符串<code class="fe ob oc od nl b">int</code>，但是<code class="fe ob oc od nl b">NAME</code>规则也匹配，因此<code class="fe ob oc od nl b">userDefinedType</code>也匹配。当解析器试图匹配<code class="fe ob oc od nl b">typeReference</code>时，它有两个选择。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="a181" class="mb mc it nl b gy np nq l nr ns">typeReference = builtInType | userDefinedType ;<br/>builtInType = 'int' | 'boolean' | 'real' ;<br/>userDefinedType = NAME ;<br/>NAME = "[a-zA-Z][a-zA-Z0-9]*" ;</span></pre><p id="91c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了消除选择的歧义，解析器首先试图找到最长的选项，如果长度相同，那么它将选择最后一个选项:在这种情况下(不正确地)，它选择了<code class="fe ob oc od nl b">userDefinedType</code>。</p><p id="d749" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了得到所需的结果，当<code class="fe ob oc od nl b">builtInType</code>规则优先于<code class="fe ob oc od nl b">userDefinedType</code>规则时，我们必须定义优先级最高的项目排在最后的规则。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="7012" class="mb mc it nl b gy np nq l nr ns">typeReference = userDefinedType | builtInType ;<br/>builtInType = 'int' | 'boolean' | 'real' ;<br/>userDefinedType = NAME ;<br/>NAME = "[a-zA-Z][a-zA-Z0-9]*" ;</span></pre><h2 id="0092" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">可选择的</h2><p id="21b3" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">要定义可选的RHS项目，使用<code class="fe ob oc od nl b">?.</code></p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="80f3" class="mb mc it nl b gy np nq l nr ns">propertyDeclaration = modifier? NAME ':' NAME ;</span></pre><h2 id="f1d6" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">多样性</h2><p id="2119" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">要定义多个RHS项目，请使用:<code class="fe ob oc od nl b">*</code>、<code class="fe ob oc od nl b">+</code>、<code class="fe ob oc od nl b">2+</code>或一个范围<code class="fe ob oc od nl b">2..5</code></p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="b7f2" class="mb mc it nl b gy np nq l nr ns">itemList0 = item* ;     // 0 or more items<br/>itemList1 = item+ ;     // 1 or more items<br/>itemList2 = item+ ;     // 2 or more items<br/>itemList3 = item3..7 ;  // between 3 and 7 items</span></pre><blockquote class="nv nw nx"><p id="44e4" class="ki kj nu kk b kl km ju kn ko kp jx kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">可选项目(使用<code class="fe ob oc od nl b">?</code>)相当于多重<code class="fe ob oc od nl b">0..1</code></p></blockquote><h2 id="15bb" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">分隔列表</h2><p id="50e5" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">有时候你想要一个列表，但是这个列表需要被其他的条目分开。一个典型的例子是由<code class="fe ob oc od nl b">','</code>符号分隔的参数列表。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="635f" class="mb mc it nl b gy np nq l nr ns">argumentList0 = [ argument / ',' ]* ;  // 0 or more<br/>argumentList1 = [ argument / ',' ]+ ;  // 1 or more<br/>argumentList2 = [ argument / ',' ]2+ ;  // 2 or more<br/>argumentList3 = [ argument / ',' ]3..7 ;  // 3 to 7</span></pre><h2 id="2c7d" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">组</h2><p id="13ac" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">当然，有时你想写一个复杂的规则，并用括号<code class="fe ob oc od nl b">(…)</code>将条目组合在一起。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="6f74" class="mb mc it nl b gy np nq l nr ns">rule1 = a b (c d* )? ( [e / ',']+ )? ; </span></pre><h2 id="30f0" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">跳过规则</h2><p id="4faa" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">除了普通的解析器规则，我们还可以定义<code class="fe ob oc od nl b">skip</code>规则。这些规则支持你的语言中的注释和空白。它们将匹配任何其他规则中项目之间的句子部分。</p><p id="340c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，大多数语言通常需要一个匹配空白的规则，如下所示:</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="7069" class="mb mc it nl b gy np nq l nr ns">skip WHITESPACE = "\s+" ;</span></pre><h2 id="9666" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">树叶规则</h2><p id="05bf" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">有时，为端子符号命名或使用多个规则定义端子会很有帮助。这可以通过将规则标记为“叶”规则来实现。</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="5c4a" class="mb mc it nl b gy np nq l nr ns">leaf ID = "[a-z][a-z0-9]*"<br/>DIGIT = "[0-9]+"<br/>leaf REAL = DIGITS '.' DIGITS </span></pre><p id="12b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上述规则中，<code class="fe ob oc od nl b">ID</code>被定义为RHS上给定正则表达式的终止符号。此外，通过将规则<code class="fe ob oc od nl b">REAL</code>标记为叶规则，它相当于用正则表达式<code class="fe ob oc od nl b">"[0-9]+[.][0-9]+"</code>定义了一个终止符号。</p><blockquote class="nv nw nx"><p id="548d" class="ki kj nu kk b kl km ju kn ko kp jx kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">叶规则<strong class="kk iu">不得包含递归。</strong></p></blockquote><h2 id="11f7" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">语法定义和构成</h2><p id="054e" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">一个完整的语法定义被包装起来并被赋予一个名称和命名空间，</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="97ec" class="mb mc it nl b gy np nq l nr ns">namespace com.example.language<br/>grammar MyPropertyLanguage {</span><span id="1124" class="mb mc it nl b gy nt nq l nr ns">  skip WHITESPACE = "\s+" ;<br/><br/>  property = ID ':' typeReference ;<br/>  typeReference = ID typeArguments? ;<br/>  typeArguments = '&lt;' [typeReference / ',']+ '&gt;' ;<br/><br/>  ID = "[A-Za-z_][A-Za-z0-9_]*" ;</span><span id="49c3" class="mb mc it nl b gy nt nq l nr ns">}</span></pre><p id="63c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提供了名称和命名空间，以便我们可以执行语法合成。例如，我们可以用一种语法扩展另一种语法，</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="5fe4" class="mb mc it nl b gy np nq l nr ns">namespace com.example.language<br/>grammar MyLanguage extends MyPropertyLanguage {</span><span id="a45b" class="mb mc it nl b gy nt nq l nr ns">  unit = class* ;<br/>  class = 'class' ID '{' property* '}' ;</span><span id="9d97" class="mb mc it nl b gy nt nq l nr ns">}</span></pre><p id="1848" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者我们可以将一种语法嵌套在另一种语法中，</p><pre class="lu lv lw lx gt nk nl nm nn aw no bi"><span id="f5e1" class="mb mc it nl b gy np nq l nr ns">namespace com.example.language</span><span id="dd25" class="mb mc it nl b gy nt nq l nr ns">grammar Expressions {</span><span id="b051" class="mb mc it nl b gy nt nq l nr ns">  expression = ... ;</span><span id="683c" class="mb mc it nl b gy nt nq l nr ns">}</span><span id="b5cc" class="mb mc it nl b gy nt nq l nr ns">grammar MyLanguage {</span><span id="ece3" class="mb mc it nl b gy nt nq l nr ns">  readOnlyProperty = 'val' NAME '=' Expressions.expression</span><span id="5e3e" class="mb mc it nl b gy nt nq l nr ns">}</span></pre><p id="bad3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用语法扩展，得到的语法相当于包含两组规则的单个语法。但是，扩展(超)语法中的规则可以在扩展(子)语法中被覆盖(给出新的定义)。</p><p id="8b17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你在另一个语法中使用<code class="fe ob oc od nl b">nest</code>一个语法时，解析器基本上暂停基于<code class="fe ob oc od nl b">outer</code>语法的解析，并尝试继续使用<code class="fe ob oc od nl b">inner</code>语法进行解析，直到它匹配给定的<code class="fe ob oc od nl b">inner</code>规则，然后它再次继续使用<code class="fe ob oc od nl b">outer</code>语法。这意味着，例如，您可以在<code class="fe ob oc od nl b">inner</code>语法中定义完全不同的空白(跳过)规则。</p><h1 id="4ed0" class="mz mc it bd md na nb nc mg nd ne nf mj jz ng ka mm kc nh kd mp kf ni kg ms nj bi translated">摘要</h1><p id="e20e" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在Kotlin中，解析器是作为一个公共模块实现的，因此它可以在任何Kotlin目标上使用。</p><p id="7af5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解析器的目标之一是使使用它尽可能容易，所以它为了可用性牺牲了原始速度。然而，对于不明确的语法，它仍然保持可接受的性能。</p><p id="c5a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解析器仍在开发中，我很乐意接受感兴趣的用户的贡献、建议和任何其他反馈。请对本文发表评论或在github资源库中提出问题。</p></div></div>    
</body>
</html>