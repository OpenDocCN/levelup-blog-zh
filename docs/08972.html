<html>
<head>
<title>Neural Networks for Market Indicators Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于市场指标分析的神经网络</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/neural-networks-for-market-indicators-analysis-dae2678270eb?source=collection_archive---------2-----------------------#2021-06-23">https://levelup.gitconnected.com/neural-networks-for-market-indicators-analysis-dae2678270eb?source=collection_archive---------2-----------------------#2021-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/eb0b1609eb11a4a3c8c8ef4f29dc9f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*UAPovtxD7zXCtuZU3260Rg.jpeg"/></div></figure><div class=""/><p id="b334" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">神经网络已经被成功地用于解决科学和工程中的一系列具有挑战性的问题。本文中的示例使用Keras构建一个执行多输出回归的神经网络，用于股票和黄金价格预测。您将配置和训练此神经网络，然后使用平均绝对误差(MAE)评估模型的准确性，这是预测准确性的最简单的度量方法。</p><h1 id="318b" class="ks kt ix bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">使用Google Colab</h1><p id="8131" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">也许用Keras实现神经网络最简单的方法是在<a class="ae lv" href="http://colab.research.google.com" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>中运行一个笔记本，在其中你可以将你的代码组织成几个代码单元。您不需要在笔记本中安装Keras，以及示例中使用的NumPy。但是，您仍然需要安装yfinance和quandl库来分别获取股票和黄金价格。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7553" class="mf kt ix mb b gy mg mh l mi mj">!pip install yfinance<br/>!pip install quandl</span></pre><p id="29b4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">之后，您可以使用这些库来获取用于训练和评估神经网络的数据。</p><h1 id="8bbb" class="ks kt ix bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">获取数据</h1><p id="cfa2" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在下面的代码单元格中，您获取了某个股票(在本例中为Tesla)在过去五年中的历史股价(当然，您也可以选择另一个股票):</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4d6a" class="mf kt ix mb b gy mg mh l mi mj">import yfinance as yf<br/>tkr = yf.Ticker('TSLA')<br/>hist = tkr.history(period="5y") <br/>import pandas_datareader.data as pdr<br/>from datetime import date, timedelta<br/>end = date.today()<br/>start = end — timedelta(days=5*365+1)<br/>index_data = pdr.get_data_stooq('^SPX', start, end)<br/>df = hist.join(index_data, lsuffix = '_tkr', rsuffix = '_idx')<br/>df = df[['Close_tkr','Volume_tkr','Close_idx','Volume_idx']]</span></pre><p id="7194" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如您可能从上一个单元格的最后一行中猜到的那样，您将只使用股票的收盘价和销售量数字来进行进一步的分析。</p><p id="be09" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，你会得到同一时期的黄金价格。在此之前，您需要创建一个<a class="ae lv" href="https://help.quandl.com/article/320-where-can-i-find-my-api-key" rel="noopener ugc nofollow" target="_blank"> Quandl帐户</a>来获得一个免费的API令牌:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b588" class="mf kt ix mb b gy mg mh l mi mj">import quandl<br/>gold_price = quandl.get("LBMA/GOLD",start_date=start, end_date=end, authtoken="your_quandl_token")<br/>df = df.join(gold_price['USD (AM)'])<br/>df = df.rename(columns={'USD (AM)': 'Gold'})</span></pre><p id="dd21" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在您已经获得了数据，您可以为要训练的网络生成要素和输出。</p><h1 id="e70e" class="ks kt ix bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">从数据中生成特征</h1><p id="c4dd" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在下一个像元中，在训练网络之前对数据进行预处理，执行要素缩放。实际上，您只需计算每个指标与前一天相比的百分比变化:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b4be" class="mf kt ix mb b gy mg mh l mi mj">import numpy as np<br/>df['priceRise_tkr'] = np.log(df['Close_tkr'] / df['Close_tkr'].shift(1))<br/>df['volumeRise_tkr'] = np.log(df['Volume_tkr'] / df['Volume_tkr'].shift(1))<br/>df['priceRise_idx'] = np.log(df['Close_idx'] / df['Close_idx'].shift(1))<br/>df['volumeRise_idx'] = np.log(df['Volume_idx'] / df['Volume_idx'].shift(1))<br/>df['priceRise_gold'] = np.log(df['Gold'] / df['Gold'].shift(1))<br/>df = df.dropna()</span></pre><p id="ef01" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，通过获取第二天价格指标的百分比变化来生成输出:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="450f" class="mf kt ix mb b gy mg mh l mi mj">df['tkrPred'] = df['priceRise_tkr'].shift(-1)<br/>df['goldPred'] = df['priceRise_gold'].shift(-1)<br/>df['tkrPred'] = df['tkrPred']*100<br/>df['goldPred'] = df['goldPred']*100<br/>df = df.dropna()</span></pre><p id="a892" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，您将tkrPred和goldPred列中的值调整为实际百分比，而不是-1.0和1.0之间的实数。</p><p id="d020" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，您需要将带有特征和目标变量的df数据帧转换为相应的NumPy数组，以用于模型训练和评估:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="21c1" class="mf kt ix mb b gy mg mh l mi mj">features = df[['priceRise_tkr','volumeRise_tkr','priceRise_idx','volumeRise_idx','priceRise_gold']].to_numpy()<br/>features = np.around(features, decimals=2) <br/>target = df[['tkrPred','goldPred']].to_numpy()</span></pre><h1 id="72b6" class="ks kt ix bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">配置模型</h1><p id="54a0" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在此示例中，您将创建一个神经网络，它遵循一个简单的顺序模型，具有一堆密集层:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ba98" class="mf kt ix mb b gy mg mh l mi mj">from keras.models import Sequential<br/>from keras.layers import Dense</span></pre><p id="6c46" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以在单独的函数中获得模型:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="075b" class="mf kt ix mb b gy mg mh l mi mj">def get_model(n_inputs, n_outputs):<br/>  model = Sequential()<br/>  model.add(Dense(n_inputs, input_dim=n_inputs, activation='relu'))<br/>  model.add(Dense(100, kernel_initializer='he_uniform', activation='relu'))<br/>  model.add(Dense(n_outputs))<br/>  model.compile(loss='mae', optimizer='adam')<br/>  return model</span></pre><p id="7b1f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，该模型有三层:输入、隐藏和输出。您将mae定义为损失函数和adam优化器。</p><h1 id="34a0" class="ks kt ix bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">训练和评估模型</h1><p id="4cfd" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在这里，您使用重复的K-fold交叉验证器来训练和评估模型，该验证器为每个split调用返回不同的结果:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="dc55" class="mf kt ix mb b gy mg mh l mi mj">from sklearn.model_selection import RepeatedKFold<br/>n_inputs, n_outputs = features.shape[1], target.shape[1]<br/>cv = RepeatedKFold(n_splits=10, n_repeats=3, random_state=1)<br/>for train_ix, test_ix in cv.split(features):<br/>  X_train, X_test = features[train_ix], features[test_ix]<br/>  y_train, y_test = target[train_ix], target[test_ix]<br/>  model = get_model(n_inputs, n_outputs)<br/>  model.fit(X_train, y_train, verbose=0, epochs=20)<br/>  mae = model.evaluate(X_test, y_test, verbose=0)<br/>  print('&gt;%.3f' % mae)</span></pre><p id="8b22" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">输出可能是这样的:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ff29" class="mf kt ix mb b gy mg mh l mi mj">&gt;1.540<br/>&gt;1.527<br/>&gt;1.551<br/>&gt;1.606<br/>&gt;1.481<br/>&gt;1.495<br/>&gt;1.731<br/>&gt;1.380<br/>…</span></pre></div></div>    
</body>
</html>