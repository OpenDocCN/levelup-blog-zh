<html>
<head>
<title>Writing type-safe Javascript code with Prisma and MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Prisma和MySQL编写类型安全的Javascript代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-type-safe-javascript-code-with-prisma-and-mysql-929a73930cba?source=collection_archive---------6-----------------------#2021-09-07">https://levelup.gitconnected.com/writing-type-safe-javascript-code-with-prisma-and-mysql-929a73930cba?source=collection_archive---------6-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a21eed5024fb40b7a4f8eb40340bfb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Hx7rpqYneOP1tFG3buITA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@popnzebra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">波普&amp;斑马</a>在<a class="ae kc" href="https://unsplash.com/s/photos/safety?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">挡泥板</a>上拍摄</figcaption></figure><p id="33f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程深入研究了如何使用<a class="ae kc" href="https://www.javascript.com/" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>、<a class="ae kc" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>、<a class="ae kc" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>、<a class="ae kc" href="https://joi.dev/" rel="noopener ugc nofollow" target="_blank"> Joi </a>、<a class="ae kc" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>和<a class="ae kc" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>创建类型安全的API服务器。您将学习如何使用Express创建服务器，使用Joi验证请求，以及使用Prisma在数据库上执行CRUD操作。</p><p id="ebcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不熟悉，CRUD代表<strong class="kf ir"> c </strong> reate、<strong class="kf ir"> r </strong> ead、<strong class="kf ir"> u </strong> pdate、<strong class="kf ir"> d </strong> elete。这些是API实现的操作，使程序员能够访问和修改数据。您的Express API服务器将是功能完整的。</p><h1 id="e566" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在开始之前</h1><p id="0b4e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本教程中，您将学习如何:</p><ul class=""><li id="297a" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">使用Prisma和验证对Javascript API实施类型安全。</li><li id="3237" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">使用Express、Prisma和MySQL创建一个实用的现代后端。</li><li id="71fb" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">添加CRUD操作和HTTP请求。</li><li id="ec19" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">用Prisma为您的数据建模。</li></ul><h1 id="96e2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是类型安全？</h1><p id="e81f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型安全是编程语言为减少或消除类型错误而实施的标准。例如，如果一个方法需要整数参数，而程序员要传递一个字符串列表，那么类型安全语言就会抛出一个错误。</p><p id="3148" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript本质上不是一种类型安全的语言，但是您可以强加某种级别的类型安全。Prisma是类型安全的，因为它生成的数据模型是强类型的。但是如果没有验证，您最好使用Joi来验证您的输入，并使用Prisma将经过验证的输入写入MySQL数据库。</p><h1 id="97d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Prisma是什么？</h1><p id="627e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Prisma是JavaScript和TypeScript的查询生成器。它与许多不同的SQL服务器兼容，包括MySQL、Postgres和SQLite，以及预发布的MongoDB和Microsoft SQL server。Prisma简化了数据库操作，并在查询中加强了类型安全。</p><p id="8cfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prisma的工作原理是自动生成一个类型感知的、特定于您的项目的客户端。它还能够通过从数据库服务器获取信息来自动创建模式。Prisma还具有一个名为Prisma Studio的可视化编辑器，以及一个用于与数据库交互的命令行界面(CLI)。</p><h1 id="9ff3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Prisma编写类型安全的API</h1><p id="c6ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面的例子使用Prisma Client和Node.js创建一个API，它将与MySQL数据库服务器通信。它将使用为面包店创建的数据库模式，特别是描述面包店商业供应商的地址簿表。</p><h1 id="24c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置项目</h1><p id="ae96" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，您需要为您的项目创建一个目录。这个例子将使用一个名为<code class="fe ms mt mu mv b">javascript-prisma-mysql</code>的项目目录。使用以下命令创建目录并导航至该目录:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c0c7" class="ne lc iq mv b gy nf ng l nh ni">mkdir javascript-prisma-mysql<br/>cd javascript-prisma-mysql</span></pre><p id="dcab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦进入正确的目录，就应该初始化Node.js项目。</p><h1 id="176f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">初始化Node.js项目</h1><p id="1973" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在启动服务器之前，您必须初始化项目。在项目的根目录下运行此命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="71c6" class="ne lc iq mv b gy nf ng l nh ni">npm init</span></pre><p id="7a2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按下enter键后，您将看到一个交互式向导已经启动。它会问一些关于你的项目的问题。可以点击“回车”并接受每行的默认值。运行带有<code class="fe ms mt mu mv b">-y</code>参数的命令将跳过该向导，并在不需要输入的情况下生成您的项目。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/d83d4c72e3077142944354484718c790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M8ajBhSsFXw8qETS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">npm初始化交互式向导。</figcaption></figure><p id="bb59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当向导完成时，它将生成节点运行应用程序所需的文件。现在，您可以继续安装项目依赖项了。</p><h1 id="9542" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装项目依赖项</h1><p id="82ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在开始编写代码之前，您需要安装一些软件包。对于这个项目，您将使用以下Node.js包:</p><p id="af9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Express是您将用来构建API服务器的框架。它提供了处理<a class="ae kc" href="https://expressjs.com/en/guide/routing.html" rel="noopener ugc nofollow" target="_blank"> HTTP请求和路由</a>所需的机制。它是由快递包裹提供的。</p><p id="c0a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prisma CLI将允许您使用npx调用Prisma特定的命令。它需要单独安装，作为一个开发依赖，从prisma包。</p><p id="ced3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prisma client是一个查询生成器，使用Prisma CLI生成的模式与MySQL数据库进行通信。Prisma将确保类型安全的API响应。你将从<code class="fe ms mt mu mv b">@prisma/client</code>包中安装它。</p><p id="5bf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Joi是一个数据验证框架，您将使用它来检查传入的HTTP请求的类型是否正确。您将从joi包中安装它。</p><p id="c0ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Joi validation for Express是将Joi数据验证规则应用到Express API请求的中间件。由<code class="fe ms mt mu mv b">express-joi-validation</code>包提供。</p><p id="6e17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保安装了Node.js，然后在项目目录中运行以下命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c6bd" class="ne lc iq mv b gy nf ng l nh ni">npm install express joi express-joi-validation @prisma/client<br/>npm install prisma — save-dev</span></pre><p id="45da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装完成后，创建一个新文件，以匹配您在上一步中指定的项目入口点。如果你完全按照步骤操作，它将需要被命名为<code class="fe ms mt mu mv b">index.js</code>。</p><h1 id="81a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从Prisma开始学习Express API</h1><p id="21fd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">您应该通过编辑<code class="fe ms mt mu mv b">index.js</code>来创建一个API服务器。在本例中，服务器运行在端口3000上，并显示一条hello消息来确认它正在工作。</p><h1 id="2333" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第一个代码</h1><p id="64dc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，您可以创建一个Hello World应用程序，并定义您的第一条路线，如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="66f3" class="ne lc iq mv b gy nf ng l nh ni"><em class="nk">/** Required Node.js modules */</em></span><span id="e0a9" class="ne lc iq mv b gy nl ng l nh ni">const Express = require(‘express’);</span><span id="0e08" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Initialize Express */</em></span><span id="f1fd" class="ne lc iq mv b gy nl ng l nh ni">const app = Express();</span><span id="a44e" class="ne lc iq mv b gy nl ng l nh ni">app.use(Express.json());</span><span id="64bb" class="ne lc iq mv b gy nl ng l nh ni">const port = 3000;</span><span id="02ee" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Routes */</em></span><span id="6587" class="ne lc iq mv b gy nl ng l nh ni">app.get(‘/’, (req, res) =&gt; {</span><span id="6e4f" class="ne lc iq mv b gy nl ng l nh ni">res.send(“Hello, API server!”);</span><span id="d2f7" class="ne lc iq mv b gy nl ng l nh ni">});</span><span id="6fbe" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Server */</em></span><span id="a3a4" class="ne lc iq mv b gy nl ng l nh ni">app.listen(port, () =&gt; {</span><span id="3dec" class="ne lc iq mv b gy nl ng l nh ni">console.log(`API listening on localhost: ${port}`);</span><span id="3fbf" class="ne lc iq mv b gy nl ng l nh ni">});</span></pre><p id="2668" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码实现了一个Express API并定义了一条路由。首先使用语句<code class="fe ms mt mu mv b">const Express = require(‘express’);</code>导入所需的模块。</p><p id="5b1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后为Express实例和API将监听的端口定义变量。您将通过一个函数调用来定义Express API的根路由。在这种情况下，您使用<code class="fe ms mt mu mv b"><a class="ae kc" href="https://expressjs.com/en/api.html#app.get" rel="noopener ugc nofollow" target="_blank">app.get()</a></code>函数为HTTP get请求定义一个处理程序。</p><p id="ee99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mv b">app.get()</code>的第一个参数指定Express将在哪个路径上监听请求，第二个参数是一个回调，包含req和res对象，它们分别包含HTTP请求和响应。</p><p id="2308" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将把路由处理器逻辑放在<code class="fe ms mt mu mv b">app.get()</code>的主体中。为了演示功能，当用户访问根目录时，您的API服务器会显示一条hello消息。</p><p id="0b40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，调用Express listen方法并记录一些关于服务器的信息。在这个例子中，一条短消息被打印到控制台，说明服务器正在运行，并显示API服务器正在监听的端口。</p><p id="d2f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能注意到这个例子还没有包括Prisma和Joi。没关系，重点是在添加任何东西之前启动服务器。</p><p id="0d51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您的代码已经编写好了，您可以使用以下命令启动服务器:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f90c" class="ne lc iq mv b gy nf ng l nh ni">node index.js</span></pre><p id="e93f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将看到我们记录到控制台的消息:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e110dfe154cc6d031c2534c73f4ca4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*hHxz69mK8yA7U-M7"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">正在运行的节点服务器的输出。</figcaption></figure><p id="9072" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您打开浏览器并访问<a class="ae kc" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>时，您应该会看到hello消息:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/57140e161ae8bab1168ffd1453b846b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*0PdXCsPZiauNprh6"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">运行应用程序时您将看到的欢迎消息。</figcaption></figure><p id="32f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你达到了那个阶段，你可以在控制台中用Ctrl+C关闭服务器，并重新运行<code class="fe ms mt mu mv b">node index.js</code>来重启它。</p><h1 id="cead" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为类型安全API介绍Joi和Prisma</h1><p id="7e44" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了说明API中类型安全的重要性，下面是一个不安全API服务器的示例:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8004" class="ne lc iq mv b gy nf ng l nh ni">const Express = require('express');</span><span id="9fe9" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Initialize Express */</em></span><span id="a49f" class="ne lc iq mv b gy nl ng l nh ni">const app = Express();</span><span id="ed6e" class="ne lc iq mv b gy nl ng l nh ni">app.use(Express.json())</span><span id="cf38" class="ne lc iq mv b gy nl ng l nh ni">const port = 3000;</span><span id="d235" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Routes */</em></span><span id="6003" class="ne lc iq mv b gy nl ng l nh ni">app.post('/unsafe_add', (req, res) =&gt; {</span><span id="adb4" class="ne lc iq mv b gy nl ng l nh ni">  let answer = Number(req.body.integer) + 10;</span><span id="6199" class="ne lc iq mv b gy nl ng l nh ni">  res.send(String(answer));</span><span id="c16e" class="ne lc iq mv b gy nl ng l nh ni">});</span><span id="7bde" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Server */</em></span><span id="bbcd" class="ne lc iq mv b gy nl ng l nh ni">app.listen(port, () =&gt; {</span><span id="5ac3" class="ne lc iq mv b gy nl ng l nh ni">  console.log(`API listening on localhost: ${port}`);</span><span id="3f06" class="ne lc iq mv b gy nl ng l nh ni">});});</span></pre><p id="8e79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，代码类似于前面的例子。这个API服务器实现了一个名为<code class="fe ms mt mu mv b">unsafe_add</code>的路由，它将给定的数字加10。这个路由的逻辑将一个名为integer的主体参数转换为一个数字，然后将其加到10，并将结果作为一个字符串发送回来。</p><p id="e4a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是使用<a class="ae kc" href="https://www.postman.com/home" rel="noopener ugc nofollow" target="_blank"> Postman </a>的请求和响应示例:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/544827e10e916c930260d776e4315d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jvhFclOR43inPHwa"/></div></div></figure><p id="534b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乍一看，它似乎工作正常。但是如果你不小心传入了一个不能被强制转换为数字的值呢？例如，单词“二十五”:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/c66c6e6f4fb4c9c1f960e87ab74d844d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kPu75sW5X7pSK7Gl"/></div></div></figure><p id="b4e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，API返回非数字(NaN)值，因为它无法成功执行转换。想象一下在没有类型安全的大型生产代码库中您可能面临的问题。</p><h1 id="6e41" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Prisma和Joi实现类型安全API</h1><p id="e8aa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">既然您已经看到了拥有类型安全API服务器的价值，那么是时候关注实现了。</p><h2 id="3ff2" class="ne lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">导入和实例化新的Prisma客户端</h2><p id="9061" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，您需要将Prisma所需的模块添加到源代码中，并实例化一个新的Prisma客户端:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="22fe" class="ne lc iq mv b gy nf ng l nh ni"><em class="nk">/** Required Node.js modules */</em></span><span id="9304" class="ne lc iq mv b gy nl ng l nh ni">const Prisma = require('prisma/prisma-client');</span><span id="df7b" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Instantiate Prisma client */</em></span><span id="a1b9" class="ne lc iq mv b gy nl ng l nh ni">const prisma = new Prisma.PrismaClient();</span></pre><p id="7664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在客户机已经被导入并实例化，但是在Prisma初始化之前它还不能使用。在您的项目目录中运行此命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="7162" class="ne lc iq mv b gy nf ng l nh ni">npx prisma init</span></pre><p id="8755" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当该命令完成时，您将会注意到项目目录中的新文件。Prisma在您的根目录下创建了一个名为。存储环境变量的env。它还创建了一个名为<code class="fe ms mt mu mv b">prisma</code>的目录，并在该目录中创建了一个名为<code class="fe ms mt mu mv b">schema.prisma</code>的文件。</p><p id="4d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编辑您的<code class="fe ms mt mu mv b">.env</code>文件并指定关于您的数据库连接的信息。如果您还没有在本地运行的MySQL数据库，您可以购买托管数据库。</p><p id="a035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使Prisma能够连接到您的数据库，您必须更改存储在<code class="fe ms mt mu mv b">.env</code>中的URI以匹配您的设置:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="b27d" class="ne lc iq mv b gy nf ng l nh ni">DATABASE_URL=localhost://username:password@localhost:3306/bakery_demo</span></pre><p id="5b06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的URL中，您应该编辑主机、用户名、密码和表以匹配您的设置。有关URL格式的更多信息，请参见MySQL的<a class="ae kc" href="https://www.prisma.io/docs/reference/database-reference/connection-urls" rel="noopener ugc nofollow" target="_blank"> Prisma URL连接指南</a>。</p><p id="f989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还需要为您的API编写一个<a class="ae kc" href="https://www.prisma.io/docs/concepts/components/prisma-schema" rel="noopener ugc nofollow" target="_blank"> Prisma模式</a>。这个模式将描述存储在数据库中的对象，这样Prisma可以生成一个客户机来存储和检索它们。本例将使用<a class="ae kc" href="https://github.com/chief-wizard/prisma-fastify-bakery" rel="noopener ugc nofollow" target="_blank"> Prisma bakery演示</a>中的供应商表作为模式的模型。</p><p id="0a60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过编辑文件<code class="fe ms mt mu mv b">prisma/schema.prisma</code>创建您的模式。首先，您的模式将包含有关数据库连接的信息:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8018" class="ne lc iq mv b gy nf ng l nh ni">datasource db {</span><span id="e118" class="ne lc iq mv b gy nl ng l nh ni">  provider = "mysql"</span><span id="00ab" class="ne lc iq mv b gy nl ng l nh ni">  url      = env("DATABASE_URL")</span><span id="4796" class="ne lc iq mv b gy nl ng l nh ni">}<br/></span><span id="a5cf" class="ne lc iq mv b gy nl ng l nh ni">generator client {</span><span id="0141" class="ne lc iq mv b gy nl ng l nh ni">  provider = "prisma-client-js"</span><span id="c546" class="ne lc iq mv b gy nl ng l nh ni">}</span></pre><p id="a202" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提供者与您的数据库相匹配是很重要的。Prisma数据库连接器默认为postgresql，但是对于这个项目，您应该将其更改为mysql。查看<a class="ae kc" href="https://www.prisma.io/docs/concepts/database-connectors#overview" rel="noopener ugc nofollow" target="_blank"> Prisma数据库连接器</a>的完整列表，了解更多信息。</p><p id="aeb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">指定正确的数据库连接器后，将数据库模型添加到prisma/prisma.schema中Prisma模式的末尾。本演示中的供应商模型包含一个表示供应商id的整数字段，其余字段为字符串:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3d8e" class="ne lc iq mv b gy nf ng l nh ni">model Supplier {</span><span id="1ef3" class="ne lc iq mv b gy nl ng l nh ni">  id        Int    @id @default(autoincrement())</span><span id="ac3c" class="ne lc iq mv b gy nl ng l nh ni">  name      String @unique</span><span id="e90c" class="ne lc iq mv b gy nl ng l nh ni">  contact   String</span><span id="cd80" class="ne lc iq mv b gy nl ng l nh ni">  email     String</span><span id="890a" class="ne lc iq mv b gy nl ng l nh ni">  phone_num String</span><span id="fe57" class="ne lc iq mv b gy nl ng l nh ni">  address   String</span><span id="241a" class="ne lc iq mv b gy nl ng l nh ni">}</span></pre><p id="f99e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行以下命令将您的模式推送到数据库，并为您的API生成一个Prisma客户端:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3743" class="ne lc iq mv b gy nf ng l nh ni">npx prisma db push</span></pre><p id="9fef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成客户端后，您将能够使用它来查询您的数据库。由于客户端对于您的项目是唯一的，因此您将能够使用IntelliSense访问数据库中的字段。</p><p id="fde1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候设置Joi来验证传入API的请求了。</p><h1 id="d5bd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">导入Joi并创建Joi模式</h1><p id="0908" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">设置Joi的第一步是导入模块。在代码的顶部，添加以下几行:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8e2c" class="ne lc iq mv b gy nf ng l nh ni">const Joi = require(‘joi’)<br/>const joiMiddleware = require(‘express-joi-validation’).createValidator({})</span></pre><p id="7d72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一行将导入核心Joi模块，并允许您编写验证规则。第二行导入Joi模块，该模块包含用于Express APIs的中间件。</p><p id="c50c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Joi中间件是传递给路由的一个函数，它在路由逻辑之前被调用。如果验证失败，路由逻辑永远不会执行。</p><p id="3b32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Joi使用自己的模式来验证传递给API的输入。您可以基于<code class="fe ms mt mu mv b">prisma/schema.prisma</code>中的Joi模式。您将需要对相同的字段建模，以便Joi可以正确地验证供应商对象。将验证器模式添加到您的<code class="fe ms mt mu mv b">index.js</code>文件中:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d5b3" class="ne lc iq mv b gy nf ng l nh ni"><em class="nk">/** Supplier validation schema for Joi */</em></span><span id="2a29" class="ne lc iq mv b gy nl ng l nh ni">const supplierSchema = Joi.object({</span><span id="964c" class="ne lc iq mv b gy nl ng l nh ni">  Id: Joi.number().greater(0),</span><span id="a669" class="ne lc iq mv b gy nl ng l nh ni">  name: Joi.string().alphanum().min(1).max(191).required(),</span><span id="fed6" class="ne lc iq mv b gy nl ng l nh ni">  contact: Joi.string().alphanum().min(1).max(191).required(),</span><span id="9174" class="ne lc iq mv b gy nl ng l nh ni">  email: Joi.string().email().max(191).required(),</span><span id="49c5" class="ne lc iq mv b gy nl ng l nh ni">  phone_num: Joi.string().length(10).pattern(/<em class="nk">^</em>[0-9]+<em class="nk">$</em>/).required(),</span><span id="62c4" class="ne lc iq mv b gy nl ng l nh ni">  address: Joi.string().alphanum().min(1).max(191).required(),</span><span id="3d00" class="ne lc iq mv b gy nl ng l nh ni">});</span></pre><p id="2616" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，Joi的验证模式是由链接在一起的方法组成的。id字段将只接受大于0的数字作为输入。其他字段必须至少有一个字符长。</p><p id="5001" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该示例使用最多191个字符作为字符串，因为这是MySQL模式中每个字段的最大长度。默认情况下，Prisma将模型中的<a class="ae kc" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#model-field-scalar-types" rel="noopener ugc nofollow" target="_blank">字符串映射到MySQL中的varchar(191)字段。</a></p><p id="81c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是Joi更多验证方法的列表:</p><ul class=""><li id="545a" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">bool()</code>。用于验证布尔对象的Joi类型。</li><li id="7ffd" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">bool().falsy()</code>。如果布尔值为假或等于假的值，如0，则有效。</li><li id="06f9" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">bool().truthy()</code>。如果布尔值为真或等于真的值，如1，则有效。</li><li id="85b6" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">bool().validate(value)</code>。如果布尔值与值匹配，则有效，值可以是真或假。</li><li id="1645" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">date()</code>。用于验证日期或时间对象的Joi类型。</li><li id="1750" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">date().greater(date)</code>。如果日期早于以MM-DD-YYY格式指定的日期，则有效。</li><li id="4fb2" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">date().less(date)</code>。如果日期晚于以MM-DD-YYY格式指定的日期，则有效。</li><li id="ad08" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">date().timestamp([options])</code>。如果时间戳与指定选项的格式相同，则有效，可以是unix或javascript。</li><li id="a5e2" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">number()</code>。用于验证数字对象的Joi类型。</li><li id="eaf9" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">number().greater(value)</code>。如果数字大于指定值，则有效。</li><li id="4052" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">number().less(value)</code>。如果数字小于指定值，则有效。</li><li id="cf6e" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">number().max(value)</code>。如果数字小于最大指定值，则有效。</li><li id="ef7b" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">number().min(value)</code>。如果数字大于指定的最小值，则有效。</li><li id="a663" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">number().positive()</code>。如果数字为正数，则有效。</li><li id="6e00" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">number().negative()</code>。如果数字为负数，则有效。</li><li id="fe0b" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">number().validate(value)</code>。如果数字与指定值匹配，则有效。</li><li id="533a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string()</code>。用于验证字符串对象的Joi类型。</li><li id="d224" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().alphanum()</code>。如果字符串只包含字母数字字符，则有效。</li><li id="2f21" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().creditCard()</code>。如果使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Luhn_algorithm" rel="noopener ugc nofollow" target="_blank"> Luhn算法</a>发现字符串是信用卡号，则有效。</li><li id="5c51" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().domain([options])</code>。如果字符串是域名，则有效。可以指定一系列选项。</li><li id="79f6" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().email([options])</code>。如果字符串是电子邮件地址，则有效。可以指定一系列选项。</li><li id="3709" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().length(value)</code>。如果字符串长度与指定值匹配，则有效。</li><li id="9a85" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().lowercase()</code>。如果字符串是小写的，则有效。默认情况下，非小写的字符串将被强制转换为小写。</li><li id="8ebe" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().min(value)</code>。如果字符串长度超过最小指定值，则有效。</li><li id="7a00" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().max(value)</code>。如果字符串短于最大指定值，则有效。</li><li id="ccf2" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().pattern(regex)</code>。如果字符串与regex中指定的正则表达式匹配，则有效。</li><li id="eaf7" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><code class="fe ms mt mu mv b">string().uppercase()</code>。如果字符串是大写的，则有效。默认情况下，非大写的字符串将被强制转换为大写。</li></ul><p id="be5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Joi模式验证方法的完整列表可以在<a class="ae kc" href="https://joi.dev/api/" rel="noopener ugc nofollow" target="_blank"> Joi API文档</a>中找到。为了清楚起见，下面是到目前为止的源代码:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="39a1" class="ne lc iq mv b gy nf ng l nh ni"><em class="nk">/** Required Node.js modules */</em></span><span id="71bc" class="ne lc iq mv b gy nl ng l nh ni">const Express = require('express');</span><span id="515c" class="ne lc iq mv b gy nl ng l nh ni">const Joi = require('joi')</span><span id="1c0e" class="ne lc iq mv b gy nl ng l nh ni">const joiMiddleware = require('express-joi-validation').createValidator({})</span><span id="7294" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Supplier validation schema for Joi */</em></span><span id="e5df" class="ne lc iq mv b gy nl ng l nh ni">const supplierSchema = Joi.object({</span><span id="fddb" class="ne lc iq mv b gy nl ng l nh ni">  id: Joi.number().greater(0),</span><span id="5d8c" class="ne lc iq mv b gy nl ng l nh ni">  name: Joi.string().alphanum().min(1).max(191),</span><span id="7e7c" class="ne lc iq mv b gy nl ng l nh ni">  contact: Joi.string().alphanum().min(1).max(191),</span><span id="69c7" class="ne lc iq mv b gy nl ng l nh ni">  email: Joi.string().email().max(191),</span><span id="a25d" class="ne lc iq mv b gy nl ng l nh ni">  phone_num: Joi.string().length(10).pattern(/<em class="nk">^</em>[0-9]+<em class="nk">$</em>/),</span><span id="f56e" class="ne lc iq mv b gy nl ng l nh ni">  address: Joi.string().alphanum().min(1).max(191),</span><span id="0125" class="ne lc iq mv b gy nl ng l nh ni">});</span><span id="cb80" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Initialize Express */</em></span><span id="7350" class="ne lc iq mv b gy nl ng l nh ni">const app = Express();</span><span id="cec7" class="ne lc iq mv b gy nl ng l nh ni">app.use(Express.json());</span><span id="29ac" class="ne lc iq mv b gy nl ng l nh ni">const port = 3000;</span><span id="4df4" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Routes */</em></span><span id="08f3" class="ne lc iq mv b gy nl ng l nh ni">app.get('/', (req, res) =&gt; {</span><span id="72b9" class="ne lc iq mv b gy nl ng l nh ni">  res.send("Hello, API server!");</span><span id="9ba4" class="ne lc iq mv b gy nl ng l nh ni">});</span><span id="b804" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** Server */</em></span><span id="a9dd" class="ne lc iq mv b gy nl ng l nh ni">app.listen(port, () =&gt; {</span><span id="ce78" class="ne lc iq mv b gy nl ng l nh ni">  console.log(`API listening on localhost: ${port}`);</span><span id="fbfb" class="ne lc iq mv b gy nl ng l nh ni">});</span></pre><h1 id="8520" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">实施CRUD</h1><p id="8ed1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">完成设置并编写好验证器后，现在可以专注于用Prisma编写类型安全的Javascript了。在本节中，您将学习为您的API编写所有的CRUD方法。</p><p id="7814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个CRUD操作都将在Routes部分用一个新方法编写。在生产环境中，这些文件通常被分割成它们自己的源文件。但是出于演示的目的，这个例子将把所有东西都留在<code class="fe ms mt mu mv b">index.js</code>中。</p><h1 id="079c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Prisma和MySQL创建记录</h1><p id="a242" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">记录通常是通过POST请求创建的，因此您需要遵守这个约定。以下示例包括以下处理记录创建的途径:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c6e6" class="ne lc iq mv b gy nf ng l nh ni"><em class="nk">/** Create a new supplier and write it to MySQL */</em></span><span id="f71d" class="ne lc iq mv b gy nl ng l nh ni">app.post("/supplier/create", joiMiddleware.query(supplierSchema), async (req, res) =&gt; {</span><span id="7fb7" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  try</em> {</span><span id="4c2c" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">    /** Use Prisma to write the data to our MySQL database */</em></span><span id="4335" class="ne lc iq mv b gy nl ng l nh ni">    res.body = <em class="nk">await</em> prisma.supplier.create({</span><span id="6293" class="ne lc iq mv b gy nl ng l nh ni">      data: {</span><span id="4931" class="ne lc iq mv b gy nl ng l nh ni">        name: req.body.name,</span><span id="77d1" class="ne lc iq mv b gy nl ng l nh ni">        contact: req.body.contact,</span><span id="451d" class="ne lc iq mv b gy nl ng l nh ni">        email: req.body.email,</span><span id="74e6" class="ne lc iq mv b gy nl ng l nh ni">        phone_num: req.body.phone_num,</span><span id="e954" class="ne lc iq mv b gy nl ng l nh ni">        address: req.body.address,</span><span id="8aeb" class="ne lc iq mv b gy nl ng l nh ni">      }</span><span id="a660" class="ne lc iq mv b gy nl ng l nh ni">    });</span><span id="42ff" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  /** Send a response telling the user our data has been written */</em></span><span id="4169" class="ne lc iq mv b gy nl ng l nh ni">  res.status(200).send({"message": "OK"});</span><span id="b316" class="ne lc iq mv b gy nl ng l nh ni">  }</span><span id="f933" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  /** If Prisma fails to write to the MySQL database */</em></span><span id="04c3" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  /** Catch the error and send it as our response */</em></span><span id="8332" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  catch</em> (err) {</span><span id="c5cc" class="ne lc iq mv b gy nl ng l nh ni">    res.status(500).send(err);</span><span id="207a" class="ne lc iq mv b gy nl ng l nh ni">  }</span><span id="6c33" class="ne lc iq mv b gy nl ng l nh ni">});</span></pre><p id="6f33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看上面的代码，您可以在路由定义中看到对Joi中间件的查询。但是Prisma正在进行自己的验证，它抛出的任何错误都由catch块处理。例如，Prisma模型指定每个供应商需要一个唯一的名称。您可以使用Postman来查看Prisma如何处理重名:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/8dbcdcec555b3eb2aed667a8591a4af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VAmFMjGuKghrBdAf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在Postman接口中显示的具有重复名称的API请求的500内部服务器错误状态。</figcaption></figure><p id="620a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意500 Internal Server错误，以及JSON响应中的target字段，指出Prisma需要一个惟一的名称。</p><h1 id="ce21" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Prisma从MySQL中读取记录</h1><p id="07be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是另一个使用Prisma的方法，但是这次您将返回一个与给定名称匹配的Supplier对象。</p><p id="3a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为您将根据名称返回有关供应商的所有信息，所以这是您需要验证的唯一变量。有了新模式后，编写代码返回您的供应商对象:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d99d" class="ne lc iq mv b gy nf ng l nh ni"><em class="nk">/** Get a supplier by name, return the object in our response */</em></span><span id="8531" class="ne lc iq mv b gy nl ng l nh ni">app.get('/supplier', async (req, res) =&gt; {</span><span id="31d7" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  try</em> {</span><span id="3d82" class="ne lc iq mv b gy nl ng l nh ni">    const supplier = <em class="nk">await</em> prisma.supplier.findUnique({</span><span id="440b" class="ne lc iq mv b gy nl ng l nh ni">      where: {</span><span id="b965" class="ne lc iq mv b gy nl ng l nh ni">        name: req.body.name,</span><span id="131f" class="ne lc iq mv b gy nl ng l nh ni">      }</span><span id="c22f" class="ne lc iq mv b gy nl ng l nh ni">    });</span><span id="9f8a" class="ne lc iq mv b gy nl ng l nh ni">    /** Send the Supplier object as our response */</span><span id="d633" class="ne lc iq mv b gy nl ng l nh ni">    res.status(200).send({"object": supplier});</span><span id="ccc2" class="ne lc iq mv b gy nl ng l nh ni">  }</span><span id="4db8" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  /** When Prisma fails to read from database, catch the error and send it as our response */</em></span><span id="d851" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  catch</em> (err) {</span><span id="23ac" class="ne lc iq mv b gy nl ng l nh ni">    res.status(500).send(err);</span><span id="8d53" class="ne lc iq mv b gy nl ng l nh ni">  }</span><span id="31fd" class="ne lc iq mv b gy nl ng l nh ni">});</span></pre><p id="9a49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个有效的名称被传递给API服务器上的<code class="fe ms mt mu mv b"> /supplier</code>路径时，供应商对象作为一个JSON数组返回:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/078080f6f624462ec688cec5d7c80c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7_-gbLcWCRO-rxGi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">成功请求中的供应商对象JSON。</figcaption></figure><p id="aad4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在左边看到查询，在右边看到响应。Prisma能够使用它的<code class="fe ms mt mu mv b"><a class="ae kc" href="https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#findfirst" rel="noopener ugc nofollow" target="_blank">findUnique()</a></code> <a class="ae kc" href="https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#findfirst" rel="noopener ugc nofollow" target="_blank">方法</a>找到供应商对象。</p><h1 id="92e6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Prisma更新MySQL中的记录</h1><p id="2da6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接下来，尝试构建更新方法。在本例中，您将使用供应商id来更新相应的对象。一旦找到正确的供应商，Prisma将修补更新的数据，并返回一条表示成功的消息:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5e75" class="ne lc iq mv b gy nf ng l nh ni"><em class="nk">/** Update an existing supplier */</em></span><span id="e46c" class="ne lc iq mv b gy nl ng l nh ni">app.patch("/supplier/update", joiMiddleware.query(supplierSchema), async (req, res) =&gt; {</span><span id="a460" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  try</em> {</span><span id="fd1a" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">    /** Use Prisma to write the data to our MySQL database */</em></span><span id="9427" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">    await</em> prisma.supplier.update({</span><span id="5366" class="ne lc iq mv b gy nl ng l nh ni">      where: {</span><span id="8dd7" class="ne lc iq mv b gy nl ng l nh ni">        id: req.body.id,</span><span id="ae9d" class="ne lc iq mv b gy nl ng l nh ni">      },</span><span id="7583" class="ne lc iq mv b gy nl ng l nh ni">      data: {</span><span id="2ad5" class="ne lc iq mv b gy nl ng l nh ni">        name: req.body.name,</span><span id="1167" class="ne lc iq mv b gy nl ng l nh ni">        contact: req.body.contact,</span><span id="d4e1" class="ne lc iq mv b gy nl ng l nh ni">        email: req.body.email,</span><span id="ede7" class="ne lc iq mv b gy nl ng l nh ni">        phone_num: req.body.phone_num,</span><span id="8335" class="ne lc iq mv b gy nl ng l nh ni">        address: req.body.address,</span><span id="8b8f" class="ne lc iq mv b gy nl ng l nh ni">     }</span><span id="9770" class="ne lc iq mv b gy nl ng l nh ni">   });</span><span id="1d52" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">   /** Send a response telling the user our data has been written */</em></span><span id="0777" class="ne lc iq mv b gy nl ng l nh ni">   res.status(200).send({"message": "OK"});</span><span id="7823" class="ne lc iq mv b gy nl ng l nh ni">  }</span><span id="7364" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">/** When Prisma fails to write to database, catch the error and send it as response */</em></span><span id="3712" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  catch</em> (err) {</span><span id="9c1a" class="ne lc iq mv b gy nl ng l nh ni">    res.status(500).send(err);</span><span id="ffee" class="ne lc iq mv b gy nl ng l nh ni">  }</span><span id="172a" class="ne lc iq mv b gy nl ng l nh ni">})</span></pre><p id="c4f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果仔细观察，您可能会注意到update方法看起来像是read和create的组合。该示例首先通过id进行查询，然后使用Prisma来覆盖Supplier对象中的name、contact、email、phone_num和address字段。</p><p id="e8b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会惊讶地看到该示例在所有字段中都通过了测试。很容易想象MySQL可能会用空字符串覆盖数据库中的信息。但是JSON对象会自动删除未定义的字符串，所以更新整个对象是安全的。</p><p id="e0bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在检查数据库，看看更新是否有效。下面的例子使用<a class="ae kc" href="https://www.prisma.io/studio" rel="noopener ugc nofollow" target="_blank"> Prisma Studio </a>浏览数据库。以下是更新前的数据:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/8486690f60087d7f2148a27fe58b236c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bdm3LYTKC8ap9mgu"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Prisma Studio界面中显示的原始供应商记录。</figcaption></figure><p id="4d6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是更新请求后的数据:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/b74bb7f0cace63aff521c875c55bb5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yGEAZPHTRy28fR7k"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Prisma Studio界面中显示的更新后的供应商记录。</figcaption></figure><p id="a623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，联系人姓名和电子邮件地址按预期进行了更改。</p><h1 id="fb20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Prisma从MySQL中删除记录</h1><p id="b9b4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">删除供应商对象与读取非常相似。在这种情况下，可以使用delete()方法，而不是使用Prisma的findFirst()方法。以下是删除操作的代码:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="ab38" class="ne lc iq mv b gy nf ng l nh ni"><em class="nk">/** Delete a supplier with a given name */</em></span><span id="1715" class="ne lc iq mv b gy nl ng l nh ni">app.delete('/supplier/delete', joiMiddleware.query(supplierSchema), async (req, res) =&gt; {</span><span id="cb39" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  try</em> {</span><span id="c881" class="ne lc iq mv b gy nl ng l nh ni">    const supplier = <em class="nk">await</em> prisma.supplier.delete({</span><span id="9a0b" class="ne lc iq mv b gy nl ng l nh ni">      where: {</span><span id="d097" class="ne lc iq mv b gy nl ng l nh ni">        name: req.body.name,</span><span id="4154" class="ne lc iq mv b gy nl ng l nh ni">      }</span><span id="8105" class="ne lc iq mv b gy nl ng l nh ni">    });</span><span id="cfce" class="ne lc iq mv b gy nl ng l nh ni">    res.status(200).send({"message": "deleted OK"});</span><span id="2612" class="ne lc iq mv b gy nl ng l nh ni">  }</span><span id="cac9" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  /** If Prisma fails to delete the object, catch the error and send it as response */</em></span><span id="ed3a" class="ne lc iq mv b gy nl ng l nh ni"><em class="nk">  catch</em> (err) {</span><span id="ec45" class="ne lc iq mv b gy nl ng l nh ni">    res.status(500).send(err);</span><span id="a6e3" class="ne lc iq mv b gy nl ng l nh ni">  }</span><span id="ba72" class="ne lc iq mv b gy nl ng l nh ni">});</span></pre><p id="4def" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在收到预期响应时确认对象已删除:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/3b7aabd3581c264f1c387321134311fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zuWwJay_sF_iKuCZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">对象删除的确认。</figcaption></figure><p id="b146" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现了delete方法之后，所有的CRUD操作都实现了。最终的API很稀疏，但是很完整。</p><h1 id="590a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Prisma进行类型安全的Javascript API调用</h1><p id="7132" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从代码中可以看出，通过Prisma和仔细的验证，可以在Javascript中获得某种程度的类型安全。另一个解决方案可能是使用Typescript实现这个API，这在默认情况下是类型安全的。但是对于许多项目来说，Prisma提供的类型安全级别已经足够了。</p><p id="2952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的源代码供参考:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="7329" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">改进和变化</h1><p id="87d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您对使用Javascript和Prisma进行后端编程感兴趣，您可能想要花一些时间来完善这个CRUD实现。这个例子是基于为了保持事情简单而做出的决定。</p><p id="cb11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会对<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes" rel="noopener ugc nofollow" target="_blank">路线和控制器逻辑</a>进行更改。它们应该被完全分割成它们自己的文件。生产API以模块化的方式路由和控制器。</p><h1 id="0eb3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Prisma为Javascript带来了类型安全</h1><p id="5405" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这个例子只涉及到Prisma的一些特性。它提供了一种简单的、声明性的方法来建模大型或复杂的数据库。因为您只建模了一个表，所以您可能没有意识到它的伸缩性有多好。</p><p id="902d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prisma提供的不仅仅是类型安全的数据库查询。Prisma Studio和CLI简化了数据库管理和迁移。</p><p id="646b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于使用Prisma的深入API实现，看一看<a class="ae kc" href="https://www.prisma.io/blog/series/modern-backend-bdes2ps5kibb" rel="noopener ugc nofollow" target="_blank">用TypeScript、PostrgreSQL和Prisma </a>构建一个现代后端。如果需要指导，可以<a class="ae kc" href="https://slack.prisma.io/" rel="noopener ugc nofollow" target="_blank">加入Prisma Slack频道</a>。</p></div></div>    
</body>
</html>