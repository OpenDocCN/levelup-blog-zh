<html>
<head>
<title>Build a JavaScript Promise from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始构建JavaScript承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-javascript-promises-by-building-a-fully-working-promise-from-scratch-c9eabe73fa3?source=collection_archive---------2-----------------------#2020-01-13">https://levelup.gitconnected.com/learn-javascript-promises-by-building-a-fully-working-promise-from-scratch-c9eabe73fa3?source=collection_archive---------2-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="acc1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习JavaScript promises并构建自己的Promise.then()。catch()实现来深入理解promises以及它们如何处理JavaScript中的异步代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e5bfa7eb0b4c9b214ef1f6f016297fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGNlA3qp4ReTAeC3lGjsJA.jpeg"/></div></div></figure><p id="d5f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">原文</strong> <a class="ae lq" href="https://skilled.dev/course/build-a-javascript-promise" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">此处</strong> </a> <strong class="kw iu"> : </strong></p><div class="lr ls gp gr lt lu"><a href="https://skilled.dev/course/build-a-javascript-promise" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">构建一个JavaScript Promise编码面试问题| Skilled.dev</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">注意:如果您想看到我们的promise实现如何处理一个真实的API请求，请查看……</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">技术开发</p></div></div><div class="md l"><div class="me l mf mg mh md mi ks lu"/></div></div></a></div><p id="5df8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">异步编程是JavaScript中的一个核心概念，与其他脚本编程语言相比，这一特性大大提高了JavaScript的速度。JavaScript是单线程的，这意味着它逐行执行程序。它也是异步的，这意味着如果我们的程序执行到了一个必须等待结果的代码块，它将继续通过这个正在等待的代码块，这样程序就不会冻结执行，一旦异步任务完成，我们的代码将通过使用一个承诺或回调来处理它正在等待的结果。</p><p id="d8c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自ES2015以来，处理异步函数调用结果的最常见方式是通过<code class="fe mj mk ml mm b">Promise</code>，但在此之前使用了回调。最近，<code class="fe mj mk ml mm b">async</code> / <code class="fe mj mk ml mm b">await</code>语法被添加到JavaScript中，但这只是对承诺的抽象，我们将在文章的最后看到它们的比较。</p><p id="6221" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本课中，您将通过从头构建JavaScript promise实现来学习JavaScript promise。你的承诺将像在原生JavaScript <code class="fe mj mk ml mm b">new Promise(...)</code>中一样被声明，它将能够链接<code class="fe mj mk ml mm b">.then()</code>和<code class="fe mj mk ml mm b">.catch()</code>语句来处理异步代码的结果。</p><h2 id="9a69" class="mn mo it bd mp mq mr dn ms mt mu dp mv ld mw mx my lh mz na nb ll nc nd ne nf bi translated">履行诺言</h2><p id="39be" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们正在构建的JavaScript promise示例旨在帮助您理解承诺和异步思维的基础——它并不打算展示承诺的最佳版本。我将首先为初学者描述promise，然后深入我们自己的promise实现，这样我们就可以从头开始理解它。</p><p id="47a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能以前见过类似的东西:</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="304d" class="mn mo it mm b gy np nq l nr ns">fetch('/user/1')<br/>  .then((user) =&gt; { <br/>    /* Do something with user after the API returns */ <br/>  })</span></pre><p id="7d78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在执行任何操作之前，<code class="fe mj mk ml mm b">.then()</code>中的代码块会一直等待，直到收到来自服务器的响应。这叫做<code class="fe mj mk ml mm b">Promise</code>。但是不要让花哨的名字或存在异步代码的事实吓倒你——<code class="fe mj mk ml mm b">Promise</code>只是一个普通的老式JavaScript对象，它具有特殊的方法，允许你同步执行代码(即使有延迟，它也会按顺序执行)。</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="06a4" class="mn mo it mm b gy np nq l nr ns">typeof new Promise((resolve, reject) =&gt; {}) === 'object' // true</span></pre><p id="81cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我重申一下(因为这是我刚学承诺时很难把握的东西)，a <code class="fe mj mk ml mm b">Promise</code>只是一个对象。为了能够在响应后等待服务器并执行<code class="fe mj mk ml mm b">.then()</code>链中的代码，您必须<code class="fe mj mk ml mm b">return</code>一个<code class="fe mj mk ml mm b">Promise</code>对象。这不是函数开箱即用的东西。在幕后，fetch函数正在做这样的事情。</p><pre class="kj kk kl km gt nl mm nm nn aw no bi"><span id="2cfa" class="mn mo it mm b gy np nq l nr ns">const fetch = function(url) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    request((error, apiResponse) =&gt; {<br/>      if (error) {<br/>        reject(error)<br/>      }<br/>      <br/>      resolve(apiResponse)<br/>    })<br/>  })<br/>}</span></pre><p id="3729" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mj mk ml mm b">fetch()</code>函数向服务器发出http请求，但是客户端不知道服务器什么时候会发回结果。因此JavaScript开始执行其他不相关的代码，同时等待服务器返回响应。一旦客户端收到响应，它就会通过调用<code class="fe mj mk ml mm b">resolve(apiResponse)</code>来启动<code class="fe mj mk ml mm b">.then()</code>语句中代码的执行。</p><p id="528e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们仔细看看<code class="fe mj mk ml mm b">Promise</code>实际上是如何让你做到这一点的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">一个承诺的教育例子—<a class="ae lq" href="https://gist.github.com/treyhuffine/d2e63bdee6645a7a0619989ee5a4538b" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/trey huffine/d 2e 63 bdee 6645 a7a 0619989 ee5a 4538 b</a></figcaption></figure><blockquote class="nz oa ob"><p id="a880" class="ku kv oc kw b kx ky ju kz la lb jx lc od le lf lg oe li lj lk of lm ln lo lp im bi translated">注意:这个版本的承诺仅用于教育目的。我省略了一些更高级的特性，将其提炼为核心功能。</p></blockquote><p id="bc3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我把它命名为<code class="fe mj mk ml mm b">PromiseSimple</code>，这样它就不会和原生的<code class="fe mj mk ml mm b">Promise</code>冲突，以防你想把它复制粘贴到你的Chrome控制台上。我们的承诺实现有一个<code class="fe mj mk ml mm b">constructor</code>，2个你可能熟悉的公共方法<code class="fe mj mk ml mm b">then()</code>和<code class="fe mj mk ml mm b">catch()</code>，2个内部方法<code class="fe mj mk ml mm b">onResolve()</code>和<code class="fe mj mk ml mm b">onReject()</code>。</p><p id="52ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你创造一个承诺时，你是这样做的。你传递给它一个回调函数，我在构造函数中命名为<code class="fe mj mk ml mm b">executionFunction</code>。执行函数采用映射到内部<code class="fe mj mk ml mm b">onResolve()</code>和<code class="fe mj mk ml mm b">onReject()</code>函数的<code class="fe mj mk ml mm b">resolve</code>和<code class="fe mj mk ml mm b">reject</code>。当fetch调用resolve或reject时，将调用这些函数。</p><p id="e1bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构造函数还创建了一个<code class="fe mj mk ml mm b">promiseChain</code>数组和<code class="fe mj mk ml mm b">handleError</code>函数。当添加一系列<code class="fe mj mk ml mm b">.then(() =&gt; {})</code>时，它会将每个功能推送到<code class="fe mj mk ml mm b">promiseChain</code>上。当用户调用<code class="fe mj mk ml mm b">catch(() =&gt; {})</code>时，它将函数分配给内部<code class="fe mj mk ml mm b">handleError</code>。注意<code class="fe mj mk ml mm b">then()</code>和<code class="fe mj mk ml mm b">catch()</code>功能<code class="fe mj mk ml mm b">return this;</code>。这允许你链接多个<code class="fe mj mk ml mm b">then()</code>，因为你正在返回对象本身。</p><blockquote class="nz oa ob"><p id="5a32" class="ku kv oc kw b kx ky ju kz la lb jx lc od le lf lg oe li lj lk of lm ln lo lp im bi translated">注意:在原生的<code class="fe mj mk ml mm b"><em class="it">Promise</em></code>中，这些<code class="fe mj mk ml mm b"><em class="it">then()</em></code>和<code class="fe mj mk ml mm b"><em class="it">catch()</em></code>函数实际上返回了一个<code class="fe mj mk ml mm b"><em class="it">new Promise</em></code>，但是对于这个简单的场景，我只返回了<code class="fe mj mk ml mm b"><em class="it">this</em></code>。此外，可以有多个<code class="fe mj mk ml mm b"><em class="it">.catch()</em></code>模块，它们也可以被链接，并且不需要出现在<code class="fe mj mk ml mm b"><em class="it">.then()</em></code>链的末端。</p></blockquote><p id="5716" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当异步函数调用<code class="fe mj mk ml mm b">resolve(apiResponse)</code>时，promise对象开始执行<code class="fe mj mk ml mm b">onResolve(apiResponse)</code>。它通过删除前面的函数来遍历整个<code class="fe mj mk ml mm b">promiseChain</code>，并使用保存在<code class="fe mj mk ml mm b">storedValue</code>中的最新值来执行它。然后将<code class="fe mj mk ml mm b">storedValue</code>更新为最近一次执行的结果。它将按顺序执行这些功能。这就创建了同步承诺链。</p><p id="7906" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个循环被包裹在一个<code class="fe mj mk ml mm b">try/catch</code>块中。这是查找错误的特殊JavaScript语法。如果你的异步函数调用了<code class="fe mj mk ml mm b">reject(error)</code>或者你的<code class="fe mj mk ml mm b">try/catch</code>发现了一个错误，那么它将被传递给<code class="fe mj mk ml mm b">onReject()</code>方法，该方法调用你传递给<code class="fe mj mk ml mm b">.catch()</code>的函数。</p><p id="5454" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结合一个更实际的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/treyhuffine/f21525172fece828d385f9c5db8f87a0" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/trey huffine/f 21525172 fece 828d 385 f 9 C5 db 8 f 87 a 0</a></figcaption></figure><h2 id="e51f" class="mn mo it bd mp mq mr dn ms mt mu dp mv ld mw mx my lh mz na nb ll nc nd ne nf bi translated">异步/等待</h2><p id="4baf" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated"><code class="fe mj mk ml mm b">async</code> / <code class="fe mj mk ml mm b">await</code>语法只是承诺的包装。</p><p id="53b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您将函数标记为async，它只是将返回响应转换为承诺。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="59cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这相当于执行以下操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div></div>    
</body>
</html>