<html>
<head>
<title>Introduction to TypeScript Enums — Const and Ambient Enums</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本枚举简介—常量枚举和环境枚举</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-typescript-enums-const-and-ambient-enums-1fe686b67495?source=collection_archive---------5-----------------------#2020-02-06">https://levelup.gitconnected.com/introduction-to-typescript-enums-const-and-ambient-enums-1fe686b67495?source=collection_archive---------5-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9a017dd2d853422377c857cffaef8b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J3rGuy-00MzB6iP9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@zmachacek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">zdenk Macháek</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4759" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想在JavaScript中定义常量，我们可以使用<code class="fe le lf lg lh b">const</code>关键字。使用TypeScript，我们有另一种方法来定义一组称为枚举的常量。枚举让我们定义一个命名常量的列表。对于定义一个可以取几个可能值的实体来说，这很方便。在本文中，我们将从第1部分继续，看看联合枚举和枚举成员类型，如何在运行时计算枚举，<code class="fe le lf lg lh b">const</code>枚举和环境枚举。</p><h1 id="a6ea" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">联合枚举和枚举成员类型</h1><p id="de19" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">枚举成员的子集可以充当TypeScript中变量和类成员的数据类型。我们可以使用文字枚举成员，它们是没有指定特定值的枚举成员，用于注释变量和类成员的数据类型。如果一个枚举成员没有字符串文字、数字文字或前面带有减号的数字文字，那么我们可以将它们用作其他成员的数据类型。例如，我们可以像在下面的代码中一样使用它们:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f378" class="mt lj it lh b gy mu mv l mw mx">enum Fruit {<br/>  Orange,<br/>  Apple,<br/>  Grape<br/>}</span><span id="e6c2" class="mt lj it lh b gy my mv l mw mx">interface OrangeInterface {<br/>  kind: Fruit.Orange;<br/>  color: string;    <br/>}</span><span id="30aa" class="mt lj it lh b gy my mv l mw mx">interface AppleInterface {<br/>  kind: Fruit.Apple;<br/>  color: string;    <br/>}</span><span id="df48" class="mt lj it lh b gy my mv l mw mx">class Orange implements OrangeInterface {<br/>  kind: Fruit.Orange = Fruit.Orange;<br/>  color: string = 'orange';<br/>}</span><span id="8c4a" class="mt lj it lh b gy my mv l mw mx">class Apple implements AppleInterface{<br/>  kind: Fruit.Apple = Fruit.Apple;<br/>  color: string = 'red';<br/>}</span><span id="78e5" class="mt lj it lh b gy my mv l mw mx">let orange: Orange = new Orange();<br/>let Apple: Orange = new Apple();</span></pre><p id="b04e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了我们的<code class="fe le lf lg lh b">Fruit</code>枚举来注释我们的<code class="fe le lf lg lh b">OrangeInterface</code>和<code class="fe le lf lg lh b">AppleInterface</code>中的<code class="fe le lf lg lh b">kind</code>字段的类型。我们将它设置为只能将<code class="fe le lf lg lh b">Fruit.Orange</code>分配给<code class="fe le lf lg lh b">OrangeInterface</code>的<code class="fe le lf lg lh b">kind</code>字段和实现<code class="fe le lf lg lh b">OrangeInterface</code>的类<code class="fe le lf lg lh b">Orange</code>。同样，我们将<code class="fe le lf lg lh b">AppleInterface</code>的<code class="fe le lf lg lh b">kind</code>字段设置为类型<code class="fe le lf lg lh b">Fruit.Apple</code>，这样我们只能将<code class="fe le lf lg lh b">kind</code>字段分配给<code class="fe le lf lg lh b">Apple</code>类实例的值。这样，我们可以使用<code class="fe le lf lg lh b">kind</code>字段作为常量字段，即使我们不能在类字段之前使用<code class="fe le lf lg lh b">const</code>关键字。</p><p id="2ff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们记录上面的<code class="fe le lf lg lh b">orange</code>和<code class="fe le lf lg lh b">apple</code>的值，我们得到<code class="fe le lf lg lh b">orange</code>是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="89cd" class="mt lj it lh b gy mu mv l mw mx">{kind: 0, color: "orange"}</span></pre><p id="7fae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而<code class="fe le lf lg lh b">apple</code>有这个价值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="71a3" class="mt lj it lh b gy mu mv l mw mx">{kind: 1, color: "red"}</span></pre><p id="deeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们在<code class="fe le lf lg lh b">if</code>语句中使用枚举时，TypeScript编译器将检查枚举成员是否以有效的方式使用。例如，它会阻止我们编写使用枚举的表达式，这些枚举总是计算为<code class="fe le lf lg lh b">true</code>或<code class="fe le lf lg lh b">false</code>。例如，如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="953d" class="mt lj it lh b gy mu mv l mw mx">enum Fruit {<br/>  Orange,<br/>  Apple,<br/>  Grape<br/>}</span><span id="8733" class="mt lj it lh b gy my mv l mw mx">function f(x: Fruit) {<br/>  if (<br/>   x !== Fruit.Orange || <br/>   x !== Fruit.Apple || <br/>   x !== Fruit.Grape<br/>  ) {</span><span id="c657" class="mt lj it lh b gy my mv l mw mx">  }<br/>}</span></pre><p id="f1c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到错误消息“这个条件将总是返回‘真’,因为类型‘果。橘子和水果。苹果没有重叠。(2367)“既然它们中至少有一个总是<code class="fe le lf lg lh b">true</code>，那么表达式:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f9b1" class="mt lj it lh b gy mu mv l mw mx">x !== Fruit.Orange || <br/>x !== Fruit.Apple || <br/>x !== Fruit.Grape</span></pre><p id="158d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总会评价到<code class="fe le lf lg lh b">true</code>。这是因为如果<code class="fe le lf lg lh b">x</code>只能是<code class="fe le lf lg lh b">Fruit</code>类型，而<code class="fe le lf lg lh b">x</code>不是<code class="fe le lf lg lh b">Fruit.Orange</code>，那么不是<code class="fe le lf lg lh b">Fruit.Apple</code>就是<code class="fe le lf lg lh b">Fruit.Grape</code>，所以其中一个必然是<code class="fe le lf lg lh b">true</code>。</p><p id="72bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也意味着枚举类型本身是每个成员的并集，因为每个成员都可以用作类型。如果数据类型将枚举作为类型，则它必须始终将其中一个成员作为实际类型。</p><h1 id="7a89" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">运行时如何计算枚举</h1><p id="11ab" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当枚举由TypeScript编译器编译时，它们被转换为真实对象，因此它们在运行时总是被视为对象。这意味着，如果我们有一个枚举，那么当我们需要把它作为参数传入时，我们可以用它的成员名作为枚举对象的属性名。例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1a75" class="mt lj it lh b gy mu mv l mw mx">enum Fruit {<br/>  Orange,<br/>  Apple,<br/>  Grape<br/>}</span><span id="1df0" class="mt lj it lh b gy my mv l mw mx">function f(fruit: { Orange: number }) {<br/>  return fruit.Orange;<br/>}<br/>console.log(f(Fruit));</span></pre><p id="6c98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们从最后一行代码的<code class="fe le lf lg lh b">console.log</code>输出中得到0，因为我们记录了<code class="fe le lf lg lh b">fruit.Orange</code>的值，它是0，因为我们没有将其初始化为任何值。同样，我们可以像在下面的代码中一样，对枚举的析构赋值使用相同的语法:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a05a" class="mt lj it lh b gy mu mv l mw mx">enum Fruit {<br/>  Orange,<br/>  Apple,<br/>  Grape<br/>}</span><span id="864e" class="mt lj it lh b gy my mv l mw mx">let { Orange }: { Orange: number } = Fruit;<br/>console.log(Orange);</span></pre><p id="b9df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将<code class="fe le lf lg lh b">Fruit</code>枚举中的<code class="fe le lf lg lh b">Orange</code>成员视为对象的另一个属性，因此我们可以像上面那样用析构赋值将它赋给一个新变量。因此，如果我们像在上面代码片段的最后一行那样记录<code class="fe le lf lg lh b">Orange</code>，那么我们再次得到0。此外，我们可以使用析构赋值将它赋给一个名称不同于属性名的变量，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5f33" class="mt lj it lh b gy mu mv l mw mx">let { Orange: orange }: { Orange: number } = Fruit;<br/>console.log(orange);</span></pre><p id="68fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该从上面代码最后一行的<code class="fe le lf lg lh b">console.log</code>语句中再次得到0。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/a77a9e6598a3ab33e530b8a9e38263cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VS7RA_YSnWvHGZEN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kris_ricepees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gary Bendig </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="e56b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">编译时枚举</h1><p id="e9c7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">唯一的例外是，当我们使用关键字<code class="fe le lf lg lh b">keyof</code>和枚举一起使用时，枚举被视为对象。<code class="fe le lf lg lh b">keyof</code>关键字不像典型对象那样工作。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1940" class="mt lj it lh b gy mu mv l mw mx">let fruit: keyof Fruit;</span></pre><p id="65ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，TypeScript编译器希望我们将带有数字方法的字符串赋给它。例如，如果我们试图将类似于<code class="fe le lf lg lh b">'Orange'</code>的东西赋给上面的表达式，我们会得到下面的错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7849" class="mt lj it lh b gy mu mv l mw mx">Type '"Orange"' is not assignable to type '"toString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf" | "toLocaleString"'.(2322)</span></pre><p id="6ff8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是对<code class="fe le lf lg lh b">keyof</code>关键字典型用法的期望，因为对于普通对象，它应该让我们为跟在<code class="fe le lf lg lh b">keyof</code>关键字后面的对象分配属性名。要制作TypeScript，让我们给它分配<code class="fe le lf lg lh b">'Orange'</code>、<code class="fe le lf lg lh b">'Apple'</code>或<code class="fe le lf lg lh b">'Grape'</code>，我们可以在<code class="fe le lf lg lh b">keyof</code>关键字之后使用<code class="fe le lf lg lh b">typof</code>关键字，就像我们在下面的代码中做的那样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7cb0" class="mt lj it lh b gy mu mv l mw mx">enum Fruit {<br/>  Orange,<br/>  Apple,<br/>  Grape<br/>}</span><span id="f11e" class="mt lj it lh b gy my mv l mw mx">let fruit: keyof typeof Fruit = 'Orange';</span></pre><p id="ca70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将被TypeScript编译器接受并运行，因为这使得TypeScript将我们的枚举成员的名称视为对象的键名。</p><h1 id="df86" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">反向映射</h1><p id="0872" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">TypeScript中的数字枚举可以从枚举值映射到枚举名称。我们可以通过枚举成员的值来获取它的名字，通过分配给它的值来获取它。例如，如果我们有以下枚举:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="850e" class="mt lj it lh b gy mu mv l mw mx">enum Fruit {<br/>  Orange,<br/>  Apple,<br/>  Grape<br/>}</span></pre><p id="77f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过按索引获取字符串<code class="fe le lf lg lh b">'Orange'</code>来获取它，就像我们对以下代码所做的那样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="24b1" class="mt lj it lh b gy mu mv l mw mx">console.log(Fruit[0]);</span></pre><p id="ed7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码应该记录<code class="fe le lf lg lh b">'Orange'</code>，因为成员<code class="fe le lf lg lh b">Orange</code>的值是0，因为我们没有给它赋值。我们也可以通过使用括号内的成员常量来访问它，如下面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="49d4" class="mt lj it lh b gy mu mv l mw mx">console.log(Fruit[Fruit.Orange]);</span></pre><p id="f9a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe le lf lg lh b">Fruit.Orange</code>的值为0，所以它们是等价的。</p><h1 id="0bca" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">常数枚举</h1><p id="0f1b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以在枚举定义前添加<code class="fe le lf lg lh b">const</code>关键字，以防止它包含在由TypeScript编译器生成的编译代码中。这是可能的，因为枚举在编译后只是JavaScript对象。由于这个原因，枚举成员的值不能动态生成，但是它们可以从其他常数值中计算出来。例如，我们可以编写以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d4d1" class="mt lj it lh b gy mu mv l mw mx">const enum Fruit {<br/>  Orange,<br/>  Apple,<br/>  Grape = Apple + 1<br/>}</span><span id="4b2c" class="mt lj it lh b gy my mv l mw mx">let fruits = [<br/>  Fruit.Orange,<br/>  Fruit.Apple,<br/>  Fruit.Grape<br/>]</span></pre><p id="fdf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们的代码被编译成ES5时，我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0ed3" class="mt lj it lh b gy mu mv l mw mx">"use strict";<br/>let fruits = [<br/>    0 /* Orange */,<br/>    1 /* Apple */,<br/>    2 /* Grape */<br/>];</span></pre><h1 id="62b0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">环境枚举</h1><p id="0d9d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">要引用存在于代码中其他地方的枚举，我们可以在枚举定义前使用<code class="fe le lf lg lh b">declare</code>关键字来表示。环境枚举不能为任何成员赋值，也不会包含在编译后的代码中，因为它们应该引用在其他地方定义的枚举。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="95fc" class="mt lj it lh b gy mu mv l mw mx">declare enum Fruit {<br/>  Orange,<br/>  Apple,<br/>  Grape<br/>}</span></pre><p id="a418" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们试图引用一个没有在任何地方定义的环境枚举，我们将得到一个运行时错误，因为编译后的代码中没有包含查找对象。</p><p id="9c51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">枚举成员可以充当变量、类成员和任何其他可以用TypeScript类型化的事物的数据类型。枚举本身也可以是这些事情的数据类型。因此，任何使用枚举类型的类型都是所有成员枚举类型的联合类型。枚举是否包含取决于我们在枚举前使用的关键字。如果它们是用<code class="fe le lf lg lh b">const</code>或<code class="fe le lf lg lh b">declare</code>定义的，那么它们就不会包含在编译后的代码中。枚举在转换成JavaScript时只是对象，成员在编译成JavaScript时被转换成属性。这意味着我们可以使用成员名作为TypeScript中对象的属性名。</p></div></div>    
</body>
</html>