<html>
<head>
<title>Avoiding Array Pitfalls in C# .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免C#中的数组陷阱。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/avoiding-array-pitfalls-in-c-net-a229a29bc45d?source=collection_archive---------9-----------------------#2021-05-09">https://levelup.gitconnected.com/avoiding-array-pitfalls-in-c-net-a229a29bc45d?source=collection_archive---------9-----------------------#2021-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a4dc" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">优化。网络应用</h2><div class=""/><div class=""><h2 id="2f44" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">C#中基本类型的有效使用</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e62f5fae32dfdebc16dbe77f56011804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MglYTi4zszXa2YCC-uN1Ow.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">一个糟糕的笑话</figcaption></figure><p id="e1d7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过理解数组在。NET运行时并在处理应用程序热路径中的数组时为作业选择正确的特性。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="eb09" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">避免空数组分配</h1><p id="23d5" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">英寸NET中，数组是在创建后不能改变大小的对象。本质上，这意味着分配空数组的多个实例没有实际意义。这些实例只会污染运行时，并且在某些时候需要被GC收集。</p><p id="af2f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果分配和释放的数量足够大，这些分配的实例会导致应用程序效率低下。</p><p id="ebb5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这最终会导致额外的垃圾收集工作:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">空数组的分配</figcaption></figure><p id="e227" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当分配一个空数组时，不能在其中存储任何元素。那么，为什么要首先分配数组呢？</p><h2 id="e240" class="nj ml it bd mm nk nl dn mq nm nn dp mu lq no np mw lu nq nr my ly ns nt na iz bi translated"><strong class="ak">另类:阵。清空&lt; T &gt; () </strong></h2><p id="f41d" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated"><strong class="lj jd">阵列。Empty &lt; T &gt; () </strong>利用静态只读属性在应用程序的整个生命周期中只创建一个数组实例。</p><p id="c7d6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这种策略避免了相同类型的多个空数组实例，节省了内存和收集不需要的对象的额外GC工作。</p><p id="996c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是它的语法:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7759" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因为我们现在只处理一个实例，所以当针对任意数量的调用对<code class="fe nu nv nw nx b">Array.Empty&lt;T&gt;</code>和<code class="fe nu nv nw nx b">new []</code>进行基准测试时，我们可以实现零分配测量:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="ny"><p id="155c" class="nz oa it bd ob oc od oe of og oh mc dk translated"><strong class="ak">底线:</strong>避免分配新的空数组。使用数组。空&lt; T &gt;()取而代之。</p></blockquote><h1 id="781a" class="mk ml it bd mm mn oi mp mq mr oj mt mu ki ok kj mw kl ol km my ko om kp na nb bi translated">对大型数组使用数组池</h1><p id="33ca" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">对于在关键路径上创建数千个大型数组新实例的应用程序，使用<strong class="lj jd">数组池</strong>可能是值得考虑的。</p><p id="58ab" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过在堆上创建大型数组的新实例，应用程序可能会在其GC过程中经历高压力或多次暂停。</p><p id="d0e2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">ArrayPools通过利用指定泛型类型<strong class="lj jd"> &lt; T &gt; </strong>的可重用数组，提供了一种防止这些暂停的方法。ArrayPool类为我们提供了一个<strong class="lj jd"> Rent </strong>方法，该方法从该池中检索一个具有指定最小长度<strong class="lj jd">的数组，以备调用者使用。</strong></p><p id="882a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">ArrayPool的主要工作是通过减少应用程序分配和释放大型数组的数量来避免GC压力。</p><p id="f784" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是它的语法:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">数组池的使用</figcaption></figure><ul class=""><li id="f118" class="on oo it lj b lk ll ln lo lq op lu oq ly or mc os ot ou ov bi translated">非常重要的一点是，我们要将租来的归还给泳池，并且不再使用它。不将数组返回到池中可能会降低应用程序的性能，使用已经返回到池中的数组可能会导致运行时错误和崩溃。</li></ul><blockquote class="ny"><p id="d21d" class="nz oa it bd ob oc od oe of og oh mc dk translated"><strong class="ak">底线:</strong>避免分配和释放大的、长寿命的对象，而是重用它们。</p></blockquote><h1 id="5a53" class="mk ml it bd mm mn oi mp mq mr oj mt mu ki ok kj mw kl ol km my ko om kp na nb bi translated">数组方法及其LINQ对应物</h1><p id="0123" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">阅读<a class="ae ow" href="https://github.com/dotnet/roslyn/blob/main/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank">时你可以注意到的一个关键点。NET Roslyn编译器贡献指南</a>是以下语句:</p><pre class="ks kt ku kv gt ox nx oy oz aw pa bi"><span id="47a5" class="nj ml it nx b gy pb pc l pd pe">DO avoid allocations in compiler hot paths:<br/>    - DO avoid LINQ</span></pre><p id="ef01" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，看到LINQ方法漂亮地散布在一些代码库中并不罕见。</p><p id="84fa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="pf">*老实说，我甚至不确定</em> <strong class="lj jd"> <em class="pf">更具可读性</em> </strong> <em class="pf">的论点在某些情况下是否成立，但那是另一篇文章的讨论内容！</em>😉</p><p id="ef83" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">回到数组…如果你手头有一个具体的数组实例，你可能不需要LINQ命名空间的方法。</p><p id="273c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可能希望对其进行基准测试。但一般来说，在热路径上使用LINQ扩展方法往往会导致高负载下的代码效率低下，这主要是由于数组和接口类型之间的装箱和拆箱。</p><p id="ffb4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最重要的是，array类已经提供了许多现成的特性，如复制项目、过滤、搜索、排序、计数等。所以如果你不熟悉它的界面，花点时间阅读它的<a class="ae ow" href="https://referencesource.microsoft.com/#mscorlib/system/array.cs" rel="noopener ugc nofollow" target="_blank">源代码</a>或者官方<a class="ae ow" href="https://docs.microsoft.com/en-us/dotnet/api/system.array?view=net-5.0" rel="noopener ugc nofollow" target="_blank">微软文档</a>可能会很有趣。</p><p id="5de2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是对LINQ计数和任何针对<strong class="lj jd">数组的方法之间的差异的度量。长度</strong>属性:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="ny"><p id="620b" class="nz oa it bd ob oc od oe of og oh mc dk translated">底线:如果你不需要LINQ，就避开它。</p></blockquote><h1 id="45c4" class="mk ml it bd mm mn oi mp mq mr oj mt mu ki ok kj mw kl ol km my ko om kp na nb bi translated">一维、多维或锯齿状</h1><p id="340b" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">在C#中，我们有三种不同类型的数组:一维(又名。向量)、多维数组和交错数组。</p><p id="7b4b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">每一种都有自己特定的语法和方法。NET编译器会翻译你的代码。但总的来说，区别在于:</p><ul class=""><li id="4526" class="on oo it lj b lk ll ln lo lq op lu oq ly or mc os ot ou ov bi translated">CLR是专门为处理向量数组而调优的。NET编译器对此有专门的指令。这些总体上将比非向量数组(多维)更有效。</li><li id="22b9" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated">多维数组的每行总是有标准数量的列。</li><li id="293a" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated">交错数组是数组的数组。本质上，这使得它成为一个可以使用的向量，而不是一个多维向量。如果需要多个维度，交错数组通常是首选方式。</li></ul><p id="ef5c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是一个基准测试，我比较了交错阵列和多维阵列的访问速度:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="ny"><p id="4351" class="nz oa it bd ob oc od oe of og oh mc dk translated">底线:明智地选择你的类型。</p></blockquote><h1 id="136b" class="mk ml it bd mm mn oi mp mq mr oj mt mu ki ok kj mw kl ol km my ko om kp na nb bi translated">额外收获:足够有趣的语法让每个人都开心</h1><p id="5dca" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">数组可以用许多不同的方式来声明和初始化，只是为了让我们有足够的理由与我们的队友和同事进行富有成效的(<strong class="lj jd"><em class="pf">…或者不是</em> </strong>)编程语言大战。</p><p id="f78b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是标准的声明版本:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">标准数组声明</figcaption></figure><h2 id="6a72" class="nj ml it bd mm nk nl dn mq nm nn dp mu lq no np mw lu nq nr my ly ns nt na iz bi translated">隐式局部变量</h2><p id="9c18" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">我们可以使用C#的隐式类型化的<code class="fe nu nv nw nx b">var</code>关键字，只要类型是指定的(或推断的，见下文…):</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">带有隐式类型“var”关键字的数组声明</figcaption></figure><h2 id="87fe" class="nj ml it bd mm nk nl dn mq nm nn dp mu lq no np mw lu nq nr my ly ns nt na iz bi translated">创建期间的初始化</h2><p id="ccc0" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">可以用一行代码声明和初始化数组:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在创建时初始化数组</figcaption></figure><h2 id="2b94" class="nj ml it bd mm nk nl dn mq nm nn dp mu lq no np mw lu nq nr my ly ns nt na iz bi translated">一条捷径</h2><p id="bb0f" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">编译器可以在初始化期间自动推断数组元素的类型。因此，我们可以跳过声明数组类型，仍然使用关键字<code class="fe nu nv nw nx b">var</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">具有自动类型推断的数组初始化</figcaption></figure><h2 id="2faa" class="nj ml it bd mm nk nl dn mq nm nn dp mu lq no np mw lu nq nr my ly ns nt na iz bi translated">一条更短的路</h2><p id="7f5f" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">事实证明，我们最终可能不需要新的关键字:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">没有“new”关键字的数组初始化</figcaption></figure><h2 id="3cab" class="nj ml it bd mm nk nl dn mq nm nn dp mu lq no np mw lu nq nr my ly ns nt na iz bi translated">这个会导致你的电脑爆炸🔥小块的</h2><p id="af06" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">不幸的是，由于the.NET团队的决定，以下代码是无效的，并将引发编译错误:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="7d41" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">关键要点</h1><ul class=""><li id="647f" class="on oo it lj b lk nc ln nd lq pl lu pm ly pn mc os ot ou ov bi translated">除非有理由，否则永远不要分配空数组。⛔</li><li id="05aa" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated">当热路径上需要大型阵列时，可以考虑使用ArrayPool。🚀</li><li id="5912" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated">评估使用LINQ方法相对于本机类型方法的成本效益。⚖️</li><li id="f7d1" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated">并非所有阵列都是相同的。◾️ ◼️ ⬛️</li><li id="ea39" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated">选择你最喜欢的语法，进行几次语言大战。你只能活一次。✔️</li><li id="d3a9" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated">要经常衡量，做出自己的结论。⏰</li></ul><div class="po pp gp gr pq pr"><a rel="noopener  ugc nofollow" target="_blank" href="/8-hidden-visual-studio-features-26723606631b"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd jd gy z fp pw fr fs px fu fw jc bi translated">8个隐藏的Visual Studio功能</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">掌握Visual Studio快捷方式和隐藏功能</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf lb pr"/></div></div></a></div><h1 id="e3b7" class="mk ml it bd mm mn oi mp mq mr oj mt mu ki qg kj mw kl qh km my ko qi kp na nb bi translated">参考</h1><ul class=""><li id="d012" class="on oo it lj b lk nc ln nd lq pl lu pm ly pn mc os ot ou ov bi translated"><a class="ae ow" href="https://docs.microsoft.com/en-us/dotnet/api/system.array?view=net-5.0" rel="noopener ugc nofollow" target="_blank">数组类，微软文档</a></li><li id="163f" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated"><a class="ae ow" href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1?view=net-5.0" rel="noopener ugc nofollow" target="_blank">微软文档ArrayPool类</a></li><li id="c31a" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated"><a class="ae ow" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays" rel="noopener ugc nofollow" target="_blank">多维数组C#指南，微软文档</a></li><li id="95f5" class="on oo it lj b lk pg ln ph lq pi lu pj ly pk mc os ot ou ov bi translated"><a class="ae ow" href="https://github.com/dotnet/roslyn/blob/main/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank">罗斯林捐款指南</a></li></ul></div></div>    
</body>
</html>