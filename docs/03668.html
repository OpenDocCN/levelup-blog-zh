<html>
<head>
<title>Implement Code Splitting in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中实现代码拆分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-code-splitting-in-react-5210d727c49e?source=collection_archive---------20-----------------------#2020-05-21">https://levelup.gitconnected.com/implement-code-splitting-in-react-5210d727c49e?source=collection_archive---------20-----------------------#2020-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="18f1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">了解反应捆绑</strong></h1><p id="25d4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过使用<em class="lm"> _Webpack_ </em>或<em class="lm"> _Browserify_ </em>等工具，将React应用进行捆绑。捆绑意味着应用程序中的文件被导入并合并到一个文件中。这样，当您在网页中导入应用程序时，您只需导入一个文件。</p><p id="e5ea" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">假设您有两个文件:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="74ce" class="mb jr it lx b gy mc md l me mf">// greeting.js</span><span id="1a5d" class="mb jr it lx b gy mg md l me mf">export <em class="lm">const</em> greeting = () <em class="lm">=&gt;</em> {</span><span id="96de" class="mb jr it lx b gy mg md l me mf"><em class="lm">console</em>.log(“Hello my friend”);</span><span id="5b76" class="mb jr it lx b gy mg md l me mf">};</span><span id="da6f" class="mb jr it lx b gy mg md l me mf">```</span><span id="a2b3" class="mb jr it lx b gy mg md l me mf">```javascript</span><span id="651d" class="mb jr it lx b gy mg md l me mf">// index.js</span><span id="8231" class="mb jr it lx b gy mg md l me mf">import { greeting } from “./greeting.js”;</span><span id="ef3e" class="mb jr it lx b gy mg md l me mf">greeting();</span></pre><p id="282a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">包会将这些文件转换成:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1eb7" class="mb jr it lx b gy mc md l me mf"><em class="lm">const</em> greeting = () <em class="lm">=&gt;</em> {</span><span id="8da2" class="mb jr it lx b gy mg md l me mf"><em class="lm">console</em>.log(“Hello my friend”);</span><span id="6f26" class="mb jr it lx b gy mg md l me mf">};</span><span id="6441" class="mb jr it lx b gy mg md l me mf">greeting();</span></pre><p id="7c8d" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">当然，这是过于简化了，因为捆绑过程中有很多步骤，但你明白了。</p><h1 id="64b5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">捆绑发行</strong></h1><p id="a4af" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当您的应用程序很小的时候，捆绑是很棒的，但是随着您的应用程序的增长，捆绑也会增长。这意味着，如果用户加载你的web应用程序的主页，她仍然需要导入你的整个应用程序包…</p><p id="8fa8" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这可能会导致性能问题。为了避免这种情况，我们可以实现代码分割。在本文中，我们将根据我们的路线使用代码分割。</p><p id="d16b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><strong class="kq iu">导入()</strong></p><p id="e6f5" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">代码分割意味着我们将把代码分成更小的部分。然而，我们不需要改变我们的代码编写方式。我们将改变我们进口零部件的方式。我们需要告诉负责捆绑代码的工具何时拆分代码。</p><p id="cf15" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">如果你使用create-react-app，它使用Webpack，你将从使用动态<em class="lm"> _import_ </em>函数开始。语法如下:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="20e2" class="mb jr it lx b gy mc md l me mf">import(“./myModule.js”).then((<em class="lm">myModule</em>) <em class="lm">=&gt;</em> {</span><span id="2712" class="mb jr it lx b gy mg md l me mf">myModule.init();</span><span id="d688" class="mb jr it lx b gy mg md l me mf">});</span></pre><p id="c5a6" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">该语法承诺在使用文件内容之前等待Javascript文件被加载。</p><p id="81e1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><strong class="kq iu"> React.lazy </strong></p><p id="a7d7" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">React用<em class="lm"> _React.lazy_ </em>实现了这种逻辑。它允许您像显示任何其他组件一样显示一个组件，不同之处在于它将被动态导入。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="8dfb" class="mb jr it lx b gy mc md l me mf">import React, { lazy } from “react”;</span><span id="cbbb" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> DynamicallyImported = lazy(() <em class="lm">=&gt;</em> import(“./DynamicallyImported.js”));</span></pre><p id="36fe" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><em class="lm"> _React.lazy_ </em>采用返回动态导入的函数。这个组件不会像没有实现任何代码分割的应用程序一样与应用程序的其余部分一起导入。React将仅在首次渲染该组件时导入它。</p><p id="f0e0" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">注意，您动态导入的组件需要是默认导出，当然，它需要导出一个React组件。</p><p id="d880" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">因此，如果我们基于我们的路线实现代码分割，这意味着如果一个用户检查我们的应用程序并且从来没有到达一个特定的路线，那么这个路线根本不会被导入。这对你的用户来说是一个巨大的好处，因为你只需要强迫她的浏览器导入她需要的东西，仅此而已。</p><p id="242e" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><strong class="kq iu">悬念</strong></p><p id="7310" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">用<em class="lm"> _React.lazy_ </em>导入的组件必须在<strong class="kq iu">* *悬念** </strong>组件内部使用。一个<em class="lm">_ suspension _</em>组件提供回退内容。这些内容表明我们的惰性组件正在加载。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="12de" class="mb jr it lx b gy mc md l me mf">import React, { lazy, Suspense } from “react”;</span><span id="2261" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> DynamicallyImported = lazy(() <em class="lm">=&gt;</em> import(“./DynamicallyImported.js”));</span><span id="f66c" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> CoolComponent = () <em class="lm">=&gt;</em> {</span><span id="2f9e" class="mb jr it lx b gy mg md l me mf">  return (</span><span id="67fa" class="mb jr it lx b gy mg md l me mf">    &lt;div&gt;</span><span id="ff1d" class="mb jr it lx b gy mg md l me mf">      &lt;<em class="lm">Suspense</em> fallback={&lt;div&gt;Loading…&lt;/div&gt;}&gt;</span><span id="d005" class="mb jr it lx b gy mg md l me mf">        &lt;<em class="lm">DynamicallyImported</em> /&gt;</span><span id="1e36" class="mb jr it lx b gy mg md l me mf">      &lt;/<em class="lm">Suspense</em>&gt;</span><span id="bfb4" class="mb jr it lx b gy mg md l me mf">    &lt;/div&gt;</span><span id="f946" class="mb jr it lx b gy mg md l me mf">   );</span><span id="b9bb" class="mb jr it lx b gy mg md l me mf">};</span></pre><p id="cad4" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这种动态导入的组件不需要被一个悬念组件直接包围。一个暂挂组件还可以<em class="lm"> _handle_ </em>几个动态导入的组件:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="31dc" class="mb jr it lx b gy mc md l me mf">import React, { lazy, Suspense } from “react”;</span><span id="ce3c" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> DynamicallyImported = lazy(() <em class="lm">=&gt;</em> import(“./DynamicallyImported.js”));</span><span id="1f84" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> AnotherDynamicallyImported = lazy(() <em class="lm">=&gt;</em></span><span id="0995" class="mb jr it lx b gy mg md l me mf">import(“./AnotherDynamicallyImported.js”)</span><span id="1ceb" class="mb jr it lx b gy mg md l me mf">);</span><span id="a39d" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> CoolComponent = () <em class="lm">=&gt;</em> {</span><span id="7a3d" class="mb jr it lx b gy mg md l me mf">return (</span><span id="245d" class="mb jr it lx b gy mg md l me mf">  &lt;div&gt;</span><span id="49c0" class="mb jr it lx b gy mg md l me mf">     &lt;<em class="lm">Suspense</em> fallback={&lt;div&gt;Loading…&lt;/div&gt;}&gt;</span><span id="6d1e" class="mb jr it lx b gy mg md l me mf">     &lt;header&gt;</span><span id="1df3" class="mb jr it lx b gy mg md l me mf">       &lt;h1&gt;Hello there&lt;/h1&gt;</span><span id="b1c9" class="mb jr it lx b gy mg md l me mf">     &lt;/header&gt;</span><span id="d3b5" class="mb jr it lx b gy mg md l me mf">     &lt;div&gt;Something else&lt;/div&gt;</span><span id="dc39" class="mb jr it lx b gy mg md l me mf">     &lt;<em class="lm">DynamicallyImported</em> /&gt;</span><span id="7c9a" class="mb jr it lx b gy mg md l me mf">     &lt;p&gt;Divider&lt;/p&gt;</span><span id="fdfa" class="mb jr it lx b gy mg md l me mf">     &lt;<em class="lm">AnotherDynamicallyImported</em> /&gt;</span><span id="0e92" class="mb jr it lx b gy mg md l me mf">     &lt;/<em class="lm">Suspense</em>&gt; </span><span id="2bdb" class="mb jr it lx b gy mg md l me mf">  &lt;/div&gt;</span><span id="9712" class="mb jr it lx b gy mg md l me mf">);</span><span id="9947" class="mb jr it lx b gy mg md l me mf">};</span></pre><p id="fe84" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><strong class="kq iu">基于我们路线的代码分割</strong></p><p id="b9aa" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">路由是开始实现代码分割的好地方。从一个页面到另一个页面，用户希望页面作为一个块加载，并等待页面呈现。这是一个很好的起点，同时确保不会改变用户体验。</p><p id="7ee9" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">在这个例子中，我将使用流行的<em class="lm"> _react-router-dom_ </em>包来路由我的react应用程序。当然，它可以用于您喜欢的任何库。</p><p id="7500" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">在代码分割之前，您的<em class="lm"> _Router_ </em>组件可能看起来像这样:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1a75" class="mb jr it lx b gy mc md l me mf">import React from “react”;</span><span id="189a" class="mb jr it lx b gy mg md l me mf">import { Route, Router, Switch } from “react-router-dom”;</span><span id="f883" class="mb jr it lx b gy mg md l me mf">import Header from “./Header”;</span><span id="1eda" class="mb jr it lx b gy mg md l me mf">import About from “./pages/About”;</span><span id="1d18" class="mb jr it lx b gy mg md l me mf">import Blog from “./pages/Blog”;</span><span id="008b" class="mb jr it lx b gy mg md l me mf">import Contact from “./pages/Contact”;</span><span id="cbb5" class="mb jr it lx b gy mg md l me mf">import Home from “./pages/Home”;</span><span id="9f9b" class="mb jr it lx b gy mg md l me mf">import Products from “./pages/Products”;</span><span id="9dc8" class="mb jr it lx b gy mg md l me mf">import { createBrowserHistory } from “history”;</span><span id="b911" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> history = createBrowserHistory();</span><span id="b330" class="mb jr it lx b gy mg md l me mf">export default () <em class="lm">=&gt;</em> {</span><span id="f26d" class="mb jr it lx b gy mg md l me mf">  return (</span><span id="c1b0" class="mb jr it lx b gy mg md l me mf">    &lt;<em class="lm">Router</em> history={history}&gt;</span><span id="0f44" class="mb jr it lx b gy mg md l me mf">      &lt;<em class="lm">Header</em> /&gt;</span><span id="da4b" class="mb jr it lx b gy mg md l me mf">      &lt;<em class="lm">Switch</em>&gt;</span><span id="3c0d" class="mb jr it lx b gy mg md l me mf">        &lt;<em class="lm">Route</em> exact path=”/” component={Home} /&gt;</span><span id="e549" class="mb jr it lx b gy mg md l me mf">        &lt;<em class="lm">Route</em> path=”/about” component={About} /&gt;</span><span id="861b" class="mb jr it lx b gy mg md l me mf">        &lt;<em class="lm">Route</em> path=”/products” component={Products} /&gt;</span><span id="e346" class="mb jr it lx b gy mg md l me mf">        &lt;<em class="lm">Route</em> path=”/blog” component={Blog} /&gt;</span><span id="44c5" class="mb jr it lx b gy mg md l me mf">        &lt;<em class="lm">Route</em> path=”/contact” component={Contact} /&gt;</span><span id="c41d" class="mb jr it lx b gy mg md l me mf">      &lt;/<em class="lm">Switch</em>&gt;</span><span id="f6c7" class="mb jr it lx b gy mg md l me mf">    &lt;/<em class="lm">Router</em>&gt;</span><span id="e5b7" class="mb jr it lx b gy mg md l me mf">  );</span><span id="7378" class="mb jr it lx b gy mg md l me mf">};</span></pre><p id="407c" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">如果你以前用过<em class="lm"> _react-router-dom_ </em>，这个会比较熟悉。如果没有，这就是使用这个库实现路由的方式。</p><p id="f708" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">有了这段代码，每当用户转到一个页面时，整个应用程序代码都会被加载。因为我们只有一捆，不可能有别的办法！这可能很贵。</p><p id="3649" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们需要做三件事来使代码分割工作并拥有几个包:</p><p id="0356" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">1.导入<em class="lm"> _React.lazy_ </em>和<em class="lm">_悬念_ </em>。</p><p id="9e7d" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">2.使用<em class="lm"> _React.lazy_ </em>和<em class="lm"> _import()_ </em>修改我们导入组件(主页、关于、产品、博客和联系人)的方式，使其动态化</p><p id="8838" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">3.使用<em class="lm">_ suspension _</em>组件在我们的返回函数中提供一个后备。</p><p id="cbcf" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">1.您应该将第一行改为:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="be71" class="mb jr it lx b gy mc md l me mf">import React, {lazy, Suspense} from “react”;</span></pre><p id="ca56" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">搞定了。</p><p id="0ee4" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">2.动态导入我们的组件。将第4行改为第8行，如下所示:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="29e4" class="mb jr it lx b gy mc md l me mf"><em class="lm">const</em> About = lazy(() <em class="lm">=&gt;</em> import(“./pages/About”));</span><span id="3b23" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> Blog = lazy(() <em class="lm">=&gt;</em> import(“./pages/Blog”));</span><span id="7b48" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> Contact = lazy(() <em class="lm">=&gt;</em> import(“./pages/Contact”));</span><span id="35d6" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> Home = lazy(() <em class="lm">=&gt;</em> import(“./pages/Home”));</span><span id="8ee4" class="mb jr it lx b gy mg md l me mf"><em class="lm">const</em> Products = lazy(() <em class="lm">=&gt;</em> import(“./pages/Products”));</span></pre><p id="192b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">厉害！</p><p id="485b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">3.最后，用<em class="lm">_悬疑_ </em>组件包围动态导入的组件:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e05f" class="mb jr it lx b gy mc md l me mf">export default () <em class="lm">=&gt;</em> {</span><span id="b594" class="mb jr it lx b gy mg md l me mf"> return (</span><span id="81c8" class="mb jr it lx b gy mg md l me mf">  &lt;<em class="lm">Router</em> history={history}&gt;</span><span id="af02" class="mb jr it lx b gy mg md l me mf">    &lt;<em class="lm">Header</em> /&gt;</span><span id="4034" class="mb jr it lx b gy mg md l me mf">    &lt;<em class="lm">Suspense</em> fallback={&lt;div&gt;Loading page…&lt;/div&gt;}&gt;</span><span id="3ba3" class="mb jr it lx b gy mg md l me mf">     &lt;<em class="lm">Switch</em>&gt;</span><span id="d297" class="mb jr it lx b gy mg md l me mf">      &lt;<em class="lm">Route</em> exact path=”/” component={Home} /&gt;</span><span id="1b48" class="mb jr it lx b gy mg md l me mf">      &lt;<em class="lm">Route</em> path=”/about” component={About} /&gt;</span><span id="f59f" class="mb jr it lx b gy mg md l me mf">      &lt;<em class="lm">Route</em> path=”/products” component={Products} /&gt;</span><span id="58de" class="mb jr it lx b gy mg md l me mf">      &lt;<em class="lm">Route</em> path=”/blog” component={Blog} /&gt;</span><span id="a49e" class="mb jr it lx b gy mg md l me mf">      &lt;<em class="lm">Route</em> path=”/contact” component={Contact} /&gt;</span><span id="f205" class="mb jr it lx b gy mg md l me mf">    &lt;/<em class="lm">Switch</em>&gt;</span><span id="7ae6" class="mb jr it lx b gy mg md l me mf">  &lt;/<em class="lm">Suspense</em>&gt;</span><span id="1d11" class="mb jr it lx b gy mg md l me mf"> &lt;/<em class="lm">Router</em>&gt;</span><span id="fa35" class="mb jr it lx b gy mg md l me mf">);</span><span id="b620" class="mb jr it lx b gy mg md l me mf">};</span></pre><p id="f0bf" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">太棒了。您已经成功地在React应用程序中实现了代码拆分。您的用户对他们的应用程序的新速度感到满意。庆祝的时间到了！</p><p id="0a89" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我用的是<em class="lm"> _create-react-app_ </em>，用的是Webpack。如果我在实现代码拆分后运行“npm run build ”,我可以看到Webpack现在正在创建不同的包。</p><figure class="ls lt lu lv gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mh"><img src="../Images/bb9364e7fb949a424a8b8f488d201a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ivfc0ZYa-_K-RRF4EOVn6Q.png"/></div></div></figure><p id="0e1a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">更多的文件，但更小的文件。这就是重点。)</p><p id="de66" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">希望够清楚。如果没有，一如既往，不要犹豫，在评论中提问。</p><p id="6647" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">玩得开心，❤</p><p id="c6fc" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><em class="lm">_来源:_ </em></p><ul class=""><li id="5fb8" class="mp mq it kq b kr ln kv lo kz mr ld ms lh mt ll mu mv mw mx bi translated"><a class="ae my" href="https://reactjs.org/docs/code-splitting.html#code-splitting" rel="noopener ugc nofollow" target="_blank"> React关于代码拆分的文档</a></li></ul></div></div>    
</body>
</html>