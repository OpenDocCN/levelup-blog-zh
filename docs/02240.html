<html>
<head>
<title>Enhance Security with OpenID Connect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过OpenID Connect增强安全性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enhance-security-with-openid-connect-73138e8232ba?source=collection_archive---------12-----------------------#2020-02-28">https://levelup.gitconnected.com/enhance-security-with-openid-connect-73138e8232ba?source=collection_archive---------12-----------------------#2020-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a313" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解OpenID Connect、OAuth 2.0流程以及对集中式认证系统的需求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f4532f6b6408b7f160bc6e9dd06fdfba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmQSnISSxxNjFLXOX5N4lg.jpeg"/></div></div></figure><p id="81cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在当今时代，网络安全是一个主要问题。尤其是对于web或移动应用程序，安全性是关键因素。为了确保我们的应用程序不会受到未经授权的访问，我们可以实现身份验证和授权等概念。</p><p id="9627" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">身份验证是识别对系统拥有有效访问权限的用户或人员的过程。类似地，授权是验证通过身份验证的用户是否有权在系统中执行特定操作的过程。</p><p id="b315" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数现代应用程序架构如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/bf2c2532fe77012a3821c093639f108c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTnXhfjc21c5XcJKOBYQJQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">现代应用架构</figcaption></figure><p id="3d5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在大多数情况下，我们的应用程序可以通过以下一种或多种方式进行交互:</p><ul class=""><li id="608c" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated">浏览器与web应用程序通信</li><li id="c5bc" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">Web应用程序与web APIs通信</li><li id="ab28" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">移动/本地应用程序与web APIs通信</li><li id="7a04" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">服务器应用程序与web APIs通信</li><li id="7917" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">web API可以与web API通信</li></ul><p id="a4a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上述任何场景中，两端都应该使用某种身份验证机制来保护，以防止未经授权的访问。</p><h2 id="551f" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">本地认证系统</h2><p id="208a" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这是最简单的一种身份验证，可以作为它的一部分在任何web应用程序中实现。在适当的护理下，它可以很好地工作并提供良好的安全性。但是，它有自己的局限性。</p><p id="62c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这种类型的安全系统，存在如下问题:</p><ul class=""><li id="3856" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated">身份验证过程与系统紧密耦合。</li><li id="948e" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">考虑一下，如果某个应用程序有分布式服务，例如Web API或微服务，那么每个应用程序都必须将单独的身份验证流程设置集成到其中，指向Web应用程序所指向的同一个数据库。</li><li id="14bd" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">考虑一下，如果一个企业有一个以上的网络产品。在这种情况下，我们如何通过隔离身份验证系统来设置单点登录(SSO)？</li><li id="8582" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">考虑一下，如果我们需要通过像Google、LinkedIn、Twitter等社交媒体实现身份验证。我们如何在不到处复制代码的情况下做到这一点？</li></ul><p id="148a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要建立上述所有问题的解决方案，最好将身份验证过程委托给专门构建的独立服务。但是如何实施呢？它遵循什么标准？</p><p id="2270" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解决方案是<strong class="kt ir"> OpenID connect </strong>！</p><h2 id="ea96" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">OpenID连接提供程序</h2><p id="6f17" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">OpenID Connect是领先的标准，它基于OAuth 2.0提供的流，并与JSON Web Token (JWT)一起工作。它为单点登录(SSO)和身份提供了很好的支持。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/0d3c79de4c3a4b3016cd3012890c144e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_DjVbBwF2eVT8OElLHdIw.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">具有分离的集中式认证提供者的应用架构</figcaption></figure><h2 id="36c9" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">OpenID连接提供程序的优势</h2><p id="2605" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated"><strong class="kt ir">认证即服务:</strong>它可以作为一个集中式服务公开，用于各种Web、本地/移动应用程序和服务的认证。</p><p id="592d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">单点登录:</strong>为多种应用类型的单点登录提供了强大的支持。</p><p id="deba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">访问控制:</strong>为服务、Web应用程序和移动应用程序颁发访问令牌，其中包含用户可以访问的资源的相关信息。</p><p id="d6e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">社交媒体登录:</strong>为通过社交媒体(如谷歌、脸书、LinkedIn、Twitter等)扩展认证流程提供了良好的支持。</p><h2 id="b54e" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">术语</h2><p id="4330" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">在实现OpenID提供者时，我们需要注意一些术语，比如</p><p id="fd34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">OpenID Provider(OP):</strong>Provider是实现OpenID Connect和OAuth 2.0协议并遵循其标准的一类服务。它保护资源、验证用户身份、提供会话管理、单点登录以及颁发和验证令牌。</p><p id="7356" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">客户端:</strong>客户端是一种向提供商请求令牌的软件，例如Web应用、本地/移动应用、服务器应用或Web API。</p><p id="bb9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">资源:</strong>资源是您希望通过OpenID提供者保护的实体，如Web APIs或用户的身份数据。</p><p id="3d04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">身份令牌:</strong>身份令牌是认证过程的结果。它包含了用户最少的一个标识符。它包含sub、iat等索赔。它包含用户如何以及何时进行身份验证的信息。</p><p id="bd51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">访问令牌:</strong>访问令牌是用于访问API资源的签名令牌。它还包含关于用户有权访问的资源的信息，以及其他用户声明。</p><p id="0e9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">OpenID提供者基于OAuth 2.0提供了不同种类的流，称为<strong class="kt ir">授权类型</strong>。使用授权类型，我们可以定制适合需求的身份验证过程的方式。下面给出了OpenID Connect提供的一些授权类型</p><ol class=""><li id="9595" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm nf ly lz ma bi translated">客户端凭据</li><li id="e994" class="ls lt iq kt b ku mb kx mc la md le me li mf lm nf ly lz ma bi translated">含蓄的</li><li id="cced" class="ls lt iq kt b ku mb kx mc la md le me li mf lm nf ly lz ma bi translated">授权代码</li><li id="c8b4" class="ls lt iq kt b ku mb kx mc la md le me li mf lm nf ly lz ma bi translated">混合物</li><li id="ff51" class="ls lt iq kt b ku mb kx mc la md le me li mf lm nf ly lz ma bi translated">设备流程</li><li id="545f" class="ls lt iq kt b ku mb kx mc la md le me li mf lm nf ly lz ma bi translated">资源所有者密码</li><li id="dab8" class="ls lt iq kt b ku mb kx mc la md le me li mf lm nf ly lz ma bi translated">刷新令牌</li><li id="5364" class="ls lt iq kt b ku mb kx mc la md le me li mf lm nf ly lz ma bi translated">推广赠款</li></ol><p id="82a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将讨论上面一些常用的授权类型及其用法。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="7c42" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated"><strong class="ak">客户凭证</strong></h2><p id="dcf5" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这是最简单的流程，主要用于<strong class="kt ir">服务器到服务器认证</strong>，例如服务器应用程序或Web API到Web API。在这种方法中，客户端代表客户端而不是用户向OpenID提供者(OP)请求访问令牌。</p><p id="73ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">客户端(服务器应用程序/ API)需要向身份验证提供者提供客户端id和客户端机密，以证明其身份是访问资源(Web API)所必需的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5985aba105825f2d47f1980706f276b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*N6TcZGJiyQXNGLWT7krwoA.gif"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">客户端凭据流</figcaption></figure><h2 id="dc60" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated"><strong class="ak">含蓄</strong></h2><p id="59a5" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这种方法专门针对基于浏览器的应用程序(如JavaScript应用程序)进行了优化。使用隐式授权类型，用户使用他/她的凭证(如用户名、密码)通过JavaScript web app请求一些资源。</p><p id="5fa9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">凭证被提交给提供商(OP ),并要求用户授权访问用户的基本简档数据，例如电子邮件、简档等。</p><p id="14d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦用户授予访问权，OP就生成访问令牌并将其发送回浏览器。然后，这个令牌可以用来访问API资源。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/df12838032fec619f9361e3ce7da6c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*aa_Y7sH3mGCkNPfO0EhavQ.gif"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">隐式流</figcaption></figure><h2 id="a10c" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">授权代码</h2><p id="cb28" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这是最常用的身份验证方法，最初由OAuth 2.0指定。该流程旨在用于<strong class="kt ir">传统网络应用以及本地/移动应用</strong>。</p><p id="eb59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个流程中，用户向提供商(OP)提交他/她的凭证，例如用户名、密码，并授予访问权限以使用用户的基本数据，例如电子邮件、个人资料等。</p><p id="e100" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，提供者用短期授权码进行响应。<br/>使用反向信道请求再次与提供商(OP)共享该代码，以获得访问令牌。</p><p id="e1ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个流程提供了最佳的安全性，因为访问令牌不会暴露给浏览器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/47aef31dfff9b6cce42fdd6ab85663fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*7v3ZSat3WzMz9Moa3TeG9Q.gif"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">授权代码流</figcaption></figure><h2 id="97f3" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">混合物</h2><p id="1ff2" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这是一种很少使用的方法，主要由<strong class="kt ir">本地应用</strong>使用。这个流程基本上是<strong class="kt ir">隐式</strong>和<strong class="kt ir">授权码</strong>流程的组合。</p><p id="193c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用这个流程，我们可以分别请求<strong class="kt ir"> Id令牌</strong>和<strong class="kt ir">访问令牌</strong>。Id令牌被传输到浏览器，它被签名并包含关于用户和其他工件的信息。</p><p id="5b6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦收到Id令牌，就会发出另一个反向信道请求，以便检索可用于访问资源的<strong class="kt ir">访问令牌</strong>和<strong class="kt ir">刷新令牌</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f7a62aab739de083a445801533bfa6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*a4v7Sy76cnQDpO9l2SuaXw.gif"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">混合流</figcaption></figure><p id="130b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们了解了本地身份验证系统，它可能面临的问题，什么是OpenID connect，以及实现它的方法/流程。</p><p id="ebe0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的下一篇文章中，我们将实现一个简单的功能OpenID Provider (OP ),以支持上述所有流和示例客户端。所以，在那之前请继续关注并快乐编码！</p></div></div>    
</body>
</html>