# PHP 数组函数和 C 语法循环方法甚至很少有人知道。

> 原文：<https://levelup.gitconnected.com/php-array-functions-and-c-syntax-loop-methods-few-people-even-know-33c198782a55>

*注意，很抱歉，这篇文章会跳过一些语言。*

大家都知道`count`、`for`、`foreach`。它们是编程数组循环的主食。如果你从事 PHP 工作，你可能知道它们做什么以及如何使用它们…

但是`current`、`end`、`key`、`last`、`next`、`prev`、`reset`呢？

更不用说如何在大多数 C 语法语言中使用`if` / `do` / `while`来巧妙的循环了？

![](img/db5f2b10559591f5092a224095de1568.png)

向你致以疯狂的敬意，卢普。石头脸黑仔。

在过去的一年左右的时间里，我震惊地发现有多少 dev 从来没有听说过它们，更不用说理解它们的用途了。促成这篇文章的原因是，我刚刚在做一个匿名的“函数栈”，其他进程可以添加到这个函数栈中，我使用这个函数栈是因为“你不能在 foreach 中添加到数组中”这个问题；一个同事看到后说“那是什么鬼东西？！?"事实上，当他看到 do/while 时，他使用了更强烈的语言。

它们是遍历数组(在某些情况下是对象)的另一种方式，基于一个简单的事实:

# PHP 数组的…不是。

这听起来可能很奇怪，但是从汇编语言、C 或像我这样的 Pascal/ADA 开发人员的角度来看，这是真的。PHP 就像 JavaScript 一样伪造数组的外观。

如果 PHP 数组不是真正的数组，那它们是什么呢？答案:**尖锐的名单！**

容器对象*(我们不能正常访问)*有一个指向第一个和最后一个元素的指针，每个元素都有一个指向它的上一个和下一个兄弟元素的指针。在所有这些指针的情况下，null(或布尔 false)意味着没有指针。

不同于“真正的数组”方法，即每个值在内存中一个接一个地正交固定大小，它们可以遍布整个内存，因为每个元素都需要有一个动态大小。为什么需要这样做？因为 PHP 数组元素可以是任何东西；字符串、整数、浮点——甚至在同一个“数组”中。“真正的”数组依赖于统一大小的数据，这是 PHP 和 JavaScript 等动态类型语言所不具备的。

如果这听起来很熟悉，那么这与遍历 DOM 或使用二叉树非常相似。只是在这种情况下，它是一个一维指针驱动的列表。

这使得许多东西——比如 foreach——更加高效，但也使得一些东西——比如 count() —非常慢。知道如何在 JavaScript 中做到这一点:

```
for (var i = 0, iLen = str.length; i < iLen; i++) {
```

执行速度比:

```
for (var i = 0; i < str.length; i++) {
```

相同的根本原因。为了得到一个数组的长度，JavaScript 实际上必须遍历整个指针列表，计算元素数，因为它不是一个真正的数组。如果您在数组上执行“for”循环而不是“foreach ”,同样适用！

# 那么这些 PHP 数组函数是干什么的呢？

每个 PHP 数组都有一个内部指针用来遍历它的元素。Foreach 在内部利用了这一点。默认情况下，指针从第一个元素开始。

## 函数电流($array):混合；

返回内部指针指向的元素，如果数组为空，则返回布尔值 false。

## 函数 end($array):混合；

将内部指针设置到列表的末尾，然后返回最后一个值。

## 功能键($array):混合；

返回当前指针指向的数组元素的“key”/index。

## 函数 next($ array):mixed；

将指针递增一个元素，并返回该元素(如果有)。如果没有下一个元素(列表的结尾),则返回布尔值 false。

## function prev($ array):mixed；

将指针递减一个元素，返回该元素(如果有)。如果没有前一个元素(列表的开始)，则返回布尔值 false。

## 函数重置($array):混合；

将指针重置为数组的开头，如果有返回值，则返回该值，否则返回布尔值 false。

# 我们如何使用它们？

假设我们有这个简单的数组:

```
$test = [ 'a', 'b', 'c', 'd' ];
```

我们想遍历它们来显示键和值。用`foreach`表示:

```
foreach ($test as $key => $value) {
  echo $key, ' : ', $value, '<br>';
}
```

使用这些方法看起来会像这样:

```
if ($value = reset($test)) do {
  echo key($test), ' : ', $value, '<br>';
} while ($value = next($test));
```

是的，现在代码更多了，所以…

# 我们为什么要使用它们？！？

他们可以做`foreach`做不到的事情。就像倒着浏览列表一样！这些年来，我在论坛上看到很多帖子，有人在做一些浪费的 array_reverse 和其他各种愚蠢的把戏，这些本来可以简单地做到:

```
if ($value = end($test)) do {
  echo key($test), ' : ', $value, '<br>';
} while ($value = prev($test));
```

引导我写这篇文章的用例也是一个很好的例子。现在假设我们有相同的$test 数组，但是当我们遇到字母“c”作为值时，我们希望追加“e”作为新值。

这不起作用:

```
foreach ($test as $key => $value) {
  echo $key, ' : ', $value, '<br>';
  if ($value === "c") $test[] = 'e';
}
```

输出:

```
0 : a
1 : b
2 : c
3 : d
```

它不输出“e”或它的键。但是，它会将其附加到$test。这源于这样一个事实，即 foreach 为其循环抓取“last”的键进行比较。*(其实有点蠢)*。

然而这:

```
if ($value = reset($test)) do {
  echo key($test), ' : ', $value, '<br>';
  if ($value === "c") $test[] = 'e';
} while ($value = next($test));
```

输出:

```
0 : a
1 : b
2 : c
3 : d
4 : e
```

我们得到新的键/值对，因为`next`实际上寻找列表的真正结尾，因为实际的“最后一个”的下一个将是假的。

是的，你可以使用一个 for 循环，但是如果这是一个关联数组，那么这个选项可能就不存在了。

# 性能是一个问题吗？

你可能会认为这是可能的，但是因为我们实际上使用了底层的基于指针的列表，我们实际上和`foreach`一样快，在某些情况下更快。数据的类型会对此产生影响。从 PHP 5 开始，我就没有对它进行过基准测试，但当时它还没有不同到足以产生任何影响。*将来当我有更多时间的时候，我会坐在板凳上把结果加到这里。*

我不担心，因为你只会在`foreach`让你失望的情况下使用这些技术。如果你坚持“正确的工作用正确的工具”，那就不再是哪种方法更快的问题，而是哪种方法能正确地完成工作。

*另一个我认为大多数现代开发者都搞砸的地方。他们学习一种做事的方法，然后试着把它用在所有事情上！就像谚语中的拿着锤子的木匠，突然间所有的东西看起来都像钉子。你可以用锤子敲螺丝，并不意味着这是个好主意……*

# Do/While？实际上

我知道。有漫画拿它开玩笑。有些“专家”说永远不要使用它，因为它“不安全”。许多语言的 Linters 会抛出一个警告，甚至是“错误”。

它们比毕夫·坦南的 48 年福特超级豪华车还肥。

有很多情况下，初始测试条件与迭代“下一个”不匹配。

例如，您可能见过这样的代码:

```
if ($stmt->rowCount() > 0) {
  while ($row = $stmt->fetch()) {
    // do something with $row here
  }
} else echo 'No records found.<br>';
```

许多 SQL 引擎在选择时不返回行计数。PHP 文档中甚至提到了这一点:

> 对于大多数数据库，PDOStatement::rowCount()不会返回受 SELECT 语句影响的行数。
> [https://www . PHP . net/manual/en/pdostatement . rowcount . PHP # example-1052](https://www.php.net/manual/en/pdostatement.rowcount.php#example-1052)

所以有一种方法可以解决这个问题？

```
if ($row = $stmt->fetch()) {
  do {
    // do something with $row here
  } while($row = $stmt->fetch());
} else echo 'No records found.<br>';
```

我认为“do/while”不仅是不可避免的，而且人们也没有经常使用它。

正如我最近多次说过的，似乎现在整个编程运动完全基于这样一个想法，即"*我太蠢了，不能使用它，所以其他人也不应该被允许！*”。用那种噪音和心态去燃烧。 *再看 90%以上的彻头彻尾的无知者胡说八道最令“棉短绒”抱怨。*

# 其他语言呢？

对于 do/while 也成立。用 JavaScript 进行一次简单的 DOM 遍历。假设你有一个变量“ul ”,它指向一个你想转换成 markdown 的列表。当然，您可以从“ul”中“getElementsByTagName”或者执行“querySelectorAll”，但是这些方法可能会很慢并且浪费内存。你可以简单地在大教堂里散步。

```
var markdown = '';
if (li = ul.firstElementChild) do {
  markdown += "* " + li.textContent + "\r\n";
} while (li = li.nextElementSibling);
```

这将比任何 nodeList 或复制的数组方法和 for 循环执行快许多倍，因为我们“省去了中间人”,不需要任何花哨的“聚集”调用来创建列表。直接去 DOM，沿着它的指针走。

事实上，我像这样直接进入了 DOM，这就是为什么当大多数人谈论他们如何“使用 DOM”时，在我的书中他们并没有。GetElementById 和 QuerySelectorAll 不是“DOM 操纵”。InnerHTML 肯定不是。你需要 DOM 操作，即 removeChild、appendChild、insertBefore、createElement、createTextNode、firstChild、lastChild、nextSibling、previousSibling 等。

在 JS 中，很多时候人们会使用数组、nodeList 或其他 iterables 来处理他们本可以直接操作的东西，这种方式更简洁、执行速度更快，而且只占用很少的内存。

事实上，你们中的大多数抱怨 Chrome 标签页像一群变态狂一样消耗内存，这是他们为了避开大多数愚蠢的 JavaScript 开发人员糟糕的编码习惯而进行的优化！

*如果你说不出好话，就用意第绪语说。*

问题是，在传统的 Pascal 中没有“while”这样的东西，这是该语言的新成员(如果 30 多年可以被称为最近的话)。最初，当我学习它时，唯一的条件重复结构是“repeat until()”，它与“do {} while()”直接平行。当我第一次学习机器语言编程时，Pascal 是我的第一门高级语言，我认为无条件的首次运行和条件循环是正常的。对于我和我的编程背景来说，就是“while () {}”这就是不自然的结构！

> *Kernigan 可以去吸它。c 不是我最喜欢的编程语言。*

# 等等！你也在使用赋值求值！

这就是 PHP 程序员嘲笑 JavaScript 人有多愚蠢的地方……就像 C/C++程序员嘲笑 JavaScript 对非常简单的“with”语句的“Use Strict”处理方式一样。

那些“只”和 PHP 打交道的人可能想知道我在说什么，但是很多自称是 JavaScript“专家”的无知之人“如果你做了类似下面的事情，就会完全失去理智:

```
if (li = ul.firstElementChild) {
```

他们中的一半会认为你的意思是==，然后会大喊大叫，大发脾气，说只使用===，而实际上单=并不正确；这对它的运作至关重要。自然，PHP 开发人员应该不会发现这有什么问题，因为我们:

```
while ($row = $stmt->fetch()) {
```

所有该死的时间。在任何使用条件的地方，赋值的这种类型的求值都是可能的。

测试作业的结果没有错。=，==，和===都有不同的含义，都有存在的理由，同样，仅仅因为有些人太愚蠢而不能正确使用它们，也没有理由因为你自己的无知和愚蠢而到处嚷嚷着让我们停止以“特定的方式”使用它们。

总的来说，有很多学究式的废话被外面那些..嗯……坦白说？我不相信他们能从尿湿了的底部有个洞的纸袋里爬出来。

如果你编写汇编程序。“for”循环是违反直觉的。如果你用这种心态，一个好的“循环 30 次”应该是:

```
$count = 30;
do {
  // something 
} while (--$count);
```

因为`++`和`--`是赋值，所以您也可以对它们的值进行操作。记住，zero 是松散的 false……这就相当于 PHP 在汇编中如何实现循环。

例如，最有效的 x86 循环是:

```
MOV ECX, 30
:loop
; do something
LOOP :loop
```

其中 ECX 是“计数器”寄存器，:loop 是标签，并且 LOOP 命令将 ECX 递减 1，如果递减量没有设置零标志，则跳转到标签。

我认为 Ruby 在这一点上做对了，考虑到这种语言仍然如此缓慢和低效，这很奇怪。它的许多结构都对应于汇编，这使得它很容易快速运行。

JavaScript 甚至可以用它来实现一个非常快的 NodeList 循环。由于类似数组的 iterable NodeList 的元素是节点对象—通常是 Element 或 TextNode —我们可以使用这些知识来做类似这样的事情:

```
for (
  var
    anchors = document.getElementsByTagName('a'),
    i = 0,
    a;
  a = anchors[i];
  i++
) {
```

这看起来可能很奇怪，但实际上这是遍历 NodeList 或类似的 iterable 的最快方法，因为你知道没有一个值会丢失 false！绕着 dumbass Array.forEach 运行绝对一圈，其开销会导致回调垃圾。它甚至比 for/of 还快。*这真的不应该，它说了很多关于脚本引擎中的实现有多糟糕。*

# 结论

![](img/f6058fa9c1a324d9fabb08c4371b60bc.png)

随机问题:先拉拉链再系紧，还是先系紧再拉拉链？

穿裤子的方法不止一种。同样，有各种不同的循环方法和方式来处理循环和数组；甚至假装 JS 和 PHP 中的数组。

学习它们。

很容易就确定了一种做事方式，然后试图全盘应用；把那个方木栓塞进圆孔里。这种心态只会阻碍你作为开发人员的发展。同样，你们中有太多的人盲目地鹦鹉学舌，从那些一开始就没有充分理解事物并给出建议的人那里得到不好的建议。从“不要单身=在某种情况下”的无知到“永远不要做/当”的古怪工作。

把这些很少使用的方法想象成你工具箱里的更多工具，以确保你尽你所能做好工作。

这些技术的出现不是出于某种恶意，当然也不是出于无知。不要让那些可能以卖汉堡为生的人假装是这个领域的权威，试图告诉你相反的事情。