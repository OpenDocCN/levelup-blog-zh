<html>
<head>
<title>Unit Test SQL in Golang, Without Mocking, Using TestContainers (Go, Postgres, Docker, TestContainers)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TestContainers (Go，Postgres，Docker，TestContainers)在Golang中对SQL进行单元测试，没有模仿</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-test-sql-in-golang-without-mocking-using-testcontainers-go-postgres-docker-4f61574b1989?source=collection_archive---------2-----------------------#2020-12-31">https://levelup.gitconnected.com/unit-test-sql-in-golang-without-mocking-using-testcontainers-go-postgres-docker-4f61574b1989?source=collection_archive---------2-----------------------#2020-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1270b231cbe03e34313ba808eaa07344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ca6rifzy39WZHedRVAd3lg.png"/></div></div></figure><p id="8a78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我写了另一篇关于同一主题的文章，利用一个纯Docker解决方案来测试数据库代码，而没有嘲笑。这是一个很酷的解决方案，而且效果很好，但是有点笨拙。它需要特殊的脚本、特定的文件夹结构，有时很难理解。尽管如此，它给了我想要的东西，没有嘲笑我的数据库测试！你可以在这里阅读那篇文章:<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/unit-test-sql-in-golang-without-mocking-using-docker-go-postgres-docker-50e99b9d38a7">用Golang单元测试SQL，不带嘲讽，使用Docker (Go，Postgres，Docker) </a></p><p id="c867" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有人在那篇文章上发帖，建议我研究一下<a class="ae kz" href="https://github.com/testcontainers" rel="noopener ugc nofollow" target="_blank"> TestContainers </a>来实现同样的目标。从他们的网站:</p><blockquote class="la lb lc"><p id="8b8e" class="kb kc ld kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated">Testcontainers是一个库，它提供了一个友好的API来运行Docker容器。它被设计用来创建在你的自动测试中使用的运行时环境。</p></blockquote><p id="a1f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗯，这听起来很像我在上一篇文章中试图做的事情。所以在这篇文章中，我们将采用相同的代码/回购，并用TestContainers重新工作，看看我们是否可以测试我们所有的数据库代码，没有模仿！我们走吧！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="4429" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">为什么要去掉仿制品，它们很棒？！</h1><p id="12f9" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">首先，我想说，我并不主张完全摆脱模仿。它们绝对在测试中占有一席之地，并且在很多事情上派上用场。对我来说，对于你无法控制的资源，模仿是至关重要的。例如，以Twilio这样的服务为例。如果您需要调用Twilio并处理来自它们的API的响应，这是一个很好的例子，说明了模仿的重要性。您无法控制它们的API，您只是简单地发出一个调用并处理响应。通常，如果您在CI/CD管道中运行，您可能无法进行这些调用，也可能不只是想进行这些调用。这里模仿是完美的，因为您并不真正关心对API的调用，只是为了确保您的代码能够处理响应。</p><p id="46d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">说到在Golang代码中嘲笑数据库交互，老实说，在我看来这是一次悲惨的经历。通常，您最终会为这些代码编写大量的接口，然后可以在您的测试中模拟出来。您的测试以大量样板代码和跨多个文件重复的SQL查询而告终。有一些软件包可以帮助解决这个问题，甚至消除了对接口的需求，但是你仍然要写很多样板代码，现在需要训练人们如何使用另一个软件包。以下是一些例子:</p><ul class=""><li id="b42c" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated"><a class="ae kz" href="https://medium.com/easyread/unit-test-sql-in-golang-5af19075e68e" rel="noopener">https://medium . com/easy read/unit-test-SQL-in-golang-5af 19075 e68e</a></li><li id="9bdb" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">https://dev.to/pieohpah/mocking-database-in-go-55bo<a class="ae kz" href="https://dev.to/pieohpah/mocking-database-in-go-55bo" rel="noopener ugc nofollow" target="_blank"/></li><li id="9b16" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">【https://github.com/DATA-DOG/go-sqlmock T4】</li></ul><p id="f324" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想要的是在真实的数据库上运行我的测试，完全消除对模拟的需求。目标是提供以下内容:</p><ul class=""><li id="c59e" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">编写没有接口和嘲讽的常规测试</li><li id="0c20" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">针对实际数据库进行测试，该数据库应用了最新的模式并植入了测试数据</li><li id="e3c0" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">不仅要测试我的数据库代码，还要测试任何公开该数据的API处理程序</li><li id="7b44" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">能够在真实的CI/CD管道中使用该流程</li></ul></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="cbb7" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">设置</h1><p id="93bb" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我创建了一个非常简单的<a class="ae kz" href="https://github.com/atkinsonbg/go-gmux-db-testcontainers" rel="noopener ugc nofollow" target="_blank"> Go API </a>，它可以处理包含时区信息的数据库。这里没有什么过于复杂的，只有两个get和一个POST用于插入。数据库同样简单，一个存储时区信息的表。让我们先来看看数据库的表模式。我有一个非常简单的<code class="fe nf ng nh ni b">./scripts/init.sql</code>脚本，它创建了一个表并用一些数据作为种子:</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="b37b" class="nr lp it ni b gy ns nt l nu nv">-- SCHEMA<br/>CREATE TABLE timezones<br/>(<br/>id serial PRIMARY KEY,<br/>created timestamptz DEFAULT now() NOT NULL,<br/>modified timestamptz DEFAULT now() NOT NULL,<br/>name text NOT NULL,<br/>timeoffset smallint NOT NULL,<br/>identifier text NOT NULL<br/>);<br/>-- SEED<br/>INSERT INTO timezones<br/>(id, name, timeoffset, identifier)<br/>VALUES<br/>(1, 'eastern', '-5', 'est');<br/>INSERT INTO timezones<br/>(id, name, timeoffset, identifier)<br/>VALUES<br/>(2, 'central', '-6', 'cst');<br/>INSERT INTO timezones<br/>(id, name, timeoffset, identifier)<br/>VALUES<br/>(3, 'mountain', '-7', 'mst');<br/>INSERT INTO timezones<br/>(id, name, timeoffset, identifier)<br/>VALUES<br/>(4, 'pacific', '-8', 'pst');<br/>INSERT INTO timezones<br/>(id, name, timeoffset, identifier)<br/>VALUES<br/>(5, 'alaska', '-9', 'ast');<br/>ALTER SEQUENCE timezones_id_seq RESTART WITH 6;</span></pre><p id="c4cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的Go API中，我在我的<code class="fe nf ng nh ni b">main.go</code>文件中定义了四条路线:</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="91ea" class="nr lp it ni b gy ns nt l nu nv">func main() { <br/>  database.InitDB()   r := mux.NewRouter()            </span><span id="0ebe" class="nr lp it ni b gy nw nt l nu nv">  r.HandleFunc("/healthcheck", handlers.HealthHandler).Methods("GET")   </span><span id="f20e" class="nr lp it ni b gy nw nt l nu nv">  r.HandleFunc("/timezones", handlers.ListTimezonesHandler).Methods("GET")   </span><span id="3bbc" class="nr lp it ni b gy nw nt l nu nv">  r.HandleFunc("/timezones/{identifier}", handlers.GetTimezoneHandler).Methods("GET")   </span><span id="55b6" class="nr lp it ni b gy nw nt l nu nv">  r.HandleFunc("/timezones", handlers.InsertTimezoneHandler).Methods("POST")   </span><span id="6a30" class="nr lp it ni b gy nw nt l nu nv">  log.Fatal(http.ListenAndServe(":80", r))<br/>}</span></pre><p id="d146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们快速分析一下这些路由，以了解数据库交互的水平设置:</p><ul class=""><li id="fcf4" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">/healthcheck:简单的健康检查，以确保我的容器正在运行</li><li id="fac7" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">/timezones: GET返回数据库中的所有时区</li><li id="53db" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">/timezones/{identifier}: GET根据标识符从数据库中返回单个时区。在这种情况下:东部时间、中部时间、太平洋标准时间等。</li><li id="16bd" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">/timezones: POST以插入新时区</li></ul><p id="ef1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将我的处理程序和数据库代码分开，以便于测试，这就是你对这样一个简单实现的期望。</p><p id="0f6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">处理程序(时区获取)</strong></p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="e9f5" class="nr lp it ni b gy ns nt l nu nv">// ListTimezonesHandler lists all the timezones in the databasefunc ListTimezonesHandler(w http.ResponseWriter, r *http.Request) <br/>{ <br/>  timezones, err := database.GetAllTimezones() <br/>  if err != nil {  <br/>      w.WriteHeader(http.StatusInternalServerError)  <br/>      return <br/>  }  <br/>  results, _ := json.Marshal(timezones)  <br/>  w.WriteHeader(http.StatusOK) <br/>  w.Write(results)<br/>}</span></pre><p id="3ca0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">数据库(时区获取)</strong></p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="0ea2" class="nr lp it ni b gy ns nt l nu nv">// GetAllTimezones returns all timezones from the DB<br/>func GetAllTimezones() ([]Timezone, error) {<br/>  rows, err := db.Query("SELECT * FROM timezones")<br/>  if err != nil {<br/>    log.Fatal(err)<br/>    return nil, err<br/>  }<br/>  var timezones []Timezone<br/>  defer rows.Close()<br/>  for rows.Next() {<br/>    var timezone Timezone<br/>    err := rows.Scan(&amp;timezone.ID, &amp;timezone.Created,        &amp;timezone.Modified, &amp;timezone.Name, &amp;timezone.Timeoffset, &amp;timezone.Identifier)<br/>    if err != nil {<br/>      log.Print(err)<br/>    }<br/>    timezones = append(timezones, timezone)<br/>  }<br/>  return timezones, nil<br/>}</span></pre><p id="28ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本地运行时，我通过Docker Compose将所有这些连接起来，这样我就可以将我的API和本地Postgres容器一起运行，并通过Postman调用轻松测试我的代码:</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="29bd" class="nr lp it ni b gy ns nt l nu nv">version: "3.7"<br/>services:<br/>  api:<br/>    container_name: go-mux-api<br/>    image: <br/>      github.com/atkinsonbg/go-gmux-db-testcontainers/api:latest<br/>    environment:<br/>      DBHOST: go-mux-db<br/>      DBNAME: go-mux-db<br/>      DBUSER: postgres<br/>    ports:<br/>      - 80:80<br/>  database:<br/>    container_name: go-mux-db<br/>    image: postgres:11.6-alpine<br/>    environment:<br/>      POSTGRES_DB: go-mux-db<br/>      volumes:<br/>        - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql<br/>      ports:<br/>        - 5432:5432</span></pre><p id="5ae6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Docker Compose在这种情况下非常有用，因为我可以快速旋转一个配置为满足我的需求的DB，将其拆下，然后再旋转回来。如果我需要更复杂的测试，我可以分别启动数据库和API，并使用<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/debugging-go-inside-docker-using-visual-studio-code-and-remote-containers-5c3724fe87b9">远程容器</a>进行测试。Docker在这里是一个救星，因为它对于我的测试用例非常灵活。更重要的是，当我们用真实的数据库进行测试时。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="5052" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试</h1><p id="4232" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在深入讨论之前，我应该指出这段代码中使用的以下环境变量:</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="2a74" class="nr lp it ni b gy ns nt l nu nv">DBHOST=localhost</span><span id="a7de" class="nr lp it ni b gy nw nt l nu nv">DBNAME=postgresTC</span><span id="127d" class="nr lp it ni b gy nw nt l nu nv">DBUSER=postgres</span><span id="0157" class="nr lp it ni b gy nw nt l nu nv">DBPORT=5432</span></pre><p id="a885" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的repo中，这些是通过Makefile的“test”命令注入的，并在整个代码中使用。您将在下面的测试代码中看到它们。</p><p id="39af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我之前所说的，我不想嘲笑我的测试。我想针对我的数据库代码和处理程序编写普通的Golang测试。TestContainers包允许我非常容易地做到这一点。基本上，它允许您启动一个数据库容器，在我们的场景中是Postgres，供您在测试中使用。完成后，您可以将其拆除，这样在测试期间您就有了一个临时数据库！</p><p id="af6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面的代码展示了它的样子。我们将首先查看这两个测试文件，然后分析它们内部的情况:</p><p id="3054" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">处理程序测试(时区获取)</strong></p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="1e91" class="nr lp it ni b gy ns nt l nu nv">package handlers</span><span id="6ce4" class="nr lp it ni b gy nw nt l nu nv">import (<br/> "bytes"<br/> "context"<br/> "encoding/json"<br/> "fmt"<br/> "net/http"<br/> "net/http/httptest"<br/> "os"<br/> "strings"<br/> "testing"</span><span id="13d9" class="nr lp it ni b gy nw nt l nu nv"> db "github.com/atkinsonbg/go-gmux-db-testcontainers/database"<br/> "github.com/gorilla/mux"<br/> "github.com/testcontainers/testcontainers-go"<br/> "github.com/testcontainers/testcontainers-go/wait"<br/>)</span><span id="3373" class="nr lp it ni b gy nw nt l nu nv">func TestMain(m *testing.M) {<br/> // Work out the path to the 'scripts' directory and set mount strings<br/> packageName := "handlers"<br/> workingDir, _ := os.Getwd()<br/> rootDir := strings.Replace(workingDir, packageName, "", 1)<br/> mountFrom := fmt.Sprintf("%s/scripts/init.sql", rootDir)<br/> mountTo := "/docker-entrypoint-initdb.d/init.sql"</span><span id="a961" class="nr lp it ni b gy nw nt l nu nv">// Create the Postgres TestContainer<br/> ctx := context.Background()<br/> req := testcontainers.ContainerRequest{<br/>  Image:        "postgres:11.6-alpine",<br/>  ExposedPorts: []string{"5432/tcp"},<br/>  BindMounts:   map[string]string{mountFrom: mountTo},<br/>  Env: map[string]string{<br/>   "POSTGRES_DB": os.Getenv("DBNAME"),<br/>  },<br/>  WaitingFor: wait.ForLog("database system is ready to accept connections"),<br/> }</span><span id="0928" class="nr lp it ni b gy nw nt l nu nv">postgresC, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{<br/>  ContainerRequest: req,<br/>  Started:          true,<br/> })<br/> if err != nil {<br/>  // Panic and fail since there isn't much we can do if the container doesn't start<br/>  panic(err)<br/> }</span><span id="91e0" class="nr lp it ni b gy nw nt l nu nv">defer postgresC.Terminate(ctx)</span><span id="0a1c" class="nr lp it ni b gy nw nt l nu nv">// Get the port mapped to 5432 and set as ENV<br/> p, _ := postgresC.MappedPort(ctx, "5432")<br/> os.Setenv("DBPORT", p.Port())</span><span id="0107" class="nr lp it ni b gy nw nt l nu nv">db.InitDB()</span><span id="7449" class="nr lp it ni b gy nw nt l nu nv">exitVal := m.Run()<br/> os.Exit(exitVal)<br/>}</span><span id="6261" class="nr lp it ni b gy nw nt l nu nv">func TestListTimezonesHandler(t *testing.T) {<br/> req, err := http.NewRequest("GET", "/timezones", nil)<br/> if err != nil {<br/>  t.Fatal(err)<br/> }</span><span id="1268" class="nr lp it ni b gy nw nt l nu nv">rr := httptest.NewRecorder()<br/> handler := http.HandlerFunc(ListTimezonesHandler)</span><span id="fe72" class="nr lp it ni b gy nw nt l nu nv">handler.ServeHTTP(rr, req)</span><span id="f4dd" class="nr lp it ni b gy nw nt l nu nv">if rr.Code != http.StatusOK {<br/>  t.Errorf("handler returned wrong status code: got %v want %v",<br/>   rr.Code, http.StatusOK)<br/> }</span><span id="c74c" class="nr lp it ni b gy nw nt l nu nv">var timezones []db.Timezone<br/> err = json.NewDecoder(rr.Body).Decode(&amp;timezones)<br/> if err != nil {<br/>  t.Error(err.Error())<br/>  t.Error("Error retreiving list of timezones.")<br/> }</span><span id="dd30" class="nr lp it ni b gy nw nt l nu nv">if len(timezones) == 0 {<br/>  t.Error("Error retreiving list of timezones.")<br/> }<br/>}</span><span id="9eb3" class="nr lp it ni b gy nw nt l nu nv">func TestGetTimezoneHandler(t *testing.T) {<br/> req, err := http.NewRequest("GET", "/timezones/est", nil)<br/> if err != nil {<br/>  t.Fatal(err)<br/> }</span><span id="7686" class="nr lp it ni b gy nw nt l nu nv">rr := httptest.NewRecorder()<br/> router := mux.NewRouter()<br/> router.HandleFunc("/timezones/{identifier}", GetTimezoneHandler)<br/> router.ServeHTTP(rr, req)</span><span id="6743" class="nr lp it ni b gy nw nt l nu nv">if rr.Code != http.StatusOK {<br/>  t.Errorf("handler returned wrong status code: got %v want %v",<br/>   rr.Code, http.StatusOK)<br/> }</span><span id="84e1" class="nr lp it ni b gy nw nt l nu nv">var timezone db.Timezone<br/> err = json.NewDecoder(rr.Body).Decode(&amp;timezone)<br/> if err != nil {<br/>  t.Error(err.Error())<br/>  t.Error("Error retreiving specific of timezone.")<br/> }</span><span id="8e51" class="nr lp it ni b gy nw nt l nu nv">if timezone.Name != "eastern" {<br/>  t.Error("Error retreiving specific of timezone.")<br/> }<br/>}</span><span id="b056" class="nr lp it ni b gy nw nt l nu nv">func TestInsertTimezoneHandler(t *testing.T) {<br/> var data = []byte(`<br/> {<br/>  "name": "xyz",<br/>  "timeoffset": -10,<br/>  "identifier": "xyz"<br/> }`)</span><span id="07a0" class="nr lp it ni b gy nw nt l nu nv">b := bytes.NewBuffer(data)</span><span id="5f0e" class="nr lp it ni b gy nw nt l nu nv">req, err := http.NewRequest("POST", "/timezones", b)<br/> if err != nil {<br/>  t.Fatal(err)<br/> }</span><span id="64ba" class="nr lp it ni b gy nw nt l nu nv">req.Header.Add("Content-Type", "application/json")</span><span id="6368" class="nr lp it ni b gy nw nt l nu nv">rr := httptest.NewRecorder()<br/> handler := http.HandlerFunc(InsertTimezoneHandler)</span><span id="a062" class="nr lp it ni b gy nw nt l nu nv">handler.ServeHTTP(rr, req)</span><span id="0d5f" class="nr lp it ni b gy nw nt l nu nv">if rr.Code != http.StatusOK {<br/>  t.Errorf("handler returned wrong status code: got %v want %v",<br/>   rr.Code, http.StatusOK)<br/> }<br/>}</span></pre><p id="072b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这段代码利用了Go中的<code class="fe nf ng nh ni b"><a class="ae kz" href="https://golang.org/pkg/net/http/httptest/" rel="noopener ugc nofollow" target="_blank">net/http/httptest</a></code>包，它允许我从测试中轻松地调用我的API端点。</p><p id="1272" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">数据库测试(时区获取)</strong></p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="cd62" class="nr lp it ni b gy ns nt l nu nv">package database</span><span id="2cbc" class="nr lp it ni b gy nw nt l nu nv">import (<br/> "context"<br/> "fmt"<br/> "os"<br/> "strings"<br/> "testing"</span><span id="e69e" class="nr lp it ni b gy nw nt l nu nv">"github.com/testcontainers/testcontainers-go"<br/> "github.com/testcontainers/testcontainers-go/wait"<br/>)</span><span id="bf3d" class="nr lp it ni b gy nw nt l nu nv">func TestMain(m *testing.M) {<br/> // Work out the path to the 'scripts' directory and set mount strings<br/> packageName := "database"<br/> workingDir, _ := os.Getwd()<br/> rootDir := strings.Replace(workingDir, packageName, "", 1)<br/> mountFrom := fmt.Sprintf("%s/scripts/init.sql", rootDir)<br/> mountTo := "/docker-entrypoint-initdb.d/init.sql"</span><span id="fde7" class="nr lp it ni b gy nw nt l nu nv">// Create the Postgres TestContainer<br/> ctx := context.Background()<br/> req := testcontainers.ContainerRequest{<br/>  Image:        "postgres:11.6-alpine",<br/>  ExposedPorts: []string{"5432/tcp"},<br/>  BindMounts:   map[string]string{mountFrom: mountTo},<br/>  Env: map[string]string{<br/>   "POSTGRES_DB": os.Getenv("DBNAME"),<br/>  },<br/>  WaitingFor: wait.ForLog("database system is ready to accept connections"),<br/> }</span><span id="7f71" class="nr lp it ni b gy nw nt l nu nv">postgresC, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{<br/>  ContainerRequest: req,<br/>  Started:          true,<br/> })<br/> if err != nil {<br/>  // Panic and fail since there isn't much we can do if the container doesn't start<br/>  panic(err)<br/> }</span><span id="996a" class="nr lp it ni b gy nw nt l nu nv">defer postgresC.Terminate(ctx)</span><span id="3a73" class="nr lp it ni b gy nw nt l nu nv">// Get the port mapped to 5432 and set as ENV<br/> p, _ := postgresC.MappedPort(ctx, "5432")<br/> os.Setenv("DBPORT", p.Port())</span><span id="9d41" class="nr lp it ni b gy nw nt l nu nv">InitDB()</span><span id="158b" class="nr lp it ni b gy nw nt l nu nv">exitVal := m.Run()<br/> os.Exit(exitVal)<br/>}</span><span id="aff5" class="nr lp it ni b gy nw nt l nu nv">func TestGetAllTimezones(t *testing.T) {<br/> tzones, err := GetAllTimezones()<br/> if err != nil {<br/>  t.Error("Get All Timezones failed.")<br/> }</span><span id="e973" class="nr lp it ni b gy nw nt l nu nv">if len(tzones) == 0 {<br/>  t.Error("Timezones did not return any values.")<br/> }<br/>}</span><span id="6cb4" class="nr lp it ni b gy nw nt l nu nv">func TestGetTimezone(t *testing.T) {<br/> tzone, err := GetTimezone("est")<br/> if err != nil {<br/>  t.Error("Get a Timezone failed.")<br/> }</span><span id="60e2" class="nr lp it ni b gy nw nt l nu nv">if tzone.Name != "eastern" {<br/>  t.Error("Timezone did not return correct values.")<br/> }<br/>}</span><span id="e0d4" class="nr lp it ni b gy nw nt l nu nv">func TestInsertTimezone(t *testing.T) {<br/> tzone := Timezone{}<br/> tzone.Name = "Test"<br/> tzone.Timeoffset = 10<br/> tzone.Identifier = "tst"</span><span id="9dea" class="nr lp it ni b gy nw nt l nu nv">rowid, err := InsertTimezone(tzone)<br/> if err != nil {<br/>  t.Error("Insert a Timezone failed.")<br/> }</span><span id="3a62" class="nr lp it ni b gy nw nt l nu nv">if rowid != 6 {<br/>  t.Error("Insert timezone failed.")<br/> }<br/>}</span></pre><p id="6dfb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一点上，你可以看到，我在这里没有使用任何模拟。这是我所能得到的最普通的测试代码，非常棒。它简明扼要。任何曾经编写过Go代码的人都可以阅读这段代码并理解它在做什么。没什么特别的，只是做些测试。然而，<code class="fe nf ng nh ni b">TestMain</code>函数有一些魔力，所以让我们来分解一下:</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="1c47" class="nr lp it ni b gy ns nt l nu nv">// Work out the path to the 'scripts' directory and set mount strings<br/> packageName := "database"<br/> workingDir, _ := os.Getwd()<br/> rootDir := strings.Replace(workingDir, packageName, "", 1)<br/> mountFrom := fmt.Sprintf("%s/scripts/init.sql", rootDir)<br/> mountTo := "/docker-entrypoint-initdb.d/init.sql"</span></pre><p id="99ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我需要做的第一件事是设计出我的挂载路径。如果你还记得在这篇文章的前面，我们有一个<code class="fe nf ng nh ni b">init.sql</code>文件，它创建了数据库模式并用数据播种它。我们需要将它挂载到Postgres映像中的<code class="fe nf ng nh ni b">docker-entrypoint-initdb.d</code>文件夹中。这是在一个不同的文件夹中，我们将进行绑定挂载，需要一个绝对路径。所以我们得到当前的工作目录路径，然后对它做<code class="fe nf ng nh ni b">strings.Replace</code>，取出当前的目录名。最后，我们创建两个新的字符串来保存挂载路径。</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="0e55" class="nr lp it ni b gy ns nt l nu nv">// Create the Postgres TestContainer<br/> ctx := context.Background()<br/> req := testcontainers.ContainerRequest{<br/>  Image:        "postgres:11.6-alpine",<br/>  ExposedPorts: []string{"5432/tcp"},<br/>  BindMounts:   map[string]string{mountFrom: mountTo},<br/>  Env: map[string]string{<br/>   "POSTGRES_DB": os.Getenv("DBNAME"),<br/>  },<br/>  WaitingFor: wait.ForLog("database system is ready to accept connections"),<br/> }</span><span id="dc99" class="nr lp it ni b gy nw nt l nu nv">postgresC, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{<br/>  ContainerRequest: req,<br/>  Started:          true,<br/> })<br/> if err != nil {<br/>  // Panic and fail since there isn't much we can do if the container doesn't start<br/>  panic(err)<br/> }</span><span id="37f7" class="nr lp it ni b gy nw nt l nu nv">defer postgresC.Terminate(ctx)</span></pre><p id="c636" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们设计好了挂载路径，我们就创建一个测试容器。这段代码完全是他们网站上的模板，但是你可以看到我们正在做以下事情:</p><ul class=""><li id="f8b3" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">基于<code class="fe nf ng nh ni b">postgres:11.6-alpine</code>图像创建新的容器</li><li id="9537" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">暴露端口5432。这将把端口5432映射到容器上动态生成的端口。这将在下一节中出现。这样做是为了在工作时最大限度地减少端口冲突。</li><li id="e6ef" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">用我们的路径添加绑定挂载。(注意，对我来说这是一个陷阱。我最初试图在这里放入字符串，但是因为我需要当前的工作目录，<code class="fe nf ng nh ni b">$(pwd)</code>在这里不适合我。更容易得到这些并将它们放入字符串中)</li><li id="bf9a" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">为Postgres数据库名称设置一个环境变量</li><li id="18e5" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">设置日志消息的“等待”命令，说明数据库已准备就绪。TestContainers有很多“等待”策略，你可以利用，这非常好！(公平地说，在我的代码中我可能不需要这样做，因为我利用了一个<a class="ae kz" href="https://github.com/cenkalti/backoff" rel="noopener ugc nofollow" target="_blank">指数回退</a>来测试数据库是否准备好了，然后再做其他事情。)</li></ul><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="8705" class="nr lp it ni b gy ns nt l nu nv">// Get the port mapped to 5432 and set as ENV</span><span id="0a95" class="nr lp it ni b gy nw nt l nu nv">p, _ := postgresC.MappedPort(ctx, "5432")</span><span id="9ef2" class="nr lp it ni b gy nw nt l nu nv">os.Setenv("DBPORT", p.Port())</span></pre><p id="ca12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经创建了容器，我们需要弄清楚它映射到哪个端口5432。我们可以使用<code class="fe nf ng nh ni b">MappedPort</code>函数做到这一点，并将它设置为我们的<code class="fe nf ng nh ni b">DBPORT</code>环境变量。</p><p id="1e98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是设置！我在每个包中都定义了一个<code class="fe nf ng nh ni b">TestMain</code>函数，所有的TestContainer设置都在里面。之后，我就像平常一样测试，没有模仿！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="8e4f" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">运行测试</h1><p id="7958" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">现在运行测试会提供以下输出:</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="e943" class="nr lp it ni b gy ns nt l nu nv">Users-Air:go-gmux-db-testcontainers user$ make test<br/>go test -v ./... -coverpkg ./...<br/>?       github.com/atkinsonbg/go-gmux-db-testcontainers [no test files]<br/>2020/12/30 16:27:06 Starting container id: c408f3bca264 image: quay.io/testcontainers/ryuk:0.2.3<br/>2020/12/30 16:27:06 Waiting for container id c408f3bca264 image: quay.io/testcontainers/ryuk:0.2.3<br/>2020/12/30 16:27:06 Container is ready id: c408f3bca264 image: quay.io/testcontainers/ryuk:0.2.3<br/>2020/12/30 16:27:07 Starting container id: e8ccb040bfed image: postgres:11.6-alpine<br/>2020/12/30 16:27:07 Waiting for container id e8ccb040bfed image: postgres:11.6-alpine<br/>2020/12/30 16:27:09 Container is ready id: e8ccb040bfed image: postgres:11.6-alpine<br/>2020/12/30 16:27:09 DB is not ready...backing off...<br/>2020/12/30 16:27:09 DB is not ready...backing off...<br/>2020/12/30 16:27:10 DB is ready!<br/>=== RUN   TestConfig<br/>--- PASS: TestConfig (0.00s)<br/>=== RUN   TestGetAllTimezones<br/>--- PASS: TestGetAllTimezones (0.00s)<br/>=== RUN   TestGetTimezone<br/>--- PASS: TestGetTimezone (0.00s)<br/>=== RUN   TestInsertTimezone<br/>--- PASS: TestInsertTimezone (0.00s)<br/>PASS<br/>coverage: 45.6% of statements in ./...<br/>ok      github.com/atkinsonbg/go-gmux-db-testcontainers/database        (cached)        coverage: 45.6% of statements in ./...<br/>2020/12/30 16:27:06 Starting container id: 5d99c0559dea image: quay.io/testcontainers/ryuk:0.2.3<br/>2020/12/30 16:27:06 Waiting for container id 5d99c0559dea image: quay.io/testcontainers/ryuk:0.2.3<br/>2020/12/30 16:27:06 Container is ready id: 5d99c0559dea image: quay.io/testcontainers/ryuk:0.2.3<br/>2020/12/30 16:27:07 Starting container id: 0310b61386ca image: postgres:11.6-alpine<br/>2020/12/30 16:27:07 Waiting for container id 0310b61386ca image: postgres:11.6-alpine<br/>2020/12/30 16:27:09 Container is ready id: 0310b61386ca image: postgres:11.6-alpine<br/>2020/12/30 16:27:09 DB is not ready...backing off...<br/>2020/12/30 16:27:09 DB is ready!<br/>=== RUN   TestHealthHandler<br/>--- PASS: TestHealthHandler (0.00s)<br/>=== RUN   TestListTimezonesHandler<br/>--- PASS: TestListTimezonesHandler (0.00s)<br/>=== RUN   TestGetTimezoneHandler<br/>--- PASS: TestGetTimezoneHandler (0.00s)<br/>=== RUN   TestInsertTimezoneHandler<br/>--- PASS: TestInsertTimezoneHandler (0.00s)<br/>PASS<br/>coverage: 68.4% of statements in ./...<br/>ok      github.com/atkinsonbg/go-gmux-db-testcontainers/handlers        (cached)        coverage: 68.4% of statements in ./...</span></pre><p id="0f4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，测试容器开始运转，我的所有测试都在执行，不需要模拟！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="3479" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">包扎</h1><p id="4981" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">总而言之，我对TestContainers非常满意。鉴于我之前在没有模拟的情况下进行测试的尝试，这一关不那么复杂，也更容易编码。也就是说，我很高兴我能够尝试这两个，因为它们都工作得很好。有选择总是好的，所以现在我至少有两个选择！</p><h2 id="877e" class="nr lp it bd lq nx ny dn lu nz oa dp ly km ob oc mc kq od oe mg ku of og mk oh bi translated">资源</h2><ul class=""><li id="3d58" class="mr ms it kd b ke mm ki mn km oi kq oj ku ok ky mw mx my mz bi translated">GitHub回购:<a class="ae kz" href="https://github.com/atkinsonbg/go-gmux-db-testcontainers" rel="noopener ugc nofollow" target="_blank">https://github.com/atkinsonbg/go-gmux-db-testcontainers</a></li><li id="6ef2" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">测试容器Go:<a class="ae kz" href="https://github.com/testcontainers/testcontainers-go" rel="noopener ugc nofollow" target="_blank">https://github.com/testcontainers/testcontainers-go</a></li><li id="5c0e" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">TestContainers Go文档:<a class="ae kz" href="https://golang.testcontainers.org/" rel="noopener ugc nofollow" target="_blank">https://golang.testcontainers.org/</a></li></ul></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><figure class="nj nk nl nm gt ju gh gi paragraph-image"><a href="https://ko-fi.com/O5O63ENS7"><div class="gh gi ol"><img src="../Images/3515ab52cb6fb5e74c27c7a2e06d3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5imNjCtY48Wh3owQyPv6Cw.png"/></div></a></figure></div></div>    
</body>
</html>