<html>
<head>
<title>DataTable with MobX implementation in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter中使用MobX实现的数据表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/datatable-with-mobx-implementation-in-flutter-8c5994b118e1?source=collection_archive---------1-----------------------#2021-02-20">https://levelup.gitconnected.com/datatable-with-mobx-implementation-in-flutter-8c5994b118e1?source=collection_archive---------1-----------------------#2021-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1964" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们将看看如何实现由MobX支持的Flutter数据表。我们将创建<strong class="jp ir">月度发票表</strong>。它显示特定用户每月的个人发票。我们将读取的所有必要数据都将保存在本地json文件中，该文件在assets/ folder中指定为invoices.json。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="b134" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> GIF: </strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="934c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL:DR/源代码:</strong></p><div class="kz la gp gr lb lc"><a href="https://github.com/Abdulsametileri/Flutter-DataTable-with-MobX" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd ir gy z fp lh fr fs li fu fw ip bi translated">abdulsamiteleri/Flutter-带MobX的数据表</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">一个新的颤振项目。这个项目是颤振应用的起点。一些帮助您入门的资源…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq lr lc"/></div></div></a></div></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="b585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文并不打算作为MobX的介绍。所以我们会假设你已经有了MobX是什么的基本知识。如果没有，你可以在<a class="ae ls" href="https://mobx.netlify.app/getting-started" rel="noopener ugc nofollow" target="_blank">他们的网站</a>上阅读基础。我认为它比BLoC更容易学习和实现。我是说，不要害怕使用它。:)</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="3932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们必须准备发票模型来解析json，如下所示。如您所见，它由id、日期和金额组成。这些属性向我们展示了发票的样子。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lt ky l"/></div></figure><p id="ef79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相应的dart类是:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lt ky l"/></div></figure><p id="1a28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个类可以通过复制我们的json文件使用网站<a class="ae ls" href="https://javiercbk.github.io/json_to_dart/" rel="noopener ugc nofollow" target="_blank">很容易地创建。也可以使用</a><a class="ae ls" href="https://pub.dev/packages/json_serializable" rel="noopener ugc nofollow" target="_blank"> json_serializable </a>包。为了简单起见，我们不会在本文中使用这个包。</p><p id="c31b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看我们的视图模型。您可以将视图模型视为包含所有应用程序逻辑、api调用、业务规则等的模型。</p><p id="865e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将尝试一行一行地讲述代码做了什么。</p><p id="6a3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始吧。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lt ky l"/></div></figure><p id="697a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们的<a class="ae ls" href="https://mobx.netlify.app/concepts" rel="noopener ugc nofollow" target="_blank">网站</a>对可观察、计算和动作注释进行了详细解释。简而言之，你可以认为<strong class="jp ir">是可观察的，</strong>我们跟踪注释变量以根据它们的值改变ui，<strong class="jp ir">计算的</strong>是可观察变量的派生形式，<strong class="jp ir">动作</strong>是改变可观察值的方式。</p><pre class="ks kt ku kv gt lu lv lw lx aw ly bi"><span id="0a58" class="lz ma iq lv b gy mb mc l md me">@observable</span><span id="8510" class="lz ma iq lv b gy mf mc l md me">ObservableList&lt;ExInvoiceModel&gt; invoices = &lt;ExInvoiceModel&gt;[].asObservable();</span></pre><p id="5b4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> ExInvoiceModel </strong>是InvoiceModel的超集。该类扩展了InvoiceModel并添加了名为<strong class="jp ir"> isSelected </strong>的新属性。</p><p id="9f0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> isSelected </strong>只是一个逻辑属性。为了更改我们的复选框和总金额卡，我们需要跟踪它的值，所以我们必须在它上面放置可观察的注释。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lt ky l"/></div></figure><pre class="ks kt ku kv gt lu lv lw lx aw ly bi"><span id="b145" class="lz ma iq lv b gy mb mc l md me">ObservableList</span></pre><p id="bbd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是一种特殊类型的列表。Dart不支持可观察的<t>类型。这些类型来自MobX包。MobX会自动观察其中的所有项目。在添加、删除或更新项目的情况下，将发出相关的动作。这意味着您将被告知有什么变化。因此你可以很容易地处理它。</t></p><pre class="ks kt ku kv gt lu lv lw lx aw ly bi"><span id="5060" class="lz ma iq lv b gy mb mc l md me">@observable</span><span id="dfb6" class="lz ma iq lv b gy mf mc l md me">ObservableList&lt;ExInvoiceModel&gt; invoices = &lt;ExInvoiceModel&gt;[].asObservable();</span></pre><p id="c804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以考虑不需要在invoices变量上添加可观察的注释。因为我们已经指出列表项是可观察的。其实都是你的逻辑问题。例如，如果你想跟踪从<code class="fe mg mh mi lv b">null</code>到一个有值列表的情况，你必须把它。在这篇文章中，我倾向于这样写:</p><pre class="ks kt ku kv gt lu lv lw lx aw ly bi"><span id="074c" class="lz ma iq lv b gy mb mc l md me">.asObservable();</span></pre><p id="e2e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过是一个扩展方法。把它从列表<t>转换成观察列表<t>。</t></t></p><pre class="ks kt ku kv gt lu lv lw lx aw ly bi"><span id="794f" class="lz ma iq lv b gy mb mc l md me">@computed<br/>List&lt;ExInvoiceModel&gt; get selectedInvoices =&gt; invoices.where((invoice) =&gt; invoice.isSelected).toList();</span></pre><p id="dfe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了计算选中发票的金额，我们需要定义<strong class="jp ir">selectedingvoices</strong>变量。这是非常简单的方法。我们将根据isSelected值过滤数组。</p><pre class="ks kt ku kv gt lu lv lw lx aw ly bi"><span id="976c" class="lz ma iq lv b gy mb mc l md me">@computed<br/>bool get selectedInvoicesIsEmpty =&gt; selectedInvoices.isEmpty;</span></pre><p id="51dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要根据selectedInvoices中的项目隐藏或显示页脚。如果没有项目在那里，我们需要隐藏我们的金额卡页脚。</p><pre class="ks kt ku kv gt lu lv lw lx aw ly bi"><span id="9274" class="lz ma iq lv b gy mb mc l md me">@computed<br/>int get totalAmount =&gt; selectedInvoices.fold(0, (previousValue, element) =&gt; previousValue + element.amount);</span></pre><p id="4541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你第一次能想到我们为什么不用还原法吗？因为我们必须处理对象类型。不是int、string等主要类型。Reduce对主要类型有效，所以不适合我们的情况。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/fb22132276ca760ee6bc4ad03e6f9afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKKA1NYtYHIz-flv9nhIZw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">fetchingvoices</figcaption></figure><p id="0015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MobX说，对fetchInvoices方法采取行动，由于这个方法，我们将变异<strong class="jp ir"> invoices </strong>变量。请跟踪它。如果你仔细观察这个方法，它基本上就是读取本地json，解码我们的InvoiceModel并添加我们的observable invoices变量。为了获取数据，我们需要调用这个方法。</p><p id="127d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将看看我们完整的用户界面。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lt ky l"/></div></figure><p id="c00b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将一部分一部分地看。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mt"><img src="../Images/27573ac31d04d142e6d04a117bfe2cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLQGNDVqv1_hFm3FvWbTAw.png"/></div></div></figure><p id="9ebd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了获得初始数据，我们需要在initState生命周期中调用fetchInvoices方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lt ky l"/></div></figure><p id="778c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要用观察者小部件包装我们的数据表。因为我们会触发UI变量的变化。我们将把我们的可观察列表映射到DataRow，所以我们需要调用<a class="ae ls" href="https://www.tutorialspoint.com/dart_programming/dart_programming_map.htm" rel="noopener ugc nofollow" target="_blank"> map </a>方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mt"><img src="../Images/bc77b2104a02538a2cc8bb4921bda28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JsFRF0htwvtxjdYAL_vmA.png"/></div></div></figure><p id="9809" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里面有两个重要属性。如果你想在每一行中选择复选框列，我们必须定义<strong class="jp ir">onselectchanged</strong>。请记住，我们将isSelected属性定义为observable，MobX跟踪该变量中的变化并触发Observer小部件，因此我们的UI会刷新，我们会在屏幕上看到我们的变化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lt ky l"/></div></figure><p id="9ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将用观察者小部件包装我们的页脚。因为我们需要根据<strong class="jp ir">selectedingvoices</strong>数组来绘制我们的ui。如果我们的数组填充了项目，我们将需要计算总金额。如果不是这样，我们可以显示空的部件。</p><p id="fa6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，就这样。如果你想看更多的细节，你可以查看源代码。</p><div class="kz la gp gr lb lc"><a href="https://github.com/Abdulsametileri/Flutter-DataTable-with-MobX" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd ir gy z fp lh fr fs li fu fw ip bi translated">abdulsamiteleri/Flutter-带MobX的数据表</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">一个新的颤振项目。这个项目是颤振应用的起点。一些帮助您入门的资源…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="mu l ln lo lp ll lq lr lc"/></div></div></a></div></div></div>    
</body>
</html>