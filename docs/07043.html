<html>
<head>
<title>TypeScript, Apollo Client and GraphQL Code Generator — a love triangle.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript、Apollo客户端和GraphQL代码生成器——一个三角恋。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-apollo-client-and-graphql-code-generator-a-love-triangle-df4cb46c9442?source=collection_archive---------3-----------------------#2021-01-20">https://levelup.gitconnected.com/typescript-apollo-client-and-graphql-code-generator-a-love-triangle-df4cb46c9442?source=collection_archive---------3-----------------------#2021-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ed8190e7de7c7995e5bf18a99048dd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJ5vIReIqbHhZWCrSr3tiQ.png"/></div></figure><p id="32cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在过去的两个月里，我一直在为一家基于Shopify平台的客户商店开发店面iOS应用程序。由于Shopify使用GraphQL——一种查询语言和运行时系统——来访问其API，我认为这将是深入学习graph QL的好时机。我以前有过使用REST的经验，使用GraphQL简直就是一见钟情。作为一个TypeScript的超级粉丝，我很喜欢所有的东西都是完全类型化的，都是模式的一部分，并且都可以通过单个端点访问，而不像REST那样每个数据部分都有不同的url。</p><p id="8cb7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我选择的客户端是Apollo Client v3，它非常平滑地集成了React Native，并通过其缓存和React变量或使用@client标记的仅本地字段提供了简单的操作挂钩和全局状态管理系统。</p><p id="82a9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我之前参与的项目中，我使用Redux作为本地状态管理，我非常喜欢Redux的控制流和逻辑。Apollo在开始时有点难以理解，但过了一段时间，老实说，我开始喜欢使用Apollo Client，而不是Redux，这是因为Apollo将数据存储在缓存中，并且只在内存缓存中没有数据时才尝试从服务器获取实际需要的数据，所有这些都可以使用缓存策略进行配置。我还发现，使用带有反应性变量的Apollo，我的组件中的反应性和数据订阅更加直观，也更容易实现。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ks"><img src="../Images/18e50ba641d48388a9e04b4d8dc48083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wVPM7SbOGZCDIfo8SfivMg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">Apollo缓存声明中的类型策略示例</figcaption></figure><p id="ccf5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Apollo Client还附带了一个基于GraphQL模式生成客户端类型的工具。我一开始一直在使用它，虽然这个工具运行良好，但我最近偶然发现了GraphQL的另一个工具GraphQL Code Generator，它做同样的事情，但我发现它使用起来更加直观。</p><p id="f60e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">到目前为止，让GraphQL代码生成器与TypeScript无缝协作的一些技巧对我很有用:</p><ul class=""><li id="e476" class="lf lg iq jw b jx jy kb kc kf lh kj li kn lj kr lk ll lm ln bi translated">用片段！—这一点我怎么强调都不为过。片段是GraphQL类型的可重用单元，生成器将为每个片段创建一个类型，因此在查询中使用片段将使在应用程序中重用相同的数据类型变得更加容易。这也将有助于访问嵌套类型</li></ul><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lo"><img src="../Images/03ffbb3bcf32074cbb3e6ae7dc002537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*If3KCyzMWkJ4YwtldmsmoQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">利用片段访问嵌套数据类型</figcaption></figure><ul class=""><li id="cbe2" class="lf lg iq jw b jx jy kb kc kf lh kj li kn lj kr lk ll lm ln bi translated">当使用片段时，您不需要在。<strong class="jw ir"> graphql </strong>文件，只需使用片段的名称——此时代码生成器将为片段和操作生成类型，并将它们包含在同一个文件中。</li><li id="d91d" class="lf lg iq jw b jx lp kb lq kf lr kj ls kn lt kr lk ll lm ln bi translated">将所有操作写在单独的文件中，并正确命名。我会建议类似于:<strong class="jw ir"> <em class="lu">【组件】。【操作】。graphql </em> </strong>，其中<strong class="jw ir">组件</strong>是组件或数据类型的名称，<strong class="jw ir">操作</strong>是突变、查询或片段，<strong class="jw ir"> <em class="lu">。graphql </em>为扩展</strong>。</li></ul><p id="c584" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用单独片段的示例:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lv"><img src="../Images/38920170e16c91575bcaf00d6654e6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2bm72sV9xiHSSNStwZQeg.png"/></div></div></figure><ul class=""><li id="f2dc" class="lf lg iq jw b jx jy kb kc kf lh kj li kn lj kr lk ll lm ln bi translated">为<strong class="jw ir">使用具有代码突出显示和完成的VSCode扩展。graphql </strong>文件。我推荐:<a class="ae lw" href="https://github.com/graphql/vscode-graphql" rel="noopener ugc nofollow" target="_blank"> VSCODE-GraphQL扩展</a></li><li id="a02e" class="lf lg iq jw b jx lp kb lq kf lr kj ls kn lt kr lk ll lm ln bi translated">在主根文件夹中为配置创建一个<strong class="jw ir"> codegen.js </strong>。使用。js而不是。yml，因为你从VSCode得到了本机代码语法。以下是我的配置文件示例:</li></ul><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lx"><img src="../Images/4363382183d17848b2e3042a080a64a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpKyjDWV0CaWduUuf4kv6A.png"/></div></div></figure><ul class=""><li id="0917" class="lf lg iq jw b jx jy kb kc kf lh kj li kn lj kr lk ll lm ln bi translated">如果您希望代码生成器为您生成React挂钩，那么设置<strong class="jw ir"> withHooks : true </strong>。我更喜欢自己编写钩子，只使用生成的类型——这可能会有争议，因为通过使用代码生成器生成的钩子代码，你基本上将Apollo逻辑包装在另一层中，因此它与应用程序更加解耦，但就我个人而言，我更喜欢自己编写钩子逻辑，只使用类型。</li><li id="3247" class="lf lg iq jw b jx lp kb lq kf lr kj ls kn lt kr lk ll lm ln bi translated">注意，这里我还有一个<strong class="jw ir">模式</strong>选项，它只指向我的本地模式。我的服务器模式是在我在这里导入的<strong class="jw ir"> graphql.config.json </strong>文件中声明的。它包含Shopify GraphQL API的端点和带有Storefront API键的头。</li><li id="538e" class="lf lg iq jw b jx lp kb lq kf lr kj ls kn lt kr lk ll lm ln bi translated">将<strong class="jw ir"> preResolveTypes </strong>设置为true会强制生成器使用更简单的类型，并在可能的情况下解析为使用TypeScript原语。这也是个人喜好。</li><li id="4e90" class="lf lg iq jw b jx lp kb lq kf lr kj ls kn lt kr lk ll lm ln bi translated">GraphQL代码生成器也可以在手表模式下使用，因此无论何时您更改任何<strong class="jw ir">。graphql </strong>文件生成器将重新创建这些类型。</li><li id="4eeb" class="lf lg iq jw b jx lp kb lq kf lr kj ls kn lt kr lk ll lm ln bi translated">！！不要修改生成的文件，因为每次运行代码生成器时都会重写它。</li><li id="933f" class="lf lg iq jw b jx lp kb lq kf lr kj ls kn lt kr lk ll lm ln bi translated">要运行生成器，只需将以下脚本添加到<strong class="jw ir">package . JSON</strong>:<strong class="jw ir">" generate ":" graph QL-codegen—config codegen . js "</strong></li></ul><p id="a2bf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">生成类型后，只需从您想要使用的组件中的生成文件中导入单个类型:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ly"><img src="../Images/0551d7226450b413015cf7e373825590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcD6o2VkvFDlothanQQkFA.png"/></div></div></figure><p id="45cd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我将保持这篇文章的简短，但是很快我一定会写一篇更深入的文章。我还计划写更多关于如何使用Apollo客户机进行本地状态管理的文章，因为我发现让Apollo处理服务器和客户机状态比试图将其与其他服务集成要容易得多。</p></div></div>    
</body>
</html>