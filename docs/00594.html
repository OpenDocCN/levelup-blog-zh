<html>
<head>
<title>Extract Prometheus Metrics to a Spreadsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将普罗米修斯指标提取到电子表格中</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/extract-prometheus-metrics-to-spreadsheet-a22e1c549635?source=collection_archive---------1-----------------------#2019-05-23">https://levelup.gitconnected.com/extract-prometheus-metrics-to-spreadsheet-a22e1c549635?source=collection_archive---------1-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fcf5abbb49d2c11a883b3e8df18c61b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xGAwOJAkFVjMGp3b.jpg"/></div></div></figure><p id="277f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不管喜欢与否，电子表格格式在企业环境中非常普遍。在我的一个项目中，我需要提取普罗米修斯的数据，并将其保存为电子表格格式，以供进一步分析。</p><p id="640c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Prometheus提供HTTP API来查询数据，并以JSON格式返回。我想使用Prometheus HTTP API 的<a class="ae kz" href="https://github.com/prometheus/client_golang#client-for-the-prometheus-http-api" rel="noopener ugc nofollow" target="_blank">客户端直接查询指标，而不是解析JSON数据。此外，我想使配置足够灵活，所以我的用户可以根据自己的需要定义电子表格。这就引出了我在GitHub上发表的工具，</a><a class="ae kz" href="https://github.com/zhiminwen/Prom2Sheet" rel="noopener ugc nofollow" target="_blank"> prom2Sheet </a>。</p><h2 id="22d3" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">定义电子表格内容</h2><p id="ad71" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">我以yaml格式定义了下面的电子表格配置文件。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="114d" class="la lb it md b gy mh mi l mj mk">---<br/>sheets:<br/>- name: CPU Requests<br/>  query: kube_pod_container_resource_requests_cpu_cores<br/>  columns:<br/>    - name: Env<br/>      type: OS.Environment<br/>      value: P_ENV<br/>    - name: Timestamp<br/>      type: Prometheus.Timestamp<br/>    - name: Namespace<br/>      type: Prometheus.Metric<br/>      value: namespace<br/>    - name: Pod<br/>      type: Prometheus.Metric<br/>      value: pod<br/>    - name: Container<br/>      type: Prometheus.Metric<br/>      value: container<br/>    - name: Node<br/>      type: Prometheus.Metric<br/>      value: node<br/>    - name: CPU Requests<br/>      type: Prometheus.Value</span><span id="e04d" class="la lb it md b gy ml mi l mj mk">- name: Memory Requests<br/>  query: kube_pod_container_resource_requests_memory_bytes<br/>  columns:<br/>    - name: Env<br/>      type: OS.Environment<br/>      value: P_ENV<br/>    - name: Timestamp<br/>      type: Prometheus.Timestamp<br/>    - name: Namespace<br/>      type: Prometheus.Metric<br/>      value: namespace<br/>    - name: Pod<br/>      type: Prometheus.Metric<br/>      value: pod<br/>    - name: Container<br/>      type: Prometheus.Metric<br/>      value: container<br/>    - name: Node<br/>      type: Prometheus.Metric<br/>      value: node<br/>    - name: Memory Requests<br/>      type: Prometheus.Value</span></pre><p id="5bdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">sheets数组定义了如何创建电子表格文件中的每个工作表。</p><p id="7aca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询字段是Prometheus查询，它将返回Prometheus矢量数据，该数据只有一个时间戳和值对。如果您执行一个范围查询，那么您需要应用一些聚合函数来确保查询返回一个向量数据。例如，使用以下查询</p><p id="4730" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mm mn mo md b">avg_over_time(kube_pod_container_resource_requests_memory_bytes[1h])</code></p><p id="28d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检索数据时，我使用配置中定义的列在电子表格中创建数据列。</p><p id="1688" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">名称字段设置列的标题。有几种类型的列定义了单元格数据应该如何设置。</p><ul class=""><li id="d781" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated"><strong class="kd iu"> OS。环境</strong>:通过读取由值字段定义的OS环境变量来设置单元数据。这带来了在工作表中添加额外列的灵活性，尤其是当我们将它作为Kubernetes作业运行时。</li><li id="3360" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><strong class="kd iu">普罗米修斯。时间戳</strong>:用返回的查询结果的时间戳设置单元格数据。</li><li id="0ce1" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><strong class="kd iu">普罗米修斯。度量</strong>:使用普罗米修斯度量设置单元数据。指标值基本上是字典键/值对中的值。键名在值字段的配置中定义。例如，对于以下配置，</li></ul><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="2669" class="la lb it md b gy mh mi l mj mk">- name: Pod<br/>  type: Prometheus.Metric<br/>  value: pod</span></pre><p id="3132" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单元格值将是度量结果的pod名称，如“<code class="fe mm mn mo md b">kube-dns-22p7s</code></p><ul class=""><li id="4e02" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated"><strong class="kd iu">普罗米修斯。值</strong>:指标查询的实际浮点数。</li></ul><h2 id="85fc" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">导入的模块</h2><p id="fbdb" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">我正在使用下面的Prometheus客户端API模块。对于电子表格处理，我使用tealeg的xlsx。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="7e99" class="la lb it md b gy mh mi l mj mk">"github.com/prometheus/client_golang/api" <br/>v1 "github.com/prometheus/client_golang/api/prometheus/v1"<br/>"github.com/prometheus/common/model"</span><span id="db35" class="la lb it md b gy ml mi l mj mk">"github.com/tealeg/xlsx"</span></pre><h2 id="a50a" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">连接普罗米修斯</h2><p id="2f43" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在IBM Cloud Private中，Prometheus通过客户端证书认证来保护。我们必须使用同一个CA生成的证书与Prometheus对话。以下函数显示了如何使用客户端证书构建基于https的连接。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="dd4b" class="la lb it md b gy mh mi l mj mk">func NewClient(promUrl, caFile, certFile, keyFile string) v1.API {<br/> caCert, err := ioutil.ReadFile(caFile)<br/> if err != nil {<br/>  log.Fatalf("Could not read CA file:%v", err)<br/> }</span><span id="482b" class="la lb it md b gy ml mi l mj mk"> caCertPool := x509.NewCertPool()<br/> caCertPool.AppendCertsFromPEM(caCert)</span><span id="bc8d" class="la lb it md b gy ml mi l mj mk"> cert, err := tls.LoadX509KeyPair(certFile, keyFile)<br/> if err != nil {<br/>  log.Fatalf("could not load client cert and key file:%v", err)<br/> }</span><span id="54a2" class="la lb it md b gy ml mi l mj mk"> transport := &amp;http.Transport{<br/>  TLSClientConfig: &amp;tls.Config{<br/>   RootCAs:      caCertPool,<br/>   Certificates: []tls.Certificate{cert},<br/>  },<br/> }<br/> client, err := api.NewClient(api.Config{<br/>  Address:      promUrl,<br/>  RoundTripper: transport,<br/> })<br/> if err != nil {<br/>  log.Fatalf("Failed to create prometheus client: %v", err)<br/> }</span><span id="962c" class="la lb it md b gy ml mi l mj mk"> return v1.NewAPI(client)<br/>}</span></pre><h2 id="8473" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">将Prometheus查询保存到工作表中</h2><p id="bddb" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">通过传递查询字符串可以直接调用查询。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="4596" class="la lb it md b gy mh mi l mj mk">func SaveSheet(sheet *xlsx.Sheet, promApi v1.API, sheetConfig Sheet) error {<br/> value, err := promApi.Query(context.Background(),   sheetConfig.Query, time.Now())<br/> if err != nil {<br/>  log.Printf("error: %v", err)<br/>  return err<br/> }<br/> var row *xlsx.Row<br/> var cell *xlsx.Cell</span><span id="e741" class="la lb it md b gy ml mi l mj mk"> row = sheet.AddRow()<br/> for _, col := range sheetConfig.Columns {<br/>  cell = row.AddCell()<br/>  cell.SetString(col.Name)<br/> }</span><span id="acf3" class="la lb it md b gy ml mi l mj mk"> for _, v := range value.(model.Vector) {<br/>  row = sheet.AddRow()<br/>  for _, col := range sheetConfig.Columns {<br/>   cell = row.AddCell()<br/>   switch col.Type {<br/>   case "OS.Environment":<br/>    cell.SetString(os.Getenv(col.Value))<br/>   case "Prometheus.Timestamp":<br/>    cell.SetDateTime(v.Timestamp.Time())<br/>   case "Prometheus.Metric":<br/>    cell.SetValue(string(v.Metric[model.LabelName(col.Value)]))<br/>   case "Prometheus.Value":<br/>    cell.SetFloat(float64(v.Value))<br/>   }<br/>  }<br/> }</span><span id="c417" class="la lb it md b gy ml mi l mj mk"> return nil<br/>}</span></pre><p id="8595" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦结果value成功返回，首先我们将标题行添加到电子表格中。将值转换为vector数据类型，循环遍历它们，它们中的每一个都将保存为工作表中的一行。</p><p id="4004" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于列定义，相应地创建它的值。对于“<code class="fe mm mn mo md b">Prometheus.Metric</code>”的类型，我们需要将来自<code class="fe mm mn mo md b">string</code>的定义投射到<code class="fe mm mn mo md b">model.LabelName</code>中，并从<code class="fe mm mn mo md b">v.Metric</code>映射中获取其值。</p><h2 id="b483" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">样本结果</h2><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/a8dd5c1b2fde515c930ca73a7a235794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHfuLPRMKdjjBzNREUc_Fg.png"/></div></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><div class="ly lz ma mb gt nl"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">学习围棋-最佳围棋教程(2019) | gitconnected</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">22大围棋教程-免费学习围棋。课程由开发者提交和投票，使您能够找到…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">gitconnected.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz jz nl"/></div></div></a></div></div></div>    
</body>
</html>