<html>
<head>
<title>7 Differences Between Arrow Functions and Traditional Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7箭头功能和传统功能的区别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-differences-between-an-arrow-function-and-a-traditional-function-bbf8a6dc8ca4?source=collection_archive---------5-----------------------#2022-03-07">https://levelup.gitconnected.com/7-differences-between-an-arrow-function-and-a-traditional-function-bbf8a6dc8ca4?source=collection_archive---------5-----------------------#2022-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8023" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">箭头函数能完全取代传统函数吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a50c901893da6d06e876df251116aafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OX7_QW1SHwMJQ6lr"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">本·罗宾斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c34d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES6中出现的箭头功能给我们带来了很大的便利，但是和传统的功能还是有区别的。开发中稍有不慎就可能出问题，那就跟我来看看箭头函数和传统函数的7大区别吧！</p><h1 id="148e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.没有争论</h1><p id="06ad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在传统函数中，有一个<code class="fe ms mt mu mv b">arguments</code>局部变量。如果函数的参数数量是动态的，使用<code class="fe ms mt mu mv b">arguments</code>可以让我们很容易地计算传递参数的最大数量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/5a5fa9dff8a097fbfd3ff9746d4c84dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_KRr5a6nA9TkHxteRV-NA.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="50c2" class="nb lw it mv b gy nc nd l ne nf">function traditionalFn() {<br/>  <strong class="mv iu">return Math.max(...arguments);</strong><br/>}</span><span id="f1ff" class="nb lw it mv b gy ng nd l ne nf">// 3<br/>console.log(traditionalFn(1, 2, 3));</span></pre><p id="9511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">arguments</code>是一个类似阵列的物体。类数组对象和数组对象的相似之处在于，它们都可以使用下标来访问相应的元素，并且都具有长度属性。不同的是，类数组对象在数组上没有内置方法，但是我们可以使用<code class="fe ms mt mu mv b">Array.from</code>将类数组对象转换成数组对象。</p><p id="896b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在箭头函数中，没有<code class="fe ms mt mu mv b">arguments</code>，如果我们在箭头函数中访问参数，将返回最近的非箭头父函数的参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/bed27ef741d8b5d1b98c3a0e9b1e3b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9m4miI_kN-z-NEzTJVwng.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="147a" class="nb lw it mv b gy nc nd l ne nf">const arrowFn = () =&gt; {<br/>  <strong class="mv iu">// ❌ Uncaught ReferenceError: arguments is not defined<br/>  console.log(arguments);</strong><br/>};</span><span id="8117" class="nb lw it mv b gy ng nd l ne nf">function wrapArrowFn() {<br/>  const arrowFn = () =&gt; {<br/>    <strong class="mv iu">// ✅ `arguments` for the wrapArrowFn function<br/>    console.log(arguments);</strong><br/>  };<br/>}</span></pre><p id="32c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> rest参数</strong> </a>来代替，从而得到一个普通的数组对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/1699d04ac98b97fe729c35c835940c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_pQCIJLGhyEL9miFToikQ.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="9c69" class="nb lw it mv b gy nc nd l ne nf">const arrowFn = (...rest) =&gt; {<br/>  <strong class="mv iu">// ✅<br/>  return Math.max(...rest);</strong><br/>};</span><span id="22c6" class="nb lw it mv b gy ng nd l ne nf">// 3<br/>console.log(arrowFn(1, 2, 3));</span></pre><h1 id="2194" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.返回值可以省略花括号</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/0a783935954c361b248ea282f0524739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIltmulOScuCd_BRYv01nw.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="7dcd" class="nb lw it mv b gy nc nd l ne nf">function traditionalFn() {<br/>  return Math.max(...arguments);<br/>}</span><span id="810e" class="nb lw it mv b gy ng nd l ne nf">const arrowFn = (...rest) =&gt; Math.max(...rest);</span></pre><p id="1d76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到，在一个只包含一个表达式的内联箭头函数中，我们可以省略花括号来返回值，这使得代码更加清晰。</p><h1 id="9283" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.不允许重复的命名参数</h1><p id="806a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在非限制模式下，传统函数允许我们使用重复的命名参数。但是在严格模式下，是不允许的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/cc2b75812e61b0255ced15b95f3e47fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYD6gGh5lgx5wVw5_Wb5_w.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="4751" class="nb lw it mv b gy nc nd l ne nf"><strong class="mv iu">// 'use strict';<br/>// 💡 If strict mode is enabled, a syntax error will be reported:<br/>// Duplicate parameter name not allowed in this context.</strong></span><span id="9b49" class="nb lw it mv b gy ng nd l ne nf">function traditionalFn(a, a, a) {<br/>  return a;<br/>}</span><span id="bdc7" class="nb lw it mv b gy ng nd l ne nf">console.log(traditionalFn(1, 2, 3)); // 3</span></pre><p id="bada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在箭头函数中，无论是否启用严格模式，都不允许有同名的参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/ab0bb3215e8aaf5926696e1ee3ff91de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBmP-pMfoxUbtGLoExqCqw.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="f14c" class="nb lw it mv b gy nc nd l ne nf"><strong class="mv iu">// ❌ SyntaxError: Duplicate parameter name not allowed in this context.</strong><br/>const arrowFn = (a, a, a) =&gt; a;</span><span id="cc18" class="nb lw it mv b gy ng nd l ne nf">console.log(arrowFn(1, 2, 3));</span></pre><h1 id="00b3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.没有原型</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/c987e49c1829e78e70c50a5f0f871717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Pf9rzFGUYv7_OwuE_04-A.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="094b" class="nb lw it mv b gy nc nd l ne nf">function traditionalFn() {<br/>  return Math.max(...arguments);<br/>}</span><span id="b89b" class="nb lw it mv b gy ng nd l ne nf">const arrowFn = (...rest) =&gt; {<br/>  return Math.max(...rest);<br/>};</span><span id="92af" class="nb lw it mv b gy ng nd l ne nf"><strong class="mv iu">// {constructor: ƒ traditionalFn()}</strong><br/>console.log(traditionalFn.prototype);<br/><strong class="mv iu">// undefined</strong><br/>console.log(arrowFn.prototype);</span></pre><p id="bb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统函数我们可以得到<code class="fe ms mt mu mv b">prototype</code>，但是箭头函数没有<code class="fe ms mt mu mv b">prototype</code>。</p><h1 id="76e2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.不，这个</h1><p id="d5df" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在传统函数中，其内部的<code class="fe ms mt mu mv b">this</code>值是<strong class="lb iu">动态的</strong>，这取决于函数是如何被调用的。例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/323e4501d3224d3efdbf28dcd2711707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-op3ZNKq1xN42UL9IxOYA.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="031d" class="nb lw it mv b gy nc nd l ne nf">const test = {<br/>  name: 1,<br/>  <strong class="mv iu">getName: function () {<br/>    return this.name;<br/>  },</strong><br/>};</span><span id="c8c1" class="nb lw it mv b gy ng nd l ne nf">const getName = test.getName;</span><span id="f8a9" class="nb lw it mv b gy ng nd l ne nf">console.log(getName()); <strong class="mv iu">// undefined</strong><br/>console.log(test.getName()); <strong class="mv iu">// 1</strong></span></pre><p id="9c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在箭头函数中，没有<code class="fe ms mt mu mv b">this</code>，如果我们在箭头函数中访问它，它将返回最近的非箭头父函数的<code class="fe ms mt mu mv b">this</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/90cd7e4729ab029780a2a5c5d59b5b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcACJUZr67Wv1EIPFFmnGw.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="65a4" class="nb lw it mv b gy nc nd l ne nf"><strong class="mv iu">globalThis.name = 2;</strong></span><span id="0ba4" class="nb lw it mv b gy ng nd l ne nf">const test = {<br/>  name: 1,<br/>  <strong class="mv iu">getName: () =&gt; {<br/>    return this.name;<br/>  },</strong><br/>};</span><span id="f130" class="nb lw it mv b gy ng nd l ne nf">const getName = test.getName;</span><span id="b93f" class="nb lw it mv b gy ng nd l ne nf">console.log(getName()); <strong class="mv iu">// 2</strong><br/>console.log(test.getName()); <strong class="mv iu">// 2</strong></span></pre><p id="e1a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，一个箭头函数的<code class="fe ms mt mu mv b">this</code>是在声明的时候确定的，永远不会改变。所以<code class="fe ms mt mu mv b">call</code>、<code class="fe ms mt mu mv b">apply</code>、<code class="fe ms mt mu mv b">bind</code>不能改变箭头功能<code class="fe ms mt mu mv b">this</code>的值。</p><h1 id="be38" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.不能用new调用</h1><p id="2036" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以在传统函数上使用<code class="fe ms mt mu mv b">new</code>关键字来创建一个新对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/64fd2f867c403236a756be39c3533ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpcSOQt5GXoMY0qMPEruDA.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="1473" class="nb lw it mv b gy nc nd l ne nf">function Animal(name) {<br/>  this.name = name;<br/>}</span><span id="ba4f" class="nb lw it mv b gy ng nd l ne nf">const cat = new Animal('cat');</span><span id="a44d" class="nb lw it mv b gy ng nd l ne nf"><strong class="mv iu">// Animal { name: 'cat' }</strong><br/>console.log('cat: ', cat);</span></pre><p id="f52d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是箭头函数不能用<code class="fe ms mt mu mv b">new</code>调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/f0686b22ef038282cde4e10ad1eae619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oy5vykFLrV4jymV-MVeeZg.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="602e" class="nb lw it mv b gy nc nd l ne nf">const Animal = (name) =&gt; {<br/>  this.name = name;<br/>};</span><span id="5778" class="nb lw it mv b gy ng nd l ne nf"><strong class="mv iu">// ❌ TypeError: Animal is not a constructor.</strong><br/>const cat = new Animal('cat');</span></pre><p id="e03e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为当调用<code class="fe ms mt mu mv b">new</code>时，我们会经历以下四个步骤:</p><ol class=""><li id="1808" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">创建新对象</li><li id="e252" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">将新对象的<code class="fe ms mt mu mv b">__proto__</code>指向构造函数的<code class="fe ms mt mu mv b">prototype</code></li><li id="9650" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">用新对象调用构造函数<code class="fe ms mt mu mv b">this</code></li><li id="7882" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">如果调用的结果是一个对象，则返回该对象，如果不是，则返回第一步中创建的新对象。</li></ol><p id="e856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以实现一个模拟的新函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c69266c020ed0cc31566d3ecd1035982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbaIJ9Ck93UMpZ8guAUvLQ.png"/></div></div></figure><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="8751" class="nb lw it mv b gy nc nd l ne nf">const _new = (fn, ...args) =&gt; {<br/>  const newObj = Object.create(null);<br/>  Object.setPrototypeOf(newObj, fn.prototype);</span><span id="f9ee" class="nb lw it mv b gy ng nd l ne nf">  const callResult = fn.apply(newObj, args);<br/>  return typeof callResult === 'object' ? callResult : newObj;<br/>};</span></pre><p id="0e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以你可以看到arrow函数不能被new关键字调用，因为它有<strong class="lb iu">没有原型</strong>和<strong class="lb iu">没有this </strong>。</p><h1 id="e63e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7.不能用作生成器函数</h1><p id="cc42" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于历史原因，规范不允许在箭头函数中使用<strong class="lb iu"> yield </strong>命令，因此箭头函数不能用作生成器函数。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="0d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，箭头函数避免了很多可能导致误解的代码场景，它使我们的代码更清晰，更可控。简单越好，不是吗？</p><p id="47cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="om">最后，我是扎卡里。我会继续输出与web开发相关的故事。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="om">中等会员</em> </a> <em class="om">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="om">我的链接</em> </a> <em class="om">报名，我会得到一点佣金。</em></p><p id="09b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的支持对我来说非常重要——谢谢。</p></div></div>    
</body>
</html>