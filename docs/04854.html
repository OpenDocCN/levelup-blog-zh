<html>
<head>
<title>Creating A Simple 2D Game With HTML5 &amp; JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用HTML5和JavaScript创建一个简单的2D游戏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-simple-2d-game-with-html5-javascript-889aa06035ef?source=collection_archive---------1-----------------------#2020-07-20">https://levelup.gitconnected.com/creating-a-simple-2d-game-with-html5-javascript-889aa06035ef?source=collection_archive---------1-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7585cf8d0e9e9d216ea3143f81f309dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O98w8ztTUxSOD_7JNlh9lg.jpeg"/></div></div></figure><p id="f718" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解本文中的代码，您应该熟悉JavaScript，并了解HTML5 Canvas的基础知识。</p><p id="8260" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您还不熟悉Canvas，那么在继续之前花几分钟时间浏览一下这篇介绍性文章会很有帮助。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="19a3" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们在建造什么？</h1><p id="26ee" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated"><strong class="ka ir">最终产品将是一个简单的2D侧滚游戏。</strong></p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/c6347f58ccf2fa8b1b60301bbcf944de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24LcUr--WQJpjTr8K_jAeg.png"/></div></div></figure><ul class=""><li id="4bcf" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">简单的概念，明确的目标:玩家在前进时会遇到“障碍”,应该跳起来避开它们。</li><li id="019b" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">向前跑、向后跑和跳跃动作由键盘上相关的光标键(箭头)控制。</li><li id="08b9" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">我们将保持画布元素不复杂(只是正方形和三角形)，这样我们可以更好地关注元素运动和“无尽的奔跑”效果，这实际上使这感觉像一个真正的游戏。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a97f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">搭建舞台</h1><p id="4254" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在我们查看实际的“游戏”代码之前，我们需要设置我们的项目文件并创建我们打算使用的canvas元素。</p><ol class=""><li id="4902" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv na ms mt mu bi translated">我们将需要index.html、<strong class="ka ir"> game.js </strong>和<strong class="ka ir"> game.css </strong>文件。</li></ol><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="eb7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">首先:</strong></p><p id="ea75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个index.html并包含显示的代码。</p><ul class=""><li id="3431" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">确保在index.html中链接了样式表和javascript文件。</li><li id="feb5" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">我们在HTML的主体中创建canvas元素。我们将在别处为它处理任何样式和尺寸。</li><li id="bbbb" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">你给你自己的游戏起什么名字并不重要，只要包括相同的说明，告诉玩家他们可以使用哪些控件来玩游戏。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="0d46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">下一步:</strong>添加您喜欢的任何页面样式，包围将保存所有游戏内容的画布区域。</p><p id="2302" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以从上面的图像中看到，在我们的例子中，我们将画布放在页面的中心，CSS文件中唯一真正发生的样式将是我们包含的其他几个元素的背景和文本颜色。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="662a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">最后:</strong>添加你的<strong class="ka ir"> game.js </strong>文件，准备开始构建你的游戏！</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f389" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里跳过详细的解释，因为到本文的这一点，你要么已经掌握了画布知识，要么已经通过页面顶部的<a class="ae kw" href="https://link.medium.com/9VvfHzjBg8" rel="noopener">链接</a>掌握了基础知识。</p><p id="8c87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之:</p><ul class=""><li id="f726" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">在JavaScript中，我们需要做的第一件事是定义画布的上下文；结果是，获得了所有返回的方法以及更多我们在2D创建时需要的方法。</li><li id="44f6" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">下一步是调整画布元素的大小。如果我们不指定新的宽度和高度，元素默认为<em class="nd">300 px</em><strong class="ka ir">W</strong><strong class="ka ir">x</strong><em class="nd">150 px</em><strong class="ka ir">h .</strong></li><li id="c95f" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">当然，您可以选择自己的尺寸，以更好地适应您想要构建的游戏或您的游戏将被添加到的页面，但要知道，在我们的代码中有几个稍后使用的值完全是根据我们在示例中设置的尺寸计算的(<em class="nd">1120</em><strong class="ka ir">W</strong><strong class="ka ir">x</strong><em class="nd">400</em><strong class="ka ir">H</strong>)。<br/>你对画布尺寸所做的任何改变都需要反映在你为元素设置的坐标值中。</li></ul><p id="8a7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上代码之后的所有内容都将针对我们的游戏。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="6628" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建玩家元素</h1><p id="ab7d" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在游戏中代表玩家的方块将被存储为一个对象。我们将在整个代码中使用这个对象来:</p><ul class=""><li id="f1e0" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">更新作为正方形当前位置的坐标属性</li><li id="46f7" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">确定方块当前是否在空中</li><li id="d76a" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">确定方块是向前还是向后移动</li><li id="49fd" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">保持正方形的高度和宽度(设置大小)</li></ul><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="70c4" class="nj lf iq nf b gy nk nl l nm nn">const square = {</span><span id="415a" class="nj lf iq nf b gy no nl l nm nn">  height: 32,<br/>  jumping: true,<br/>  width: 32,<br/>  x: 0,<br/>  xVelocity: 0,<br/>  y: 0,<br/>  yVelocity: 0</span><span id="00a2" class="nj lf iq nf b gy no nl l nm nn">};</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="5463" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建玩家的控制器</h1><p id="89a0" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">控制器也将被表示为一个对象，并将跟踪玩家当前正在按下的键(允许我们确定在画布中采取哪个动作)。</p><p id="4407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们根据与左、右和上箭头键相关联的键码来检查键侦听器的事件类型。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="77a3" class="nj lf iq nf b gy nk nl l nm nn">const controller = {</span><span id="4966" class="nj lf iq nf b gy no nl l nm nn">  left: false,<br/>  right: false,<br/>  up: false,</span><span id="c85b" class="nj lf iq nf b gy no nl l nm nn">  keyListener: function (event) {</span><span id="7a2e" class="nj lf iq nf b gy no nl l nm nn">    let key_state = (event.type == "keydown") ? true : false;</span><span id="4f52" class="nj lf iq nf b gy no nl l nm nn">    switch (event.keyCode) {<br/>      case 37: // left arrow<br/>        controller.left = key_state;<br/>        break;<br/>      case 38: // up arrow<br/>        controller.up = key_state;<br/>        break;<br/>      case 39: // right arrow<br/>        controller.right = key_state;<br/>        break;<br/>    }<br/>  }<br/>};</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e413" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建促进动画的“循环”</h1><p id="1657" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">下一步是非常具体的一步。</p><p id="046c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">循环函数将是我们:</p><ul class=""><li id="d948" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">不断检查玩家正在用他们的控制器做什么，并相应地动画化玩家的方块(方向、速度、奔跑或跳跃)。</li><li id="8371" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">应用“重力”和“摩擦”效果，这将改变玩家方块的速度，并允许它以真实的方式移动。</li><li id="cba2" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">处理玩家的方块向左或向右退出屏幕的情况，并建立无限滚动行为。</li><li id="958c" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">绘制并填充组成游戏的所有画布形状，最初，以及每个新帧的动画。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><ol class=""><li id="4392" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv na ms mt mu bi translated">因此，让我们从设置条件块开始，这些条件块将通过调整正方形对象的速度值或将跳跃标志设为true来模拟玩家触发的正方形移动。</li></ol><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="8e9d" class="nj lf iq nf b gy nk nl l nm nn">const loop = function () {</span><span id="a6ff" class="nj lf iq nf b gy no nl l nm nn">  if (controller.up &amp;&amp; square.jumping == false) {<br/>    square.yVelocity -= 20;<br/>    square.jumping = true;<br/>  }</span><span id="007e" class="nj lf iq nf b gy no nl l nm nn">  if (controller.left) {<br/>    square.xVelocity -= 0.5;<br/>  }</span><span id="dd6a" class="nj lf iq nf b gy no nl l nm nn">  if (controller.right) {<br/>    square.xVelocity += 0.5;<br/>  }</span></pre><p id="07e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="5473" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.接下来，我们添加重力和摩擦效果。一旦添加了它们，它们在动作中不会很突出，但是没有它们，动画看起来会很颠簸和笨拙。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="c4c5" class="nj lf iq nf b gy nk nl l nm nn">  square.yVelocity += 1.5; // gravity</span><span id="e51b" class="nj lf iq nf b gy no nl l nm nn">  square.x += square.xVelocity;</span><span id="bfc3" class="nj lf iq nf b gy no nl l nm nn">  square.y += square.yVelocity;</span><span id="509b" class="nj lf iq nf b gy no nl l nm nn">  square.xVelocity *= 0.9; // friction</span><span id="4e84" class="nj lf iq nf b gy no nl l nm nn">  square.yVelocity *= 0.9; // friction</span></pre><p id="efd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="c0d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.在此之后，我们必须开始处理游戏的特征，这些特征将会在观看动画在屏幕上运行的方式时变得明显。</p><p id="4ad6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要保证方块永远不会“落到”我们确定要穿过的“地面”以下。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="b9dd" class="nj lf iq nf b gy nk nl l nm nn">  // if the square is falling below floor line, then:</span><span id="0993" class="nj lf iq nf b gy no nl l nm nn">  if (square.y &gt; 386 - 16 - 32) {</span><span id="bcc0" class="nj lf iq nf b gy no nl l nm nn">    square.jumping = false;</span><span id="38e2" class="nj lf iq nf b gy no nl l nm nn">    square.y = 386 - 16 - 32;</span><span id="6de8" class="nj lf iq nf b gy no nl l nm nn">    square.yVelocity = 0;</span><span id="7f90" class="nj lf iq nf b gy no nl l nm nn">  }</span></pre><p id="90ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，方块的y坐标的当前值永远不应该大于表示地线“顶部”的y坐标(从中减去跳跃的高度和方块的高度)。</p><p id="31f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">如果是</strong>，我们停止方块的跳跃，将方块的y坐标设置为它无法超越的值的y坐标，停止方块的“下落”(将y速度设置回0)。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="a189" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，我们需要保证当玩家的方块退出到游戏窗口的任何一边时，我们能够控制会发生什么。在这种情况下，我们设置它把玩家带回来，从他们离开的对面进入。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="d654" class="nj lf iq nf b gy nk nl l nm nn">  if (square.x &lt; -20) {</span><span id="b0ec" class="nj lf iq nf b gy no nl l nm nn">    square.x = 1220;</span><span id="e72e" class="nj lf iq nf b gy no nl l nm nn">  } else if (square.x &gt; 1220) {  // if the square goes off the right</span><span id="57f5" class="nj lf iq nf b gy no nl l nm nn">    square.x = -20;</span><span id="f660" class="nj lf iq nf b gy no nl l nm nn">  }</span></pre><p id="6587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="a19f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.接下来绘制形状，包括背景、地面层、玩家广场(以及本文后面的障碍物)。这也包含在循环函数中，因此它运行并重新绘制每个动画帧上的形状。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="b854" class="nj lf iq nf b gy nk nl l nm nn">  // Creates the backdrop for each frame</span><span id="c7c9" class="nj lf iq nf b gy no nl l nm nn">  context.fillStyle = "#201A23";</span><span id="675d" class="nj lf iq nf b gy no nl l nm nn">  context.fillRect(0, 0, 1220, 400); // x, y, width, height<br/></span><span id="492c" class="nj lf iq nf b gy no nl l nm nn">  // Creates and fills the cube for each frame</span><span id="4ed8" class="nj lf iq nf b gy no nl l nm nn">  context.fillStyle = "#8DAA9D"; // hex for cube color</span><span id="0f8d" class="nj lf iq nf b gy no nl l nm nn">  context.beginPath();</span><span id="02ff" class="nj lf iq nf b gy no nl l nm nn">  context.rect(square.x, square.y, square.width, square.height);</span><span id="bbab" class="nj lf iq nf b gy no nl l nm nn">  context.fill();<br/></span><span id="2767" class="nj lf iq nf b gy no nl l nm nn">  // Creates the "ground" for each frame</span><span id="03bb" class="nj lf iq nf b gy no nl l nm nn">  context.strokeStyle = "#2E2532";</span><span id="926f" class="nj lf iq nf b gy no nl l nm nn">  context.lineWidth = 30;</span><span id="1de3" class="nj lf iq nf b gy no nl l nm nn">  context.beginPath();</span><span id="ff5a" class="nj lf iq nf b gy no nl l nm nn">  context.moveTo(0, 385);</span><span id="78b9" class="nj lf iq nf b gy no nl l nm nn">  context.lineTo(1220, 385);</span><span id="aaa4" class="nj lf iq nf b gy no nl l nm nn">  context.stroke();</span></pre><p id="b9ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="2f69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.我们向浏览器发出信号，表示我们已经准备好执行动画，并且在下一次重画之前，浏览器应该使用循环函数更新动画。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="0af2" class="nj lf iq nf b gy nk nl l nm nn">// Updates when called to tell the browser it is ready to draw again</span><span id="2ae1" class="nj lf iq nf b gy no nl l nm nn">window.requestAnimationFrame(loop);</span></pre><p id="78d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">requestAnimationFrame方法的一个规则是，您传递给它的回调函数必须在它自身内部调用requestAnimationFrame<br/>(如果您想在下一次重画时动画显示另一帧)。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a3cb" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建事件监听器</h1><h2 id="9d18" class="nj lf iq bd lg np nq dn lk nr ns dp lo kj nt nu ls kn nv nw lw kr nx ny ma nz bi translated">(&amp; KICKSTART动画循环)</h2><p id="f721" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我们为控制器对象中的必要键设置了keyup和keydown事件侦听器。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="f95b" class="nj lf iq nf b gy nk nl l nm nn">window.addEventListener("keydown", controller.keyListener)</span><span id="ff0d" class="nj lf iq nf b gy no nl l nm nn">window.addEventListener("keyup", controller.keyListener);</span></pre><p id="b4cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们通过添加requestAnimationFrame的初始调用来启动动画循环，提供循环函数作为回调。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="90e4" class="nj lf iq nf b gy nk nl l nm nn">window.requestAnimationFrame(loop);</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="eaa0" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">下一步:障碍</h1><p id="ba23" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在这个阶段，我们几乎完成了。你会看到你是否遵循了你自己的代码版本，你有一个玩家控制的可以移动和跳跃的方块，以及一个看起来永远持续的背景。</p><p id="3098" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们忽略了等式中的一个关键部分，那就是玩家需要面对的障碍。为了进行必要的调整来创建它们，我们只需在已经编写好的代码中添加一两件事情</p><ol class=""><li id="50e1" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv na ms mt mu bi translated">首先，我们需要重温代码的最开始。<br/>在上下文定义下方和square声明上方的空白处，我们需要添加以下内容:</li></ol><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="42c4" class="nj lf iq nf b gy nk nl l nm nn">// Start the frame count at 1 (also level 1)<br/>let frameCount = 1;</span><span id="54d9" class="nj lf iq nf b gy no nl l nm nn">// Set the number of obstacles to match the current "level" number<br/>let obCount = frameCount;</span><span id="dfb3" class="nj lf iq nf b gy no nl l nm nn">// Create a collection to hold the randomly generated x coordinates<br/>const obXCoors = [];</span></pre><p id="5d8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望跟踪帧数，就我们对游戏幕后的关注而言，这相当于关卡。<br/>我们也想设置障碍的数量随着等级的增加而直接增加。<br/>最后，我们希望建立一个存储空间来保存我们随机生成的x坐标，并使用它在每个新帧上动态放置障碍物。</p><p id="be09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="e68e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.有一种简单的方法可以让我们知道用户何时完成了一个“级别”并开始了一个新的级别，而且它实际上已经在现有的代码中设置好了。</p><p id="5216" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道，如果用户从右边退出游戏窗口，那么他们将从左边重新进入，这将代表一个新的关卡开始了。因此，我们希望有一些函数在这种情况下可以调用。</p><p id="4a19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">* *作为一个旁注，解释为什么我们不能简单地在用户退出屏幕时画出障碍物体<em class="nd">:T<strong class="ka ir">画出形状的顺序<em class="nd"/>有关系吗？</strong> <br/>因此，我们可以提前创建我们的随机坐标，但必须等到<em class="nd">背景和其他形状绘制完成后再绘制障碍物。**</em></em></p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="4088" class="nj lf iq nf b gy nk nl l nm nn">// Create the obstacles for each frame</span><span id="5c8e" class="nj lf iq nf b gy no nl l nm nn">const nextFrame = () =&gt; {</span><span id="a565" class="nj lf iq nf b gy no nl l nm nn">  // increase the frame / "level" count</span><span id="a2e4" class="nj lf iq nf b gy no nl l nm nn">  frameCount++;</span><span id="ee64" class="nj lf iq nf b gy no nl l nm nn">  for (let i = 0; i &lt; obCount; i++) {</span><span id="9c0e" class="nj lf iq nf b gy no nl l nm nn">    // Randomly generate the x coordinate for the<br/>       top corner start of each triangle</span><span id="0ebb" class="nj lf iq nf b gy no nl l nm nn">    obXCoor = Math.floor(Math.random() * (1165 - 140 + 1) + 140);</span><span id="7a38" class="nj lf iq nf b gy no nl l nm nn">    obXCoors.push(obXCoor);</span><span id="449e" class="nj lf iq nf b gy no nl l nm nn">  }</span><span id="6818" class="nj lf iq nf b gy no nl l nm nn">}</span></pre><ul class=""><li id="4fd8" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">增加帧数(我们认为这意味着已经达到了下一个级别)，这将增加下一个场景中的障碍物的数量。</li><li id="a415" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">开始迭代，直到障碍物的当前计数。</li><li id="bcce" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">在140和1165的x坐标之间产生那个数量(障碍计数)的随机x坐标<br/>“随机的”——选择这些坐标是为了确保没有障碍会出现在离游戏窗口的开始太近的地方，或者正好在游戏窗口的结尾(对玩家来说完全不公平且不可能被击败)。</li><li id="3a95" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">将每个x坐标添加到坐标集合中，以便稍后可以在循环函数中动态绘制障碍物形状。</li></ul><p id="bede" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="725c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.一个非常小的调整，我们需要将nextFrame()的调用添加到验证播放器正在退出窗口右侧的条件中</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="60db" class="nj lf iq nf b gy nk nl l nm nn">} else if (square.x &gt; 1220) {// if square goes past right boundary</span><span id="6091" class="nj lf iq nf b gy no nl l nm nn">square.x = -20;</span><span id="da31" class="nj lf iq nf b gy no nl l nm nn">nextFrame();</span><span id="de2c" class="nj lf iq nf b gy no nl l nm nn">}</span></pre><p id="2ab9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(这个条件的其余部分已经在您的代码中，我只在这里显示它，以便您可以在上下文中看到nextFrame方法调用。)</p><p id="9a0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="f4b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.实际的<strong class="ka ir">最终的</strong>变化是将障碍物形状的绘制部分添加到循环函数体的正确区域。我们将把它插在正方形抽屉的下面，地面抽屉的上面。</p><pre class="mi mj mk ml gt ne nf ng nh aw ni bi"><span id="eff2" class="nj lf iq nf b gy nk nl l nm nn">  // Create the obstacles for each frame</span><span id="5694" class="nj lf iq nf b gy no nl l nm nn">  // Set the standard obstacle height</span><span id="2cfc" class="nj lf iq nf b gy no nl l nm nn">  const height = 200 * Math.cos(Math.PI / 6);</span><span id="c3db" class="nj lf iq nf b gy no nl l nm nn">  context.fillStyle = "#FBF5F3"; // hex for triangle color</span><span id="ba35" class="nj lf iq nf b gy no nl l nm nn">  obXCoors.forEach((obXCoor) =&gt; {</span><span id="c655" class="nj lf iq nf b gy no nl l nm nn">    context.beginPath();</span><span id="93d7" class="nj lf iq nf b gy no nl l nm nn">    // (x = random, y = coor. on "ground")<br/>    context.moveTo(obXCoor, 385);</span><span id="ea0d" class="nj lf iq nf b gy no nl l nm nn">    // (x = ^random + 20, y = coor. on "ground")<br/>    context.lineTo(obXCoor + 20, 385);</span><span id="e985" class="nj lf iq nf b gy no nl l nm nn">    // (x = ^random + 10, y = peak of triangle)<br/>    context.lineTo(obXCoor + 10, 510 - height);</span><span id="45d3" class="nj lf iq nf b gy no nl l nm nn">    context.closePath();</span><span id="9be1" class="nj lf iq nf b gy no nl l nm nn">    context.fill();</span><span id="6716" class="nj lf iq nf b gy no nl l nm nn">  });</span></pre><ul class=""><li id="926c" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">计算所有障碍物的标准高度</li><li id="929d" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">对随机生成的x坐标集合进行迭代，这将确定障碍物在地面上沿窗口宽度出现的位置。</li><li id="4c57" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">将每个x坐标值偏移一致的值(20和10 ),以绘制相同大小的等边三角形，而不管x坐标是什么。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="7920" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最后的结果</h1><p id="1845" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在我们介绍了所有内容之后，您的game.js文件应该如下所示:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><ul class=""><li id="111f" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">玩家可以向前或向后移动和跳跃。</li><li id="1619" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">玩家的动作和移动会看起来流畅而逼真。<br/> -当方块从跳跃中落回时，存在影响方块的“重力”<br/> -当方块向前或向后滑动时，存在影响方块的“摩擦力”<br/> -按住向前或向后箭头，同时仍然按住另一个箭头，将会减慢然后立即停止方块的运动，因为两个相互冲突的力同时作用在物体上。</li><li id="1508" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">对于一个简单、快速的效果，障碍物的数量将与当前的“级别”相匹配(玩家每次通过另一帧时，级别都会增加)。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e8c3" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论:</h1><p id="90c7" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">现在你有了它，一个用JavaScript和HTML5画布制作的基本的2D侧边滚动条！</p><p id="a201" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的主要目的是展示开始制作某种游戏是多么容易；当它经常看起来像一个相当令人生畏的基础学习时，仅仅为了进入游戏开发的世界就必须完成。</p><p id="f8d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">一些快速改进游戏的建议和后续步骤:</strong></p><ul class=""><li id="e229" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">在屏幕上添加一个指示器，通知玩家他们当前所处的“等级”。</li><li id="f2ae" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">添加一个<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Collision_detection" rel="noopener ugc nofollow" target="_blank">形式的碰撞检测</a>；所以玩家如果撞上一个或者一定数量的障碍物就会丢分或者直接失败。</li><li id="6538" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">优化新障碍的生成:<br/> -让新障碍的数量每两级增加一次，而不是每一级增加一个。<br/> -提高障碍物位置的随机性，限制它们聚集在一起的次数。</li><li id="8c77" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">添加一些音乐或其他效果，如灯光，以改善玩家的体验。</li></ul><p id="c80e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多方法可以定制和改进我们开发的游戏，如果你在这个项目中玩得开心(像我一样)，并且很想知道下一步会发生什么，你可以学习很多技术。</p><h2 id="84b6" class="nj lf iq bd lg np nq dn lk nr ns dp lo kj nt nu ls kn nv nw lw kr nx ny ma nz bi translated">感谢您的阅读！</h2></div></div>    
</body>
</html>