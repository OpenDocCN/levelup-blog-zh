<html>
<head>
<title>Internals of Protocol Buffers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协议缓冲区的内部</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/internals-of-protocol-buffers-bb87c59544a3?source=collection_archive---------1-----------------------#2020-10-17">https://levelup.gitconnected.com/internals-of-protocol-buffers-bb87c59544a3?source=collection_archive---------1-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="24bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着从单一应用程序开发到基于微服务的应用程序开发的快速过渡，微服务之间的通信已经成为至关重要的核心组件。我们需要某种公共语言模式，在这种模式下，所有依赖的微服务都应该能够进行通信，而不考虑编程语言。</p><p id="68e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都从XML开始，然后我们转向JSON (Javascript Object Notation ),它是一个键值对。JSON与REST配合得很好，并且仍然是微服务通信的首选。但是就像任何其他产品一样，它也有自己的起伏，当涉及到大规模操作时，JSON也有很多问题。由于本文不打算比较各种各样的数据交换格式，所以我将跳过这一步继续讨论。</p><p id="4213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到JSON引起的问题，开发了协议缓冲区，在本文中，我将讨论一些人们在使用协议缓冲区时犯的常见错误。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="d472" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设有两个微服务正在处理用户资料部分。一个是前端服务，一个是后端服务。</p><p id="c555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景</strong></p><p id="6b6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设该应用程序有3种不同的钱包，用户可以通过点击用户配置文件下的钱包部分来查看他/她的钱包余额。用户一点击检查钱包余额，前端就向后端发出一个网络调用来获取钱包余额。现在让我们比较JSON和proto请求格式。</p><p id="ff73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> JSON格式</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="0126" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">Request (can be a get with query params as well)</strong></span><span id="2908" class="lb lc iq kx b gy lh le l lf lg">URL: <a class="ae li" href="http://localhost:8080/getUserWallet" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/getUserWallet</a></span><span id="90cc" class="lb lc iq kx b gy lh le l lf lg">RequestType: POST</span><span id="adc0" class="lb lc iq kx b gy lh le l lf lg">{<br/>    "userID":"mouryavenkat"<br/>}</span><span id="75c8" class="lb lc iq kx b gy lh le l lf lg"><strong class="kx ir">Response</strong></span><span id="8faa" class="lb lc iq kx b gy lh le l lf lg">[<br/>    {<br/>        "walletType": "wallet1",<br/>        "walletAmount": 300,<br/>    },<br/>    {<br/>        "walletType": "wallet2",<br/>        "walletAmount": 200,<br/>    },<br/>    {<br/>        "walletType": "wallet1",<br/>        "walletAmount": 500,<br/>    }<br/>]</span></pre><p id="c154" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">原型格式</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="358c" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">Request </strong></span><span id="035e" class="lb lc iq kx b gy lh le l lf lg">RPC Method: GetUserWalletDetails</span><span id="060e" class="lb lc iq kx b gy lh le l lf lg">message UserWalletRequest {<br/>    string user_id = 1;<br/>}</span><span id="95c2" class="lb lc iq kx b gy lh le l lf lg"><strong class="kx ir">Response</strong></span><span id="4b45" class="lb lc iq kx b gy lh le l lf lg">message WalletInfo {<br/>    string wallet_type = 1;<br/>    int64 wallet_amount = 2;<br/>}</span><span id="1010" class="lb lc iq kx b gy lh le l lf lg">message UserWalletResponse {<br/>    repeated WalletInfo wallet_info = 1;<br/>}</span></pre><p id="4910" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原型请求和响应存储在客户端和服务端的. proto文件中。在前端，它根据需要填充所有数据，然后调用RPC方法，就像调用函数一样。然后，底层的GRPC客户端库将数据整理成二进制格式，并通过网络将数据传输到服务器，然后服务器的GRPC客户端库解编数据，并将其交给应用程序来处理请求，当服务器将钱包信息回复到前端时，将重复相同的过程。</p><p id="3426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里需要注意的非常重要的一点是编组和解组过程。我们给原型请求和响应中每个字段的编号在编组和解编请求-响应中起着关键作用。</p><p id="cf84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">编组过程</strong></p><figure class="ks kt ku kv gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lj"><img src="../Images/6126f9f32d183cb51587514687dffdbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4T3fp9EWSuWa-KEgmiGBw.jpeg"/></div></div></figure><p id="f6d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">响应包含多个数据块。到目前为止，在第1层，它只包含一个类型为repeated wallet_info的块。每个wallet_info包含2个子字段，钱包类型为序列1的字符串，钱包金额为序列2的整数类型。</p><p id="4a4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解组过程</strong></p><p id="3a32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在解组时，服务器接收它拥有的proto文件，而不是通过键名解组，它试图匹配客户机发送的序列顺序。</p><ul class=""><li id="df8c" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">它首先转到UserWalletResponse并获得序列1，这是重复的钱包信息。它首先检查服务器拥有的序列1的数据类型是否与客户机序列匹配。如果是，它会尝试深入挖掘，直到找到一个基本数据类型(int、double、string等)。</li><li id="2f5f" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">在我们的例子中，它找到一个wallet_info片段，进入每个wallet信息块，然后从1开始检查wallet_info的序列。</li><li id="441f" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">1是一个字符串，与服务器的协议相匹配。</li><li id="1c06" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">wallet_info中的2是int64，与服务器的proto相匹配。</li></ul><p id="2d55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于客户机发送的序列与服务器proto拥有的序列相匹配，所以它相应地填充请求数据，并将其传递给应用程序来处理请求。</p><p id="84cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们已经简要了解了解组的发生，现在让我们来看几个例子。</p><p id="94d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">情况1(客户机、服务器具有相同的序列，但字段名称不同)</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="6f69" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">Response Structure Client Has</strong></span><span id="3e8d" class="lb lc iq kx b gy lh le l lf lg">message WalletInfo {<br/>    string wallet_type = 1;<br/>    int64 wallet_amount = 2;<br/>}</span><span id="0693" class="lb lc iq kx b gy lh le l lf lg">message UserWalletResponse {<br/>    repeated WalletInfo wallet_info = 1;<br/>}</span><span id="d17f" class="lb lc iq kx b gy lh le l lf lg"><strong class="kx ir">Response Structure Server Has</strong></span><span id="4f95" class="lb lc iq kx b gy lh le l lf lg">message WalletInfo {<br/>    string <strong class="kx ir">type_of_wallet</strong> = 1;<br/>    int64 <strong class="kx ir">wallet_balance</strong> = 2;<br/>}</span><span id="7909" class="lb lc iq kx b gy lh le l lf lg">message UserWalletResponse {<br/>    repeated WalletInfo wallet_info = 1;<br/>}</span></pre><p id="bb0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果看到上面。原型文件客户端和服务器都有两个不同的原型，序列相同，但名称不同。如果是对于JSON，解组肯定会导致不稳定的行为，但是对于proto，由于序列和数据类型匹配，解组将会成功。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="f5ae" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">Server sends response as </strong></span><span id="c11d" class="lb lc iq kx b gy lh le l lf lg">WalletInfo {<br/>    <strong class="kx ir">type_of_wallet</strong> = "wallet1";<br/>    <strong class="kx ir">wallet_balance</strong> = 300;<br/>}</span><span id="7043" class="lb lc iq kx b gy lh le l lf lg"><strong class="kx ir">At client end it will be interpreted as </strong></span><span id="71e1" class="lb lc iq kx b gy lh le l lf lg">WalletInfo {<br/>    <strong class="kx ir">wallet_type</strong> = "wallet1";<br/>    <strong class="kx ir">wallet_amount</strong> = 300;<br/>}</span></pre><p id="6b57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">案例2(客户希望更改字段的数据类型)</strong></p><p id="5502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以到目前为止，我们将wallet_amount显示为一个整数值，而产品团队希望它显示为一个浮点值，四舍五入到小数点后两位数<strong class="jp ir">(例如:300.27)。</strong>为此，必须更新后端和前端契约，以发送和接收double(proto中的float64等价物)而不是integer。</p><p id="663e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在滚动升级和独立微服务部署的情况下，任何一项服务都必须首先上线。假设后端服务已经首先投入生产。原型现在朝这边看。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="fbdd" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">Response Structure Client Has</strong></span><span id="d126" class="lb lc iq kx b gy lh le l lf lg">message WalletInfo {<br/>    string wallet_type = 1;<br/>    int64 wallet_amount = 2;<br/>}</span><span id="d143" class="lb lc iq kx b gy lh le l lf lg">message UserWalletResponse {<br/>    repeated WalletInfo wallet_info = 1;<br/>}</span><span id="7822" class="lb lc iq kx b gy lh le l lf lg"><strong class="kx ir">Response Structure Server Has</strong></span><span id="629f" class="lb lc iq kx b gy lh le l lf lg">message WalletInfo {<br/>    string <strong class="kx ir">type_of_wallet</strong> = 1;<br/>    <strong class="kx ir"><em class="mf">double</em></strong> <strong class="kx ir">wallet_balance</strong> = 2;<br/>}</span><span id="f74a" class="lb lc iq kx b gy lh le l lf lg">message UserWalletResponse {<br/>    repeated WalletInfo wallet_info = 1;<br/>}</span></pre><p id="c16c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这一更改，wallet info中序列2的数据类型与客户端wallet info中的序列2不匹配，并且每当客户端库尝试解封响应时，都会导致错误。在客户机接受更新的更改之前，RPC调用一直在生产中中断。</p><p id="69c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:永远不要改变字段的数据类型，如果有任何需要，只需添加一个具有较新数据类型的新字段，并要求客户端使用新字段中的值。</strong></p><p id="7c39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应该是这样</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="30f7" class="lb lc iq kx b gy ld le l lf lg">message WalletInfo {<br/>    string <strong class="kx ir">type_of_wallet</strong> = 1;<br/>    //deprecated field<br/>    <strong class="kx ir"><em class="mf">int64</em></strong> <strong class="kx ir">wallet_balance</strong> = 2;<br/>    <strong class="kx ir"><em class="mf">double</em></strong> <strong class="kx ir">double_type_wallet_balance</strong> = 3;</span><span id="b6b5" class="lb lc iq kx b gy lh le l lf lg">}</span><span id="5b18" class="lb lc iq kx b gy lh le l lf lg">message UserWalletResponse {<br/>    repeated WalletInfo wallet_info = 1;<br/>}</span></pre><p id="15eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原型解组过程最好的部分是它只检查客户机拥有的序列号，如果服务器发送一些额外的数据，它将被忽略。因此，通过这种方式，服务器可以首先投入生产，而客户端可以提取最新的原型，进行所需的应用程序更改，然后投入生产。</p><p id="442e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在问题来了，我们能把废弃的字段重新用于其他用途吗？嗯，你可以，但是根据客户的理解，这可能会导致一些不稳定的结果。最好的方法是只增加序列，不要废弃序列。为了给不赞成使用的添加更多的含义，proto保留了一个名为<strong class="jp ir">的关键字</strong>。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="a1d5" class="lb lc iq kx b gy ld le l lf lg">message WalletInfo {<br/>    <strong class="kx ir">reserved 2;</strong><br/>    string <strong class="kx ir">type_of_wallet</strong> = 1;<br/>    <strong class="kx ir"><em class="mf">double</em></strong> <strong class="kx ir">double_type_wallet_balance</strong> = 3;</span><span id="8760" class="lb lc iq kx b gy lh le l lf lg">}</span><span id="dc71" class="lb lc iq kx b gy lh le l lf lg">message UserWalletResponse {<br/>    repeated WalletInfo wallet_info = 1;<br/>}</span></pre><p id="94a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个保留的关键字在某种程度上帮助了我们，没有人会错误地重用一个不推荐使用的序列号。</p><p id="dc39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">案例3(经典的字符串编组和解组问题。情况2的例外)</strong></p><p id="2eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑这样一种情况，用户试图更新他/她的详细信息，初始原型是这样的。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="b5bd" class="lb lc iq kx b gy ld le l lf lg">message UserDetails {<br/>    string first_name = 1;<br/>    string last_name = 2;<br/>    string phone_number = 3;<br/>}</span></pre><p id="26db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设客户机和服务器拥有相同的原型。现在，前端想到将phone_number更改为一个重复的字符串，其中用户可以添加他/她使用的所有手机号码。</p><p id="978b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在没有通知前端服务的情况下，后端将字段类型从<strong class="jp ir">字符串</strong>更新为<strong class="jp ir">重复的</strong> <strong class="jp ir">字符串。</strong></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="c0e2" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">Client Request Structure</strong></span><span id="171a" class="lb lc iq kx b gy lh le l lf lg">message UserDetails {<br/>    string first_name = 1;<br/>    string last_name = 2;<br/>    string phone_number = 3;<br/>}</span><span id="677d" class="lb lc iq kx b gy lh le l lf lg"><strong class="kx ir">Server Request Structure</strong></span><span id="6af3" class="lb lc iq kx b gy lh le l lf lg">message UserDetails {<br/>    string first_name = 1;<br/>    string last_name = 2;<br/>    repeated string phone_number = 3;<br/>}</span></pre><p id="7830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，当服务器试图解包请求时，这应该会失败，但这里不是这种情况。考虑下面的例子</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="60d0" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">Client Request</strong></span><span id="0014" class="lb lc iq kx b gy lh le l lf lg">UserDetails {<br/>    first_name = "mourya";<br/>    last_name = "venkat";<br/>    phone_number = "99493XXXXX";<br/>}</span><span id="34cf" class="lb lc iq kx b gy lh le l lf lg"><strong class="kx ir">Server Request</strong></span><span id="e64e" class="lb lc iq kx b gy lh le l lf lg">message UserDetails {<br/>    first_name = "mourya";<br/>    last_name = "venkat";<br/>    phone_number = ["9","9","4","9","3","X","X","X","X","X"];<br/>}</span></pre><p id="8273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，它试图通过按字符拆分字符串，将字符串转换为重复的字符串，而不是无法解编组。我不完全确定为什么要这样设计，但这是我在生产中遇到的边缘情况之一。</p></div></div>    
</body>
</html>