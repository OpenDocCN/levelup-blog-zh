<html>
<head>
<title>Firestore Objects to Swift Structs and Back, With Complex Types, Enums and Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firestore对象到Swift结构，以及复杂类型、枚举和数组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/firestore-to-swift-models-with-complex-types-enums-and-arrays-282893affb15?source=collection_archive---------1-----------------------#2020-07-31">https://levelup.gitconnected.com/firestore-to-swift-models-with-complex-types-enums-and-arrays-282893affb15?source=collection_archive---------1-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9ff37e22016e9a9e6556f9f2b424c499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KgGGek4THV98sYKoEPTiA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可编码结构</figcaption></figure><p id="d268" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们用Swift编写并使用SwiftUI的应用程序中，我们需要一种方法将我们的数据从Google Firestore读入应用程序，然后将一些数据写回Firestore。</p><p id="8edb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最初，我遵循Firestore文档中的指南,尽管它涉及到大量将字典键/值映射到我所需要的类型。写数据也差不多。对于我的Swift类中的每个属性，我必须指定相应Firestore字段的名称，然后为该字段分配适当的值。我知道一定有更好的方法。</p><p id="691b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，Firestore文档认识到了这个问题，并提供了一种方法来<a class="ae ld" href="https://firebase.google.com/docs/firestore/query-data/get-data#custom_objects" rel="noopener ugc nofollow" target="_blank">将您的文档放入一个Swift类</a>，并允许您像使用任何其他数据一样使用它。这是通过使用Pod <code class="fe le lf lg lh b">FirebaseFirestoreSwift</code>实现的，它向<code class="fe le lf lg lh b">document.data()</code>调用添加了一个扩展方法，因此您可以指定数据以什么类型进入。在<code class="fe le lf lg lh b">document.setData()</code>方法上也有一个<a class="ae ld" href="https://firebase.google.com/docs/firestore/manage-data/add-data#custom_objects" rel="noopener ugc nofollow" target="_blank">类似的方法</a>用于将你的Swift对象转换回Firestore对象。</p><p id="6dae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，我不确定在数据类型不是简单的字符串到字符串或数字到整数映射的情况下，这将如何工作。具体来说，有五种情况我不确定(按照从最简单到最复杂的顺序):</p><ol class=""><li id="d02d" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated">数组/列表</li><li id="fc38" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">复杂/自定义对象</li><li id="ba5a" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">字段名不匹配的地方</li><li id="c372" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">枚举</li><li id="f346" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">其他数据转换</li></ol><h1 id="f8a9" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">我如何将我的Swift对象转换为Firestore，反之亦然？</h1><p id="f478" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">最基本的例子是当你的对象只有简单的数据类型时。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一个简单的Firestore对象，带有一个字符串和一个数字</figcaption></figure><p id="2328" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">相应的Swift结构可能如下所示</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">带有一个字符串和一个整数的简单Swift结构</figcaption></figure><p id="0c84" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要让Firestore对象进入Swift，您需要使用<code class="fe le lf lg lh b">.data(as: &lt;type&gt;)</code>方法。在下面的场景中，我正在获取Firestore集合<code class="fe le lf lg lh b">websites</code>中的所有文档，并将它们放入名为<code class="fe le lf lg lh b">self.websites</code>的属性中</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">将Firestore数据引入Swift</figcaption></figure><p id="5b44" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">需要注意一些事情:</p><ul class=""><li id="53ea" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc nf lo lp lq bi translated">第12行是我调用<code class="fe le lf lg lh b">document.data(as: &lt;type&gt;)</code>方法的地方。我把我想转换成的文件类型传到这里。</li><li id="5207" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc nf lo lp lq bi translated">在第11行，我正在使用一个<code class="fe le lf lg lh b">flatMap</code>。这就像一个映射，它将数组中的每个对象转换成另一个对象。在本例中，我将每个文档(本质上是一个键/值对的字典)转换为我的网站结构。除非，如果结果返回nil(这种情况发生在无法将其转换为指定的结构时),它将从数组中移除该结果。<br/>一个等效的方法是首先在<code class="fe le lf lg lh b">documents</code>上应用一个过滤器来移除任何不能被转换成网站结构的项目。因为Firestore本身并不要求集合中的每个文档看起来都一样，所以有些文档可能无法转换为您指定的结构。</li></ul><p id="9b71" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还有一种相反的方法，其工作方式基本相同，只是将数据保存到Firestore。注意，我在这里只设置了一个文档。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3c2a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们看过的所有代码都还不能工作。我们遗漏了一个小成分。</p><p id="65e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要让Swift知道如何将文档(此时只是一个字典)转换成我们想要的结构。对于这个简单的例子，这真的很容易。我们只需要对我们的结构做三件事。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">网站结构，现在可编码和识别</figcaption></figure><ol class=""><li id="019f" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated">使我们的结构符合<code class="fe le lf lg lh b">Identifiable</code>。这要求它有一个id属性，我们将添加…</li><li id="9ac0" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">添加一个id属性并用<code class="fe le lf lg lh b">@DocumentID</code>进行注释。Firestore将在这里存储文档本身的id。这是必需的，对于将正确的文档保存回Firestore非常有用。</li><li id="8e20" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">使我们的结构符合<code class="fe le lf lg lh b">Codable</code>。这是Swift与我们的struct和Firestore相互转换的关键步骤。</li></ol><h2 id="7c35" class="ng lx it bd ly nh ni dn mc nj nk dp mg kq nl nm mk ku nn no mo ky np nq ms nr bi translated">可编码的</h2><p id="edd2" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">Codable是awesome协议(由两个协议组成:Decodable和Encodable ),它增加了两个关键功能:</p><ol class=""><li id="56c8" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated">init()方法，它允许我们从Firestore返回的字典中创建结构。这是解码器。</li><li id="5297" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">一种允许我们将结构转换回Firestore所期望的字典格式的方法。这是编码器。</li></ol><p id="aee6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些方法分别来自可解码和可编码协议。如果你有一个结构，你只需要从Firestore中检索，但从来没有保存回Firestore，你可以简单地遵循可解码的协议。</p><p id="f1e9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，Codable非常聪明，如果您有一个像我们这样的结构，其中只有简单的类型，如String、Int或Bool，这就是您需要做的所有事情。我们的代码现在可以工作了。</p><h1 id="b2de" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">1.如果我的对象有一个数组呢？</h1><p id="f659" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">幸运的是，数组和标准类型一样受支持。请参见下面的第5行。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">带有字符串数组的Swift结构</figcaption></figure><p id="e74f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将把Firestore中的字符串数组直接转换成Swift中的字符串数组。不需要额外的代码。</p><h1 id="a0f1" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">2.如果我的对象有自定义数据类型怎么办？</h1><p id="7ab8" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">一个常见的场景是支持您自己编写的自定义数据类型。例如，我的网站可以有一个作者，这是它自己的数据类型。让我们看看这在Firestore中是如何表现的。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8cc7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，在Swift中实现这一点也很简单。我们只需要定义另一个结构，包含我们在自定义数据类型中需要的字段。<strong class="kh iu">重要的是</strong>，这个<strong class="kh iu">也</strong>需要符合编码。事实上，只要每个结构都符合Codable，您就可以任意深度地嵌套自定义对象。让我们来看看实际情况:</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ac6f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如你所见，我在我们的<code class="fe le lf lg lh b">Website</code>结构中使用了自定义的<code class="fe le lf lg lh b">Author</code>类型。你会注意到<code class="fe le lf lg lh b">Author</code>不需要符合<code class="fe le lf lg lh b">Identifiable</code>，因为我们只跟踪一个作者，并且作者不是Firestore文档——它只是我们网站中的一个字段。</p><p id="697c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您也可以像创建字符串数组一样创建自定义对象数组。</p><h1 id="087a" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">3.如果我的Firestore对象与我的Swift struct相比具有不同的字段名称，该怎么办？</h1><p id="18d3" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">这是一种相当常见的情况，尤其是在更新Firestore数据库很困难的情况下，因为它已经包含数据，正在被您无法更新的其他客户端使用，或者只是因为您没有更新Firestore的权限。</p><p id="a94f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在第一种情况下，我会尽量保持字段名不变，即使只是为了你自己的理智。如果在你的Firestore中，你把某个东西称为“作者”,但在你的Swift代码中，你把相同的数据称为“人”,你可能会感到困惑。</p><p id="bc5c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是，如果您无法使它们保持同步，幸运的是，Codable协议允许您告诉Swift，对于某个特定的属性，Firebase的字典中的键将被称为其他的东西。这是通过定义一个名为<code class="fe le lf lg lh b">CodingKeys</code>的枚举来实现的。</p><p id="9768" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于我们的网站示例，在Firestore中，我们可能有一个名为<code class="fe le lf lg lh b">websiteDescription</code>的字段，但在Swift中，我们希望属性被称为<code class="fe le lf lg lh b">description</code>，因为我们知道它将描述网站。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们的网站结构，其中Swift中的域名与Firestore不匹配</figcaption></figure><p id="98a3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里你可以看到我正在定义名为<code class="fe le lf lg lh b">CodingKeys</code>的枚举。它符合协议<code class="fe le lf lg lh b">String</code>,因为我们的Firestore中的键/字段名都是字符串。如果由于某种原因，我们的字段名称是Firestore中的数字，我们将遵守<code class="fe le lf lg lh b">Int</code>协议。重要的是，我们还符合<code class="fe le lf lg lh b">CodingKey</code>协议，该协议让Swift知道这个枚举将在这个可编码结构中使用，以定义字段的名称。</p><p id="4d32" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，在<code class="fe le lf lg lh b">CodingKeys</code>枚举中，我们需要为我们使用的每个字段创建一个案例。不幸的是，我们不能只定义一个名称不匹配的字段，我们需要定义每一个字段。</p><p id="d744" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们到了不匹配的地方，我们需要做的就是给名字不匹配的地方一个字符串值。正如您在代码示例中看到的，我们希望Swift属性被称为<code class="fe le lf lg lh b">description</code>，但在Firestore中它被称为<code class="fe le lf lg lh b">websiteDescription</code>。所以，我已经把case <code class="fe le lf lg lh b">description</code>的字符串值设置为<code class="fe le lf lg lh b">websiteDescription</code>，就这样！完成了。</p><h1 id="6c68" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">4.如果我的对象有枚举怎么办？</h1><p id="4424" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">啊，艾努斯。这是我害怕的类型，也是我最初在Firestore方法中做自己的映射而不是依赖Codable的原因。但是，我实际上发现这并不太复杂。</p><p id="b59b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们回到网站的例子。我想要一个名为<code class="fe le lf lg lh b">typeOfWebsite</code>的枚举，值为<code class="fe le lf lg lh b">blog</code>、<code class="fe le lf lg lh b">app</code>和<code class="fe le lf lg lh b">forum</code>。Firestore实际上<a class="ae ld" href="https://firebase.google.com/docs/firestore/manage-data/data-types#data_types" rel="noopener ugc nofollow" target="_blank">支持相当多不同的数据类型</a>，但是它们都不是枚举，所以我将不得不把它们作为字符串存储在Firestore中。</p><p id="0aa3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我想做的是在解码Firestore对象时将我的字符串转换为enum，这样我就可以在我的Swift应用程序中使用typesafe enum，而不必依赖神奇的字符串。但是，当我在Firestore中对要保存的对象进行编码时，我需要它返回到一个字符串，这样它才能被保存。</p><p id="3134" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以自然地，正如我前面说过的，你的结构中的任何类型也需要是可编码的。因此，我需要使我的枚举符合Codable。</p><p id="9cdc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你的枚举使用<code class="fe le lf lg lh b">String</code>或<code class="fe le lf lg lh b">Int</code>作为它的原始值，它实际上可以符合Codable而不需要额外的工作。这里有一个例子:</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3a52" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为这些例子使用Int和String原始值，所以Swift能够编码和解码这些值。对于Int示例，Firestore会在文档中为blog保存数字0，为app保存数字1，为forum保存数字2。对于字符串示例，它实际上为博客保存了<code class="fe le lf lg lh b">blog</code>，为应用程序保存了<code class="fe le lf lg lh b">app</code>，为论坛保存了<code class="fe le lf lg lh b">forum</code>。对于90%的情况，这将工作得很好。</p><p id="0cdd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，我有一个稍微复杂一点的例子，Firestore中的enum值与我的enum的原始值不完全匹配。所以，我需要做的是实现我自己的编码器和解码器。</p><p id="1487" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请记住，您可以对任何数据类型这样做——不一定需要在枚举上。如果您需要对数据进行某种转换，而我已经描述过的特性并不支持这种转换，那么这是一种可行的方法。</p><p id="acf5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以，我的确切问题是一个第三方API把枚举值放入我的Firestore，它与我的枚举名称不完全匹配。回到我们网站的例子，尽管<code class="fe le lf lg lh b">blog</code>是我在Swift中定义的enum值，但是这个第三方API把它作为<code class="fe le lf lg lh b">Blog</code>放入。尽管这只是一个字母的大小写变化，但这破坏了编码和解码，所以我们需要编写自己的方法。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="67be" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里有相当多的东西需要解开。</p><ol class=""><li id="f03c" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated">首先，我在enum内部创建了两个方法，在字符串表示之间进行相互转换。</li><li id="5946" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">我创建了一个符合<code class="fe le lf lg lh b">Codable</code>的<code class="fe le lf lg lh b">WebsiteType</code>扩展。这是不必要的，您可以将这个扩展中的所有代码移动到enum中——我只是认为它很好地将enum与可编码实现分离开来。</li><li id="ba2b" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">如前所述，Codable实际上是两个协议，<code class="fe le lf lg lh b">Encodable</code>和<code class="fe le lf lg lh b">Decodable</code>。它们中的每一个都有一个方法，你可以用你自己的方法覆盖它，就像我在这里做的那样。所以…</li><li id="613c" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">在<strong class="kh iu">第40行</strong>我们有init方法。这个<strong class="kh iu">创建</strong>给定值的WebsiteType枚举。因此，在<strong class="kh iu">第41行和第42行</strong>上，我们获取值，作为一个字符串，然后在<strong class="kh iu">第43行</strong>上，我们获取该字符串，并将其传递给一个静态函数(因为enum尚未初始化，因为我们现在正在进行初始化)，这给了我们与字符串值相对应的enum。这是可解码的部分。</li><li id="11e8" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">在第<strong class="kh iu">行</strong> <strong class="kh iu"> 46 </strong>上，我们有一个将枚举转换回字符串的函数。在第<strong class="kh iu">行第48 </strong>行，我们使用<code class="fe le lf lg lh b">self.description</code>方法获取枚举的字符串表示，然后我们对它进行编码。注意<strong class="kh iu">第47行</strong>我们正在使用<code class="fe le lf lg lh b">singleValueContainer()</code>。这确保了当我们对枚举进行编码时，它输出一个值，比如<code class="fe le lf lg lh b">app</code>。<br/>我在网上看过的很多其他教程都把这个作为<code class="fe le lf lg lh b">container(keyedBy: CodingKey.self)</code>，然后他们像<code class="fe le lf lg lh b">container.encode(self.description, keyBy: .rawValue)</code>一样把这个值编码。这是可行的，但是输出了一个对象中的枚举，比如:<code class="fe le lf lg lh b">{rawValue: "app"}</code>。</li></ol><p id="ccae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！</p><h1 id="8a6a" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">5.如果我需要做一些其他类型的数据转换呢？</h1><p id="703b" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">好问题。实际上，你已经拥有了继续做这件事所需的所有工具。与我为<code class="fe le lf lg lh b">WebsiteType</code> enum创建自定义编码器和解码器的方式相同，您实际上可以为任何符合Codable的<em class="ns">对象创建自己的编码和解码函数。</em></p><p id="ffcd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一些你可以做的事情的例子:</p><ul class=""><li id="1365" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc nf lo lp lq bi translated">仅获取数组的第一个值</li><li id="c4bc" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc nf lo lp lq bi translated">移除不需要的额外属性(在任一方向上)</li><li id="ef67" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc nf lo lp lq bi translated">更改字符串值的大小写</li><li id="14a4" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc nf lo lp lq bi translated">将int转换成Floats</li><li id="212f" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc nf lo lp lq bi translated">更改日期时区</li></ul><p id="11ba" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为可以自己写函数，机会是无限的。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="8628" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">希望这篇文章对你的快速旅程有用。在我们的应用中，我们基本上使用Firestore和Firebase功能作为我们的逻辑层，尽管有原生的Android和iOS应用，但这真的感觉像一个跨平台的应用，因为它们共享相同的数据API。</p><p id="b1a9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦您的数据类型符合Codable，读取和保存数据就是一件轻而易举的事情，我建议您不要做任何手动映射。现在，您需要做的就是读入对象，更新一个值，然后再次保存它。这可能会占用大约3行代码，如果您必须使用API或通过ORM，这将花费更多的时间。Codable也可以用于JSON解码/编码，因此本故事中的经验并不局限于Firestore中的用法。</p></div></div>    
</body>
</html>