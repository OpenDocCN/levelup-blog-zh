# VueJS，组合 API & Firebase 认证

> 原文：<https://levelup.gitconnected.com/vuejs-the-composition-api-firebase-authentication-a5b9f5823e31>

![](img/4cac64cce48db82e1ed5c7cb93fae99e.png)

照片由[克里斯蒂安·威迪格](https://unsplash.com/@christianw?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

作为 web 应用程序的创建者，您可能最终需要某种形式的身份验证。

开发一个成熟的认证系统，包括电子邮件验证和忘记密码系统，很难做好，更难证明其安全性。

另一种选择是选择“现成的”身份提供商，虽然他们可以提供您开箱所需的一切，但很快就会变得昂贵，因此对于较小的项目来说不可行。

谷歌的 Firebase 认证是一个例外。

[Firebase Auth](https://firebase.google.com/products/auth) 允许你连接到社交提供商以及电子邮件/密码验证，并且默认带有电子邮件验证和忘记密码流。不仅如此，它还可以免费使用！(当然在一定程度上)。

我应该指出，其他身份提供商，如 Auth0 和 Okta，提供免费的定价。然而，我发现 Firebase 身份验证要快得多，也更容易上手。更不用说它与 Firestore DB 的集成有多好，允许我利用一个提供商进行身份验证和数据库，而且全部免费！

所以没有任何进一步的序言。让我们看看如何将它与 VueJS 集成在一起。

我们将使用 Vue3、复合 API 和 Vue 路由器，所以我假设你知道它们，并且已经有一个从 Vue CLI 搭建的应用程序。

如果你不熟悉组合 API，请随意阅读我的文章。

# 添加 Firebase SDK

从一个简单的开始…

`yarn add firebase`

然后，在`src/components`中新建一个名为“auth”的文件夹。在这里，我们将存储所有与身份验证相关的文件和组件。

# 初始化组合 API 数据

在新的“auth”文件夹的根目录下创建`index.js`:

我们首先从`firebase/app`和`firebase/auth`进口火碱。我们可以只调用`import firebase from "firebase"`，但是，这会导致导入整个*firebase SDK。更好的方法是捆绑 size 来导入核心(从“firebase/auth”)然后通过导入单独的模块添加到 firebase“名称空间”中。*

然后，我们分配 firebase 配置(这里是从环境变量)。值得注意的是，firebase 配置不是一个“秘密”。任何访问该网站的人都可以找到您的配置信息。也就是说，为了多种环境(本地、生产等),保留环境变量仍然是值得的。).

然后，我们创建一个用户 ref，在这里我们将存储我们登录的用户，并为`onAuthStateChanged`设置一个监听器，以便当有人登录或退出时，我们可以将它分配给用户 ref。

# 与 Vue 组件集成

有了所有的功能，我们现在需要组件来使用它们。

## 注册组件

将以下内容添加到合成 API 文件中:

这个函数初始化数据，我们需要一个注册表格(电子邮件和密码)和一个功能，我们可以在提交时执行。所有这些都封装在一个`useSignup`函数中，这样数据在每次使用时都会被初始化。这防止了使用在应用程序的整个生命周期中不必要地初始化的“全局”状态。

接下来，我们将创建注册组件:

这里，我们设置了一个基本表单，其中有几个电子邮件和密码输入。

由于组合 API 的强大，我们可以直接从`useSignup`调用中传递引用值，以及注册方法本身。这将组件本身的功能保持在最低限度，组件只负责处理注册后重定向。

我们还从复合文件中返回“google”函数，允许一个按钮启动弹出认证流。

## 登录组件

接下来，是登录组件的时候了。

将以下内容添加到合成 API 文件中:

我们用与注册相同的方式设置登录功能:表单的数据引用和通过该数据登录的功能。

然后，我们创建组件本身:

注意这个组件和注册组件是多么的相似。我们导入所有需要的内容，并将`useLogin`的元素传递到模板中，以便在组件上使用。

# 保护应用程序

![](img/73ba9652d73e930f29f0ec3c5ec66bda.png)

照片由[尼哈尔·沙阿](https://unsplash.com/@nihal_1312?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

最后，我们需要确保任何受保护的路由在未登录时都是不可访问的。

假设路由文件类似于:

我们需要的是一个每当我们开始导航到一条路线时执行的功能，检查用户，然后根据需要指引他们。

为此，我们使用“beforeEach”路由保护:

简单地说，这个函数检查用户引用是否有值，如果没有，就引导用户登录。

注意到瑕疵了吗？我们将进入一个无限循环，不断尝试登录路径！为了避免这种情况，我们可以使用路由元数据来避免“公共”路由。

为此，请按如下方式更改路由器文件:

关于如何工作的更多信息，请查看 [Vue 路由器](https://router.vuejs.org/guide/advanced/meta.html)文档。你会注意到他们颠倒了逻辑，使用`requiresAuth`而不是`public`。然而，我更喜欢默认锁定路线，并打开我想要的路线。

向右排序？不对！我们还有最后一个问题:在身份验证初始化之前导航到路由。

我们第一次点击一条路线，`user.value`将*总是*为空，因为 Firebase 还没有机会完全初始化。这意味着用户将总是被重定向登录，即使他们已经过完全身份验证。

为了解决这个问题，我们必须等待 Firebase API 初始化。

我们通过两次编辑来实现这一点，一次是对身份验证组合 API 文件的编辑，另一次是对 route guard 的编辑。

首先，我们更新合成 API 文件:

我们导出一个名为`initialised`的新引用，它最初被设置为 false。然后，当我们得到一个 auth 状态更改时，我们将其设置为 true。一旦 API 被初始化，Firebase 总是会触发一个`onAuthStateChanged`事件。如果用户未经身份验证，则使用一个`null`参数，如果用户经过身份验证，则使用一个用户对象。

然后，我们需要在 route guard 中监视这个值:

这看起来有点复杂，但是它做的很简单。

首先，它检查验证是否已经初始化。如果是，那么我们继续进行其余的身份验证检查。

如果不是…我们在初始化时设置一个监视器，等待它变成真的。一旦它是，我们继续像以前一样。

# 最后

因此，在这一切之后，我们有了一个有效的认证流程，由 Google 免费处理。我们有公开可访问的路由，可以防止用户访问应用程序，直到认证服务初始化。

值得注意的是，有很多东西我还没有涉及到；例如错误处理(用户存在，密码不匹配的复杂性等。)、加载栏和一般 UX 改进，您应该 100%地为全功能身份验证流程实现这些功能。但这能让你继续前进。

您还可以在 [GitHub repo](https://github.com/mlawd/blog-demos/tree/main/vuejs-firebase) 中查看完整的工作源代码。