<html>
<head>
<title>React: How I learned to create optimized contexts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:我如何学会创建优化的上下文</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-how-i-learned-to-create-optimized-contexts-e121dc232a95?source=collection_archive---------3-----------------------#2020-11-09">https://levelup.gitconnected.com/react-how-i-learned-to-create-optimized-contexts-e121dc232a95?source=collection_archive---------3-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c72d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">…别再担心炸弹了。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bcc7b903c432c0e427d5f385396e5793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KKxqaOa0k6YCfrx_"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">为什么大家都一直在说语境…？</figcaption></figure><h1 id="3125" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">一点…嗯，上下文🤭</h1><p id="69af" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp ir">注意:如果你想直接潜水，跳过这一部分。</strong></p><p id="0e4d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://reactjs.org/docs/context.html#when-to-use-context" rel="noopener ugc nofollow" target="_blank"> React contexts </a>是一个非常酷的特性，并且<em class="mp">非常实用于hooks API。你肯定遇到过一些人，而且可能会马上认出他们。</em></p><p id="94fc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">今天我想分享我在创建自己的React上下文时学到的东西:<strong class="lp ir">我认为什么是好的上下文</strong>和<strong class="lp ir">如何编写一个</strong>。</p><p id="3147" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我想稍后分享的另一个探索不会出现在这篇文章中:如何以及何时将一个上下文分割成2个或更多。</p><h1 id="c782" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">让我们潜水吧</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/9ba383e4e9d9e1b1aeeec0a7a1913a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/0*uRSo2l07OMnGkzTA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">超级跳水</figcaption></figure><p id="ba5e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们以一个<code class="fe mr ms mt mu b">Theme</code>上下文为例，它提供了一个<code class="fe mr ms mt mu b">mode: 'dark' or 'light'</code>和一个<code class="fe mr ms mt mu b">compact</code>布尔值来指示UI是否应该减少边距和填充。</p><h2 id="0998" class="mv kw iq bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">第一种方法</h2><p id="db27" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">基本上，我会使用React <code class="fe mr ms mt mu b">createContext</code>创建一个上下文，然后导出它，这样就可以了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1b14" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您可以使用<code class="fe mr ms mt mu b">useContext</code>钩子或消费者组件来消费这个上下文，如下所示:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="969b" class="mv kw iq mu b gy nn no l np nq"><strong class="mu ir">const</strong> theme = useContext(ThemeContext)<br/>// or<br/>&lt;ThemeContext.Consumer&gt;<br/>  <strong class="mu ir">{</strong>(theme) =&gt; …<strong class="mu ir">}</strong><br/>&lt;/ThemeContext.Consumer&gt;</span></pre><p id="2458" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">好吧，但是这很不安全。</p><p id="265d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您是否注意到回退值如何为<code class="fe mr ms mt mu b">setMode</code>和<code class="fe mr ms mt mu b">setCompact</code>提供无操作功能？这是因为我们不能确定一个提供者被声明在组件树的上层。</p><p id="50c4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">另外，哪个组件将负责为<strong class="lp ir">提供值？</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/391a626b0eb67cc7fbab8f2cbd49adc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*DesJxi7NLIvPm1Y0.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">…</figcaption></figure><h2 id="099e" class="mv kw iq bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">我认为是一个好的背景</h2><p id="5d7e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对我来说，一个好的上下文应该:</p><ul class=""><li id="fed2" class="ns nt iq lp b lq mj lt mk lw nu ma nv me nw mi nx ny nz oa bi translated">容易维护吗<strong class="lp ir"/>(你通常不单独工作，是吗？即使你做了，你也是在和过去和未来的自己一起工作🤐)</li><li id="d2d3" class="ns nt iq lp b lq ob lt oc lw od ma oe me of mi nx ny nz oa bi translated"><strong class="lp ir">快速</strong>失效，以防有人忘记<strong class="lp ir">提供</strong>一个值。快速失败可以防止无声的错误，这种错误很难被发现。</li><li id="5f1d" class="ns nt iq lp b lq ob lt oc lw od ma oe me of mi nx ny nz oa bi translated"><strong class="lp ir">嵌入其</strong>自己的<strong class="lp ir">逻辑</strong>——不要将该逻辑留给不对其负责的组件。</li><li id="137f" class="ns nt iq lp b lq ob lt oc lw od ma oe me of mi nx ny nz oa bi translated">仅在必要时使其消费者<strong class="lp ir">重新呈现</strong></li></ul></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="61bf" class="kv kw iq bd kx ky on la lb lc oo le lf jw op jx lh jz oq ka lj kc or kd ll lm bi translated">如何写好语境</h1><h2 id="0b5e" class="mv kw iq bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">建筑/骨架🏚</h2><blockquote class="os ot ou"><p id="f502" class="ln lo mp lp b lq mj jr ls lt mk ju lv ov ml ly lz ow mm mc md ox mn mg mh mi ij bi translated">事先说明:以下是自以为是，绝对不是<em class="iq"/><em class="iq">只有</em> <em class="iq">可行的写作方式</em>反应上下文。我也很高兴听到你的。</p></blockquote><p id="f92e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们不会直接导出不安全的上下文。相反，我们将导出3个包装器来保护它:</p><ul class=""><li id="afa0" class="ns nt iq lp b lq mj lt mk lw nu ma nv me nw mi nx ny nz oa bi translated">一个<strong class="lp ir">提供者</strong>组件——T0——它将嵌入自己的逻辑，而不是把它委托给天知道的地方。</li><li id="c731" class="ns nt iq lp b lq ob lt oc lw od ma oe me of mi nx ny nz oa bi translated">一个<strong class="lp ir">钩子</strong>，为了消耗上下文值<code class="fe mr ms mt mu b">useTheme()</code>，它将断言该上下文已经被提供了一个值。</li><li id="f786" class="ns nt iq lp b lq ob lt oc lw od ma oe me of mi nx ny nz oa bi translated"><em class="mp">如果需要的话</em> : <strong class="lp ir"> </strong>一个<strong class="lp ir">消费者</strong>组件——与钩子相同，它将断言上下文已经被提供了一个值。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="1a98" class="mv kw iq bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">消费者:断言所提供的价值</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/f3c220aa8dbe0b09fbf16fc8ef66c46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/0*wmuK-WguEjHTnqxW.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">嗯，没有。</figcaption></figure><p id="e050" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了断言上下文值，我们将在这里添加一个任意回退值<code class="fe mr ms mt mu b">null</code>，但它可以是任意值，并且消费者<code class="fe mr ms mt mu b">useTheme</code>和<code class="fe mr ms mt mu b">ThemeConsumer</code>将<em class="mp">断言</em>上下文值<em class="mp">不是<em class="mp">回退值</em>。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">控制狂消费者</figcaption></figure><h2 id="10f7" class="mv kw iq bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">提供商:避免不必要的重新渲染</h2><p id="e86d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">坚持住，这是🥵.的最后一英里下面是基本但效率低下的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">效率低下的供应商效率低下。</figcaption></figure><p id="d2aa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你会问“为什么效率低”？很高兴你问:因为<code class="fe mr ms mt mu b">value</code>！</p><p id="a360" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当<code class="fe mr ms mt mu b">ThemeProvider</code>的父级重新渲染时，<strong class="lp ir"> </strong> <code class="fe mr ms mt mu b">ThemeProvider</code>也会重新渲染，这将<em class="mp">重新创建值</em>，从而<strong class="lp ir"> <em class="mp">改变其引用</em> </strong>。<br/>然后，React会检测到一个上下文值的变化，<strong class="lp ir">每个消费我们主题的组件都会更新！顺便说一下，请记住这适用于任何JavaScript对象:数组、映射、集合等等……(我制作了一个<a class="ae mo" href="https://codesandbox.io/s/react-context-ximn2" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>来演示这个小故障)。</strong></p><p id="05c6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了解决这个问题，我们应该用<code class="fe mr ms mt mu b">useMemo</code> <a class="ae mo" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">钩子</a>来记忆这个值，以防止引用的改变，这样就可以了。</p><blockquote class="os ot ou"><p id="82ce" class="ln lo mp lp b lq mj jr ls lt mk ju lv ov ml ly lz ow mm mc md ox mn mg mh mi ij bi translated">注意1:大多数上下文将出现在你的app⋅s的根目录下，这意味着它们没有任何可以重新渲染的父节点。尽管如此，当编写一个上下文提供者时，提供者不能预先知道<em class="iq">在<em class="iq">树</em>中的</em>将被使用。因此，你应该<strong class="lp ir">始终</strong>优化你的提供商。</p><p id="f74e" class="ln lo mp lp b lq mj jr ls lt mk ju lv ov ml ly lz ow mm mc md ox mn mg mh mi ij bi translated">注意2:在我的实验中，有人建议我将提供者组件包装在一个<code class="fe mr ms mt mu b">React.memo</code> HOC中。那是一个好主意，不幸的是它不起作用。所以不要。自己试试<a class="ae mo" href="https://codesandbox.io/s/react-context-ximn2?file=/src/contexts/Auth.tsx:586-628" rel="noopener ugc nofollow" target="_blank">这里(codesandbox) </a>。</p><p id="a136" class="ln lo mp lp b lq mj jr ls lt mk ju lv ov ml ly lz ow mm mc md ox mn mg mh mi ij bi translated">注3:代替<code class="fe mr ms mt mu b">useMemo</code>，你也可以使用一个分组状态，比如:<br/> <code class="fe mr ms mt mu b"><strong class="lp ir">const</strong> [theme, setTheme] = useState({ mode: 'dark', compact: <strong class="lp ir">false</strong> })</code></p><p id="46b6" class="ln lo mp lp b lq mj jr ls lt mk ju lv ov ml ly lz ow mm mc md ox mn mg mh mi ij bi translated">注意4:也有可能使用<code class="fe mr ms mt mu b">useReducer</code>钩子来管理状态，但是我感觉这个钩子只有redux-users才能理解，所以我不习惯在团队项目中使用它。</p></blockquote><h1 id="3b03" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">包装🧐</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/cca5b89bac18f9e4d66949aa13e0ec23.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/0*O5JPMKDs6J3US1mW.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">您的下一次潜水将使用React上下文🤓</figcaption></figure><ul class=""><li id="d670" class="ns nt iq lp b lq mj lt mk lw nu ma nv me nw mi nx ny nz oa bi translated"><strong class="lp ir">架构</strong> <code class="fe mr ms mt mu b">Provider + hook (+ Consumer)</code>确保了<strong class="lp ir">可读性</strong>(因此可维护性<strong class="lp ir">)并且</strong>将<strong class="lp ir">逻辑嵌入到一个地方，</strong>减少了我们的错误来源。</li><li id="818e" class="ns nt iq lp b lq ob lt oc lw od ma oe me of mi nx ny nz oa bi translated"><strong class="lp ir">钩子</strong>(和消费者组件)实现了<strong class="lp ir">快速失效策略</strong>，以避免无声错误和绝望的调试会话。</li><li id="e5c6" class="ns nt iq lp b lq ob lt oc lw od ma oe me of mi nx ny nz oa bi translated"><strong class="lp ir">提供者</strong>组件被<strong class="lp ir">优化</strong>以<strong class="lp ir">避免</strong>不必要的<strong class="lp ir">重新呈现其消费者的</strong>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">最后一瞥💅</figcaption></figure><p id="456e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">就是这样！我希望它能对你的上下文之旅有所帮助，现在代码安全，回头见😇。</p><p id="dae5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">仅供参考:这里有一个代码沙箱<a class="ae mo" href="https://codesandbox.io/s/react-context-ximn2" rel="noopener ugc nofollow" target="_blank"/>，如果你想玩上下文的话，在最后🤪。</p><p id="62c7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所以下次再见，哦。等等。我认为我们可以做得更多😏。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="0070" class="kv kw iq bd kx ky on la lb lc oo le lf jw op jx lh jz oq ka lj kc or kd ll lm bi translated">更进一步😤</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/eac19352985a9013c1da6c585c076d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*XKjz2c6MJ2HBG3etyJdusg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">🙇 🙇‍♂️ 🙇‍♀️</figcaption></figure><p id="44d9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你没想到会有这一天？我们可以抽象出两种重复的逻辑:</p><ul class=""><li id="2837" class="ns nt iq lp b lq mj lt mk lw nu ma nv me nw mi nx ny nz oa bi translated">使用唯一且可识别的默认值创建上下文。</li><li id="27bd" class="ns nt iq lp b lq ob lt oc lw od ma oe me of mi nx ny nz oa bi translated">创建消费者——钩子和组件——当找到默认值时抛出。</li></ul><p id="4131" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于默认值，因为<code class="fe mr ms mt mu b">null</code>值<em class="mp">可能会在某一天的上下文中使用</em>(并且因为我们不知道未来会发生什么🔮)，我们必须找到另一个唯一可识别的默认值。JavaScript有完美的数据类型:<code class="fe mr ms mt mu b"><a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">Symbol</a></code>。</p><blockquote class="os ot ou"><p id="af1c" class="ln lo mp lp b lq mj jr ls lt mk ju lv ov ml ly lz ow mm mc md ox mn mg mh mi ij bi translated">编者按:我现在就像一个孩子…我知道这是一个奇怪的梦，但我认真地梦想有一天使用一个具有适当用例的JavaScript符号…这一天已经到来了！<em class="iq"> 🥳🤓</em></p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">现在我完成了。真的。不是开玩笑。</figcaption></figure><p id="6bc2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">给你，把这个GIF作为走了这么远的奖励😎</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/edb50afd604dda70c1c07017280b491c.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/0*77uZI8GFxHCpRZs5.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">恭喜你。</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/20e6f9ec5f980cae7380927c892294ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/0*2QzSu-XVn-R_i3mM.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">你，下一次一个上下文困扰你。</figcaption></figure></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="6e42" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">承诺的codesandbox😊</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pc ni l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">🦄</figcaption></figure></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="bf33" class="kv kw iq bd kx ky on la lb lc oo le lf jw op jx lh jz oq ka lj kc or kd ll lm bi translated">分级编码</h1><p id="e22f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">感谢您成为我们社区的一员！<a class="ae mo" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae mo" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> Skilled.dev编码面试课程</strong> </a>。</p><div class="pd pe gp gr pf pg"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd ir gy z fp pl fr fs pm fu fw ip bi translated">编写面试问题+获得开发工作</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">掌握编码面试的过程</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">技术开发</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu kp pg"/></div></div></a></div></div></div>    
</body>
</html>