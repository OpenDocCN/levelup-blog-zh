<html>
<head>
<title>How to build an AWS Lambda CI Pipeline with Goss and TravisCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Goss和TravisCI构建AWS Lambda CI管道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-an-aws-lambda-ci-pipeline-with-goss-and-travisci-4928874b218e?source=collection_archive---------10-----------------------#2020-05-20">https://levelup.gitconnected.com/how-to-build-an-aws-lambda-ci-pipeline-with-goss-and-travisci-4928874b218e?source=collection_archive---------10-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fc87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">开发、构建和测试您的Lambda函数，而无需实际进入AWS云！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b398aad92b2f0c38210a486178ed39d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3Yv_GuiGq99-nkdLWyZRA.jpeg"/></div></div></figure><p id="ea45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从用于开发示例Lambda函数的Python环境开始，<strong class="js iu">让我们看看如何创建一个持续集成管道</strong>，它处理对每个新提交的测试。我们将使用<strong class="js iu"> <em class="la"> Goss </em> </strong>作为测试工具，使用<strong class="js iu"> <em class="la"> TravisCI </em> </strong>来实现CI管道。</p><h1 id="621d" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Docker容器中的AWS Lambda</h1><p id="e0d2" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">让我们快速看看如何在基于<a class="ae me" href="https://hub.docker.com/r/lambci/lambda/" rel="noopener ugc nofollow" target="_blank"> LambdaCI </a> Docker图像的容器中运行AWS Lambda函数。</p><p id="525d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用下面的Python函数，它处理在SQS上排队的消息，并且需要一个通常不安装在默认Lambda环境中的包(PILLOW)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8381" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了创建执行Lambda函数所需的Docker映像，这个<strong class="js iu"> <em class="la"> Dockerfile </em> </strong>从映像<strong class="js iu"> <em class="la">开始/lambda:python3.6 </em> </strong>并安装<strong class="js iu"><em class="la">requirements . txt</em></strong>中提供的任何附加python包</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="c3db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多详情请查看<a class="ae me" href="https://www.vittorionardone.it/en/2020/05/12/aws-lambda-offline-development-with-docker/" rel="noopener ugc nofollow" target="_blank">这篇帖子</a>；现在我们有了Docker映像，Lambda函数在容器中正确运行。我们已经准备好开始构建测试套件。</p><h1 id="79fa" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">戈斯和德戈斯</h1><p id="d8b6" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我选择使用<a class="ae me" href="https://goss.rocks/" rel="noopener ugc nofollow" target="_blank"> Goss </a>作为测试工具主要是因为这些原因:由于包装器DGoss，在测试的执行阶段和开发(或编辑)期间，可以直接与docker容器交互。Goss的主要目的是验证服务器的配置，在我们的例子中，服务器就是运行Lambda函数的容器。测试套件可以直接从服务器(或容器)的当前状态生成，使得操作非常快速和实用。</p><p id="1f12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">测试套件由YAML文件定义。</p><p id="f902" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续进行Goss和DGoss 的<a class="ae me" href="https://github.com/aelsabbahy/goss" rel="noopener ugc nofollow" target="_blank">安装。我们现在已经准备好启动允许我们创建测试套件的容器了。为此，我喜欢使用Makefile。</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="cc5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个命令以“保持打开”模式启动容器docker:API服务器监听端口9001，我们的Lambda函数回复HTTP请求。使用DGoss参数<strong class="js iu"> <em class="la"> edit </em> </strong>是因为我们要运行容器来创建测试套件。<strong class="js iu"> <em class="la">测试</em> </strong>目录的目的是收集运行测试所需的文件。例如，如果我们想通过lambda验证SQS消息处理，一些样本事件(以JSON格式)将被保存在这个文件夹中，以便在测试期间使用。</p><p id="b048" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，可以使用任何Goss命令来创建我们的测试套件:例如，如果我们想要验证函数处理程序文件的存在，要使用的命令是:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="5e62" class="mm lc it mi b gy mn mo l mp mq">goss add file /var/task/src/lambda_function.py</span></pre><p id="14ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该选项向配置文件添加了一个新的测试，在我们的例子中是检查指定文件的存在。Goss允许检查运行环境的许多配置参数，例如文件、包、进程、DNS解析等的存在。<a class="ae me" href="https://github.com/aelsabbahy/goss/blob/master/docs/manual.md" rel="noopener ugc nofollow" target="_blank">参考手册</a>非常详尽。</p><p id="f9c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们创建一个脚本来验证Lambda函数的响应。</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="c002" class="mm lc it mi b gy mn mo l mp mq">#!/bin/sh<br/># /var/task/test/test-script.sh</span><span id="790b" class="mm lc it mi b gy mr mo l mp mq">curl --data-binary "@/var/task/test/test-event.json" <a class="ae me" href="http://localhost:9001/2015-03-31/functions/myfunction/invocations" rel="noopener ugc nofollow" target="_blank">http://localhost:9001/2015-03-31/functions/myfunction/invocations</a></span></pre><p id="b883" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="la"> Curl </em> </strong>用于查询Lambda端点发送测试SQS事件(文件<strong class="js iu"> test-event.json </strong>)。所以让我们添加另一个Goss测试，这次是键入<strong class="js iu"> <em class="la">命令</em> </strong>。<strong class="js iu"> <em class="la"> goss.yaml </em> </strong>文件将变成如下所示。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="545e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="la">命令</em> </strong>部分包括查询Lambda函数的脚本的执行。我们期望在<strong class="js iu"> <em class="la"> stdout </em> </strong>上有一个特定内容的JSON，确认函数的正确执行。当然，这个测试只是用Goss可以做什么的一个示例。</p><p id="a08b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当从容器中退出时，DGoss负责将新编辑的文件<strong class="js iu"> <em class="la"> goss.yaml </em> </strong>复制到我们的localhost，这样它在删除容器本身后仍然存在。通过再次启动编辑过程，相同的文件被复制到新的容器中，并在最后再次同步。</p><p id="da60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考试时间！代替<strong class="js iu"> <em class="la">编辑</em> </strong>，我们将使用DGoss <strong class="js iu"> <em class="la">运行</em> </strong>命令。同样，Makefile:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6c05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DGoss创建一个新的容器并运行测试套件。这里有一个例子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/98a223e9809c8bab31620ea0813fda5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4P5ntdhOO-YhODNdm8cqaw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">数据运行</figcaption></figure><p id="2a2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！我们的测试套件已经准备好了，让我们继续将它集成到我们的CI管道中。</p><h1 id="13ff" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带TravisCI的AWS Lambda CI</h1><p id="7b42" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">是时候配置CI管道了。我选择<a class="ae me" href="https://travis-ci.com/" rel="noopener ugc nofollow" target="_blank"> TravisCI </a>是因为它的简单性，因为它允许我们在任何计划中构建docker映像。我也在这篇文章和<a class="ae me" href="https://www.ansible.com/" rel="noopener ugc nofollow" target="_blank"> Ansible </a>中使用了它<a class="ae me" href="https://www.vittorionardone.it/en/2020/02/11/travisci-pipeline-to-test-ansible-roles-with-molecule-on-aws-ec2/" rel="noopener ugc nofollow" target="_blank">，它是我更喜欢的CI工具。为了在每次提交时自动化测试过程，TravisCI被配置为监控托管源代码的GitHub / Bitbucket存储库。</a></p><p id="2014" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个简单的文件<strong class="js iu"> <em class="la"> .travis.yaml </em> </strong>定义了管道。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="215c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来分析一下:<strong class="js iu"> <em class="la"> services </em> </strong>指令指示TravisCI使用<strong class="js iu"> <em class="la"> docker </em> </strong>服务。在开始测试之前，按照<strong class="js iu"> <em class="la">安装</em> </strong>之前的说明，安装Goss ad DGoss并构建AWS Lambda映像。最后<strong class="js iu"> <em class="la">脚本</em> </strong>表示有效执行我们之前准备好的测试套件的命令。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/d2f546b7375a2bc158129cb99c8fa9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkdI_yDAnHHDwZspxdLMpQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">管道执行示例</figcaption></figure><p id="6df7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！我们的管道完工了！</p><h1 id="297c" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a555479214a0c2ff10064f11ae9c82b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*UD3Lxw3JbGgnADpUK2qEcw.png"/></div></figure><p id="f5ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经自动化了一个简单的AWS Lambda函数的构建和测试过程，而不需要它真正进入AWS云。我已经在许多项目中使用了这个环境，我相信它允许我们显著地加速开发，允许我们在AWS上部署经过测试的高质量代码。</p><p id="383d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个GitHub存储库收集了本文中讨论过的内容，它可以作为用Goss构建自己的CI管道的起点。</p><p id="f377" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们玩得开心吗？下次见！</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="73c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la">原载于2020年5月20日</em><a class="ae me" href="https://www.vittorionardone.it/en/2020/05/20/build-aws-lambda-ci-pipeline-with-goss-and-travisci/" rel="noopener ugc nofollow" target="_blank"><em class="la">https://www . vittorionardone . it</em></a><em class="la">。</em></p></div></div>    
</body>
</html>