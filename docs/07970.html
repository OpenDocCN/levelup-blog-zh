<html>
<head>
<title>Optimize Your Daily Workflow, First!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">首先，优化你的日常工作流程！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimize-your-daily-workflow-first-1e55e1b8985b?source=collection_archive---------5-----------------------#2021-03-25">https://levelup.gitconnected.com/optimize-your-daily-workflow-first-1e55e1b8985b?source=collection_archive---------5-----------------------#2021-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d931" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">细节很重要。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7424685983c3f3087ba3010e613fa6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*luuE8U16mmzi2XGL"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">艾玛·马修斯数字内容制作在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="b046" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些开发人员会问这样一个问题<strong class="ky ir"> <em class="ls">“如果我可以使用Windows，为什么还要使用Linux？”</em> </strong>，但是他们弄颠倒了。正确的问题应该是<strong class="ky ir"> <em class="ls">“如果像Linux这样的东西存在，为什么是Windows？”</em> </strong>。尤其是软件开发。</p><p id="f064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我应该注意到，我在这里并不是站在一个铁杆自由软件纯粹主义者的立场上。倒不是说一定是坏事，只是不是今天的话题。我们将以纯粹的实用主义来看待这个问题。因此，我将尝试建立一个动议:<em class="ls">当谈到软件开发的生产力时，Linux如何成为一个更好的选择？</em></p><h1 id="b9a3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">̶d̶e̶v̶i̶l̶的生产力在于细节！</h1><p id="069e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们通常倾向于认为生产力是一次性大变革的结果。对我来说，这不是正确的定义方式。相反，生产率是一个持续的递增过程。我们一遍又一遍地迭代，以达到我们做事稍微更快更有效率的状态。然后，丽贝卡！</p><blockquote class="mq mr ms"><p id="91b9" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">没有任何一个元素会让我们说:“瞧！我刚刚变得富有成效”。</p></blockquote><p id="5742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还得出了一个结论，无论你如何优化你的日程表，无论你使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Pomodoro_Technique" rel="noopener ugc nofollow" target="_blank">番茄工作法</a>，或者如果你采用最新流行的强力午睡法，如果你日常工作流程的细节没有得到解决，你仍然会远离时间质量等式。换句话说，为了变得更有效率，你的第一个目标应该是日常事务和重复的任务。仅仅因为它们是重复的，你一直在做。</p><h1 id="1bb4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">让我们具体点</h1><p id="1f57" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">回到软件开发，如果你是这个领域的一员，你肯定知道你一遍又一遍地重复很多相同的任务——对不起，同学们，这不像电影里那样！其中一些任务可能是创建git分支、构建项目、运行测试、推送代码、搜索文件等等。您还可以运行docker命令、SSH到服务器、调用API等等。由于大多数操作(如果不是全部的话)都发生在您的操作系统中，因此充分利用操作系统来快速高效地完成任务是一个好主意。回到开头的陈述，我发现Linux绝对是现有替代方案中最适合实现这一点的。我相信这一点，因为我用了几乎所有的。我从Windows到Linux，到OSX，再回到Linux。所以我认为我的声明是充分知情的。</p><p id="2886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给予Linux这些特权的两个主要原因是社区和它是自由软件的事实。前者让你接触到由了不起的人创造的了不起的工具，以节省你重新发明轮子的时间。后者意味着，从字面上看，你可以对你的环境做任何你想做的事情，并以最适合你的方式利用它。</p><h1 id="f358" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">让我们说得更具体些</h1><p id="5f7d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了说明我的观点，我将在这里列出一些我在旅途中收集的并且每天都在使用的工具和实践。希望它们能帮助你将你的日常工作流程推向更高的生产率。我不会给出安装说明，因为那会让文章变得很长，但我会留下一些可能有帮助的链接。</p><blockquote class="mq mr ms"><p id="6c4e" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir">免责声明</strong>:以下列表并不是让你成为忍者软件开发人员的终极生产力圣经。它主要是通过提供一些相关的例子来吸引你对细节的注意。</p></blockquote><h1 id="28d9" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">1.幸福终点站</h1><blockquote class="mq mr ms"><p id="adf6" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">显然，一切都从这里开始！</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/5c1b5b395c3d4375f73848a7bf4ca5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEg9MLnOwUe8jhP15CZhzw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">瑞士陆军航站</figcaption></figure><p id="eb91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我尽量多使用终端——或者命令行界面(CLI)——不是因为我想感觉自己像电影黑客——虽然这不是一个无效的理由，而是因为它更快。因为这是我花费大量时间的地方，所以它应该既漂亮又有效率。也许你不太关心“好”的部分，这没什么，但我个人非常重视审美。</p><p id="3c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://launchpad.net/terminator" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">终结符</strong> </a> <strong class="ky ir"> : </strong>这是一个允许在一个窗口中排列多个终端的模拟器。例如，对于同时调试多个服务，或者在本地和远程机器上同时工作时，它非常有用。</p><p id="4be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.zsh.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a><strong class="ky ir">&amp;</strong><a class="ae kv" href="https://ohmyz.sh" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Oh-My-Zsh</strong></a><strong class="ky ir">:</strong>Zsh——也称为Z shell——是一个非常棒的类Unix操作系统shell。它使使用命令行更具交互性，并为您节省一些时间和挫折。当涉及到命令、文件名和进程id的自动完成时，它特别强大。它会自动纠正拼写，并允许您使用<em class="ls">选项卡</em>键浏览建议。<br/>关于这些特性和其他特性的更多信息，请点击<a class="ae kv" href="https://code.joejag.com/2014/why-zsh.html" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kv" href="https://www.sitepoint.com/zsh-tips-tricks/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="5ed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了充分利用Zsh，它应该与令人愉快的<br/> Oh-My-Zsh相结合。这是一个社区驱动的框架，带有数以千计的插件和主题，使一个好看的瑞士陆军终端。我强烈推荐那些(至少):</p><ul class=""><li id="ba28" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/romkatv/powerlevel10k" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Powerlevel10k主题</strong> </a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/fb6925fbac25718cfdfeddbcd6ead236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0AvLNsz2B0suA77ja1oTQ.png"/></div></div></figure><p id="d609" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了是一个华丽的主题之外，这个主题还提供了一些即时的反馈，否则，就需要运行额外的命令，比如当前目录的路径，当前git分支，git状态，python的virtualenv…等等。<br/> <em class="ls">不再有提交追加到错误的分支！</em></p><ul class=""><li id="c600" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/zsh-users/zsh-autosuggestions" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Zsh-自我暗示</strong> </a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/e1faefec9155e86947defe4b0559fce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xK615HFeddUVQwM_VhRFQ.png"/></div></div></figure><p id="1171" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你经常问自己类似<em class="ls">“服务器的IP是什么？”</em>或<em class="ls">“我对这个很长的命令使用了什么选项？”</em>，那你就需要这个插件。这是一个像鱼一样的自动建议，可以省去你在无聊的讨论中查找IP地址或者试图记住一周前运行的长docker命令的麻烦。你只需要开始输入一个命令的开头，就可以得到基于你的历史的建议。</p><ul class=""><li id="2bba" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/zsh-users/zsh-syntax-highlighting" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Zsh-语法-高亮</strong> </a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/985481c3c3463ac2e88c7dc8742fe57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJYR8rRa4aV3De_xosonjw.png"/></div></div></figure><p id="dcae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个插件使命令更容易阅读，并在输入时突出错误或不存在的命令。</p><p id="06b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也有特定技术的插件，具有自动完成和通用别名，如git、docker &amp; docker-compose、nvm &amp; npm(用于nodejs)、sdk(用于java)、ansi ble……完整列表可在此处找到<a class="ae kv" href="https://github.com/ohmyzsh/ohmyzsh/wiki/plugins#vscode" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="da3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="http://guake.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Guake </strong> </a>:是一个下拉终端，可以在旅途中快速运行命令。只需一次按键，它就随处可用。遵循教程说明的最快方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/947b03c9039811027223da5c6b266cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_akxBTjxI5xusyNyl9log.png"/></div></div></figure><p id="c13b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">别名:使用它们，它们会让你更有效率。为您一直运行的重复命令使用别名，或者简化长命令。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="004c" class="no lu iq nk b gy np nq l nr ns">alias dclsa="docker container ls -a"<br/>alias grdb="gradle clean build --refresh-dependencies"<br/>alias gp="git pull &amp;&amp; git fetch -p"</span></pre><p id="bd93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">其他有用的终端工具:</strong></p><ul class=""><li id="9548" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/junegunn/fzf" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Fzf </strong> </a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/6e8cfa4a6a6c37d9067bd0cd59717f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pm3MWUcUhlGnkUMLtczHVA.png"/></div></div></figure><p id="f674" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个快得惊人的命令行模糊查找器，可以过滤任何文件、进程、主机名、git提交、命令历史的列表……只需运行<code class="fe nu nv nw nk b">fzf</code>并开始键入，或者您可以使用它和管道来过滤任何命令的输出。有了这样一个强大的工具，唯一的限制就是想象力。<br/>例如，如果我们需要返回消息中包含单词vim的提交，但我们不确定是哪一个，我们可以运行命令<br/> <code class="fe nu nv nw nk b">git log --oneline</code>，将其输出重定向到<code class="fe nu nv nw nk b">fzf</code>，这将允许我们交互地过滤和导航提交，然后使用<code class="fe nu nv nw nk b">xargs</code>检查我们选择的那个。</p><ul class=""><li id="5776" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><a class="ae kv" href="https://github.com/sharkdp/bat" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">蝙蝠猫</strong> </a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/3d769bdb74cc8ee95c0be13dec566f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yw3kiSkPQqr_BcwJMiQBjQ.png"/></div></div></figure><p id="fdd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">“一只长着翅膀的克隆猫①。”</em>显示其Github页面。对于Linux中的<code class="fe nu nv nw nk b">cat</code>命令，Bat是一个更好的选择。除了其他选项之外，它还具有语法突出显示功能，并与<code class="fe nu nv nw nk b">fzf</code>无缝集成，可以预览正在过滤的文件。</p><ul class=""><li id="29dc" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><a class="ae kv" href="https://httpie.org" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> HTTPie </strong> </a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/1ba5cd38374f86eeba81edb43b6d1828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlfoRic9nj580RowxEnNkA.png"/></div></div></figure><p id="5976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Postman很好，但是它需要点击鼠标，并且不能在无GUI环境中使用。可以做到这一点，但是并不那么简单，它需要额外的工具(例如解析JSON)。这就是HTTPie出手相救的地方。一个奇妙的命令行HTTP客户端<em class="ls">“API时代的”</em>。它支持JSON开箱即用，并具有语法高亮和持久会话等功能。</p><h1 id="8a31" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">2.代码编辑</h1><blockquote class="mq mr ms"><p id="e838" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">一枚戒指统治所有人！</p></blockquote><p id="e8ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会在这一部分做太多的阐述，因为，简单地说，没有放之四海而皆准的方法。不过，有一件事值得一提，我尝试对几乎所有的代码使用同一个编辑器。由于我选择使用<a class="ae kv" href="https://vscodium.com/" rel="noopener ugc nofollow" target="_blank"> VSCodium </a>作为我的代码编辑器，我必须让它与Java和Spring Boot兼容。如果你对此感兴趣，我会在<a class="ae kv" href="https://medium.com/cllfst/spring-boot-with-visual-studio-code-why-not-530813d6d9ff?source=friends_link&amp;sk=3b653dab2e54a9a1e78f1224e25706b9" rel="noopener">这篇博文</a>中解释。</p><h1 id="6c1c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">3.使用Docker</h1><blockquote class="mq mr ms"><p id="f2be" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">你再也不需要安装软件了！</p></blockquote><p id="df02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员花费了大量的时间来安装软件，如项目依赖、数据库或HTTP服务器。如果所有东西都直接安装在机器上，不同的包之间或者同一个包的不同版本之间迟早会产生冲突。发现这些冲突有时会成为一项可怕的任务，而解决这些冲突可能会花费很长时间。突然，那个不可忽略的时间可怕地延长了，宇宙开始采用堆栈轨迹的形状。</p><p id="6f6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，<a class="ae kv" href="https://www.docker.com/why-docker" rel="noopener ugc nofollow" target="_blank"> docker </a>存在。它使开发和运输更快、更容易、更安全。无论你是需要构建你的hole项目还是简单地尝试一个新的操作系统工具，只需生成一个你选择的docker容器并安装你所需要的。一旦你对你所得到的感到满意，写一个<a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>来重现完全相同的步骤。最终，您将有一种确定的方式从头开始重新创建您的环境。除了保持一切隔离之外，docker使开发环境尽可能接近生产环境。</p><h1 id="ffdc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">4 .点文件</h1><blockquote class="mq mr ms"><p id="761b" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">自动化！</p></blockquote><p id="5986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更进一步，除了采用上述工具和实践，我们甚至可以自动化它们的安装，用一个命令配置它们，并在版本控制系统中跟踪它们的配置(例如Git)。</p><p id="0ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点文件是名称以点开头的文件——是的，软件人员对名称很有创意！它们旨在存储用户特定的配置。这也使它们的管理更加容易，因为它们可以在需要时进行备份和重复使用。在第一次手动配置所有东西之后，如果你达到了对你所得到的东西感到满意的状态，保存你需要的点文件——我将它们存储在<a class="ae kv" href="https://github.com/zguesmi/dotfiles" rel="noopener ugc nofollow" target="_blank"> Github </a>上以获得两个优势:托管和版本控制。下一次你擦除你的磁盘或改变你的机器，在安装你的应用程序和工具之后(你可以写脚本)，你只需要抓取那些文件并把它们放在正确的位置。</p><p id="bef2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">管理点文件的过程因方法而异。我个人不喜欢使用<a class="ae kv" href="https://medium.com/toutsbrasil/how-to-manage-your-dotfiles-with-git-f7aeed8adf8b" rel="noopener">的bare git项目</a> (1)也不喜欢使用<a class="ae kv" href="https://wiki.archlinux.org/index.php/Dotfiles#Tools" rel="noopener ugc nofollow" target="_blank">的专用工具</a> (2)。我不想跟踪我的主目录(1)或依赖更多的第三方软件。我采用了利用<a class="ae kv" href="https://www.gnu.org/software/stow/" rel="noopener ugc nofollow" target="_blank"> GNU stow </a>(这里解释<a class="ae kv" href="https://alexpearce.me/2016/02/managing-dotfiles-with-stow/" rel="noopener ugc nofollow" target="_blank"/>)的方法，因为它看起来更方便。我会留下一个<a class="ae kv" href="https://github.com/zguesmi/dotfiles" rel="noopener ugc nofollow" target="_blank">链接</a>到我的dotfiles只是为了获得灵感。</p><h1 id="9632" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">外卖食品</h1><p id="4b98" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">希望我回答了这个问题<em class="ls">“当谈到软件开发的生产力时，Linux如何成为更好的选择？”</em>并给出了一些切实可行的例子，供您从现在开始应用。我要强调的是，这些例子只是Linux生态系统中存在的一小部分，这要归功于它令人惊叹的社区。</p><blockquote class="nz"><p id="154f" class="oa ob iq bd oc od oe of og oh oi lr dk translated">最后，请记住，细节很重要！</p></blockquote></div></div>    
</body>
</html>