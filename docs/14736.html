<html>
<head>
<title>Implementing Redux With Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rust实现Redux</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-redux-with-rust-a-step-by-step-guide-220acd2885f9?source=collection_archive---------7-----------------------#2022-12-20">https://levelup.gitconnected.com/implementing-redux-with-rust-a-step-by-step-guide-220acd2885f9?source=collection_archive---------7-----------------------#2022-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a20" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">循序渐进的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ff4d63133b67777ce62960702bb81262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JPZkQJ3UzBnpL4zg6lHYw.jpeg"/></div></div></figure><p id="faec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Redux是一个流行的JavaScript应用程序状态管理库。它允许开发人员以可预测和一致的方式管理他们的应用程序的状态，使得开发和维护复杂的应用程序变得更加容易。</p><p id="f754" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇博文中，我们将探讨如何在Rust中实现Redux，Rust是一种静态类型的系统编程语言，以其性能和安全性而闻名。</p><p id="537f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在Rust中实现Redux，我们需要创建一个表示应用程序状态的struct和一个定义可以在状态上执行的动作的trait。我们还需要创建一个reducer函数，它接受当前状态和一个动作，并基于该动作返回一个新状态。</p><h1 id="46fb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">基本实现</h1><p id="28c5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">下面是一个简单结构的示例，它表示待办事项应用程序的状态:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="2fb9" class="mp lo iq ml b be mq mr l ms mt">struct TodoState {<br/>    todos: Vec&lt;String&gt;,<br/>}</span></pre><p id="8d2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将使用trait定义可以在状态上执行的操作:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="16a0" class="mp lo iq ml b be mq mr l ms mt">trait TodoAction {<br/>    fn apply(&amp;self, state: &amp;mut TodoState);<br/>}</span></pre><p id="f5ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们可以定义reducer函数，它接受当前状态和一个动作，并基于该动作返回一个新状态</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="981b" class="mp lo iq ml b be mq mr l ms mt">fn todo_reducer(state: &amp;TodoState, action: &amp;dyn TodoAction) -&gt; TodoState {<br/>    let mut new_state = state.clone();<br/>    action.apply(&amp;mut new_state);<br/>    new_state<br/>}</span></pre><p id="fc4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经有了Redux实现的基本结构，我们可以定义可以在我们的to-do状态上执行的具体操作。例如，我们可能有一个添加新待办事项的操作:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="f22f" class="mp lo iq ml b be mq mr l ms mt">struct AddTodoAction {<br/>    todo: String,<br/>}<br/><br/>impl TodoAction for AddTodoAction {<br/>    fn apply(&amp;self, state: &amp;mut TodoState) {<br/>        state.todos.push(self.todo.clone());<br/>    }<br/>}</span></pre><p id="4180" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还可以定义一个删除待办事项的操作:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="c8d4" class="mp lo iq ml b be mq mr l ms mt">struct RemoveTodoAction {<br/>    index: usize,<br/>}<br/><br/>impl TodoAction for RemoveTodoAction {<br/>    fn apply(&amp;self, state: &amp;mut TodoState) {<br/>        state.todos.remove(self.index);<br/>    }<br/>}</span></pre><p id="352d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这些动作，我们现在可以使用reducer函数根据用户交互来更新待办事项应用程序的状态。例如，如果用户添加了一个新的待办事项，我们可以使用<code class="fe mu mv mw ml b">todo_reducer</code>函数来更新状态，如下所示:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="bf68" class="mp lo iq ml b be mq mr l ms mt">let mut state = TodoState { todos: vec![] };<br/>let action = AddTodoAction { todo: "Learn Rust".to_string() };<br/>state = todo_reducer(&amp;state, &amp;action);</span></pre><p id="fda0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是在Rust中实现Redux的一个非常简单的例子，但是它应该让您对基本结构以及如何创建动作和reducer函数有一个很好的了解。在Rust中实现Redux还有许多其他方法，包括使用宏来生成reducer函数，使用枚举来表示动作。</p><h1 id="af02" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">使用宏生成reducer函数和枚举来表示动作</h1><p id="7a4c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">首先，我们将定义一个枚举，它表示可以对状态执行的不同操作:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="a326" class="mp lo iq ml b be mq mr l ms mt">enum TodoAction {<br/>    AddTodo(String),<br/>    RemoveTodo(usize),<br/>}</span></pre><p id="2c2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将定义为我们生成reducer函数的宏:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="6550" class="mp lo iq ml b be mq mr l ms mt">#[macro_export]<br/>macro_rules! create_reducer {<br/>    ($state_type:ty, $action_type:ty, $reducer_fn:expr) =&gt; {<br/>        fn reducer(state: &amp;$state_type, action: $action_type) -&gt; $state_type {<br/>            let mut new_state = state.clone();<br/>            $reducer_fn(&amp;mut new_state, action);<br/>            new_state<br/>        }<br/>    }<br/>}</span></pre><p id="69e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以使用<code class="fe mu mv mw ml b">create_reducer</code>宏来定义我们的减速器功能，如下所示:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="a5d7" class="mp lo iq ml b be mq mr l ms mt">create_reducer!(TodoState, TodoAction, |state: &amp;mut TodoState, action| {<br/>    match action {<br/>        TodoAction::AddTodo(todo) =&gt; state.todos.push(todo),<br/>        TodoAction::RemoveTodo(index) =&gt; state.todos.remove(index),<br/>    }<br/>});</span></pre><p id="3fbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将生成一个reducer函数，它接受一个<code class="fe mu mv mw ml b">TodoState</code>和一个<code class="fe mu mv mw ml b">TodoAction</code>枚举，并根据动作更新状态。</p><p id="2238" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以使用reducer函数来更新我们的待办事项应用程序的状态，如下所示:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="dcdb" class="mp lo iq ml b be mq mr l ms mt">let mut state = TodoState { todos: vec![] };<br/>let action = TodoAction::AddTodo("Learn Rust".to_string());<br/>state = reducer(&amp;state, action);</span></pre><h1 id="3237" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">现在我们可以使用Yew来为我们的待办事项应用程序构建UI</h1><p id="305e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">首先，我们将定义一个表示单个待办事项的组件:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="a7c8" class="mp lo iq ml b be mq mr l ms mt">use yew::{html, Callback, Html};<br/><br/>struct TodoItem {<br/>    todo: String,<br/>    on_remove: Callback&lt;()&gt;,<br/>}<br/><br/>impl Component for TodoItem {<br/>    type Message = ();<br/>    type Properties = Self;<br/><br/>    fn create(props: Self::Properties, _: ComponentLink&lt;Self&gt;) -&gt; Self {<br/>        Self {<br/>            todo: props.todo,<br/>            on_remove: props.on_remove,<br/>        }<br/>    }<br/><br/>    fn update(&amp;mut self, _: Self::Message) -&gt; ShouldRender {<br/>        false<br/>    }<br/><br/>    fn view(&amp;self) -&gt; Html {<br/>        html! {<br/>            &lt;div&gt;<br/>                &lt;span&gt;{ &amp;self.todo }&lt;/span&gt;<br/>                &lt;button onclick=self.on_remove.clone()&gt;{"Remove"}&lt;/button&gt;<br/>            &lt;/div&gt;<br/>        }<br/>    }<br/>}</span></pre><p id="b356" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将定义应用程序的主要组件，它将包含一个待办事项列表和一个用于添加新待办事项的表单:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="0061" class="mp lo iq ml b be mq mr l ms mt">use yew::{html, Callback, Component, ComponentLink, Html, ShouldRender};<br/>use yew_functional::{use_state, use_reducer};<br/><br/>struct TodoApp {<br/>    link: ComponentLink&lt;Self&gt;,<br/>    state: TodoState,<br/>    dispatch: Callback&lt;TodoAction&gt;,<br/>}<br/><br/>impl Component for TodoApp {<br/>    type Message = ();<br/>    type Properties = ();<br/><br/>    fn create(_: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {<br/>        let state = TodoState { todos: vec![] };<br/>        let (dispatch, _) = use_reducer(link, reducer, state);<br/>        Self { link, state, dispatch }<br/>    }<br/><br/>    fn update(&amp;mut self, _: Self::Message) -&gt; ShouldRender {<br/>        false<br/>    }<br/><br/>    fn view(&amp;self) -&gt; Html {<br/>        html! {<br/>            &lt;div&gt;<br/>            &lt;h1&gt;{"Todo List"}&lt;/h1&gt;<br/>            &lt;ul&gt;<br/>                { for self.state.todos.iter().enumerate().map(|(index, todo)| {<br/>                    html! {<br/>                        &lt;TodoItem<br/>                            todo=todo.clone()<br/>                            on_remove=self.link.callback(move |_| {<br/>                                self.dispatch.emit(TodoAction::RemoveTodo(index))<br/>                            })<br/>                        /&gt;<br/>                    }<br/>                }) }<br/>            &lt;/ul&gt;<br/>            &lt;form onsubmit=self.link.callback(|event| {<br/>                event.prevent_default();<br/>                let input = event.target().unwrap().try_into::&lt;HtmlInputElement&gt;().unwrap();<br/>                let todo = input.value();<br/>                input.set_value("");<br/>                self.dispatch.emit(TodoAction::AddTodo(todo))<br/>            })&gt;<br/>                &lt;input type="text" /&gt;<br/>                &lt;button type="submit"&gt;{"Add Todo"}&lt;/button&gt;<br/>            &lt;/form&gt;<br/>        &lt;/div&gt;<br/>    }<br/>}</span></pre><p id="6f32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该组件将呈现一个待办事项列表和一个添加新待办事项的表单。使用来自Yew的<code class="fe mu mv mw ml b">use_reducer</code>钩子来管理应用程序的状态，这允许我们使用我们之前定义的reducer函数来基于用户交互更新状态。</p><p id="6bb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要在Yew应用程序中使用该组件，可以像这样将其添加到根组件中:</p><pre class="kg kh ki kj gt mk ml mm bn mn mo bi"><span id="5eaa" class="mp lo iq ml b be mq mr l ms mt">use yew::{html, App};<br/><br/>fn main() {<br/>    yew::initialize();<br/>    App::&lt;TodoApp&gt;::new().mount_to_body();<br/>    yew::run_loop();<br/>}</span></pre><p id="21f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个例子帮助你理解如何使用Yew和Redux在Rust中构建一个web应用。如果你有任何问题或建议，请不要犹豫地问！</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="282c" class="ln lo iq bd lp lq ne ls lt lu nf lw lx jw ng jx lz jz nh ka mb kc ni kd md me bi translated">分级编码</h1><p id="87d8" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="8e37" class="nj nk iq kt b ku kv kx ky la nl le nm li nn lm no np nq nr bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="330c" class="nj nk iq kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">📰查看<a class="ae nx" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="8a68" class="nj nk iq kt b ku ns kx nt la nu le nv li nw lm no np nq nr bi translated">🔔关注我们:<a class="ae nx" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae nx" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nx" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="105c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">🚀👉<a class="ae nx" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>