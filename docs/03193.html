<html>
<head>
<title>How to read Azure Dev Ops logs from Node.js using REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用REST API从Node.js读取Azure Dev Ops日志</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-read-azure-dev-ops-logs-from-node-js-using-rest-api-e575a4c85cc3?source=collection_archive---------11-----------------------#2020-04-24">https://levelup.gitconnected.com/how-to-read-azure-dev-ops-logs-from-node-js-using-rest-api-e575a4c85cc3?source=collection_archive---------11-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a2631b6df6590fbedc30d780e309fb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LN6marWepoOycPjqbrtkfA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@moniqa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莫妮卡·格拉布斯卡</a>在<a class="ae jg" href="https://unsplash.com/s/photos/%40moniqa-logs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的日志照片。</figcaption></figure><div class=""/><blockquote class="kg kh ki"><p id="8d6a" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">得到一些木头不会那么难吧？我肯定能用几行代码做到这一点！</p></blockquote><p id="8852" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated"><em class="kl">原发布</em> <a class="ae jg" href="https://indepth.dev/how-to-read-azure-dev-ops-logs-from-node-js-using-rest-api/" rel="noopener ugc nofollow" target="_blank"> <em class="kl">深度开发</em> </a></p><p id="3c81" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">嗯，我最初也是这么想的。原来它不仅仅是调用一个GET端点。</p><p id="eabb" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">一部分原因是来自logs端点的响应实际上是一个zip文件。其中有多个文件条目——每个管道任务一个。另外还有授权的部分。所以…</p><p id="0cba" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">本文将带你一步一步地从一个空白文件到拥有来自你的Azure Dev Ops发布管道的日志。如你所知，它们可以在网上找到，但是要找到它们，必须经过几个步骤/点击。您可能希望获得日志并以编程方式处理它们。例如，我必须检查一个特定的字符串是否是发布管道日志的一部分。</p><p id="9180" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">先决条件:</p><ul class=""><li id="76e7" class="ll lm jj km b kn ko kr ks li ln lj lo lk lp lh lq lr ls lt bi translated">从一个空白的node.js项目开始，并包含依赖项— <a class="ae jg" href="https://npmjs.com/packages/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>和<a class="ae jg" href="https://npmjs.com/packages/yauzl" rel="noopener ugc nofollow" target="_blank"> yauzl </a>。</li><li id="fd56" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">从Azure Dev Ops获取个人访问令牌(PAT ),并将其存储在环境变量中。用它来获得授权。</li><li id="f5c7" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">通过<a class="ae jg" href="https://docs.microsoft.com/en-us/rest/api/azure/devops/" rel="noopener ugc nofollow" target="_blank"> Azure Dev Ops REST API </a>获取压缩日志。</li><li id="87b5" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">在内存中解压缩并读取文本内容。</li><li id="da96" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">我们将从发布管道运行中读取日志，但是在最后有一节是关于如何转换脚本和读取构建管道脚本的。</li></ul><blockquote class="kg kh ki"><p id="ea3d" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><em class="jj">如果你只想要完成的脚本，下面是从</em> <a class="ae jg" href="https://gist.github.com/gparlakov/426820697dc2574da6e6f6f6b31d5498" rel="noopener ugc nofollow" target="_blank"> <em class="jj">发布管道</em> </a> <em class="jj">和</em> <a class="ae jg" href="https://gist.github.com/gparlakov/95e41ebee68c99baf36f36c12278deaf" rel="noopener ugc nofollow" target="_blank"> <em class="jj">构建管道</em> </a> <em class="jj">中读取日志的要点。我已经为变量留下了提醒</em> <code class="fe lz ma mb mc b"><em class="jj">// TODO Replace with your own</em></code> <em class="jj">。</em></p></blockquote><p id="5346" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">我将使用<a class="ae jg" href="https://npmjs.com/packages/ts-node" rel="noopener ugc nofollow" target="_blank"> ts-node </a>,因为我更喜欢类型脚本安全，不想处理转换步骤。所以我用<code class="fe lz ma mb mc b">ts-node index.ts</code>代替<code class="fe lz ma mb mc b">node index.js</code>。如果您愿意的话，在类型被删除之后，脚本应该像普通js一样工作。</p><p id="5f5d" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">我的shell是在Linux的Windows子系统内运行的<code class="fe lz ma mb mc b">bash</code>(<a class="ae jg" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="noopener ugc nofollow" target="_blank">WSL</a>)。</p><h2 id="4ecd" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated">1.开始</h2><p id="033e" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">在文件夹<code class="fe lz ma mb mc b">azdo-logs</code>中初始化一个节点包:</p><pre class="nb nc nd ne gt nf mc ng nh aw ni bi"><span id="0703" class="md me jj mc b gy nj nk l nl nm">mkdir azdo-logs <br/>cd azdo-logs <br/>npm init -y</span></pre><p id="3615" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">预期会看到类似于以下内容的输出:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/c241e5f4930512fbed94d5bb643d786c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rBlrsA5OBl77qcHu"/></div></div></figure><p id="9d72" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">创建<code class="fe lz ma mb mc b">index.ts</code>文件，包括以下几行:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6d39" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">我们希望确保令牌在那里，安全地隐藏在您的<strong class="km jk">私有环境变量</strong>中，而不是与代码一起签入！</p><p id="bde9" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">顶部的<code class="fe lz ma mb mc b">reference</code>让我们可以访问nodejs类型。您可能需要将它们作为开发依赖项来安装:</p><pre class="nb nc nd ne gt nf mc ng nh aw ni bi"><span id="ec1d" class="md me jj mc b gy nj nk l nl nm">npm i @types/node -D</span></pre><h2 id="f518" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated">2.添加依赖关系</h2><p id="fe0c" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">全局安装<code class="fe lz ma mb mc b">ts-node</code>和<code class="fe lz ma mb mc b">typescript</code>来执行我们的脚本。</p><pre class="nb nc nd ne gt nf mc ng nh aw ni bi"><span id="6ecb" class="md me jj mc b gy nj nk l nl nm">npm i -g ts-node typescript</span></pre><p id="7996" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">在我们的包装中安装<code class="fe lz ma mb mc b">axios</code>和<code class="fe lz ma mb mc b">yauzl</code>。标志<code class="fe lz ma mb mc b">-s</code>会将它们保存到我们的<code class="fe lz ma mb mc b">package.json</code>中。并且<code class="fe lz ma mb mc b">@types/yauzl</code>会给我们输入，用<code class="fe lz ma mb mc b">-D</code>标志将其添加到<code class="fe lz ma mb mc b">devDependencies</code></p><pre class="nb nc nd ne gt nf mc ng nh aw ni bi"><span id="ef38" class="md me jj mc b gy nj nk l nl nm">npm i axios yauzl -s <br/>npm i @types/yauzl -D</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d3815198a78435533d94bf365ec4cf15.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/0*nppSCj8Ff229k-5s"/></div></figure><p id="1ed3" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">这是<code class="fe lz ma mb mc b">package.json</code>现在的样子:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="9429" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated">3.获取Azure开发操作令牌</h2><p id="1eb4" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">它可以通过profile菜单获得</p><ul class=""><li id="e04b" class="ll lm jj km b kn ko kr ks li ln lj lo lk lp lh lq lr ls lt bi translated">打开个人访问令牌页面</li></ul><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ff1a08e536b9d85224f86a0551329159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/0*xDbUtM6rfG1yapse"/></div></figure><ul class=""><li id="976d" class="ll lm jj km b kn ko kr ks li ln lj lo lk lp lh lq lr ls lt bi translated">使用Release <code class="fe lz ma mb mc b">Read</code>权限创建新的访问令牌</li></ul><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/a8fa66f62dc31b3af81592d4aa3cc6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S2-4Y_CU7tmFZhxc"/></div></div></figure><ul class=""><li id="2887" class="ll lm jj km b kn ko kr ks li ln lj lo lk lp lh lq lr ls lt bi translated">把它储存起来，因为你再也看不到它了(<em class="kl">如果你丢失了它，你还可以重新创建它)</em></li></ul><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/002125378701e834a6190f84951e11ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*U-XWOYbh_x_f-Et9"/></div></div></figure><p id="37a8" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">最后，将它放在本地机器的环境变量中或安全存储中(例如<a class="ae jg" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&amp;tabs=classic%2Cbatch#secret-variables" rel="noopener ugc nofollow" target="_blank"> secret环境变量</a>)</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6f1f" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">或Windows命令行</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f909" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">我已经将这一行添加到我的<code class="fe lz ma mb mc b">.bashrc</code>文件中，这样PAT就可以在bash start上使用，这样我就不必在每次启动终端时都记住它。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/1fda91af385068e9ce2a6654cb9a3abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mKYO8tp4V4bwWRnb"/></div></div></figure><p id="344d" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">在Windows上，您可以将它添加到环境变量中。请记住，要使env变量生效，您需要重启您的会话(注销/登录)。</p><p id="e44a" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">现在运行<code class="fe lz ma mb mc b">ts-node index.ts</code>，你应该会看到</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1139f75eb9f55461c8dc6f88194ae1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*CkabInh3notI9gN6"/></div></figure><p id="df90" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">有关如何获取个人访问令牌的更多详细信息，请参见<a class="ae jg" href="https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&amp;tabs=preview-page" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><p id="6197" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">好了—我们现在有了令牌和依赖项！</p><h2 id="450b" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated">4.获取Azure Dev Ops组织和项目</h2><p id="2dce" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">为了获取日志，我们需要组织和项目名称，以及我们想要读取日志的发布id。后者将在以后的每一次运行中增加——版本1、2、3，所以我们需要在每次调用时提供它。对于这个例子，我将把我维护的包的<a class="ae jg" href="https://dev.azure.com/gparlakov/Scuri/_releaseProgress?_a=release-environment-logs&amp;releaseId=58&amp;environmentId=87" rel="noopener ugc nofollow" target="_blank">发布管道</a>作为目标。</p><p id="c5fb" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">我们可以从Azure Dev Ops UI获得的项目名称和组织:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/795d7c9d05c3ae0a0a77b1a006fecef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N769H8DIn7xuEiOi"/></div></div></figure><p id="ac2d" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">就我而言，是组织‘gparlakov’和项目‘Scuri’。在<code class="fe lz ma mb mc b">index.ts</code>中添加这些行，并替换为您的组织和项目名称:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="f3e4" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated"><strong class="ak"> 5。授权</strong></h2><p id="8f06" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">为了使用个人访问令牌(PAT)获得API端点的授权，我们需要发送一个报头，该报头中的令牌以base64格式编码，符合特定的合同<a class="ae jg" href="https://docs.microsoft.com/en-us/rest/api/azure/devops/?view=azure-devops-rest-5.1#assemble-the-request" rel="noopener ugc nofollow" target="_blank"/>。在<code class="fe lz ma mb mc b">index.ts</code>的末尾增加以下内容:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5556" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">我们需要导入axios模块，在<code class="fe lz ma mb mc b">index.ts</code>的顶部</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="c300" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated">6.获取发布日志</h2><p id="c396" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">对于这个例子，我将使用带有<code class="fe lz ma mb mc b">58</code>的<code class="fe lz ma mb mc b">id</code>的实际版本(替换为您自己的版本)。追加到<code class="fe lz ma mb mc b">index.ts</code>:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8751" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">运行<code class="fe lz ma mb mc b">ts-node index.ts</code>应该会产生类似于:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a08f00065e3cb882faf365a9c9b74752.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/0*hsnwS2EOOQU_hJAY"/></div></figure><p id="80c0" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">这证明我们被授权使用这个REST API端点！</p><h2 id="ee04" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated">7.解压缩日志</h2><p id="7ab6" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">删除或注释掉<code class="fe lz ma mb mc b">console.log</code>行——我们现在不需要它，并更改<code class="fe lz ma mb mc b">axiosInstance</code>调用，使其看起来像这样:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7aa2" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">最后是<code class="fe lz ma mb mc b">readLogs</code>功能:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0619" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">这里似乎发生了很多事情。归结起来就是处理3个流。</p><ul class=""><li id="0a4f" class="ll lm jj km b kn ko kr ks li ln lj lo lk lp lh lq lr ls lt bi translated">首先，我们将<code class="fe lz ma mb mc b">zipFile</code>推入到<code class="fe lz ma mb mc b">zipChunks</code>中，并将它们连接成一个<code class="fe lz ma mb mc b">Buffer</code>。</li><li id="81ff" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">然后，在返回具有<code class="fe lz ma mb mc b">readEntry()</code>方法的对象的<code class="fe lz ma mb mc b">yauzl.fromBuffer()</code>调用中使用<code class="fe lz ma mb mc b">Buffer</code>。我认为它是一个<code class="fe lz ma mb mc b">next</code>，因为它读取归档中的下一个条目。</li><li id="223f" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">我们为每个zip文件条目获取一个<code class="fe lz ma mb mc b">readStream</code>。那是我们推入<code class="fe lz ma mb mc b">chunks</code>的<code class="fe lz ma mb mc b">ReadableStream</code>。</li><li id="60dd" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">最后把字符串从<code class="fe lz ma mb mc b">chunks</code> <br/> <code class="fe lz ma mb mc b">Buffer.concat(chunks).toString('utf8');</code>中取出</li></ul><h2 id="09c7" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated">完成的</h2><p id="14d4" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">我们现在有了一个包含所有日志的<code class="fe lz ma mb mc b">string</code>变量！</p><p id="7592" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">以下是最终<a class="ae jg" href="https://gist.github.com/gparlakov/426820697dc2574da6e6f6f6b31d5498" rel="noopener ugc nofollow" target="_blank"> index.ts </a>的要点。我已经为变量留下了提醒<code class="fe lz ma mb mc b">// TODO Replace with your own</code>。</p><h2 id="1068" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated"><strong class="ak">读取构建管道日志</strong></h2><p id="9372" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">为了从构建管道中读取日志，我们需要</p><p id="183e" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">1.向我们的令牌添加“Build: Read”权限，或者颁发一个具有该权限的新令牌:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e5df77ef96c9937c4fefd3e220758498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/0*hXGkbUeqZ2PsLZIz"/></div></figure><p id="7c86" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">2.更改一点(只移除一部分)验证逻辑:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a22c" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">3.更改基本URL:</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f24e" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">4.更改端点地址并提供一个构建号(在我的例子中，我将使用<a class="ae jg" href="https://dev.azure.com/gparlakov/Scuri/_build/results?buildId=208&amp;view=logs&amp;j=12f1170f-54f2-53f3-20dd-22fc7dff55f9" rel="noopener ugc nofollow" target="_blank"> this build </a></p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9e67" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">下面是最终的<a class="ae jg" href="https://gist.github.com/gparlakov/95e41ebee68c99baf36f36c12278deaf" rel="noopener ugc nofollow" target="_blank">剧本</a>。</p><h2 id="e5da" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated">内存消耗记录</h2><p id="4cf7" class="pw-post-body-paragraph kj kk jj km b kn mw kp kq kr mx kt ku li my kx ky lj mz lb lc lk na lf lg lh im bi translated">这种方法在内存中保留了一些缓冲区，基本上就是在内存中多次复制zip文件。考虑到我们正在读取管道日志，这应该不是问题。我希望它们不会太大。如果这对你来说是个问题，那么在本地存储档案(尽管正如Samuel Attard @marshallofsound指出的那样，这可能是一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Zip_bomb" rel="noopener ugc nofollow" target="_blank">安全问题</a>，然后使用另一种方法<code class="fe lz ma mb mc b">yauzl</code></p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="54ef" class="pw-post-body-paragraph kj kk jj km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">*响应流、块、缓冲区、zip内容块、它们的缓冲区，最后是字符串——对于一个50k的日志，我们最终使用250k RAM。</p><h2 id="a173" class="md me jj bd mf mg mh dn mi mj mk dp ml li mm mn mo lj mp mq mr lk ms mt mu mv bi translated"><strong class="ak">资源</strong></h2><ul class=""><li id="e25d" class="ll lm jj km b kn mw kr mx li ny lj nz lk oa lh lq lr ls lt bi translated">Restful API <a class="ae jg" href="https://docs.microsoft.com/en-us/rest/api/azure/devops/?view=azure-devops-rest-5.1" rel="noopener ugc nofollow" target="_blank">文档</a>——非常有用</li><li id="1ad4" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">用于API的nodejs <a class="ae jg" href="https://github.com/microsoft/azure-devops-node-api" rel="noopener ugc nofollow" target="_blank"> client </a>(但是它大约116k minified+GZipped！根据<a class="ae jg" href="https://bundlephobia.com/result?p=azure-devops-node-api@10.1.1" rel="noopener ugc nofollow" target="_blank"> bundlephobia </a> ~830k值的脚本供您的运行时解析——对于每个请求<strong class="km jk"/></li><li id="90cf" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated"><a class="ae jg" href="https://github.com/axios/axios#request-config" rel="noopener ugc nofollow" target="_blank">轴</a>的文档</li><li id="1f58" class="ll lm jj km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated"><a class="ae jg" href="https://github.com/thejoshwolfe/yauzl" rel="noopener ugc nofollow" target="_blank"> yauzl </a>的文档</li></ul></div></div>    
</body>
</html>