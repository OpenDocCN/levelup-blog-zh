<html>
<head>
<title>Ruby Methods New to Me</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby方法对我来说是新的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ruby-methods-new-to-me-e82b2a8ebde9?source=collection_archive---------10-----------------------#2020-11-02">https://levelup.gitconnected.com/ruby-methods-new-to-me-e82b2a8ebde9?source=collection_archive---------10-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5d0c8664d2d6d09399bc8ee045f8fb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cwUMAQOattbWJo8w.jpg"/></div></div></figure><div class=""/><p id="66ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了前端和基于React的项目/技能，我在博客上退了一步，也关注了Ruby。在一周前做了一次课后测试后，我意识到我已经足够擅长制作我自己的RoR项目，但是从零开始创建一个正则表达式，简单的Ruby设置…我不是。知道Rails的工作方式，但在一个普通的Regex文件中，忘记使用require‘path _ name’感觉很奇怪。我认为这是Ruby的一个优点，也是一个缺点。由于Ruby社区和语言的稳定性和寿命，很多工作都是在后台自动完成的，但与此同时，知道x做y，并不一定有助于您理解<em class="kw">为什么</em> x做y。在带回家的考试中，我发现自己学到了新的简单的东西，无论是用rspec测试还是更好地使用Ruby枚举。所以我决定记录下我遇到的一些问题。</p><p id="9756" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，一个简单的问题。在某些数组方法上使用bang。在我日常使用Ruby或其他语言时，我总是使用bang(！)或者双(！！)为真/假。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kx"><img src="../Images/bfd007a3d7cfcd8958de63305174fb6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvpsH8H4W3_uKZgpF8sz4w.png"/></div></div></figure><p id="f69c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像这样最基本的东西。它只是简单地使用了'！'在数组前说“如果数组不包含字母，则返回…”。</p><p id="1bf7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在经历了这次带回家的考试后，我不得不操纵我做的一个散列。散列有指向元素数组的单个键。我需要找出每个数组中每个键的唯一值的数量。然而……这个散列是一个实例变量，因此我随后需要将存储在其中的数据用于另一个方法。但是我一直发现如果我打电话给uniq！方法，它操作我的散列，由此我的下一个方法处理一个只包含唯一值的被操作的散列！</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lc"><img src="../Images/6d9b02caa9612da3f555a21ac2d31913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJ0SwuCjTnhdEsMv2wdHIA.png"/></div></div></figure><p id="60f0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不应该发生的！在我的带回家的文章中，我把这个独特的方法称为最后一个。所以幸运的是，通过检查最后一个方法后的数据是否正常，我发现它不正常，我已经操纵了我的实例变量。</p><p id="61c9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">爆炸在操纵自我并将其还原。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ld"><img src="../Images/3154f43cb04170a2303a2abed91a0330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBEglGzhGQCvViaBShWASw.png"/></div></div></figure></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="7de3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是兰姆达斯。或者没有名字的函数。因为lambdas是匿名函数。lambda的最后一个表达式是返回的内容。我不知道的是这实际上非常有用。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ll"><img src="../Images/48a74524bc10cb47793fe70b1068559b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1X2u03p_sz-6HvRT6COtA.png"/></div></div></figure><p id="d629" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将返回值“我是返回者”。例如，当递增任何一个数字时，我们可以创建一个lambda，它只接受一个数字并调用。下一步返回下一个数字。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lm"><img src="../Images/c04dc8d5a6b1625b40a66ec712b7db4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3AbePq_iECuNZPS4KQ9ag.png"/></div></div></figure></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="88b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Find_all帮助查找非重复项。如果你要获取一个数组，你只是想找到所有不重复的元素，find_all非常有用，它在块中使用了count。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ln"><img src="../Images/519d073a7b5ed81818f1c005a3cda5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4BT1Xr99AdO_gBMv74fpw.png"/></div></div></figure><p id="2668" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将返回["薄荷"，"草莓"]。我发现find_all实际上是一个非常有用的可枚举类型，可以被很好地使用！</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="1179" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我将再做一个枚举，然后进入依赖注入和::常量查找操作符。如果你知道这一切，就对我坦白吧！</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="3106" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个带有对象。我发现这对于计算数组元素的频率非常有用(尽管非常类似于inject)。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lo"><img src="../Images/07651b1eb1c08bfd210b88cc4094fe8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_djGUr8BMGEw70BiVoyxfg.png"/></div></div></figure><p id="a93a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于each_with_object，与在块之前声明结构相反，您可以将正在创建的结构声明为参数。这里我们选择了散列，但是我也可以使用数组。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lp"><img src="../Images/39d4f48ec85aa3fa3944f81d6e739743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiojKhuagldWtPLR7Jc4Wg.png"/></div></div></figure><p id="f616" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现的一件事是你不能用不可变对象来枚举。我在womanonrails.com找到了一个很好的例子—</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lq"><img src="../Images/cde27d4c14f94e6c29d5fe141438eb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXXtvvEUNUCmRBwN5OBZAg.png"/></div></div></figure></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="e5f5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在开始更深入的学习。依赖注入。</p><p id="5e6d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在RSpec3的有效测试中发现了这一点。依赖注入是一种技术，通过这种技术，您可以传入协作对象，而不是对它们进行硬编码，或者将组件粘合在一起。在OOP中，对象通常依赖于其他对象才能正常工作。</p><p id="40ed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它给你带来了几个好处:</p><ul class=""><li id="79f0" class="lr ls jb ka b kb kc kf kg kj lt kn lu kr lv kv lw lx ly lz bi translated">初始化中记录的显式依赖项</li><li id="97f7" class="lr ls jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">更容易推理的代码(没有全局状态)。</li><li id="d17b" class="lr ls jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">更容易放入另一个项目的库。</li><li id="efc4" class="lr ls jb ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">更多可测试的代码。</li></ul><p id="3ea4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个ReportFormatter类，它依赖于另一个单独的类来像CSVFormatter类一样工作。CSVFormatter类将数据解析为特定的结构，并将其发送给ReportFormatter。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mf"><img src="../Images/55518d62f49b9e79cb993a221de80415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IRqOvGTmNzKBJyOm_NlKw.png"/></div></div></figure><p id="ff83" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就建立了对CsvFormatter的依赖，这不是我们想要的。一种更好的方式是这样写的，它给这个类更多的灵活性:</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/286d5965b572b71c766293a42b7c6fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDKnxTW_aWBn_9okg6Dwjg.png"/></div></div></figure><p id="367e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这允许使用更改parsed_data的选项。它不再被锁定为CSVFormatter的一个实例，它将简单地使用它作为默认值。我们可以创建一个新的类，将数据解析为JSOn格式，并将其传递给我们的ReportFormatter。它允许我们在代码和测试中创造更多的灵活性。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="1c20" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后是::lookup操作符。</p><p id="9060" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块可以容纳类。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ll"><img src="../Images/4442109ed22168a9707bcf2158cf8f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWq4bujLUYWuRcoo8r_y0A.png"/></div></div></figure><p id="4e1c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我在RubyMonk上找到的一个很好的例子。这会输出，Perimeter::Array和Array。这可能是因为我们使用了命名空间。如果我们没有使用命名空间，而是使用:</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/3a6f46c929f898a91d3dfc7453476803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*PJcrhAMYkI7MYZ6Y6MT0ig.png"/></div></figure><p id="63f0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们输出应该是数组。这不是我们想要的，因为这会在整个项目中全局扩展数组类。</p><p id="a63b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">命名空间的使用允许我们只在外围模块中查找数组常量。</p><p id="abf5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自RubyMonk的最后一个例子使用查找向您展示了一个很长的模块/类列表。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mi"><img src="../Images/257c2a324ba720f44e90757d5e2f8fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPiBNJ-nJYBRpFPd3JR38g.png"/></div></div></figure><p id="ac15" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道这有点随机！但是学习经历的一部分是接触新事物并分享它们。堆栈溢出和介质节省了我很多时间。你也可能从未使用过这些工具，但是如果你真的遇到了它们，了解它们的作用是有好处的。</p><p id="41cf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">祝你好运！</p></div></div>    
</body>
</html>