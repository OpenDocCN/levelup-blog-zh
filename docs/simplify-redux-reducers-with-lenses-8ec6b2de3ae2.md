# 带透镜的简化 Redux 减压器

> 原文：<https://levelup.gitconnected.com/simplify-redux-reducers-with-lenses-8ec6b2de3ae2>

![](img/7d50e9f58a0fd0c6735c9afa344b6d6e.png)

让我们做一些清理工作；)

> 请禁用您的广告拦截器/隐私獾。否则示例代码将被禁用…

现代 JavaScript 环境有许多处理状态的方法。我们可以使用闭包或类来拥有一些共享状态，但是有时需要一个更复杂的状态管理库。一个流行的选择是 Redux 模式。

# Redux 101

如果你熟悉 Redux，你可以跳过这一步，但是简单回顾一下，这里有一个 Redux 是什么的概述。
**属性**

*   有一个状态对象
*   状态对象是不可变的
*   每一次改变都会产生状态对象新版本
*   通过调度操作发生变化，导致下面的流程

**流(在使用 thunk 的场景中)**

*   用户点击按钮
*   一个动作被分派。一个动作是一个包含一个`type`和`data`的普通对象。
*   中间件监听该动作并发出异步请求。让我们假设它成功了，然后它将分派另一个动作(`{type: LOGIN_SUCCESS, data: {accessToken: x, refreshToken: y}}`)
*   缩减器监听该动作，并将旧状态缩减为新版本的状态。(`(state, action) => ({…state, someNewStateValues })`)
*   状态被更新，并且组件可以用新状态重新呈现。

Redux 最好的一点是，它使得推断状态变得非常容易，因为所有的更改都必须经过这些步骤。然而，最大的缺点是这需要相当多的样板文件。创建`actions`和`reducers`会有很多工作，更不用说大部分 UI 状态现在应该包含在那个对象中了。因此，即使像复选框或开关这样的东西也需要经过那里，而不仅仅是在本地或服务中改变一个变量。

# 问题是

如上所述，整个 Redux 设置需要大量样板文件。有些可以用 [redux 网站](https://redux.js.org/recipes/reducing-boilerplate)上的指针还原。但是有一些东西可以进一步减少它(并在这个过程中使它变得更加清晰)。
有时，状态对象变得非常嵌套。以这个对象为例，简而言之，它描述了一个包含对象和对象组的 3d 场景。

比方说，用户需要能够向场景结构和该结构中的组添加额外的对象。这些减速器可以写成如下形式:

虽然这不一定是这段代码的最佳版本(我们可以使用一些其他的常量使其可读性更好，并使用一些函数来抽象掉一些对象突变)，但还有一些其他的事情需要更棘手地解决。

> 状态的结构越深，我们需要做的保持一切完整的对象传播就越多，代码就越复杂。

幸运的是，有一个解决方案。

# 镜头

> 镜头和一些配合使用的功能提供了一种方式:查看值，不变地设置它们，并对它们应用功能。都在一个物体内，在某个路径上。它允许你给镜头一个完整的对象(就像一个状态)并获得完整的对象，但是使用新的值集或应用的函数，无论你想要改变的值嵌套有多深。

当查看 Ramda 的[文档时(我们正在使用这个库来实现它的镜头)。有 4 件事与镜头有关，我们将使用其中的两件，`lensPath`和`lensProp`。`lensPath`功能允许您为嵌套路径创建一个镜头，而`lensProp`功能允许您为特定属性创建一个镜头。另外两个在某些情况下可能有用(尤其是`lensIndex`)，但是一旦你知道了这两个，就不难推断出来。在我们的情况下，让我们为我们的小场景中的那些对象和组制作一个镜头。](https://ramdajs.com/docs/#lens)

如果你对`compose`有疑问，我已经写了[一篇关于这个的文章](https://medium.com/@rolandpeelen/function-composition-currying-in-real-life-e74c86302205)。
指定镜头后，我们可以使用三个功能，`view`、`set`和`over`。这些允许您分别查看给定对象在镜头路径上的值，设置值，或对该值运行函数。像这样:

最好的事情是，我们不必手动传播对象！还有，`over`功能让它变得无比强大。所以让我们用透镜重写我们早期的减速器。

通过将`append`功能分解成一个函数，这样我们就可以使用`over`，我们已经能够将实际的缩减器本身减少到一行！当然，现在有一些镜头需要定义，但这意味着实际 reducer 的 switch 语句(或 lookup 对象)要简单得多。镜头甚至可以从单独的文件中导入。在第二个例子中，使用多个`lensProps`并组合它们的想法变得清晰了。在`groups`中，有`objects`，因为我们有`lensProp`用于`objects`，我们可以在那里重用它。

# 结束的

是的，redux 有一定的开销。尤其是在存在极度嵌套状态的情况下。当然，在某些情况下，尽量避免这种嵌套更好。在其他情况下，没有嵌套实际上可能会使推理对象变得更加困难。在这些情况下，使用透镜可能是有益的。