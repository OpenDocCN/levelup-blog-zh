<html>
<head>
<title>Functional Programming Concepts in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数式编程概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-programming-concepts-in-javascript-87a2d28bd2dd?source=collection_archive---------18-----------------------#2020-02-10">https://levelup.gitconnected.com/functional-programming-concepts-in-javascript-87a2d28bd2dd?source=collection_archive---------18-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c399a4adcd0fb1f0bc4ec93bbdeb9ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rSwLL9yaKFRUTavC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@mysa21?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mysaell Armendariz </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4f1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数式编程是一种编程范式，它声明我们创建计算作为函数的评估，并避免改变状态和可变数据。</p><p id="6ead" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，我们可以应用这些原则来使我们的程序更健壮，产生更少的错误。</p><p id="dff9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何在JavaScript程序中应用一些函数式编程原则，包括纯函数和创建不可变对象。</p><h1 id="3371" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">纯函数</h1><p id="4753" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">纯函数是在给定相同输入集的情况下总是返回相同输出的函数。</p><p id="b305" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该尽可能地使用纯函数，因为它们更容易测试，并且给定一组输入，输出总是可预测的。</p><p id="ce35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，纯函数不会产生任何副作用，这意味着它确实会改变函数之外的任何东西。</p><p id="3d40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数的一个例子是下面的<code class="fe mh mi mj mk b">add</code>函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="778b" class="mt lf it mk b gy mu mv l mw mx">const add = (a, b) =&gt; a + b;</span></pre><p id="b3cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数是一个纯函数，因为如果我们传入两个数字，我们将返回这两个数字相加的结果。</p><p id="07e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它在函数之外不做任何事情，也没有改变函数内部返回值的值。</p><p id="d37a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非纯函数的例子包括:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="db74" class="mt lf it mk b gy mu mv l mw mx">let x;<br/>const setX = val =&gt; x = val;</span></pre><p id="fdcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">setX</code>不是一个纯函数，因为它设置了函数之外的<code class="fe mh mi mj mk b">x</code>的值。这叫副作用。</p><p id="d697" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">副作用是在被调用函数之外观察到的状态变化，而不是它的返回值。<code class="fe mh mi mj mk b">setX</code>在函数之外设置一个状态，所以会产生副作用。</p><p id="afe0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个例子如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b9e4" class="mt lf it mk b gy mu mv l mw mx">const getCurrentDatePlusMs = (milliseconds) =&gt; +new Date() + milliseconds;</span></pre><p id="9897" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">getCurrentDatePlusMs</code>返回一个依赖于<code class="fe mh mi mj mk b">+new Date()</code>的值，这个值总是变化的，所以我们可以很容易地用测试来检查它的值。给定输入也很难预测返回值，因为它总是在变化。</p><p id="0b86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不是一个纯粹的函数，而且由于其不断变化的返回值，维护和测试也很困难。</p><p id="89b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使它更纯粹，我们应该把<code class="fe mh mi mj mk b">Date</code>对象放在外面，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0452" class="mt lf it mk b gy mu mv l mw mx">const getCurrentDatePlusMs = (date, milliseconds) =&gt; +date + milliseconds;</span></pre><p id="26ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，给定相同的日期和毫秒，我们将总是得到相同的结果。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/c80c62f7f4e3af8c2891eb84e93ad8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vDxs35N-dndvDGdh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Lauren McConachie 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="e10b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不变</h1><p id="f5e3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">不变性意味着数据一旦被定义就不能被更改。</p><p id="3d3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，原始值是不可变的，包括数字、布尔值、字符串等。</p><p id="7941" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，没有办法在JavaScript中定义一个不可变的对象。这意味着我们必须小心对待它们。</p><p id="f40c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有<code class="fe mh mi mj mk b">const</code>关键字，从名字判断应该会创建一个常量，但是没有。我们不能给它重新赋值，也不能用相同的名字重新定义一个常数。</p><p id="202b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，分配给<code class="fe mh mi mj mk b">const</code>的对象仍然是可变的。我们可以更改它的属性值，也可以删除现有的属性。可以添加或删除数组值。</p><p id="fc44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们需要一些其他的方法来使对象不可变。</p><p id="816b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，JavaScript拥有使对象不可变的<code class="fe mh mi mj mk b">Object.freeze</code>方法。它防止对象的属性描述符被修改。此外，它还可以防止使用<code class="fe mh mi mj mk b">delete</code>关键字删除属性。</p><p id="4fbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦对象被冻结，就不能撤销。为了使它再次可变，我们必须将对象复制到另一个变量。</p><p id="e4f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将这些更改应用到对象的顶层。因此，如果我们的对象有嵌套，那么它不会被应用到嵌套的对象。</p><p id="57ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以定义一个简单的递归函数来冻结一个对象的级别:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9e24" class="mt lf it mk b gy mu mv l mw mx">const deepFreeze = (obj) =&gt; {<br/>  for (let prop of Object.keys(obj)) {<br/>    if (typeof obj[prop] === 'object') {<br/>      Object.freeze(obj[prop]);<br/>      deepFreeze(obj[prop]);<br/>    }<br/>  }<br/>}</span></pre><p id="2994" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的函数遍历对象的每一层，并在其上调用<code class="fe mh mi mj mk b">Object.freeze</code>。这意味着它使整个嵌套对象不可变。</p><p id="eb28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以在操纵一个对象之前复制它。为此，我们可以使用spread运算符，该运算符适用于ES2018之后的对象。</p><p id="731c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下函数来制作对象的深层副本:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7860" class="mt lf it mk b gy mu mv l mw mx">const deepCopy = (obj, copiedObj) =&gt; {<br/>  if (!copiedObj) {<br/>    copiedObj = {};<br/>  }</span><span id="20f9" class="mt lf it mk b gy mz mv l mw mx">  for (let prop of Object.keys(obj)) {<br/>    copiedObj = {<br/>      ...copiedObj,<br/>      ...obj<br/>    };<br/>    if (typeof obj[prop] === 'object' &amp;&amp; !copiedObj[prop]) {<br/>      copiedObj = {<br/>        ...copiedObj,<br/>        ...obj[prop]<br/>      };<br/>      deepCopy(obj[prop], copiedObj);<br/>    }<br/>  }<br/>  return copiedObj;<br/>}</span></pre><p id="7ad3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个新的<code class="fe mh mi mj mk b">copiedObj</code>对象来保存复制对象的属性，如果它还不存在的话，这在第一次调用中是不应该的。</p><p id="9916" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们遍历<code class="fe mh mi mj mk b">obj</code>对象的每个属性，然后对<code class="fe mh mi mj mk b">copiedObj</code>和<code class="fe mh mi mj mk b">obj</code>应用spread操作符来复制给定级别的值。然后我们在每一层递归地这样做，直到我们通过每一层，然后我们返回最后的<code class="fe mh mi mj mk b">copiedObj</code>。</p><p id="12e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只在属性在那个级别还不存在时应用spread操作符。</p><p id="9a3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们怎么知道这行得通？首先，我们可以检查每个值的属性是否相同，如果我们对它运行<code class="fe mh mi mj mk b">console.log</code>，结果就是相同的。然后我们也可以用<code class="fe mh mi mj mk b">===</code>检查复制的对象是否与原始对象具有相同的引用。</p><p id="d59a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e6dd" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  foo: {<br/>    bar: {<br/>      bar: 1<br/>    },<br/>    a: 2<br/>  }<br/>};</span></pre><p id="e9f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过书写来检查:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="93dc" class="mt lf it mk b gy mu mv l mw mx">const result = deepCopy(obj);<br/>console.log(result);</span></pre><p id="979e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查<code class="fe mh mi mj mk b">result</code>的内容。</p><p id="3778" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ddf9" class="mt lf it mk b gy mu mv l mw mx">{<br/>  "foo": {<br/>    "bar": {<br/>      "bar": 1<br/>    },<br/>    "a": 2<br/>  }<br/>}</span></pre><p id="a002" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个和<code class="fe mh mi mj mk b">obj</code>一样。如果我们跑:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b1f1" class="mt lf it mk b gy mu mv l mw mx">console.log(result === obj);</span></pre><p id="2acc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mh mi mj mk b">false</code>，这意味着这两个没有引用同一个对象。这意味着它们是彼此的复制品。</p><p id="9b62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数和不变性是函数式编程的重要组成部分。这些概念流行是有原因的。它们使输出变得可预测，并使意外的状态变化变得更加困难。</p><p id="85ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数是可预测的，因为它们对同一组输入返回相同的输出。</p><p id="37dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不可变对象很好，因为它防止了意外的变化。JavaScript中的原始值是不可变的，但对象不是。我们可以用<code class="fe mh mi mj mk b">Object.freeze</code>方法冻结它以防止对它的修改，我们也可以用spread操作符递归地复制它。</p></div></div>    
</body>
</html>