<html>
<head>
<title>The Program’s Regress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">程序的退化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-programs-regress-c5c8bcaf6f66?source=collection_archive---------17-----------------------#2022-10-03">https://levelup.gitconnected.com/the-programs-regress-c5c8bcaf6f66?source=collection_archive---------17-----------------------#2022-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么好的软件会变坏？你能做什么来阻止它的退化？</p><p id="5454" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="#d784" rel="noopener ugc nofollow"/><br/><a class="ae kl" href="#0c0b" rel="noopener ugc nofollow">什么是回归测试？</a> <br/> <a class="ae kl" href="#b113" rel="noopener ugc nofollow">为什么产品会退化</a> <br/> <a class="ae kl" href="#fd57" rel="noopener ugc nofollow">为什么回归测试很难</a> <br/> <a class="ae kl" href="#9a68" rel="noopener ugc nofollow">回归测试的两种方法</a> <br/> ∘ <a class="ae kl" href="#5178" rel="noopener ugc nofollow">分阶段方法</a> <br/> ∘ <a class="ae kl" href="#89a4" rel="noopener ugc nofollow">选择方法</a> <br/> <a class="ae kl" href="#f470" rel="noopener ugc nofollow">回归测试最佳实践</a> <br/> <a class="ae kl" href="#7670" rel="noopener ugc nofollow">参考文献</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/387558e487d3b43a2a7c877d02aa9b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4T5574qLM6hFZIadqpc5g.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Joshua Hoehne 在<a class="ae kl" href="https://unsplash.com/s/photos/blue-screen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bde7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">软件的生命周期随着产品的发布而结束。如果该软件从此幸福地生活在一起，那将是一个童话般的结局。唉，事实上，产品以这样或那样的方式倒退，需要产品团队将资源集中在一起，要么修复bug，要么更新特性。本文的目的是找出回归的常见原因以及管理回归测试的有效方法。</p><h1 id="d784" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">两只虫子的故事</h1><p id="4b92" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设您可以在两种类型的bug之间做出选择。一个是可怕的蓝屏死机，正如你在上面看到的。另一种是类似下图的各种网站错误。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/dd61a745f5c638e34c19331f16bec396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLTPe59ewE9EtgSLdw2W-w.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae kl" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kl" href="https://unsplash.com/s/photos/web-error-message?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="149c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有人希望遇到任何类型的错误，但是如果你被迫在两种类型中选择，你会选择哪一种？想一分钟。</p><p id="0415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的选择可能与我的不同，但我宁愿选择服务错误，而不是Windows错误，因为当操作系统崩溃时，你无能为力，除了重新启动和(希望)再次登录。</p><p id="29c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果你是一名开发者，你必须在操作系统错误和网络服务器错误之间做出选择，我认为选择应该是明确的。尽管开发和维护web服务器的压力很大，但是调试和修复web服务器的错误要比在操作系统上容易得多。为什么？因为web服务器开发人员很容易就能访问到导致该错误的代码。另一方面，操作系统代码对于开发者来说是不可及的，除非通过定期的操作系统更新。当选择正确的回归测试策略时，了解这两种类型的错误之间的区别将成为一个重要的点。</p><h1 id="0c0b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是回归测试？</h1><p id="621b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">回归测试的定义是，“重新运行<a class="ae kl" href="https://en.wikipedia.org/wiki/Functional_testing" rel="noopener ugc nofollow" target="_blank">功能性</a>和<a class="ae kl" href="https://en.wikipedia.org/wiki/Non-functional_testing" rel="noopener ugc nofollow" target="_blank">非功能性测试</a>，以确保之前开发和测试的软件在变更后仍能运行。”(<a class="ae kl" href="https://en.wikipedia.org/wiki/Regression_testing" rel="noopener ugc nofollow" target="_blank">维基百科</a>)这听起来很简单，但这意味着对同一款软件进行相同的测试吗？</p><p id="d8dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不想表现得很哲学，但是没有什么是一成不变的。想想Windows操作系统是如何随着时间的推移从Windows 3.1、XP、Vista发展而来的。7、8、10和11。现在的Windows操作系统与以前的Windows有很大不同。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mg"><img src="../Images/81cbb2658741531b872919b594d77575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WeES7DPQefAMYLhj3a3QOg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Windows的演变</figcaption></figure><p id="9b38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试用例及工具怎么样？你认为他们会随着时间而改变吗？你打赌！随着软件的更新，新的测试必须被添加，原始的测试用例也必须被修改。</p><h1 id="b113" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">产品退化的原因</h1><p id="c489" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">不管是OS崩溃还是web服务故障，所有的bug都是不好的。不幸的事实是，如果运行回归测试，许多错误都是可以避免的。简单地说，回归测试是为了确保所有以前的功能和特性仍然工作而设计的测试。然而，管理和运行回归测试是困难的，至少有四个原因。</p><p id="0cfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，也是最重要的，产品发生了变化。所有软件变更。任何复杂的软件都包含一些缺陷，必须修复或修改这些缺陷以满足客户的新需求。或者增加新的功能来吸引新的用户群。唯一不变的软件是过时的。即使软件本身没有改变，它的依赖关系也会更新，这就相当于把地毯(软件)拖到它的脚下。</p><p id="862a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二，需求变化。一个程序发布后，会发生很多事情。用户变化的人口统计、预期的市场需求不存在、新法规可能被实施等等。这些变化总是导致重新检查软件的需求。因此，我们需要改变现有测试用例的期望。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mh"><img src="../Images/db456f6851ca33a01597b987bbab77a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6Ebw_iGh5L8GlDl2cHHZg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">在<a class="ae kl" href="https://unsplash.com/s/photos/software?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kl" href="https://unsplash.com/@austindistel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</figcaption></figure><p id="eff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三，数据变化。即使程序本身不处理任何数据库，数据也可以以不同的形式出现。除了数据库数据，用户输入、来自另一个服务的参数、来自设备的传感器数据、文件和流都是程序必须处理的数据形式。根据时间、日期、季节和地点的不同，数据经常会发生巨大的变化。随着数据的改变或迁移，软件以及回归测试也将随之改变。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mi"><img src="../Images/f8c18b0e5f1350c4122f4beb1d4c6afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geEUTANhEQ14I8euv60rSA.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae kl" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ee31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四，硬件的变化。更大的空间、更快的速度、更好的分辨率或新的外形都是升级硬件的不同理由。随着硬件的变化，固件和软件也需要更新，回归测试也在进行中。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mj"><img src="../Images/2d53ac4138b22085cc78db7be3566378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VG96_sDd5LjmlwQy0WZLlQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/@christianw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Christian Wiediger </a>在<a class="ae kl" href="https://unsplash.com/s/photos/hardware?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="fd57" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么回归测试很难</h1><p id="d51e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">所有这些变化给回归测试带来了两个问题。首先，测试用例及工具需要不断更新。问题是这些测试用例及工具并不属于个人或团队。除非有一个独立的持续工程团队来维护它们，否则一个特性团队的所有涉众(PM、dev和test)都需要参与进来。</p><p id="e03f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二，无论何时发生任何变化，都应该执行所有的回归测试用例，以确保没有回归。如果测试用例的数量不是很大，并且都是自动化的，那么运行一次完整的测试就不是问题。然而，总的来说，全面测试需要大量的资源和时间投入。</p><h1 id="9a68" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">回归测试的两种方法</h1><p id="4726" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">根据团队采用的软件开发生命周期的类型，有两种回归测试的方法。</p><h2 id="5178" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">分阶段方法</h2><p id="9407" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">第一种方法是我称之为“分阶段”的方法，在这种方法中，您在分层的阶段中运行一组测试。典型的CI/CD管道有三个阶段:开发、测试和生产。它们对应三种不同的测试环境。回归测试在管道的所有阶段运行。理想的测试结构是一个金字塔，其中单元测试比集成测试和端到端测试多得多。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/0e12b882d76b6af6ca5e3df3a70e3b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*nrnz-KgAZlT2LLGu.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">测试金字塔</figcaption></figure><p id="df18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法是所有的功能问题，包括边缘案例，都包含在单元测试中。这是非常理想的，因为在单元测试中，所有的依赖项都被假定为是“模拟的”,因此它们可以在一个隔离的环境中非常快速和可靠地运行。</p><p id="58bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在集成测试阶段，只运行集成测试用例，这些用例检查与其他组件的集成。通常，依赖组件是通过API调用来调用的。它们的数量可以而且应该更少，因为集成测试是在具有其他依赖项的测试环境中运行的，因此可靠性更低，耗时更长。您不希望在集成测试中检查功能问题。</p><p id="6637" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最终的端到端测试中，甚至有更大的依赖，如UI或接近真实的服务依赖。由于高碎片化和不可靠性，测试用例的数量需要比集成测试更少。</p><p id="cb95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在CI/CD管道中，所有的回归测试都是运行的，但是它们是自动运行的，并且是分阶段运行的，因此所需的资源和时间得到了管理。如果它们不是自动化的，而是分阶段的，那么您仍然可以使用相同的分阶段方法。如果在早期阶段(例如，单元测试阶段)发现了任何bug，那么只运行几个选定的测试，这样您就节省了运行其他测试的时间，这些测试会更加耗时和消耗资源。</p><h2 id="89a4" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">选择方法</h2><p id="004a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">第二种策略是“选择”方法，在这种方法中，您仔细地只选择与代码变更相关的测试用例。显然，如果您知道哪些测试用例是相关的，那么您应该选择选择性方法。问题是你不能总是知道哪些是相关的。要知道哪些是相关的，你需要额外的信息。</p><p id="c742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种流行的方法是考虑您之前运行的代码覆盖率信息。代码覆盖率和测试用例之间的关联是基于之前运行的测试的。例如，您可以喜欢一个文件或一个行号所命中的测试用例的数量。然后，如果某一行发生了变化，您可以进行反向查找，找到一组最有可能与引入的代码变化相关的测试用例。</p><p id="7a84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了优化测试执行，选择方法需要分三步实现。第一步是测试套件最小化，其中重复和重叠的测试用例被删除或合并。第二步是我们刚刚描述的测试用例选择步骤。在最后一步中，您想要对所选择的测试用例进行优先级排序，以便更重要的测试用例能够首先运行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mx"><img src="../Images/afeadade24451e991a0bc76f6752eeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FZXqGSo46GnOHCUECU-aw.png"/></div></div></figure><p id="4eec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会问为什么测试用例优先级排序的最后一步是必要的。仅仅选择测试用例还不够吗，因为重点是针对给定的代码变更运行所有相关的测试用例？你不想错过任何重要的案子，对吧？测试覆盖是重要的，但是如果没有优先级，你可能会在遇到一个关键的bug之前浪费时间运行不重要的测试用例。例如，如果代码更改涉及到安装的更改，那么您希望在检查功能问题之前首先运行相关的设置场景。如果您甚至不能安装一个组件，那么运行功能测试或检查文档是没有意义的。</p><p id="a80e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这两种方法中，选择方法似乎更可取，因为如果您选择了正确的测试用例，您可以显著减少测试执行资源。然而，实际上，这种选择方法并不总是奏效，原因有二。首先，只有当您已经有了现有的测试用例并且有了历史记录，测试用例关联表才能被构建。如果代码变更是全新的，您将没有相关的测试用例，因此您没有测试用例可供选择。第二，虽然您可以基于代码覆盖率、需求、相似性等来构建测试用例相关表。，只有在依赖关系明确的情况下，它才能相对较好地工作。换句话说，如果您的代码变更是在您有测试用例的测试下的一个组件中，您可以选择它们。但是，如果更改发生在依赖关系之一(例如，库、操作系统、驱动程序等)中。)，那么关系不是很清楚，因此不会有任何匹配的测试用例。</p><p id="4b42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这些原因，在许多特性团队中，回归测试大部分是由测试专家完成的，他们非常了解领域，并且在测试服务方面有丰富的经验。然而，近年来，有人试图用机器学习来取代人类专家。[2]</p><h1 id="f470" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">回归测试最佳实践</h1><p id="c69d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">最后，这里是管理和运行回归测试的最佳实践。</p><ol class=""><li id="4185" class="my mz iq jp b jq jr ju jv jy na kc nb kg nc kk nd ne nf ng bi translated"><strong class="jp ir">为测试用例分配优先级:</strong>在写测试用例的时候，总是要分配一个优先级。当你只有有限的时间时，这样做将允许过滤测试用例，而这恰好是生产团队的大部分时间。划分优先级也有助于在分类时评估bug的严重性。</li><li id="3fb4" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir">使用分阶段的方法:</strong>不管你的管道是否是CI/CD，总是以这样一种方式排列你的测试用例的优先级，最相关和最重要的测试用例首先运行。即使你没有管道，做分阶段的方法也会节省你大量的资源和时间。</li><li id="4bef" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir">为每一个bug创建一个测试用例:</strong>对于发现的每一个bug，让它成为团队中的习惯和强制规则，创建一个回归测试用例。在每个相关的阶段都这样做。对于一个足够复杂的服务，没有一个产品团队能够拥有完整的测试覆盖，所以在产品中发现的bug是不可避免的。重要的是要记住通过为每个bug创建回归测试来增加测试覆盖率。</li></ol><p id="ed60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/The_Pilgrim%27s_Progress" rel="noopener ugc nofollow" target="_blank">约翰·班扬的《天路历程》据说是有史以来最重要的基督教小说。它讲述了基督徒走向天堂之城的旅程。然而，他所取得的进步被无数的挫折所破坏，但最终，他到达了目的地。</a></p><p id="390f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，这篇文章的标题是向著名的天堂发展的故事致敬。但更重要的是，它描绘了一个类似于《天路历程》中基督徒的旅程。如果一个程序要在第一个初始发布生命周期之后继续存在，那么只要它还存在，就需要更新和维护。回归测试是提供重要生命支持的最重要方法之一。</p><p id="222d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“那些不了解历史的人注定会重复历史。”—乔治·桑塔亚纳</p><h1 id="7670" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">参考</h1><p id="b929" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">[1] <a class="ae kl" href="https://medium.com/analytics-vidhya/regression-test-case-selection-using-machine-learning-241ded86f559" rel="noopener"> Kush Bhatnagar (2020)，利用机器学习选择回归测试用例</a>。分析Vidhya。</p><p id="d917" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2] <a class="ae kl" href="https://arxiv.org/abs/2106.13891" rel="noopener ugc nofollow" target="_blank">潘荣琦等。艾尔。(2021)，使用机器学习的测试用例选择和优先化:系统的文献综述</a>。arXiv。</p><p id="9041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3] <a class="ae kl" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2009/01/Test_Suite_Clustering_MS_paper.pdf" rel="noopener ugc nofollow" target="_blank"> Vipindeep Vangala等。艾尔。(2009)，使用程序概要和静态执行的测试用例比较和聚类</a>。微软研究院。</p><p id="ea0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[4] <a class="ae kl" href="http://opera.ucsd.edu/paper/fse11.pdf" rel="noopener ugc nofollow" target="_blank">尹等(2011)，补丁如何变成bug？:对商业和开源操作系统中错误修复的综合特征研究</a>。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="5550" class="lc ld iq bd le lf nt lh li lj nu ll lm ln nv lp lq lr nw lt lu lv nx lx ly lz bi translated">分级编码</h1><p id="5e42" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="e97d" class="my mz iq jp b jq jr ju jv jy na kc nb kg nc kk ny ne nf ng bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="b256" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk ny ne nf ng bi translated">📰查看<a class="ae kl" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="9d04" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk ny ne nf ng bi translated">🔔关注我们:<a class="ae kl" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kl" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kl" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="1a80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae kl" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>