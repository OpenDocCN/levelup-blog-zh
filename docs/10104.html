<html>
<head>
<title>Tech Characteristics of a React Native App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React原生应用的技术特征</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tech-characteristics-of-a-react-native-app-756ba40e7af5?source=collection_archive---------13-----------------------#2021-10-26">https://levelup.gitconnected.com/tech-characteristics-of-a-react-native-app-756ba40e7af5?source=collection_archive---------13-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fa9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您自己的应用程序中使用的指示性列表</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5fe4f79f92c3f272a9d61271273e7e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mifT0ak40PAWBjQuz5oGHQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3325080" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><h1 id="02f5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="338f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这个故事中，我给出了我在<a class="ae le" href="https://www.wheelrun.biz/" rel="noopener ugc nofollow" target="_blank">我自己的React原生应用</a>中介绍的技术特征列表。你也可以考虑在自己的应用程序中使用。</p><h1 id="9aad" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">三层架构</h1><p id="0f59" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我决定采用三层架构，如下图所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/cdef3e7a59de5295bf6a7139e07c9ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*0pd-UA1CgAM-AXcoaMDWTQ.png"/></div></figure><p id="19db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我谈论的是一个网络化的React本地应用程序。为了运行它，需要网络存在。</p><h1 id="2a3c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">GraphQL</h1><p id="f269" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">与API服务器的通信是使用GraphQL完成的。</p><h2 id="95a8" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">GraphQL客户端</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/66a191a65a4c972acad9c67fa1586424.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*p2pxtYRK7wOrwmL27rYNRg.png"/></div></figure><p id="18fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我需要使用任何特殊的库来构建我的GraphQL查询吗？</p><p id="1f10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不，我没有。我使用标准的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取</a> JavaScript库。然而，你可能想考虑使用<a class="ae le" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo GraphQL客户端</a>库。我没有使用它，因为我发现它对我的情况来说相当复杂，并且我希望对我的GraphQL查询的构造和处理有更多的控制。</p><h2 id="356e" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">GraphQL服务器</h2><p id="0477" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在服务器端，我使用Ruby和gem <a class="ae le" href="https://graphql-ruby.org/" rel="noopener ugc nofollow" target="_blank"> graphql </a>。根据您将决定采用的服务器技术，您可以选择最好的库来合并。GraphQL官方网站<a class="ae le" href="https://graphql.org/code" rel="noopener ugc nofollow" target="_blank">列出了您偏好的服务器技术的编程语言的各种选项。</a></p><h1 id="f748" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">WebSockets应用更新</h1><p id="543c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我发现当后台有事情发生时，应用程序的状态被即时更新是非常重要的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8e133feb0d80df4e94e88e891614cc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*IcmF-focetkHNAT0rwkrqw.png"/></div></figure><p id="e930" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用来将状态变化从服务器传播到移动应用程序的技术是<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" rel="noopener ugc nofollow" target="_blank"> WebSockets </a>。</p><p id="95c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，当应用程序启动时，它连接到WebSockets服务器并订阅一系列通道。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4b59af95537be2f70b42d5af21656daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*9GJGglyxoHh1l-lYyrsPLw.png"/></div></figure><h2 id="8cc3" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">WebSockets服务器</h2><p id="0808" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如您所见，我为WebSockets使用了不同的服务器。不是GraphQL API的那个。它是在Go中实现的专用服务器。特别是，我使用<a class="ae le" href="https://docs.anycable.io/anycable-go/getting_started" rel="noopener ugc nofollow" target="_blank"> AnyCable-Go </a>。AnyCable-Go是一个用于AnyCable的WebSockets服务器(见下一段)。</p><h2 id="b420" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">WebSockets客户端</h2><p id="061c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">对于WebSockets客户端，我使用包<a class="ae le" href="https://www.npmjs.com/package/action-cable-react-jwt" rel="noopener ugc nofollow" target="_blank"> action-cable-react-jwt </a>。这是一个JavaScript库，通过WebSockets实现了<a class="ae le" href="https://docs.anycable.io/misc/action_cable_protocol" rel="noopener ugc nofollow" target="_blank"> ActionCable </a>协议。</p><h2 id="bc76" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">WebSockets注释</h2><p id="b526" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">结合WebSockets技术可能具有挑战性，这取决于您决定采用的服务器和客户端协议。您可能想考虑将这一负担交给第三方服务，如<a class="ae le" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank"> Pusher </a>或<a class="ae le" href="https://onesignal.com/" rel="noopener ugc nofollow" target="_blank"> OneSignal </a>。</p><h1 id="440a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">媒体服务器</h1><p id="0576" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我的React本地应用程序大量使用媒体、图像和视频。用户生成的内容。</p><p id="af06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了减轻主API服务器处理和提供媒体内容的负担，我决定使用<a class="ae le" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>集成。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/59fe30c80b5bcda0b2695ccee578a756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*SCltsmRsiz_IAGz1QFQklw.png"/></div></figure><p id="6a9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上图可以看出，React原生应用直接与Cloudinary服务器对话。然后，它使用API服务器来存储和获取媒体的URL。因此，API服务器是卸载的，并且不处理媒体本身。</p><h1 id="84d2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">后台作业</h1><p id="190e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我确保任何耗时的处理任务都由后台作业执行。例如，发送电子邮件。我使用<a class="ae le" href="https://sidekiq.org/" rel="noopener ugc nofollow" target="_blank"> Sidekiq </a>和<a class="ae le" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>进行后台作业的存储和处理。</p><h1 id="0f6a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">SMTP服务器</h1><p id="73a5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">对于我的SMTP服务器，我使用<a class="ae le" href="https://sendgrid.com/" rel="noopener ugc nofollow" target="_blank"> SendGrid </a>。但是，还有许多其他好的替代方案，比如邮戳。</p><p id="f8fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于您的交易电子邮件，我的建议是使用SMTP服务器，它允许您定义和使用动态内容电子邮件模板。<a class="ae le" href="https://sendgrid.com/solutions/email-api/dynamic-email-templates/" rel="noopener ugc nofollow" target="_blank"> SendGrid在这里支持这个特性</a>。</p><h1 id="a40b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">社交登录</h1><p id="9ed0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">除了标准的电子邮件/密码功能，我决定提供社交登录功能。特别是，我已经决定去谷歌和苹果签到。</p><p id="394a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">重要提示:</strong>如果你决定实现社交登录，你至少要实现苹果登录。否则，你的申请不会被苹果批准。</p><h2 id="2d7e" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">使用Google登录</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/adab44513c5b38969b76b2658c60190d.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*M67bBIPKkg17ckRDdROwKg.jpeg"/></div></figure><p id="9042" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在客户端，有一个React本地库，它可以很好地将你的应用程序与Google Sign In集成。它就是<a class="ae le" href="https://www.npmjs.com/package/@react-native-google-signin/google-signin" rel="noopener ugc nofollow" target="_blank">@ react-native-Google-sign in/Google-sign in</a>包。</p><p id="4ffa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经决定使用客户端登录，但也在服务器端确认谷歌登录令牌。只有在我确认了提供给后端服务器的身份验证令牌是有效的之后，我才使用从Google登录过程中获得的用户信息。</p><p id="f646" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在服务器端，自从我使用Ruby以来，我已经集成了gem <a class="ae le" href="https://github.com/google/google-id-token/" rel="noopener ugc nofollow" target="_blank"> google-id-token </a>。</p><p id="b2f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:我不得不在这里<a class="ae le" href="https://github.com/pmatsinopoulos/google-id-token" rel="noopener ugc nofollow" target="_blank">派生这个gem</a>和<a class="ae le" href="https://github.com/pmatsinopoulos/google-id-token/commit/2ecc89a974d3724b502eff8fdab5eeab8762a5bd" rel="noopener ugc nofollow" target="_blank">创建一个commit </a>，这将允许我使用最新的<a class="ae le" href="https://github.com/jwt/ruby-jwt" rel="noopener ugc nofollow" target="_blank"> jwt </a> gem。</p><h2 id="98e0" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">登录Apple</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/922fda146f2cb60f47822710c347af98.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*JATmnNNbe5_EMblVwONHbQ.jpeg"/></div></div></figure><p id="482a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在客户端，我用的是React Native<a class="ae le" href="https://www.npmjs.com/package/@invertase/react-native-apple-authentication" rel="noopener ugc nofollow" target="_blank">@转化酶/React-Native-apple-authentic ation</a>，也真的很牛逼。</p><p id="9684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，客户端生成的苹果令牌被发送到服务器，我进行服务器端验证。我用的是宝石<a class="ae le" href="https://rubygems.org/gems/apple_id_token" rel="noopener ugc nofollow" target="_blank"> apple_id_token </a>。</p><h2 id="3b42" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">创建用户帐户时要小心</h2><p id="eb5d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">成功社交登录后，在您的数据库中创建用户帐户时，请确保您始终如一地处理用户的电子邮件。例如，用户可能决定某一天使用标准电子邮件和密码帐户创建一个帐户，第二天使用他们的社交登录来登录。这意味着当用户使用社交网站登录时，您需要确保首先尝试查找他们是否已经拥有帐户。</p><p id="8cf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户帐户的创建，尤其是当你的应用程序提供各种注册/登录方法时，可能是相当复杂的。它需要仔细设计，并且您需要确保同一用户不会在您的应用程序中创建不同的帐户。</p><h1 id="dbe6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">证明</h1><p id="6f40" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">应用程序和后端服务器之间的查询和变化需要进行身份验证。换句话说，对于每个请求，我需要有一种方法来识别当前登录的用户。</p><p id="a14b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用值为<code class="fe na nb nc nd b">Bearer &lt;authentication_token&gt;</code>的HTTP头<code class="fe na nb nc nd b">Authorization</code>来做这件事。每个需要认证的请求都有这个头。用户每次登录时都会生成<code class="fe na nb nc nd b">&lt;authentication_token&gt;</code>。是一个<code class="fe na nb nc nd b">JWT</code>令牌。JWT规范是一种使用各种算法对请求进行加密签名的技术。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/c1660402209b63e5dcae1065718e1ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*25ilUAQ3oRK3ldCKc_jbgw.png"/></div></figure><h1 id="370f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用户和工作区</h1><p id="bee9" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我发现对于同一个用户来说，能够加入多个工作空间是一个非常酷和重要的特性。</p><p id="0689" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了支持这个特性，我实现了这样一个模型:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ad88b75967adba4c6c5ca64b26ee8a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*ZgiKKkkDjDvcdjYws8Z7rw.png"/></div></figure><p id="0b26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，用户可以属于一个或多个工作空间。用户注册后，我会创建该用户所属的第一个工作区，并将该用户附加到这个工作区。这是他们的默认工作空间。</p><p id="beab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我想对模型更精确一点，我已经在用户和工作空间之间创建了一个关联模型。像这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/7d5d63c8f6cca8dcf1fa058c3e019226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-800uyLfrP_CTDyknZlhQ.png"/></div></div></figure><p id="297b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个关联模型非常重要，因为它允许我根据当前登录的工作空间来调整用户的行为。</p><p id="aa5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户可以通过应用程序主菜单中的中心选项从一个工作区切换到另一个工作区。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/740f9d66b890a43086c15d96e1594324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkXTB76epRWSp82EVl93ig.jpeg"/></div></div></figure><p id="7bb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">跟踪最后登录的工作区很重要，这样当用户重新登录时就可以自动切换到那个工作区。</p><p id="5d23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也意味着，在用户登录之后，我需要作为HTTP响应的一部分发送回最后登录的工作区。</p><h1 id="b468" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">批准</h1><p id="49bc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">除了识别登录的用户和他们当前的工作空间，我还需要找出用户在工作空间中扮演什么角色。</p><p id="8563" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我有一个我称之为Role的模型，我将它与UserWorkspace进行多对多的关联。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/366b64ce4a4f59ac122732386423d5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LG-rnXwLwQWjJReXddCNpw.png"/></div></div></figure><p id="4b87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的数据模型允许我根据用户所属的工作空间给同一个用户不同的角色。</p><p id="2dbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于管理角色和授权用户，我还得到了Ruby世界中两个非常流行的宝石的帮助。<a class="ae le" href="https://rubygems.org/gems/cancancan" rel="noopener ugc nofollow" target="_blank">灿灿</a>宝石和<a class="ae le" href="https://rubygems.org/gems/rolify" rel="noopener ugc nofollow" target="_blank">罗利弗</a>宝石。</p><h1 id="1efb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">局部存储器</h1><p id="ccb8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我使用手机设备本地存储最少的应用程序和用户相关信息。特别是，我使用了包<a class="ae le" href="https://www.npmjs.com/package/@react-native-async-storage/async-storage" rel="noopener ugc nofollow" target="_blank">@ react-native-async-storage/async-storage</a>，它隐藏了Android和iOS在本地存储管理方面的差异。</p><h1 id="cc60" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">应用程序状态—反应还原</h1><p id="748f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我使用<a class="ae le" href="https://www.npmjs.com/package/react-redux" rel="noopener ugc nofollow" target="_blank"> React-Redux </a>来建模和管理应用程序状态。我相信redux使得对应用程序状态的内容进行建模和管理变得非常容易。</p><p id="0c2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用动作和减速器，就像这里的文档中描述的一样:<a class="ae le" href="https://redux.js.org/usage/structuring-reducers/structuring-reducers" rel="noopener ugc nofollow" target="_blank">结构化减速器</a>。</p><h1 id="76f8" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">唯一设备Id</h1><p id="ae90" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我使用包<a class="ae le" href="https://www.npmjs.com/package/react-native-device-info" rel="noopener ugc nofollow" target="_blank"> react-native-device-info </a>，以便获得设备的唯一id。</p><p id="f2f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设备的唯一id对我来说相当有用。当用户登录时，我也会注册他们登录的设备。此外，每个进入API服务器的请求在头中都有设备id。因此，用户可以从不同的设备登录，服务器知道请求来自哪个设备。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/07cd4c280cbbf5ea8b64f389999df3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*0z-1v13PVXLRBnYthDaCTA.png"/></div></figure><p id="18f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这允许我将更新信息仅推回到我必须推回的设备。例如，如果用户Panos M .从他的iPhone上传图像，同时也从iPad登录，服务器仅向iPad设备推送更新，以便iPad应用程序状态与iPhone应用程序状态保持同步。</p><h1 id="667c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">样式组件</h1><p id="3362" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我使用<a class="ae le" href="https://www.npmjs.com/package/styled-components" rel="noopener ugc nofollow" target="_blank"> styled-components </a>库来创建带有样式的组件。这真的很强大，也确保了我的组件代码是干净的。</p><h1 id="ac5e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">反应导航</h1><p id="8616" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">对于应用程序不同屏幕之间的用户导航，我使用<a class="ae le" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> React Navigation Native </a>。</p><p id="0058" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该应用程序的导航非常简单(至少目前如此)。我使用两个专门工作的堆栈导航器:</p><ol class=""><li id="23f7" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated">用户未登录时屏幕的堆栈导航器。</li><li id="91cf" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">用户登录时屏幕的堆栈导航器。</li></ol><p id="9fb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，组件代码或多或少是这样的:</p><pre class="kp kq kr ks gt nw nd nx ny aw nz bi"><span id="0c15" class="mj lg it nd b gy oa ob l oc od">{isLoggedIn &amp;&amp; &lt;Stack.Navigator ...&gt; ... &lt;/Stack.Navigator&gt;}<br/>{!isLoggedIn &amp;&amp; &lt;Stack.Navigator ...&gt; ... &lt;/Stack.Navigator&gt;}</span></pre><p id="b88f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，用户登录时的堆栈导航器有不同的屏幕，但它也有一个带选项卡屏幕的选项卡导航器。所以，就像下面这样:</p><pre class="kp kq kr ks gt nw nd nx ny aw nz bi"><span id="e235" class="mj lg it nd b gy oa ob l oc od">&lt;Stack.Navigator ...&gt;<br/>   &lt;Stack.Screen component={MyTabNavigator}.../&gt;<br/>   &lt;Stack.Screen ...&gt;<br/>...<br/>&lt;/Stack.Navigator&gt;</span></pre><p id="080c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的<code class="fe na nb nc nd b">MyTabNavigator</code>是这样的:</p><pre class="kp kq kr ks gt nw nd nx ny aw nz bi"><span id="71cf" class="mj lg it nd b gy oa ob l oc od">&lt;Tab.Navigator ...&gt;<br/>  &lt;Tab.Screen .../&gt;<br/>  &lt;Tab.Screen .../&gt;<br/>...</span><span id="67af" class="mj lg it nd b gy oe ob l oc od">&lt;/Tab.Navigator&gt;</span></pre><h1 id="f857" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">深层链接</h1><p id="b05f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">React导航支持深度链接，真的很酷。</p><p id="6625" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，您像这样定义一个配置:</p><pre class="kp kq kr ks gt nw nd nx ny aw nz bi"><span id="08ad" class="mj lg it nd b gy oa ob l oc od">const linking = {<br/>    prefixes: ['myapp://'],<br/>    config: {<br/>      screens: {<br/>        ActivateYourAccount: 'users/signup/confirmemail/:code/:email',<br/>        EditCustomer:<br/>          'customers/:id',<br/>        EditInvoice:<br/>          'invoices/:id',<br/>        PasswordReset: 'users/password/reset/:code/:email',        <br/>      },<br/>    },<br/>  };</span></pre><p id="cb94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，将它作为值传递给<code class="fe na nb nc nd b">NavigationContainer</code>:</p><pre class="kp kq kr ks gt nw nd nx ny aw nz bi"><span id="8596" class="mj lg it nd b gy oa ob l oc od">&lt;NavigationContainer linking={linking}&gt;<br/>  &lt;StackNavigator...&gt;</span><span id="47b1" class="mj lg it nd b gy oe ob l oc od">...<br/>&lt;/NavigationContainer&gt;</span></pre><p id="26df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在如何定义深层链接、它们如何是动态的以及如何解析任何查询参数方面有很大的灵活性。在<a class="ae le" href="https://reactnavigation.org/docs/deep-linking" rel="noopener ugc nofollow" target="_blank">深度链接指南</a>中有更多关于这个的信息。</p><h1 id="2fec" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">推送通知</h1><p id="60cd" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">对于移动推送通知，我决定使用<a class="ae le" href="https://onesignal.com/" rel="noopener ugc nofollow" target="_blank"> OneSignal </a>，尽管还有很多其他选择。</p><p id="ad6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">推送通知的客户端使用React Native OneSignal库进行处理，即<a class="ae le" href="https://www.npmjs.com/package/react-native-onesignal" rel="noopener ugc nofollow" target="_blank"> react-native-onesignal </a>。我使用允许我的应用程序接收推送通知的最低配置。</p><p id="eec2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在服务器端，我使用我围绕<a class="ae le" href="https://documentation.onesignal.com/docs/onesignal-api" rel="noopener ugc nofollow" target="_blank"> OneSignal REST API </a>开发的定制库包装器发送推送通知。</p><p id="4903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OneSignal功能非常丰富。我用它来发送包括文本、图像和启动网址的通知。</p><h1 id="93ac" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">反应原生纸</h1><p id="41c3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我需要一套React本地组件来帮助我引导应用程序。我选择了<a class="ae le" href="https://callstack.github.io/react-native-paper/" rel="noopener ugc nofollow" target="_blank"> React原生纸</a>。</p><p id="4c99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是React本地组件的丰富库，如按钮、头像、标签等</p><p id="39f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的建议是，如果你决定像这样使用一个库，试着在你自己的包装组件中包装所有你使用的第三方库组件。因此，您的应用程序将使用您自己的组件，而不是直接对本机纸张组件做出反应。使用这种技术，如果您决定要这样做，那么更改/切换到另一个组件库将会容易得多。</p><p id="e2c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，下面这段代码将React Native Paper <code class="fe na nb nc nd b">Caption</code>组件包装到我自己的<code class="fe na nb nc nd b">Caption</code>组件中:</p><pre class="kp kq kr ks gt nw nd nx ny aw nz bi"><span id="8c41" class="mj lg it nd b gy oa ob l oc od">import <strong class="nd iu"><em class="of">React </em></strong>from 'react';<br/>import {<strong class="nd iu"><em class="of">Caption </em></strong>as RNPCaption} from 'react-native-paper';<br/><br/>const Caption = props =&gt; {<br/>  return &lt;RNPCaption {...props}&gt;{props.children}&lt;/RNPCaption&gt;;<br/>};<br/><br/>export default Caption;</span></pre><p id="6f20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，在我的应用程序的其余部分，每当我想使用一个<code class="fe na nb nc nd b">Caption</code>，我从我自己的文件导入，而不是从<code class="fe na nb nc nd b">react-native-paper.</code></p><h1 id="2f48" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">反应原生矢量图标</h1><p id="71e5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">React Native Paper有许多组件需要使用<a class="ae le" href="https://github.com/oblador/react-native-vector-icons" rel="noopener ugc nofollow" target="_blank">react-Native-vector-icons</a>。这是一个非常酷的库，因为它允许你使用一个非常大的图标列表，这些图标来自著名的库，比如FontAwesome、Ionicons、MaterialCommunityIcons等等。该项目还有一个非常有用的页面，你可以浏览它支持的所有图标。</p><h1 id="e87b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">日期时间选择器</h1><p id="be2f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">允许用户选择日期和/或时间是非常常见的用户体验情况。</p><p id="49ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我选择了<a class="ae le" href="https://www.npmjs.com/package/@react-native-community/datetimepicker" rel="noopener ugc nofollow" target="_blank">@ react-native-community/datetime picker</a>。这是一个React Native datetime picker组件，在Android和iOS上都能很好地工作。</p><h1 id="3143" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">快速图像</h1><p id="7ce7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我的应用程序大量使用图像。我想找到一种方法来缓存图像，直到它们被改变。React Native <code class="fe na nb nc nd b">Image</code>组件像浏览器一样缓存图像，但用户遇到了各种问题，如闪烁、缓存缺失等。<a class="ae le" href="https://www.npmjs.com/package/react-native-fast-image" rel="noopener ugc nofollow" target="_blank"> react-native-fast-image </a>组件在解决这些问题上表现出色。</p><h1 id="9b9e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">图像裁剪选择器</h1><p id="7686" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我在应用程序中引入的下一个与图像相关的功能是，用户可以在上传之前裁剪图像。</p><p id="4cf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用包<a class="ae le" href="https://www.npmjs.com/package/react-native-image-crop-picker" rel="noopener ugc nofollow" target="_blank">react-native-image-crop-picker</a>。这个库允许用户上传图像和视频。从电话的照片/视频库中或者使用照相机。</p><h1 id="78a3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">图像缩放查看器</h1><p id="c486" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我发现用户能够放大他们上传到我的应用程序的照片非常有用。为此，我使用了包<a class="ae le" href="https://www.npmjs.com/package/react-native-image-zoom-viewer" rel="noopener ugc nofollow" target="_blank">react-native-image-zoom-viewer</a>。</p><h1 id="566d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">随机图像</h1><p id="ac88" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">应用程序UX设计严重依赖于图像的存在。不然看起来很丑。然而，这些图像需要由用户上传。</p><p id="4dae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在用户上传他们自己的图片之前，我一直使用随机图片，这些图片是我根据具体情况从两个不同的地方收集的:</p><ul class=""><li id="764f" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn og no np nq bi translated"><a class="ae le" href="https://loremflickr.com/" rel="noopener ugc nofollow" target="_blank"> LoremFlickr </a>。我用它来获得各种物体类型的随机图像。试试这里的这个链接:【https://loremflickr.com/320/240/car?random=1】T4。你会得到一个随机的汽车图像。很酷的一点是，对于相同的对象和随机查询参数值，您将获得相同的图像，这对缓存非常有用。</li><li id="980d" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn og no np nq bi translated"><a class="ae le" href="https://randomuser.me/" rel="noopener ugc nofollow" target="_blank">随机用户生成器</a>。这提供了一个API(<a class="ae le" href="https://randomuser.me/api" rel="noopener ugc nofollow" target="_blank">https://randomuser.me/api</a>)，它返回随机的用户数据，包括一张图片。同样，对缓存有用的是，API允许您传递带有您控制的值的<code class="fe na nb nc nd b">seed</code>查询参数，因此为相同的<code class="fe na nb nc nd b">seed</code>值返回相同的数据。</li></ul><h1 id="30d2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">反应本机版本号</h1><p id="892e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">告知用户他们正在使用的应用程序的当前版本是非常有用的。以一个<em class="of">关于</em>的屏幕为例。为了获得应用版本号和编译号，我使用了库<a class="ae le" href="https://www.npmjs.com/package/react-native-version-number" rel="noopener ugc nofollow" target="_blank">react-native-version-number</a>。</p><h1 id="e1d9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">其他有用的JavaScript库</h1><p id="771f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这里值得一提的其他一些有用的库有:</p><h2 id="c68e" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">数组移动</h2><p id="6a31" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated"><a class="ae le" href="https://www.npmjs.com/package/array-move" rel="noopener ugc nofollow" target="_blank">数组移动</a>允许我将对象从一个数组位置移动到另一个。</p><h2 id="2deb" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">洛达什</h2><p id="356c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我使用<a class="ae le" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>库主要是为了<a class="ae le" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">去抖()</a>函数。去抖确保作为对用户动作的响应而被调用的函数不会被调用两次，例如，作为双击的结果。</p><h1 id="934f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">调试工具</h1><h2 id="d284" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">鳍状肢</h2><p id="2a53" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了调试，我经常使用<a class="ae le" href="https://github.com/facebook/flipper" rel="noopener ugc nofollow" target="_blank">脚蹼</a>。这是非常容易使用，并有很多功能。它可以使用各种插件进行扩展。</p><h2 id="c407" class="mj lg it bd lh mk ml dn ll mm mn dp lp kb mo mp lt kf mq mr lx kj ms mt mb mu bi translated">Redux Flipper</h2><p id="b7a3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">因为我正在使用Redux，我发现<a class="ae le" href="https://www.npmjs.com/package/redux-flipper" rel="noopener ugc nofollow" target="_blank"> redux-flipper </a>插件非常有用。它允许我看到应用程序状态如何从一个动作变化到下一个动作。</p><h1 id="7326" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">监控应用程序稳定性和崩溃报告</h1><p id="fd5e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了监控应用程序的稳定性和获得崩溃报告，我决定集成<a class="ae le" href="https://www.bugsnag.com/" rel="noopener ugc nofollow" target="_blank"> BugSnag </a>。</p><p id="71e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">BugSnag有一个React原生库，允许您轻松地与您的应用程序集成。它有一个非常实用的API，其中你可以标记错误报告给当前登录的用户。此外，它还集成了我用来导航的React导航库。</p><h1 id="09f6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">服务器端错误报告</h1><p id="68c8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">对于服务器端错误报告，我使用<a class="ae le" href="https://sentry.io/" rel="noopener ugc nofollow" target="_blank"> Sentry </a>。</p><h1 id="30c7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">部署</h1><p id="2cab" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">应用程序的服务器端部署在<a class="ae le" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>上。</p><h1 id="e87c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结束语</h1><p id="28a7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这是我在<a class="ae le" href="https://www.wheelrun.biz/" rel="noopener ugc nofollow" target="_blank">自己的React原生应用</a>中加入的一些技术特征的指示性列表。你可能会发现它们中的一些在你自己的应用中也很有用。</p><p id="3975" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不用说，我从你身上学到的比你从我身上学到的要多得多。因此，我们非常欢迎您的反馈和意见。</p></div></div>    
</body>
</html>