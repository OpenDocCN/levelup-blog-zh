<html>
<head>
<title>JavaScript Best Practices — Constructors and Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—构造函数和类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-constructors-and-classes-6faf0ade166?source=collection_archive---------24-----------------------#2020-06-04">https://levelup.gitconnected.com/javascript-best-practices-constructors-and-classes-6faf0ade166?source=collection_archive---------24-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7a76d32b52646e2cb08f806823690dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R_pxUHZpph4X1Z2A"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="af03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="9766" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究用JavaScript开发时的一些最佳实践，包括对象创建和构造函数。</p><h1 id="5965" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">原型</h1><p id="2aad" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们的构造函数中有方法时，我们应该将它们添加到构造函数的<code class="fe mh mi mj mk b">prototype</code>属性中，而不是放在构造函数中。</p><p id="ef4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2edd" class="mt lf it mk b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>  this.greet = function() {<br/>    return `hi ${this.name}`;<br/>  }<br/>}</span></pre><p id="eb19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b794" class="mt lf it mk b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="ec73" class="mt lf it mk b gy my mv l mw mx">Person.prototype.greet = function() {<br/>  return `hi ${this.name}`;<br/>}</span></pre><p id="3b6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的是，我们通过编写以下代码来使用类语法:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1c07" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="4e29" class="mt lf it mk b gy my mv l mw mx">  greet() {<br/>    return `hi ${this.name}`;<br/>  }<br/>}</span></pre><p id="1659" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后两段代码是相同的。</p><p id="069c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望像最后两个例子一样编写我们的构造函数，因为我们只想在所有实例之间共享一个<code class="fe mh mi mj mk b">greet</code>方法的副本。</p><p id="9570" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">greet</code>方法不会改变，只有<code class="fe mh mi mj mk b">this</code>的值会改变。</p><p id="a5fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不想像在第一个例子中那样保留同一个方法的不同副本。</p><p id="2cfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们想像前两个例子一样分享它。</p><p id="3509" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建一个构造函数的实例来找出不同之处:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7b50" class="mt lf it mk b gy mu mv l mw mx">const person = new Person('joe');<br/>console.log(person)</span></pre><p id="6f5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们记录下<code class="fe mh mi mj mk b">person</code>对象，我们可以看到该方法在<code class="fe mh mi mj mk b">__proto__</code>属性中，这是<code class="fe mh mi mj mk b">person</code>的原型。</p><p id="1792" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有<code class="fe mh mi mj mk b">greet</code>方法。</p><p id="9ff6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们用第一版的<code class="fe mh mi mj mk b">Person</code>构造函数创建同一个对象，我们会看到<code class="fe mh mi mj mk b">greet</code>方法在<code class="fe mh mi mj mk b">person</code>对象本身中。</p><p id="66a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，为了节省内存，方法应该在构造函数的<code class="fe mh mi mj mk b">prototype</code>属性中，而不是在构造函数本身内部。</p><h1 id="8255" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构造函数的返回值</h1><p id="d3aa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">构造函数不需要显式地返回一些东西。</p><p id="dc2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通常不应该显式返回任何东西，因为它会自动返回构造函数的实例。</p><p id="4e62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果我们愿意，它确实让我们返回不同的东西。</p><p id="14de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但我们通常不应该这样做，除非我们有理由这样做。</p><p id="245e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想这样做，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3aee" class="mt lf it mk b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>  return {<br/>    foo: name<br/>  }<br/>}</span></pre><p id="d881" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们如下实例化它时:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="91b3" class="mt lf it mk b gy mu mv l mw mx">const person = new Person('joe');<br/>console.log(person)</span></pre><p id="3f3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据控制台日志输出，我们得到<code class="fe mh mi mj mk b">{foo: “joe”}</code>而不是<code class="fe mh mi mj mk b">Person {name: “joe”}</code>。</p><h1 id="6b52" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实施新的模式</h1><p id="45cc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了创建一个对象的新实例，我们需要使用<code class="fe mh mi mj mk b">new</code>。</p><p id="4bdb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最好的方法是使用类语法。</p><p id="8e56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样我们没有<code class="fe mh mi mj mk b">new</code>就叫不出来了。</p><p id="6828" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们调用一个不带<code class="fe mh mi mj mk b">new</code>的构造函数，那么<code class="fe mh mi mj mk b">this</code>就是全局对象。</p><h1 id="6787" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构造函数/类的命名约定</h1><p id="a8f7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">构造函数或类通常用PascalCase命名。</p><p id="0af5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将常规函数与构造函数和类区分开来。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/75127e8d312f74a86f1001986439fd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MdEtB7dWLtRei4oU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@huyennguyen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Huyen Nguyen </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="ba55" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">利用这个</h1><p id="ff00" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们想确保我们的构造函数总是像构造函数一样，我们也可以创建一个对象并返回它。</p><p id="4f4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9e17" class="mt lf it mk b gy mu mv l mw mx">function Person(name) {<br/>  const that = {};<br/>  that.name = name;<br/>  return that;<br/>}</span></pre><p id="1380" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们在没有使用<code class="fe mh mi mj mk b">new</code>的情况下调用我们的<code class="fe mh mi mj mk b">Person</code>构造函数，我们仍然会返回一个对象。</p><h1 id="1b5b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">自调用构造函数</h1><p id="6bf3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以使用<code class="fe mh mi mj mk b">instanceof</code>操作符来检查构造函数的<code class="fe mh mi mj mk b">this</code>是否是构造函数的实例。</p><p id="a66d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们就知道我们是否用<code class="fe mh mi mj mk b">new</code>调用了它。</p><p id="c7c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们这样做了，那么构造函数的<code class="fe mh mi mj mk b">this</code>应该是构造函数的一个实例。</p><p id="8719" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以进行如下检查:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="dff1" class="mt lf it mk b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>  if (!(this instanceof Person)) {<br/>    return new Person(name);<br/>  }<br/>}</span></pre><p id="8f86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，不管我们是否用<code class="fe mh mi mj mk b">new</code>调用了<code class="fe mh mi mj mk b">Person</code>构造函数，我们都会得到相同的结果。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8c6d" class="mt lf it mk b gy mu mv l mw mx">const person = new Person('joe');</span></pre><p id="f841" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2aeb" class="mt lf it mk b gy mu mv l mw mx">const person = Person('joe');</span></pre><p id="5f8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应该会得到同样的结果。</p><h1 id="afbf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="1a5d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该将方法保存在构造函数的原型中，而不是构造函数本身。</p><p id="a86a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，该方法的一个副本在所有实例之间共享。</p><p id="0295" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是可行的，因为该方法在所有实例中都是相同的。</p><p id="65cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类语法会自动为我们做这件事。</p><p id="7af9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以检查<code class="fe mh mi mj mk b">this</code>是否是构造函数的实例，以检查我们的构造函数是否被正确调用。</p><p id="b876" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类语法也为我们处理了这一点，因为没有关键字<code class="fe mh mi mj mk b">new</code>我们就不能调用类。</p></div></div>    
</body>
</html>