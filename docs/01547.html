<html>
<head>
<title>How Docker Authentication Works: By Documentation, MITM, and Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker认证如何工作:通过文档、MITM和实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-docker-authentication-works-by-documentation-mitm-and-implementation-e62cd7a31178?source=collection_archive---------3-----------------------#2020-01-12">https://levelup.gitconnected.com/how-docker-authentication-works-by-documentation-mitm-and-implementation-e62cd7a31178?source=collection_archive---------3-----------------------#2020-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="6974" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">背景</h1><p id="ffb2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Nordstrom，我们到处使用Docker和Kubernetes。我们已经将这些容器技术深度集成到我们日常开发的各个方面，从CI/CD构建、计划的作业，到每秒处理数千个事务的托管公共服务。</p><p id="46a2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们已经这样做了很多年，这给了我们时间来成熟它是一个平台。这意味着适当的工程标准、共享的分布式跟踪和日志记录，最重要的是导致这种深入的原因:限制性的pod安全策略。</p><p id="dc10" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在搜索团队中，我们最近引入了另一个容器协调器:<a class="ae lr" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank">亚马逊的弹性容器服务</a>。我们这样做是为了降低使用特定于AWS的服务的复杂性，但是新的基础设施总是会带来学习的机会。</p><p id="b94d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><em class="ls">特别是</em>，我遇到了让我们在Kubernetes的Gitlab CICD运行人员从docker文件构建docker映像并将其部署到<a class="ae lr" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank"> ECR </a>的问题。问题的根源在于，单个Gitlab CICD级可能会:</p><ul class=""><li id="c00a" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">获取AWS证书(例如<code class="fe mc md me mf b">awscli ecr get-login</code> ) <strong class="kq iu">或</strong></li><li id="e0cb" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">运行docker守护进程来拉、构建和推送(例如<code class="fe mc md me mf b">docker pull</code>)</li></ul><p id="6b07" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我可以在一个容器中做一个，在另一个容器中做另一个，但是我不能在同一个容器中同时做两个。这是因为我们共享的CICD运行器锁定了哪些服务可以与哪些映像并行运行。这给了我以下选择:</p><ul class=""><li id="5299" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">在没有守护进程的情况下构建docker映像(无守护进程docker)</li><li id="9490" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">找到一种方法来安全地生成ECR凭证，并将其从一个阶段传递到另一个拥有docker并可以使用它们的阶段。</li></ul><p id="6489" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">虽然最终的解决方案是后者(使用Gitlab的秘密管理器),但我通过研究daemonless docker builders开始了这个过程。我学到了以下几点:</p><p id="edc3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">有一些无daemonless容器构建器，它们使用runc构建映像并运行容器，与Docker使用相同的开放容器规范。</p><p id="8b1d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">有两家非常有前途的集装箱制造商不是码头工人:</p><ul class=""><li id="bc5e" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated"><a class="ae lr" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank">谷歌的Kaniko </a>是专门为在Kubernetes上用作docker图像构建器而构建的。</li><li id="1375" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated"><a class="ae lr" href="https://github.com/genuinetools/img" rel="noopener ugc nofollow" target="_blank">正版工具的img </a>宣称自己是一个“独立的、无守护进程的、无特权的Dockerfile和OCI兼容的容器映像构建器”</li></ul><p id="8d9a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">听起来很棒！对吗？嗯……算是吧。</p><p id="78ac" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">还记得我之前提到的那些pod安全策略吗？我们的Kubernetes集群上的策略之一是<a class="ae lr" href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems" rel="noopener ugc nofollow" target="_blank"> ReadOnlyRootFilesystem，</a>这意味着您的容器不能修改根文件系统。对于Kaniko，这是一个问题，因为它写入到硬编码的根文件夹路径<a class="ae lr" href="https://github.com/GoogleContainerTools/kaniko/blob/c5bc179c85be57128d802626a03cbc24469f7bec/pkg/constants/constants.go#L37" rel="noopener ugc nofollow" target="_blank">。我们可以定制我们自己的版本，但是现在，让我们继续。</a></p><p id="9e63" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所以我看了看正版工具的img和d，看起来它符合所有的标准:</p><ul class=""><li id="57a1" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">无梦的</li><li id="fa45" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">在非特权设置下运行良好</li><li id="b894" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">根目录中没有建筑</li><li id="3990" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">支持ECR认证<code class="fe mc md me mf b">docker login {creds}</code> → <code class="fe mc md me mf b">img login {creds}</code></li></ul><p id="ba6e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然而，在我的研究中，我在github上找到了下面这张票:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/1ab4f0dabac7080f233a440f1e78542a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZ_nIkgPKhFdR_pNaKHCIg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">勉强挤过特征</figcaption></figure><p id="a814" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">原来<em class="ls"> img只有</em>支持ECR私人回购，这让我很好奇:</p><ul class=""><li id="d85b" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">docker认证是如何工作的？</li><li id="e4db" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">为什么这个项目只适用于一个私有存储库，而不适用于所有其他的存储库？</li><li id="4901" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">在这个项目中实现对GCR的支持有多难？(我们在Nordstrom也有谷歌云项目)</li></ul><h1 id="9bf4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Docker认证如何工作</h1><p id="93dc" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将通过使用Google容器注册中心作为私有注册中心的例子来详细了解这一点，我们将首先查看关于它应该做什么的相关文档，然后在我的机器上设置一个MITM代理来监视所有传出的请求，以查看到底发送了什么。</p><p id="4d00" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果你想跟着做，你需要安装<a class="ae lr" href="https://cloud.google.com/sdk/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=na-CA-all-en-dr-bkws-all-all-trial-b-dr-1008076&amp;utm_content=text-ad-none-any-DEV_c-CRE_339544711141-ADGP_Hybrid+%7C+AW+SEM+%7C+BKWS+%7C+RLSA+%7C+CA+%7C+en+%7C+BMM+~+Tools+~+Developer+Tools+~+Cloud+SDK+~+Sdk+Google+Cloud-KWID_43700042240005671-kwd-317970009092&amp;utm_term=KW_%2Bsdk%20%2Bgoogle%20%2Bcloud-ST_%2Bsdk+%2Bgoogle+%2Bcloud&amp;gclid=CjwKCAiApOvwBRBUEiwAcZGdGC2fAXg6iKl3QRRF-W4lzYgOMc7XWhQnnpDhXKDLUbQR9c6os2oe-RoCqxwQAvD_BwE" rel="noopener ugc nofollow" target="_blank">谷歌云SDK </a>，通过<code class="fe mc md me mf b">gcloud auth </code>正确认证，并使用SDK的<code class="fe mc md me mf b">gcloud auth configure-docker</code>设置命令。</p><h1 id="0cb0" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">文档</h1><p id="b254" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当你执行<code class="fe mc md me mf b">docker login gcr.io</code>登录并且<em class="ls">正常工作</em>时，你很容易忽略到底发生了什么。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/22fe8162b2299a551896ee703c2da501.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/0*eXSTNwxVZLHEqJDi.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">docker认证模型</figcaption></figure><p id="8c74" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">上图来自<a class="ae lr" href="https://docs.docker.com/registry/spec/auth/token/" rel="noopener ugc nofollow" target="_blank"> Docker令牌认证规范，</a>，它从较高的层面向我们展示了认证是如何发生的，它还告诉我们每个调用代表什么:</p><blockquote class="nc nd ne"><p id="064f" class="ko kp ls kq b kr lm kt ku kv ln kx ky nf lo lb lc ng lp lf lg nh lq lj lk ll im bi translated">1.尝试对注册表开始推/拉操作。</p><p id="70a2" class="ko kp ls kq b kr lm kt ku kv ln kx ky nf lo lb lc ng lp lf lg nh lq lj lk ll im bi translated">2.如果注册中心需要授权，它将返回一个包含如何认证信息的<code class="fe mc md me mf b">401 Unauthorized</code> HTTP响应。</p><p id="9d92" class="ko kp ls kq b kr lm kt ku kv ln kx ky nf lo lb lc ng lp lf lg nh lq lj lk ll im bi translated">3.注册中心客户端向授权服务请求一个承载令牌。</p><p id="3f12" class="ko kp ls kq b kr lm kt ku kv ln kx ky nf lo lb lc ng lp lf lg nh lq lj lk ll im bi translated">4.授权服务返回代表客户端授权访问的不透明载体令牌。</p><p id="1436" class="ko kp ls kq b kr lm kt ku kv ln kx ky nf lo lb lc ng lp lf lg nh lq lj lk ll im bi translated">5.客户端使用嵌入在请求授权头中的承载令牌重试原始请求。</p><p id="0b67" class="ko kp ls kq b kr lm kt ku kv ln kx ky nf lo lb lc ng lp lf lg nh lq lj lk ll im bi translated">6.注册中心通过验证承载令牌和嵌入其中的声明集来授权客户端，并照常开始推/拉会话。</p></blockquote><p id="b4c9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这是一个很好的开始，但是Docker守护进程，或者可能是它的客户机(不清楚是哪一个)如何从“授权服务”获得凭证以获得不记名令牌呢？</p><h2 id="698e" class="ni jr it bd js nj nk dn jw nl nm dp ka kz nn no ke ld np nq ki lh nr ns km nt bi translated">凭据助手</h2><p id="e91e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lr" href="https://docs.docker.com/engine/reference/commandline/login/#credential-helpers" rel="noopener ugc nofollow" target="_blank">根据文档</a>，docker客户端通过凭证助手启动该流程。凭证助手是docker客户机用来调用特定于服务的身份验证机制的二进制文件。它们实现了一个非常简单的接口，并通过一个非常简单的机制被调用。</p><p id="0fa4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当您使用gcloud sdk的<code class="fe mc md me mf b">gcloud auth configure-docker</code>设置docker时，它会将以下文件写入您的<code class="fe mc md me mf b">~/.docker/config.json</code>:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">gcloud docker配置示例</figcaption></figure><p id="cfee" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当您执行一个<code class="fe mc md me mf b">docker login {HOST_NAME}</code>时，它会在这个文件中执行一个查找来找出要调用哪个助手。在上面的配置中<code class="fe mc md me mf b">docker login gcr.io</code>会调用<code class="fe mc md me mf b">docker-credential-gcloud</code>。</p><p id="6a50" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这意味着配置具有以下结构:</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="b8d0" class="ni jr it mf b gy oa ob l oc od">{<br/>  "credHelpers":<br/>    [HOST_NAME]: [HELPER_SUFFIX]<br/>  }<br/>}</span></pre><p id="abed" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">助手界面很简单:</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="6964" class="ni jr it mf b gy oa ob l oc od">docker-credential-{suffix} get [host_name]<br/>docker-credential-{suffix} store [host_name]<br/>docker-credential-{suffix} erase [host_name]</span></pre><ul class=""><li id="f66a" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated"><code class="fe mc md me mf b">get</code>要求帮助者接收它将需要的认证凭证</li><li id="51ed" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated"><code class="fe mc md me mf b">store</code>要求助手保存凭证</li><li id="6f2f" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated"><code class="fe mc md me mf b">erase</code>要求助手删除任何为<code class="fe mc md me mf b">docker logout</code>呼叫保存的凭证</li></ul><p id="2906" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们实际上可以通过直接调用助手来测试这一点:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">验证并打印我们的凭证</figcaption></figure><p id="6099" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这将为您提供类似于</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="7d12" class="ni jr it mf b gy oa ob l oc od">{<br/>  "Secret": "ya29.[REDACTED]",<br/>  "Username": "_dcgcloud_token"<br/>}</span></pre><h1 id="188c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">作者:MITM</h1><p id="2adf" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们看看具体的请求是什么。我们可以通过在以下两者之间建立一个中间人代理来做到这一点:</p><ul class=""><li id="5b67" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">证书助手和互联网</li><li id="6d03" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">docker守护进程和互联网</li><li id="7e75" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">docker客户端和docker守护进程</li></ul><p id="7eef" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">警告:</strong>我们将把Docker和gcloud SDK都配置为不安全的，这使得针对我们的MITM攻击变得轻而易举。不要在你的机器上尝试这样做，除非你愿意自己撤销。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oe"><img src="../Images/47bee3733c6272a34ec334da72bef015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kYiSA90H_WVG_oLX2QjdQA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">我们将要策划的MITM袭击</figcaption></figure><h2 id="e24d" class="ni jr it bd js nj nk dn jw nl nm dp ka kz nn no ke ld np nq ki lh nr ns km nt bi translated">设置</h2><p id="f141" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">打开你的终端，让我们开始安装我们将需要设置一个MITM攻击</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="a0aa" class="ni jr it mf b gy oa ob l oc od">docker pull mitmproxy/mitmproxy<br/>sudo apt-get install socat</span></pre><p id="18c3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在设置gcloud以允许不安全的连接，并通过我们即将设置的代理进行代理</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="75bf" class="ni jr it mf b gy oa ob l oc od">gcloud config set proxy/address 127.0.0.1<br/>gcloud config set proxy/port 8080<br/>gcloud config set proxy/type http<br/>gcloud config set auth/disable_ssl_validation  True</span></pre><p id="5333" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在设置docker守护进程通过我们的代理，并允许它与docker守护进程建立不安全的连接</p><p id="9c89" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在<code class="fe mc md me mf b">/etc/docker/daemon.json</code></p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="1b16" class="ni jr it mf b gy oa ob l oc od">{<br/>  "insecure-registries" : ["gcr.io"]<br/>}</span></pre><p id="ee58" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在<code class="fe mc md me mf b">/etc/systemd/system/docker.service.d/http-proxy.conf</code></p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="7036" class="ni jr it mf b gy oa ob l oc od">[Service]<br/>Environment="HTTP_PROXY=<a class="ae lr" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a>"</span></pre><p id="8f9e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在<code class="fe mc md me mf b">/etc/systemd/system/docker.service.d/https-proxy.conf</code></p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="898e" class="ni jr it mf b gy oa ob l oc od">[Service]<br/>Environment="HTTPS_PROXY=<a class="ae lr" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a>"</span></pre><p id="0274" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，在另外两个终端中，我们需要启动以下程序:</p><ul class=""><li id="ac44" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">我们的HTTP代理</li><li id="a111" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">我们的SOCKS代理</li></ul><p id="5ef0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">HTTP代理:</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="59af" class="ni jr it mf b gy oa ob l oc od">docker run --rm -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -p 8080:8080 mitmproxy/mitmproxy</span></pre><p id="81d1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">SOCKS代理:</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="cefd" class="ni jr it mf b gy oa ob l oc od">socat -v UNIX-LISTEN:/tmp/fake,fork UNIX-CONNECT:/var/run/docker.sock</span></pre><h2 id="eff7" class="ni jr it bd js nj nk dn jw nl nm dp ka kz nn no ke ld np nq ki lh nr ns km nt bi translated">执行</h2><p id="9207" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们现在有一个人在中间代理运行。在第三个终端中，我们可以开始认证。</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="eba0" class="ni jr it mf b gy oa ob l oc od">export DOCKER_HOST=unix:///tmp/fake<br/>docker login gcr.io</span></pre><p id="b603" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您将立即看到4个HTTP请求和一系列SOCKs消息。最重要的SOCKS消息是启动整个过程的认证请求:</p><pre class="mm mn mo mp gt nw mf nx ny aw nz bi"><span id="fa4a" class="ni jr it mf b gy oa ob l oc od">&gt; 2020/01/11 16:29:33.415001  length=353 from=165 to=517<br/>POST /v1.39/auth HTTP/1.1\r<br/>Host: docker\r<br/>User-Agent: Docker-Client/18.09.0 (linux)\r<br/>Content-Length: 214\r<br/>Content-Type: application/json\r<br/>\r<br/>{"username":"_dcgcloud_token","password":"ya29.[REMOVED]","serveraddress":"gcr.io"}<br/>&lt; 2020/01/11 16:29:33.850583  length=250 from=2826 to=3075<br/>HTTP/1.1 200 OK\r<br/>Api-Version: 1.39\r<br/>Content-Type: application/json\r<br/>Docker-Experimental: false\r<br/>Ostype: linux\r<br/>Server: Docker/18.09.0 (linux)\r<br/>Date: Sun, 12 Jan 2020 00:29:33 GMT\r<br/>Content-Length: 48\r<br/>\r</span></pre><p id="6db9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">从那里，docker守护进程开始处理进程的其余部分，并执行以下4个调用:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi of"><img src="../Images/e166b89b692664d15b939cd4841b1860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSDFa7eMyqEqQ0VlChuviA.png"/></div></div></figure><ol class=""><li id="3765" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll og lz ma mb bi translated">gcloud凭证助手使用用户的Oauth令牌(在<code class="fe mc md me mf b">gcloud auth</code>期间由浏览器登录检索并存储)调用<code class="fe mc md me mf b">/oauth/v4/token</code></li><li id="0900" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll og lz ma mb bi translated">对注册中心的第一个调用，它返回一个<code class="fe mc md me mf b">401 Forbidden</code>来触发下一个调用:</li><li id="d160" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll og lz ma mb bi translated">使用正确的凭据作为GET参数调用注册表。</li><li id="08ae" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll og lz ma mb bi translated">使用不记名令牌对注册中心进行测试调用，以确保身份验证成功。</li></ol><p id="9647" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在你知道了。文档中描述的全套网络调用。</p><p id="142a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果你跟着做，现在是撤销这个不安全配置的好时机。</p><h1 id="6aeb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">履行</h1><p id="e6d4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么，为什么<em class="ls"> img不支持</em>使用认证助手或ECR之外的任何其他注册表认证助手对GCR进行认证呢？结果他们几乎做到了。</p><p id="ac1e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><em class="ls"> img </em>使用与docker客户端完全相同的代码，<a class="ae lr" href="https://github.com/genuinetools/img/blob/master/login.go#L14" rel="noopener ugc nofollow" target="_blank">事实上它是一个直接依赖</a>。他们只是忽略了凭证助手的工作，并且<strong class="kq iu">总是</strong>提示输入密码，而不是通过<code class="fe mc md me mf b">img login</code>命令提供。</p><p id="d921" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">那么解决方法是什么？</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oh"><img src="../Images/fca0ee421bd83313ea472244cce78658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZB-H4xZyjdpcGm3kXCZMag.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">拉式请求img</figcaption></figure><p id="db0c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我的前三行golang。<a class="ae lr" href="https://github.com/genuinetools/img/pull/276/files" rel="noopener ugc nofollow" target="_blank">作为拉取请求提交给项目</a>。</p><h1 id="475e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="1598" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为软件工程师，我们站在巨人的肩膀上。我们的大量日常工作依赖于Rube Goldberg机器的二进制文件、库和服务，我们可以在解决问题的过程中理所当然地使用它们。花点时间深入探究香肠是如何制成的，可以教会我们一些我们从来不知道自己想了解的事情，比如:</p><ul class=""><li id="8250" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">我们构建的映像都是同一个<a class="ae lr" href="https://www.opencontainers.org/" rel="noopener ugc nofollow" target="_blank">开放容器规范</a>的一部分，在docker之外有不同的运行时。</li><li id="96ef" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">几乎整个docker/runc/img/kaniko/jib生态系统都依赖于相同的共享管道。</li><li id="8eb2" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated"><a class="ae lr" href="https://www.docker.com/blog/runc/" rel="noopener ugc nofollow" target="_blank">基础设施规划宣言</a>和Docker试图将他们所有的基础设施分解成模块化组件。</li><li id="3c09" class="lt lu it kq b kr mg kv mh kz mi ld mj lh mk ll ly lz ma mb bi translated">为逆向工程套接字请求设置MITM代理几乎非常简单。</li></ul><p id="f623" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">因此，当你面临一个问题时，花一点时间考虑一下你所期望的<em class="ls">只是工作</em>，并深入了解它正在做什么来帮助保持位流。</p></div></div>    
</body>
</html>