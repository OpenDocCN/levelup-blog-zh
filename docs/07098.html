<html>
<head>
<title>Memory Allocation and Performance in Golang Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang映射中的内存分配和性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/memory-allocation-and-performance-in-golang-maps-b267b5ad9217?source=collection_archive---------4-----------------------#2021-01-25">https://levelup.gitconnected.com/memory-allocation-and-performance-in-golang-maps-b267b5ad9217?source=collection_archive---------4-----------------------#2021-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f440" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">戈朗</h2><div class=""/><div class=""><h2 id="cdef" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Golang地图可能会很棘手。理解它们是如何工作的可以帮助你提高代码的性能</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/64a04e091efbce3a69bc5e0ba9025ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pv0FXQ6YKQat0gblywA2xg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">(来源:<a class="ae le" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">pexels.com</a>)</figcaption></figure><p id="ae4f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最近在栈溢出上发现一个有趣的<a class="ae le" href="https://stackoverflow.com/questions/65258003/memory-allocation-of-mapintinterface-vs-mapintstruct/65866774" rel="noopener ugc nofollow" target="_blank">问题。当我们使用一个接口作为值(<code class="fe mb mc md me b">map[int]interface{}</code> ) <em class="mf">与</em>一个空结构作为值(<code class="fe mb mc md me b">map[int]struct{}</code>)时，它与Golang映射中的内存分配有关。OP设置了两个基准测试来比较这两种地图类型，并发现了一些奇怪的结果。基准描述如下:</a></p><p id="0579" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在下面的代码中，我们为每种地图类型提供了一个函数。每个函数基本上都创建一个映射，然后重复固定次数的零值赋值。也就是说，在执行结束时，映射将具有固定数量的条目，并且每个条目将接收类型的零值(接口为<code class="fe mb mc md me b">nil</code>，空结构为<code class="fe mb mc md me b">struct{}{}</code>)。</p><pre class="kp kq kr ks gt mg me mh mi aw mj bi"><span id="50b5" class="mk ml iq me b gy mm mn l mo mp">package main<br/><br/>func main() {}<br/><br/>func MapWithInterface() {<br/>    m := map[int]interface{}{}<br/>    for i := 1; i &lt;= 100; i++ {<br/>        m[i] = nil<br/>    }<br/>}<br/><br/>func MapWithEmptyStruct() {<br/>    m := map[int]struct{}{}<br/>    for i := 1; i &lt;= 100; i++ {<br/>        m[i] = struct{}{}<br/>    }<br/>}</span></pre><p id="ffcd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">基准:</p><pre class="kp kq kr ks gt mg me mh mi aw mj bi"><span id="8f73" class="mk ml iq me b gy mm mn l mo mp">package main<br/><br/>import "testing"<br/><br/>func Benchmark_Interface(b *testing.B) {<br/>    for i := 0; i &lt; b.N; i++ {<br/>        MapWithInterface()<br/>    }<br/>}<br/><br/>func Benchmark_EmptyStruct(b *testing.B) {<br/>    for i := 0; i &lt; b.N; i++ {<br/>        MapWithEmptyStruct()<br/>    }<br/>}</span></pre></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="a87b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">基准执行的结果如下:</p><pre class="kp kq kr ks gt mg me mh mi aw mj bi"><span id="b9e5" class="mk ml iq me b gy mm mn l mo mp">goos: darwin<br/>goarch: amd64<br/>pkg: awesomeProject1<br/>Benchmark_Interface-8         130419          8949 ns/op        7824 B/op          7 allocs/op<br/>Benchmark_EmptyStruct-8       165147          6964 ns/op        3070 B/op         17 allocs/op<br/>PASS<br/>ok      awesomeProject1 3.122s</span></pre><p id="ad47" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">两个映射的条目都被赋予零值(<code class="fe mb mc md me b">nil</code>和<code class="fe mb mc md me b">struct{}{}</code>，即不需要分配的值)。然而，我们看到空结构版本运行得更快，使用的内存更少，但它进行了更多的分配。这里发生了什么？为什么这些如此相似的基准测试会有如此不同的结果？</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="d9ee" class="mx ml iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="52af" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">Golang中地图的内部设计针对性能和内存管理进行了高度优化。映射跟踪可以保存指针的键和值。如果桶中的条目不能保存指针，映射只需创建溢出桶来避免垃圾收集(GC)带来的不必要开销，这将导致更多的分配和更好的性能(<code class="fe mb mc md me b">map[int]struct{}</code>的情况)。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="9b2a" class="mx ml iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">长回答</h1><p id="9c26" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在我们得到答案之前，我们需要理解映射初始化和映射结构。我们将首先浏览这些主题，然后我们将分析一些基准，以了解我们在这里试图理解的两种地图类型的性能。我创建了一个<a class="ae le" href="https://github.com/ricardoerikson/benchmark-golang-maps" rel="noopener ugc nofollow" target="_blank">库</a>，其中包含一些测试来帮助理解这个答案。因此，如果您在文本中看到一些对测试或基准的引用，它可能在存储库中。</p><h2 id="aadf" class="mk ml iq bd my nt nu dn nc nv nw dp ng lo nx ny ni ls nz oa nk lw ob oc nm iw bi translated">地图初始化</h2><p id="a09a" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">地图初始化有两种方法:</p><ul class=""><li id="0bcf" class="od oe iq lh b li lj ll lm lo of ls og lw oh ma oi oj ok ol bi translated">当我们不知道有多少条目将被添加到地图中时。</li><li id="278d" class="od oe iq lh b li om ll on lo oo ls op lw oq ma oi oj ok ol bi translated"><code class="fe mb mc md me b">make(map[int]string, hint)</code>:当我们知道要添加多少条目时。<code class="fe mb mc md me b">hint</code>是对地图初始容量的估计。</li></ul><p id="f026" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">无论我们选择哪种初始化方法，映射都是可变的，它们会按需增长。然而，第二种方法至少为<code class="fe mb mc md me b">hint</code>个条目预分配了内存，从而提高了性能。</p><h2 id="da6d" class="mk ml iq bd my nt nu dn nc nv nw dp ng lo nx ny ni ls nz oa nk lw ob oc nm iw bi translated">地图结构</h2><p id="3b14" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">Go中的map是一个散列表，它将其键/值对存储在桶中。每个存储桶是一个最多可容纳8个条目的数组。默认桶数是1。一旦每个存储桶中的条目数量达到存储桶的平均负载(也称为负载系数)，这个映射就会因为存储桶的数量翻倍而变大。每次映射增长时，它都会为新来的条目分配内存。实际上，每当存储桶的负载达到6.5或更高时，地图就会增长。这个值是硬编码的，选择它是为了优化内存使用。</p><p id="0f5e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在幕后，映射是指向<code class="fe mb mc md me b">hmap</code>结构的指针。还有一个<code class="fe mb mc md me b">map</code>结构，它保存了一些关于地图类型的信息。Golang地图的源代码可以在这里找到:</p><p id="a238" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://github.com/golang/go/blob/master/src/runtime/map.go" rel="noopener ugc nofollow" target="_blank">https://github.com/golang/go/blob/master/src/runtime/map.go</a></p><p id="364d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如您在上面的链接中看到的，map内部是复杂的。在下面的链接中，你可以找到一些关于如何破解地图类型的见解。Aleksandr Kochetkov 出色地展示了地图内部的一些细节。</p><p id="f360" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://hackernoon.com/some-insights-on-maps-in-golang-rm5v3ywh" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/some-insights-on-maps-in-golang-rm5v 3 ywh</a></p><p id="7da1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://play.golang.org/p/NaoC8fkmy9x" rel="noopener ugc nofollow" target="_blank">https://play.golang.org/p/NaoC8fkmy9x</a></p><p id="4720" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">需要注意的一件重要事情是，映射跟踪可以保存指针的键和值。如果一个桶中的条目不能容纳任何指针，则该桶被标记为不包含指针，并且映射只创建溢出桶(这意味着更多的内存分配)。这避免了不必要的GC开销。参见本</strong> <a class="ae le" href="https://github.com/golang/go/blob/682a1d2176b02337460aeede0ff9e49429525195/src/runtime/map.go#L132" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">注释中的</strong> </a> <code class="fe mb mc md me b"><a class="ae le" href="https://github.com/golang/go/blob/682a1d2176b02337460aeede0ff9e49429525195/src/runtime/map.go#L132" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja">mapextra</strong></a></code> <a class="ae le" href="https://github.com/golang/go/blob/682a1d2176b02337460aeede0ff9e49429525195/src/runtime/map.go#L132" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> struct(第132行)</strong> </a> <strong class="lh ja">和本</strong><a class="ae le" href="https://www.komu.engineer/blogs/go-gc-maps" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja">post</strong></a><strong class="lh ja">以供参考。</strong></p><h2 id="aeb7" class="mk ml iq bd my nt nu dn nc nv nw dp ng lo nx ny ni ls nz oa nk lw ob oc nm iw bi translated">基准分析</h2><p id="9c50" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">空结构<code class="fe mb mc md me b">struct{}</code>没有字段，不能保存任何指针。因此，空结构情况下的桶将被标记为不包含指针的<em class="mf">。这将避免不必要的地图扫描，我们可以期待提高执行速度。此外，我们还可以期待为类型为<code class="fe mb mc md me b">map[int]struct{}</code>的映射分配更多的内存，因为随着它的增长，它会创建更多的溢出桶。</em></p><p id="e71a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">与空结构不同，<code class="fe mb mc md me b">interface{}</code>类型可以保存任何值，包括指针。为了理解这如何影响映射性能，我们需要理解映射桶跟踪保存所有指针的内存前缀的大小(<code class="fe mb mc md me b"><a class="ae le" href="https://github.com/golang/go/blob/cd99385ff4a4b7534c71bb92420da6f462c5598e/src/runtime/type.go#L33" rel="noopener ugc nofollow" target="_blank">ptrdata</a></code> <a class="ae le" href="https://github.com/golang/go/blob/cd99385ff4a4b7534c71bb92420da6f462c5598e/src/runtime/type.go#L33" rel="noopener ugc nofollow" target="_blank">字段，第33行</a>)。可以保存指针的映射类型不会分配额外的溢出桶。但是，这些类型需要GC扫描。</p><p id="8775" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在map内部实现中，我们可以看到如何使用<code class="fe mb mc md me b">ptrdata</code>字段来决定是否创建更多的溢出桶(<a class="ae le" href="https://github.com/golang/go/blob/b634f5d97a6e65f19057c00ed2095a1a872c7fa8/src/runtime/map.go#L265" rel="noopener ugc nofollow" target="_blank"> map.go，第265行</a>)。参考这个<a class="ae le" href="https://play.golang.org/p/_-QKWu1GBnr" rel="noopener ugc nofollow" target="_blank">链接</a>来查看保存所有<code class="fe mb mc md me b">map[int]struct{}</code>和<code class="fe mb mc md me b">map[int]interface{}</code>指针的内存前缀的大小。</p><p id="81a4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们看到CPU配置文件时，两个基准测试(<code class="fe mb mc md me b">Benchmark_EmptyStruct</code>和<code class="fe mb mc md me b">Benchmark_Interface</code>)之间的差异就很明显了。<code class="fe mb mc md me b">Benchmark_Interface</code>没有导致额外内存分配流的方法<code class="fe mb mc md me b">(*hmap)createOverflow</code>。</p><h2 id="a331" class="mk ml iq bd my nt nu dn nc nv nw dp ng lo nx ny ni ls nz oa nk lw ob oc nm iw bi translated">Benchmark_EmptyStruct CPU配置文件</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/be36fd29b3319f9cd5d2058d97893d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMiIJkGEnfYgQ13MkIBE0Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><em class="os">Benchmark _ empty struct CPU profile(</em><a class="ae le" href="https://raw.githubusercontent.com/ricardoerikson/benchmark-golang-maps/main/map_empty_struct_cpu_profile.png" rel="noopener ugc nofollow" target="_blank"><em class="os">png</em></a><em class="os">，</em><a class="ae le" href="https://raw.githubusercontent.com/ricardoerikson/benchmark-golang-maps/main/map_empty_struct_cpu_profile.svg" rel="noopener ugc nofollow" target="_blank"><em class="os">SVG</em></a><em class="os">)</em></figcaption></figure><h2 id="4bed" class="mk ml iq bd my nt nu dn nc nv nw dp ng lo nx ny ni ls nz oa nk lw ob oc nm iw bi translated">基准_接口CPU配置文件</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/3989e4fad69e9473798f38f6dfc28b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*1yyZ6uldnwtlBao3pQlxTQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><em class="os">基准_接口CPU概要文件(</em><a class="ae le" href="https://raw.githubusercontent.com/ricardoerikson/benchmark-golang-maps/main/map_interface_cpu_profile.png" rel="noopener ugc nofollow" target="_blank"><em class="os">png</em></a><em class="os">，</em><a class="ae le" href="https://raw.githubusercontent.com/ricardoerikson/benchmark-golang-maps/main/map_interface_cpu_profile.svg" rel="noopener ugc nofollow" target="_blank"><em class="os">SVG</em></a><em class="os">)</em></figcaption></figure><h2 id="485b" class="mk ml iq bd my nt nu dn nc nv nw dp ng lo nx ny ni ls nz oa nk lw ob oc nm iw bi translated">基准结果</h2><p id="ffe5" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">我定制了基准测试来通过条目的数量和地图的初始容量(<code class="fe mb mc md me b">hint</code>)。这是处决的结果。当条目很少或初始容量大于条目数时，结果基本相同。如果您有许多条目，初始容量为0，您将获得一个完全不同的分配数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/465cb4a0aa60e7c5f5851cb9a1cbd6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SNbOKMhW-QGhcJbdiwnOw.png"/></div></div></figure><p id="4803" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">随着条目数量的增加，当我们比较<code class="fe mb mc md me b">Interface</code>和<code class="fe mb mc md me b">EmptyStruct</code>时，我们可以清楚地看到速度上的差异。<code class="fe mb mc md me b">Interface</code>基准比<code class="fe mb mc md me b">EmptyStruct</code>基准慢得多。我们还可以看到，当map的初始容量大于条目数时，map不需要太多的分配，因为所有条目都有一个预分配的空间。</p><h2 id="dbd5" class="mk ml iq bd my nt nu dn nc nv nw dp ng lo nx ny ni ls nz oa nk lw ob oc nm iw bi translated">结论</h2><p id="02ce" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">导致堆栈溢出问题的不同结果与性能和内存管理的映射优化有关。类型为<code class="fe mb mc md me b">map[int]interface{}</code>的映射速度较慢，因为当GC扫描可以保存指针的桶时，它们的性能会下降。类型<code class="fe mb mc md me b">map[int]struct{}</code>的地图使用更少的内存，因为它们实际上使用更少的内存😄。不需要为空结构分配空间(<code class="fe mb mc md me b">Test_EmptyStructValueSize</code>表明<code class="fe mb mc md me b">struct{}{}</code>的大小为零)。尽管<code class="fe mb mc md me b">nil</code>是<code class="fe mb mc md me b">interface{}</code>的零值，但是<code class="fe mb mc md me b">interface{}</code>类型需要一些空间来存储任何值(测试显示了保存<code class="fe mb mc md me b">nil</code>值不为零的<code class="fe mb mc md me b">interface{}</code>类型的大小)。最后，空结构基准分配更高，因为<code class="fe mb mc md me b">map[int]struct{}</code>类型需要更多溢出桶(为了性能优化),因为它的桶不包含任何指针。</p></div></div>    
</body>
</html>