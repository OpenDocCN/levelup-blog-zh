<html>
<head>
<title>How to get a Data Science Job…using Data Science-Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何获得一份数据科学工作…使用数据科学-第一部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/applying-data-science-and-web-scraping-to-find-a-job-on-linkedin-part-i-7192cff6d05b?source=collection_archive---------9-----------------------#2022-05-10">https://levelup.gitconnected.com/applying-data-science-and-web-scraping-to-find-a-job-on-linkedin-part-i-7192cff6d05b?source=collection_archive---------9-----------------------#2022-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4b335b4a534c1588951959f5bb8811a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFmn68-tJMq5R4oFn7k_dg.png"/></div></div></figure><p id="523b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">找工作是一项全职工作。你不得不花费无数的时间搜索和阅读招聘网站，<strong class="ka ir">写求职信</strong>，<strong class="ka ir">一遍又一遍地填写你的简历</strong>(即使你已经上传了简历)<strong class="ka ir">结果却发现你并不适合这个职位。</strong></p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/c97cab33de60e6d7751625a93be721b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R19RNbVEOBA29aBflZNOnA.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">当他们在你上传简历后告诉你输入你的工作经历时</figcaption></figure><p id="e965" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是等等！我们是数据科学家，一定有更好的方法来找到我们的理想工作，而不必阅读那里的每一个工作岗位。如果我们可以建立一个职位发布数据库，然后找到最符合我们资质的职位，那会怎么样？比如资历，编程语言，框架等。然后对每项工作进行评级，这样我们就可以<strong class="ka ir">优先考虑与</strong>更匹配的工作。那会很酷，不是吗？</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="bc35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我们将利用这个现实生活中的问题来介绍一些<strong class="ka ir">网络搜集技术</strong>以及学习如何应用<strong class="ka ir">数据科学</strong>思维方式来解决问题……<strong class="ka ir">因此，我们将利用数据科学来获得一份数据科学工作！</strong></p><h1 id="2c6e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">这个计划</h1><p id="b995" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在开始编码之前，让我们先在纸上解决问题，然后<strong class="ka ir">把它分成几个步骤。</strong></p><ol class=""><li id="e01c" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">找到数据来源——有很多招聘网站，但目前最受欢迎的是LinkedIn，所以这将是我们的数据来源。</li><li id="3a9b" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir">收集数据</strong> —我们将在Jupyter上编写一个Python脚本来访问LinkedIn，用关键词“数据科学”搜索工作，然后在我们从每个帖子中提取信息的同时抓取页面。</li><li id="128d" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">清理收集的数据——这对于任何ETL来说都是非常重要的一部分。将数据以尽可能好的形式呈现，使其易于理解和搜索。由于我们将处理非结构化数据，即人类编写的文本，我们将不得不清理文本并删除评分部分不必要的单词。</li><li id="d9b8" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir">创建一个评分函数</strong> —我们需要的是创建一个函数来评分我们与每个职位的匹配程度。简单地说，该函数将获取我们的简历和一个职位，输出将是一个介于0和1之间的数字:f(简历，职位)=分数</li></ol><h1 id="5e15" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">代码</h1><h2 id="d6bb" class="nd ln iq bd lo ne nf dn ls ng nh dp lw kj ni nj ma kn nk nl me kr nm nn mi no bi translated">登录LinkedIn</h2><p id="ae63" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">当天的第一个任务是<strong class="ka ir">安装硒库</strong>。我们将使用这个库用Python代码打开并<strong class="ka ir">控制一个Google Chrome窗口。我们还需要<strong class="ka ir">从以下网址下载from驱动程序</strong>:</strong></p><p id="bbf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae np" href="https://chromedriver.chromium.org/downloads" rel="noopener ugc nofollow" target="_blank">https://chromedriver.chromium.org/downloads</a></p><p id="09fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保chromedriver版本与您电脑上安装的Google Chrome版本相匹配。你可以打开谷歌浏览器，点击右上角的3个点来查看版本，然后进入帮助和关于浏览器。</p><p id="19e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们在项目文件夹中安装了Selenium和chromedriver，我们就可以开始编码了。我们将导入库:熊猫、硒和时间。后者是一个预安装的库，我们将使用它来<strong class="ka ir">增加等待时间，让浏览器在下一步之前完全加载</strong>一个页面。这是一个重要的考虑时，做网页抓取。然后<strong class="ka ir">我们将创建一个浏览器实例，并使用该实例进入LinkedIn登录页面。</strong></p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="6be4" class="nd ln iq nr b gy nv nw l nx ny">#Create browser instance by giving the address to chrome webdriver<br/>browser = webdriver.Chrome('./chromedriver')<br/># Navigate to LinkedIn Login page<br/>browser.get('<a class="ae np" href="https://www.linkedin.com/login/es?fromSignIn=true&amp;trk=guest_homepage-basic_nav-header-signin'" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/login/es?fromSignIn=true&amp;trk=guest_homepage-basic_nav-header-signin'</a>)</span></pre><p id="f8a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会看到一个谷歌浏览器窗口打开，并自动导航到LinkedIn。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d7aff7f828b0429bd7ba5865fcc6aebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*ALp8OefNx4gXc6Mu9TLvYg.gif"/></div></figure><p id="f117" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在将添加几行代码，让<strong class="ka ir">自动插入我们的LinkedIn用户和密码</strong>。要插入用户名，我们使用下面一行:</p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="644a" class="nd ln iq nr b gy nv nw l nx ny">browser.find_element(<a class="ae np" href="http://by.id/" rel="noopener ugc nofollow" target="_blank">By.ID</a>,'username').send_keys('erichhohenstein@gmail.com')</span></pre><p id="94a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们把这行代码</strong>打散。首先我们有一个浏览器实例，我们将其命名为<strong class="ka ir">“browser”</strong>，然后我们有方法<strong class="ka ir">“find _ element”</strong>我们将如何找到浏览器元素，在本例中为<strong class="ka ir"/><a class="ae np" href="http://by.id/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">by . id</strong></a><strong class="ka ir"/>，然后我们传递id <strong class="ka ir">“用户名”</strong>。我们使用Selenium的方式是在浏览器屏幕上找到元素，然后通过发送字符串、点击和其他命令与它们进行交互。如果你输入" By "然后点击tab，你可以看到所有可能的方法来找到元素。在本例中，我们传递了“用户名”id。<strong class="ka ir">我是用Chrome DevTools找到这个id的:在浏览器上右击→Inspect→Select and element to Inspect</strong>(这让你在页面上点击一个元素，然后显示元素背后的代码)</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">如何使用Chrome开发工具在网站上找到元素</figcaption></figure><p id="a150" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们同样发送密码，然后使用下面的<strong class="ka ir">代码点击登录按钮。</strong></p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="5567" class="nd ln iq nr b gy nv nw l nx ny">browser.find_element(By.CLASS_NAME,’btn__primary — large’).click()</span></pre><p id="c3b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，在这种情况下，我使用类名找到了元素，并使用了<strong class="ka ir">。click()方法</strong>点击按钮<strong class="ka ir">…我们就进去了！</strong></p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/dcfec0ab7145672ec69eafdd5f0d4599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*DM-cI6GlFbl30Z_K5UZ46A.jpeg"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">*黑客之声*我加入</figcaption></figure><p id="9c61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了保持代码的整洁，我们将为每个特定的任务使用函数。因此，登录函数的最终代码如下:</p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="b4fd" class="nd ln iq nr b gy nv nw l nx ny">def loginLinkedIn(browser,usr,psw):<br/>    # Go to LinkedIn Login page<br/>    browser.get('<a class="ae np" href="https://www.linkedin.com/login/es?fromSignIn=true&amp;trk=guest_homepage-basic_nav-header-signin'" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/login/es?fromSignIn=true&amp;trk=guest_homepage-basic_nav-header-signin'</a>)<br/>    time.sleep(4)<br/>    browser.find_element(By.ID,'username').send_keys(usr)<br/>    time.sleep(1)<br/>    browser.find_element(By.ID,'password').send_keys(psw)<br/>    time.sleep(1)<br/>    browser.find_element(By.CLASS_NAME,'btn__primary--large').click()<br/>    return browser</span></pre><p id="01ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我添加了<strong class="ka ir"> time.sleep(1) </strong>，所以程序在每一步之前会等待1秒钟。这样做是为了避免执行任务过快的错误，比如单击一个还没有呈现的按钮。</p><h2 id="2f5e" class="nd ln iq bd lo ne nf dn ls ng nh dp lw kj ni nj ma kn nk nl me kr nm nn mi no bi translated">网络爬行</h2><p id="d1c3" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">下一步是找工作。为此，我们将首先手动进行<strong class="ka ir">搜索，以获取URL并理解部分内容</strong>，如果是这样，我们可以使用它来抓取LinkedIn。</p><p id="7bba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在全球范围内搜索数据科学职位<strong class="ka ir">远程职位</strong>，得到了以下网址:</p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="75a6" class="nd ln iq nr b gy nv nw l nx ny"><a class="ae np" href="https://www.linkedin.com/jobs/search/?f_WT=2&amp;geoId=92000000&amp;keywords=data%20science&amp;location=Worldwide&amp;sortBy=R" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/jobs/search/?f_WT=2&amp;geoId=92000000&amp;keywords=data science&amp;location=Worldwide&amp;sortBy=R</a> and when I go to the next page 2, the link changes to <a class="ae np" href="https://www.linkedin.com/jobs/search/?f_WT=2&amp;geoId=92000000&amp;keywords=data" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/jobs/search/?f_WT=2&amp;geoId=92000000&amp;keywords=data</a>science&amp;location=Worldwide&amp;sortBy=R&amp;start=25</span></pre><p id="9f77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分析URL </strong>我们看到这里发生了3件重要的事情:</p><ol class=""><li id="36fa" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><strong class="ka ir"> "f_WT=" </strong>"后的数字搜索<strong class="ka ir">现场、远程或混合</strong>。其中2表示远程。</li><li id="eeb4" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">在<strong class="ka ir"> "keywords=" </strong>之后是我们要搜索的内容，用“%20”替换空格</li><li id="8797" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">在<strong class="ka ir">之后，“start=" </strong>是工作岗位的数量。每页从25的倍数<strong class="ka ir">开始。</strong></li></ol><p id="71da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这些知识，我们现在可以使用某种类型的循环来遍历所有的结果页面。那么我们抓取搜索结果的代码将如下所示。</p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="324f" class="nd ln iq nr b gy nv nw l nx ny">#PARAMETERS<br/>jobtype = '2' #Remote <br/>keyword = 'data%20science' # "%20" = space <br/>page = '0' #start at 0. Goes in multiples of 25 <br/>#URL<br/>URL = '<a class="ae np" href="https://www.linkedin.com/jobs/search/?f_WT=%27+jobtype+%27&amp;geoId=92000000&amp;keywords=%27+keyword+%27&amp;location=Worldwide&amp;sortBy=R&amp;start=%27+page" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/jobs/search/?f_WT='+jobtype+'&amp;geoId=92000000&amp;keywords='+keyword+'&amp;location=Worldwide&amp;sortBy=R&amp;start='+page</a></span></pre><h2 id="adbd" class="nd ln iq bd lo ne nf dn ls ng nh dp lw kj ni nj ma kn nk nl me kr nm nn mi no bi translated">LinkedIn招聘信息的网络抓取</h2><p id="ca12" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">接下来我们需要解决的是如何处理每个帖子。<strong class="ka ir">当我们点击一个职位时，整个描述会显示出来</strong>。所以我们需要写一个函数，这样每次我们的程序点击一个职位，里面的信息就被提取出来。我们想要得到的信息是:<strong class="ka ir">职位名称，公司，公司简介链接，地点，职位链接，海报姓名，海报简介链接，职位描述</strong>。我们现在将编写一个函数，该函数将接收Selenium浏览器实例并返回该信息。代码如下:</p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="89b5" class="nd ln iq nr b gy nv nw l nx ny">def getLinkedinJobs(browser,keyword,jobType,maxPageNumSearch):<br/>    actions = ActionChains(browser)<br/>    jobtype = str(jobType) #2 = Remote<br/>    keyword = keyword.replace(' ','%20') # %20 = space<br/>    jobData = [['title','company','companyLink','location','jobLink','posterName','posterProfileLink','jobDescription']]<br/>    for p in range(maxPageNumSearch):<br/>        page = str(p*25)<br/>        #print(page)<br/>        browser.get('<a class="ae np" href="https://www.linkedin.com/jobs/search/?f_WT='+jobtype+'&amp;geoId=92000000&amp;keywords='+keyword+'&amp;location=Worldwide&amp;sortBy=R&amp;start='+page" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/jobs/search/?f_WT='+jobtype+'&amp;geoId=92000000&amp;keywords='+keyword+'&amp;location=Worldwide&amp;sortBy=R&amp;start='+page</a>)<br/>        time.sleep(3)<br/>        #Search for all job postings shown<br/>        jobs = browser.find_elements(By.CLASS_NAME,'jobs-search-results__list-item')<br/>        i=0<br/>        for j in jobs:<br/>            #print(i)<br/>            i+=1<br/>            time.sleep(2)<br/>            actions.move_to_element(j).perform()<br/>            j.find_element(By.TAG_NAME,'img').click() #Click on the image so it doesnt misclick a URL<br/>            jobData.append(getJobInfo(browser))<br/>    df = pd.DataFrame(jobData[1:],columns=jobData[0])<br/>    #Drop any duplicate<br/>    df.drop_duplicates(subset = ['jobLink'],inplace=True)<br/>    return df</span></pre><p id="bac8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了很多事情，所以<strong class="ka ir">我们来分解一下</strong>。我们的函数接受以下<strong class="ka ir">输入</strong>:一个浏览器实例，要搜索的<strong class="ka ir">关键字</strong>(例如。“软件开发人员”)、一个<strong class="ka ir">作业类型</strong>(例如:远程作业为2)和<strong class="ka ir"> maxPageNumSearch </strong>。当我们在LinkedIn 上进行<strong class="ka ir">搜索时，结果被分成几页，这个数字代表我们想要抓取结果的页面。该函数将遍历所有结果页面(直到maxPageNumSearch ),并且对于每个页面，将<strong class="ka ir">点击每个帖子以在屏幕上显示职位描述。</strong>点击一个作业后，它调用函数<strong class="ka ir"> getJobInfo(browser) </strong>，该函数<strong class="ka ir">提取我们想要的所有信息</strong>并将其作为列表返回。最后，所有的列表被放入一个返回的<strong class="ka ir"> Pandas数据帧中。</strong><strong class="ka ir">getJobInfo()</strong>的代码如下:</strong></p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="a4eb" class="nd ln iq nr b gy nv nw l nx ny">def getJobInfo(browser):<br/>    title = ''<br/>    company = ''<br/>    companyLink = ''<br/>    location = ''<br/>    jobLink = ''<br/>    posterName = ''<br/>    posterProfileLink = ''<br/>    jobDescription = ''<br/>    try:<br/>        title = browser.find_element(By.CLASS_NAME,'jobs-unified-top-card__content--two-pane').text.split('\n')[0]<br/>    except:<br/>        pass<br/>    try:<br/>        company = browser.find_element(By.CLASS_NAME,'jobs-unified-top-card__company-name').text<br/>    except:<br/>        pass<br/>    try:<br/>        companyLink = browser.find_element(By.CLASS_NAME,'jobs-unified-top-card__company-name').find_element(By.TAG_NAME,'a').get_attribute('href')<br/>    except:<br/>        pass<br/>    try:<br/>        location = browser.find_element(By.CLASS_NAME,'jobs-unified-top-card__bullet').text<br/>    except:<br/>        pass<br/>    try:<br/>        jobLink = browser.find_element(By.CLASS_NAME,'jobs-unified-top-card__content--two-pane').find_element(By.TAG_NAME,'a').get_attribute('href')<br/>    except:<br/>        pass<br/>    try:<br/>        posterName = browser.find_element(By.CLASS_NAME,'jobs-poster__name').text<br/>    except:<br/>        pass<br/>    try:<br/>        posterProfileLink = browser.find_element(By.CLASS_NAME,'jobs-poster__name-link').get_attribute('href')<br/>    except:<br/>        pass<br/>    try:<br/>        jobDescription = browser.find_element(By.CLASS_NAME,'jobs-box__html-content').find_element(By.TAG_NAME,'span').text.replace('\n',' ')<br/>    except:<br/>        pass<br/>    return [title,company,companyLink,location,jobLink,posterName,posterProfileLink,jobDescription]</span></pre><p id="3bb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管它看起来很复杂，但这个函数遵循的是我们在开始时讨论过的相同原则。使用<strong class="ka ir"> Chrome开发工具</strong>找到一个元素名，然后使用selenium<strong class="ka ir">“find _ element”</strong>通过使用<strong class="ka ir"> ID，或者类名，或者任何其他对我们有用的方法</strong>找到元素。注意我是如何将每个find元素实例包含在一个<strong class="ka ir"> try-pass </strong>中的。当有些元素并不总是显示时，这是一个很好的实践。例如，有时“位置”元素不包含在职位信息中，所以我们可以安全地跳过“尝试通过”。</p><h1 id="735b" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">1000份从LinkedIn上抓取的工作！...现在怎么办？</h1><p id="1059" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我运行代码，使用我们的函数搜索远程数据科学工作:</p><pre class="kx ky kz la gt nq nr ns nt aw nu bi"><span id="e269" class="nd ln iq nr b gy nv nw l nx ny">getLinkedinJobs(browser,'data science','2',40)</span></pre><p id="3122" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我得到了一个数据框，里面有1000份招聘信息和所有数据。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/97109091886c081079df495987b307da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5Mnii2N4tgpJMAr5oAFcQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">LinkedIn数据科学工作搜集数据</figcaption></figure><p id="7e99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要看的招聘信息太多了！我们现在需要做的是找到一种方法来处理所有这些职位，这样我们就可以<strong class="ka ir">找到更适合我们的工作，并对我们的申请流程进行优先排序。这正是我们在下一篇博文中要做的。<strong class="ka ir">我们将应用数据科学将每个职位描述与我们的简历</strong>进行比较。我们将学习如何<strong class="ka ir">用<strong class="ka ir"> Python </strong>阅读pdf</strong>，然后如何进行<strong class="ka ir">文本比较，根据我们的简历给每个职位打分</strong>，找到最适合我们的工作。</strong></p><p id="10ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二部分在这里:<a class="ae np" href="https://medium.com/@erichhohenstein/applying-data-science-and-web-scraping-to-find-a-job-on-linkedin-part-ii-f5f5caabd371?source=friends_link&amp;sk=3e3a80f0561cc4b40358df1f7a36f9af" rel="noopener">https://medium . com/@ erichhohenstein/applying-data-science-and-web-scraping-to-find-a-job-on-LinkedIn-part-II-f 5 F5 caabd 371？source = friends _ link&amp;sk = 3 E3 a 80 f 0561 C4 b 40358 df 1 f 7 a 36 f 9 af</a></p><p id="547d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代号:<a class="ae np" href="https://github.com/erichho/LinkedIn-Job-Webscraper" rel="noopener ugc nofollow" target="_blank">https://github.com/erichho/LinkedIn-Job-Webscraper</a></p></div></div>    
</body>
</html>