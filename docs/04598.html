<html>
<head>
<title>Build a Node Service using Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes构建一个节点服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-node-service-using-kubernetes-b360bde91ced?source=collection_archive---------12-----------------------#2020-07-05">https://levelup.gitconnected.com/build-a-node-service-using-kubernetes-b360bde91ced?source=collection_archive---------12-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1b6a936e4f142fb78d2feb9b57b664c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uI2Y-R8gE_fcHTW0tDi95w.jpeg"/></div></div></figure><p id="6816" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将尝试向您介绍如何使用MongoDB开发为节点应用程序设置Kubernetes。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="ccfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">阅读本文的先决条件Node、TypeScript、Docker和Kubernetes的基础知识</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="37eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">让我们从设置应用程序开始</strong></p><p id="40b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们创建一个package.json并安装该应用程序所需的所有依赖项</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="0c4d" class="lp lq it ll b gy lr ls l lt lu">npm init</span></pre><p id="f8c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个应用程序中，我们将使用express framework和TypeScript。因此，让我们继续安装它。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="1756" class="lp lq it ll b gy lr ls l lt lu">npm i express @types/express typescript @types/typescript</span></pre><p id="6f64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，要在本地运行这个应用程序，我们需要ts-node-dev来运行并重启我们基于TypeScript构建的节点应用程序。更多信息可以在<a class="ae lv" href="https://www.npmjs.com/package/ts-node-dev" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="a442" class="lp lq it ll b gy lr ls l lt lu">npm i ts-node-dev</span></pre><p id="9884" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，要启动应用程序，请将package.json中的脚本标记编辑到下面的代码中，其中index.ts是应用程序的源文件。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="32c0" class="lp lq it ll b gy lr ls l lt lu">"scripts": {</span><span id="43cf" class="lp lq it ll b gy lw ls l lt lu">  "start": "ts-node-dev src/index.ts",</span><span id="9039" class="lp lq it ll b gy lw ls l lt lu">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span id="d9cc" class="lp lq it ll b gy lw ls l lt lu">}</span></pre><p id="169a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">为我们的应用程序创建一个express服务器并设置一个路由</strong></p><p id="263f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们在routes文件夹中创建一个简单的路由，稍后它将被转换为一个简单的注册路由</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="47a2" class="lp lq it ll b gy lr ls l lt lu">import express, { Request, Response } from "express";</span><span id="e2fd" class="lp lq it ll b gy lw ls l lt lu">const router = express.Router();</span><span id="2fef" class="lp lq it ll b gy lw ls l lt lu">router.get("/api/users/signup", (req: Request, res: Response) =&gt; {</span><span id="ac90" class="lp lq it ll b gy lw ls l lt lu">  console.log("API Hit");</span><span id="0c94" class="lp lq it ll b gy lw ls l lt lu">  res.send({ success: true });</span><span id="774b" class="lp lq it ll b gy lw ls l lt lu">});</span><span id="0e69" class="lp lq it ll b gy lw ls l lt lu">export { router as SignupRoute };</span></pre><p id="5fd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将把应用程序和express server分成两个文件，因为稍后我需要应用程序配置来为这个应用程序编写单元测试。</p><p id="df53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将在app.ts下定义我的应用程序</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="f056" class="lp lq it ll b gy lr ls l lt lu">import express from "express";</span><span id="4fe9" class="lp lq it ll b gy lw ls l lt lu">import { json } from "body-parser";</span><span id="da24" class="lp lq it ll b gy lw ls l lt lu">import { SignupRoute } from "./routes/signup";</span><span id="2522" class="lp lq it ll b gy lw ls l lt lu">const app = express();</span><span id="79a7" class="lp lq it ll b gy lw ls l lt lu">app.use(json());</span><span id="7e19" class="lp lq it ll b gy lw ls l lt lu">app.set("trust proxy", true);</span><span id="8b9d" class="lp lq it ll b gy lw ls l lt lu">app.use(SignupRoute)</span><span id="bca2" class="lp lq it ll b gy lw ls l lt lu">export { app };</span></pre><p id="3097" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在index.ts中启动express服务器</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="960f" class="lp lq it ll b gy lr ls l lt lu">import { app } from "./app";</span><span id="a963" class="lp lq it ll b gy lw ls l lt lu">const start = async () =&gt; {</span><span id="6c76" class="lp lq it ll b gy lw ls l lt lu">  app.listen(3000, () =&gt; {</span><span id="044e" class="lp lq it ll b gy lw ls l lt lu">    console.log(" listening on port 3000");</span><span id="f59d" class="lp lq it ll b gy lw ls l lt lu">  });</span><span id="72c0" class="lp lq it ll b gy lw ls l lt lu">};</span><span id="4e0f" class="lp lq it ll b gy lw ls l lt lu">start();</span></pre><p id="0512" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们的基本应用程序已经准备好了一个简单的路线，让我们为这个应用程序创建Docker文件</p><p id="d3e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">我们的节点应用程序的Docker</strong></p><p id="f396" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的docker文件将定义以下步骤</p><ol class=""><li id="cb09" class="lx ly it kd b ke kf ki kj km lz kq ma ku mb ky mc md me mf bi translated">From = &gt;我们将在哪个服务器上运行应用程序</li><li id="ff63" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">WORKDIR = &gt;我们的应用程序的目录</li><li id="2c6b" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">COPY =&gt; Copy package.json</li><li id="702c" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">运行= &gt;安装在pacakge.json中定义的所有npm软件包</li><li id="2700" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">复制= &gt;源文件的其余部分</li><li id="0298" class="lx ly it kd b ke mg ki mh km mi kq mj ku mk ky mc md me mf bi translated">CMD = &gt;运行我们的应用程序的命令</li></ol><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="dc0c" class="lp lq it ll b gy lr ls l lt lu">FROM node:13.3.0-alpine</span><span id="1e17" class="lp lq it ll b gy lw ls l lt lu">WORKDIR /app</span><span id="8636" class="lp lq it ll b gy lw ls l lt lu">COPY package.json .</span><span id="2256" class="lp lq it ll b gy lw ls l lt lu">RUN npm install --only=prod</span><span id="8c09" class="lp lq it ll b gy lw ls l lt lu">COPY . .</span><span id="380c" class="lp lq it ll b gy lw ls l lt lu">CMD ["npm","start"]</span></pre><p id="4e78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">建立并推广docker映像</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="b619" class="lp lq it ll b gy lr ls l lt lu">docker build -t dockerid/imagename .</span><span id="abfb" class="lp lq it ll b gy lw ls l lt lu">In my case its<br/>docker build -t suhas86/auth</span><span id="bb15" class="lp lq it ll b gy lw ls l lt lu">Followed by</span><span id="f215" class="lp lq it ll b gy lw ls l lt lu">docker push dockerid/imagename<br/>docker push suhas86/auth</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="75e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">为我们的应用程序设置Kubernetes】</strong></p><p id="d366" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在设置之前，让我们有一个小的库伯内特之旅</p><p id="b02b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">什么是Kubernetes？</strong></p><p id="308e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="ml">注意:如果你了解Kubernetes的基础知识，你可以跳过这一节</em> </strong></p><p id="3ae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes是一个运行许多不同容器的工具。</p><p id="13e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当我们想使用Kubernetes时，我们都需要一个docker图像。Docker图像基本上是如何创建容器的指南</p><p id="2744" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用这个映像创建一个容器，并将其部署到Kubernetes集群。</p><p id="4bf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了用docker映像创建一个容器，我们需要创建一个配置文件。在这个配置文件中，我们提到了需要运行多少docker映像副本，并使其可以从网络上访问。</p><p id="a30e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们将这个配置信息提供给Kubernetes时，它将获取docker映像。如果图像不可用，它将从docker hub下载。</p><p id="1dff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将下载docker映像并在pod中创建容器。Pod是Kubernetes应用程序的基本执行单元。</p><p id="d576" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以这些舱将运行我们的服务。但是，如果出了问题，我们需要重新启动吊舱呢？</p><p id="6835" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了维护pod，我们为pod创建部署。如果pod出现任何问题，或者说它崩溃或被意外删除。这些部署将确保自动重新创建它。</p><p id="7930" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，配置的第二部分是使它可以从网络访问。为此，Kubernetes创造了服务。服务提供对我们服务器内部运行的pod的访问。它处理我们Kubernetes集群中不同pod之间的网络。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="3e99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的项目中，让我们称之为auth，我们需要为auth模块和auth mongo DB部署和服务。所以让我们为相同的创建YAML文件。我们将在infra/k8s目录下创建这些YAML文件，这是标准做法。</p><p id="cffe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">用于授权的YAML文件</strong></p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="872c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的文件部署了pod以及连接到网络的服务。</p><p id="8c70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总结一下YAML文件，我们将部署的名称命名为auth-depl，将pod的名称命名为auth，在spec下，我们提供了创建容器所需的映像、Mongodb URL，接下来我们将为其创建一个配置文件，并通过名称auth-srv访问我们的pod。</p><p id="288e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，现在让我们为这个项目所需的mongo DB创建YAML</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8d3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个YAML文件中，我们将使用MongoDB团队创建的mongo映像在我们的pod中创建一个容器。</p><p id="3653" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">负载平衡器和入口控制器</strong></p><p id="b660" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要一个负载平衡器服务来从集群外部进行服务调用。负载平衡器服务将流量放入单个pod中。但是，如果我们有多个集群，单独的负载平衡器是不够的。如果我们有多个pod，我们需要将流量分配到不同的pod，我们需要有路由规则来决定将请求发送到哪里。为此，我们使用入口控制器。具有一组路由规则的pod</p><p id="b436" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个应用程序中，我们将使用ingress-nginx来创建负载平衡器服务和ingress。请点击此<a class="ae lv" href="https://kubernetes.github.io/ingress-nginx/deploy/" rel="noopener ugc nofollow" target="_blank">链接</a>获取NGINX入口控制器的安装指南。</p><p id="f1ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">YAML文件入口服务</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3bd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的YAML文件中，我提到了我们之前创建的<strong class="kd iu"> auth-srv </strong>的路由规则。还有，我提到过主持人是quiz.com。</p><p id="5131" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要更改本地主机的主机名</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="e10f" class="lp lq it ll b gy lr ls l lt lu">code /etc/hosts .</span><span id="cbc5" class="lp lq it ll b gy lw ls l lt lu">This will open host file in your code editor</span><span id="83ec" class="lp lq it ll b gy lw ls l lt lu">Add this at the end of the file<br/>127.0.0.1 quiz.com</span><span id="a2da" class="lp lq it ll b gy lw ls l lt lu">Note: If your editor is not configured in command path. Please do this manuallay. Also to make this change you need to grant Admin access</span></pre><p id="b9cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lv" href="https://skaffold.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">斯卡福德</strong> </a> <strong class="kd iu">进行开发</strong></p><p id="ef54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次我们进行更改时，我们都需要构建docker映像，推送映像，并再次应用Kubernetes部署，例如kubectl apply -f auth-dep.yaml ,这相当耗时且令人沮丧。为了在开发过程中自动化这一过程，我们使用了skaffold。此外，当我们退出skaffold时，将删除所有属于该项目的pod和对象。斯卡福德的安装指南可以在<a class="ae lv" href="https://skaffold.dev/docs/install/" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ac5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个配置文件中，我们在manifests下给了infra k8s路径，在artifacts下给了映像名称。</p><p id="d3e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在开发机器上运行我们的应用程序</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="7051" class="lp lq it ll b gy lr ls l lt lu">skaffold dev</span></pre><p id="4fb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将在您的控制台上看到类似的内容</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/4e5b90b8f62315d2243b87e58c791737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm3ZZOXT_JcOF-Z50rZ9Vw.png"/></div></div></figure><p id="c879" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果你打开另一个控制台，输入<strong class="kd iu"> kubectl get pods。</strong>您可以看到我们应用程序的所有窗格</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/3d86358a27470ee9bb87ba26a2fde576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdR86DFd8lCRh5nK-QGpBQ.png"/></div></div></figure><p id="5f1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要测试我们的负载平衡器服务和NGINX入口控制器，请访问postman或任何其他API测试工具，并测试我们在routes目录中编写的GET方法，您应该会得到200个响应。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/1c68bbcd1d16e3cdf4c6d6517f12dcae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6XVKxBjHPmpCthf2KJv1Q.png"/></div></div></figure><p id="1797" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">节点应用程序的Kubernetes设置到此结束。这方面的代码可以在<a class="ae lv" href="https://github.com/suhas86/node-typescript-kube-sample/tree/initial-setup" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到。</p><p id="b264" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近学习了Kubernetes来构建一个微服务应用。我对Kubernetes的世界如此着迷，我想在一篇文章中分享我的学习。希望这能让您了解如何为您的应用程序设置Kubernetes。如果你对我们如何改进这个设置有任何建议，请留下评论，因为这将有助于我和其他开发者在这方面做更多的改进。</p><p id="12cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一篇后续文章，我使用了MongoDB的相同设置，并解释了使用GitHub hooks的<a class="ae lv" href="https://medium.com/@murthy.suhas/test-driven-development-continuous-integration-using-nodejs-and-github-hooks-f9f0e2924f7" rel="noopener">测试驱动开发和持续集成。</a></p><p id="5f67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编码快乐，干杯！</p></div></div>    
</body>
</html>