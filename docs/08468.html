<html>
<head>
<title>iOS Content Localization and Versioning with Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Firebase进行iOS内容本地化和版本控制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ios-strings-localization-and-versioning-with-firebase-be5c67087ddd?source=collection_archive---------0-----------------------#2021-05-05">https://levelup.gitconnected.com/ios-strings-localization-and-versioning-with-firebase-be5c67087ddd?source=collection_archive---------0-----------------------#2021-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a0bcd38342448b3d0c606b8b0e5d375c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZHOBQmv9TiMnmuJmplY6A.png"/></div></div></figure><div class=""/><p id="d8c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Firebase已经成为任何iOS开发者添加到项目中的第一个工具。虽然<code class="fe kw kx ky kz b">Analysts</code>、<code class="fe kw kx ky kz b">Crashlytics</code>和<code class="fe kw kx ky kz b">Performance</code>通常是开箱即用的，但有一种工具会引发更多的问题。是<code class="fe kw kx ky kz b">Firebase Database</code>。</p><p id="9dd2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是如何处理app本地化的？</p><p id="93be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在生产中如何配置？</p><p id="3912" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何设置合适的环境和版本？</p><p id="1cdc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何使这种集成变得平滑、可维护和可测试？</p><p id="160c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在应用程序<code class="fe kw kx ky kz b">strings</code>的背景下讨论这个问题，并简要回顾处理<code class="fe kw kx ky kz b">strings</code>的不同方法。从没有本地化的最简单设置到具有版本控制的远程本地化数据库环境。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="913a" class="lh li jb bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">第一部分。你有标签文件吗？</h1><p id="9398" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">从事任何一个iOS项目，你迟早都要决定如何组织和存储所有标签、按钮和文本字段的字符串值。现在没有人(希望)直接硬编码字符串:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">别告诉我你的项目里还有这个</figcaption></figure><p id="6a59" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很可能您的项目中有一个文件<code class="fe kw kx ky kz b">Labels.swift</code>,它使您的字符串保持结构化并易于访问:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dab8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可以进化成更有组织性的东西:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="9d20" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">你注意到我们是如何把Struct改成Enum的了吗？它更有意义，因为我们使用静态属性，我们不想通过提供一种方法来创建一个无用的<code class="fe kw kx ky kz b">Labels</code>实例来误导我们自己或其他工程师。</p></blockquote><p id="8231" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以像下面这样简单地分配字符串值</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cf9b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个设置将完成这项工作，并且很有可能您不需要任何其他东西。</p><p id="f452" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，有一天你可能会决定支持另一种语言。所以说本地化吧。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="ff41" class="lh li jb bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">第二部分。本地化</h1><p id="68a1" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">向项目中添加本地化非常简单。进入<strong class="ka jc">项目- &gt;信息- &gt;本地化- &gt;加号按钮</strong>，选择所需语言:</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/f2727840b302391ab95c70f94a1c0a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4K2ntoEg6wZTGtS0odPjg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">添加本地化</figcaption></figure><p id="aa8a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您需要添加一个<code class="fe kw kx ky kz b">Localized.strings</code>文件，它将保存所有支持语言的字符串:转到<strong class="ka jc">文件- &gt;新建- &gt;文件</strong>，选择<strong class="ka jc">字符串文件</strong>，并将其命名为<code class="fe kw kx ky kz b">Localizable.strings</code>:</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/e8351e6741d6da88a1e29e4823e71fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEdPP5v7Ojx2GTaxHN9ITw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">添加本地化字符串</figcaption></figure><p id="83b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在项目导航器中选择<code class="fe kw kx ky kz b">Localized.strings</code>文件，在文件检查器中点击<code class="fe kw kx ky kz b">Localize</code>，并选择语言:</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/9497355a61ab6488af972989fbc07b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*di37jWo3Yi5_VGEP8gmUHg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">本地化字符串</figcaption></figure><p id="0198" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，对于您支持的每种语言，您都应该有这样一个文件:</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/6fcdfc1076ad52ec070fbe2b744dc1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKAFqagKuZZsAdNVTPOSIQ.png"/></div></div></figure><p id="b0cd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是它如何与我们的标签一起工作？好吧，这就是事情可能会变得一团糟的时候。</p><p id="2568" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，您需要将所有支持语言的所有字符串添加到<code class="fe kw kx ky kz b">Localizable.strings</code>:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">Localizable.strings(英语)</figcaption></figure><p id="19c5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要使用<code class="fe kw kx ky kz b">Labels</code>中的本地化字符串:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="7f6a" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Localized.strings</code>中的键应该与<code class="fe kw kx ky kz b">NSLocalizedString</code>中的键匹配。实际的字符串值将根据当前语言从<code class="fe kw kx ky kz b"> Localized.strings</code>中获取。</p></blockquote><p id="66e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你给一个字符串添加一个<code class="fe kw kx ky kz b">NSLocalizedString</code>，我会变得更加易读:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1095" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，根据项目的复杂性和您当前的目标，这种配置可能是您在应用程序中处理复制和本地化所需的全部。</p><p id="61ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是让我们回顾一下这个解决方案，看看这里可能会出现什么问题。</p><ul class=""><li id="6af5" class="nf ng jb ka b kb kc kf kg kj nh kn ni kr nj kv nk nl nm nn bi translated">我们需要仔细匹配<code class="fe kw kx ky kz b">Localized.strings</code>和<code class="fe kw kx ky kz b">Labels.swift</code>之间的按键。如果密钥错误，或者您忘记在<code class="fe kw kx ky kz b">Localized.strings</code>中提供值，用户将看到密钥本身，而不是实际的本地化值</li><li id="cb4e" class="nf ng jb ka b kb no kf np kj nq kn nr kr ns kv nk nl nm nn bi translated"><code class="fe kw kx ky kz b">Localized.strings</code>容易畸形。如果您有一个很大的<code class="fe kw kx ky kz b">Localized.strings</code> <em class="mx"> </em>文件，并且其中一行末尾缺少了分号——祝您找到正确的位置来修复它。Xcode对此没有给出任何线索:</li></ul><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/cd65d2671f06afc02d3afc6c6ebf39a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfNTL-jRwIksP4OGZwUl0w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">某处缺少分号</figcaption></figure><ul class=""><li id="1dcb" class="nf ng jb ka b kb kc kf kg kj nh kn ni kr nj kv nk nl nm nn bi translated"><code class="fe kw kx ky kz b">Localized.strings</code>是一个纯文本文件，没有办法让它结构化。一旦达到几百行，就变得几乎不可维护了。是的，您可以使用外部工具自动生成它，但是键匹配仍然是一项繁琐且容易出错的工作。</li><li id="c3d4" class="nf ng jb ka b kb no kf np kj nq kn nr kr ns kv nk nl nm nn bi translated">更重要的是，有一天你可能想更新一些字符串。比方说，你想把“欢迎使用我的酷App”改成“早上好！”。使用当前的方法，您需要更新所有<code class="fe kw kx ky kz b">Localized.strings</code>文件中的值，并发布您的应用程序的新版本。对于简单的字符串更新来说，这听起来不太合适，不是吗？</li></ul><p id="5284" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有上面列出的任何一个问题，是时候使用远程标签了！</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="8780" class="lh li jb bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">第三部分。远程标签</h1><p id="f6ee" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">我们将使用Firebase数据库作为后端，为您的应用程序提供标签。这将消除上面的大部分问题:您不再需要支持客户端上的多种语言，也不需要维护<code class="fe kw kx ky kz b">Localized.strings</code> <em class="mx">中的键匹配。</em>最棒的是，你只需点击几下就可以更新标签，而无需发布新的应用版本。然而，它仍然有一些缺点:</p><ul class=""><li id="1cd4" class="nf ng jb ka b kb kc kf kg kj nh kn ni kr nj kv nk nl nm nn bi translated">本地化没有去任何地方，它只是移动到Firebase。所以我们需要适当的维护它</li><li id="2051" class="nf ng jb ka b kb no kf np kj nq kn nr kr ns kv nk nl nm nn bi translated">配置应用程序以读取每个区域的正确标签</li><li id="65b9" class="nf ng jb ka b kb no kf np kj nq kn nr kr ns kv nk nl nm nn bi translated">维护Firebase上的数据库版本</li></ul><p id="8c5c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们深入研究一下，看看如何使它工作。</p><h2 id="dbac" class="nu li jb bd lj nv nw dn ln nx ny dp lr kj nz oa lv kn ob oc lz kr od oe md of bi translated">什么是Firebase数据库，它是如何工作的</h2><p id="9be9" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">我们不会讨论如何将Firebase依赖项添加到您的项目中，也不会进行基本的设置。Firebase为此提供了<a class="ae og" href="https://firebase.google.com/docs/ios/setup?authuser=0" rel="noopener ugc nofollow" target="_blank">良好的分步说明</a>。让我们直接跳到Firebase数据库，并开始为我们的项目实现它。</p><p id="aad2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Firebase数据库是一个云托管的noSQL数据库。它以普通的JSON格式保存数据，Firebase提供一个API以JSON格式获取数据:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="0c31" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">别忘了导入<code class="fe kw kx ky kz b"><em class="jb">FirebaseDatabase</em></code>。</p></blockquote><p id="a864" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想订阅实时更新，也可以使用<code class="fe kw kx ky kz b">DatabaseReference.observe</code>方法，但我们不需要这样做。我们想在应用程序启动后下载标签，而<code class="fe kw kx ky kz b">observeSingleEvent</code>会完成这项工作。如果您在应用中使用任何web服务，您应该已经熟悉JSON格式。Swift提供了一种简单的方法，通过<code class="fe kw kx ky kz b">Decodable</code>协议将JSON解析到您的Swift模型。</p><p id="4e31" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用Firebase从JSON中获取标签并解码之前，我们需要做一些更新:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="1c1d" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">标签将是一个符合<code class="fe kw kx ky kz b">Decodable</code>协议的结构，而不是保存实际值。注意，它不再是一个枚举，因为我们必须使用Labels的实例来访问它的内容。出于同样的原因，我们不再使用<code class="fe kw kx ky kz b">static let</code>。</p></blockquote><p id="cf03" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">综上所述，我们有了一种从FirebaseDatabase获取和解码标签的方法:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2f60" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们打开FirebaseDatabase并创建我们可以使用的标签JSON:</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/241d25b13d0381e32447bc81b2a21861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mgii3CgHjSib_ADKbQ37Uw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">简单标签示例</figcaption></figure><p id="4dbd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是以下JSON的Firebase可视化表示:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="bea2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行此代码，您将成功加载标签。恭喜你，你有了简单的远程存储标签！</p><p id="f4db" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是等等，本地化、版本化、生产和开发数据库，以及我们之前讨论过的所有额外津贴呢？</p><h2 id="1b3c" class="nu li jb bd lj nv nw dn ln nx ny dp lr kj nz oa lv kn ob oc lz kr od oe md of bi translated">Firebase数据库路径</h2><p id="fcae" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">FirebaseDatabase提供了一个孩子的概念，允许只获取数据库的某一部分。</p><p id="a106" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们可以通过使用带有子<code class="fe kw kx ky kz b">login</code>的<code class="fe kw kx ky kz b">DatabaseReference</code>来仅请求<code class="fe kw kx ky kz b">Labels.Login</code>:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="6a18" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">请注意，“登录”路径组件应该与数据库中的密钥相匹配。Firebase将只返回您小时候提供的键的数据。</p></blockquote><p id="4e89" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，我们可以想出一个简单的方法来添加多个本地化。我们还将使用<code class="fe kw kx ky kz b">Labels</code>作为标签的顶级关键字:</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/e44a201575e8e4d811e3cb2f048a893c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3mbslfmJEmo3_kPjvoy2A.png"/></div></div></figure><p id="d090" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需要指出Firebase数据库的正确路径。我们如何告诉应用程序将孩子<code class="fe kw kx ky kz b">ENG</code>或<code class="fe kw kx ky kz b">RUS</code>附加到路径上？我们已经有了这样的机制:<code class="fe kw kx ky kz b">Localized.strings</code>。我们需要一个单一的值，而不是面向用户的值:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">本地化字符串(英语)</figcaption></figure><p id="948e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们使用这个本地化的字符串来创建一个正确的数据库部分的路径:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d05d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您的应用程序将能够根据当前的本地化获取字符串。</p><p id="4252" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们如何将所有本地化的标签添加到Firebase数据库中呢？</p><h2 id="e5df" class="nu li jb bd lj nv nw dn ln nx ny dp lr kj nz oa lv kn ob oc lz kr od oe md of bi translated">为Firebase创建JSON</h2><p id="69d7" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">我们在您的应用程序中为每个地区创建了一个本地默认的<code class="fe kw kx ky kz b">Labels</code>实例:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ebab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，编译器将确保您不会遗漏任何键，因为手动创建JSON时可能会发生这种情况。相反，我们将从标签类的Swift实例生成JSON，并通过firebase控制台将其上传到Firebase。</p><p id="7e82" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JSON标签生成器是一个服务工具，因此在应用程序中创建一个单独的目标是有意义的。姑且称之为<code class="fe kw kx ky kz b">LabelsParser</code>。现在我们可以将<code class="fe kw kx ky kz b">DefaultLabelsENG</code>和<code class="fe kw kx ky kz b">DefaultLabelsRUS</code>移动到这个目标，并添加一个代码片段来生成JSON文件并将它们保存到您的计算机:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="b520" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">确保您的<code class="fe kw kx ky kz b">Labels</code>和所有嵌套的结构符合<code class="fe kw kx ky kz b">Codable</code>协议，这样您就可以将<code class="fe kw kx ky kz b">Labels</code>编码到JSON中。另外，确保<code class="fe kw kx ky kz b">DefaultLabelsENG</code>和<code class="fe kw kx ky kz b">DefaultLabelsRUS</code>在目标成员中都有一个<code class="fe kw kx ky kz b">LabelsParser</code>。</p></blockquote><figure class="mk ml mm mn gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/31f81f4fa06865fb2417394dd5c747d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*hxHZBpDZs-D4R3iezy8s8Q.png"/></div></figure><p id="ec8c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Firebase数据库控制台中，通过单击适当标签的键来导航路径<code class="fe kw kx ky kz b">ENG/labels</code>，从右侧菜单中选择Import JSON，找到创建的<code class="fe kw kx ky kz b">LabelsENG.json</code>，并导入文件。如果导入成功，Firebase将更新标签。对<code class="fe kw kx ky kz b">RUS/labels</code>路径和<code class="fe kw kx ky kz b">LabelsRUS.json</code>文件重复此步骤。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/f484940713239a70337da10d2c6f8efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGIgifXuNAA9a_Nixv0eAw.png"/></div></div></figure><p id="4586" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新标签将分为3个步骤:</p><ol class=""><li id="7daa" class="nf ng jb ka b kb kc kf kg kj nh kn ni kr nj kv ol nl nm nn bi translated">更新<code class="fe kw kx ky kz b">Labels</code>结构(添加、删除或重命名关键字或嵌套结构，或更改字符串值)</li><li id="e7d5" class="nf ng jb ka b kb no kf np kj nq kn nr kr ns kv ol nl nm nn bi translated">Xcode会抛出<code class="fe kw kx ky kz b">DefaultLabelsENG</code>和<code class="fe kw kx ky kz b">DefaultLabelsRUS</code>中的错误，所以你需要相应地更新它们</li><li id="6491" class="nf ng jb ka b kb no kf np kj nq kn nr kr ns kv ol nl nm nn bi translated">最后，用<code class="fe kw kx ky kz b">LabelsParser</code>重新生成JSON文件并上传到Firebase</li></ol><p id="6bb4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您只想更新现有的字符串值，可以直接在Firebase中完成，所有用户将在下次应用程序启动时获取更新的标签。还是没有？</p><p id="4ef4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果所有用户都期待现有的JSON格式，我们如何更新实时数据库呢？如果我们更改或删除Firebase数据库中的一些密钥，<code class="fe kw kx ky kz b">Labels</code>解码将会失败。</p><p id="01a4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题意味着您已经准备好配置数据库环境和版本。</p><h2 id="974b" class="nu li jb bd lj nv nw dn ln nx ny dp lr kj nz oa lv kn ob oc lz kr od oe md of bi translated">数据库环境</h2><p id="7b68" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">在配置数据库环境之前，我们还需要做一件事来确保标签解析总是成功的。提供默认标签。我们已经有了一个<code class="fe kw kx ky kz b">DefaultLabelsENG</code>，如果Firebase连接或JSON解析由于任何原因失败，我们只需要返回这个而不是抛出错误:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="4501" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">您还可以在上面的截图中添加本地化检查，以根据当前应用程序的区域设置返回正确的默认标签。</p></blockquote><p id="ac5f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到我们的环境和版本问题。任何远程数据库都应该至少有两个环境:<code class="fe kw kx ky kz b">Development</code>和<code class="fe kw kx ky kz b">Production</code>(您可以添加<code class="fe kw kx ky kz b">Staging</code>、<code class="fe kw kx ky kz b">Beta</code>，并根据您的项目需要添加任意多个)。你的应用程序的所有真实用户都应该连接到<code class="fe kw kx ky kz b">Production</code>环境，而开发人员和测试人员应该使用<code class="fe kw kx ky kz b">Development</code> one。</p><p id="6e59" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了用Firebase实现这一点，我们将采用与本地化相同的方法:数据库路径。在数据库的根目录中，我们创建了两个键，<code class="fe kw kx ky kz b">Development</code>和<code class="fe kw kx ky kz b">Production</code>，它们中的每一个都有当前数据库的副本:</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi om"><img src="../Images/c55e50d8186a74d81b18e0e2ab15aeed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76PQ_QS0cujxjinJpvEQAQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">开发和生产</figcaption></figure><p id="4010" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了将应用指向正确的数据库路径，我们在创建Firebase数据库引用时使用了<code class="fe kw kx ky kz b">#if DEBUG</code>检查:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="6783" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">除了使用<code class="fe kw kx ky kz b">#if DEBUG</code>标志，<a class="ae og" href="https://nshipster.com/xcconfig/" rel="noopener ugc nofollow" target="_blank">您还可以使用</a> <code class="fe kw kx ky kz b"><a class="ae og" href="https://nshipster.com/xcconfig/" rel="noopener ugc nofollow" target="_blank">.xcconfig</a></code> <a class="ae og" href="https://nshipster.com/xcconfig/" rel="noopener ugc nofollow" target="_blank">文件</a>在Xcode的开发和生产环境之间进行选择。这种方法提供了更多的灵活性和清晰度。对于这个例子，我们将坚持使用<code class="fe kw kx ky kz b"><em class="jb">#if DEBUG</em></code> <em class="jb">标志</em></p></blockquote><p id="77ce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">拥有开发和生产数据库固然很好，但是支持多个应用版本又如何呢？例如，您的版本<code class="fe kw kx ky kz b">1.0.0</code>在生产中有一个数据库。后来你发布了一个新的<code class="fe kw kx ky kz b">1.1.0</code>版本，在<code class="fe kw kx ky kz b">Labels</code>中有一些变化。如果您更新您的<code class="fe kw kx ky kz b">Production</code>数据库以匹配新版本，所有使用先前应用版本的用户将无法下载标签。现在我们讨论数据库版本。</p><blockquote class="mu mv mw"><p id="3943" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">我们所说的数据库版本化是指数据库必须支持应用程序上的所有版本。所以我们需要为版本<code class="fe kw kx ky kz b">1.0.0</code>、<code class="fe kw kx ky kz b">1.1.0</code>等有一个单独的数据库路径。</p></blockquote><p id="17f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了处理这个问题，我们将创建一个<code class="fe kw kx ky kz b">Environment</code>枚举:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="4123" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">正如您所注意到的，对于生产环境，我们提供了一个字符串形式的应用程序版本。稍后我们会将它与当前的iOS应用程序版本进行匹配。<code class="fe kw kx ky kz b">stringValue</code>为给定环境创建一个数据库路径。</p></blockquote><p id="96a1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将我们在应用数据库配置中的所有内容打包，让我们创建一个新的<code class="fe kw kx ky kz b">Endpoint</code>类，它将负责为您的所有环境、应用版本和区域设置构建正确的路径:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7a0a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了<code class="fe kw kx ky kz b">Endpoint</code>，我们可以创建出<code class="fe kw kx ky kz b">WebService</code>，我们将使用它来获取<code class="fe kw kx ky kz b">labels</code>:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8232" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们初始化<code class="fe kw kx ky kz b">WebService</code>:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="mu mv mw"><p id="a432" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">也可以使用<code class="fe kw kx ky kz b">CFBundleShortVersionString</code>获取当前app版本，而不是硬编码。只要确保Firebase数据库有一个适合这个应用程序版本的密钥，并且版本格式是相同的。</p></blockquote><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/ed41a76f683f2a50130759fb59570719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yQ74ZCuPfSLcSonxTDNVQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">Firebase数据库的最终版本</figcaption></figure><p id="13a3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这种设置，您可以使用Firebase数据库来支持任意数量的本地化、应用程序环境和版本。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="f084" class="lh li jb bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">第四部分。还有一点</h1><p id="2329" class="pw-post-body-paragraph jy jz jb ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">为你的数据库添加测试URL路径会很棒。在本例中，您可以测试<code class="fe kw kx ky kz b">Endpoint.labelsReference</code>是否与给定的<code class="fe kw kx ky kz b">Endpoint</code>匹配。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/6e4cda5955765c4b691fbfee40960720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChrXjdBHyomc_IiHyshJrw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">完整的URL字符串在顶部</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="cb4b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我知道你对这个数据库设置的想法，我随时欢迎你的反馈。</p><p id="b97e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我刚刚在我最新的<a class="ae og" href="https://bikemeter.app.link/medium" rel="noopener ugc nofollow" target="_blank">自行车追踪器应用</a>中创建了同样的<code class="fe kw kx ky kz b">WebService</code>。如果你像喜欢编码一样喜欢骑自行车，那就去试试吧。如果你想要免费应用程序订阅的促销代码，请在LinkedIn上ping我。</p></div></div>    
</body>
</html>