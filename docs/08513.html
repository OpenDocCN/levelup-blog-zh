<html>
<head>
<title>OnCollisionEnter vs. OnTriggerEnter and when to use them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OnCollisionEnter与OnTriggerEnter以及何时使用它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oncollisionenter-vs-ontriggerenter-and-when-to-use-them-c62d2ceabcbd?source=collection_archive---------1-----------------------#2021-05-08">https://levelup.gitconnected.com/oncollisionenter-vs-ontriggerenter-and-when-to-use-them-c62d2ceabcbd?source=collection_archive---------1-----------------------#2021-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6b0a94ccdd0c3f6e8852048856d6e4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIb2tyyqP9jxZZMS77RGdA.png"/></div></div></figure><div class=""/><figure class="gl gn kd ke kf iv gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/dc973c6b4a0077676a9ffc47252c2d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*JBafh-7XKMYHaycmSU3TUw.png"/></div></figure><p id="e841" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OnCollisionEnter将会像它听起来那样被使用…带着冲撞！当我想到碰撞时，我首先想到的是<strong class="ki jf">硬表面碰撞</strong>，这正是OnCollisionEnter所指的。汽车碰撞、球反弹和树倒下都是硬表面碰撞的例子！我将在本文中介绍一些不同版本的OnCollision。首先，碰撞的<strong class="ki jf">进入</strong>方面可以在下面的文档中看到。基本上，<strong class="ki jf">碰撞事件</strong>发生在一个物体<strong class="ki jf">接触另一个物体</strong>的瞬间<strong class="ki jf">。当这种情况发生时，关于碰撞的<strong class="ki jf">信息</strong>就在我们的指尖，可以<strong class="ki jf">访问</strong>。如下所述，<strong class="ki jf">一个</strong>物体绝对碰撞<strong class="ki jf">需要</strong>有一个<strong class="ki jf">刚体连接</strong>才能工作。</strong></p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi le"><img src="../Images/b7d083fedf8810a7352e514d50a49f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFNVeSIT_2zTFItC4FvAaw.png"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/e6fe2a84ac43c9a82420e2ffac8f69ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*1GTqTTanGyv_xRbpgstvaQ.png"/></div></figure><p id="b826" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如下文所述，只要对象<strong class="ki jf">相互接触</strong>，则<strong class="ki jf">oncolissionstay</strong>方法对<strong class="ki jf">有效。这可能就像当一个球停止反弹，停在地板上。还要注意的是，在进行接触时，每帧</strong>调用一次Stay方法<strong class="ki jf">。</strong></p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lr"><img src="../Images/21077bdabf6cc1924e8668431ca5e334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5i9_A9UHvlLdAn7tkauRtQ.png"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ls"><img src="../Images/40219385d323e180f5058bd6e58a58c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6wp7FfptpA3JgGwN-0cVw.png"/></div></div></figure><p id="7471" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦对象<strong class="ki jf">停止</strong>接触，调用<strong class="ki jf">oncolissionexit</strong>方法关闭对象交互。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lt"><img src="../Images/2b6cae3988d90eb4a153adceda33877c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvMgxDks3HaKSa5Cq2jaBg.png"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/d9daa3ccdab358876298327ba1186ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*uAEmdezXQOFUkU8G6hCFfA.png"/></div></figure><p id="704e" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jf">触发</strong>碰撞是<strong class="ki jf">通过</strong>碰撞，此时物体<strong class="ki jf">不会相互弹开</strong>，但是当<strong class="ki jf">接触</strong>时<strong class="ki jf">事件</strong>可以被<strong class="ki jf">触发</strong>。我在我的子弹和敌人的碰撞中使用这个，这样子弹就不会被敌人弹开而消失。相反，它似乎被吸收了，然后就消失了。碰撞<strong class="ki jf">信息</strong>也可用于触发事件。就像OnCollisionEnter一样，OnTriggerEnter get被称为对象碰撞的时刻。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lv"><img src="../Images/1e9496f783881cc6d005da07b7a112de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0dAPs3UKoY1laPDPU7ncQ.png"/></div></div></figure><p id="f89d" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<strong class="ki jf">是触发器</strong>选项需要在上切换<strong class="ki jf">以将其用作触发器。</strong></p><div class="lf lg lh li gt ab cb"><figure class="lw iv lx ly lz ma mb paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/4327e922246bf861662642bd3f3c06c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*8BNF0dH4znccz1YehR9p_g.png"/></div></figure><figure class="lw iv mc ly lz ma mb paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/f8d18fd477a3c60b59280d463767c22c.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*RAdN8UX4Vas2Xdtoxu5AvQ.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk mh di mi mj translated">玩家盒子碰撞器(左)。敌箱碰撞器和刚体(右)。</figcaption></figure></div></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mk"><img src="../Images/f9858676a987e44b7a33f7930a35e03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tj3Yjx2-BZoSRsKSEa0Q-w.png"/></div></div></figure><p id="0d9e" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jf"> OnTriggerStay </strong>方法的工作原理类似于OnCollisionStay，只是这些物体可以通过彼此自由移动<strong class="ki jf">，然后<strong class="ki jf"> Stay </strong>方法<strong class="ki jf">继续</strong>触发<strong class="ki jf">，同时</strong>物体碰撞器<strong class="ki jf">接触</strong>。</strong></p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ml"><img src="../Images/670fd05a9fa411ecff8a53e3ab95027b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTkHLlUM9B4jE6VWpYeohA.png"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/91c4683d98111e96f3d6a7a4c2fb668d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*hU8rItfCGAJP5Bp_5yv0Sg.png"/></div></figure><p id="4aa2" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你已经注意到这里的一个主题，那就是<strong class="ki jf"> OnTriggerExit </strong>方法的工作方式类似于OnCollisionExit，当游戏对象<strong class="ki jf">停止接触</strong>时<strong class="ki jf">触发</strong>。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/19ea99e771d25b26023ef77f816d6535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*pOIi7W5sjizzCDhYI9gL-Q.png"/></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="aa75" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的敌人脚本中，我使用OnTriggerEnter来收集一些信息。我用<strong class="ki jf">调试。日志</strong>告诉我与我相撞的<strong class="ki jf">其他</strong>物体的<strong class="ki jf">名称</strong>。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mo"><img src="../Images/90ef298b865a8f4a7df701eeaa4ef06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqZD3k-aiocWKz3S-y21kw.png"/></div></div></figure><p id="ec3d" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我运行了一个小的<strong class="ki jf">测试</strong>让一个敌人打<strong class="ki jf">玩家</strong>，用<strong class="ki jf">子弹</strong>射击另一个。您可以在下面控制台上看到冲突信息。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/45fca102bc23ca9c4ccbe2af31ab82bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*krttTppfHR7LgqVgkokzhQ.png"/></div></figure><p id="e6ea" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更进一步，我要求被碰撞物体的<strong class="ki jf">名称</strong>和<strong class="ki jf">位置</strong>。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/06ead0c7ecaa8ad019fd0728a0847633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KMumLnWXOzgPiLaDg4xONg.png"/></div></div></figure><p id="7449" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里可以看到，与敌人碰撞的<strong class="ki jf">其他</strong>物体的<strong class="ki jf">名称</strong>和<strong class="ki jf">位置</strong>以(x，y，z)的形式打印到控制台上！</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/cb1bfe533886bfce955c59422d338134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*64H0p3ioFiN3ubfHhqdKpg.png"/></div></figure><p id="e8fd" class="pw-post-body-paragraph kg kh je ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显而易见，所有这些碰撞选项都可以用于一些高级的游戏机制。即使只是一次小小的碰撞，也有很多机会获取信息并采取行动！<br/>说到<strong class="ki jf">碰撞</strong>可能产生的<strong class="ki jf">动作</strong>，我将在下一篇文章中开始使用<strong class="ki jf"> GetComponent </strong>进行脚本通信，在那里这些碰撞可以开始触发一些更有意义的交互。</p></div></div>    
</body>
</html>