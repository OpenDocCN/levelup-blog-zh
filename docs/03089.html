<html>
<head>
<title>JavaScript Best Practices — Improving Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—改进类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-improving-classes-b343d5c1102a?source=collection_archive---------15-----------------------#2020-04-18">https://levelup.gitconnected.com/javascript-best-practices-improving-classes-b343d5c1102a?source=collection_archive---------15-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/885903a91de0deb568420861fc33bf9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AcpgddGR6aafEBF9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="24f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用默认参数和属性缩写，清理我们的JavaScript代码很容易。</p><p id="1073" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究创建类的最佳实践，以及何时应该创建它们。</p><h1 id="7dd1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构造器</h1><p id="659d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了让我们的构造函数变得更好，我们应该做一些事情。它们如下。</p><h1 id="70a0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如果可能，初始化所有构造函数中的所有成员数据</h1><p id="a9d0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该把它们都放在构造函数中，这样当我们实例化对象时它们都被初始化了。</p><p id="1cda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6985" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>}</span></pre><p id="a972" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们确保所有的东西都用一个值初始化了。</p><h1 id="20be" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在构造函数中创建一个单例</h1><p id="7694" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们只需要构造函数的一个实例，那么我们可以创建它的一个实例。</p><p id="b24d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7f94" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    if (this.instance) {<br/>      this.instance = {<br/>        name<br/>      }<br/>    }<br/>    return this.instance;<br/>  }<br/>}</span></pre><p id="ac71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，如果<code class="fe mv mw mx mm b">this.instance</code>还没有定义，我们返回我们创建的对象。</p><p id="669c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们返回设置为<code class="fe mv mw mx mm b">this.instance</code>的值。</p><h1 id="699c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">除非证明并非如此，否则更喜欢深层副本而不是浅层副本</h1><p id="6171" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">深层拷贝拷贝所有东西，所以这比浅层拷贝好多了。浅层拷贝会留下一些引用原始对象的内容。</p><p id="2953" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想要一个真实的副本，那就不好了。</p><p id="a846" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们必须让我们的代码生成深层副本，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a0c2" class="mq lf it mm b gy mr ms l mt mu">const copy = obj =&gt; {<br/>  const copied = {<br/>    ...obj<br/>  };<br/>  for (const k of Object.keys(obj)) {<br/>    if (typeof obj[k] === 'object') {<br/>      copied[k] = {<br/>        ...copied[k]<br/>      };<br/>      copy(copied[k]);<br/>    }<br/>  }<br/>  return copied;<br/>}</span></pre><p id="0c98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是使用spread操作符来复制嵌套的对象，如果找到一个的话。递归地做同样的事情。</p><p id="d9f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们返回复制的对象。</p><h1 id="8caa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们应该什么时候创建一个类？</h1><p id="e64e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该总是创造阶级。在一些情况下，创建一个类是有意义的。</p><h2 id="3313" class="mq lf it bd lg my mz dn lk na nb dp lo kr nc nd ls kv ne nf lw kz ng nh ma ni bi translated">模拟真实世界的物体</h2><p id="584d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类对于建模现实世界的对象非常有用，因为它们建模对象的行为</p><p id="52be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们让我们将实例变量和方法封装到一个包中，分别存储状态和对对象执行操作。</p><h2 id="910f" class="mq lf it bd lg my mz dn lk na nb dp lo kr nc nd ls kv ne nf lw kz ng nh ma ni bi translated">模型抽象对象</h2><p id="884d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">同样，我们可以使用类来建模抽象对象。</p><p id="f885" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们可以用来进行抽象，抽象是不同种类对象的概括。</p><p id="bd34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类非常适合保存子类的共享成员。子类可以继承它们。</p><p id="9877" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们应该保持继承树的简单，这样人们就不会对代码感到困惑。</p><h2 id="1aab" class="mq lf it bd lg my mz dn lk na nb dp lo kr nc nd ls kv ne nf lw kz ng nh ma ni bi translated">降低复杂性</h2><p id="7014" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用类来降低程序的复杂性。</p><p id="cba5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类非常适合隐藏信息。在JavaScript中，类中还没有私有变量，所以我们必须在方法中隐藏数据。</p><p id="bdf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样我们就可以最小化程序不同部分之间的耦合。</p><h2 id="652d" class="mq lf it bd lg my mz dn lk na nb dp lo kr nc nd ls kv ne nf lw kz ng nh ma ni bi translated">隐藏实施细节</h2><p id="f195" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">方法也有利于隐藏实现细节。</p><p id="4d91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将细节隐藏在方法中，只运行需要的东西。</p><p id="700e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以在方法中嵌套函数和变量。</p><h2 id="24ed" class="mq lf it bd lg my mz dn lk na nb dp lo kr nc nd ls kv ne nf lw kz ng nh ma ni bi translated">限制变化的影响</h2><p id="ac3e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">变化的影响可以被减少，因为我们可以隐藏事情。</p><p id="27da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与隐藏实现一样，可以通过限制方法中更改的影响来隔离更改的影响。</p><h2 id="a212" class="mq lf it bd lg my mz dn lk na nb dp lo kr nc nd ls kv ne nf lw kz ng nh ma ni bi translated">隐藏全局数据</h2><p id="46f0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通过将全局数据放入类的方法中，它们可以变成私有数据。</p><p id="d82c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那他们就不用暴露在公众面前了。我们所要做的就是使用<code class="fe mv mw mx mm b">let</code>和<code class="fe mv mw mx mm b">const</code>在方法中声明它们。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/47de048c62946fdb7205ff931fa041ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wiBNfMDKmjmxciaS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@the_bracketeer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨德里克·科内里森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="300a" class="mq lf it bd lg my mz dn lk na nb dp lo kr nc nd ls kv ne nf lw kz ng nh ma ni bi translated">流线参数传递</h2><p id="4d47" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们将相同的参数传递给不同的函数，那么我们可以将参数更改为实例变量，将函数更改为方法。</p><p id="a4f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7d2a" class="mq lf it mm b gy mr ms l mt mu">const speak = (name) =&gt; `${name} spoke`;<br/>const greet = (name) =&gt; `hi, ${name}`;</span></pre><p id="a40a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以将这些方法放入它们自己的类中，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b6fb" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  speak() {<br/>    return `${this.name} spoke`;<br/>  }<br/>  greet() {<br/>    return `hi, ${this.name}`;<br/>  }<br/>}</span></pre><p id="89ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们不必到处都经过<code class="fe mv mw mx mm b">name</code>。</p><p id="653b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是创建了一个<code class="fe mv mw mx mm b">Person</code>的实例，并在不传入任何参数的情况下调用这些方法。</p><h1 id="5c03" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="2054" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以创建类来封装数据和打包东西。然而，我们不应该为每件事创建类。</p><p id="de7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该尽可能制作深层拷贝而不是浅层拷贝。</p></div></div>    
</body>
</html>