<html>
<head>
<title>Building neural network with PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PyTorch构建神经网络</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-neural-network-with-pytorch-e30019aa362?source=collection_archive---------24-----------------------#2021-03-28">https://levelup.gitconnected.com/building-neural-network-with-pytorch-e30019aa362?source=collection_archive---------24-----------------------#2021-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3d99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之前我们讨论了从零开始构建监督学习模型。现在是时候推出大枪了。我将使用PyTorch库来构建一个能够识别手写数字的模型。从头开始写完所有东西后，PyTorch如何简化开发和测试深度学习模型的过程令人惊叹。让我们看看我得到了什么。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/c47732bac5f51d277f544eb449d4e019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pvyx8-QWdo_WBghNOd-zGA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图片由<a class="ae ko" href="https://commons.wikimedia.org/wiki/File:Pytorch_logo.png" rel="noopener ugc nofollow" target="_blank">sou Smith chint ala</a>提供</figcaption></figure><h2 id="477f" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated"><strong class="ak">先决条件</strong></h2><p id="eb43" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">因为我们要使用PyTorch，所以它必须安装在您的机器上。此外，库必须导入到python文件中。我们需要的是:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi md"><img src="../Images/7009363d47a25b178d82110251a9b83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHNhuner-15b4EtiFA9k4g.png"/></div></div></figure><h2 id="ab2d" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated"><strong class="ak">型号描述</strong></h2><p id="c319" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们将使用卷积神经网络(CNN)来教会模型识别图像上的数字。首先让我们创建一个python类，从PyTorch导入所有必需的库，声明并连接CNN模型中的所有层。它看起来是这样的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi me"><img src="../Images/3746df34f1c98c2c1b6eb1933b999743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4LPrnZIwlCri7hzy1U0sg.png"/></div></div></figure><p id="f2c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的模型包括:</p><ul class=""><li id="aa35" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><strong class="js iu"> Conv2d </strong> —是一个卷积层，用2d矩阵计算输入和输出之间的关系。</li><li id="692c" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><strong class="js iu"> MaxPool2d </strong> —缩小矩阵或缩小数据。</li><li id="202b" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><strong class="js iu"> Dropout </strong> —正则化函数，将输入张量中的一些元素随机置零。</li><li id="3eb3" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><strong class="js iu">线性</strong> —是一个线性变换层。</li></ul><p id="3e5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看各层是如何连接的。卷积网络有输入和输出通道。您可以看到每个下一层输入通道如何与上一层的输出通道相匹配。这同样适用于线性层。</p><p id="1c5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个模型的另一个方面是前馈过程，看起来是这样的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/b4158c0ef18335b265a1dbfe4a32c9d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*uNJFo7hJ6tKsVjGGqFPHZg.png"/></div></figure><p id="599e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所看到的，线性层的每个卷积都通过了relu激活函数。在每一层(但是线性的)之后，我们缩小数据并应用正则化函数。</p><h2 id="892e" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated"><strong class="ak">数据和模型准备</strong></h2><p id="a9a7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">下一步是准备数据和配置模型。我们将从批处理开始。您可能知道，我们无法将整个训练数据集加载到模型中，因为世界上没有任何内存可以做到这一点。这就是为什么我们必须把数据集分成几个部分。此外，数据需要转换成张量和标准化。令人高兴的是，PyTorch图书馆已经有了MNIST的数据。它可以在本地下载，然后用于培训和测试。事情是这样完成的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mu"><img src="../Images/e526939a685821092ab9bb402fa56f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhZaC7rjkGrXw_gNme2Yqw.png"/></div></div></figure><p id="b186" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步将指定应该使用哪个硬件，CPU还是GPU。你可能听说过GPU卡在矩阵乘法方面表现非常好，这可以加快学习过程。如果机器有GPU，我打算让PyTorch使用GPU，如果没有，使用CPU。</p><p id="be79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，必须启动模型以及损失和优化功能。损失是交叉熵，优化是亚当。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mv"><img src="../Images/d3e52fda28267d5b8998d772e8630998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUKGPV8JXpA5MIkbzXA_XA.png"/></div></div></figure><h2 id="8380" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated"><strong class="ak">训练</strong></h2><p id="7be2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">培训过程与<a class="ae ko" href="https://betterprogramming.pub/neural-network-from-scratch-hidden-layers-bb7a9e252e44" rel="noopener ugc nofollow" target="_blank">以前的</a>完全一样。将数据前馈到模型中，计算损耗，反向传播损耗并应用优化函数。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/29d9dae102e599bb5764f0e4d05a8d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*ZTqEi9ltTyUdNuadJogo1w.png"/></div></figure><h2 id="c539" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated"><strong class="ak">评估模型</strong></h2><p id="5a2f" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">为世界准备模型的最后一步是评估它在训练和训练后的测试数据上的表现。评估函数是这样的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/97f2e1aa6b9f70c749f10edc6d1eba9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*8r7UwoV9n9VkwH3RUXh0HQ.png"/></div></figure><h2 id="1ea5" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated"><strong class="ak">部署架构</strong></h2><p id="85e8" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">为了能够在应用程序中使用经过训练的模型，我们需要保存它。基本上，它保存的是模型每一层的权重值。PyTorch的拯救模式是这样的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0404e96d9cc9ccc42ceb557a4246b85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*mF72-J54-yEGMFCdO9iaXg.png"/></div></figure><p id="d14f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们准备在一些应用程序中部署CNN模型。有了数字识别器，就很容易提出概念应用程序的证明。用户应该能够在前端绘制图像，然后这将被发送到后端，转换成可馈送的形式和饲料的模型。输出应该被发送回前端渲染它。</p><p id="7b32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于frontend我就不多说了，只说我用React.js和React Canvas Draw让用户在浏览器里画东西。</p><p id="d31f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使模型有用，我在Flask的帮助下设计了一个简单的API，并将其部署在heroku上。</p><p id="052a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在这里查看前端和API <a class="ae ko" href="https://github.com/Exo-Labs/digits_recognizer/tree/main/web_app" rel="noopener ugc nofollow" target="_blank">的完整代码。在这里</a><a class="ae ko" href="https://mldigits.netlify.app" rel="noopener ugc nofollow" target="_blank">您可以尝试该模型如何与定制输入一起工作。</a></p><h2 id="d8cf" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated"><strong class="ak">结论</strong></h2><p id="c233" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我的主要动机是把人工智能从实验室中取出来，放到现实世界中。我想把这个机会给我自己和每个人，让他们接触和使用基于人工智能的应用。请让我在评论中知道，应用程序如何(或不)识别你的图纸。</p><p id="efa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不断学习，不断成长！</p></div></div>    
</body>
</html>