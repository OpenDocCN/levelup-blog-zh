<html>
<head>
<title>Node.js Best Practices — Going to Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—投入生产</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-best-practices-going-to-production-55f08c3d48d1?source=collection_archive---------2-----------------------#2020-04-29">https://levelup.gitconnected.com/node-js-best-practices-going-to-production-55f08c3d48d1?source=collection_archive---------2-----------------------#2020-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cded0b32d1fa29027944c4577856d181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j5zoqNDQelu4sfdc"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Anukrati Omar 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bf3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是编写应用程序的流行运行时。这些应用程序通常是许多人使用的生产质量应用程序。为了使维护它们变得更容易，我们必须为人们设定一些准则来遵循。</p><p id="c9cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看我们的节点应用程序在投入生产之前和之后应该做些什么。</p><h1 id="5042" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用类似生产的环境进行E2E测试</h1><p id="e9c5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在类似生产的环境中运行端到端的测试确保了我们不会在生产中遇到我们预先发现的不同问题。</p><p id="2ba5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该用干净的数据在数据库中运行我们的测试，这样我们就可以重复我们的测试。</p><h1 id="5052" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用静态分析工具定期重构</h1><p id="3ab8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在将我们的代码投入生产之前，我们应该重构我们的代码，以便它能在生产中快速运行。自动化测试将帮助我们确保重构不会破坏任何现有的功能。</p><p id="bfe3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">糟糕的代码质量会产生更多难以修复的bug和性能问题。</p><h1 id="0395" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">谨慎选择我们的CI平台</h1><p id="f889" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Jenkins和CircleCI是持续集成的流行平台。有了CI(持续集成)管道，我们可以在后台自动运行测试和部署，而不是手动运行一切。它将我们从其他工作中解放出来，并将我们从手动管理基础架构中解放出来。</p><p id="3d07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须谨慎选择，因为从一个地方迁移到另一个地方会很痛苦。</p><h1 id="a805" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">监控我们的应用</h1><p id="5ce8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该监控我们的应用程序，这样我们的应用程序才能正常运行，不会占用太多资源。为此，我们可以使用监控工具并添加健康检查端点来检查我们的应用程序是否正在运行。</p><p id="b81d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不必让客户告诉我们，我们的应用程序失败了。</p><h1 id="e9e4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用智能日志记录增加透明度</h1><p id="d243" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">日志记录让我们可以通过发现lo中可能导致问题的活动来轻松地解决问题。大多数日志平台可以控制如何收集、存储和分析日志，以确保只存储我们需要的数据。</p><h1 id="76f6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将任何可能的事情委托给反向代理</h1><p id="ef21" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果一些事情可以通过反向代理来完成，那么它们就不属于我们的应用程序。CPU密集型任务，如SSL，Gzipping，终止都应该在一个反向代理上完成，以减轻我们的应用程序的负荷。</p><p id="98b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于Node应用程序尤其重要，因为它只运行在一个线程上，所以我们不想让它做属于反向代理的基础设施相关的任务。</p><h1 id="5f8d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">锁定依赖关系</h1><p id="39af" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该锁定我们的应用程序的依赖关系，这样它们就不会在不同的环境中改变版本。现在，这应该是自动完成的，因为如果不存在的话,<code class="fe mh mi mj mk b">npm install</code>会生成一个<code class="fe mh mi mj mk b">package-lock.json</code>。如果它确实存在，那么<code class="fe mh mi mj mk b">npm install</code>将使用文件中的版本来安装依赖项。</p><p id="debc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它不存在于我们的回购协议中，或者如果我们使用细粒度的版本锁定控制，我们可以运行<code class="fe mh mi mj mk b">npm shrinkwrap</code>。这个命令重新将<code class="fe mh mi mj mk b">package-lock.json</code>变成一个可发布的<code class="fe mh mi mj mk b">npm-shrinkwrap.json</code>或者创建一个新的。</p><p id="0dc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它优先于<code class="fe mh mi mj mk b">package-lock.json</code>。</p><h1 id="8a74" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用正确的工具保障流程正常运行</h1><p id="04af" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的应用程序失败时必须重新启动。我们可以使用永久或PM2观看我们的应用程序，并在它崩溃时重新启动。如果我们有一个集群，那么我们也必须管理它。</p><h1 id="3d56" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">利用所有CPU内核</h1><p id="4d58" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该使用所有的CPU内核，以最快的性能运行我们的应用程序。如果CPU内核处于闲置状态，它就毫无用处。如果是这样的话，我们应该复制节点进程并利用所有的CPU。对于小型应用程序，我们可以使用节点集群或PM2。否则，我们可能会使用像ECS这样的Docker集群。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/b2687b85b8744d21e821cde8bb00fbe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ESzN-4Dw5bC5z0wm"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Vincent van Zalinge 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="4b75" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建“维护端点”</h1><p id="fdfd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用它来安全地公开应用程序中的诊断信息，而无需登录到服务器。有些信息使用代码更容易获得。</p><p id="b8be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Node中，我们可以使用<code class="fe mh mi mj mk b">os</code>模块来公开关于我们的服务器的信息。例如，我们可以如下获取应用程序的平台，并通过端点返回它:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="353c" class="mu lf it mk b gy mv mw l mx my">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const os = require('os');</span><span id="840d" class="mu lf it mk b gy mz mw l mx my">const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="7bbc" class="mu lf it mk b gy mz mw l mx my">app.get('/', (req, res, next) =&gt; {<br/>  res.send(os.platform());<br/>});</span><span id="098d" class="mu lf it mk b gy mz mw l mx my">app.listen(3000, () =&gt; console.log('server started'));<br/>module.exports = app;</span></pre><p id="3446" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，在生产应用程序中，这应该通过身份验证来保护。</p><h1 id="3377" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="63ce" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在投入生产之前，我们应该有一套端到端的测试，在一个干净的类似生产的环境中运行。数据应该在每次测试运行时重置，这样它们才能正常运行。这也有助于重构后的测试。</p><p id="6971" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该确保我们已经实现了自动化部署，以便为其他任务腾出时间。</p><p id="09f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，确保我们的服务器的CPU核心都得到利用。</p><p id="8b97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可能希望创建一个安全的维护端点，在不登录服务器的情况下向我们公开一些信息。</p></div></div>    
</body>
</html>