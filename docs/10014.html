<html>
<head>
<title>A Go Debugging Anti-Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去调试反模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-go-debugging-anti-pattern-6777a1fe7c34?source=collection_archive---------11-----------------------#2021-10-14">https://levelup.gitconnected.com/a-go-debugging-anti-pattern-6777a1fe7c34?source=collection_archive---------11-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e7be31ba5a11aa62c81cf00030059ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9aMX9vlEaD4E7fIOCUPaw.jpeg"/></div></div></figure><p id="fc7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我工作的地方，单元测试中出现了一种模式，使用一级函数在测试函数中声明局部作用域的函数。我相信它有机地进入了我们的代码，有人用它来避免以封装良好的方式复制一组断言。下面是一个示例:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="f279" class="li lj it le b gy lk ll l lm ln">func TestSomething(t *testing.T) {<br/>  validate := func(expectX, expectY int) {<br/>    // some assertions making sure we got the proper X and Y<br/>  }</span><span id="86b0" class="li lj it le b gy lo ll l lm ln">  // Do some testing<br/>  validate(1, 2)</span><span id="14af" class="li lj it le b gy lo ll l lm ln">  // Do some more testing<br/>  validate(3, 4)<br/>}</span></pre><p id="0511" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一组断言被封装在一个<em class="lp"> validate </em>函数中，并在测试的不同时间被调用。我第一次看到这个模式时，它引起了我的注意，因为我通常会这样写:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="aad1" class="li lj it le b gy lk ll l lm ln">func TestSomething(t *testing.T) {<br/>  // Do some testing<br/>  validate(1, 2)</span><span id="bfa7" class="li lj it le b gy lo ll l lm ln">  // Do some more testing<br/>  validate(3, 4)<br/>}</span><span id="c16d" class="li lj it le b gy lo ll l lm ln">func validate(expectX, expectY int) {<br/>  // some assertions making sure we got the proper X and Y<br/>}</span></pre><p id="977e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我有点喜欢局部作用域的第一类函数的封装，但是我的直觉告诉我它似乎是关闭的，所以当我把它留在代码中时，我自己继续使用普通函数。</p><h2 id="45a1" class="li lj it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">我的直觉被证明是正确的</h2><p id="40c1" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">今天，我向其中一个包含一级函数的测试中添加了新的测试用例。一级函数中的一个断言失败。我没有预料到失败，需要进行调查，所以我在断言处设置了一个断点，在调试模式下运行测试，然后……<em class="lp">什么都没有</em>。调试器完全忽略了断点。套用杰瑞·宋飞的话:</p><blockquote class="mm mn mo"><p id="db3c" class="kb kc lp kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated">它知道如何获取断点，但它只是不知道如何在断点处中断，这是断点最重要的部分，中断。</p></blockquote><p id="93cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将一级函数重构为一个普通函数，瞧，断点成功了。</p><p id="0c97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这似乎是我的IDE调试集成中的一个bug(IntelliJ——参见读者评论),但我可以看到为什么会发生这种情况。使用一个一级函数，我会<em class="lp">假设</em>(也就是我在猜测)<em class="lp">，</em>改变了确定代码位置的方式，而调试器没有为此做好准备。</p><p id="7bfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我没有看到封装的巨大优势，我声明这是一个反模式，至少对IntelliJ来说是这样，并且鼓励人们<strong class="kd iu">而不是</strong>使用它。</p></div></div>    
</body>
</html>