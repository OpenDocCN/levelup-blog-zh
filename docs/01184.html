<html>
<head>
<title>How to Solve Two Sum in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript求解两个和</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-solve-two-sum-in-javascript-d1ebd9dfd3d3?source=collection_archive---------3-----------------------#2019-11-24">https://levelup.gitconnected.com/how-to-solve-two-sum-in-javascript-d1ebd9dfd3d3?source=collection_archive---------3-----------------------#2019-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a041" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不用排序，线性时间解决经典面试问题。</h2></div><p id="c2e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两个和——这可能是现存最丰富的算法问题之一，因此，应该广泛练习。</p><p id="e6d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这是一个常见的问题，但这个问题有很多变体，可能会在面试中绊倒开发人员。</p><p id="3333" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在面试中可以使用的一个约束是不允许<strong class="kk iu">对输入数组</strong>进行排序。这个约束是评估候选人是否彻底理解数据结构及其可能的时间复杂性的一个很好的方法。</p><p id="11f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将深入探讨<strong class="kk iu">两个Sum </strong>。以下是我们将使用的问题描述:</p><blockquote class="le lf lg"><p id="bdcb" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">给定一个整数数组，返回<strong class="kk iu">一个数组，包含两个数字的索引</strong>，这两个数字加起来就是一个特定的目标。可以假设每个输入将有<strong class="kk iu"> <em class="it">恰好</em> </strong>一个解，并且<em class="it">相同的</em>元素可以<strong class="kk iu">而不是</strong>被使用两次。最后，数组不能排序。</p></blockquote></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="a975" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">理解问题</h1><p id="bad9" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">问题描述的第一行非常具体:给定一个数组，返回两个数的索引，这两个数加起来就是某个目标。此外，很明显返回值应该是一个包含两个索引的<strong class="kk iu">数组</strong>。</p><p id="e2d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给定了一个整数数组的<strong class="kk iu">是肯定的，但是这个描述并没有明确目标是否可以是<code class="fe mp mq mr ms b">null</code>或者除了<code class="fe mp mq mr ms b">number</code>之外的数据类型。例如，<strong class="kk iu">目标</strong>可能是<code class="fe mp mq mr ms b">'3'</code>，它是一个<code class="fe mp mq mr ms b">string</code>，但可以被强制为<code class="fe mp mq mr ms b">number</code>。</strong></p><p id="b1c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在面试中，这些都是问面试官的好问题。出于这个问题的目的，假设<strong class="kk iu">目标</strong>将始终是<code class="fe mp mq mr ms b">number</code>数据类型的整数。</p><p id="9173" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二句解释了对于一个设定的<strong class="kk iu">目标</strong>数，在一个给定的数组中只有<strong class="kk iu">一个</strong>解。因此，可以返回第一对和等于目标数的数字，而不会引发异常。</p><p id="7240" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，同一元素不能使用两次。这意味着一个元素不能通过自身相加来达到目标数。</p><p id="b3ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，最后一行表示数组不能排序。</p><p id="3b7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然问题已经解释清楚了，那就把它分解成小的需求。这将有助于创建算法。</p><ol class=""><li id="ac37" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated">给定一个整数数组和一个整数。</li><li id="5dee" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">找出和等于整数输入的两个数，然后返回它们的索引。</li><li id="3920" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">返回值应该是一个数组，其中存储了索引。</li><li id="82fd" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">给定索引中的同一元素不能使用两次。</li><li id="3fad" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">对于给定的数组和目标整数，只有一个解。</li><li id="87a5" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">不允许排序。</li></ol><h2 id="af1a" class="nh lt it bd lu ni nj dn ly nk nl dp mc kr nm nn me kv no np mg kz nq nr mi ns bi translated">测试案例</h2><p id="11fe" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这个问题实际上非常简单，所以没有必要覆盖大量的边缘情况；但是，有一种边缘情况需要考虑，那就是:<strong class="kk iu">负整数</strong>。</p><p id="9304" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题描述没有说整数一定是正数。因此，一个数组中有负元素的测试用例以及一个目标数为负的用例包含在测试套件中是明智的。</p><p id="f7b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以根据需要包含任意多的测试，但是这些是本文的测试用例:</p><ol class=""><li id="6da7" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated"><code class="fe mp mq mr ms b">array = [3, 2, 4], target = 6</code></li><li id="3122" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated"><code class="fe mp mq mr ms b">array = [6, 2, 3, 9, -5, 5, 7, 2], target = 1</code></li><li id="fd8f" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated"><code class="fe mp mq mr ms b">array = [2, -3, 1, -5], target = -3</code></li></ol><p id="0930" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是时候规划一个算法了。</p><blockquote class="le lf lg"><p id="c143" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">注:<code class="fe mp mq mr ms b">n</code>将代表<code class="fe mp mq mr ms b">array</code>的<code class="fe mp mq mr ms b">length</code>属性。</p></blockquote></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="34d6" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">暴力算法是不够的</h1><p id="04cd" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">因为这个问题的本质是找到加起来等于某个数的元素对，这个问题的逻辑很容易理解:</p><ol class=""><li id="d5ca" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated">对于<code class="fe mp mq mr ms b">array</code>中的<code class="fe mp mq mr ms b">currentElement</code>，对照目标检查<code class="fe mp mq mr ms b">currentElement</code>和<code class="fe mp mq mr ms b">nextElement</code>的总和。如果是<code class="fe mp mq mr ms b">sum === target</code>，返回<code class="fe mp mq mr ms b">currentElement</code>和<code class="fe mp mq mr ms b">nextElement</code>的索引。</li><li id="1c7e" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">遍历<code class="fe mp mq mr ms b">array</code>，检查每个元素以及每个具有更高索引的元素，直到找到正确的元素对。</li></ol><p id="4988" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个<strong class="kk iu">蛮力</strong>解决方案。这不是一个有效的解决方案，因为在找到所需的对之前，它可能需要多次迭代<code class="fe mp mq mr ms b">array</code>。</p><p id="367b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在大多数情况下，会有一个测试用例，它有一个包含数千个元素的数组。现在，假设元素的<code class="fe mp mq mr ms b">sum === target</code>在索引<code class="fe mp mq mr ms b">[array.length — 2, array.length — 1]</code>处。</p><p id="a9d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了到达这两个元素，来自<code class="fe mp mq mr ms b">array</code>的<code class="fe mp mq mr ms b">n-1</code>元素必须在<code class="fe mp mq mr ms b">currentElement</code>循环的每次迭代中被迭代。</p><blockquote class="le lf lg"><p id="ace5" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">记住，<code class="fe mp mq mr ms b">currentElement</code>必须与<code class="fe mp mq mr ms b">array</code>中之后的每个元素<strong class="kk iu">相加，因为<code class="fe mp mq mr ms b">currentElement</code>之前的元素已经检查过了。</strong></p></blockquote><p id="52aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种嵌套循环会导致数千次不必要的迭代。</p><p id="e40c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个图表，详细说明了检查整个<code class="fe mp mq mr ms b">array</code>所需的迭代次数。请记住，这是一个非常小的输入；想象一下这种类型的算法在一个<strong class="kk iu">巨大的</strong>输入上。</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi nt"><img src="../Images/df4dd57f87c08d1ba280827e9b84e86a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HeCnAKQy7wwly_okd8nSyg.png"/></div></div></figure><p id="bcd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">红色的<strong class="kk iu">窗口代表<code class="fe mp mq mr ms b">currentElement</code>。<strong class="kk iu">绿色</strong>窗口代表所有必须添加<code class="fe mp mq mr ms b">currentElement</code>以检查<code class="fe mp mq mr ms b">sum === target</code>的元素。对于绿色窗口中的每个元素，都有一次迭代。</strong></p><p id="957f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用数学术语来表达，在一个<code class="fe mp mq mr ms b">array</code>中有<code class="fe mp mq mr ms b">n**2</code>个可能的配对。因此，这种算法最长(最坏的情况)可能需要<code class="fe mp mq mr ms b">O(n**2)</code>时间，这是非常低效的。</p><p id="6062" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看出，强力解决方案对于大型<code class="fe mp mq mr ms b">array</code>输入并不理想。</p><p id="6c0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">必须有一种方法来最小化找到正确对所需的迭代次数。是否有一种数据结构允许恒定的<code class="fe mp mq mr ms b">O(1)</code>查找时间？</p><h2 id="976a" class="nh lt it bd lu ni nj dn ly nk nl dp mc kr nm nn me kv no np mg kz nq nr mi ns bi translated">哈希表</h2><p id="6a23" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">一个<strong class="kk iu">散列表</strong>是键和值对的集合。一个<strong class="kk iu">散列函数</strong>用于将值映射到索引，也称为键。这些键和值对允许恒定的查找时间。</p><p id="f64f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，我们可以使用一个<code class="fe mp mq mr ms b">object</code>来创建一个散列表。下面是一个简单哈希表的例子:</p><figure class="nu nv nw nx gt ny"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e770" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如第6–9行所示，可以通过引用<code class="fe mp mq mr ms b">hashTable</code>中的<code class="fe mp mq mr ms b">value</code>从<code class="fe mp mq mr ms b">values</code>访问每个元素的<code class="fe mp mq mr ms b">index</code>。</p><p id="a5c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用哈希表的主要好处是<code class="fe mp mq mr ms b">O(1)</code>查找时间。一旦值被映射到某种惟一的键，就可以使用它的键立即引用该值，而不需要遍历值列表来找到正确的值。</p><h1 id="4cba" class="ls lt it bd lu lv oh lx ly lz oi mb mc jz oj ka me kc ok kd mg kf ol kg mi mj bi translated">创建更高效的算法</h1><p id="7a16" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">因此，对两个Sum使用哈希表是一个明智的想法；然而，对于这个问题，使用one的正确方法是什么？</p><p id="d9a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">强力解决方案有两个循环，一个嵌套在另一个里面。耗时较长的循环是嵌套循环，因为它经历了几次<code class="fe mp mq mr ms b">array</code>。在上图中，嵌套循环被着色为绿色。</p><p id="7bd2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果只有第一个循环，由上图中的<strong class="kk iu">红色</strong>窗口表示，时间复杂度将是<code class="fe mp mq mr ms b">O(n)</code>，因为在最坏的情况下<code class="fe mp mq mr ms b">array</code>将需要被完全迭代以找到正确的对。</p><p id="11cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">消除嵌套循环是个好主意。嵌套循环可以用哈希表代替吗？</p><p id="5680" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的——哈希表实际上可以很好地与单个循环一起工作。</p><p id="835b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，循环将一次迭代一个元素。这意味着<code class="fe mp mq mr ms b">currentElement</code>必须与<code class="fe mp mq mr ms b">array</code>中的所有其他元素进行核对。这如何用哈希表实现呢？</p><p id="9b89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe mp mq mr ms b">currentElement</code>配对的数字是<code class="fe mp mq mr ms b">currentElement</code>和<code class="fe mp mq mr ms b">target</code>之间的<strong class="kk iu">差值</strong>。因此，将<code class="fe mp mq mr ms b">target — currentElement</code>存储在<code class="fe mp mq mr ms b">currentDifference</code>中。使用哈希表的查找功能，检查<code class="fe mp mq mr ms b">currentDifference</code>是否是哈希表中的<strong class="kk iu">键</strong>。</p><p id="62a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它存在于哈希表中，这意味着它是<code class="fe mp mq mr ms b">array</code>的一个元素。</p><p id="b5fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一张图纸详细说明了算法的这一步。出于本图的目的，输入为:<code class="fe mp mq mr ms b">array = [3, 2, 4], target = 6</code>。另外，<code class="fe mp mq mr ms b">currentElement = 2</code>在循环中。</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi om"><img src="../Images/596ebdd9a285b7db3a06b80cb46cab73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mgrjUUaHKYBKDR3RAZI1Q.jpeg"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">有时候，笔和纸是必要的。</figcaption></figure><p id="b62f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些输入的答案是<code class="fe mp mq mr ms b">[1, 2]</code>，因为索引<code class="fe mp mq mr ms b">1</code>和<code class="fe mp mq mr ms b">2</code>处的<code class="fe mp mq mr ms b">2</code>和<code class="fe mp mq mr ms b">4</code>分别包含一对数字，其总和为<code class="fe mp mq mr ms b">target = 6</code>。</p><p id="3bf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面提出的算法通过在<code class="fe mp mq mr ms b">hashTable</code>中查找<code class="fe mp mq mr ms b">currentDifference</code>来找到该元素是否存在，从而成功找到了正确的元素。然后，它返回索引<code class="fe mp mq mr ms b">hashTable[currentDifference]</code>并在返回值<code class="fe mp mq mr ms b">[1, 2]</code>中使用。<code class="fe mp mq mr ms b">1</code>代表<code class="fe mp mq mr ms b">array</code>中<code class="fe mp mq mr ms b">currentElement</code>的索引。</p><p id="0938" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，该算法的唯一警告是，元素不能与自身组合来匹配<code class="fe mp mq mr ms b">target</code>。不过，对<code class="fe mp mq mr ms b">currentElementIndex !== hashTable[currentDifference]</code>的简单检查将消除这种边缘情况。</p><p id="65ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，最后的算法是:</p><ol class=""><li id="e09f" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated">创建一个对象，分别包含元素及其索引的键值对。</li><li id="534a" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">迭代通过<code class="fe mp mq mr ms b">array</code>。对于<code class="fe mp mq mr ms b">currentElement</code>，计算<code class="fe mp mq mr ms b">currentDifference</code>。</li><li id="d74d" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">如果<code class="fe mp mq mr ms b">hashTable</code>和<code class="fe mp mq mr ms b">currentElementIndex !== hashTable[currentDifference]</code>中存在<code class="fe mp mq mr ms b">currentDifference</code>，则返回每个元素的索引。</li><li id="fd7d" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">如果<code class="fe mp mq mr ms b">currentDifference</code>不存在或者两个元素的索引相等，则移动到<code class="fe mp mq mr ms b">array</code>中的下一个元素。</li></ol></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="4119" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">实现算法</h1><p id="6ff5" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">首先，声明一个函数<code class="fe mp mq mr ms b">twoSum</code>并声明一个变量来存储对象。</p><figure class="nu nv nw nx gt ny"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9469" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是遍历<code class="fe mp mq mr ms b">nums</code>数组。在一个<code class="fe mp mq mr ms b">for</code>循环中这样做，这样<code class="fe mp mq mr ms b">break</code>提前是可能的。</p><p id="f39f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个循环中，还要检查哈希表中是否存在<code class="fe mp mq mr ms b">currentDifference</code>:如果存在，<code class="fe mp mq mr ms b">return</code>正确的索引。在<code class="fe mp mq mr ms b">else</code>的情况下，将当前元素指定为<code class="fe mp mq mr ms b">numsIndexes</code>上的属性，并将其值指向索引<code class="fe mp mq mr ms b">i</code>。</p><figure class="nu nv nw nx gt ny"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3394" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是时候在LeetCode上测试这个解决方案了，以确保大型测试用例可以成功执行。</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div class="gh gi or"><img src="../Images/b3caedb2758bc49eefcf37762b51f2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*Cm_pijWPTr3k2JkxABClSA.png"/></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">几乎100%！</figcaption></figure><p id="d73c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">99.51%!那相当快。此外，整个测试套件被成功执行。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="6575" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">结论</h1><p id="518f" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这篇文章涉及大量信息和算法，因此在这一点上做得非常好。</p><p id="4f67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看出，在算法中使用哈希表可以大大降低算法的时间复杂度。在这个问题中使用哈希表的策略可以很好地转移到许多其他问题中，所以在处理困难问题时要保持它。</p><p id="b73f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！</p></div></div>    
</body>
</html>