<html>
<head>
<title>Publishing private NPM packages to Nexus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向Nexus发布私有NPM包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-private-npm-packages-to-nexus-a16722cc8166?source=collection_archive---------0-----------------------#2018-10-10">https://levelup.gitconnected.com/deploying-private-npm-packages-to-nexus-a16722cc8166?source=collection_archive---------0-----------------------#2018-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/39af543d44f353fcee57de6b37ed2650.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*nYOlEmWlIlFt4ugndsdisQ.jpeg"/></div></figure><p id="46d7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们都参与过一些项目，这些项目给了我们构建可重用组件的机会。大多数情况下，这些组件最终会出现在项目的<code class="fe ks kt ku kv b">shared</code>文件夹中。然后，这个文件夹被复制粘贴到几个项目中，随着时间的推移，这变成了一个更新的噩梦，因为我们不容易拥有一个组件的多个版本，并且在多个分支上维护相同的代码版本是解决这个问题的一种方法。</p><p id="b853" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将了解Nexus Repository Manager(又名Nexus)，这是一个由<a class="ae kw" href="https://www.sonatype.com/" rel="noopener ugc nofollow" target="_blank"> Sonatype </a>提供的开源存储库管理器。我们将讨论如何创建一个私有存储库(由亚马逊S3支持)并将其与公共的NPM注册中心相结合，以提供一个成熟的解决方案，可以保持我们的私有存储库的私有性，允许版本控制，以及缓存存储库。</p><p id="9cda" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将创建两个应用程序，其中一个将被推送到Nexus，另一个将从Nexus使用。在整篇文章中，我们将只讨论本地部署的Nexus。</p><h1 id="52c0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">评估需求</h1><p id="12b6" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在我们进入细节之前，有必要考虑一下像Nexus vs npmjs提供的私有存储库(收费)这样的东西。我个人认为，如果您的组织没有任何云基础设施，npmjs上托管的存储库是一个更容易、更干净的解决方案。如果没有内置到您的云基础架构中，托管Nexus、定期备份、健康检查都是一项开销。现在让我们假设所有这些都已就位并继续下去。</p><h1 id="5e3e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">目录:</h1><ol class=""><li id="7c6f" class="ma mb iq jw b jx lv kb lw kf mc kj md kn me kr mf mg mh mi bi translated">在本地运行Nexus存储库管理器</li><li id="d854" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">了解卷</li><li id="b95b" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">创建一个斑点</li><li id="6b8e" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">创建托管存储库</li><li id="3d3e" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">创建NPM代理和组</li><li id="efa1" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">将二进制文件推送到Nexus</li><li id="a186" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">从Nexus提取二进制文件</li><li id="b2f3" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">结论</li></ol><h1 id="8cc3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在本地运行Nexus存储库管理器</h1><p id="6bb6" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">由于docker越来越受欢迎，现在运行任何软件都像找到正确的(Docker)映像一样容易。幸运的是，Sonatype为Nexus提供了docker映像，可以使用下面的pull命令轻松地在本地提取。</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="537a" class="mw ky iq kv b gy mx my l mz na">docker pull sonatype/nexus</span></pre><p id="2d02" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦图像被拉出。要运行，只需执行下面的命令:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="f706" class="mw ky iq kv b gy mx my l mz na">docker run --rm -it -p 8081:8081/tcp sonatype/nexus3:latest</span></pre><p id="15b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将打开运行我们的Nexus实例的容器。要尝试一下，在浏览器中打开<code class="fe ks kt ku kv b">http://localhost:8081</code>，默认凭证是<code class="fe ks kt ku kv b">admin</code> / <code class="fe ks kt ku kv b">admin123</code></p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/3e2d641d8391a9c89f900dbda787491b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Y0QrPONIXboQsDHjDCh9g.png"/></div></div></figure><p id="8127" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Nexus提供了许多不同的功能。在这个时候，我们将只与那些需要为NPM建立我们的私人仓库，但概念可以很容易地应用于其他形式的项目(maven，NuGet，docker等)。</p><h2 id="2af8" class="mw ky iq bd kz ng nh dn ld ni nj dp lh kf nk nl ll kj nm nn lp kn no np lt nq bi translated">基本概念</h2><p id="b9d7" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">Nexus向公共的NPM注册中心公开了一个<code class="fe ks kt ku kv b">group</code>存储库，它是我们的<code class="fe ks kt ku kv b">private</code>存储库(在Nexus术语中称为<code class="fe ks kt ku kv b">hosted</code>存储库)和一个<code class="fe ks kt ku kv b">proxy</code>存储库的内部组合。</p><p id="4dcf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">公共注册中心的代理是必要的，因为我们仍然需要一种从NPM注册中心访问所有公共存储库的方法。每当我们使用这些公共包时，它们都被缓存在代理中，我们将在文章末尾看到这一点。</p><p id="928d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，当我们想要安装一个新的私有或公共NPM包时，我们将项目注册表指向<code class="fe ks kt ku kv b">group</code>(使用<code class="fe ks kt ku kv b">.npmrc</code>)，这样它就可以安装任何必要的包(使用<code class="fe ks kt ku kv b">npm</code>或<code class="fe ks kt ku kv b">yarn</code>)。并且，要创建或更新一个现有的存储库，将发布操作指向<code class="fe ks kt ku kv b">hosted</code>存储库(使用<code class="fe ks kt ku kv b">package.json</code>中的<code class="fe ks kt ku kv b">publishConfig</code>选项)。</p><p id="5fb4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是为什么我们第一次加载Nexus时，会看到一组默认的组/托管/代理存储库组合。</p><blockquote class="nr ns nt"><p id="dfce" class="ju jv nu jw b jx jy jz ka kb kc kd ke nv kg kh ki nw kk kl km nx ko kp kq kr ij bi translated">组=托管+代理。从组中读取并写入托管存储库</p></blockquote><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/a667da41ff2942f60fe02a1dc74b6ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YS1cCeoBxj8GLXMyPtz3vA.png"/></div></div></figure><h2 id="6b90" class="mw ky iq bd kz ng nh dn ld ni nj dp lh kf nk nl ll kj nm nn lp kn no np lt nq bi translated">用户管理</h2><p id="a134" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在引导Nexus时，会为我们(以及所有使用Nexus的人)创建一个默认用户。因此，世界上几乎每个Nexus用户都知道默认用户名和密码是什么。这就是为什么我们应该在创建新的管理员用户后删除/禁用默认用户。默认情况下，我们只有两个角色，但我们总是可以创建更多的角色(这是权限的组合)，并在我们认为合适的时候将它们添加到用户中。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ny"><img src="../Images/601058938459efbff4884fac14f58eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLfuKogG1_zkZ8B26Oen7w.png"/></div></div></figure><p id="8977" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管这不是强制性的，但强烈建议创建自定义角色，并仅根据用户的需求将其分配给用户。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/395c588db9bea6ac436a72373043bede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUtrF1iPCG6mY7JxKnJEHQ.png"/></div></div></figure><p id="3e52" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，让我们阻止未经授权的用户访问我们的服务器，单击<code class="fe ks kt ku kv b">Security</code>下的<code class="fe ks kt ku kv b">Anonymous</code>，取消选中允许访问服务器的选项:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nz"><img src="../Images/b890906832bdf248760a5a67a541a979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJQCMrkg8wpfXoR6BKdMpw.png"/></div></div></figure><p id="3ff4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们已经创建了名为<code class="fe ks kt ku kv b">npmuser</code>的新管理员，并阻止了匿名用户访问我们的存储库，我们准备进入下一步。</p><h1 id="45cf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">了解卷</h1><p id="7fc7" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">每当我们将docker镜像作为容器运行时，包含的所有信息都是无状态的，也就是说，如果我们的容器因为任何原因重启，数据可能会丢失。例如，在我们的例子中，我们已经在Nexus中创建了一个admin用户，如果我们要重启容器，我们创建的用户在重启时将不可用，因为这是一个全新的从头开始的容器。</p><p id="bd86" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了绕过这个问题(以及其他类似的问题)，Docker允许我们将卷挂载到它可以持久存储数据的容器中。在重新启动的情况下，只要新容器重新装载到与以前相同的卷上，它就可以保留信息。</p><p id="5c94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，让我们创建一个目录，我们将把这个例子中生成的所有nexus数据放在这个目录中。</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="67b3" class="mw ky iq kv b gy mx my l mz na">mkdir nexus-data</span></pre><p id="e853" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是我们将用作Nexus映像临时卷的文件夹。我们现在需要在为容器发出run命令时提供卷的路径:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="5d3d" class="mw ky iq kv b gy mx my l mz na">docker run --rm -it -p 8081:8081 <strong class="kv ir">-v</strong> <strong class="kv ir">/Users/../../nexus-data:/nexus-data</strong> sonatype/nexus3</span></pre><p id="1445" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面突出显示的部分非常重要，我们指定了到<code class="fe ks kt ku kv b">nexus-data</code>目录的完整路径，并将其安装到Nexus容器中名为<code class="fe ks kt ku kv b">nexus-data</code>的默认数据目录。此处列出了其他属性和配置<a class="ae kw" href="https://hub.docker.com/r/sonatype/nexus3/#notes" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="937a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦我们运行列出的命令，我们会看到在我们创建的<code class="fe ks kt ku kv b">nexus-data</code>文件夹下创建了不同的文件夹。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oa"><img src="../Images/de11399944c02d0936baf5a27d3b1cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKc8q-Y1XkTluXXLAscECQ.png"/></div></div></figure><p id="16d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在在Nexus中所做的任何更改都会同步回这个文件夹。如果您很好奇，可以再次创建具有<code class="fe ks kt ku kv b">admin</code>角色的<code class="fe ks kt ku kv b">npmuser</code>，停止容器并重启它。新创建的用户将按预期被持久化。</p><h1 id="fbbd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建一个斑点</h1><p id="d4f8" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">我们现在准备创建一个Blob存储，这是一个逻辑分区，我们希望为我们的不同项目类型强制执行，即我们希望分离我们的NPM二进制文件和maven二进制文件，以避免任何冲突(名称或其他)。在内部，Nexus只是为我们创建的每个Blob存储创建不同的文件夹。</p><p id="afdc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要创建blob，请转到“设置”页面&gt;存储库&gt; Blob存储&gt;创建Blob存储</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ob"><img src="../Images/a60e7db3b33f60d84f8e28a5e21f41ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnqJY8FSh-iXCRXbmkkuaw.png"/></div></div></figure><p id="ce24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个斑点一旦被创建，就如预期那样出现在我们的体积中:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oc"><img src="../Images/f8bddcd3c459832b130f4222763eceef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gYu-1jXfkPwVSZyXAPHJIQ.png"/></div></div></figure><p id="3068" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在上传到该blob的任何包都将保存在与其关联的文件夹下的卷中。</p><p id="cfe1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还将使用基于AWS S3的blob，这是Nexus提供的基于文件的blob的替代方案。要配置基于S3的Blob，只需从<code class="fe ks kt ku kv b">Type</code>下拉列表中选择S3，并填写所需信息。相同的示例如下所示:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi od"><img src="../Images/d342ce9b95a2ba3e5dcd18640a44cf02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRnaxfJNTNRavhZJcj1CGg.png"/></div></div></figure><p id="350c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这最终会在您的S3存储桶中创建一些默认文件:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oe"><img src="../Images/fafbb26ca16ef3a6427e109dd62ef2f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcFgxU7uX75mGKoG8wdn5A.png"/></div></div></figure><p id="8b99" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用该blob推送到存储库的任何和所有内容将由S3更新和管理，但是，我们提供给Nexus的关于我们的S3存储桶的配置仍然保留在我们之前装载的卷上。这就是为什么确保我们定期备份该卷非常重要。</p><p id="2e9a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">出于多种原因，我们希望减少对卷的依赖:</p><ol class=""><li id="0b68" class="ma mb iq jw b jx jy kb kc kf of kj og kn oh kr mf mg mh mi bi translated">在生产集群中，我们必须备份与灾难恢复(DR)容器关联的卷。虽然这无法完全避免(因为我们需要持久化用户、自定义角色和其他有状态的信息)，但我们可以将备份减少到无法与云同步的部分，如S3。</li><li id="ac0e" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">备份到S3允许我们在AWS S3存储桶上添加额外的规则，如果需要的话，可以将我们的旧包移动到冷库。</li></ol><p id="5588" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">至此，我们已经准备好进入过程的下一个阶段，创建存储库。</p><h1 id="4a6f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建托管存储库</h1><p id="44a7" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">如前所述，托管存储库是我们创建的私有存储库，用来保存我们的私有包。使这些存储库私有的原因是没有<code class="fe ks kt ku kv b">authToken</code>就不能读取这些存储库的内容。我们将在文章末尾的一个例子中看到这一点。</p><p id="d616" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要创建托管存储库，请转到“设置”页面&gt;存储库&gt;存储库&gt;创建存储库。</p><p id="a935" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们点击Create Repository时，Nexus很友好地为我们提供了定义某种类型的存储库需要如何配置的方法，在我们的例子中，我们只关心与<code class="fe ks kt ku kv b">npm</code>相关的方法。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oi"><img src="../Images/e19794bca60f3d23778cf34ef2f4c176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vx-e2X_c9AFKZd3hv_oh9g.png"/></div></div></figure><p id="e9bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们首先选择<code class="fe ks kt ku kv b">npm(hosted)</code>选项，因为这是我们想要开始的。它向我们请求两件事，托管存储库的名称和存储库数据需要持久存储的blob。单击“创建存储库”按钮，完成存储库的创建。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oj"><img src="../Images/d85d52b7e6473bd592bf8fc1da7561d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*irUx2wE6gJ8sMNcCvzYFgw.png"/></div></div></figure><p id="271b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就是这样。我们已经为所有的<code class="fe ks kt ku kv b">npm</code>项目创建了我们的私有(托管)存储库。</p><h1 id="ce9d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建NPM代理和组</h1><p id="c3bc" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">现在我们已经设置了私有存储库，我们准备创建npm代理，它代理我们对公共NPM注册中心的所有读取请求。我们可以通过将<code class="fe ks kt ku kv b">hosted</code>和<code class="fe ks kt ku kv b">proxy</code>库合并成一个<code class="fe ks kt ku kv b">group</code>来完成我们的变更。</p><h2 id="6277" class="mw ky iq bd kz ng nh dn ld ni nj dp lh kf nk nl ll kj nm nn lp kn no np lt nq bi translated">创建代理存储库</h2><p id="c7d3" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在创建存储库屏幕中，选择<code class="fe ks kt ku kv b">npm (proxy)</code>，这将把我们带到配置页面，我们希望代理到位于URL <code class="fe ks kt ku kv b"><a class="ae kw" href="https://registry.npmjs.org." rel="noopener ugc nofollow" target="_blank">https://registry.npmjs.org</a></code> <a class="ae kw" href="https://registry.npmjs.org." rel="noopener ugc nofollow" target="_blank">的NPM公共注册中心。</a></p><p id="9c6b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们仅在此输入3个必填字段:</p><ol class=""><li id="9143" class="ma mb iq jw b jx jy kb kc kf of kj og kn oh kr mf mg mh mi bi translated">名称— <code class="fe ks kt ku kv b">npm-proxy</code></li><li id="a2ca" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">代理位置— <code class="fe ks kt ku kv b"><a class="ae kw" href="https://registry.npmjs.org." rel="noopener ugc nofollow" target="_blank">https://registry.npmjs.org</a></code></li><li id="b056" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">Blob存储(用于缓存存储、配置等)— <code class="fe ks kt ku kv b">NPM-S3</code>(之前创建)</li></ol><p id="2fb2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将按预期创建代理存储库。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ok"><img src="../Images/08ab92386ead7282accfba5aed33a9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7kqOjCvIbPE0KILqyQy7g.png"/></div></div></figure><h2 id="1967" class="mw ky iq bd kz ng nh dn ld ni nj dp lh kf nk nl ll kj nm nn lp kn no np lt nq bi translated">创建组存储库</h2><p id="b005" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">如前所述创建组存储库是为了将托管存储库和代理存储库结合起来，这使得读取更加容易。让我们创建类似于<code class="fe ks kt ku kv b">hosted</code>和<code class="fe ks kt ku kv b">proxy</code>存储库的<code class="fe ks kt ku kv b">npm (group)</code>存储库。</p><p id="d54c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它接受与以前类似的配置，如名称、blob存储等。我们选择了<code class="fe ks kt ku kv b">npm-private</code>和<code class="fe ks kt ku kv b">npm-proxy</code>存储库，并使它们成为这个组的活跃成员。</p><p id="447a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将来，如果我们有更多兼容的存储库，它们会出现在<code class="fe ks kt ku kv b">Available</code>列表下，可以选择并移动到<code class="fe ks kt ku kv b">Members</code>部分。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ol"><img src="../Images/5c06d73dfa1b4441f01f2b0b07fb521e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5grwfOhbboTA8Wz08bmFw.png"/></div></div></figure><h1 id="a94e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将二进制文件推送到Nexus</h1><p id="1af5" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">既然我们已经准备好了必要的存储库，我们现在可以根据需要在我们的项目中使用它们。让我们首先用一个空白的<code class="fe ks kt ku kv b">index.js</code>文件创建一个样本NodeJS项目，并将它推送到我们托管的存储库:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="3ede" class="mw ky iq kv b gy mx my l mz na">mkdir npm-app1 &amp;&amp; cd npm-app1</span><span id="086b" class="mw ky iq kv b gy om my l mz na">npm init -y</span><span id="dfc2" class="mw ky iq kv b gy om my l mz na">touch index.js</span></pre><p id="e336" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了发布这个项目，我们需要用指向我们新的托管存储库的<code class="fe ks kt ku kv b">publishConfig</code>更新我们的<code class="fe ks kt ku kv b">package.json</code>文件。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="2d34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们现在尝试用<code class="fe ks kt ku kv b">npm publish</code>命令发布项目，我们会看到如下错误，说明我们需要认证:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi op"><img src="../Images/ff136961b8e6651548cdefa8c2c955f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYy7_ICCyvQQkl2BIsGtvg.png"/></div></div></figure><p id="0eae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用与Nexus dashboard相同的凭证来添加身份验证(如错误消息中所建议的):</p><blockquote class="nr ns nt"><p id="e08f" class="ju jv nu jw b jx jy jz ka kb kc kd ke nv kg kh ki nw kk kl km nx ko kp kq kr ij bi translated">注意:注意注册表url包含存储库名称</p></blockquote><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oq"><img src="../Images/e05b4d32c798eff552e2bf7468627825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMdWS5OwjSsd26HxgQjyww.png"/></div></div></figure><p id="1357" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们再试一次！现在我们看到一个不同的错误，说它不能发出<code class="fe ks kt ku kv b">Put</code>请求:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi or"><img src="../Images/c725ba9ebd105847311d584ccaf48370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2nv0agkplmO_kP3MGN3oA.png"/></div></div></figure><p id="071c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是因为Nexus中的安全工作方式，<code class="fe ks kt ku kv b">realms</code>的概念决定了任何用户如何与Nexus交互。应用的默认<code class="fe ks kt ku kv b">realm</code>称为本地认证和本地授权<code class="fe ks kt ku kv b">realm</code>,根据文档，其职责如下:</p><blockquote class="nr ns nt"><p id="0042" class="ju jv nu jw b jx jy jz ka kb kc kd ke nv kg kh ki nw kk kl km nx ko kp kq kr ij bi translated">它们允许存储库管理器在没有额外外部系统的情况下管理安全性设置。</p></blockquote><p id="124f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们需要添加额外的<code class="fe ks kt ku kv b">realms</code>来启用<code class="fe ks kt ku kv b">npm publish</code>功能。要启用其他领域，请转到设置&gt;安全&gt;领域。</p><p id="f679" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">添加<code class="fe ks kt ku kv b">npm Bearer Token Realm</code>并保存更改。关于服务器的更多信息可以在<a class="ae kw" href="https://help.sonatype.com/repomanager3/security/realms" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi os"><img src="../Images/0bb87ead0865e583fefda3681ff9ecd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJc2Gybcyrqpqaj-kojTaA.png"/></div></div></figure><p id="9dfa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们准备好重试我们的发布命令，并按预期工作:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ot"><img src="../Images/ebca3e75eed3ae1ff11575bd12771c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMuXGlu1yaOHSMXldZ56XQ.png"/></div></div></figure><p id="45bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了验证这一点，我们可以浏览我们的存储库并看到预期的包。从顶部导航栏&gt;浏览&gt; NPM-私有中选择浏览选项，查看如下所示的软件包:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ou"><img src="../Images/e55e4864dc73b9f45825dc93eb5d0985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRRYl5ZiaPUJzY0lquknBw.png"/></div></div></figure><p id="30fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还可以验证这是在S3上传到名为<code class="fe ks kt ku kv b">content</code>的文件夹下，虽然我们看不清楚，因为它在存储时被转换成一个blob。</p><h1 id="01b5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从Nexus中提取二进制文件</h1><p id="434d" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">现在我们已经将二进制文件发布到Nexus，让我们创建另一个项目，我们将尝试从这个项目中使用<code class="fe ks kt ku kv b">npm-app1</code>。</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="b70b" class="mw ky iq kv b gy mx my l mz na">mkdir npm-app2 &amp;&amp; cd npm-app2</span><span id="e848" class="mw ky iq kv b gy om my l mz na">npm init -y</span></pre><p id="00ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们尝试使用<code class="fe ks kt ku kv b">npm install </code>从我们的存储库中检索<code class="fe ks kt ku kv b">npm-app1</code>之前，让我们删除之前使用<code class="fe ks kt ku kv b">npm login</code>时添加的凭证。我们这样做是为了避免使用这些凭证来检索包。理想情况下，我们希望复制一个正在使用我们的应用程序的新开发人员的体验。</p><p id="97cd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要删除这些凭据，只需运行以下命令:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="857f" class="mw ky iq kv b gy mx my l mz na">npm logout --registry=<a class="ae kw" href="http://localhost:8081/repository/npm-private/" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/repository/npm-private/</a></span></pre><p id="0f4c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们试着安装新<code class="fe ks kt ku kv b">npm-app2</code>项目中的<code class="fe ks kt ku kv b">npm-app1</code>:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="fb3d" class="mw ky iq kv b gy mx my l mz na">npm i -S npm-app1</span></pre><p id="d57f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如所料，我们看到一个404错误，因为在默认情况下<code class="fe ks kt ku kv b">npm</code>指向的公共注册表上没有找到<code class="fe ks kt ku kv b">npm-app1</code>。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ov"><img src="../Images/e0e40741e20808b380452c35011d951d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vNugMumuSwUf_huw_44Fw.png"/></div></div></figure><p id="1ffb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了解决这个问题，我们需要在本地添加一个<code class="fe ks kt ku kv b">.npmrc</code>文件到项目中。这个<code class="fe ks kt ku kv b">.npmrc</code>文件包含<code class="fe ks kt ku kv b">registry</code>，我们需要指向它来获取我们的包和任何需要的额外凭证。</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="ead8" class="mw ky iq kv b gy mx my l mz na">touch .npmrc</span></pre><p id="ee36" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们首先添加我们需要指向的注册表，以便能够检索我们的包</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="4164" class="mw ky iq kv b gy mx my l mz na">registry=<a class="ae kw" href="http://localhost:8081/repository/npm-group" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/repository/npm-group</a>/</span></pre><p id="6deb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，我们指向的是<code class="fe ks kt ku kv b">npm-group</code>而不是<code class="fe ks kt ku kv b">npm-private</code>库，因为我们想要访问私有和代理的<code class="fe ks kt ku kv b">npm</code>公共包。我们可以看到项目已定位，但无法安装，因为我们没有获得授权。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ow"><img src="../Images/89ce221cd09e681fda5aeffdc0905bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4CXyxhHsmE3CPQSatXecA.png"/></div></div></figure><p id="2231" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最简单的解决方案是添加完成这项工作所需的<code class="fe ks kt ku kv b">authToken</code>。</p><blockquote class="nr ns nt"><p id="adc9" class="ju jv nu jw b jx jy jz ka kb kc kd ke nv kg kh ki nw kk kl km nx ko kp kq kr ij bi translated">作为一个最佳实践，我建议创建一个对所有存储库都具有只读角色的新用户。我们这样做是因为我们不想将Nexus的admin auth令牌添加到源代码中。</p><p id="cba2" class="ju jv nu jw b jx jy jz ka kb kc kd ke nv kg kh ki nw kk kl km nx ko kp kq kr ij bi translated">为此，创建具有与读取和浏览相关的所有权限的角色，最简单的方法是为角色提供<code class="fe ks kt ku kv b">nx-repository-view-*-*-browse</code>和<code class="fe ks kt ku kv b">nx-repository-view-*-*-read</code>权限</p></blockquote><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ox"><img src="../Images/4b77cdec6f21b5fa15f6e11761e463ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2FJB8yDQpW12FyLF9qvOLA.png"/></div></div></figure><blockquote class="nr ns nt"><p id="f316" class="ju jv nu jw b jx jy jz ka kb kc kd ke nv kg kh ki nw kk kl km nx ko kp kq kr ij bi translated">然后创建具有该角色的用户:</p></blockquote><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oy"><img src="../Images/e1b9440429396bfce9af1aaa1668392d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFfl_yxa2eC4wolc7XTbSw.png"/></div></div></figure><p id="6778" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，为了获得这个用户的auth令牌，执行一个指向我们的<code class="fe ks kt ku kv b">npm-group</code>存储库的<code class="fe ks kt ku kv b">npm login</code>:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oz"><img src="../Images/beec8cd1398bd3b2e352df5b3e4c0343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p97heVo71KDkGYYQ8rJhCQ.png"/></div></div></figure><p id="28de" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">执行登录会将凭据添加到您计算机根目录下的<code class="fe ks kt ku kv b">.npmrc</code>文件中。打开全局<code class="fe ks kt ku kv b">.npmrc</code>文件，找到类似如下的行:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="2582" class="mw ky iq kv b gy mx my l mz na">//localhost:8081/repository/npm-group/:_authToken=NpmToken.bb495270–9831–3046–8c24-a2978853d3a1</span></pre><p id="62aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">_authToken</code>是上面打印的最后一行。我们现在可以在<code class="fe ks kt ku kv b">npm-app2</code>项目中将<code class="fe ks kt ku kv b">_authToken</code>添加到我们的<code class="fe ks kt ku kv b">.npmrc</code>文件中。我们这样做是为了避免在克隆该存储库的每台计算机上登录。</p><p id="f594" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们先注销，然后再继续:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="4329" class="mw ky iq kv b gy mx my l mz na">npm logout --registry=<a class="ae kw" href="http://localhost:8081/repository/npm-private/" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/repository/npm-group/</a></span></pre><p id="0556" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">项目中<code class="fe ks kt ku kv b">.npmrc</code>文件的最终形式如下:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="fdae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有了它，我们现在应该能够安装和使用如下所示的任何和所有软件包:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi pa"><img src="../Images/fe13b77cd6f60c1080910d101bf9a082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ashW3MiXiFVK8VMKJNmzow.png"/></div></div></figure><p id="288b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们浏览存储库时，我们可以看到代理包(在本例中为lodash)的缓存在起作用:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi pb"><img src="../Images/9736f0626dfbcd1ea7109cc753d84e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvUKiIfxH5NQmZXnQxLOoQ.png"/></div></div></figure><h1 id="84cc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="07cd" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">本文仅介绍了如何将Nexus用作存储库管理器的一些基础知识。尽管我们运行容器并将卷装载到本地目录中，但强烈建议您在自己选择的云提供商上尝试上述方法。请记住，在云提供商(或自托管)的情况下，您需要备份卷以进行灾难恢复。</p></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><p id="3c55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nu">如果你喜欢这个博客，一定要拍几下。</em> <a class="ae kw" href="https://medium.com/@kashyap.mukkamala" rel="noopener"> <em class="nu">多看几遍</em> </a> <em class="nu">或者跟我上</em><a class="ae kw" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"><em class="nu">LinkedIn</em></a><em class="nu">。</em></p></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><figure class="mo mp mq mr gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi pj"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="pk pl gp gr pm pn"><a href="https://gitconnected.com/learn/node-js" rel="noopener  ugc nofollow" target="_blank"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd ir gy z fp ps fr fs pt fu fw ip bi translated">Learn Node.js - Best Node.js教程(2019) | gitconnected</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">前31个Node.js教程。课程由开发人员提交和投票，让您能够找到最好的节点</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">gitconnected.com</p></div></div><div class="pw l"><div class="px l py pz qa pw qb js pn"/></div></div></a></div></div></div>    
</body>
</html>