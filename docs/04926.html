<html>
<head>
<title>Backend API &amp; Flask Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后端API和Flask概述</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/develop-a-backend-api-using-flask-27aade77993f?source=collection_archive---------1-----------------------#2020-07-24">https://levelup.gitconnected.com/develop-a-backend-api-using-flask-27aade77993f?source=collection_archive---------1-----------------------#2020-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c77b91690ecced1c2d282579ca5bd792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqrGQ8s6KPQZxjUuBzg8Rg.png"/></div></div></figure><p id="2bf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated">lask是一个轻量级框架，可以用来实现web应用程序和后端API应用程序。这篇文章之后，我的目标是演示使用Sqlite这样的数据库开发后端API的简单步骤。</p><p id="97cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们将实现一个完整的后端API应用程序，并通过任何API工具(如postman)测试JSON请求和响应。</p><p id="c686" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我想告诉所有的读者和程序员，我希望至少对python编程语言有一点好的理解，对数据库和SQL查询有一点了解。</p><p id="3059" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想提一下我使用过的必要工具。确保您已经安装了python/anaconda并且已经执行了python脚本。</p><ol class=""><li id="b5ba" class="li lj it kd b ke kf ki kj km lk kq ll ku lm ky ln lo lp lq bi translated">任何IDE，比如Pycharm，或者如果对编码很熟悉，那么notepad++也可以。</li><li id="88b7" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated">邮差工具。</li></ol><p id="81a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经准备好开始实施了！但是在开始之前，我想先说明一下这次学习的结果。</p><p id="b389" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将创建后端API，使用API将学生详细信息存储到数据库中，GET和POST两种方法都将实现，我们将使用Postman工具手动测试我们的API。</p><p id="fe4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在使用Flask框架，所以我们需要用anaconda或PIP安装它。</p><p id="2476" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;康达安装-c蟒蛇烧瓶</p><p id="8a55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt; &gt; pip安装烧瓶</p><p id="01cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用户可以使用上面的任何命令来安装python的Flask框架。</p><p id="cf4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以开始实现一个后端API，将简单的学生信息存储到数据库中。</p><h2 id="07e8" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">第一步:</h2><p id="13c0" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">创建一个项目文件夹，如果使用任何IDE，然后在那里创建一个项目。</p><h2 id="91b6" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">第二步:</h2><p id="37ee" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">创建两个python文件，分别命名为<strong class="kd iu"> <em class="mu"> server_config.py </em> </strong>和<strong class="kd iu"> <em class="mu"> route_config.py </em> </strong></p><blockquote class="mv mw mx"><p id="53d2" class="kb kc mu kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu"> <em class="it">注意:</em> </strong> <em class="it">我没有遵循任何指南来创建项目文件结构，因此可能会以不同的方式做同样的工作。所有的python文件都是为了更好的理解和代码的可重用性而创建的。</em></p></blockquote><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/cb0c9b42d004e049a10a58aa65035ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*IqpxE4St5jv4GXEs4U78Yw.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">这就是项目结构的样子。</figcaption></figure><h2 id="0aeb" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">第三步:</h2><p id="c53d" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">用flask python脚本设置<strong class="kd iu"><em class="mu">server _ config . py</em></strong>和<strong class="kd iu"><em class="mu">route _ config . py</em></strong>。</p><p id="887f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<strong class="kd iu"><em class="mu">server _ config . py</em></strong>中设置主机和端口</p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="f75d" class="lw lx it nl b gy np nq l nr ns">import os<br/>from route_config import *</span><span id="cb8a" class="lw lx it nl b gy nt nq l nr ns">app.debug = True<br/>host = os.environ.get(<strong class="nl iu">'IP'</strong>, <strong class="nl iu">'0.0.0.0'</strong>)<br/>port = int(os.environ.get(<strong class="nl iu">'PORT'</strong>, 8080))<br/>app.run(host=host, port=port)</span></pre><p id="4a37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在route_config.py中创建应用程序引用</p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="85a1" class="lw lx it nl b gy np nq l nr ns">from flask import Flask</span><span id="b043" class="lw lx it nl b gy nt nq l nr ns"># app reference<br/>app = Flask(__name__)</span></pre><p id="7072" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在您可以运行<strong class="kd iu"><em class="mu">server _ config . py</em></strong>，预期的输出将是。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/c014485aaf294d417c812826e9d9ee27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpPIkszy1U132E-mdgPo1Q.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">这表明服务器已经启动并在本地主机上运行</figcaption></figure><blockquote class="mv mw mx"><p id="dd35" class="kb kc mu kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>如果未明确定义主机和端口，则默认主机将是127.0.0.1，端口将是5000。</p></blockquote><h2 id="b2c8" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">第四步:</h2><p id="feb9" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">现在我们准备将GET和POST方法以及一些额外的辅助方法从flask添加到<strong class="kd iu"><em class="mu">route _ config . py</em></strong>中。</p><p id="e390" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将以下代码添加到<strong class="kd iu"> <em class="mu"> route_config.py </em> </strong></p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="4684" class="lw lx it nl b gy np nq l nr ns">from flask import Flask</span><span id="334c" class="lw lx it nl b gy nt nq l nr ns"># app reference<br/>app = Flask(__name__)</span><span id="a756" class="lw lx it nl b gy nt nq l nr ns"># This method executes before any API request<br/>@app.before_request<br/>def before_request():<br/>    print(<strong class="nl iu">'before API request'</strong>)</span><span id="03d3" class="lw lx it nl b gy nt nq l nr ns"># This method returns students <br/># list and by default method will be GET<br/>@app.route(<strong class="nl iu">'/api/students'</strong>)<br/>def get_students_list():<br/>    return "Student list[GET]"</span><span id="5dcd" class="lw lx it nl b gy nt nq l nr ns"># This is POST method which stores students details.<br/>@app.route(<strong class="nl iu">'/api/storestudents'</strong>, methods=[<strong class="nl iu">'POST'</strong>])<br/>def store_student_data():<br/>    return "Student list[POST]"</span><span id="23bd" class="lw lx it nl b gy nt nq l nr ns"># This method executes after every API request.<br/>@app.after_request<br/>def after_request(response):<br/>    return response</span></pre><p id="bdda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在GET和POST API URL已经准备好用postman工具测试API请求-响应(postman工具可以作为chrome浏览器的扩展)</p><blockquote class="mv mw mx"><p id="8fcf" class="kb kc mu kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated">请阅读帖子了解postman工具和API测试<a class="ae nv" href="https://medium.com/aubergine-solutions/api-testing-using-postman-323670c89f6d" rel="noopener"> <em class="it">点击这里</em> </a> <em class="it">。</em>我们需要在postman工具上设置几个参数来测试API，详细信息请见我们的中型社区帖子，我发现这对使用postman学习API测试非常有用。</p></blockquote><p id="f442" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;方法&gt;<a class="ae nv" href="http://localhost:8080/api/storestudents" rel="noopener ugc nofollow" target="_blank"> http://Host:P </a> ort/ <strong class="kd iu">方法路由路径。&gt; </strong>正文:？</p><p id="b968" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt; &gt; GET &gt;<a class="ae nv" href="http://localhost:8080/api/students" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/<strong class="kd iu">API/students</strong></a><strong class="kd iu">&gt;</strong>Body:无</p><p id="ee82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;回应:学生名单[获取]</p><p id="bb84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt; &gt; POST &gt;<a class="ae nv" href="http://localhost:8080/api/storestudents" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/<strong class="kd iu">API/store students</strong></a><strong class="kd iu">:</strong>Body:{ }</p><p id="d829" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;回应:学生名单[帖子]</p><p id="7f0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;内容类型:应用程序/JSON</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/af1b961afaae625646c445aa11923626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgW51b2Be1-dA-BdsgyBLg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">这是邮递员工具</figcaption></figure><p id="896d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，我们已经用一个POST和一个GET方法配置了服务器，现在我们必须配置数据库并创建一个表来执行进一步的任务。</p><p id="f8c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经为学生详细解释了数据库和表的创建，请查看(<a class="ae nv" href="https://medium.com/@narendra147h/sqlite-database-crud-operations-using-python-3774929eb799" rel="noopener">单击此处)</a>为了更加清晰，正如我之前提到的，我们需要对数据库和SQL有一点了解。因此，为了从这里进一步理解，我希望您已经理解了数据库术语，并具有使用python的SQL的基本知识。</p><h2 id="4dee" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">第五步:</h2><p id="1e52" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">我正在创建一个名为<strong class="kd iu"> StudentDB </strong>的Sqlite数据库，表名为<strong class="kd iu"> StudentTable </strong>。</p><p id="1f24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据库模式将如下所示。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/bd0a1afcc416c5f7f82f434c14f9c158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*Oc_Xa7dy_LYWSXsD0V-nnA.png"/></div></figure><p id="b0eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在项目根文件夹中创建一个名为“db”的包，并创建两个用于数据库支持的python文件，如<strong class="kd iu"> <em class="mu"> db_config.py </em> </strong>、<strong class="kd iu"><em class="mu">db _ creation . py</em></strong></p><p id="aa3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="mu"> db_config.py </em> </strong>用于API实现，<strong class="kd iu"><em class="mu">db _ creation . py</em></strong>，是创建数据库表的python脚本。</p><p id="eb10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将代码添加到<em class="mu"> db_config.py </em>中</p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="d81a" class="lw lx it nl b gy np nq l nr ns">import sqlite3 as sq<br/>from flask import g</span><span id="c710" class="lw lx it nl b gy nt nq l nr ns">DATABASE_DIR = <strong class="nl iu">"C:</strong>\\<strong class="nl iu">SqliteDB</strong>\\<strong class="nl iu">StudentDB"<br/></strong>DB_NAME = <strong class="nl iu">'StudentDB.db'<br/></strong>TABLE_NAME = <strong class="nl iu">'StudentTable'<br/></strong>DATABASE_PATH = DATABASE_DIR + <strong class="nl iu">'</strong>\\<strong class="nl iu">' </strong>+ DB_NAME<br/>print(DATABASE_PATH)</span><span id="ce40" class="lw lx it nl b gy nt nq l nr ns"># The method returns the database instance <br/>def get_db():<br/>    if <strong class="nl iu">'db' </strong>not in g:<br/>        g.db = sq.connect(DATABASE_PATH, detect_types=sq.PARSE_DECLTYPES)<br/>        g.db.row_factory = sq.Row</span><span id="c6da" class="lw lx it nl b gy nt nq l nr ns">return g.db</span></pre><p id="c6a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件中，数据库的配置和DB实例创建代码是在route_config()中调用get_db()方法来实例化数据库的地方编写的。</p><blockquote class="mv mw mx"><p id="07a2" class="kb kc mu kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>必须先创建DATABSE _ DIR，它可以是系统的任何路径。由于我们不部署此代码，所以我们的数据库将存储在系统硬盘驱动器中，对于不同的操作系统它可能会有所不同，也请根据您的操作系统采取相应的行动，如果是Linux或Mac for windows用户，最好将相同的文件夹结构创建到“C”驱动器中。</p><p id="4247" class="kb kc mu kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated">DATABASE _ DIR =<strong class="kd iu">" C:</strong>\ \<strong class="kd iu">SqliteDB</strong>\ \<strong class="kd iu">StudentDB "<br/>此路径适用于windows用户，Linux和Mac用户请根据您的操作系统将路径替换为有效位置。</strong></p></blockquote><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/585d4c2a0bc27ce7ebcc50136820bf54.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*O1DjnYkq-_5BgEuVBj49Sg.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">现在的项目结构会是这样的。</figcaption></figure><h2 id="e598" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">第六步:</h2><p id="6fd5" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">将代码添加到<strong class="kd iu"><em class="mu">db _ creation . py</em></strong>中并运行它。如果没有任何错误，那么数据库文件将在此位置创建到“C”驱动器<strong class="kd iu">C:</strong>\ \<strong class="kd iu">SqliteDB</strong>\ \<strong class="kd iu">StudentDB</strong>中，并位于为Linux和MAC用户配置的位置。</p><p id="1225" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这完全取决于“数据库路径”，它在<strong class="kd iu"> <em class="mu"> db_config.py </em> </strong>中被定义为一个变量，所以这个脚本使用相同的路径来创建数据库。</p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="0fe6" class="lw lx it nl b gy np nq l nr ns">import sqlite3 as sq<br/>from db.db_config import *</span><span id="d392" class="lw lx it nl b gy nt nq l nr ns">conn = sq.connect(DATABASE_PATH)<br/>cur = conn.cursor()</span><span id="f57e" class="lw lx it nl b gy nt nq l nr ns">conn.execute(<strong class="nl iu">'CREATE TABLE if not exists ' </strong>+ TABLE_NAME + <strong class="nl iu">' (' </strong>+<br/>             <strong class="nl iu">'ID TEXT PRIMARY KEY NOT NULL, '<br/>             'NAME TEXT NOT NULL, '<br/>             'RollNo TEXT NOT NULL, ' <br/>             'Address TEXT NOT NULL, '<br/>             'CLASS TEXT NOT NULL,'<br/>             'DOB TEXT NOT NULL,'<br/>             'gender TEXT NOT NULL' </strong>+ <strong class="nl iu">' );'</strong>)</span><span id="5c02" class="lw lx it nl b gy nt nq l nr ns">conn.commit()<br/>conn.close()</span></pre><blockquote class="mv mw mx"><p id="2826" class="kb kc mu kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>我预计人们可能会在创建python文件和在硬盘上创建文件夹位置时出错，为了避免这种情况，请创建与我上面提到的相同的文件夹结构，并根据您的操作系统使用数据库文件位置的有效路径。</p></blockquote><p id="5c80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们必须返回到<strong class="kd iu"><em class="mu">route _ config . py</em></strong>，然后进一步编辑代码，以扩展GET和POST方法，通过后端API获取和存储学生的详细信息。</p><h2 id="9f5f" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">第七步:</h2><p id="169c" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">对于batter项目代码结构，您必须创建一个名为“api”的包，并在名为<strong class="kd iu"><em class="mu">api _ student . py</em></strong>的“API”包中创建一个python文件</p><p id="3cfd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个文件将包含数据库查询的业务逻辑。我已经创建了一个实用程序文件，其中包含可重用的方法，如生成Json响应等，因此您需要再创建一个名为utils的python包，并在其中创建一个utils python文件。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d20bb7852c50eaa9cfbaea2d44c2640b.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*abauQ2L6AlGB2_ZVM0SbUg.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">这是包含所有python源文件的最终项目结构。</figcaption></figure><blockquote class="mv mw mx"><p id="6e84" class="kb kc mu kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu">注意:根据项目结构，项目的最终源代码如下，所以现在一个接一个地将最终代码添加到您的项目文件中。</strong></p></blockquote><p id="99f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">T36】server _ config . pyT38】</strong></p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="ec6e" class="lw lx it nl b gy np nq l nr ns">import os<br/>from route_config import *</span><span id="2052" class="lw lx it nl b gy nt nq l nr ns">app.debug = True<br/>host = os.environ.get(<strong class="nl iu">'IP'</strong>, <strong class="nl iu">'0.0.0.0'</strong>)<br/>port = int(os.environ.get(<strong class="nl iu">'PORT'</strong>, 8080))<br/>app.run(host=host, port=port)</span></pre><p id="7799" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"><em class="mu">route _ config . py</em></strong></p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="1360" class="lw lx it nl b gy np nq l nr ns">from flask import Flask<br/>from api.api_student import *<br/>from db.db_config import *<br/># app reference<br/>app = Flask(__name__)</span><span id="4e83" class="lw lx it nl b gy nt nq l nr ns"># This method executes before any API request<br/>@app.before_request<br/>def before_request():<br/>    g.db = get_db()</span><span id="f867" class="lw lx it nl b gy nt nq l nr ns"># This method returns students list<br/># and by default method will be GET<br/>@app.route(<strong class="nl iu">'/api/students'</strong>)<br/>def get_students_list():<br/>    return get_student()</span><span id="21a0" class="lw lx it nl b gy nt nq l nr ns"># This is POST method which stores students details.<br/>@app.route(<strong class="nl iu">'/api/storestudents'</strong>, methods=[<strong class="nl iu">'POST'</strong>])<br/>def store_student_data():<br/>    return store_student()</span><span id="1abf" class="lw lx it nl b gy nt nq l nr ns"># This method executes after every API request.<br/>@app.after_request<br/>def after_request(response):<br/>    return response</span></pre><p id="7fa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在before request方法中添加了<strong class="kd iu"> "g.db = get_db()" </strong>用于在任何API请求之前创建db实例，</p><p id="2178" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> get_students_list() </strong>方法是返回学生列表</p><p id="bcf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> store_student_data() </strong>方法现在将学生的详细信息存储到数据库中，并在响应中返回同一个学生的详细信息。</p><p id="7454" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">拥有这个文件的主要动机只是编写路由方法，所以当我们添加任何新的API时，我们应该只添加一个新的方法，并且我们应该将业务逻辑存储在不同的文件中。这就是为什么这可以被认为是一个项目的配置文件。</p><p id="63f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">T3】db/db _ config . pyT5】</strong></p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="2ada" class="lw lx it nl b gy np nq l nr ns">import sqlite3 as sq<br/>from flask import g<br/># For windows user Linux and Mac Os required chnage here<br/>DATABASE_DIR = <strong class="nl iu">"C:</strong>\\<strong class="nl iu">SqliteDB</strong>\\<strong class="nl iu">StudentDB"<br/></strong>DB_NAME = <strong class="nl iu">'StudentDB.db'<br/></strong>TABLE_NAME = <strong class="nl iu">'StudentTable'<br/></strong>DATABASE_PATH = DATABASE_DIR + <strong class="nl iu">'</strong>\\<strong class="nl iu">' </strong>+ DB_NAME</span><span id="7499" class="lw lx it nl b gy nt nq l nr ns"># The method returns the database instance<br/>def get_db():<br/>    if <strong class="nl iu">'db' </strong>not in g:<br/>        g.db = sq.connect(DATABASE_PATH, <br/>                          detect_types=sq.PARSE_DECLTYPES)<br/>        g.db.row_factory = sq.Row</span><span id="32b5" class="lw lx it nl b gy nt nq l nr ns">return g.db</span></pre><p id="3fb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">T7】db/db _ creation . pyT9】</strong></p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="89f3" class="lw lx it nl b gy np nq l nr ns">import sqlite3 as sq<br/>from db.db_config import *</span><span id="3ee6" class="lw lx it nl b gy nt nq l nr ns">conn = sq.connect(DATABASE_PATH)<br/>cur = conn.cursor()</span><span id="0cbc" class="lw lx it nl b gy nt nq l nr ns">conn.execute(<strong class="nl iu">'CREATE TABLE if not exists ' </strong>+ TABLE_NAME + <strong class="nl iu">' (' </strong>+<br/>             <strong class="nl iu">'ID TEXT PRIMARY KEY NOT NULL, '<br/>             'NAME TEXT NOT NULL, '<br/>             'RollNo TEXT NOT NULL, ' <br/>             'Address TEXT NOT NULL, '<br/>             'CLASS TEXT NOT NULL,'<br/>             'DOB TEXT NOT NULL,'<br/>             'gender TEXT NOT NULL' </strong>+ <strong class="nl iu">' );'</strong>)</span><span id="975f" class="lw lx it nl b gy nt nq l nr ns">conn.commit()<br/>conn.close()</span></pre><p id="8698" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"><em class="mu">API/API _ student . py</em></strong></p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="ec8b" class="lw lx it nl b gy np nq l nr ns">from flask import request, g<br/>import uuid<br/>from utils.uitils import *</span><span id="5fe1" class="lw lx it nl b gy nt nq l nr ns"># This method is to fetch the students details<br/>def get_student():<br/>    if request.method == <strong class="nl iu">'GET'</strong>:<br/>        data_cursor = g.db.execute(<strong class="nl iu">"SELECT * "<br/>                                   "FROM StudentTable"</strong>)<br/>        data = data_cursor.fetchall()<br/>        user_data = [{<strong class="nl iu">'ID'</strong>: row[0], <strong class="nl iu">'NAME'</strong>: row[1],<br/>                      <strong class="nl iu">'RollNo'</strong>: row[2], <strong class="nl iu">'Address'</strong>: row[3],<br/>                      <strong class="nl iu">'CLASS'</strong>: row[4], <strong class="nl iu">'DOB'</strong>: row[5],<br/>                      <strong class="nl iu">'Gender'</strong>: row[6]} for row in data]<br/>        return success_response(user_data,<br/>                                <strong class="nl iu">"These are the students "<br/>                                "stored into records"</strong>)</span><span id="6260" class="lw lx it nl b gy nt nq l nr ns"># This method is to store the students details<br/>def store_student():<br/>    if request.method == <strong class="nl iu">'POST'</strong>:<br/>        data = request.json<br/>        user_cursor = g.db.execute(<strong class="nl iu">"SELECT * FROM "<br/>                                   "StudentTable WHERE "<br/>                                   "NAME=? OR RollNo=? "</strong>,<br/>                                   (data[<strong class="nl iu">"name"</strong>],<br/>                                    data[<strong class="nl iu">"RollNo"</strong>]))<br/>        if len(user_cursor.fetchall()) &gt;= 1:<br/>            return success_message(<strong class="nl iu">"Student details is "<br/>                                   "already Stored !!"</strong>)<br/>        else:<br/>            query = (<strong class="nl iu">'INSERT INTO StudentTable (ID, NAME, RollNo, '<br/>                     'Address, CLASS, DOB, gender) '<br/>                     ' VALUES (:ID, :NAME, :RollNo, '<br/>                     ':Address, :CLASS, :DOB, :GENDER);'</strong>)<br/>            param = {<br/>                <strong class="nl iu">'ID'</strong>: str(uuid.uuid4()),<br/>                <strong class="nl iu">'NAME'</strong>: data[<strong class="nl iu">"name"</strong>],<br/>                <strong class="nl iu">'RollNo'</strong>: data[<strong class="nl iu">"RollNo"</strong>],<br/>                <strong class="nl iu">'Address'</strong>: data[<strong class="nl iu">"address"</strong>],<br/>                <strong class="nl iu">'CLASS'</strong>: data[<strong class="nl iu">"class"</strong>],<br/>                <strong class="nl iu">'DOB'</strong>: data[<strong class="nl iu">"dob"</strong>],<br/>                <strong class="nl iu">'GENDER'</strong>: data[<strong class="nl iu">"gender"</strong>]<br/>            }<br/>            g.db.execute(query, param)<br/>            g.db.commit()<br/>            data_cursor = g.db.execute(<strong class="nl iu">"SELECT * FROM "<br/>                                       "StudentTable WHERE NAME=? OR "<br/>                                       "RollNo=? "</strong>,<br/>                                       (data[<strong class="nl iu">"name"</strong>],<br/>                                        data[<strong class="nl iu">"RollNo"</strong>]))<br/>            data = data_cursor.fetchall()<br/>            user_data = [{<strong class="nl iu">'ID'</strong>: row[0], <strong class="nl iu">'NAME'</strong>: row[1],<br/>                          <strong class="nl iu">'RollNo'</strong>: row[2], <strong class="nl iu">'Address'</strong>: row[3],<br/>                          <strong class="nl iu">'CLASS'</strong>: row[4], <strong class="nl iu">'DOB'</strong>: row[5],<br/>                          <strong class="nl iu">'Gender'</strong>: row[6]} for row in data]<br/>            return success_response(user_data,<br/>                                    <strong class="nl iu">"These are the students "<br/>                                    "stored into records"</strong>)<br/>    else:<br/>        return error_response(<strong class="nl iu">"Invalid method[GET/POST]"</strong>)</span></pre><p id="88b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该文件包含所有业务逻辑API请求的GET和POST方法，</p><p id="342d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> get_student() </strong>是用来获取学生的详细信息和</p><p id="4f11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> store_student() </strong>方法通过POST请求存储学生。</p><p id="e54c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两种方法都被调用到route_config.py中</p><p id="cab7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">T19】utils/utils . pyT21】</strong></p><pre class="nc nd ne nf gt nk nl nm nn aw no bi"><span id="4f06" class="lw lx it nl b gy np nq l nr ns">import json<br/>from flask import make_response</span><span id="cf5b" class="lw lx it nl b gy nt nq l nr ns">JSON_MIME_TYPE = <strong class="nl iu">'application/json; charset=utf-8'<br/></strong>STATUS = <strong class="nl iu">'success'</strong></span><span id="7dee" class="lw lx it nl b gy nt nq l nr ns">def json_response(data=<strong class="nl iu">''</strong>, status=200, headers=None):<br/>    headers = headers or {}<br/>    if <strong class="nl iu">'Content-Type' </strong>not in headers:<br/>        headers[<strong class="nl iu">'Content-Type'</strong>] = JSON_MIME_TYPE</span><span id="972c" class="lw lx it nl b gy nt nq l nr ns">return make_response(data, status, headers)</span><span id="eb45" class="lw lx it nl b gy nt nq l nr ns">def error_response(error):<br/>    error = json.dumps({<strong class="nl iu">'status'</strong>: <strong class="nl iu">'failed'</strong>,<br/>                        <strong class="nl iu">'error'</strong>: error})<br/>    return json_response(error)</span><span id="a800" class="lw lx it nl b gy nt nq l nr ns">def success_response(result, message=<strong class="nl iu">''</strong>):<br/>    format = {<strong class="nl iu">'status'</strong>: <strong class="nl iu">'success'</strong>,<br/>                  <strong class="nl iu">'message'</strong>: message,<br/>                  <strong class="nl iu">'result'</strong>: result}<br/>    return json_response(json.dumps(format))</span><span id="9adf" class="lw lx it nl b gy nt nq l nr ns">def success_message(message):<br/>    format = {<strong class="nl iu">'status'</strong>: <strong class="nl iu">'success'</strong>,<br/>              <strong class="nl iu">'result'</strong>: message}</span><span id="450d" class="lw lx it nl b gy nt nq l nr ns">return json_response(json.dumps(format))</span></pre><p id="64e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个Utils文件，对于成功和失败的响应几乎没有可重用的方法，因为API应该总是返回一个响应，不管它是成功还是失败，它不应该以错误结束。</p><p id="97b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将所有文件集成到项目中后，运行<strong class="kd iu"><em class="mu">server _ config . py</em></strong>，如果服务器运行成功，它将显示与最初显示的相同的输出。</p><p id="91fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以测试GET和POST方法。现在再次启动postman工具，使用URL并相应地更改参数。</p><p id="7c92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt; &gt; &gt;<a class="ae nv" href="http://localhost:8080/api/students" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/<strong class="kd iu">API/students</strong></a><strong class="kd iu">&gt;</strong></p><p id="b1b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;正文:无</p><p id="bda3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;回应:</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/4985217b01bfdc9ebd3b82e111917779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-p1h0j1pUvc-_3YVZ_EzQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">响应将所有学生的Json存储到数据库中</figcaption></figure><blockquote class="mv mw mx"><p id="8c74" class="kb kc mu kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu">注意:</strong>首先使用Post方法测试，这样至少有一些数据可以进入数据库。</p></blockquote><p id="69ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt; &gt; POST &gt;<a class="ae nv" href="http://localhost:8080/api/storestudents" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/<strong class="kd iu">API/store students</strong></a></p><p id="3114" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;正文:{ <br/>"姓名":" Raj13 "，<br/>"罗尔诺":" 005 "，<br/>"地址":"班加罗尔"，<br/>"阶级":" 12日"，<br/>"多布":" 01/01/2001 "，<br/>"性别":" M" <br/> }</p><p id="0b15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;回应:</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/330bd45e42c1d8491765bafcc062f572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2YEo5kiIVxi_bkJMqMpQg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">响应将是post请求中发送的同一学生的记录。</figcaption></figure><p id="3611" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">&gt;&gt;内容类型:应用程序/JSON</p><p id="c3e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果一切都运行良好，那么工作就完成了，你可以在GitHub repo中找到完整的源代码，但我的建议是，请一步一步地尝试，并理解实现。</p><p id="56f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个使用Python和Flask的SQLite数据库API的完整实现。</p><p id="1abb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GitHub:<a class="ae nv" href="https://gitlab.com/NarendraH/narendrablogssource" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/NarendraH/narendrablogssource</a></p><p id="60c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">REST/Backend API开发需要大量的经验和时间来成为这方面的专家，Flask和Django这样的框架使python变得更容易。此外，我们应该学习如何上传文件和从服务器下载文件。</p><p id="ecbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mu">感谢，</em><a class="ob oc ep" href="https://medium.com/u/74bddc99f2b2?source=post_page-----27aade77993f--------------------------------" rel="noopener" target="_blank"><em class="mu">Khushboo kote cha</em></a><em class="mu">为邮差撰写API测试博客。</em></p><p id="6ec8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谢谢大家！！！快乐编码。</p></div></div>    
</body>
</html>