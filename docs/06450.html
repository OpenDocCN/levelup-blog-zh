<html>
<head>
<title>What’s Mediastreamer2. Data movement mechanism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Mediastreamer2。数据移动机制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/whats-mediastreamer2-data-movement-mechanism-29444d22d36b?source=collection_archive---------9-----------------------#2020-11-25">https://levelup.gitconnected.com/whats-mediastreamer2-data-movement-mechanism-29444d22d36b?source=collection_archive---------9-----------------------#2020-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/12a83b61623358045d23e6557024dbff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyHLOZuBPQ9zKaFcqXxJ2g.png"/></div></figure><p id="4a36" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(上一篇文章<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/whats-mediastreamer2-filters-development-4b7d05e09a0f">什么是Mediastreamer2。过滤器开发</a></p><p id="ef06" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">媒体流中的数据移动是使用由<em class="kt"> queue_t </em>结构描述的队列来执行的。<em class="kt"> mblk_t </em>类型的消息序列沿着队列移动，消息本身不包含数据块，而仅包含对前一个、下一个消息和数据块的引用。另外我要特别强调的是，还有一个同类型消息链接的字段，可以让你把消息组织成一个单链表。由这样的列表联合的一组消息将被称为元组。因此，队列的任何元素都可以是单个消息<em class="kt"> mblk_t </em>，或者可能是一组消息<em class="kt"> mblk_t </em>的头。元组中的每个消息都可以有自己的数据块。稍后我们将讨论为什么需要元组。</p><p id="3ccc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如上所述，消息本身不包含数据块；相反，它只包含一个指向存储块的内存区域的指针。在这一部分中，mediastreamer的工作概况类似于漫画“Monsters，Inc .”中的仓库门</p><p id="904d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，向上移动层次，让我们详细考虑mediastreamer中数据传输机制的列出的实体。</p><h1 id="55e9" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5.1数据块dblk_t</h1><p id="2c26" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">一个数据块由一个报头和一个数据缓冲区组成。报头由<em class="kt"> dblk_t </em>结构描述，</p><p id="3b7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单5.1:结构dblk_t</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7e86" class="mg kv iq mc b gy mh mi l mj mk">typedef struct datab<br/>{<br/>  unsigned char *db_base; /* Pointer to the beginning of the data buffer. */<br/>  unsigned char *db_lim;  /* Pointer to the end of the data buffer. */<br/>  void (*db_freefn)(void*); /* The function of freeing memory when deleting a block. */<br/>  int db_ref; /* Reference counter. */<br/>} dblk_t;</span></pre><p id="a7c2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结构字段包含指向缓冲区开头、缓冲区结尾和删除数据缓冲区的函数的指针。标题中的最后一个元素是引用计数<em class="kt"> db_ref </em>，如果它达到零，这将作为一个信号从内存中删除该块。如果数据块是由<em class="kt"> datab_alloc() </em>函数创建的，那么数据缓冲区将紧接在数据头之后放入内存。在所有其他情况下，缓冲区可以单独位于某个地方。数据缓冲器将包含信号样本或我们希望用滤波器处理的其它数据。</p><p id="e685" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用函数创建数据块的新实例:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1a21" class="mg kv iq mc b gy mh mi l mj mk">dblk_t *datab_alloc(int size);</span></pre><p id="da3b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一个输入参数，它被传递给块将要存储的数据的大小。分配更多的内存是为了在分配的内存的开始放置一个头——一个<em class="kt"> datab </em>结构。但是当使用其他函数时，这并不总是发生，在某些情况下，数据缓冲区可能与数据块的头分开。在创建过程中，结构字段被配置为使其<em class="kt"> db_base </em>字段指向数据区的开头，而<em class="kt"> db_lim </em>指向其结尾。参考计数<em class="kt"> db_ref </em>被设置为1。数据清理函数指针被设置为零。</p><h1 id="9cea" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5.2消息mblk_t</h1><p id="b065" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">如上所述，队列元素属于类型<em class="kt"> mblk_t </em>，其定义如下:</p><p id="a26b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单5.2:结构mblk_t</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="37c3" class="mg kv iq mc b gy mh mi l mj mk">typedef struct msgb<br/>{<br/>  struct msgb *b_prev;   // Pointer to the previous item in the list.<br/>  struct msgb *b_next;   // Pointer to the next item in the list.<br/>  struct msgb *b_cont;   // Pointer for “gluing” other messages to a message to create a message tuple.<br/>  struct datab *b_datap; // Pointer to the structure of the data block.<br/>  unsigned char *b_rptr; // Pointer to the beginning of the data area to read data from the b_datap buffer.<br/>  unsigned char *b_wptr; // Pointer to the beginning of the data area to write data to the b_datap buffer.<br/>  uint32_t reserved1;    // Reserved field1, media streamer puts service information there.<br/>  uint32_t reserved2;    // Reserved field2, media streamer places service information there.<br/>  #if defined(ORTP_TIMESTAMP)<br/>  struct timeval timestamp;<br/>  #endif<br/>  ortp_recv_addr_t recv_addr;<br/>} mblk_t;</span></pre><p id="d050" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开始的<em class="kt"> mblk_t </em>结构包含<em class="kt"> b_prev </em>，<em class="kt"> b_next </em>指针，需要这些指针来组织一个双向链表(也就是<em class="kt"> queue_t </em>队列)。</p><p id="0f9b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后是<em class="kt"> b_contb_cont </em>指针，它只在消息进入元组时使用。对于元组中的最后一条消息，该指针保持为空。</p><p id="aa4f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们看到一个指向<em class="kt"> b_datap </em>数据块的指针，该消息存在于其中。其后是指向块数据缓冲区内区域的指针。<em class="kt"> b_rptr </em>字段指示将从哪个位置读取缓冲器中的数据。<em class="kt"> b_wptr </em>字段指示写入缓冲区的位置。</p><p id="aeb2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">其余字段是服务性质的，与数据传输机制的操作无关。</p><p id="cad0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">图<a class="ae ks" href="#fig___________mblk_t" rel="noopener ugc nofollow"> 5.1 </a>显示了名为<em class="kt"> m1 </em>的单条消息和数据块<em class="kt"> d1 </em>。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/0ff7ea5ee2c1c130812d9b2cf1dc02df.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*UjiQBb1bFBhmlUItu-HGaw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图5.1:消息mblk_t</figcaption></figure><p id="d2f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在图片上<a class="ae ks" href="#fig_______________" rel="noopener ugc nofollow"> 5.2 </a>描绘了三个消息的元组<em class="kt"> m1 </em>、<em class="kt"> m1_1 </em>、<em class="kt"> m1_2 </em>。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/982b014b7627ec74acfdf19f2a81d00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*f8vJFzgJl7FPKdWMlqO8Ig.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图5.2:三个消息的元组<em class="mr"> mblt_t </em></figcaption></figure><h1 id="62db" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5.2.1使用mblk_t操作<br/>的功能</h1><p id="f220" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">函数<em class="kt"> allocb() </em>创建了一条新消息<em class="kt"> mblk_t </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ca34" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *allocb(int size, int pri);</span></pre><p id="7c97" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它在内存中分配一个新消息<em class="kt"> mblk_t </em>和一个指定<em class="kt">大小</em>的数据块，第二个参数<em class="kt"> pri </em>在这个版本的库中没有使用。在它的位置你需要替换BPRI _地中海宏(扩展宏后，零将被替换)。在该函数运行期间，将为新消息的结构分配内存，并将调用函数<em class="kt"> mblk_init() </em>，该函数将该结构的已创建实例的所有字段清零，然后使用上述<em class="kt"> datab_alloc() </em>创建一个数据缓冲区。之后，将配置结构中的字段:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="40d1" class="mg kv iq mc b gy mh mi l mj mk">mp-&gt;b_datap = datab;<br/>mp-&gt;b_rptr = mp-&gt;b_wptr = datab-&gt;db_base;<br/>mp-&gt;b_next = mp-&gt;b_prev = mp-&gt;b_cont = NULL;</span></pre><p id="dbab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在输出端，我们得到一个新消息，其中包含初始化的字段和一个空的数据缓冲区。要向消息中添加数据，需要将其复制到数据块缓冲区:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="55db" class="mg kv iq mc b gy mh mi l mj mk">memcpy(msg-&gt;b_rptr, data, size);</span></pre><p id="71ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">数据数据源指针；数据的大小。</p><p id="758f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，您需要更新指向写指针的指针，使它再次指向缓冲区中空闲区域的开始:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="df25" class="mg kv iq mc b gy mh mi l mj mk">msg-&gt;b_wptr = msg-&gt;b_wptr + size</span></pre><p id="dfaa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您想从现有的缓冲区创建一条消息，而不进行复制，那么使用函数<em class="kt"> esballoc() </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3f27" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *esballoc(uint8_t *buf, int size, int pri, void (*freefn)(void*));</span></pre><p id="836a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建消息和数据块结构后，它将设置指向地址<em class="kt"> buf </em>的数据的指针。那些。在这种情况下，数据缓冲区并不位于数据块的头字段之后，因为数据块是由函数<em class="kt"> datab_alloc() </em>创建的。传递给函数的数据的缓冲区将保持在原来的位置，但在指针的帮助下，它将被刺激到数据块的新创建的头，并相应地被刺激到消息。</p><p id="4e19" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">几个数据块可以连接成一个消息<em class="kt"> mblk_t </em>。这是通过<em class="kt"> appendb() </em>函数完成的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ead9" class="mg kv iq mc b gy mh mi l mj mk">mblk_t * appendb(mblk_t *mp, const char *data, int size, bool_t pad);</span></pre><p id="c965" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将添加一个以上数据块的mpa消息；块的数据指针，其副本将被添加到消息中；大小数据大小；pad标志所分配内存的大小应该沿4字节边界对齐(用零填充)。</p><p id="f0e3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果现有消息数据缓冲区中有足够的空间，新数据将被粘在已有数据的后面。如果消息数据缓冲区中的空闲空间小于<em class="kt">大小</em>，则创建一个具有足够缓冲区大小的新消息，并将数据复制到其缓冲区中。这是一条新消息，使用<em class="kt"> b_cont </em>指针连接到原始消息。在这种情况下，消息变成了一个元组。</p><p id="74f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您需要向元组中再添加一个数据块，那么您需要使用函数<em class="kt">msgapend()</em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8ebb" class="mg kv iq mc b gy mh mi l mj mk">void msgappend(mblk_t *mp, const char *data, int size, bool_t pad);</span></pre><p id="9b42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它将找到元组中的最后一条消息(这样的消息将具有零<em class="kt"> b_cont </em>)并为此消息调用函数<em class="kt"> appendb() </em>。</p><p id="1a95" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以使用函数<em class="kt"> msgdsize() </em>找出消息或元组中数据的大小:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="46e8" class="mg kv iq mc b gy mh mi l mj mk">int msgdsize(const mblk_t *mp);</span></pre><p id="63f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它将遍历元组中的所有消息，并返回这些消息的数据缓冲区中的数据总量。对于每条消息，数据量计算如下:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a8fe" class="mg kv iq mc b gy mh mi l mj mk">mp-&gt;b_wptr - mp-&gt;b_rptr</span></pre><p id="f61b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要组合两个元组，请使用函数<em class="kt"> concatb() </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a22b" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *concatb(mblk_t *mp, mblk_t *newm);</span></pre><p id="ebf6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它将元组<em class="kt"> newm </em>连接到<em class="kt"> mp </em>的尾部，并返回指向结果元组的最后一条消息的指针。</p><p id="6065" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如有必要，可以将元组转换成一条包含单个数据块的消息，这由函数<em class="kt"> msgpullup() </em>完成:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ec9a" class="mg kv iq mc b gy mh mi l mj mk">void msgpullup(mblk_t *mp,int len);</span></pre><p id="62df" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果<em class="kt"> len </em>为-1，则自动确定分配的缓冲区的大小。如果<em class="kt"> len </em>是一个正数，那么这个大小的缓冲区将被创建，元组的消息数据将被复制到其中。如果缓冲区中的位置结束，复制将在那里停止。元组的第一条消息将接收具有复制数据的新大小的缓冲区。其余的消息将被删除，内存返回到堆中。</p><p id="f390" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在删除<em class="kt"> mblk_t </em>结构时，考虑数据块的引用计数，如果在调用<em class="kt"> freeb() </em>时结果是零，那么数据缓冲区连同指向它的<em class="kt"> mblk_t </em>实例一起被删除。</p><p id="f5ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">初始化新消息字段<em class="kt"> mblk_init() </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ef97" class="mg kv iq mc b gy mh mi l mj mk">void mblk_init(mblk_t *mp);</span></pre><p id="686a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在消息<em class="kt"> appendb() </em>中增加一条数据:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d692" class="mg kv iq mc b gy mh mi l mj mk">mblk_t * appendb(mblk_t *mp, const char *data, size_t size, bool_t pad);</span></pre><p id="2ee2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果新数据不适合消息数据缓冲区的空闲空间，则将具有所需大小的缓冲区的单独创建的消息附加到该消息(指向添加的消息的指针设置在第一个消息中)，该消息变成元组。</p><p id="8de3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">向元组添加数据块<em class="kt">msgapend()</em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e983" class="mg kv iq mc b gy mh mi l mj mk">void msgappend(mblk_t *mp, const char *data, size_t size, bool_t pad);</span></pre><p id="623a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该函数循环调用<em class="kt"> appendb() </em>。</p><p id="ed03" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将两个元组合并成一个<em class="kt"> concatb() </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="68a2" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *concatb(mblk_t *mp, mblk_t *newm);</span></pre><p id="430f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">消息<em class="kt"> newm </em>将被附加到<em class="kt"> mp </em>上。</p><p id="a00b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">制作单个消息的副本<em class="kt"> copyb() </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e915" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *copyb(const mblk_t *mp);</span></pre><p id="d126" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">包含所有数据块的元组的完整副本<em class="kt"> copymsg() </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0113" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *copymsg(const mblk_t *mp);</span></pre><p id="5d5d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">元组的元素由函数<em class="kt"> copyb() </em>复制。</p><p id="8b1f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建<em class="kt"> mblk_t </em>消息的简单副本。在这种情况下，数据块不被复制，但是其链接的计数器<em class="kt"> db_ref </em>增加:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b5a0" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *dupb(mblk_t *mp);</span></pre><p id="922a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">制作元组的简单副本。不复制数据块，仅增加其引用计数<em class="kt"> db_ref </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="22ac" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *dupmsg(mblk_t* m);</span></pre><p id="b190" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将一个元组的所有消息合并成一条消息<em class="kt"> msgpullup() </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b2dc" class="mg kv iq mc b gy mh mi l mj mk">void msgpullup(mblk_t *mp,size_t len);</span></pre><p id="22c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果<em class="kt"> len </em>为-1，那么分配的缓冲区大小将自动设置。</p><p id="5c56" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">删除消息或元组<em class="kt"> freemsg() </em>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="edb8" class="mg kv iq mc b gy mh mi l mj mk">void freemsg(mblk_t *mp);</span></pre><p id="d8aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">数据块的引用计数减1。如果同时达到零，则数据块也被删除。</p><p id="1ec3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">计算消息或元组中的数据总量。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="5437" class="mg kv iq mc b gy mh mi l mj mk">size_t msgdsize(const mblk_t *mp);</span></pre><p id="7d78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将一个消息的保留字段的内容复制到另一个消息(实际上，这些字段包含媒体流所使用的标志):</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="64e0" class="mg kv iq mc b gy mh mi l mj mk">mblk_meta_copy(const mblk_t *source, mblk *dest);</span></pre><h1 id="16c7" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5.3队列queue_t</h1><p id="ccbe" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">媒体流中的消息队列被实现为循环双向链表。列表中的每个元素都包含一个指向具有信号样本的数据块的指针。原来只有指向数据块的指针被依次移动，而数据本身保持不动。描述队列<em class="kt"> queue_t </em>的结构，如下所示:</p><p id="2fd6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单5.3:结构queue_t</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6b0f" class="mg kv iq mc b gy mh mi l mj mk">typedef struct _queue<br/>{<br/>   mblk_t _q_stopper; /* Idle queue element, does not point to data, is used only for queue management. When initializing a queue(qinit()) its pointers are configured to point to itself. */<br/>   int q_mcount;        /* Number of items in the queue. */<br/>} queue_t;</span></pre><p id="2c5d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该结构包含一个类型为<em class="kt"> *mblk_t </em>的字段指针<em class="kt"> _q_stopper </em>，它指向队列中的第一项(消息)。该结构的第二个字段是队列中消息的计数器。下图<a class="ae ks" href="#fig____________4_" rel="noopener ugc nofollow"> 5.3 </a>中一个名为<em class="kt"> q1 </em>的队列，包含4条消息<em class="kt"> m1 </em>、<em class="kt"> m2 </em>、<em class="kt"> m3 </em>、<em class="kt"> m4 </em>。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/fcd6b55c44de10c08ca000063c979c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSpvg0iIlmTS_lXijicCJQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图5.3:4条消息的队列</figcaption></figure><p id="465f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如下图<a class="ae ks" href="#fig____________3_" rel="noopener ugc nofollow"> 5.4 </a>一个名为<em class="kt"> q1 </em>的队列，包含4条消息<em class="kt"> m1 </em>、<em class="kt"> m2 </em>、<em class="kt"> m3 </em>、<em class="kt"> m4 </em>，其中<em class="kt">m2</em>——两条消息的元组。消息<em class="kt"> m2 </em>是包含另外两个消息<em class="kt"> m2_1 </em>和<em class="kt"> m2_2 </em>的元组的头。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/a13fb51734edeefc103a107a77ce6c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yaU0sSXs-Cf3o2ZIOsquhg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图5.4:3条消息和一个元组的队列</figcaption></figure><h1 id="9ffe" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5 . 3 . 1<br/>使用queue_t的功能</h1><p id="c45a" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">队列初始化:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b0a1" class="mg kv iq mc b gy mh mi l mj mk">void qinit(queue_t *q);</span></pre><p id="35ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kt"> _q_stopper </em>字段(以下我们称之为“stopper”)用<em class="kt"> mblk_init() </em>函数初始化，设置它的前一个元素和下一个元素的指针，使它们指向自身。队列项计数器被重置为零。</p><p id="1529" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">添加新项目(消息):</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0f9e" class="mg kv iq mc b gy mh mi l mj mk">void putq(queue_t *q, mblk_t *m);</span></pre><p id="8d38" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个新元素<em class="kt"> m </em>被添加到列表的末尾，元素指针被调整，使得停止符成为它的下一个元素，并且它成为停止符的前一个元素。队列项计数器递增。</p><p id="7642" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从队列中检索项目:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e3fb" class="mg kv iq mc b gy mh mi l mj mk">mblk_t * getq(queue_t *q);</span></pre><p id="ab9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">取回止动器后，元件计数器递减。如果队列中没有元素，除了停止符，则返回0。</p><p id="5169" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将消息插入队列:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b259" class="mg kv iq mc b gy mh mi l mj mk">void insq(queue_t *q, mblk_t *emp, mblk_t *mp);</span></pre><p id="52e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kt"> mp </em>元件插在<em class="kt"> emp </em>元件之前。如果<em class="kt"> emp </em>为0，则消息被添加到队列的尾部。</p><p id="2703" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从队列头提取消息:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fa74" class="mg kv iq mc b gy mh mi l mj mk">void remq(queue_t *q, mblk_t *mp);</span></pre><p id="26ba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">元素计数器递减1。</p><p id="0e3c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">读取指向队列中第一项的指针:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d419" class="mg kv iq mc b gy mh mi l mj mk">mblk_t * peekq(queue_t *q);</span></pre><p id="6b32" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从队列尾部提取消息:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d322" class="mg kv iq mc b gy mh mi l mj mk">mblk_t *ms_queue_peek_last (queue_t *q);</span></pre><p id="e95f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从队列中移除所有项目，同时移除项目本身:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0345" class="mg kv iq mc b gy mh mi l mj mk">void flushq(queue_t *q, int how);</span></pre><p id="0ccb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">没有使用<em class="kt">和</em>参数。队列项计数器被设置为零。</p><p id="2699" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">读取指向队列最后一个元素的指针的宏:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8cf4" class="mg kv iq mc b gy mh mi l mj mk">mblk_t * qlast(queue_t *q);</span></pre><p id="32e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用消息队列时，请记住，当您使用指向消息的空指针调用<em class="kt"> ms_queue_put (q，m) </em>时，该函数将会循环。你的程序会冻结。函数<em class="kt"> ms_queue_next (q，m) </em>的行为类似。</p><h1 id="0909" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">连接过滤器</h1><p id="9c8a" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">上述队列用于将邮件从一个过滤器传输到另一个过滤器，或者从一个过滤器传输到多个过滤器。过滤器和它们之间的连接形成了一个有向图。滤波器的输入或输出将被称为概括词“pin”。为了描述过滤器之间的连接顺序，mediastreamer使用了“信号点”的概念。信号点是结构<em class="kt"> MSCPoint </em>，它包含一个指向滤波器的指针和它的一个管脚的编号，分别描述了滤波器的一个输入或输出的连接。</p><h2 id="a7d2" class="mg kv iq bd kw mx my dn la mz na dp le kf nb nc li kj nd ne lm kn nf ng lq nh bi translated"><br/>数据处理图的信号点</h2><p id="bc36" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">清单5.4:结构化MSCPoint</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="22d1" class="mg kv iq mc b gy mh mi l mj mk">typedef struct _MSCPoint<br/>{<br/>  struct _MSFilter *filter; /* Pointer to the media streamer filter. */<br/>  int pin;                 /* The number of one of the filter inputs or outputs, i.e. pin. */<br/>} MSCPoint;</span></pre><p id="1f7a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">滤波器引脚从零开始编号。两个引脚与消息队列的连接由结构<em class="kt"> MSQueue </em>描述，该结构包含一个消息队列和指向其连接的两个信号点的指针:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8a3f" class="mg kv iq mc b gy mh mi l mj mk">typedef struct _MSQueue<br/>{<br/>  queue_t q;<br/>  MSCPoint prev;<br/>  MSCPoint next;<br/>}MSQueue;</span></pre><p id="14fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们称这种结构为信号链路。每个mediastreamer滤波器包含一个输入表和一个输出信号链接表(<em class="kt"> MSQueue </em>)。创建过滤器时设置表格的大小，在第<a class="ae ks" href="#chap_Filters_development" rel="noopener ugc nofollow"> 4 </a>章开发我们自己的过滤器时，我们已经使用类型为<em class="kt"> MSFilterDesc </em>的导出变量完成了这项工作。下面，在清单<a class="ae ks" href="#lis___________MSFilter" rel="noopener ugc nofollow"> 5.5 </a>中，显示了描述mediastreamer中任何过滤器的结构，<em class="kt"> MSFilter </em>:</p><p id="cc7b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单5.5:струкураms filter</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2f8a" class="mg kv iq mc b gy mh mi l mj mk">struct _MSFilter{<br/>    MSFilterDesc *desc;    /* Pointer to filter descriptor. */<br/>    /* Protected attributes, they cannot be shifted or removed, otherwise the work with plugins will be broken. */<br/>    ms_mutex_t lock;      /* Mutex. */<br/>    MSQueue **inputs;     /* Input links table. */<br/>    MSQueue **outputs;    /* Output links table. */<br/>    struct _MSFactory *factory; /* Pointer to the factory that created this filter instance. */<br/>    void *padding;              /* Not used, will be used if protected fields are added. */<br/>    void *data;                 /* Pointer to an arbitrary structure for storing data for the internal state of the filter and intermediate calculations. */<br/>    struct _MSTicker *ticker;   /* A pointer to the ticker object, which must not be null when the function is called process(). */<br/>    /*private attributes, they can be moved and changed at any time*/<br/>    MSList *notify_callbacks; /* List of callbacks used to handle filter events. */<br/>    uint32_t last_tick;       /* Last measure number when the call   of process() was made. */ <br/>    MSFilterStats *stats;     /* Filter statistics.*/<br/>    int postponed_task; /* Number of pending tasks. Some filters may delay data processing (call process()) for several measures.*/<br/>    bool_t seen;  /* The flag used by the ticker to indicate that it has already served this filter instance at this clock cycle.*/<br/>};</span><span id="6bd8" class="mg kv iq mc b gy ni mi l mj mk">typedef struct _MSFilter MSFilter;</span></pre><p id="fbb5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们按照我们的意图连接了C程序中的过滤器之后(但没有连接跑马灯)，我们由此创建了一个有向图，其节点是<em class="kt"> MSFilter </em>结构的实例，边是信号链接<em class="kt"> MSQueue </em>的实例。</p><h1 id="2b42" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5.4幕后<br/>报价机活动</h1><p id="5287" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">当我告诉你ticker是一个时钟源过滤器时，并没有全部的真相。ticker是一个对象，它每小时执行与其直接或间接连接的所有过滤器的<em class="kt"> process() </em>函数。当我们在C程序中将滚动条连接到图形过滤器时，我们向滚动条显示一个图形，从现在起它将控制这个图形，直到我们关闭它。连接后，ticker开始检查委托给它的图，列出它包含的过滤器列表。为了不“计数”同一个过滤器两次，它通过设置标志<em class="kt">来标记检测到的过滤器，见</em>。搜索是根据每个滤波器的信号链路表进行的。</p><p id="e143" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在熟悉图表的过程中，ticker检查过滤器中是否至少有一个过滤器，它充当数据块的来源。如果没有找到，那么这个图就被认为是不正确的，ticker就会使程序崩溃。</p><p id="a82c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果该图被证明是“正确的”，则为每个找到的过滤器调用<em class="kt">预处理()</em>函数来初始化它。一旦到了下一个处理周期(默认情况下，每隔10毫秒)，ticker就会为所有之前找到的源过滤器调用<em class="kt"> process() </em>函数，然后为其余的列表过滤器调用。如果过滤器有输入链接，那么重复<em class="kt">过程()</em>功能，直到输入链接队列为空。之后，滚动条转到列表中的下一个过滤器并“滚动”它，直到输入链接中没有消息。滚动条从一个过滤器移动到另一个过滤器，直到列表滚动。这就完成了测量的处理。</p><p id="9833" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们将回到元组，并讨论为什么将这样的实体添加到mediastreamer中。一般情况下，滤波器内部算法所需的数据量并不一致，也不是输入数据缓冲器大小的倍数。例如，我们编写一个执行快速傅立叶变换的过滤器，根据定义，它只能处理大小等于2的幂的数据块。假设是512个样本。如果数据是由电话信道产生的，那么输入端的每个消息的数据缓冲器将带给我们160个信号样本。在信号链路达到所需的数据量之前，不从输入端获取数据是一种诱惑。但是在这种情况下，会与ticker发生冲突，ticker会不成功地尝试滚动过滤器，直到输入链接为空。早先我们把这个规则称为过滤器的第三个原则。根据这个原则，过滤器的<em class="kt"> process() </em>函数应该从输入队列中提取所有数据。</p><p id="96e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，不可能从入口仅拾取512个样本，因为只能拾取整个块，即滤波器必须拾取640个样本，使用其中的512个样本，并存储剩余的样本，直到累积新的数据部分。因此，除了它的主要工作之外，我们的过滤器必须为输入数据的中间存储提供辅助动作。用于解决这个一般问题的mediastreamer的开发者已经开发了一个特殊的对象—<em class="kt">ms bufferizer</em>(bufferiser)，它使用元组来解决这个任务。</p><h1 id="df1b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5.5缓冲对象<br/> MSBufferizer</h1><p id="1c83" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">这是一个对象，它可以在过滤器中累积输入数据，并在信息量足以启动过滤器算法时立即开始处理这些数据。当缓冲器累积数据时，过滤器将在空闲模式下工作，而不消耗处理器的处理能力。但是，一旦从缓冲区读取的函数返回非零值，过滤器的<em class="kt"> process() </em>函数就开始从缓冲区获取数据，并按所需大小的部分处理数据，直到它们用尽。无人认领的数据作为元组的第一个元素保留在缓冲区中，新输入数据的后续块附加到该元组中。</p><p id="4a0c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结构<em class="kt"> MSBufferizer </em>，描述清单<a class="ae ks" href="#lis___________MSBufferizer" rel="noopener ugc nofollow"> 5.6 </a>中显示的缓冲。</p><p id="2734" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单5.6:构造MSBufferizer</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="efa3" class="mg kv iq mc b gy mh mi l mj mk">struct _MSBufferizer<br/>{<br/>  queue_t q; /* Message queue. */<br/>  int size; /* The total size of the data currently in the buffer. */<br/>};</span><span id="fcc0" class="mg kv iq mc b gy ni mi l mj mk">typedef struct _MSBufferizer MSBufferizer;</span></pre><h1 id="749d" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5.5.1与MSBufferizer一起使用<br/>的功能</h1><p id="d61a" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">创建bufferiser的新实例:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2270" class="mg kv iq mc b gy mh mi l mj mk">MSBufferizer * ms_bufferizer_new(void);</span></pre><p id="0b47" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">分配内存，在<em class="kt"> ms_bufferizer_init() </em>中初始化，返回一个指针。</p><p id="7c82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">初始化功能:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="061f" class="mg kv iq mc b gy mh mi l mj mk">void ms_bufferizer_init(MSBufferizer *obj);</span></pre><p id="ebeb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">队列<em class="kt"> q </em>被初始化，大小<em class="kt">字段</em>被设置为零。</p><p id="2662" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">添加消息:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9ecf" class="mg kv iq mc b gy mh mi l mj mk">void ms_bufferizer_put(MSBufferizer *obj, mblk_t *m);</span></pre><p id="fe36" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">消息<em class="kt"> m </em>被添加到队列。数据块的计算大小被加到<em class="kt">大小</em>中。</p><p id="2203" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">缓冲链路<em class="kt"> q </em>的数据队列中的所有消息:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8ca5" class="mg kv iq mc b gy mh mi l mj mk">void ms_bufferizer_put_from_queue(MSBufferizer *obj, MSQueue *q);</span></pre><p id="a6e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用函数<em class="kt"> ms_bufferizer_put() </em>将消息从链路<em class="kt"> q </em>传输到缓冲器。</p><p id="0def" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从缓冲器中读取:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ba9a" class="mg kv iq mc b gy mh mi l mj mk">int ms_bufferizer_read(MSBufferizer *obj, uint8_t *data, int datalen);</span></pre><p id="5edd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果缓冲器中累积的数据量小于请求的数据量(<em class="kt"> datalen </em>)，该函数返回零，数据不会被复制到<em class="kt"> data </em>中。否则，从缓冲区的元组中顺序复制数据。复制后，元组被删除，内存被释放。当<em class="kt"> datalen </em>字节被复制时，复制结束。如果<em class="kt">数据中的空间</em>在源数据块中间结束，那么在这个消息中，它将被减少到剩余的、尚未复制的部分。在下一次调用时，复制将从这一点继续。</p><p id="758d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">读取缓冲区中当前可用的数据量:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bc2d" class="mg kv iq mc b gy mh mi l mj mk">int ms_bufferizer_get_avail(MSBufferizer *obj);</span></pre><p id="7a0b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">返回缓冲器的<em class="kt">大小</em>字段。</p><p id="657a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">丢弃缓冲区中的一些数据:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fd7a" class="mg kv iq mc b gy mh mi l mj mk">void ms_bufferizer_skip_bytes(MSBufferizer *obj, int bytes);</span></pre><p id="c5e8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检索并丢弃指定字节数的数据。最旧的数据将被丢弃。</p><p id="4f62" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">删除bufferiser中的所有消息:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="da62" class="mg kv iq mc b gy mh mi l mj mk">void ms_bufferizer_flush(MSBufferizer *obj);</span></pre><p id="3876" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">数据计数器被重置为零。</p><p id="3830" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">删除bufferiser中的所有消息:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fb6c" class="mg kv iq mc b gy mh mi l mj mk">void ms_bufferizer_uninit(MSBufferizer *obj);</span></pre><p id="6a52" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">计数器不会复位。</p><p id="f861" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">移除缓冲区并释放内存:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4895" class="mg kv iq mc b gy mh mi l mj mk">void ms_bufferizer_destroy(MSBufferizer *obj);</span></pre><p id="b6f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用缓冲的示例可以在几个mediastreamer过滤器的源代码中找到。例如，在将样本中的字节从网络顺序交换到主机顺序的过滤器MS_L16_ENC中:<a class="ae ks" href="https://github.com/BelledonneCommunications/mediastreamer2/blob/1a9e8dec369a65ed10db975f5b77b92dc999b096/src/audiofilters/l16.c" rel="noopener ugc nofollow" target="_blank"> l16.c </a></p><p id="c801" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下一章，我们将看看调试过滤器。</p><p id="4e2f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kt"> ( </em>下一篇<em class="kt"> </em> <a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/whats-mediastreamer2-debugging-craft-filters-83a07192c341">什么是Mediastreamer2。调试<br/>精心制作的过滤器</a></p><blockquote class="nj nk nl"><p id="3420" class="ju jv kt jw b jx jy jz ka kb kc kd ke nm kg kh ki nn kk kl km no ko kp kq kr ij bi translated">附言</p><p id="a897" class="ju jv kt jw b jx jy jz ka kb kc kd ke nm kg kh ki nn kk kl km no ko kp kq kr ij bi translated">如果你对如何轻松绘制像5.1–5.4这样的精美图片感兴趣，你可以阅读我的文章:<a class="ae ks" href="https://medium.com/swlh/synergy-of-graphviz-and-the-c-c-preprocessor-254e5d0db542" rel="noopener">Graphviz和C/C ++预处理器的协同</a></p></blockquote></div></div>    
</body>
</html>