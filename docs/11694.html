<html>
<head>
<title>How to use libraries in a Linux C program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Linux C程序中使用库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-libraries-in-linux-c-program-d907c8528f9c?source=collection_archive---------5-----------------------#2022-04-06">https://levelup.gitconnected.com/how-to-use-libraries-in-linux-c-program-d907c8528f9c?source=collection_archive---------5-----------------------#2022-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="f552" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背景</h1><p id="ee5a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在你学会并理解了如何在Linux中编写小的C程序之后(也就是说你知道C语言的语法以及如何用<code class="fe lj lk ll lm b">gcc</code>来编译你的程序)，你会想要有一些冒险来编写更强大更大的程序。要成为一名伟大的软件工程师，你需要这种探索的激情，对吗？</p><p id="1ad7" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">要编写一个更大的程序，你不能从头开始构建一切。这意味着您需要在您的程序中导入和使用他人开发的库。</p><p id="030f" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">对于Linux C编程的新开发者来说，整个库的处理可能是一个谜，这需要关于<code class="fe lj lk ll lm b">gcc compiler</code>、<code class="fe lj lk ll lm b">Linux system</code>、<code class="fe lj lk ll lm b">GNU conventions</code>等等的知识。在这篇文章中，我将关注这个话题，并把所有这些拼凑在一起。读完这篇文章后，我希望你可以放心大胆地将开源世界的共享库添加到你的程序中。</p><p id="022b" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><strong class="kn ir">注</strong>:为了更清楚地说明讨论，本文基于这个演示github <a class="ae ls" href="https://github.com/baoqger/handle-c-library-demo-linux" rel="noopener ugc nofollow" target="_blank"> app </a>。我的演示应用程序是从斯蒂芬·阿文韦德的原始<a class="ae ls" href="https://opensource.com/article/20/6/linux-libraries" rel="noopener ugc nofollow" target="_blank">回购</a>中派生出来的。谢谢你。</p><p id="cac7" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这个演示应用程序的代码逻辑非常简单，所以我不会在本文中逐行审查代码，这不是本文的目标。</p><h1 id="e0d5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">静态库与共享库</h1><p id="be60" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，有两种类型的图书馆:<code class="fe lj lk ll lm b">Static</code>和<code class="fe lj lk ll lm b">Shared</code>。</p><ul class=""><li id="66ce" class="lt lu iq kn b ko ln ks lo kw lv la lw le lx li ly lz ma mb bi translated"><strong class="kn ir">静态库</strong>:简单来说就是普通对象文件的集合；按照惯例，静态库以<code class="fe lj lk ll lm b">.a</code>后缀结尾。该集合是使用<code class="fe lj lk ll lm b">ar</code>命令创建的。例如，在演示应用程序中，我们像这样构建静态库:</li></ul><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="47f8" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在我们的例子中，静态库将安装在子目录<code class="fe lj lk ll lm b">./lib/static</code>中，并命名为<code class="fe lj lk ll lm b">libmy_static.a</code>。</p><p id="d69a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">当应用程序链接到一个静态库时，该库的代码成为生成的可执行文件的一部分。因此，您无需任何进一步的设置或配置就可以运行该应用程序。这是静态库的最大优势，您将在下一节看到它是如何工作的。</p><p id="1ff2" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">静态库不像以前那样经常使用，因为<code class="fe lj lk ll lm b">shared library</code>有更多的优势。</p><ul class=""><li id="fb69" class="lt lu iq kn b ko ln ks lo kw lv la lw le lx li ly lz ma mb bi translated"><strong class="kn ir">共享库</strong>:以<code class="fe lj lk ll lm b">.so</code>结尾，表示<strong class="kn ir">共享对象</strong>。当应用程序启动时，共享库被加载到内存中。如果多个应用程序使用同一个共享库，共享库将只加载一次。在我们的演示应用程序中，共享库构建如下:</li></ul><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="08aa" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">共享库<code class="fe lj lk ll lm b">libmy_shared.so</code>安装在<code class="fe lj lk ll lm b">./lib/shared</code>子目录下。注意，共享库是为<code class="fe lj lk ll lm b">gcc</code>构建的，有一些特殊的选项，比如<code class="fe lj lk ll lm b">-fPIC</code>和<code class="fe lj lk ll lm b">-shared</code>。详细的，你可以查看gcc的文档。</p><h1 id="1530" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">命名约定</h1><p id="abea" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，共享库的名字遵循这样的模式:<code class="fe lj lk ll lm b">lib</code> +库名+ <code class="fe lj lk ll lm b">.so</code>。当然，版本信息非常重要，但是在本文中，我们忽略版本问题。</p><h1 id="0d4e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">链接库</h1><p id="8110" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">构建完库后，下一步您需要将库导入到应用程序中。对于我们的app，源代码是如下的<code class="fe lj lk ll lm b">demo/main.c</code>文件:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7eb9" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">注意，我们导入了三个<code class="fe lj lk ll lm b">header file</code>库。下一个问题是如何构建演示应用程序。</p><p id="5a7a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">让我们回忆一下一个C程序的构建过程如下:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/f5b994762d92c7281b682641077288c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FvlM8MNrrroKhN87.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">编译过程</figcaption></figure><p id="6d72" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这是一个两步过程:<code class="fe lj lk ll lm b">compile</code>和<code class="fe lj lk ll lm b">link</code>。首先将<code class="fe lj lk ll lm b">main.c</code>的源代码文件编译成一个目标文件，比如说<code class="fe lj lk ll lm b">main.o</code>文件。在这一步，关键的事情是告诉<code class="fe lj lk ll lm b">gcc</code>在哪里可以找到库的<code class="fe lj lk ll lm b">header file</code>。接下来，将<code class="fe lj lk ll lm b">main.o</code>目标文件链接到我们的库:<code class="fe lj lk ll lm b">libmy_static.a</code>和<code class="fe lj lk ll lm b">libmy_shared.so</code>。<code class="fe lj lk ll lm b">gcc</code>需要知道它应该链接的库的名称以及在哪里可以找到这些库，对吗？</p><p id="1256" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这些信息可以由以下三个选项定义:</p><ul class=""><li id="42ff" class="lt lu iq kn b ko ln ks lo kw lv la lw le lx li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">I</code>:增加头文件的包含目录，</li><li id="b41b" class="lt lu iq kn b ko mu ks mv kw mw la mx le my li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">l</code>:库名</li><li id="8144" class="lt lu iq kn b ko mu ks mv kw mw la mx le my li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">L</code>:库的目录</li></ul><p id="1557" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在我们的例子中，构建演示应用程序的<code class="fe lj lk ll lm b">make</code>命令如下:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="307d" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">由于我们有两个库:<code class="fe lj lk ll lm b">libmy_static.a</code>和<code class="fe lj lk ll lm b">libmy_shared.so</code>，基于我们上面提到的命名约定，库名的<code class="fe lj lk ll lm b">-l</code>选项应该是<strong class="kn ir"> my_static </strong>和<strong class="kn ir"> my_shared </strong>。我们可以为每个库使用两个<code class="fe lj lk ll lm b">-l</code>选项。</p><p id="93a9" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">对于<code class="fe lj lk ll lm b">-L</code>选项，我们需要提供找到库的目录路径。我们可以使用相对于演示源代码文件的路径<code class="fe lj lk ll lm b">../lib/shared</code>和<code class="fe lj lk ll lm b">../lib/static</code>。对吗？同样的规则也适用于包含头文件的<code class="fe lj lk ll lm b">-I</code>选项。</p><p id="63ad" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">运行<code class="fe lj lk ll lm b">make demo</code>命令，你就可以成功地构建库链接在一起的演示应用了。</p><h1 id="5cdd" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">文件系统放置约定</h1><p id="b06d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我上面所展示的，库被放在这个项目的子目录中。这样不方便别人导入你的库。大多数开源软件倾向于遵循<code class="fe lj lk ll lm b">GNU</code>标准。<code class="fe lj lk ll lm b">GNU</code>标准推荐在分发源代码时默认安装<code class="fe lj lk ll lm b">/usr/local/lib</code>中的所有库和<code class="fe lj lk ll lm b">/usr/local/include</code>中的所有头文件。因此，让我们再添加一个<code class="fe lj lk ll lm b">make</code>命令，将库文件和头文件安装到基于GNU约定的目录中:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bd6d" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">为此，您可以在我的开源项目中找到类似的make命令。</p><p id="5996" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">好处是<code class="fe lj lk ll lm b">gcc</code>编译器(也来自GNU，遵循相同的约定)默认会在这两个目录中寻找库:<code class="fe lj lk ll lm b">/usr/local/lib</code>和<code class="fe lj lk ll lm b">/usr/local/include</code>。所以不需要设置<code class="fe lj lk ll lm b">-L</code>和<code class="fe lj lk ll lm b">-I</code>选项。例如，在我们运行上面的<code class="fe lj lk ll lm b">make install</code>命令并将库安装到系统目录中后，您可以如下构建演示应用程序:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4374" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">了解<code class="fe lj lk ll lm b">GNU</code>约定可以让你的开发更容易吧？</p><p id="d9f9" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">然后下一步让我们通过简单地调用<code class="fe lj lk ll lm b">./my_app</code>来运行演示应用程序，但是您会得到下面的错误消息:</p><pre class="mc md me mf gt mz lm na nb aw nc bi"><span id="fa6c" class="nd jo iq lm b gy ne nf l ng nh">./my_app: error while loading shared libraries: libmy_shared.so: cannot open shared object file: No such file or directroy</span></pre><p id="701a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">发生什么事了？</p><h1 id="3c55" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">动态连接器</h1><p id="47ae" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我们启动一个可执行文件时，Linux内核会自动运行<code class="fe lj lk ll lm b">dynamic linker</code>(或者动态加载器)。这个动态链接器依次查找并加载程序使用的所有其他共享库。</p><p id="2fef" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">事实上，Linux系统中的可执行文件通常是<code class="fe lj lk ll lm b"><a class="ae ls" href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/" rel="noopener ugc nofollow" target="_blank">ELF</a></code>格式，缩写为<code class="fe lj lk ll lm b">Executable and Linkable Format</code>。ELF可执行文件包含链接信息，动态链接器只是读取这些信息来加载共享库。</p><p id="f2e5" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在Linux系统中，动态链接器的名字是<code class="fe lj lk ll lm b">ld.so</code></p><p id="ef56" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">根据上面的错误信息，我们可以说动态链接器找不到共享库。我们可以通过运行<code class="fe lj lk ll lm b">ldd</code>命令来验证这一点，该命令用于打印命令行上指定的每个程序或共享对象所需的共享对象(共享库)。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ni"><img src="../Images/f8bc01ccb4a13dd1cdb9cd7da533a127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ChUWcqiq1jDHebX8.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">ldd</figcaption></figure><p id="e388" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">显然，我们的共享库<code class="fe lj lk ll lm b">libmy_shared.so</code>没有找到。我们需要看看<code class="fe lj lk ll lm b">ld.so</code>是如何工作的。找到这些信息的最好方法是运行<code class="fe lj lk ll lm b">man</code>命令。我们可以在<code class="fe lj lk ll lm b">ld.so</code>手册文档中获得以下信息:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nj"><img src="../Images/9a70cb6465e489d48c0f7eac4530e9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s2rmBXQcPzXLucW6.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">ld.so</figcaption></figure><p id="8a33" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">根据这张截图，我们可以通过三种方式解决这个问题:</p><ul class=""><li id="5958" class="lt lu iq kn b ko ln ks lo kw lv la lw le lx li ly lz ma mb bi translated">将共享库安装到目录:<code class="fe lj lk ll lm b">/lib</code>或<code class="fe lj lk ll lm b">/usr/lib</code></li><li id="d265" class="lt lu iq kn b ko mu ks mv kw mw la mx le my li ly lz ma mb bi translated">通过追加包含我们库的目录路径来编辑环境变量<code class="fe lj lk ll lm b">LD_LIBRARY_PATH</code></li><li id="2671" class="lt lu iq kn b ko mu ks mv kw mw la mx le my li ly lz ma mb bi translated">更新缓存文件<code class="fe lj lk ll lm b">/etc/ld.so.cache</code></li></ul><p id="47f3" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">根据我的测试，前两种方法可以很好地工作，但我个人推荐使用第三种方法，这是一种更系统的注册库的方法。</p><h1 id="2e2f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">寄存器库</h1><p id="1b65" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了注册一个新的库，我们需要使用命令<code class="fe lj lk ll lm b">ldconfig</code>来配置动态链接器运行时绑定。</p><p id="b7aa" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><code class="fe lj lk ll lm b">ldconfig</code>是如何工作的？它会搜索一些特定目录下的<code class="fe lj lk ll lm b">.so</code>库文件，搜索结果会更新到动态链接器的缓存文件<code class="fe lj lk ll lm b">/etc/ld.so.cache</code>。</p><p id="3af4" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">而<code class="fe lj lk ll lm b">ldconfig</code>会看的目录之一就是<code class="fe lj lk ll lm b">/etc/ld.so.conf</code>。在我们的Ubuntu系统中，它实际上是一个如下的文件:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nk"><img src="../Images/b5b643dbf2a7625eb15f2741ae8437cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XuePL-OF3m-f6xOa.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">ld.so.conf</figcaption></figure><p id="dea2" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">它扩展到<code class="fe lj lk ll lm b">ld.so.conf.d</code>中的所有<code class="fe lj lk ll lm b">.conf</code>文件，在我的例子中，有一个默认文件<code class="fe lj lk ll lm b">libc.conf</code>，如下所示:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nl"><img src="../Images/9243e40a68187e36ffd1dd34553e055a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yyy0gKDV1yuaxTHU.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">libc.conf</figcaption></figure><p id="3936" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">请注意，<code class="fe lj lk ll lm b">/usr/local/lib</code>是在文件中定义的，那么<code class="fe lj lk ll lm b">ldconfig</code>将会搜索。所以这个目录中的库。</p><p id="3453" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">正如我们在上一节提到的，<code class="fe lj lk ll lm b">/usr/local/lib</code>只是安装基于GNU惯例的共享库的地方。对吗？</p><p id="acab" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">因此，我们可以简单地运行<code class="fe lj lk ll lm b">ldconfig</code>命令，而没有任何选项来<strong class="kn ir">注册一个新库</strong>(确保该库安装在该目录中):</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nm"><img src="../Images/76597a1575b646c9929c519ca8a2995c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UuC6l0mapJf4cJya.png"/></div></div></figure><p id="5cbc" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在上面的截图中，你可以看到运行<code class="fe lj lk ll lm b">sudo ldconfig</code>命令前后的变化。(<code class="fe lj lk ll lm b">ldconfig -p</code>将列出当前从缓存文件中读取的库文件<code class="fe lj lk ll lm b">/etc/ld.so.cache</code>)。注册库后，添加到动态链接器的缓存文件中，对吗？让我们用<code class="fe lj lk ll lm b">ldd</code>再次验证一下:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nk"><img src="../Images/44505383f90d9836dd23cef1ddbc41ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ge9VDCudsQfN-i61.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">ldd-结果</figcaption></figure><p id="72b0" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">可以找到我们新的共享库！然后我们也可以成功运行应用程序。</p><h1 id="efab" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="4663" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我们讨论了几个重要的工具，如<code class="fe lj lk ll lm b">ld.so</code>、<code class="fe lj lk ll lm b">ldd</code>、<code class="fe lj lk ll lm b">ldconfig</code>和<code class="fe lj lk ll lm b">gcc</code>，它们帮助您构建和导入共享库。另一件事是<code class="fe lj lk ll lm b">GNU</code>定义这些工具行为的惯例或标准。</p></div></div>    
</body>
</html>