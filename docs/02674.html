<html>
<head>
<title>Django User Groups with Django Rest Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Django Rest框架的Django用户组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/django-user-groups-with-django-rest-framework-f6f2bab43499?source=collection_archive---------2-----------------------#2020-03-29">https://levelup.gitconnected.com/django-user-groups-with-django-rest-framework-f6f2bab43499?source=collection_archive---------2-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="4078" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">情况</h1><p id="345a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">周末，按照客户的要求，我开始在我们的旗舰web应用程序中实现“只读”用户帐户。</p><p id="f43b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当前的应用程序栈是一个React前端，由Django web应用程序提供服务，与Django-Rest-Framework后端API进行交互。</p><p id="7ef9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在过去与Django一起工作时，我相当确定存在一些很好的内置用户权限特性，如果不是一个完整的解决方案，将为我在我们的应用程序中添加不同级别的客户雇员帐户提供一个很好的起点。</p><p id="19c1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">事实上，当我再次访问Django文档的认证部分时，我的怀疑得到了证实。长话短说Django内置了一个非常漂亮的基于模型的权限系统，我在下面解释一下:</p><p id="95d7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">权限</strong></p><p id="a942" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于Django项目中指定的每个模型(或数据库表),存在四种权限类型:</p><ul class=""><li id="24e4" class="ls lt it kq b kr lm kv ln kz lu ld lv lh lw ll lx ly lz ma bi translated">查看—读取数据库记录的能力</li><li id="9093" class="ls lt it kq b kr mb kv mc kz md ld me lh mf ll lx ly lz ma bi translated">添加—能够添加数据库记录</li><li id="5a3d" class="ls lt it kq b kr mb kv mc kz md ld me lh mf ll lx ly lz ma bi translated">更改—更改数据库记录的能力</li><li id="1fc2" class="ls lt it kq b kr mb kv mc kz md ld me lh mf ll lx ly lz ma bi translated">删除—删除数据库记录的能力</li></ul><p id="98e6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">组</strong></p><p id="a18a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">上述权限可以分配给任何用户(即django用户模型的实例)，以限制该用户访问或修改数据库中记录的能力。但是，创建权限并将其分配给一个组通常更有意义。这样，添加到该组的任何用户都会继承其所有权限。</p><p id="deb5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">组方法的明显优势是，如果需要检查或更新权限，可以在组级别进行更改，该组的所有用户都将感受到影响，而不是审核每个用户的单独权限。</p><p id="534c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">看起来很简单，对吧？</p><h1 id="bd85" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">问题</h1><p id="5042" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Django权限+组似乎是我的特性需求的完美解决方案。从表面上看，我的实现很简单，几乎不需要修改代码:</p><ol class=""><li id="3846" class="ls lt it kq b kr lm kv ln kz lu ld lv lh lw ll mg ly lz ma bi translated">只需创建一个<code class="fe mh mi mj mk b">read-only</code>组</li><li id="7c9d" class="ls lt it kq b kr mb kv mc kz md ld me lh mf ll mg ly lz ma bi translated">将我的应用程序中每个模型的<code class="fe mh mi mj mk b">view</code>权限添加到该组中。</li><li id="0df7" class="ls lt it kq b kr mb kv mc kz md ld me lh mf ll mg ly lz ma bi translated">每次创建一个用户，我可以把他们添加到<code class="fe mh mi mj mk b">read-only</code>组。</li></ol><p id="0824" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">轻松点。至少我是这样认为的…</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/0fe53cf530b5474a68e36c7565148c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-2HUPQQst_A0mq53s33ew.png"/></div></div></figure><p id="27c2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我继续将以下内容添加到我的<code class="fe mh mi mj mk b">settings.py</code>文件中的<code class="fe mh mi mj mk b">REST_FRAMEWORK</code>字典对象中:</p><pre class="mm mn mo mp gt mx mk my mz aw na bi"><span id="cfc3" class="nb jr it mk b gy nc nd l ne nf">"DEFAULT_PERMISSION_CLASSES": [<br/>    "rest_framework.permissions.IsAuthenticated",<br/>    "rest_framework.permissions.DjangoModelPermissions",<br/>]</span></pre><p id="0729" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">为了清楚起见，我的<code class="fe mh mi mj mk b">settings.py</code>文件现在定义了以下对象:</p><pre class="mm mn mo mp gt mx mk my mz aw na bi"><span id="2dcc" class="nb jr it mk b gy nc nd l ne nf">REST_FRAMEWORK = {<br/>    "DEFAULT_AUTHENTICATION_CLASSES": [<br/>        "rest_framework.authentication.TokenAuthentication",<br/>        "rest_framework.authentication.SessionAuthentication",<br/>    ],<br/>    "DEFAULT_PERMISSION_CLASSES": [<br/>        "rest_framework.permissions.IsAuthenticated",<br/>        "rest_framework.permissions.DjangoModelPermissions",<br/>    ],<br/>}</span></pre><p id="7875" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我认为这将是对我的应用程序代码的唯一更改，所以我重新运行了开发服务器，希望能够大获全胜。然而，正如在这种情况下经常发生的那样，事情并没有那么简单。</p><p id="da03" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">内置的Django模型权限系统与<code class="fe mh mi mj mk b">rest_framework.views.APIView</code>不兼容，所以我立即遇到了以下错误:</p><p id="f101" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><code class="fe mh mi mj mk b">AssertionError: Cannot apply DjangoModelPermissions on a view that does not set `.queryset` or have a `.get_queryset()` method.</code></p><h1 id="123d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">解决办法</h1><p id="702a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">解决方案是在扫描DRF文档时找到的，原因是为什么会发生这种情况。公平地说，DRF的维护者们确实在<a class="ae lr" href="https://www.django-rest-framework.org/api-guide/permissions/#djangomodelpermissions" rel="noopener ugc nofollow" target="_blank">docs(here)</a>中说得很清楚，在你的视图类中缺少一个<code class="fe mh mi mj mk b">queryset</code>属性将会阻止它决定所需的权限。</p><p id="5ad2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在我的例子中，我在后端基于类的视图中大量使用了<code class="fe mh mi mj mk b">rest_Framework.views.APIView</code>类，它既没有<code class="fe mh mi mj mk b">queryset</code>属性也没有<code class="fe mh mi mj mk b">get_queryset</code>方法。</p><p id="e672" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">根据文件，有一个简单的解决办法:</p><blockquote class="ng nh ni"><p id="7130" class="ko kp nj kq b kr lm kt ku kv ln kx ky nk lo lb lc nl lp lf lg nm lq lj lk ll im bi translated">如果您对使用被覆盖的<code class="fe mh mi mj mk b">get_queryset()</code>方法的视图使用该权限，那么该视图上可能没有<code class="fe mh mi mj mk b">queryset</code>属性。在这种情况下，我们建议也用sentinel queryset标记视图，以便该类可以确定所需的权限。例如:</p><p id="0b6e" class="ko kp nj kq b kr lm kt ku kv ln kx ky nk lo lb lc nl lp lf lg nm lq lj lk ll im bi translated"><code class="fe mh mi mj mk b">queryset = User.objects.none()</code></p></blockquote><p id="827b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然而，由于我们的应用程序有大量的视图，在每个视图中包含这一行会有点麻烦。因此，我们选择如下:</p><p id="1452" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在项目中的某个地方创建一个新文件(在我们的例子中称为<code class="fe mh mi mj mk b">custom_views.py</code>)，并在那里创建一个继承自<code class="fe mh mi mj mk b">rest_Framework.views.APIView</code>的全新视图，但添加了急需的<code class="fe mh mi mj mk b">queryset</code>参数:</p><p id="d31b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> custom_views.py </strong></p><pre class="mm mn mo mp gt mx mk my mz aw na bi"><span id="afc7" class="nb jr it mk b gy nc nd l ne nf">from rest_framework.views import APIView<br/>from django.contrib.auth.models import User<br/><br/><br/>class DjangoGroupCompatibleAPIView(APIView):<br/><br/>    queryset = User.objects.none()</span></pre><p id="41ce" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后，在我的任何<code class="fe mh mi mj mk b">views.py</code>文件中，只需导入这个新视图并进行更改:</p><pre class="mm mn mo mp gt mx mk my mz aw na bi"><span id="b40a" class="nb jr it mk b gy nc nd l ne nf">class GetAccount(APIView):<br/>    def get(self, request):</span></pre><p id="1aed" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">到</p><pre class="mm mn mo mp gt mx mk my mz aw na bi"><span id="b9e6" class="nb jr it mk b gy nc nd l ne nf">class GetAccount(DjangoGroupCompatibleAPIView):<br/>    def get(self, request):</span></pre><p id="ad49" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">嘿，很快！我们现在有Django用户组在整个DRF后台完美地工作！</p><p id="265f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我希望这是有用的，请随时评论如下:)</p><p id="5554" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">斯科特</p></div></div>    
</body>
</html>