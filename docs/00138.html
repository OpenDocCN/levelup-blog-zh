<html>
<head>
<title>Flow vs TypeScript in React — My two cents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的流与打字稿——我的两分钱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flow-vs-typescript-in-react-my-two-cents-d4d0c657d236?source=collection_archive---------0-----------------------#2018-05-18">https://levelup.gitconnected.com/flow-vs-typescript-in-react-my-two-cents-d4d0c657d236?source=collection_archive---------0-----------------------#2018-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a1ce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">打字稿和流的利弊</h2></div><p id="be10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">更新。</strong>写这个故事的时候，巴别塔对TypeScript的支持还没有发布。这极大地改进了React项目中TypeScript的集成。Expo是React本地生态系统中的一个关键元素，它最近宣布将从Flow转向TypeScript(在这里阅读公告<a class="ae lb" href="https://blog.expo.io/expo-for-professionals-218b7937fafb" rel="noopener ugc nofollow" target="_blank"/>)。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lh li l"/></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lj li l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">我现在结合使用林挺的ESlint和类型检查的TypeScript。编译由巴别塔完成。</figcaption></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lj li l"/></div></figure><p id="f875" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一个React项目中应该使用Flow还是TypeScript？我最近对这个问题有点左右为难，我想分享一下我对这个话题的想法。如果您已经在使用Flow或TypeScript，并且对您当前的设置感到满意，那么这篇文章可能是一篇评论，但是也请留下评论来分享您的设置和体验。如果您没有在React项目中使用静态类型检查，请允许我建议您可以通过使用静态类型检查来大幅降低开发成本。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/ff15d6f7ae34d1f8014a60335e63400b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*ulwmJZfctsdMiwO8HRFDKQ.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated"><a class="ae lb" href="https://codeburst.io/strict-types-typescript-flow-javascript-to-be-or-not-to-be-959d2d20c007" rel="noopener" target="_blank">严格类型:打字稿、流、Javascript——生存还是毁灭？</a></figcaption></figure><p id="0fb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flow和TypeScript都是限制JavaScript项目中技术债务的极好方法，允许您满怀信心地发展您的代码库。我总是试图对静态代码分析施加最大的压力。我使用类型作为我的应用程序的不同组件之间的真实的单一来源。每当我被一个bug绊倒时，我都会问自己:“这可能是静态分析发现的吗？”类型安全也是我喜欢React胜过Angular或Vue等其他框架的原因之一。有了JSX，我们有了一个跨越应用程序逻辑、样式和表示的统一类型系统。其他库似乎没有相同级别的类型安全。</p><p id="43b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以JavaScript类型的系统很棒。但是应该使用Flow还是TypeScript呢？</p><h2 id="8c0d" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">进退两难</h2><p id="3a32" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如果您正在构建一个React项目，TypeScript是一个更自然的选择:它与<a class="ae lb" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>和<a class="ae lb" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank">material-ui</a>(React应用程序中UI的一个常用库)具有对TypeScript的一流支持。在React Native中，流动感觉更自然。Expo是用Flow实现的，据我所知<a class="ae lb" href="https://github.com/react-community/create-react-native-app" rel="noopener ugc nofollow" target="_blank">create-react-native-app</a>没有很好的类型脚本支持。</p><p id="c955" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一段时间我用TypeScript写React projects，用Flow写React Native projects，一切都是爱，一切都很好。</p><p id="b783" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而对于一个新的React项目，我考虑使用Flow。这将使我能够在所有代码库中保持一致的代码风格和林挺规则。此外，对React在TypeScript和Flow中的支持变得越来越复杂，最好只在这两种类型系统中的一种中发展强大的专业技能。在这里，我开始为<code class="fe mp mq mr ms b">material-ui</code> <a class="ae lb" href="https://github.com/wcandillon/material-ui-flow" rel="noopener ugc nofollow" target="_blank">开发一个强流类型定义，我真的需要一些帮助🙏🏻。</a></p><p id="fc4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我思考这个问题时整理的清单。</p><h1 id="c635" class="mt ls iq bd lt mu mv mw lw mx my mz lz jw na jx mc jz nb ka mf kc nc kd mi nd bi translated"><strong class="ak">流程:优点&amp;缺点</strong></h1><h2 id="fbf2" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated"><strong class="ak">优点</strong></h2><ul class=""><li id="2b24" class="ne nf iq kh b ki mk kl ml ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir"> Eslint插件</strong>💄:React和React Native的Eslint插件提供了有价值的静态分析，似乎优于它们的tslint插件。</li><li id="5f77" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">使命宣言</strong>💂🏼:TypeScript的最初目标是提供现代JS特性以及静态类型。现在JS已经很好地赶上了现代特性，TypeScript仅仅被认为是一个类型系统，这就是Flow。</li><li id="c16c" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> Premium React支持⚛️:</strong>react的流量支持有三个方面。首先，来自Flow的React类型定义比TypeScript更精确一些。您可以轻松地键入组件子组件。高阶组件的类型支持是无可挑剔的。其次，TypeScript的主要特色是OOP，而Flow的特色是函数性的。React的主要特色是功能性的:组件是通过组合而不是继承构建的，这使得Flow非常适合。最后但同样重要的是，Flow是一个Babel插件，大多数React项目已经将它集成到他们的构建系统中。</li><li id="34c4" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">轻松集成&amp;自动化重构</strong>🤖:由于Flow基于Babel，所以在各种工具链中集成得非常好。我可能永远不需要这么做，这听起来可能有点牵强，但是如果它是基于Babel的，你就能够为你的项目构建自动代码重构。</li></ul><h2 id="5922" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">骗局</h2><ul class=""><li id="c178" class="ne nf iq kh b ki mk kl ml ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir">疯狂的版本改动</strong>😱:从Flow的一个版本到另一个版本的变化有时会让人感到有点不知所措。这可能是由于该项目比TypeScript更新得多……以及来自其母公司的<em class="ns">“快速移动和打破事物”</em>座右铭。</li><li id="8d87" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">未记录的特征</strong>📚:并非流程中的所有公用设施类型都有记录。虽然这个<em class="ns">可能很快就会被修复。</em></li><li id="6fff" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">流程结果检查器</strong>🤨:这个有点大。Flow不提供消除来自<em class="ns"> node_modules </em>的类型错误的能力，这些错误是您无法控制的。默认行为应该报告所有错误，这是有道理的，但是<a class="ae lb" href="https://github.com/facebook/flow/issues/869" rel="noopener ugc nofollow" target="_blank">应该有一个标志来消除它们</a>。有一个非常有用的名为<a class="ae lb" href="https://github.com/jbreckel/flow-result-checker" rel="noopener ugc nofollow" target="_blank"> flow-result-checker </a>的包可以做到这一点，但是它不能用于最新版本的flow，因为它的报告格式已经改变了。</li><li id="00dd" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">隐式any in类型定义</strong>🤦🏻‍:我注意到在编写库定义时，类型导入被隐式地当作any而不是抛出一个错误(如果导入是在模块声明之外完成的)。这有点可怕，因为您可能认为您的代码正在接受类型检查，而实际上并没有。希望库定义是唯一可能发生这种情况的地方。</li></ul><h1 id="3554" class="mt ls iq bd lt mu mv mw lw mx my mz lz jw na jx mc jz nb ka mf kc nc kd mi nd bi translated"><strong class="ak">打字稿</strong>:赞成&amp;反对</h1><h2 id="6eaa" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">赞成的意见</h2><ul class=""><li id="a2ed" class="ne nf iq kh b ki mk kl ml ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir">更大的社区</strong>👨‍👨‍👧‍👧:因为它是一个较老的项目，所以它的社区更大。但这不一定意味着流量就赶不上了。目前，TypeScript库定义的质量比用Flow编写的高一个数量级。在TypeScript中IDE支持似乎更好。就我个人而言，我使用的是Atom IDE，所以这对我来说不是一个因素。</li><li id="2b62" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">比流量快</strong>🏎:在笔记本电脑上工作时，TypeScript比Flow快得多，似乎也没有Flow消耗那么多电池寿命。</li><li id="9f7e" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">前期编译错误</strong>🚨:这可能可以在TypeScript和Flow中进行配置，但是在测试代码时，使用预先编译错误而不是非强制性的类型检查似乎可以节省时间，因为它可以防止您运行伪造的代码。</li></ul><h2 id="b5fa" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">骗局</h2><ul class=""><li id="0f2b" class="ne nf iq kh b ki mk kl ml ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir">较小的React支持</strong> ⚛️: React支持在类型脚本中不如在流中好，尤其是在创建高阶组件时。然而，这种情况将来可能会改变。</li></ul><h2 id="b0f1" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">你对此有什么想法？</h2><p id="25b7" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">你同意这个列表或者有什么建议吗？留言评论！我期待着听到你对此的想法。</p><p id="f738" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要脸的plug:你在找一个高级的React原生入门套件吗？您应该签出React本机元素。</p><div class="nt nu gp gr nv nw"><a href="https://hackernoon.com/react-native-sketch-elements-889f010f9626" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">反应原生草图元素</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">经过两个月的制作，React本地草图元素终于出现了。反应原生元素涵盖了广泛的…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">hackernoon.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok lp nw"/></div></div></a></div></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><figure class="lc ld le lf gt lg gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi os"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="nt nu gp gr nv nw"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">18大TypeScript教程-免费学习TypeScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">gitconnected.com</p></div></div><div class="of l"><div class="ot l oh oi oj of ok lp nw"/></div></div></a></div></div></div>    
</body>
</html>