<html>
<head>
<title>JavaScript Design Patterns — Factory Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式—工厂模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-design-patterns-factory-pattern-dc75cf7fd989?source=collection_archive---------20-----------------------#2020-06-11">https://levelup.gitconnected.com/javascript-design-patterns-factory-pattern-dc75cf7fd989?source=collection_archive---------20-----------------------#2020-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c32f265c26f252bcedf0c1949c18cf2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*06pOCvgyG6fNvbSZ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">莱尼·屈尼在Unsplash上的照片</figcaption></figure><p id="1f48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设计模式是任何好软件的基础。JavaScript程序也不例外。</p><p id="ad40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究工厂和观察者模式。</p><h1 id="18d8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">工厂模式</h1><p id="c370" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">工厂模式是一种设计模式，它允许我们创建新的对象，并以一种干净的方式返回它们。</p><p id="a111" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可能想要返回相似的不同种类的东西。</p><p id="4d27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了方便起见，我们可以创建一个工厂函数，让我们用一个工厂函数返回不同种类的对象。</p><p id="54b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="66a4" class="mq lf it mm b gy mr ms l mt mu">class Fruit {<br/>  //...<br/>}</span><span id="c1f3" class="mq lf it mm b gy mv ms l mt mu">class Apple extends Fruit {<br/>  //...<br/>}</span><span id="52d5" class="mq lf it mm b gy mv ms l mt mu">class Orange extends Fruit {<br/>  //...<br/>}</span><span id="6d54" class="mq lf it mm b gy mv ms l mt mu">const fruitFactory = (type) =&gt; {<br/>  if (type === 'apple') {<br/>    return new Apple()<br/>  } else if (type === 'orange') {<br/>    return new Apple()<br/>  }<br/>}</span></pre><p id="325a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有<code class="fe mw mx my mm b">fruitFactory</code>工厂函数，它获取一个对象的<code class="fe mw mx my mm b">type</code>作为参数，然后根据类型返回一个对象。</p><p id="b16d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有<code class="fe mw mx my mm b">'apple'</code>作为<code class="fe mw mx my mm b">type</code>的值，我们返回一个<code class="fe mw mx my mm b">Apple</code>实例。</p><p id="38c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将<code class="fe mw mx my mm b">type</code>设置为<code class="fe mw mx my mm b">'orange'</code>，我们将返回一个<code class="fe mw mx my mm b">Orange</code>实例。</p><p id="40bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以返回<code class="fe mw mx my mm b">Fruit</code>的不同子类实例，而不用显式地写出它们。</p><p id="e1c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们对类做了任何更改，或者添加或删除了它们，那么我们仍然可以使用相同的工厂函数，不会破坏任何东西。</p><p id="8cb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的一些工厂函数在标准库中。</p><p id="96d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们包括用于创建字符串的<code class="fe mw mx my mm b">String</code>，用于从其他实体创建数字的<code class="fe mw mx my mm b">Number</code>，用于将变量转换为布尔值的<code class="fe mw mx my mm b">Boolean</code>，用于创建数组的<code class="fe mw mx my mm b">Array</code>，等等。</p><p id="7b7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们不必担心类结构的改变会弄乱我们的代码，因为我们使用了一个工厂函数来创建我们的<code class="fe mw mx my mm b">Fruit</code>对象。</p><h1 id="5bd3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">观察者</h1><p id="f6c0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">观察者模式是指多个对象监听一个可观察的对象。</p><p id="f93e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，可观察对象(也称为主体)可以用发出的数据通知订阅可观察对象的对象。</p><p id="580f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d78e" class="mq lf it mm b gy mr ms l mt mu">const observable = {<br/>  observers: {},<br/>  subscribe(obj) {<br/>    const id = Object.keys(this.observers).length + 1;<br/>    this.observers[id] = obj;<br/>    return id;<br/>  },</span><span id="9869" class="mq lf it mm b gy mv ms l mt mu">  notify(data) {<br/>    for (const o of Object.keys(this.observers)) {<br/>      this.observers[o].listen(data);<br/>    }<br/>  }<br/>}</span><span id="6abf" class="mq lf it mm b gy mv ms l mt mu">const observer = {<br/>  listen(data) {<br/>    console.log(data);<br/>  }<br/>}<br/>observable.subscribe(observer);<br/>observable.notify({<br/>  a: 1<br/>});</span></pre><p id="91de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有<code class="fe mw mx my mm b">observable</code>对象，它让观察者对象(有一个<code class="fe mw mx my mm b">listen</code>方法来监听数据)订阅来自<code class="fe mw mx my mm b">observable</code>对象的通知。</p><p id="b2bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们可以像上面那样<code class="fe mw mx my mm b">observable.notify</code>处理某些东西时，observer对象的<code class="fe mw mx my mm b">listen</code>方法就会运行。</p><p id="46c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，交流完全是通过<code class="fe mw mx my mm b">notify</code>方法来完成的，而不是其他地方。</p><p id="9d5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有公开实现，因此没有紧密耦合。</p><p id="d7c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要方法做同样的事情，我们就不必担心破坏订阅<code class="fe mw mx my mm b">observable</code>的观察者对象。</p><p id="91f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以给<code class="fe mw mx my mm b">observable</code>添加一个<code class="fe mw mx my mm b">unsubscribe</code>方法，它使用从<code class="fe mw mx my mm b">subscribe</code>返回的<code class="fe mw mx my mm b">id</code>从<code class="fe mw mx my mm b">observers</code>对象中移除一个观察者对象。</p><p id="43f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6770" class="mq lf it mm b gy mr ms l mt mu">const observable = {<br/>  observers: {},<br/>  subscribe(obj) {<br/>    const id = Object.keys(this.observers).length + 1;<br/>    this.observers[id] = obj;<br/>    return id;<br/>  },</span><span id="1d09" class="mq lf it mm b gy mv ms l mt mu">  notify(data) {<br/>    for (const o of Object.keys(this.observers)) {<br/>      this.observers[o].listen(data);<br/>    }<br/>  },</span><span id="caa5" class="mq lf it mm b gy mv ms l mt mu">  unsubscribe(id) {<br/>    delete this.observers[id];<br/>  }<br/>}</span><span id="e175" class="mq lf it mm b gy mv ms l mt mu">const observer = {<br/>  listen(data) {<br/>    console.log(data);<br/>  }<br/>}<br/>const subscriberId = observable.subscribe(observer);<br/>observable.notify({<br/>  a: 1<br/>});</span><span id="10ad" class="mq lf it mm b gy mv ms l mt mu">observable.unsubscribe(subscriberId);</span></pre><p id="4fe8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加了一个<code class="fe mw mx my mm b">unsubscribe</code>方法，这样我们就可以从<code class="fe mw mx my mm b">this.observers</code>列表中删除观察者对象。</p><p id="d361" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们取消订阅，如果我们再次调用<code class="fe mw mx my mm b">notify</code>,我们将不再收到取消订阅的观察者的通知。</p><p id="952e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">观察者模式的例子在很多地方都有使用。</p><p id="e9f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">observer模式的另一个好处是我们不通过类进行任何交流。</p><p id="e957" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">松耦合应该总是优于紧耦合。</p><p id="d000" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们只通过一个通道进行通信，所以观察者模式是耦合所能达到的最松散的模式。</p><p id="d1bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们包括消息队列和GUI事件(如鼠标点击和按键)的事件处理程序。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/8ec65949399e241e2718bac4c771a697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9OmVsu6Fe8hVIcEu"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安妮·斯普拉特在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5d9f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b1e7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用观察者模式来尽可能地分离对象。</p><p id="92a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所做的就是从一个我们想要改变的可观察物体接收事件。</p><p id="6972" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可观察对象向观察对象发送通知。</p><p id="5899" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">工厂模式允许我们通过创建工厂函数在一个地方创建相似类型的对象。</p></div></div>    
</body>
</html>