<html>
<head>
<title>Node + TypeScript + Mocha + ESLint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node + TypeScript + Mocha + ESLint</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-typescript-mocha-eslint-efad2e3d2943?source=collection_archive---------7-----------------------#2020-12-06">https://levelup.gitconnected.com/node-typescript-mocha-eslint-efad2e3d2943?source=collection_archive---------7-----------------------#2020-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1a74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">使用Node、TypeScript、Mocha和ESLint设置编程项目的指南。</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/ee7840ba6afd998fc577bc2550f0883f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w1nhEIjvCaxprXoj"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated"><a class="ae lf" href="https://unsplash.com/@stanleydai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯坦利戴</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a205" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应该建立编程项目以使开发变得容易。要做到这一点，项目应该具备以下能力。</p><ol class=""><li id="e654" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">在开发过程中观察源文件。</li><li id="8c32" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">在开发过程中观察测试文件。</li><li id="8da5" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">提交时的Lint文件。</li><li id="b227" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">将文件建立到一个<code class="fe lu lv lw lx b">dist</code>文件夹中(并提供给他们)。</li></ol><p id="98db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建立一个项目是主观的，但我希望这能给你一个好的起点。</p><p id="eba3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想跳转到代码，使用我创建的名为<a class="ae lf" href="https://github.com/christo8989/node-typescript-mocha-eslint" rel="noopener ugc nofollow" target="_blank">node-typescript-mocha-eslint</a>的git模板。这不是一个非常原始的名字，但它完成了任务。</p><p id="fcd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:回购中的文件可能会发生变化。检查回购的最新代码。</em></p><h1 id="5fd0" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">安装软件包</h1><p id="4daa" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">当您从模板创建项目时，使用<code class="fe lu lv lw lx b">npm</code>或<code class="fe lu lv lw lx b">yarn</code>来安装这些包。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="3675" class="nf lz it lx b gy ng nh l ni nj">npm install<br/>yarn install</span></pre><p id="f8e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一点上，两者之间的差异可以忽略不计，所以只需选择一个。</p><h1 id="9fe9" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">在开发过程中观察源代码</h1><p id="1ddf" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">在开发过程中，您会希望在保存更改时重新编译程序。为此，启动一个开发服务器，它将在您编码时保持运行。</p><p id="4047" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的命令做了完全相同的事情。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="32eb" class="nf lz it lx b gy ng nh l ni nj">npm start<br/>npm run start:dev</span><span id="0319" class="nf lz it lx b gy nk nh l ni nj">yarn start<br/>yarn start:dev</span></pre><p id="9fd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些命令通过nodemon用名为<code class="fe lu lv lw lx b">.nodemonrc.json</code>的配置文件启动一个节点服务器，从文件<code class="fe lu lv lw lx b">src/index.ts</code>开始。</p><h2 id="8a1e" class="nf lz it bd ma nl nm dn me nn no dp mi kb np nq mm kf nr ns mq kj nt nu mu nv bi translated"><code class="fe lu lv lw lx b">.nodemonrc.json</code></h2><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="6903" class="nf lz it lx b gy ng nh l ni nj">{<br/>  "restartable": "rs",<br/>  "ignore": [".git", "node_modules/", "dist/"],<br/>  "watch": ["src/"],<br/>  "execMap": {<br/>    "ts": "node -r ts-node/register"<br/>  },<br/>  "ext": "js,json,ts"<br/>}</span></pre><p id="df7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">nodemon包使开发服务器在您编码时保持运行。</p><ol class=""><li id="667a" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"restartable": "rs"</code>指定重新启动已经运行的服务器。</li><li id="dc46" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"ignore": [...]</code>查找更改时忽略文件/文件夹列表。</li><li id="3bb5" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"watch": [...]</code>在查找更改时监视文件/文件夹列表。</li><li id="6816" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"execMap": {...}</code>是一个键/值，其中键是文件类型，值是构建这些文件的命令。对我们来说，我们只需要它来传输打字稿文件。</li><li id="c34c" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"ext": "..."</code>是一个逗号分隔的值，标识在查找更改时要监视的文件类型。</li></ol><p id="536e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们更深入地研究TypeScript配置，以便理解<code class="fe lu lv lw lx b">execMap</code>在做什么。</p><h2 id="3661" class="nf lz it bd ma nl nm dn me nn no dp mi kb np nq mm kf nr ns mq kj nt nu mu nv bi translated">tsconfig.json</h2><p id="aea9" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">一般来说，默认配置将带您去您需要去的地方。然而，我已经修改了这个文件，以便能够用es5语法导入模块。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="3975" class="nf lz it lx b gy ng nh l ni nj">import { hello } from '~/hello'</span></pre><p id="6a59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，这些选项中的大多数都支持该语法。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="a246" class="nf lz it lx b gy ng nh l ni nj">{<br/>  "ts-node": {<br/>    "compiler": "ttypescript"<br/>  },<br/>  "compilerOptions": {<br/>    "target": "es5",<br/>    "module": "commonjs",<br/>    "outDir": "./dist",<br/>    "baseUrl": "./src",<br/>    "paths": {<br/>      "~/*": ["*"]<br/>    }, <br/>    "plugins": [<br/>      { "transform": "typescript-transform-paths" }<br/>    ],<br/>  }<br/>}</span></pre><ol class=""><li id="522a" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">使用<code class="fe lu lv lw lx b">ts-node</code>时，<code class="fe lu lv lw lx b">"compiler": "ttypescript"</code>将使用<code class="fe lu lv lw lx b">ttsc</code>而不是<code class="fe lu lv lw lx b">tsc</code>来传输打字稿文件。</li><li id="740e" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"target": "es5"</code>是要转换的javascript版本。</li><li id="e57f" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"module": "commonjs"</code>是进口到transpile的款式。</li><li id="31b0" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">是文件传输到的目录。</li><li id="4142" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"baseUrl": "./src"</code>是项目的文件夹，将被识别为传输的根文件夹。</li><li id="384d" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"paths": {...}</code>允许您指定映射到项目中文件夹/文件的特殊路径。这些路径相对于baseUrl。</li><li id="d7f7" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"plugins": {...}</code>定义你想要包含的插件，以帮助转换代码。</li></ol><p id="ab2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让<code class="fe lu lv lw lx b">typescript-transform-paths</code>工作，我们必须使用<code class="fe lu lv lw lx b">ttsc</code>来传输类型脚本文件。这就是为什么<code class="fe lu lv lw lx b">ts-node</code>被配置为使用<code class="fe lu lv lw lx b">ttsc</code>作为编译器。</p><p id="3e76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">插件<code class="fe lu lv lw lx b">typescript-transform-paths</code>执行下面的转换。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="b4db" class="nf lz it lx b gy ng nh l ni nj">import { hello } from "~/hello"</span><span id="b55a" class="nf lz it lx b gy nk nh l ni nj">// will transpile to</span><span id="002a" class="nf lz it lx b gy nk nh l ni nj">var hello_1 = require("./hello");</span></pre><p id="fbff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe lu lv lw lx b">tsconfig.json</code>文件有更多的选项。如果你想深入研究，我推荐你去探索文档。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="842b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你已经做到这一步，我们已经涵盖了大部分的设置。其他一切都建立在这个基础之上。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="78ff" class="ly lz it bd ma mb od md me mf oe mh mi mj of ml mm mn og mp mq mr oh mt mu mv bi translated">在开发过程中观察测试</h1><p id="9626" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">当您进行更改时，测试命令将运行并重新运行测试。这有助于我们毫无争议地根据测试进行编码。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="ff6e" class="nf lz it lx b gy ng nh l ni nj">npm test<br/>yarn test</span><span id="a68f" class="nf lz it lx b gy nk nh l ni nj">// Alternative<br/>npm test -- --watch=false<br/>yarn test --watch=false</span></pre><p id="9c4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我很失望mocha不能在不添加更多脚本的情况下测试单个文件；本来想写一个类似 <code class="fe lu lv lw lx b"><em class="ko">npm test src/index.test.ts</em></code> <em class="ko">的命令。我还发现它不用</em> <code class="fe lu lv lw lx b"><em class="ko">fdescribe</em></code> <em class="ko">。有其他方法可以用Mocha测试一个文件，但是我推荐使用Jest或者其他测试包。我们还是继续吧。</em></p><h2 id="0138" class="nf lz it bd ma nl nm dn me nn no dp mi kb np nq mm kf nr ns mq kj nt nu mu nv bi translated">. mocharc.json</h2><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="0629" class="nf lz it lx b gy ng nh l ni nj">{<br/>  "require": ["ts-node/register"],<br/>  "watch-files": ["./src/**/*.ts"]<br/>}</span></pre><ol class=""><li id="02cf" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"require": ["ts-node/register"]</code>将使用ts-node传输测试代码。</li><li id="2f56" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"watch-files": [...]</code>是一个文件夹/文件的列表，在我们编码时要注意其中的变化。我们希望观察测试和代码的变化。</li></ol><h1 id="8a49" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">提交并推动变更</h1><p id="702e" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">我在这个模板中添加了eslint、husky和lint-staged，因为林挺是保持代码整洁和捕捉简单的恶魔错误的最简单的方法之一。</p><h2 id="6431" class="nf lz it bd ma nl nm dn me nn no dp mi kb np nq mm kf nr ns mq kj nt nu mu nv bi translated">. eslintrc.json</h2><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="e2cb" class="nf lz it lx b gy ng nh l ni nj">{<br/>  "env": {<br/>    "node": true,<br/>    "es2021": true<br/>  },<br/>  "extends": [<br/>    "eslint:recommended",<br/>    "plugin:@typescript-eslint/recommended"<br/>  ],<br/>  "parser": "@typescript-eslint/parser",<br/>  "parserOptions": {<br/>    "ecmaVersion": 12,<br/>    "sourceType": "module"<br/>  },<br/>  "plugins": [<br/>    "@typescript-eslint"<br/>  ],<br/>  "rules": {<br/>    "comma-dangle": ["error", "always-multiline"],<br/>    "indent": ["error", 2],<br/>    "linebreak-style": ["error", "windows"],<br/>    "quotes": ["error", "single"],<br/>    "semi": ["error", "always"]<br/>  }<br/>}</span></pre><ol class=""><li id="1779" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"env": {...}</code>是棉绒识别的环境列表。这些环境并不相互排斥，因此鼓励使用多个值。</li><li id="4d1a" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"extends": [...]</code>将导入指定的配置。</li><li id="f5d5" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"parser": "@typescript-eslint/parser"</code>指定使用什么解析器。</li><li id="2762" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"parserOptions": {...}</code>指定解析器的选项。</li><li id="871a" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"plugins": [...]</code>指定要使用的插件。</li><li id="5ad6" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"rules": {...}</code>是规则列表。我建议研究所有的规则来个性化你的编码风格。</li></ol><p id="6396" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">值得注意的是，tslint已被弃用。所以即使我们有一个TypeScript项目，你也会想使用eslint。</em></p><p id="37f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，您可以手动lint代码。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="fd39" class="nf lz it lx b gy ng nh l ni nj">npm run lint<br/>yarn lint</span><span id="20a5" class="nf lz it lx b gy nk nh l ni nj">// Alternatives<br/>npm run lint -- --fix=false<br/>yarn lint --fix=false</span></pre><p id="5a7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是为了修复代码，并对无法修复的代码给出警告或错误。</p><p id="8c9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种方法是禁用修复，这在拉式请求批准步骤中很有用。</p><p id="6d5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，当您提交代码时，lint将自动运行。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="dcd0" class="nf lz it lx b gy ng nh l ni nj">"husky": {<br/>  "hooks": {<br/>    "pre-commit": "lint-staged",<br/>    "post-commit": "git update-index --again"<br/>  }<br/>},<br/>"lint-staged": {<br/>  "*.ts": [<br/>    "eslint --fix",<br/>    "git add"<br/>  ]<br/>}</span></pre><p id="4afb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在提交<code class="fe lu lv lw lx b">"pre-commit"</code>之前，如果没有错误，linter将修复所有文件，然后运行<code class="fe lu lv lw lx b">git add</code>。</p><p id="5670" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后提交发生，因为这是我们执行的命令。</p><p id="90c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后<code class="fe lu lv lw lx b">"post-commit"</code>运行。这件东西可能不需要，但我把它留着以防万一。似乎有一个问题可以阻止<code class="fe lu lv lw lx b">git add</code>发生。点击阅读更多相关信息。</p><h1 id="c019" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">为生产构建项目</h1><p id="e4d7" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">构建命令将删除<code class="fe lu lv lw lx b">./dist</code>文件夹(tsconfig的outDir ),并使用<code class="fe lu lv lw lx b">ttypescript</code>或<code class="fe lu lv lw lx b">ttsc</code>运行构建。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="ad3b" class="nf lz it lx b gy ng nh l ni nj">npm run build<br/>yarn build</span></pre><p id="e382" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">生产构建使用生产tsconfig文件。这允许我们从产品构建中排除测试文件。</p><h2 id="75fb" class="nf lz it bd ma nl nm dn me nn no dp mi kb np nq mm kf nr ns mq kj nt nu mu nv bi translated">tsconfig.prod.json</h2><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="727c" class="nf lz it lx b gy ng nh l ni nj">{<br/>  "extends": "./tsconfig.json",<br/>  "exclude": ["src/**/*.test.ts"]<br/>}</span></pre><ol class=""><li id="41d2" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"extends": "./tsconfig.json"</code>将从<code class="fe lu lv lw lx b">tsconfig.json</code>文件导入配置。</li><li id="7662" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><code class="fe lu lv lw lx b">"exclude": [...]</code>是要从构建中排除的文件夹/文件列表。</li></ol><h1 id="75a7" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">运行生产版本</h1><p id="d667" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">构建生产环境后，我们可以使用以下命令运行生产服务器。</p><p id="3b76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果代码不是首先用build命令构建的，这将不起作用。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="0ab9" class="nf lz it lx b gy ng nh l ni nj">npm run start:prod<br/>yarn start:prod</span></pre><p id="7e5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个单独的命令来运行开发服务器和生产服务器，因为这些服务器有不同的要求。通常，您将在开发中使用nodemon，在生产中使用node(最好使用Docker + Kubernetes之类的工具)。</p><h1 id="3be9" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">这些脚本都是从哪里来的？</h1><p id="049c" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">如果你没有听说过npm，那么你能走到这一步是一个惊喜。</p><p id="6eda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不熟悉<code class="fe lu lv lw lx b">package.json</code>文件，那么我建议您看看脚本部分。</p><p id="706f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，这一节列出了上面所有的命令和执行的底层脚本。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="5d35" class="nf lz it lx b gy ng nh l ni nj">"scripts": {<br/>  "start": "npm run start:dev", // or "yarn start:dev"<br/>  "test": "mocha --config .mocharc.json --watch src/**/*.test.ts",<br/>  "lint": "eslint src/**/*.ts --fix",<br/>  "build": "rimraf dist &amp;&amp; ttsc --build tsconfig.prod.json",<br/>  "start:dev": "nodemon --config .nodemonrc.json src/index.ts",<br/>  "start:prod": "node dist/index.js"<br/>}</span></pre><p id="b626" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">脚本部分就是为什么我们可以编写像<code class="fe lu lv lw lx b">npm start</code>这样的命令来启动整个开发服务器。否则，我们将不得不写出执行的实际命令，<code class="fe lu lv lw lx b">nodemon --config .nodemonrc.json src/index.ts</code>，这很麻烦。</p><p id="1c6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，<code class="fe lu lv lw lx b">package.json</code>命令可以运行其他<code class="fe lu lv lw lx b">package.json</code>命令。</p><pre class="kq kr ks kt gt nb lx nc nd aw ne bi"><span id="6472" class="nf lz it lx b gy ng nh l ni nj">. npm start<br/>|<br/>v<br/>. npm run start:dev<br/>|<br/>v<br/>. nodemon --config .nodemonrc.json src/index.ts</span></pre><h1 id="873e" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">结论</h1><p id="d06a" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">希望能够更容易地识别和修复脚本问题，并升级脚本以改善您的开发体验。有几个变化可以改善这个设置。</p><p id="1b8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管我不需要Babel来完成这个设置，但我很好奇它是否会让设置变得更容易，或者是否会让transpilation更快。</p><p id="899f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二，我不喜欢摩卡的设置，所以我想换出那个库；可能是开玩笑。</p><p id="8270" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，如果您不知道配置难题的每一部分，那也没关系。请随意派生、使用、修改<a class="ae lf" href="https://github.com/christo8989/node-typescript-mocha-eslint" rel="noopener ugc nofollow" target="_blank">node-typescript-mocha-eslint</a>模板来改善您的开发体验。</p></div></div>    
</body>
</html>