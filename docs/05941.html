<html>
<head>
<title>SwiftUI: Minesweeper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:扫雷</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/swiftui-minesweeper-cd145f888343?source=collection_archive---------10-----------------------#2020-10-13">https://levelup.gitconnected.com/swiftui-minesweeper-cd145f888343?source=collection_archive---------10-----------------------#2020-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="25c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个没有人知道怎么玩的游戏的超级基本实现</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1ecb26cc8f21ef82125cbd80d60b9500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8pN9U0JuohECNPhB"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">洛伦佐·埃雷拉在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="863a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们将在本教程中创建的内容</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lm ln l"/></div></figure><h1 id="9f00" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">入门指南</h1><p id="1fd8" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">在Xcode中创建新的SwiftUI项目。请确定您正在运行macOS Catalina(或更高版本)并安装了Xcode 11(或更高版本)。(这允许您使用SwiftUI。)</p><p id="5b4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开Xcode →文件→新建→项目</p><p id="f6d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我把我的叫做扫雷舰，但是随便你怎么叫。</p><p id="9b2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保将用户界面设置为SwiftUI。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mr"><img src="../Images/bddcf7502c72f80e21b85f667122bbbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brkniUjPlFHSJ0t8yAT_0w.png"/></div></div></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="77ee" class="lo lp it bd lq lr ms lt lu lv mt lx ly lz mu mb mc md mv mf mg mh mw mj mk ml bi translated">履行</h1><p id="18d8" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">至于图片，它们都来自commons.wikimedia.org。这些图片也可以在我的github repo中找到。</p><p id="12c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从定义游戏如何运行的要求开始。</p><p id="9365" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想说明我们的网格有多大，炸弹的数量，然后根据这些信息和用户设备的大小计算每个单元的大小。</p><p id="0223" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">右键点击顶层文件夹(扫雷)→ <strong class="js iu">新建组</strong>，命名为‘模型’。</p><p id="67f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">右键单击新创建的模型文件夹，创建一个新的Swift文件，并将其命名为<code class="fe mx my mz na b">GameSettings.swift</code></p><p id="d3f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个文件将包含上面提到的游戏设置。It <strong class="js iu"> <em class="nb">可以用于通过UI设置该信息，但是为了本教程的缘故，我们将把它保留为默认值。</em></strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="fa2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码记录了我们应用程序的所有设置。</p><p id="21ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里没有使用<code class="fe mx my mz na b">@Published</code>的真正原因。如果我们想将这些设置添加到UI中，并让它自动更新UI，那么它是必需的。(我把它留在这里，以防有人想对此进行扩展)。</p><p id="ef76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的下一个设计决定是创建一个<code class="fe mx my mz na b">Game.swift</code>类。这个类将保存我们所有的游戏逻辑。</p><p id="b82f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们现在创建该文件。右键单击模型，创建一个新的Swift文件，并将其命名为<code class="fe mx my mz na b">Game.swift</code>。</p><p id="bb6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将以下代码添加到新创建的文件中。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="79b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们所做的只是添加了一个继承自<code class="fe mx my mz na b">ObservableObject</code>的游戏类。这将允许这个类本质上“发布”UI可以“监听”并自动更新的更改。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="f961" class="nd lp it bd lq ne nf dn lu ng nh dp ly kb ni nj mc kf nk nl mg kj nm nn mk no bi translated">清注意</h2><p id="0683" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">在撰写本文时，SwiftUI不处理带有<code class="fe mx my mz na b">@Published</code>的嵌套对象。你可能会想，如果<code class="fe mx my mz na b">GameSettings</code>类中的某些东西发生了变化，它会发布更新，然后这个类Game会观察并发布这些变化。<em class="nb">不幸的是，情况并非如此，我将在后面谈到这一点。。</em></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="f56f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">棋盘中的每个方格本质上都是它的一个单元格，并且会有一个相应的单元格视图。</p><p id="f321" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从创建Cell类开始，然后继续到CellView。</p><p id="cbd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在模型文件夹中创建一个新的Swift文件，命名为<code class="fe mx my mz na b">Cell.swift</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="f87a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常简单，我们的<code class="fe mx my mz na b">Cell</code>将知道它在其他单元格的网格中的位置，保持一个<code class="fe mx my mz na b">Status</code>，它是否被打开(触摸)以及用户是否标记了该单元格。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="cc99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我放在它自己的名为<code class="fe mx my mz na b">Cell+Status.swift</code>的文件中的状态代码</p><p id="e3b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“状态”仅仅是它是否是空的，是否暴露在接触的炸弹中(用<code class="fe mx my mz na b">case exposed(Int)</code>表示)，或者是一个炸弹单元。</p><p id="688e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们转到<code class="fe mx my mz na b">CellView.swift</code>文件。这将是一个新的视图文件，并将包含我们的单元格。</p><p id="4e36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建新的SwiftUI视图，并将其命名为<code class="fe mx my mz na b">CellView.swift</code></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="f5c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的单元格视图将可以访问游戏的<code class="fe mx my mz na b">EnvironmentObject</code>,并且有一个单元格将被传入。</p><p id="7cf9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是一个基础水平的图像，将基于用户屏幕的宽度和我们游戏中的列数。</p><p id="5345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，返回到<code class="fe mx my mz na b">Cell.swift</code>并添加这个属性，根据单元格状态计算我们的图像。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="aeac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们根据单元的不同状态和标志来计算图像。</p><p id="dd31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是SwiftUI画布现在的样子</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f8217fa45cccb75bda1c91d45ef87fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*qG7Mn6lwH3HSTa5qlWpOHg.png"/></div></figure><p id="f09f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们实际创建我们的董事会！</p><p id="9880" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的Views文件夹下创建一个新的SwiftUI视图，并将其命名为<code class="fe mx my mz na b">BoardView.swift</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="f5c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只需循环我们的<code class="fe mx my mz na b">numberOfRows</code>和<code class="fe mx my mz na b">numberOfColumns</code>并创建一个<code class="fe mx my mz na b">VStack</code>和<code class="fe mx my mz na b">HStack</code>来获得类似网格的视图。</p><p id="adee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的画布现在应该看起来像这样</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f1896c067d4de91aefab7cef76cd28dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*OPEZwxjMs8yZuw25k8I6yg.png"/></div></figure><p id="d1a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要构建我们的板，并用我们的板替换我们刚刚添加的内容，而不是在我们的嵌套循环中构建一个新的单元格。</p><p id="6217" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该板将被制作并存在于我们的游戏类中。用户界面将根据该板进行更新。</p><p id="7afc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe mx my mz na b">Game.swift</code>并添加以下代码来生成我们的电路板并随机放置炸弹。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="a076" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们正在构建我们的电路板，并根据在<code class="fe mx my mz na b">GameSettings</code>中声明的炸弹数量随机放置炸弹</p><p id="c801" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，回到<code class="fe mx my mz na b">BoardView.swift</code>，我们想要显示我们游戏文件中的棋盘，而不是我们在UI中构建的。</p><p id="c1b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进行以下更改:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="bd11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将ForEach替换为board size，并将boards单元格传入CellView。</p><p id="fcf9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一点上，UI没有太大的变化。然而，一些细胞现在是“下面”的炸弹。</p><p id="5f27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们实现点击行和切换状态。</p><p id="33e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开<code class="fe mx my mz na b">Game.swift</code>，添加如下公共函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="b974" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们检查牢房是不是炸弹，如果是，我们就打开它。否则，我们打开它并将暴露的计数设置为0。(这个案子我们以后再处理)。</p><p id="1b1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们必须使用<code class="fe mx my mz na b">self.objectWillChange.send()</code>，因为我们正在更新一个<em class="nb">嵌套的</em>对象。我们希望我们的UI基于那些发布的更改进行更新，所以我们通知我们的类已经更改。</p><p id="c185" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe mx my mz na b">CellView.swift</code>,在单元格中添加下面的点击手势。</p><pre class="kp kq kr ks gt nr na ns nt aw nu bi"><span id="3950" class="nd lp it na b gy nv nw l nx ny">.onTapGesture {<br/>    game.click(on: cell)<br/>}</span></pre><p id="ba66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将使用提供的单元格调用我们的<code class="fe mx my mz na b">Game.swift </code>中的click函数。</p><p id="6ff4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，您可能无法运行您的程序，因为我们还没有更新项目中的<code class="fe mx my mz na b">@main</code>。</p><p id="e702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开<code class="fe mx my mz na b">MinesweeperApp.swift</code>并进行以下更改</p><pre class="kp kq kr ks gt nr na ns nt aw nu bi"><span id="19b9" class="nd lp it na b gy nv nw l nx ny">@main<br/>struct MinesweeperApp: App {<br/>    var gameSettings = GameSettings() // our game settings<br/><br/>    var body: some Scene {<br/>        WindowGroup {<br/>            BoardView() // our new ContentView<br/>                .environmentObject(Game(from: gameSettings))<br/>        }<br/>    }<br/>}</span></pre><p id="c2da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在我们启动应用程序时更新我们的视图。</p><p id="c66a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续构建并运行，您现在应该会看到如下所示的内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="85b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！现在，让我们来揭示所有的空单元格，以及找到暴露的计数(又名，接触给定单元格的炸弹数量)。</p><p id="7cda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe mx my mz na b">Game.swift</code>，让我们添加另一个私有函数，它将计算有多少炸弹接触到我们刚刚点击的单元格。</p><p id="1856" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加以下代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="0843" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要改变现在使用我们的<code class="fe mx my mz na b">getExposedCount</code>功能的点击功能。</p><p id="7e53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们简单地从单元格的左上角开始，向下到右下角，循环遍历以确定有多少炸弹在它的附近。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/94000d838caa1318dfec37bb3d3dad09.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*9lok52yPz5N5A34a-VEQpw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">红圈是点击。我们从左上角开始，遍历到右下角</figcaption></figure><p id="52b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你点击相邻炸弹的单元格时，应该会看到这样的内容:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/6dfe3775e147c91be79bf94e686e758c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qqx3CerNAclTHpvilBFLTQ.png"/></div></div></figure><p id="e6af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在要做的最后一件事是，当点击的单元格本身为空时，显示所有的空单元格。</p><p id="0c4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加显示功能，并再次更新<code class="fe mx my mz na b">click</code>功能。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc ln l"/></div></figure><p id="7922" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用递归来访问相邻的单元格，直到这些单元格的暴露计数大于1，它被标记，已经打开，或者是一个炸弹。</p><p id="1450" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建并运行，你应该看到当你找到一个空的单元格时，所有相邻的空单元格都打开了！</p><p id="3eef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们要做的最后一件事就是标记一个单元格。</p><p id="a77d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仍然在<code class="fe mx my mz na b">Game.swift</code>中，添加以下功能来切换标志状态</p><pre class="kp kq kr ks gt nr na ns nt aw nu bi"><span id="06a9" class="nd lp it na b gy nv nw l nx ny">func toggleFlag(on cell: Cell) {<br/>    guard !cell.isOpened else {<br/>        return<br/>    }<br/><br/>    cell.isFlagged = !cell.isFlagged<br/><br/>    self.objectWillChange.send()<br/>}</span></pre><p id="a2ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们更新单元格标记状态，并通知UI我们想要发布这些更改(同样，因为单元格是嵌套的可观察对象，即使单元格已经更改，我们的UI也不会更新)。</p><p id="3b53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe mx my mz na b">CellView.swift</code>，在我们的<code class="fe mx my mz na b">tapGesture</code>下面添加这个<code class="fe mx my mz na b">onLongPressGesture</code></p><pre class="kp kq kr ks gt nr na ns nt aw nu bi"><span id="446c" class="nd lp it na b gy nv nw l nx ny">.onLongPressGesture {<br/>    game.toggleFlag(on: cell)<br/>}</span></pre><p id="9cf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建立和运行，并尝试长时间按下一个细胞？该标志应该显示为刚刚标记的单元格！</p><h1 id="ee3f" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">就是这样！</h1><p id="115a" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">希望你喜欢学习SwiftUI，用最少的代码构建UI并随着<code class="fe mx my mz na b">@ObservableObject</code>的变化自动更新是多么容易！</p><p id="4339" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是完整的源代码:</p><div class="ob oc gp gr od oe"><a href="https://github.com/bbaars/SwiftUI-Minesweeper" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">bbaars/swift ui-扫雷舰</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">SwiftUI中扫雷的超级基本实现dissolve GitHub是超过5000万开发者的家园…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os ky oe"/></div></div></a></div></div></div>    
</body>
</html>