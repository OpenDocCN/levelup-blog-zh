<html>
<head>
<title>TypeScript and Mocha Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿和摩卡挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-and-mocha-hooks-c5d9ccffd58f?source=collection_archive---------8-----------------------#2021-09-20">https://levelup.gitconnected.com/typescript-and-mocha-hooks-c5d9ccffd58f?source=collection_archive---------8-----------------------#2021-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6fc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一名软件开发人员，我一直确保测试架构的维护。作为一个原则，我相信测试应该表现出与产品代码同等的质量。现在，我们如何用TypeScript实现这一点呢？</p><p id="284a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我看来，我们首先需要选择一个合适的测试框架。我发现Mocha有很好的效果——它足够灵活，可以帮助我们利用其他库。尽管它很简单，但它支持构建一个非常适合TypeScript项目的可靠的测试架构——全部通过使用钩子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c7f9e55a538153d20286b78a8313dd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gZV2Ga6XrX5LuUnS"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">杰米·马托西诺斯在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="77ec" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摩卡挂钩</h1><p id="cd82" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Mocha提供了4种类型的挂钩:<br/> * <code class="fe mi mj mk ml b">beforeEach</code>(特定块中的每个特定测试执行之前)、<br/> * <code class="fe mi mj mk ml b">beforeAll</code>(特定块中的所有测试执行之前)、<br/> * <code class="fe mi mj mk ml b">afterEach</code>(特定块中的每个特定测试执行之后)、<br/> * <code class="fe mi mj mk ml b">afterAll</code>(特定块中的所有测试执行之后)。</p><p id="e330" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我故意用了“特别”这个词，因为摩卡允许我们在任何有意义的层面上建立挂钩。正如您可能已经发现的，测试架构是相当全局的构造——我们打算在全局级别上设置钩子。为了实现这一点，我们需要更深入地挖掘测试配置。</p><h2 id="9c18" class="mm lg it bd lh mn mo dn ll mp mq dp lp kb mr ms lt kf mt mu lx kj mv mw mb mx bi translated">根摩卡钩</h2><p id="bf0c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">根Mocha挂钩适用于整个测试设置中的所有测试。你如何使用它们必然是你的决定——然而，我想给你我的想法清单。在我的测试中，我倾向于严重依赖这些钩子的正确配置，这为编写测试的人减轻了许多工作。</p><h2 id="f8c4" class="mm lg it bd lh mn mo dn ll mp mq dp lp kb mr ms lt kf mt mu lx kj mv mw mb mx bi translated">摩卡语境</h2><p id="a246" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Mocha上下文是可用于访问每个测试的可变对象。我对Mocha测试架构的想法是让每个测试都有相同的上下文，并且只使用根Mocha钩子来改变它。它保证了每个测试的简单性、有序性和可预测的行为。</p><p id="4078" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于<code class="fe mi mj mk ml b">Mocha.Context</code>是一个类(不是一个可扩展的接口)，我们应该定义两种类型——为我们管理的属性定义<code class="fe mi mj mk ml b">InjectableContext</code>，为作为上下文一部分的所有属性定义<code class="fe mi mj mk ml b">TestContext</code>。<code class="fe mi mj mk ml b">TestContext</code>将是测试使用的类型。下面的一个简单片段应该可以澄清这个概念:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">InjectableContext和TestContext的定义</figcaption></figure><p id="9f4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想知道为什么我在上面的代码片段中使用了<code class="fe mi mj mk ml b">Readonly</code>类型，您可以阅读我发表在the Level Up Coding出版物上的关于TypeScript中的不变性的文章:</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/the-complete-guide-to-immutability-in-typescript-99154f859fdb"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">TypeScript中不变性的完全指南</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">如何使用函数式编程理论、只读修饰符和经过良好测试的实践来将不变性应用于</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ky nd"/></div></div></a></div><h2 id="134d" class="mm lg it bd lh mn mo dn ll mp mq dp lp kb mr ms lt kf mt mu lx kj mv mw mb mx bi translated">在所有挂钩之前</h2><p id="b091" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们可以使用这个钩子来设置所有被测试直接或间接使用的系统组件。我总是推荐使用依赖注入来最小化模仿、间谍和存根的数量。我们可以通过将系统组件放在Mocha环境中，将它们暴露给所有的测试。</p><p id="9187" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于系统组件，我理解如下(列表不完整):<br/> *模拟数据库、<br/> *模拟服务器、<br/> *模拟消息系统、<br/> *共享服务、<br/> *控制器、<br/> *有用的助手功能。</p><p id="75a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有大量的测试并使用并行化，请注意Mocha将为每个测试文件执行Before All钩子。</p><h2 id="e0c7" class="mm lg it bd lh mn mo dn ll mp mq dp lp kb mr ms lt kf mt mu lx kj mv mw mb mx bi translated">每次挂钩前</h2><p id="b3bd" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我想我们可以使用这个钩子来设置Mocha上下文中的属性，这些属性不是作为Before All钩子的一部分来设置的。也可以设置一些结构的初始状态，比如计数器或者间谍。“每个挂钩之前”与“每个挂钩之后”协同工作。</p><h2 id="19c1" class="mm lg it bd lh mn mo dn ll mp mq dp lp kb mr ms lt kf mt mu lx kj mv mw mb mx bi translated">毕竟钩</h2><p id="8e62" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们作为Before All钩子的一部分初始化的所有东西，我们必须作为After Each钩子的一部分拆除。为了让Mocha完成并产生任何结果，需要释放所有悬空资源。在并行测试执行的情况下，Mocha将为每个测试文件执行这个钩子。</p><h2 id="7a2a" class="mm lg it bd lh mn mo dn ll mp mq dp lp kb mr ms lt kf mt mu lx kj mv mw mb mx bi translated">每次上钩后</h2><p id="063e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如前所述，After Each钩子与Before Each钩子协同工作。这意味着，如果某个复位指令被放在其中一个钩子中，我们很可能不需要把它放在另一个钩子中。例如，如果我们在每个钩子之前把一个计数器重置为零，我们就不必在每个钩子之后做同样的事情。</p><h1 id="6de3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置</h1><p id="acf2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">既然我已经解释了这个理论，我们应该尝试在TypeScript项目中设置根Mocha挂钩。假设Mocha配置存储在主应用程序目录中的<code class="fe mi mj mk ml b">.mocharc.yml</code>文件中，我们需要键入以下内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c49b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这通知Mocha我们想要注册一个类型脚本加载器(使用<code class="fe mi mj mk ml b">ts-node</code>库),并且我们需要测试框架来执行<code class="fe mi mj mk ml b">test/rootMochaHooks.ts</code>文件。顾名思义，这个文件将包含Rook Mocha钩子。</p><p id="5805" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该文件的最基本结构如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">根摩卡钩的示例性定义</figcaption></figure><p id="7709" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该文件需要导出一个名为<code class="fe mi mj mk ml b">mochaHooks</code>的函数，该函数返回该类型的<code class="fe mi mj mk ml b">Mocha.RootHookObject</code>或<code class="fe mi mj mk ml b">Promise</code>。定义为返回值一部分的所有函数也可以是异步的。明眼人可以看出，<code class="fe mi mj mk ml b">beforeAll</code>函数接受<code class="fe mi mj mk ml b">Mocha.Context</code>类型的<code class="fe mi mj mk ml b">this</code>，但是所有其他函数已经以先前定义的<code class="fe mi mj mk ml b">TestContext</code>的形式从<code class="fe mi mj mk ml b">InjectableContext</code>获取数据。</p><p id="edd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理论上，我们已经可以在<code class="fe mi mj mk ml b">mochaHooks</code>函数的主体中初始化一些系统组件。重要的是我们正确地填充了<code class="fe mi mj mk ml b">InjectableContext</code>——这正是我在代码中明确定义它的原因。如果您想知道<code class="fe mi mj mk ml b">Object.assign(this, context);</code>是否是一个正确的赋值——是的，这是一个不寻常的用法，但是它执行得很好。</p><h2 id="709b" class="mm lg it bd lh mn mo dn ll mp mq dp lp kb mr ms lt kf mt mu lx kj mv mw mb mx bi translated">我们如何在测试中使用它？</h2><p id="8b9a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">根据定义，每个测试都可以直接访问<code class="fe mi mj mk ml b">TestContext</code>，它可以通过以下方式访问:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="83b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，匿名函数不能成为箭头函数，否则它将失去对<code class="fe mi mj mk ml b">this</code>对象的访问。</p><h1 id="7da7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="0da5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">由于Mocha使用行为驱动开发设计模式，我们需要相应地构建我们的代码以适应它。多亏了(Root) Mocha钩子，我们可以毫不费力地进行装配，获得可维护的测试架构和类型安全性。如果你有问题，请在评论区留言！</p></div></div>    
</body>
</html>