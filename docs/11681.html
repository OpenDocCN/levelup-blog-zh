<html>
<head>
<title>GraphQL As A Migration Strategy For REST APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL作为REST APIs的迁移策略</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-as-a-migration-strategy-for-rest-apis-d847ef357cdb?source=collection_archive---------13-----------------------#2022-04-05">https://levelup.gitconnected.com/graphql-as-a-migration-strategy-for-rest-apis-d847ef357cdb?source=collection_archive---------13-----------------------#2022-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="33f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像SOAP和REST这样的传统API架构已经驱动web很长时间了。但是在过去的五年中，使用GraphQL，API协议开始向更灵活和前端驱动的方法转变。在StepZen，我们相信这是一个重要的变化，它将在很长一段时间内决定我们通过API处理数据的方式。但是从像REST这样的传统API架构转移到GraphQL是一个挑战。不仅您的团队需要适应GraphQL，而且这也意味着您可能会失去对当前API架构的投资。</p><p id="0605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，您可以使用StepZen创建一条从REST到GraphQL的清晰的迁移路径。将GraphQL添加到堆栈中的好处是，您仍然可以利用所有当前的API。在本文中，我将展示如何在迁移到GraphQL时使用现有的REST API端点。</p><h1 id="44c4" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">将REST API端点映射到GraphQL</h1><p id="a12e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">REST APIs传统上要求您为每个实体请求数据。如果您有一个电子商务API，并且想要检索一个特定的产品，这个产品的数据来自一个名为<code class="fe lo lp lq lr b">/API/products/[id]</code>的端点。该端点的数据可能来自同名的数据库表。</p><p id="3b1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果您还想获得该产品的评级，并且数据是不同的数据库表，则应该从另一个端点请求评级。因为REST APIs有这种基于实体的方法，所以地址将在端点<code class="fe lo lp lq lr b">/API/products/[id]/rating</code>可用。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/f13ba930a616a322ba39d7ac40fdfb2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pnz5l7gpm36vPIqq.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">将数据库表映射到REST端点</figcaption></figure><p id="e6b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当迁移到GraphQL时，您可以利用这种基于实体的设置。您可以将每个REST API端点映射到一个GraphQL类型。这个GraphQL类型是GraphQL操作的响应，通常是在REST API端点支持GET请求时的查询。请求对<code class="fe lo lp lq lr b">/API/products/[id]</code>的响应是一个JSON对象，带有字段<code class="fe lo lp lq lr b">id</code>、<code class="fe lo lp lq lr b">name</code>和<code class="fe lo lp lq lr b">thumbnail</code>。这个响应可以被翻译成一个名为<code class="fe lo lp lq lr b">Product</code>的GraphQL类型。您可以对该请求执行同样的操作，以获得该产品的评级。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mi"><img src="../Images/4e3e68064539c4f03d0b728ccafb0fb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8x1VFZdg2_JUP5bz.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">从数据库表到GraphQL类型</figcaption></figure><p id="0d2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，当您创建一个GraphQL服务器时，您需要编写解析器代码来从数据源获取数据，并根据您的GraphQL模式返回数据。每个解析器都会从一个端点(有时是多个端点)请求数据，该请求的响应会与GraphQL模式中的一个类型相关联。</p><p id="c11f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用StepZen时，您不再需要编写解析器，而是为每个GraphQL操作定义REST API端点。使用StepZen，您可以使用StepZen支持的名为<code class="fe lo lp lq lr b">@rest</code>的自定义指令将GraphQL操作解析到REST API端点。该指令接受您想要转换成GraphQL操作的REST API端点的端点。在端点旁边，您还可以指定参数和头信息来处理身份验证和缓存。</p><p id="ff5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想把REST API对<code class="fe lo lp lq lr b">/API/products/[id]</code>和<code class="fe lo lp lq lr b">/API/products/[id]/rating</code>的请求转换成GraphQL，你需要用StepZen编写下面的GraphQL SDL来实现:</p><pre class="lt lu lv lw gt mj lr mk ml aw mm bi"><span id="871c" class="mn km iq lr b gy mo mp l mq mr">type Product {<br/>  id: ID!<br/>  name: String<br/>  thumbnail: String<br/>}</span><span id="c959" class="mn km iq lr b gy ms mp l mq mr">type Rating {<br/>  id: ID!<br/>  productId: ID!<br/>  score: Float<br/>}</span><span id="f018" class="mn km iq lr b gy ms mp l mq mr">type Query {<br/>  getProduct(id: ID!): Product @rest(endpoint: "/api/products/$id")<br/>  getProductRating(productId: ID!): Rating<br/>    @rest(endpoint: "/api/products/$productId/rating")<br/>}</span></pre><p id="fb01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，查询<code class="fe lo lp lq lr b">getProduct</code>和<code class="fe lo lp lq lr b">getProductRating</code>使用了<code class="fe lo lp lq lr b">@rest</code>指令。使用这个指令，您可以创建REST API端点到GraphQL操作的一对一映射，这仍然是基于实体的。但是现在您可以完全控制GraphQL查询返回的数据，而不是接收REST API端点的整个数据结构。如果您只想接收产品的名称，您可以在查询<code class="fe lo lp lq lr b">getProduct</code>中指定:</p><pre class="lt lu lv lw gt mj lr mk ml aw mm bi"><span id="84d9" class="mn km iq lr b gy mo mp l mq mr">query {<br/>  getProduct(id: 1) {<br/>    name<br/>  }<br/>}</span></pre><p id="6a64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个查询只返回REST API端点<code class="fe lo lp lq lr b">/API/products/1</code>的JSON响应中的字段<code class="fe lo lp lq lr b">name</code>。所有未指定的字段都无法从GraphqL中查询。它不止于此，因为StepZen可以做得更多。通过将<code class="fe lo lp lq lr b">@rest</code>指令与其他StepZen指令相结合，您还可以在一个GraphQL查询中组合REST API端点。</p><h1 id="6433" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">组合REST API端点</h1><p id="cf11" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">将REST API端点映射到一个GraphQL查询只是开始，因为真正强大的是将多个端点组合到一个GraphQL操作中。这允许您删除处理基于实体的请求的REST API约束。再加上GraphQL响应的灵活数据结构，这使您能够更好地控制REST API端点的输出。组合这些端点是在GraphQL类型上完成的，而不是在操作上。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mt"><img src="../Images/32d72a95fc3a058342bfd2038a8a245e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T0URKZfT_LU4We5o.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">将REST端点映射到GraphQL</figcaption></figure><p id="e4dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您之前映射到GraphQL类型和操作的REST API端点可以与<code class="fe lo lp lq lr b">@materializer</code>指令结合使用。上图中的类型<code class="fe lo lp lq lr b">Product</code>是查询<code class="fe lo lp lq lr b">getProduct</code>和<code class="fe lo lp lq lr b">getProductRating</code>的组合响应类型。大多数场来自<code class="fe lo lp lq lr b">getProduct</code>，只有场<code class="fe lo lp lq lr b">rating</code>来自<code class="fe lo lp lq lr b">getProductRating</code>。</p><p id="faba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以在用StepZen构建的任何GraphQL模式中实现<code class="fe lo lp lq lr b">@materializer</code>指令。在下面的例子中，字段<code class="fe lo lp lq lr b">rating</code>从查询<code class="fe lo lp lq lr b">getProductRating</code>中获取数据，字段<code class="fe lo lp lq lr b">id</code>作为参数传递给该查询。</p><pre class="lt lu lv lw gt mj lr mk ml aw mm bi"><span id="7b2c" class="mn km iq lr b gy mo mp l mq mr">type Product {<br/>  id: ID!<br/>  name: String<br/>  thumbnail: String<br/>  rating: Rating<br/>    @materializer(<br/>      query: "getProductRating"<br/>      arguments: [{ name: "productId", field: "id" }]<br/>    )<br/>}</span></pre><p id="6248" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您使用StepZen构建GraphQL API时，您现在可以将产品的评级作为一个关系来查询。您不需要编写任何额外的解析器，并且获取产品独立评级的逻辑是可重用的。</p><p id="d4e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个查询从<code class="fe lo lp lq lr b">/api/products/[id]</code>和<code class="fe lo lp lq lr b">/api/products/[id]/rating</code>获得数据:</p><pre class="lt lu lv lw gt mj lr mk ml aw mm bi"><span id="7abc" class="mn km iq lr b gy mo mp l mq mr">query {<br/>  getProduct(id: 1) {<br/>    name<br/>    rating {<br/>      score<br/>    }<br/>  }<br/>}</span></pre><p id="b17a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您不请求字段<code class="fe lo lp lq lr b">rating</code>时，<code class="fe lo lp lq lr b">@materializer</code>指令不会查询<code class="fe lo lp lq lr b">getProductRating</code>查询。因此，StepZen不会调用REST API端点<code class="fe lo lp lq lr b">/API/products/[id]/rating</code>。这有助于解决许多REST API端点面临的N+1约束。</p><h1 id="3983" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">带身份验证的迁移路径</h1><p id="84a7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当将REST迁移到GraphQL时，您可以使用REST API通常是如何设置的，方法是将REST API端点的响应映射到GraphQL类型。将端点映射到GraphQL是通过<code class="fe lo lp lq lr b">@rest</code>指令完成的，而REST API端点响应是通过<code class="fe lo lp lq lr b">@materializer</code>完成的。简而言之，我们讨论的迁移路径如下:</p><ol class=""><li id="e001" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">将REST API端点响应映射到GraphQL类型</li><li id="a0a3" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">为每个REST API端点创建操作</li><li id="2761" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">使用运算组合GraphQL类型</li></ol><p id="7767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这个迁移路径并不完整，因为没有提到认证的解决方案。如何将身份验证迁移到GraphQL取决于在REST API中如何实现身份验证。一个流行的认证标准是<a class="ae ni" href="https://oauth.net/" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>。使用OAuth2，您可以访问应用程序，而不必担心泄露用户凭证，如密码。此外，通过OAuth，你可以建立与第三方API的通信，正如你在<a class="ae ni" href="https://stepzen.com/blog/spotify-oauth-2-tokens-in-3-steps" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中读到的关于结合StepZen和Spotify的内容。</p><p id="2073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您的REST API实现了OAuth2时，它有一个端点来请求带有用户凭证的令牌。当凭证有效时，将返回一个令牌。您的应用程序可以使用这个令牌向需要身份验证的REST API端点发送请求。先前请求的令牌被添加到HTTP头的请求中。该过程将遵循以下流程:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nj"><img src="../Images/b6e24dc1e6a720c55a13af33bdd95758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Auu7WcKxnAGpP-Wb.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">处理GraphQL APIs的身份验证</figcaption></figure><p id="a37e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相同的流程可以应用于GraphQL API。您可以使用GraphQL查询或变体，而不是向端点发送HTTP请求来请求和接收令牌。这些操作将获取用户凭证作为参数，并在这些凭证有效时返回令牌。当您调用GraphQL API时，可以将返回的令牌附加在头中，或者作为需要身份验证的操作的参数。</p><p id="1420" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用StepZen将现有的OAuth2流迁移到GraphQL，意味着您不必重新实现这个流。您的应用程序可以继续使用相同的流程；只有它需要使用GraphQL操作，而不是对REST API的HTTP请求:</p><pre class="lt lu lv lw gt mj lr mk ml aw mm bi"><span id="acc3" class="mn km iq lr b gy mo mp l mq mr">type Auth {<br/>  id: Int!<br/>  token: String!<br/>}</span><span id="a456" class="mn km iq lr b gy ms mp l mq mr">type Query {<br/>  login(username: String, password: String): Auth<br/>    @rest(<br/>      endpoint: "/api/login?username=$username&amp;password=$password"<br/>      configuration: "auth"<br/>    )<br/>}</span></pre><p id="ac3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lo lp lq lr b">login</code>查询获取用户凭证<code class="fe lo lp lq lr b">username</code>和<code class="fe lo lp lq lr b">password</code>。这些将被追加到对REST API端点<code class="fe lo lp lq lr b">/API/login</code>的调用中。此外，额外的配置被传递到端点，这可能是OAuth2服务的客户端凭证。</p><p id="1acb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lo lp lq lr b">login</code>查询将返回的令牌可以作为参数传递给任何其他GraphQL操作。通过使用<code class="fe lo lp lq lr b">@rest</code>指令选项将头设置为REST API端点，您可以将这个令牌传递给底层REST API:</p><pre class="lt lu lv lw gt mj lr mk ml aw mm bi"><span id="e060" class="mn km iq lr b gy mo mp l mq mr">type Query {<br/>  getProduct(id: ID!, token: String!): [Product]<br/>    @rest(<br/>      endpoint: "/API/products/$id"<br/>      headers: [{ name: "Authorization", value: "Bearer $token" }]<br/>    )<br/>}</span></pre><p id="25a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码块中，GraphQL查询<code class="fe lo lp lq lr b">getProduct</code>现在将令牌传递给REST API端点<code class="fe lo lp lq lr b">/API/products/[id]</code>。这样，在迁移到GraphQL时，您不必设置新的认证服务，因为您可以利用您已经为现有的REST API所做的投资。</p><h1 id="ae9c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">摘要</h1><p id="2577" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">阅读完这篇文章后，您已经了解了如何使用StepZen将现有的REST API迁移到graph QL——您无需编写任何解析器就可以创建一个GraphQL API。该实现仅通过GraphQL SDL使用指令来完成。</p><p id="c786" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将REST API端点映射到GraphQL类型和操作。这些类型和操作可以一次组合多个REST API端点的响应。如果您已经对应用程序的身份验证流程进行了投资，那么您可以通过将该流程添加到GraphQL模式中来利用这些投资。</p></div></div>    
</body>
</html>