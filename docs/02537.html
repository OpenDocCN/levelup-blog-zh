<html>
<head>
<title>3 Useful Things About Scala’s Either Class That You Want To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Scala的两个类，你想知道的3件有用的事情</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-useful-things-about-scalas-either-class-that-you-want-to-know-42adbe090e60?source=collection_archive---------3-----------------------#2020-03-20">https://levelup.gitconnected.com/3-useful-things-about-scalas-either-class-that-you-want-to-know-42adbe090e60?source=collection_archive---------3-----------------------#2020-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/56217538ec2523d5a99a1b35e4c5078f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N57XQKlOef7JD_KS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【https://edward-huang.com】原载于<a class="ae kd" href="https://edward-huang.com/monad/programming/functional-programming/scala/2020/03/19/3-useful-things-about-either-that-you-want-to-know/" rel="noopener ugc nofollow" target="_blank"><em class="kc"/></a></figcaption></figure><p id="e614" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这是我在学习Scala时学到的一种新的类。随着我对函数式编程了解的越来越深入，越来越深刻，要么不仅仅是一个存储left和right两个值的容器，而是一个单子。</p><p id="ffef" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">使用任一类型构造函数的原因之一是在运行程序时不会产生任何令人惊讶的输出。没有这两者，你的功能是不可预测的。抛出异常时，您可能会遇到一些意想不到的副作用。例如，不是意外地爆发异常，而是可以返回左(失败情况)或右(成功情况)。因此，该函数对调用者来说是可预测的，让调用者知道可能发生的潜在结果。</p><p id="cea9" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在本文中，我想分享一些有用的特性，我认为了解函数式编程是有益的。</p><h1 id="87c6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">两者都是单子</h1><p id="d555" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">在Scala 2.1.1和更早的版本中，许多人都不认为是单子，因为它没有map和flatMap方法。</p><p id="be74" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这使得很难组成用于理解的序列。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="d1ee" class="mo ld iq mk b gy mp mq l mr ms">val either1: Either[Exception, Int] = Right(1)<br/>val either2: Either[Exception, Int] = Right(2)<br/><br/>for {<br/>  one &lt;- either1.right<br/>  two &lt;- either2.right<br/>} yield one + two</span></pre><p id="f15f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">然而，在Scala 2.1.1中，两者都被重新设计成具有类似函数的特性。</p><p id="e544" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现代人要么认定右边是成功案例。因此，它支持地图和平面图。</p><p id="7108" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这让理解变得更加愉快:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2e33" class="mo ld iq mk b gy mp mq l mr ms">val either1 : Either[Exception,Int] = Right(1)<br/>val either2: Either[Exception, Int] = Right(2)<br/><br/>for{<br/>  one &lt;- either1<br/>  two &lt;- either2<br/>} yield one + two</span></pre><p id="97ed" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">它要么从不偏不倚的类型转变为右偏。</p><h1 id="90a1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">两者都是右倾</h1><p id="e0d2" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">要成为Monad类型，您需要能够对值应用map或flatMap。然而，在<a class="ae kd" href="https://edward-huang.com/functional-programming/2019/12/30/what-is-an-adt-algebraic-data-types/" rel="noopener ugc nofollow" target="_blank"> ADT </a>中，两者都被归类为Sum类型。这意味着它有两个可能的值，一个右，一个左。另一个类似的单子类型包括未来(成功，失败)，选项(一些，没有)。这些单子持有两个值，通常是快乐和悲伤的场景。</p><p id="4f69" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">该函数应该应用哪个值？</p><p id="4834" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这就是右倾偏见出现的原因。右偏意味着像<code class="fe mt mu mv mk b">map</code>和<code class="fe mt mu mv mk b">flatMap</code>这样的函数只适用于“右侧”或“快乐场景”，而不影响另一侧。</p><p id="7579" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">直到Scala 2.12，两者都是无偏的，这意味着函数的<code class="fe mt mu mv mk b">map</code>和<code class="fe mt mu mv mk b">flatMap</code>不知道应用哪个值。你必须使用“右可投影”来使其右偏并且<em class="mw">可平面映射</em>。</p><p id="3024" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">无偏差适合于验证功能。但是，对于右偏，这两种方法都可以非常方便地创建操作序列。</p><p id="3bb7" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">例如，以验证一个对象为例。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="036b" class="mo ld iq mk b gy mp mq l mr ms">case class CarEngine(sound: String)</span></pre><p id="531c" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">你想验证这个引擎声，看看是不是一辆车。如果不是<code class="fe mt mu mv mk b">vroom</code>的声音，可以通过抛出一个错误来完成。然后，如果它是一个有效的汽车引擎，您希望返回该对象的实例。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="bf61" class="mo ld iq mk b gy mp mq l mr ms">def validCarEngineSound(car:CarEngine): Either[Exception, CarEngine] = {<br/>  car.sound.toLowerCase match {<br/>    case "vroom" =&gt; Right(car)<br/>    case _ =&gt; Left(new Exception("not a valid car sound"))<br/>  }<br/>}</span></pre><p id="2a8f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在，右偏的好处是在验证之后做一些其他的操作，推迟错误处理。</p><p id="8e6f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">假设您想要连接<code class="fe mt mu mv mk b">CarEngine</code>的声音并将其添加到Toyota类，因为Toyota需要将其汽车引擎声音限制为某种方式。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fa78" class="mo ld iq mk b gy mp mq l mr ms"><em class="mw">// TOYOTA class define somewhere in the class<br/></em>val engine = CarEngine("vroom")<br/>val result = validCarEngeinSound(engine).map{ case CarEngine(sound) =&gt; wireToToyota(sound) }<br/><br/>result match {<br/>  case Left(err) =&gt; println(err.getMessage)<br/>  case Right(_) =&gt; println("The engine is correct and is wired to Toyota")<br/>}</span></pre><p id="adf5" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果该值无效，那么它将延迟该值并返回结果。然而，如果它成功了，那么它就执行<code class="fe mt mu mv mk b">map</code>函数中的值。</p><h1 id="0a44" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">折叠</h1><p id="271d" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">最后一个是在任何一个上折叠列表的操作都很棘手。</p><p id="4b11" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">举个例子:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5608" class="mo ld iq mk b gy mp mq l mr ms">List(1,2,3).foldLeft(Right(0)) { (accumulator, num) =&gt; <br/>  if(num &gt; 0) {<br/>    accumulator.map(_ +1)<br/>  } else {<br/>    Left("Negative. Stopping!")<br/>  }<br/>}</span></pre><p id="e2e5" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">因为Left和Right都是其中一个的子类型，所以它抛出一个错误，指出该类型不匹配。因此，您需要为<code class="fe mt mu mv mk b">Right.apply</code>指定类型参数，这样编译器就可以将左边的参数推断为<code class="fe mt mu mv mk b">Nothing</code>。</p><p id="28db" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最好是你来铸造它们。Cats提供了一个智能构造函数，用<code class="fe mt mu mv mk b">asRight</code>将左右值包装成任意一个。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="64d7" class="mo ld iq mk b gy mp mq l mr ms">implicit class EitherOps[A](v:A) {<br/>  def asLeft[B]: Either[A,B] = Left(v)<br/>  def asRight[B]: Either[B,A] = Right(v)<br/>}<br/><br/>List(1,2,3).foldLeft(0.asRight[String]) { (accumulator, num) =&gt; <br/>  if(num &gt; 0) {<br/>    accumulator.map(_ +1)<br/>  } else {<br/>    Left("Negative. Stopping!")<br/>  }<br/>}</span></pre><p id="8e31" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">另一个有用的foldLeft提供了一个左和一个右的场景。</p><p id="1a36" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这取自scala库函数定义。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="23e7" class="mo ld iq mk b gy mp mq l mr ms">type Either[+A,+B]<br/>def fold[C](fa:A =&gt; C, fb:B =&gt; C):C</span></pre><p id="5c3c" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当值为a时，它应用一个<code class="fe mt mu mv mk b">fa</code>,当值为b时，它应用<code class="fe mt mu mv mk b">fb</code>。当您想在不进行模式匹配的情况下进行左右赋值时，这很方便。</p><h1 id="10aa" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">外卖食品</h1><ul class=""><li id="3ca2" class="mx my iq kg b kh ma kl mb kp mz kt na kx nb lb nc nd ne nf bi translated">两者都是monad，具有map和flatMap功能。我们现在没有注意到，在它变成单子之后，它变得多么方便。</li><li id="930f" class="mx my iq kg b kh ng kl nh kp ni kt nj kx nk lb nc nd ne nf bi translated">任何一个都是右偏的，这意味着如果值是“正确的”或“令人满意的场景”，方法就可以执行<code class="fe mt mu mv mk b">map</code>和<code class="fe mt mu mv mk b">flatMap</code>。它没有触及“左”的场景。</li><li id="0980" class="mx my iq kg b kh ng kl nh kp ni kt nj kx nk lb nc nd ne nf bi translated">文件夹是编写任一模式匹配函数执行的另一种方式。</li></ul></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="571a" class="lc ld iq bd le lf ns lh li lj nt ll lm ln nu lp lq lr nv lt lu lv nw lx ly lz bi translated"><strong class="ak">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯，每周都会收到关于科技职业的文章、有趣的链接和内容。</strong></h1><p id="bf30" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">你也可以在<a class="ae kd" href="https://medium.com/@edwardgunawan880" rel="noopener"> Medium </a>上关注我更多类似的帖子。</p></div></div>    
</body>
</html>