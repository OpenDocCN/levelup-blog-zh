<html>
<head>
<title>How to use the Executor Framework in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java中使用Executor框架</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-the-executor-framework-in-java-58a610d20b87?source=collection_archive---------10-----------------------#2020-06-23">https://levelup.gitconnected.com/how-to-use-the-executor-framework-in-java-58a610d20b87?source=collection_archive---------10-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0523" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Java Executor线程管理完全指南—第1部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1548407e04a5e3ee2474081b912ebea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IIQNyifViJd9NubB"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@hjrc33?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Héctor J. Rivas </a>拍摄</figcaption></figure><p id="0728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java 5之前，线程的创建和管理只能在应用层内部完成。创建线程对象需要大量内存。所以在大规模的应用中，如果继续创建大量的线程对象，会造成很大的内存开销。因此，最好将线程的创建和管理与应用程序的其余部分分开。</p><p id="31a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，Java引入了Executor框架作为解决方案。Executor框架包含一系列用于有效管理多线程的特性。你不需要每次用Executor创建新的线程，因为它允许你在需要的时候使用已经创建的线程。因此，使用Executor将在Java应用程序中节省大量内存，同时也节省了您的宝贵时间。</p><p id="e204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将了解Executor框架、线程池、用于创建线程池的不同方法，以及如何使用它们管理线程。让我们现在开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">执行器接口和执行器类</h1><p id="1e70" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">执行器框架有三个执行器接口:<code class="fe mz na nb nc b">Executor</code>、<code class="fe mz na nb nc b">ExecutorService</code>和<code class="fe mz na nb nc b">ScheduledExecutorService</code>。</p><p id="7872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Executor</code>是一个简单的接口，包含一个名为<code class="fe mz na nb nc b">execute()</code>的方法来启动一个由<code class="fe mz na nb nc b">Runnable</code>对象指定的任务。</p><p id="bc36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">ExecutorService</code>是<code class="fe mz na nb nc b">Executor</code>接口的子接口，增加了管理线程生命周期的功能。它还包括<code class="fe mz na nb nc b">submit()</code>方法，类似于<code class="fe mz na nb nc b">execute()</code>方法，但用途更广。<code class="fe mz na nb nc b">submit()</code>方法的重载版本可以接受一个<code class="fe mz na nb nc b">Runnable</code>和一个<code class="fe mz na nb nc b">Callable</code>对象。<code class="fe mz na nb nc b">Callable</code>对象类似于<code class="fe mz na nb nc b">Runnable</code>对象，只是由<code class="fe mz na nb nc b">Callable</code>对象指定的任务也可以返回值。因此，如果我们将一个<code class="fe mz na nb nc b">Callable</code>对象传递给<code class="fe mz na nb nc b">submit()</code>方法，它将返回一个<code class="fe mz na nb nc b">Future</code>对象。<code class="fe mz na nb nc b">Future</code>对象可用于检索<code class="fe mz na nb nc b">Callable</code>返回值，并管理<code class="fe mz na nb nc b">Callable</code>和<code class="fe mz na nb nc b">Runnable</code>任务的状态。</p><p id="b8a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">ScheduledExecutorService</code>是<code class="fe mz na nb nc b">ExecutorService</code>的子接口。它添加了在代码中调度任务执行的功能。</p><p id="225f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了上面提到的三个接口，executor框架还提供了一个名为<code class="fe mz na nb nc b">Executors</code>的类，它包含了创建不同类型的Executor服务的工厂方法。我们可以使用这个类和接口创建线程池。现在让我们看看什么是线程池以及如何创建它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7c21" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">线程池</h1><p id="48a5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">线程池是一组<code class="fe mz na nb nc b">Runnable</code>对象和一组持续运行的线程的集合。这个<code class="fe mz na nb nc b">Runnable</code>对象的集合被称为工作队列。持续运行的线程检查新工作的工作查询，如果需要完成新工作，它们将执行工作队列中的一个<code class="fe mz na nb nc b">Runnable</code>对象。要使用Executor框架，我们需要创建一个线程池，并将任务提交给它执行。Executors类中主要有四种方法用于创建线程池。让我们分别用例子来讨论它们。</p><h2 id="aea7" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">newSingleThreadExecutor()</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bf77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们提交了5个任务。但是因为我们使用的是<code class="fe mz na nb nc b">newSingleThreadExecutor()</code>方法，所以一次只会创建一个新线程和一个任务。其他4个任务正在等待队列中等待。一旦一个任务被线程完成，下一个任务将被该线程选择并执行。<code class="fe mz na nb nc b">shutdown()</code>方法等到当前提交给执行器的任务完成后关闭执行器。但是，如果您想立即关闭执行程序而不等待，请使用<code class="fe mz na nb nc b">shutdownNow()</code>方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6730" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">newFixedThreadPool()</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这和之前的例子是一样的，但是我们使用的是<code class="fe mz na nb nc b">newFixedThreadPool()</code>方法。这个方法允许我们创建一个线程数量固定的池。因此，在代码中，当我们提交5个任务时，将创建3个新线程，并执行3个任务。另外两个任务正在等待队列中等待。只要一个线程完成了一个任务，下一个任务就会被这个线程选择并执行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="ec40" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">newCachedThreadPool()</h2><p id="b820" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们使用这种方法创建线程池时，线程池的最大大小被设置为Java中的最大整数值。根据需求，该方法将创建新的线程，如果需求减少，并且线程空闲时间超过1分钟，该方法将拆除线程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a7d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe mz na nb nc b">newCachedThreadPool()</code>方法最初会创建5个新线程并处理这5个任务。队列中没有等待的任务。如果一个线程空闲时间超过一分钟，这个方法就会把它关闭。<strong class="lb iu">因此，如果您想要比</strong> <code class="fe mz na nb nc b">newFixedThreadPool()</code> <strong class="lb iu">方法更好的排队性能，这种方法是一个不错的选择。</strong> <strong class="lb iu">但是如果你想限制并发任务的数量，对于资源管理，用</strong> <code class="fe mz na nb nc b">newFixedThreadPool()</code>就可以了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="33fd" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">newScheduledThreadPool()</h2><p id="80a5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">newScheduledThreadPool()</code>方法创建一个线程池，该线程池可以调度任务在指定的延迟后运行或定期运行。这个方法返回一个<code class="fe mz na nb nc b">ScheduledExecutorService</code>。在这个线程池中，有三种方法可以用来调度任务:<code class="fe mz na nb nc b">schedule()</code>、<code class="fe mz na nb nc b">scheduleAtFixedRate()</code>和<code class="fe mz na nb nc b">scheduleWithFixedDelay()</code>。让我们看一个如何使用<code class="fe mz na nb nc b">schedule()</code>方法实现这个线程池的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c8fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从示例中可以看出，schedule方法有三个参数，即任务、延迟和延迟的时间单位。<code class="fe mz na nb nc b">schedule()</code>方法用于在固定延迟后调度任务。<code class="fe mz na nb nc b">scheduleAtFixedRate()</code>方法用于在固定延迟后调度任务，然后定期执行该任务。<code class="fe mz na nb nc b">scheduleWithFixedDelay()</code>方法用于在初始延迟后调度任务，然后在前一个任务完成后以固定延迟执行任务。这三种方法适用于不同的场景。</p><p id="9dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是线程池的全部内容，现在让我们看看如何使用executor框架的一些重要注意事项。</p><h1 id="f680" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">重要注意事项</h1><ul class=""><li id="b50d" class="nw nx it lb b lc mu lf mv li ny lm nz lq oa lu ob oc od oe bi translated">不要将正在等待其他任务结果的任务排队。这可能会导致死锁情况。</li><li id="5aac" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">线程池必须在最后通过调用<code class="fe mz na nb nc b">shutdown()</code>方法显式终止。如果不这样做，程序将继续运行，永远不会结束。如果关机后再给执行程序发送一个任务，就会抛出一个<code class="fe mz na nb nc b">RejectedExecutionException</code>。</li><li id="5916" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">使用线程进行长期操作时要小心。这可能导致线程永远等待，并最终导致资源泄漏。</li><li id="4780" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">您需要了解有效调优线程池的任务。如果任务非常不同，那么对不同类型的任务使用不同的线程池以便对它们进行适当的调优是有意义的。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="26cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文到此为止。在本文中，我没有讨论如何使用Executor框架中的<code class="fe mz na nb nc b">Callable</code>和<code class="fe mz na nb nc b">Future</code>，我将在下一篇文章的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-java-callable-and-future-5d79ecb47c8b">中讨论。我希望您已经理解了Java ExecutorService和线程池。</a></p><p id="ff0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，祝您编码愉快！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f05c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="c2c5" class="nw nx it lb b lc mu lf mv li ny lm nz lq oa lu ob oc od oe bi translated"><a class="ae ky" href="https://www.vogella.com/tutorials/JavaConcurrency/article.html" rel="noopener ugc nofollow" target="_blank"> Java并发(多线程)—教程</a></li><li id="3296" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html" rel="noopener ugc nofollow" target="_blank">关于执行者的Java文档</a></li><li id="12c9" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/thread-pools-java/#:~:text=Method%20Description%20newFixedThreadPool(int)%20Creates,()%20Creates%20a%20single%20thread." rel="noopener ugc nofollow" target="_blank">Java中的线程池</a></li></ul></div></div>    
</body>
</html>