# 干净的代码库，或者如何让你的团队感谢你并提高生产力

> 原文：<https://levelup.gitconnected.com/clean-codebases-or-how-to-make-your-team-thankful-for-you-755f60763c9a>

![](img/eaa133564271c05dc51ac4b52774be70.png)

我是一名项目程序员，如果我学到了关于项目的一件事，那就是在前期花费额外的 30%的时间遵循完美的约定，可以在后期节省 300%的时间。我*是*一个“无名小卒”的事实非常有用:和你一起工作的大多数人也将会是“无名小卒”，所以帮助我的东西很可能会帮助他们。

每个人都在谈论 UX，但是用户是不可预测的。你不能只是*希望*用户会喜欢你的改变——你推出它，你 A/B 测试它，你得到用户的意见。您快速迭代变更。总体用户体验是 DX 的一项功能，即开发人员体验。当你的代码干净且易于使用时，变化和特性会很快发生，用户总体上会更高兴。

我们将从一个非常小的范围(在功能级别)开始，一步步向上，直到我们谈到整个项目。

## 程序员令人愉悦的纯洁

函数式编程语言有一个纯净的概念。不要担心——我不会用这一节来说服你放弃 Haskell 或 Scala(这两种语言我都不懂，所以如果我真的开始向你推销它们，我会很担心),但是函数纯度是必须的。

纯粹性意味着一个函数是一个独立的逻辑:

每次我们用`[1, 2]`运行`add`，我们得到 3。程序的全局状态无关紧要，因为函数是纯函数。如果我们有一个像这样的 add 函数会有多烦人:

如果在项目的另一个文件深处，程序员想把两个数字加在一起，他们会调用`add([1, 2])`。然后，他们会得到 8。然后，他们会用剩下的 8 小时工作时间撕扯自己的头发——第二天，他们会站着问为什么 1 + 2 = 8。只有到那时，你才会尖叫“哦…这个函数是为了给在线用户添加一个元组。”

如果这个函数带有另一个参数`onlineUsersCount`，其他程序员会想知道这个参数是什么意思——你甚至可以在不知道的情况下拯救他们的一天，仅仅通过遵循函数纯度。拍拍自己的背！

纯洁的另一部分是我们也不会破坏外部状态。我们只是做我们被要求做的事情，只是用我们被给予的东西。如果 add 真的做了`usersOnline = pair[0] + pair[1]`，我们早就在外邦混日子了。

一个纯函数对我来说主要有两个好处:容易测试，容易消化。测试一个纯粹的函数是一种纯粹的快乐，因为我们不需要担心增加外部依赖。

## 不要自作聪明

如果你一直在研究 leetcode，请举手，进入讨论，看到一个隐晦地命名他们的变量的答案`x, y, z, list, heap, pq` …现在，你不仅要用你的脑袋去思考不可思议的算法，而且你已经将跟踪单个字母变量的含义添加到你的认知负荷中了？

我从来不会在完成的当天打开一个 PR。如果它不是关键任务，它可以等待，并且能够在第二天上午 11:00 用一种全新的眼光来看你的 PR 可以帮助你从一个从未见过它的人的角度来阅读你的代码。作家经常忘记设身处地为他们的读者着想:记住你有你的评论者没有的上下文，对你来说似乎显而易见的东西可能不到两个星期，导致维护痛苦。重读你的代码，重读它不是为了正确性(尽管也这样做！)但是为了清楚起见，代码应该像书一样阅读，每个文件应该是它自己的故事。

## 不要害怕重构

对一些逻辑进行一次*单次*的复制和粘贴不会有什么坏处——它只有 15 行代码，我们只在两个地方真正需要它，对吗？让我们复制代码，然后复制测试逻辑，我们都很好！

下一个工程师走过来:“嗯，这里的*一定是*没有提取到函数中的原因……我需要一些类似的逻辑，所以让我们像上一个人一样复制这个逻辑。”

滑坡是一个谬论，但仍然是一个适用的谬论。最好的代码库有严格的林挺规则、严格的习惯用法、严格的代码审查，而且是……嗯，严格的！要求在字符串周围使用单引号而不是双引号这种乏味的学究气可能看起来没用，但是代码读起来比写起来更难，所以当读者的工作已经很困难的时候，为什么还要给他们增加更多的压力呢？

小的重构以后会保存更大的重构:将一个重复使用的副本提取到一个常量中可以节省时间，以后当您需要找到该副本被使用的每一次并替换一个单词时。SLOC 越低越好——维护更少，更容易搭载。

## 优秀的应用程序在本地运行

这个很大。

不要经历必须测试 Beta 中的变化的痛苦。当你不能在本地测试时，分支冲突，错误的合并，失败的 E2E 测试是很平常的。

有了在本地运行大多数服务的能力，您可以通过允许快速原型化来节省时间、金钱和开发人员的挫折感，这直接导致了快速交付。

不幸的是，AWS 没有在本地提供大部分服务，这可能会严重破坏全栈本地梦想。不过，不要担心，有一些方法可以在本地运行云服务，我最喜欢的是 [LocalStack](https://localstack.cloud/) (不以任何方式附属或赞助，这只是一个诚实的建议)，因为我可以在一个命令中快速启动整个微服务架构，允许我在`localhost`上测试我的应用程序 full stack——lambdas、对象存储和服务器。

糟糕——我使用了错误的 API 来获得一个签名链接，它没有按预期工作。如果不在本地运行，您最早可以在 Alpha 阶段发现这一点——在 PR、审查和初始测试过程之后。通过允许开发人员在本地运行他们的堆栈，您节省了开发人员似乎从来没有的时间。

如果你在一个真实的环境中运行集成/ E2E 测试，比如 local stack——这可以让你尽可能接近现实地运行测试，这有助于在过程的早期发现错误。

感谢阅读！你觉得我错过了什么吗？我一直在寻求学习，所以如果有什么你认为我应该看一看或者改变的，那么请留下评论。