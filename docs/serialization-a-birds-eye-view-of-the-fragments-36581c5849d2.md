# 序列化——片段的鸟瞰图

> 原文：<https://levelup.gitconnected.com/serialization-a-birds-eye-view-of-the-fragments-36581c5849d2>

![](img/74dc2a080951ec9f236156e5c105237c.png)

Rene b hmer 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

在大多数软件系统由需要跨进程、网络和机器相互通信的微服务组成的世界中，选择正确的序列化类型可能会产生巨大的性能影响。不幸的是，使用哪种序列化方案的决定经常很快被放弃，而使用众所周知的技术，而不太考虑它们是否适合这项工作。

本文试图找出序列化的一些问题，并在各种方案所暴露的权衡之间提供一些清晰度。

在处理第三方服务时，我们通常不能自由选择序列化方案。许多服务会公开使用 [JSON](https://www.json.org/json-en.html) 或 [XML](https://www.w3.org/TR/xml/) 的方案，如果你接触过一些金融解决方案，你可能会遇到 [FIX](https://www.fixtrading.org/standards/) 。在这种情况下，我们必须遵守给我们的计划。然而，当涉及到我们选择在组织内部开发和维护的解决方案时，我们有更大的自由度来选择如何在我们的程序和服务之间交换数据。这正是我们应该考虑的比我们在使用外部 API 时接触到的常见解决方案更广泛一点的时候。

# 不考虑序列化的缺陷

让我们假设你是一名后端工程师，在微服务环境中从事一些用 C#编写的软件项目，你需要向某处的一些客户端公开一个 API。您决定将您的后端实现为一个接收和发送 JSON 的 web 服务，因为这似乎是目前每个人都在做的事情。你还会发现一个令人信服的论点，那就是你几乎完全有自由对你的领域对象建模，因为两者都是 Newtonsoft。JSON 和内置系统。Json 非常擅长序列化我们扔给它们的大多数数据结构和对象。这将使您能够在开发过程中无缝地添加和删除新字段，而不会因为破坏序列化代码而受到太多的阻碍。如果性能成为问题，您可以随时切换到更有效的方案。

那么问题出在哪里？好吧，你做了一些隐含的设计选择，这也带来了一些缺点。由于没有花时间指定模式，在开发阶段，服务的所有调用者将会收到格式快速变化的数据，而不会有任何通知，从而妨碍他们的开发过程。此外，如果您决定使用 C#中的数据类型，如`decimal`，您可能会遇到问题。这将如何转化为 JSON，因为这种格式并不真正支持`decimal`提供的更高精度？它们很有可能被转换成双精度型，但精度损失相当。

有一些方法可以解决这样的问题，例如，确保通过网络发送一个`decimal`的字符串表示，而不是依赖默认的转换。但是突然之间你不得不主动做出这样的选择，序列化不再像以前那么琐碎。当解决性能问题时，只有当它从未发生或者您的解决方案没有用户时，这才是容易的。如果您必须更改序列化方案，您的 API 可能会有许多不同的用户，并不是所有的用户都乐意升级到新的二进制序列化方案，因此您可能需要暂时运行和维护两个版本的 API。明智的做法是记住，你的系统从来没有比你计划设计它的时候拥有更少更快乐的用户，因此改变序列化的成本实际上是免费的。

# 指导选择序列化的一些问题

幸运的是，我们可以开始问自己几个问题，引导我们找到一个合理的解决方案。以下是其中的一些:

*   谁是交流的参与者？
*   它们的局限性是什么？
*   有模式还是无模式？
*   文本还是二进制？
*   需要版本控制吗？

## 谁是交流的参与者？

在大多数软件系统中，在交流中有两种参与者:人类和机器。尽管随着命令行程序变得越来越不流行，您很少能够直接向人类展示数据。用户可能仍然会提出要求，比如他们需要你提供的数据，在 Excel、浏览器或其他东西中易于处理。这显然对如何格式化数据造成了一些限制，因为一些超紧凑的二进制格式可能很难导入 Excel，而像 [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) 这样的文本格式可能会容易得多。当两个软件系统之间进行通信时，您需要问这样一个问题:是否真的需要以文本格式读取它们之间的通信，或者更紧凑的二进制格式是否足够。通常是后者的情况。

## 参与者的局限性是什么？

通常，您必须考虑系统调用者的需求。如果您主要由 React 前端调用，那么选择像 SBE 这样的高性能二进制序列化方案可能不是最佳选择，因为很少有工具和库可以从 javascript 支持这种格式。如果调用者是具有大量库的其他系统，并且您可能会遇到大量调用，或者通过网络发送大量数据，那么您可能会从选择二进制序列化方案中受益，例如[协议缓冲区](https://github.com/protocolbuffers/protobuf)、 [Cap'n'Proto](https://capnproto.org/) 或 [SBE](https://github.com/real-logic/simple-binary-encoding) ，这些方案可以提高性能。一般来说，文本格式和二进制格式之间的性能差异可以是数量级的，所以根据您的服务遇到的请求数量，最好在开发过程的早期就确定这一点。

## 有模式还是无模式？

是否使用模式的选择引起了相当多的争论。如果您选择花时间并指定一个模式，您将使任何调用您的应用程序的开发人员的工作变得更加容易。最有可能的是，他们甚至能够通过工具生成数据模型。选择不这样做，会使您的生活更轻松，因为您不必在更改数据模型时维护模式，但是，当您更改内容时，调用者可能会大吃一惊，他们的代码会神奇地中断。对于某些数据格式，如 XML 和 JSON，您可以选择是否希望分别使用 [XML 模式](https://www.w3.org/TR/xmlschema11-1/)和 [JSON 模式](https://json-schema.org/)来定义模式。但是对于其他格式，如 SBE，模式是必需的。我通常更喜欢使用模式，因为它们可以帮助我思考我的数据模型将会是什么样子，而不需要过多地钻研代码。但是对于较小的实用程序来说，模式可能是多余的。

## 文本还是二进制？

选择用于序列化的文本格式允许开发人员使用基本的文本编辑器来查看通过网络传输的数据，这通常会带来比大多数二进制格式更大的消息大小和更慢的反序列化的代价。二进制格式通常会暴露相反的权衡。尽管有些人会认为像 JSON 这样的文本格式是不可读的，除非你记住了整个 ASCII 表。虽然从技术上来说这是对的，但这并不能改变这样一个事实，即有很多工具可以轻松地打印 XML 和 JSON，而您可能需要花一点时间开发自己的工具来显示以二进制序列化模式传输的消息内容。那么你应该选择哪一个呢？同样，这取决于谁是沟通的参与者。显然，由于消息主要是在机器之间交换的，因此让它们变得可读没有什么意义，所以为什么还要考虑文本格式呢？为了让其他机器与运行你的代码的机器进行通信，你需要开发人员开发应用程序来完成这项工作。这些开发人员也是人，他们可能更容易通读一些 JSON，而不是依赖您提供的工具或自己开发工具。除了编辑器，同样的规则也适用于语言库。您的客户使用的语言越深奥或越特殊，他们就越有可能通过一些包支持 JSON 或 XML，而不是一些更复杂的二进制格式。根据经验，当在组织内部公开模式时，我通常会使用模式的二进制序列化，特别是当我知道大部分代码库是用。NET、C++或 Java。如果需要公开文本格式，我会添加一个转换网关，这样，将二进制格式转换为文本格式的额外复杂性和性能成本就隐藏在一个地方。

# 是否版本化？

您是否曾经需要推出一些功能，这些功能需要向通过网络的对象添加新的字段？这就是版本控制派上用场的地方。如果您的模式指定了通过网络传输的数据对象的版本，那么每个客户端都将知道它可以处理哪些消息，不能处理哪些消息。在相当多的格式中，添加新字段不成问题，大多数 JSON 框架会很乐意忽略您没有在[dto](https://en.wikipedia.org/wiki/Data_transfer_object)中指定的字段，有些甚至会为您的 DTO 中的字段采用默认值，因为反序列化程序找不到与之匹配的值。但是在 dto 中添加和删除字段是一条危险的道路，尤其是当调用您的服务的人不同意这些变化时。也就是说，如果你在一个高度敏捷的环境中工作，并且你运行一个带有自动生成的 [Swagger](https://swagger.io/) 文档的 ASP.NET web 服务，这可能没问题。其他序列化格式，如 SBE，提供了对版本控制的支持，您可以添加某些字段，指定它们适用于哪个版本，以及早期版本的消息的默认值。您是否需要在序列化格式中考虑版本控制，取决于您的具体情况，但在设计过程的早期，这绝对值得考虑。

# 结论

序列化是一个重要的问题，如果不及时解决，可能会导致开发阶段下游的其他问题。我希望这篇文章有助于改变您对序列化的看法，从仅仅选择一个合理的缺省值，到使它成为应用程序架构中的一个主动选择，无论您是否选择坚持使用您所知道的东西，或者尝试一些新的东西，您现在应该对您的选择所暴露的权衡有所了解。祝您未来在 API 设计和序列化方面的努力好运。