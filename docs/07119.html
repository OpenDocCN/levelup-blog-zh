<html>
<head>
<title>Demystify Minimum Spanning Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解开最小生成树之谜</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solving-the-muddy-city-problem-with-minimum-spanning-tree-57d5eef88d65?source=collection_archive---------25-----------------------#2021-01-25">https://levelup.gitconnected.com/solving-the-muddy-city-problem-with-minimum-spanning-tree-57d5eef88d65?source=collection_archive---------25-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ab03bc6afca56a500be24123cbdc6a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dYuFyKLkHeLTokBf"/></div></div></figure><p id="4ca0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从前，有一座城市没有路。暴雨过后，在城市里四处走动特别困难，因为地面变得非常泥泞。汽车陷在泥里，人们把靴子弄脏了。市长想改造这座城市，但他不想花不必要的钱，因为它还想建设其他东西。因此，迈耶规定了两个条件:</p><ol class=""><li id="000f" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">必须铺设足够多的街道，这样每个人都可以沿着铺设好的道路从自己的家到别人的家</li><li id="5d96" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">铺路的费用应该尽可能低。</li></ol><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ln"><img src="../Images/144ecf6ced31b32507b8997d9067f85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zzHOwhtiypvB1KVi.png"/></div></div></figure><p id="5109" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上图是城市的布局。如何才能以尽可能少的铺路成本来确定铺路路线？</p><p id="44ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哇哦！这是最小生成树的经典问题。每个目的地可以是一个顶点，道路可以用边来表示。我们希望在图中创建一个边集合，该边可以到达所有顶点，并且构建这些边的成本尽可能小。</p><p id="7cf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">什么是生成树？给定一个图G，生成树是图G中的一个子图。这个子图是一棵树，并且连接所有的顶点。一个图可以有多个生成树。</p><p id="865f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然是树，那就无环。</p><p id="3f89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">生成树的开销是生成树每条边上的总权重。因此，最小生成树是图中所有生成树中价格最小的生成树。一个图中也可以有许多极小生成树。</p><p id="a84d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">求最小生成树的两个著名算法是Kruskal和Prims。这些算法是计算图中生成树的最小成本的贪婪算法。我想解释两种算法以及两者之间的区别。</p><h1 id="0ea3" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">克鲁斯卡尔算法</h1><p id="4973" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">Kruskal的算法通过将边添加到不断增长的生成树中来计算生成树的最小成本。底层算法是迭代并不断从剩余边列表中寻找池的最小成本边。将边添加到不断增长的生成树中。</p><p id="e994" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">算法是这样的:</p><ol class=""><li id="98a0" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">根据权重将边按升序排序。</li><li id="26a9" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">初始化一个增长生成树的空集。</li><li id="e3cc" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">遍历排序后的边，做这两个操作:1。检查将这条边添加到不断增长的生成树集合中是否会花费任何周期。如果它形成了循环，跳过这条边，并通过下一条边。如果它不能创造一个循环，那么就把边加到列表中。</li><li id="949e" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">一旦你遍历完所有的边，生成树将由最小生成树组成。</li></ol><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/58882221a30d52a7fbd3901e66badcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8oA85M1ErHf4D8Gq.png"/></div></div></figure><p id="a2be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，我们根据权重对边进行排序。最小边是<code class="fe mw mx my mz b">A -&gt; B</code>、<code class="fe mw mx my mz b">B-&gt;C</code>和<code class="fe mw mx my mz b">D-&gt;E</code>，由权重1组成。我们选<code class="fe mw mx my mz b">A -&gt; B</code>吧。然后，我们找到第二条边，在这种情况下，<code class="fe mw mx my mz b">B -&gt; C</code>，并检查<code class="fe mw mx my mz b">B -&gt; C</code>是否会形成任何循环。然后，我们检查<code class="fe mw mx my mz b">C-&gt;D</code>，看看<code class="fe mw mx my mz b">C-&gt;D</code>是否会在生长的生成树中形成任何循环。然后第二小的边是<code class="fe mw mx my mz b">A-&gt;C</code>，权重为2。但是，我们不能添加<code class="fe mw mx my mz b">A -&gt; C</code>，因为它在不断增长的生成树中形成了一个循环。跳过<code class="fe mw mx my mz b">A -&gt; C</code>。然后，下一个最小的权重是<code class="fe mw mx my mz b">C -&gt; D</code>。<code class="fe mw mx my mz b">C-&gt;D</code>不会导致生成树的循环增长。将<code class="fe mw mx my mz b">C-&gt;D</code>添加到生成树中，我们就完成了算法。</p><p id="5a76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于生成树的边总数将是V-1条边，所以您可以使用通过边的任一循环，直到增长的生成树具有<em class="na"> V-1条边。</em></p><h1 id="8139" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">普里姆算法</h1><p id="8932" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">Prim的算法通过向不断增长的生成树添加顶点来计算生成树的最小成本。底层算法将类似于Kruskal的算法，除了它将遍历所有顶点，直到所有顶点都在不断增长的生成树中。</p><p id="e75b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">算法是这样的:</p><ol class=""><li id="4db9" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">维护两个不相交的集合。一个是成长生成树，一个不是成长生成树。</li><li id="f8f3" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">选择与增长生成树集合相邻的最小加权顶点，该顶点不在增长生成树中，并将其添加到不断增长生成树集合中。使用PriorityQueue可以从非增长生成树中选择最小权重的顶点。我们可以将生长生成树中顶点的所有邻居添加到优先级队列中。优先级队列将根据顶点的最小权重值对顶点进行排序。我们从队列中取出最小权重值。检查它是否在生长生成树中。如果不是，我们可以增加生成树的价值。然而，我们还需要考虑一件事，这将在第3步。</li><li id="ce33" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">检查周期。为了做到这一点，我们可以用一个布尔数组来记录所有添加到生成树中的顶点。一旦节点被选中，我们将布尔数组中的顶点标记为true。因此，在探索它的邻居时，我们只将该节点添加到优先级队列中当且仅当该值尚未被选择时。</li></ol><p id="0406" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看这个算法是如何生成最小生成树的。</p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/262455cf42002ea51f5c7dafa9749ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0Bw-sHpDrN6CvE7l.png"/></div></div></figure><p id="bea1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">起始顶点不重要。让我们选择起始顶点为<code class="fe mw mx my mz b">B</code>。我们探索邻居B，并添加优先级队列中的所有值。它由<code class="fe mw mx my mz b">(C,1)</code>、<code class="fe mw mx my mz b">(A,1)</code>和<code class="fe mw mx my mz b">(E,4)</code>组成。从min-heap中弹出，这就是<code class="fe mw mx my mz b">(A,1)</code>。标记顶点，探索其邻居，并将尚未标记的邻居添加到最小堆中。在下一次迭代中，优先级队列中最小的权重是<code class="fe mw mx my mz b">(C,1)</code>。标记顶点C并探索它的邻居。将邻居添加到优先级队列。现在，我们有权重为3，2，4的边。最小堆将弹出两个，因为它的权重是所有堆中最小的。但是，我们不把它添加到正在增长的生成树中，因为顶点会导致循环。跳过操作，从最小堆中取出下一个最小的权重。所以我们选择<code class="fe mw mx my mz b">(D,3)</code>。探索相邻的顶点D，并将其邻居添加到最小堆中。最小堆现在具有权重为1.4的边。Prim的算法会选择<code class="fe mw mx my mz b">(1,E)</code>。最后，它将弹出最小堆中的剩余值，并完成算法。</p><h1 id="88c9" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">差别</h1><p id="b3f1" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">算法区别在于，Kruskal的算法用一条边来求最小生成树，Prim的算法用顶点。</p><p id="1de6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就时间复杂度而言，这是差不多的，取决于你想如何实现该算法。但是，如果使用斐波那契堆，prims会比Kruskal运行得更好。</p><p id="14d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于Kruskal的算法来说，找到最小生成树所需的时间将是<code class="fe mw mx my mz b">ElogE</code>。首先，我们需要根据权重对边进行排序，这将花费<code class="fe mw mx my mz b">ElogE</code>。然后，我们将遍历所有的边，从每条边开始，我们检查添加这条边是否会导致循环。如果使用union-find通过秩和路径压缩用union来检测循环，每个<code class="fe mw mx my mz b">find</code>操作都可以取<code class="fe mw mx my mz b">LG*N</code>，分摊到常数。如果你正在按等级做唯一的联合，每个<code class="fe mw mx my mz b">find</code>方法将花费不相交集合树的高度<code class="fe mw mx my mz b">logV</code>。因此，第二个操作是遍历所有边并检查添加一条边是否会在生成树成本增长中形成一个循环<code class="fe mw mx my mz b">Elg*V</code>——这相当于<code class="fe mw mx my mz b">E</code>。由于我们正在寻找总运算的一个上界，所以它将是<code class="fe mw mx my mz b">ElogE + E</code>，它将是<code class="fe mw mx my mz b">ElogE</code>。从<code class="fe mw mx my mz b">logE = logV^2</code>开始，我们可以得出<code class="fe mw mx my mz b">ElogV</code>的结论。</p><p id="2527" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于Prim的算法，找到最小生成树所需的时间将是<code class="fe mw mx my mz b">(V + E)logV</code>。因为我们是基于顶点而不是边来构建生成树的，所以我们需要遍历所有的顶点和边。我们将把所有的边推到堆中，并从堆中移除所有的边。在遍历每个顶点和边的过程中，我们还会推送所有不在生成树中的相邻顶点。因此，优先级队列具有不同权重的重复顶点。在这个算法中，我们最终会将所有与边相关的顶点添加到优先级队列中。所以运行时间是<code class="fe mw mx my mz b">VlogE+ElogE = (V+E)logE</code>。然而，一个连通图可以拥有的最大边数是<code class="fe mw mx my mz b">V^2</code>。如果我们用<code class="fe mw mx my mz b">logE = logV^2</code>代替，就是<code class="fe mw mx my mz b">2logV</code>——相当于<code class="fe mw mx my mz b">logV</code>。所以是<code class="fe mw mx my mz b">(V+E)logV</code>。在连通图中，<code class="fe mw mx my mz b">V</code>可以等于<code class="fe mw mx my mz b">E</code>，因为max <code class="fe mw mx my mz b">E</code>是<code class="fe mw mx my mz b">V^2</code>。我们可以断定是<code class="fe mw mx my mz b">ElogV</code>。</p><p id="e4bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过使用斐波那契堆而不是二进制堆来进一步优化。我们仍然会遍历图中的所有顶点和边。但是，因为在Fibonacci堆中，插入需要常数时间，移除需要对数时间。所以总操作可以变成<code class="fe mw mx my mz b">E+VlogV</code>。</p><p id="aa7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">何时使用一种算法而不是另一种算法？</p><p id="0e50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这取决于用例。</p><p id="0388" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果图是稠密的，那么Prims将具有比Kruskal更好的性能。如果图是稀疏的，Kruskal将是一个更好的选择，因为它比Prim的更容易实现。</p><h1 id="114c" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="fe6b" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">最小生成树是指可以到达图中所有顶点的边的最小成本。求解最小生成树的算法有很多种，最流行的两种是Kruskal的算法和Prim的算法。这两种算法都使用贪婪方法来寻找最小生成树。然而，技术是不同的。Kruskal的使用一条边将每条边放入生长的生成树中，而Prim的使用顶点将每个具有最小权重的顶点添加到生长的生成树中。</p><h1 id="37ae" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">资源</h1><p id="7f74" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">有一些关于最小生成树的很好的资源，以及它的使用案例。如果您想了解更多信息，请查看下面的参考资料！</p><ul class=""><li id="6757" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky nc lf lg lh bi translated"><a class="ae nd" href="https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/tutorial/" rel="noopener ugc nofollow" target="_blank">最小生成树教程&amp;注释</a></li><li id="7bbd" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky nc lf lg lh bi translated"><a class="ae nd" href="https://stackoverflow.com/questions/20430740/time-complexity-of-prims-algorithm#:~:text=Given%20that%20the%20total%20time,can%20conclude%20O(ElogV)%20." rel="noopener ugc nofollow" target="_blank">Prims算法的时间复杂度？—堆栈溢出</a></li><li id="cb20" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky nc lf lg lh bi translated"><a class="ae nd" href="https://personal.utdallas.edu/~besp/teaching/mst-applications.pdf" rel="noopener ugc nofollow" target="_blank">最小生成树的应用</a></li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="82da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">【https://edward-huang.com】最初发表于<a class="ae nd" href="https://edward-huang.com/graph-theory/algorithm/2021/01/21/solving-the-muddy-city-problem-with-minimum-spanning-tree/" rel="noopener ugc nofollow" target="_blank"><em class="na"/></a><em class="na">。</em></p></div></div>    
</body>
</html>