<html>
<head>
<title>Intersection Observer API: speed up your web applications with lazy loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉点观察器API:通过延迟加载加速您的web应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/intersection-observer-api-speed-up-your-web-applications-with-lazy-loading-ab6df7ead9ca?source=collection_archive---------1-----------------------#2019-05-07">https://levelup.gitconnected.com/intersection-observer-api-speed-up-your-web-applications-with-lazy-loading-ab6df7ead9ca?source=collection_archive---------1-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3e61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">交叉点观察器可以通过帮助你实现图像的延迟加载来提高你的web应用程序的性能。</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/cf8d447e9354a3316274431b58165291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUWWv7fGDMjCJy9tPGIjMQ.png"/></div></div></figure><p id="1394" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在过去的几个月里，我努力提高我的网站的页面速度。我改进了我所有的客户端代码，以便能够在谷歌官方Chrome工具<a class="ae lb" href="https://developers.google.com/web/tools/lighthouse/" rel="noopener ugc nofollow" target="_blank"> Lighthouse </a>上达到90分以上的性能分数，以衡量你的网络应用程序的性能、可访问性、<a class="ae lb" href="https://www.fabrizioduroni.it/2019/03/03/github-pages-progressive-web-app.html" rel="noopener ugc nofollow" target="_blank"> progressive web apps </a>合规性等。报告中的最后一件事是关于屏幕外图像的警告，如下面的屏幕截图所示:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lc"><img src="../Images/ad8fb006e562019b0cf19721cbfb4692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3QmIUuakWjh_9E7LpQv6w.jpeg"/></div></div></figure><p id="6a33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我点击了报告中的链接，该链接指向一个包含谷歌官方关于屏幕外图片加载指南的页面。该页面的主题是<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交叉点观察器API </a>以及它如何帮助您仅在特定内容在视窗中可见时才加载它。我还在Google developer官方网站上找到了另一篇文章，详细解释了如何利用Intersection Observer的能力在web应用程序中延迟加载图像。所以你可以想象我“接受了挑战”(就像《我是如何遇见你的母亲》中的巴尼·斯丁森那样)😜)然后我开始为我的网站实现图片的惰性加载。</p><h2 id="3870" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">履行</h2><p id="507e" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">首先，我们先创建一个名为<code class="fe mb mc md me b">lazyLoadImages</code>的函数。这个函数有两个参数:</p><ul class=""><li id="4275" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><code class="fe mb mc md me b">selector</code>这是一个字符串，我将使用它来选择我想要观察的所有文档对象</li><li id="295c" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><code class="fe mb mc md me b">loadCompleted</code>图像下载后将执行的功能</li></ul><p id="1ee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该函数将从<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交叉点观察器API </a>创建一个<code class="fe mb mc md me b">IntersectionObserver</code>对象的新实例。这个对象构造函数有两个参数:</p><ul class=""><li id="7a51" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">回调，即在给定当前配置的情况下，当对象变得可见时调用的函数</li><li id="537d" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">一个配置选项，允许开发人员自定义交叉点观察器如何计算与视口的交叉点</li></ul><p id="0e5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在创建了<code class="fe mb mc md me b">IntersectionObserver</code>对象之后，我通过调用使用<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll" rel="noopener ugc nofollow" target="_blank"> querySelectorAll </a>方法选择的文档对象上的<code class="fe mb mc md me b">observer(element)</code>方法，将它附加到我想要观察的DOM元素上，并将<code class="fe mb mc md me b">selector</code>作为参数接收。</p><pre class="kq kr ks kt gt mt me mu mv aw mw bi"><span id="4bc7" class="ld le it me b gy mx my l mz na">const lazyLoadImages = (selector, loadCompleted) =&gt; {<br/>  const intersectionObserver: IntersectionObserver = <br/>          new IntersectionObserver(<br/>            (entries, observer) =&gt; onIntersection(entries, <br/>                                                  observer,  <br/>                                                  loadCompleted),<br/>            { rootMargin: '50px 0px', threshold: 0.01 }<br/>          )<br/>  document.querySelectorAll(selector)<br/>          .forEach(image =&gt; intersectionObserver.observe(image))<br/>}</span></pre><p id="273f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在上面的代码片段中看到的，在交叉点回调中，我调用了<code class="fe mb mc md me b">onIntersection</code>函数。它是做什么的？该函数检查从交叉点观察器接收的<code class="fe mb mc md me b">IntersectionObserverEntry</code>作为参数。如果一个<code class="fe mb mc md me b">target</code> <code class="fe mb mc md me b">Element</code>在视口内，它的<code class="fe mb mc md me b">intersectionRatio</code> &gt;将为0。当这种情况发生时，我可以移除观察者，并使用<code class="fe mb mc md me b">loadImage</code>函数开始加载图像。</p><pre class="kq kr ks kt gt mt me mu mv aw mw bi"><span id="8bf5" class="ld le it me b gy mx my l mz na">const onIntersection = (entries, observer, loadCompleted) =&gt; {<br/>  entries.forEach(entry =&gt; {<br/>    if (entry.intersectionRatio &gt; 0) {<br/>      observer.unobserve(entry.target)<br/>      loadImage(entry.target, loadCompleted)<br/>    }<br/>  })<br/>}</span></pre><p id="4009" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mb mc md me b">loadImage</code>功能通过用<code class="fe mb mc md me b">data-src</code>域中包含的数据设置图像src域来下载图像。在下载结束时，我删除了用来隐藏图片的css类<code class="fe mb mc md me b">lazy</code>,直到图片下载完毕。然后调用<code class="fe mb mc md me b">loadCompleted</code>函数，调用者可以对图像做任何想做的事情(例如，我做了一个自定义动画，以避免图像显示时出现闪烁效果)。</p><pre class="kq kr ks kt gt mt me mu mv aw mw bi"><span id="4f1f" class="ld le it me b gy mx my l mz na">const loadImage = (image, loadCompleted) =&gt; {<br/>  image.src = image.dataset.src<br/>  image.onload = () =&gt; {<br/>    removeCssClass(image, 'lazy')<br/>    loadCompleted(image)<br/>  }<br/>}</span></pre><p id="0ab0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是具有完整流程的最终脚本。</p><pre class="kq kr ks kt gt mt me mu mv aw mw bi"><span id="5a0a" class="ld le it me b gy mx my l mz na">import 'intersection-observer'<br/>import { removeCssClass } from './css-class'</span><span id="4a0e" class="ld le it me b gy nb my l mz na">const lazyLoadImages = (selector, loadCompleted) =&gt; {<br/>  const intersectionObserver: IntersectionObserver = <br/>          new IntersectionObserver(<br/>            (entries, observer) =&gt; onIntersection(entries, <br/>                                                  observer,  <br/>                                                  loadCompleted),<br/>            { rootMargin: '50px 0px', threshold: 0.01 }<br/>          )<br/>  document.querySelectorAll(selector)<br/>          .forEach(image =&gt; intersectionObserver.observe(image))<br/>}</span><span id="2224" class="ld le it me b gy nb my l mz na">const onIntersection = (entries, observer, loadCompleted) =&gt; {<br/>  entries.forEach(entry =&gt; {<br/>    if (entry.intersectionRatio &gt; 0) {<br/>      observer.unobserve(entry.target)<br/>      loadImage(entry.target, loadCompleted)<br/>    }<br/>  })<br/>}</span><span id="4262" class="ld le it me b gy nb my l mz na">const loadImage = (image, loadCompleted) =&gt; {<br/>  image.src = image.dataset.src<br/>  image.onload = () =&gt; {<br/>    removeCssClass(image, 'lazy')<br/>    loadCompleted(image)<br/>  }<br/>}</span><span id="0097" class="ld le it me b gy nb my l mz na">export { lazyLoadImages }</span></pre><p id="1bfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有一件事我还没讨论。对于还没有实现<code class="fe mb mc md me b">IntersectionObserver</code> API的浏览器，我们如何支持这种类型的延迟加载呢？答案是<a class="ae lb" href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill" rel="noopener ugc nofollow" target="_blank">节间观察者Polyfill </a>。我把它作为我的项目的一个依赖项来安装。</p><pre class="kq kr ks kt gt mt me mu mv aw mw bi"><span id="895f" class="ld le it me b gy mx my l mz na">npm install --save intersection-observer</span></pre><p id="98ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<a class="ae lb" href="https://en.wikipedia.org/wiki/Polyfill_(programming)" rel="noopener ugc nofollow" target="_blank"> polyfill </a>公开了交叉点观察器的普通javascript中的特定实现，或者它公开了当前的浏览器实现，如果它已经存在于用户正在使用的浏览器中的话。</p><h2 id="c8c0" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">结论</h2><p id="62f5" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">交叉点观察器是一个强大的API。它让你实现资源加载的延迟加载，并达到我只有在移动原生应用中才有机会看到的性能和架构应用模式。网络正在用原生应用填补这一空白，而交叉点观察者是另一个证明，90%的现有原生移动应用可以成为强大的网络应用。事实上，在我的日常工作中，我仍然是一名原生移动应用程序开发人员，我仍然在关注iOS、Android和React原生场景，我仍然在研究苹果、谷歌和脸书发布的所有新工具和SDK改进。但是，你知道，技术发展很快，我必须为未来做好准备😌。Sooo，路口观察者万岁！！！有了您的帮助，Web应用程序的性能将会大大提高💚。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="c503" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2019年5月7日</em><a class="ae lb" href="https://www.fabrizioduroni.it/2019/05/08/intersection-observer.html" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://www . fabrizioduroni . it</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>