<html>
<head>
<title>An Overall Look at Unit Testing Svelte Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试细长组件的总体情况</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-overall-look-at-unit-testing-svelte-components-c6d612adf269?source=collection_archive---------11-----------------------#2022-06-26">https://levelup.gitconnected.com/an-overall-look-at-unit-testing-svelte-components-c6d612adf269?source=collection_archive---------11-----------------------#2022-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1ad90589417c1363b3db7ad9124da3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuT0hM7hen68ajeGRpPdnw.png"/></div></div></figure><p id="8ab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">如果你正在为你的项目管理<strong class="ka ir">一系列组件</strong>，单元测试</strong>会被证明是非常有用的。如果您想确保组件在未来更改后仍能正常工作，建议在每次更改后进行单元测试。</p><h1 id="bcde" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">入门—初始设置</h1><p id="dd2f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们将使用<a class="ae lz" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Jest </strong> </a>以及<a class="ae lz" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">测试库</strong> </a>来测试我们的组件。</p><p id="9c2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<code class="fe ma mb mc md b">jest</code>、<code class="fe ma mb mc md b">@testing-library/jest-dom</code>、<code class="fe ma mb mc md b">@testing-library/svelte</code>安装到您项目的<code class="fe ma mb mc md b">devDependencies</code>中。</p><p id="9b64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们为你的组件创建一个<strong class="ka ir">测试文件</strong>。假设我们有一个文本输入组件<code class="fe ma mb mc md b">Input</code>，它接受属性<code class="fe ma mb mc md b">id</code>、<code class="fe ma mb mc md b">class</code>和<code class="fe ma mb mc md b">type</code>。</p><p id="31f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试组件，为它创建一个<code class="fe ma mb mc md b">__test__</code> <strong class="ka ir">文件夹</strong>。Jest会寻找文件名末尾有<code class="fe ma mb mc md b">.test.js</code>或<code class="fe ma mb mc md b">.spec.js</code>的文件。</p><p id="0877" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我是这样构建这些文件的:</p><h2 id="95c0" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">进口</h2><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="92a4" class="me kx iq md b gy my mz l na nb">import { render, fireEvent } from '@testing-library/svelte';<br/>import Component from "../src/Component.svelte";<br/>import SlotTest from "../../../test/slot/SlotTest.svelte";</span></pre><p id="8c14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常你需要<strong class="ka ir">从<code class="fe ma mb mc md b">@testing-library</code>导入</strong>函数<code class="fe ma mb mc md b">render</code>和<code class="fe ma mb mc md b">fireEvent</code>，组件本身，以及一个组件来测试插槽(<code class="fe ma mb mc md b">SlotTest</code>)。</p><p id="ca07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看<code class="fe ma mb mc md b">render</code>和<code class="fe ma mb mc md b">fireEvent</code>是做什么的:</p><h2 id="f7d2" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">渲染-获取组件</h2><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="357b" class="me kx iq md b gy my mz l na nb">const result = render(Component, { props });</span></pre><p id="6f93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">render</code>功能主要是<strong class="ka ir">用指定的<strong class="ka ir">道具</strong>将</strong>组件渲染到<strong class="ka ir">文档体</strong>上。</p><p id="e3f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我会像这样使用<code class="fe ma mb mc md b"><strong class="ka ir">result.container</strong></code>获取元素本身:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="32e3" class="me kx iq md b gy my mz l na nb">const { container } = result;<br/>// OR<br/>const { container } = render(Component, { props };</span></pre><p id="9301" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，使用选择器获取元素本身:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="490e" class="me kx iq md b gy my mz l na nb">const component = container.getElementsByClassName(props.class)[0];</span></pre><p id="6968" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你知道你在搜索什么，建议使用一个<strong class="ka ir">更窄的get方法</strong>。如果没有，您可以使用<code class="fe ma mb mc md b">querySelector</code>或<code class="fe ma mb mc md b">querySelectorAll</code>，但是这些函数<strong class="ka ir">不是很有效</strong>，并且在搜索整个文档时可能需要一些资源。</p><h2 id="cb65" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">火灾事件—测试事件</h2><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="e024" class="me kx iq md b gy my mz l na nb">await fireEvent.click(component)</span></pre><p id="65df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">fireEvent</code>模拟<strong class="ka ir">事件</strong>如点击、输入、更改等。它允许您测试当事件被触发时<strong class="ka ir">会改变</strong>什么。</p><h1 id="bfd1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">创建测试</h1><p id="2a82" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了测试，我们使用了函数<code class="fe ma mb mc md b">describe</code>和<code class="fe ma mb mc md b">it</code> / <code class="fe ma mb mc md b">test</code>。<code class="fe ma mb mc md b">it</code> / <code class="fe ma mb mc md b">test</code>用于<strong class="ka ir">单个</strong>测试用例，而<code class="fe ma mb mc md b">describe</code>用于将<strong class="ka ir">多个</strong>测试用例分组在一起。</p><p id="85c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">describe</code>和<code class="fe ma mb mc md b">it</code> / <code class="fe ma mb mc md b">test</code>需要<strong class="ka ir">两个参数</strong>，第一个是字符串，也就是测试的<strong class="ka ir">名称</strong>。最好把<strong class="ka ir">你正在测试的</strong>放在那个字段。第二个是您将<strong class="ka ir">执行</strong>测试的功能。</p><p id="0d22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的测试通常基于使用<code class="fe ma mb mc md b"><strong class="ka ir">expect</strong></code>函数检查<strong class="ka ir">属性或文本内容</strong>以查看它们是否与期望值匹配。</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="7413" class="me kx iq md b gy my mz l na nb">expect(component.id).toEqual(props.id);</span></pre><p id="d383" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b"><strong class="ka ir">expect</strong></code>用于<strong class="ka ir">以多种不同方式</strong>将中的一个值与另一个值进行比较，并可根据其结果确定该组的<strong class="ka ir">测试结果</strong>。</p><p id="621a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些例子是:</p><p id="9a6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等式(<code class="fe ma mb mc md b">toEqual</code>):</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="9b57" class="me kx iq md b gy my mz l na nb">expect(component.value).toEqual(10);</span></pre><p id="1d32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比较(<code class="fe ma mb mc md b">toBeGreaterThan</code>，<code class="fe ma mb mc md b">toBeLessThan</code>)</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="8b87" class="me kx iq md b gy my mz l na nb">expect(component.value).toBeGreaterThan(5);</span></pre><p id="ab73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">布尔型(<code class="fe ma mb mc md b">toBeTruthy</code>，<code class="fe ma mb mc md b">toBeFalsy</code>)</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="c139" class="me kx iq md b gy my mz l na nb">expect(component.activeElement).toBeTruthy();</span></pre><h2 id="24b2" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">示例测试</h2><p id="66cd" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将所有这些功能放在一起，您将得到如下结果:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="1792" class="me kx iq md b gy my mz l na nb">import { render, fireEvent } from '@testing-library/svelte';<br/>import Component from "../src/Component.svelte";<br/>import SlotTest from "../../../test/slot/SlotTest.svelte";</span><span id="ee4e" class="me kx iq md b gy nc mz l na nb">describe("Component test", () =&gt; {<br/>  const props = {<br/>    id: "component",<br/>    class: "component-custom",<br/>    style: "width: 100%; height: 100%",<br/>  };</span><span id="15fa" class="me kx iq md b gy nc mz l na nb">  it("should render properly", () =&gt; {<br/>    const result = render(Component, { props });<br/>    expect(() =&gt; result).not.toThrow();<br/>  });</span><span id="68b0" class="me kx iq md b gy nc mz l na nb">  it("should render with slots", () =&gt; {<br/>    const result = render(SlotTest, { props: { component: Component, props } });<br/>    expect(() =&gt; result).not.toThrow();<br/>  });</span><span id="2554" class="me kx iq md b gy nc mz l na nb">  // getElementsByClassName, getElementsByTagName, etc may be used<br/>  it("should have correct props", () =&gt; {<br/>    const { container } = render(Component, { props });<br/>    const component = container.getElementsByClassName("component")[0];</span><span id="56c9" class="me kx iq md b gy nc mz l na nb">    expect(component.getAttribute("style").toEqual(props.style);<br/>  });</span><span id="4d72" class="me kx iq md b gy nc mz l na nb">  it("fireEvent", async () =&gt; {<br/>    const { container } = render(Component, { props });<br/>    const component = container.getElementById("component");</span><span id="62d8" class="me kx iq md b gy nc mz l na nb">    expect(component.value).toEqual(1);<br/>    await fireEvent.click(component);<br/>    expect(component.value).toEqual(2);<br/>  });<br/>});</span></pre><p id="9e21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">准备好测试文件后，要开始单元测试，使用<strong class="ka ir">命令</strong></p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="53b2" class="me kx iq md b gy my mz l na nb">jest</span></pre><p id="21e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jest也可以通过使用一个<strong class="ka ir">可选的</strong>参数来设置<strong class="ka ir">目录名</strong>来覆盖你想要的某个<strong class="ka ir">文件或文件夹</strong>。</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="9746" class="me kx iq md b gy my mz l na nb">jest src/components</span></pre><h2 id="1eee" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">提示:预提交</h2><p id="e64f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一旦你设置好测试，我建议你通过设置<strong class="ka ir">预提交</strong>在每次提交前自动运行它们。这将<strong class="ka ir">改进您的工作流程</strong>，并且消除每次您对组件进行修改时运行测试的需要。然而，我们不会在本文中详细介绍它们，但是我会推荐像<code class="fe ma mb mc md b"><a class="ae lz" href="https://pre-commit.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">pre-commit</strong></a></code>这样的库。</p><h1 id="cfd2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="4cf3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一开始，单元测试对你来说似乎势不可挡(对我来说确实是这样)，但是一旦你掌握了窍门，就很容易理解了。由于有了<code class="fe ma mb mc md b">jest</code>库，编写测试也非常<strong class="ka ir">简单</strong>。我希望这能帮助你测试你的苗条UI组件。感谢您的阅读！</p><h2 id="9c3f" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">相关链接</h2><p id="3473" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">请阅读<code class="fe ma mb mc md b">jest</code>和测试库的文档，以获得更多关于单元测试的信息。</p><ul class=""><li id="8379" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">笑话:<a class="ae lz" href="https://jestjs.io/docs/getting-started" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/getting-started</a></li><li id="d230" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">测试库:<a class="ae lz" href="https://testing-library.com/docs/" rel="noopener ugc nofollow" target="_blank">https://testing-library.com/docs/</a></li></ul><p id="4fb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也可以去看看Svelte Society，那里有关于组件、设计模式和单元测试的食谱。</p><ul class=""><li id="d630" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">苗条社会——食谱:<a class="ae lz" href="https://sveltesociety.dev/recipes" rel="noopener ugc nofollow" target="_blank">https://sveltesociety.dev/recipes</a></li></ul></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="ca30" class="kw kx iq bd ky kz ny lb lc ld nz lf lg lh oa lj lk ll ob ln lo lp oc lr ls lt bi translated">分级编码</h1><p id="b80e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae lz" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae lz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae lz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae lz" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="ka ir">升一级正在转型理工大招聘➡️ </strong> <a class="ae lz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>