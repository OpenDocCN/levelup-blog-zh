<html>
<head>
<title>JavaScript Best Practices — Modules, Arrays, and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—模块、数组和对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-modules-arrays-and-objects-cb83de8073d6?source=collection_archive---------3-----------------------#2020-06-10">https://levelup.gitconnected.com/javascript-best-practices-modules-arrays-and-objects-cb83de8073d6?source=collection_archive---------3-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/72f612f39d6dd45ad6bd21c4a591da31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d7DD7uKgFN-rCu9S"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8107" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="1b5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将探讨使用模块、数组和对象的最佳方式。</p><h1 id="aca6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如果我们只有一个导出，那么我们应该使用默认导出</h1><p id="40d7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们的模块只有一个导出，那么我们应该使用默认导出，而不是命名导出。</p><p id="2317" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它更具可读性和可维护性。</p><p id="c884" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0deb" class="mq lf it mm b gy mr ms l mt mu">export const foo = () =&gt; {};</span></pre><p id="20dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a037" class="mq lf it mm b gy mr ms l mt mu">const foo = () =&gt; {}<br/>export default foo;</span></pre><h1 id="1c8f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将所有进口置于非进口声明之上</h1><p id="ff03" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">将所有的<code class="fe mv mw mx mm b">imports</code>放在非导入语句之上，使它们更容易阅读。</p><p id="0246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bb74" class="mq lf it mm b gy mr ms l mt mu">import { foo } from "./foo";</span><span id="b4ab" class="mq lf it mm b gy my ms l mt mu">foo();</span></pre><h1 id="a132" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">多行导入应该像多行数组和对象文字一样缩进</h1><p id="fa53" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有大量的进口，我们不应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8025" class="mq lf it mm b gy mr ms l mt mu">import {foo, bar, baz, qux, longName} from 'foo';</span></pre><p id="9fda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="08af" class="mq lf it mm b gy mr ms l mt mu">import {<br/>  foo,<br/>  bar,<br/>  baz,<br/>  qux,<br/>  longName<br/>} from "foo";</span></pre><h1 id="a668" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要在import语句中使用Webpack Loader语法</h1><p id="d765" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们使用特定于Webpack的语法来导入东西，那么当我们试图切换到另一个模块加载器时就会有问题。</p><p id="d397" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该使用标准语法来避免Webpack特定语法的问题。</p><p id="8cb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cae8" class="mq lf it mm b gy mr ms l mt mu">import barSass from 'css!sass!bar.scss';</span></pre><p id="6a4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="28fa" class="mq lf it mm b gy mr ms l mt mu">import barCss from 'bar.css';</span></pre><h1 id="e7f2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要在导入中添加JavaScript文件扩展名</h1><p id="2398" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不需要向导入添加JavaScript文件扩展名。</p><p id="e2fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们改变扩展名时也会产生问题，</p><p id="e4d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该包括它。</p><p id="7003" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2a50" class="mq lf it mm b gy mr ms l mt mu">import { bar } from './foo.js';</span></pre><p id="e69a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3dc5" class="mq lf it mm b gy mr ms l mt mu">import { bar } from './foo';</span></pre><h1 id="b64b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">迭代器和生成器</h1><p id="343c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">迭代器和生成器是ES6新增的JavaScript特性，允许我们顺序返回项目。</p><h1 id="77c4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用迭代器来操作数组</h1><p id="e7a6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该使用数组方法来操作数组，而不是使用循环。</p><p id="ff48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c788" class="mq lf it mm b gy mr ms l mt mu">let arr = [1, 2, 3];<br/>let result = [];<br/>for (const a of arr) {<br/>  result.push(a ** a);<br/>}</span></pre><p id="3c33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="952c" class="mq lf it mm b gy mr ms l mt mu">const arr = [1, 2, 3];<br/>const result = arr.map(a =&gt; a ** a);</span></pre><p id="2ff1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它更短，没有环。</p><p id="b6be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个原因是我们不想改变数组条目。</p><p id="22ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="49fd" class="mq lf it mm b gy mr ms l mt mu">let arr = [1, 2, 3];<br/>for (let i = 0; i &lt; arr.length; i++) {<br/>  arr[i] = arr[i] ** arr[i];<br/>}</span></pre><p id="0bff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们遍历它时，我们改变<code class="fe mv mw mx mm b">arr</code>的每个条目。</p><p id="9419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们可以避免突变，那么我们应该这样做。</p><p id="20e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一些我们可以用来操作数组的数组方法:</p><ul class=""><li id="1f96" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">map</code> —将条目从一个映射到另一个，并返回包含映射条目的数组</li><li id="87a4" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">every</code> —检查每个数组条目是否满足某些条件</li><li id="dad2" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">find</code> —返回满足某些条件的第一个条目</li><li id="e861" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">findIndex</code> —返回满足某些条件的第一个条目的索引</li><li id="f7f2" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">reduce</code> —将数组条目组合成一个值并返回</li><li id="62b3" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">some</code> —检查一些数组条目是否满足给定的条件</li></ul><p id="f338" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以用这些方法获得对象键和值:</p><ul class=""><li id="871c" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">Object.keys</code> —获取对象自己的字符串键</li><li id="5119" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">Object.values</code> —获取对象的自身值</li><li id="8f2e" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mv mw mx mm b">Object.entries</code> —获取自己的对象键值对</li></ul><h1 id="5708" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用发电机</h1><p id="9e41" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们在构建中以ES5为目标，那么我们不应该使用生成器，因为它们不能很好地移植。</p><h1 id="3de7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正确定义空间生成器</h1><p id="3b25" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该如下分隔函数定义:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b102" class="mq lf it mm b gy mr ms l mt mu">function* foo() {<br/>  // ...<br/>}</span></pre><h1 id="2cb3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象属性</h1><p id="4b9f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们访问对象属性，需要注意一些事情。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/5b141ac7ac6f99e6872eb60577f98a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*beCnQ02F8M86ta2o"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@tcooper86?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·库珀</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4076" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">访问属性时使用点标记法</h1><p id="ec60" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们访问作为有效JavaScript标识符的对象属性时，应该使用点符号。</p><p id="1a2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="933c" class="mq lf it mm b gy mr ms l mt mu">const bar = foo['bar'];</span></pre><p id="9d71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8113" class="mq lf it mm b gy mr ms l mt mu">const bar = foo.bar;</span></pre><h1 id="3acc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9bb3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们只导出一个模块的一个成员，我们应该有一个默认的导出。</p><p id="6ce0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该使用数组方法来操作数组，而不是使用循环。</p><p id="8977" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要操作对象的键和值，我们可以用一些<code class="fe mv mw mx mm b">Object</code>静态方法得到它们。</p><p id="27ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，尽可能使用点符号来访问对象属性。</p></div></div>    
</body>
</html>