<html>
<head>
<title>Blurred Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模糊的图像</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/blurred-images-75b69e6ece40?source=collection_archive---------10-----------------------#2020-06-26">https://levelup.gitconnected.com/blurred-images-75b69e6ece40?source=collection_archive---------10-----------------------#2020-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dcd0d6cb9a7a9af2a4f35ee7f3032e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mpy5xyD8y2ya0f9zEt9HOQ.png"/></div></div></figure><p id="ca97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，在C语言中完成一个函数时，<a class="ae kw" href="https://cs50.harvard.edu/x/2020/psets/4/filter/less/" rel="noopener ugc nofollow" target="_blank">我的任务</a>是平均位图中每个像素及其周围像素的红色、绿色和蓝色值，以使图像看起来模糊。一个名为“image”的二维数组通过指定的高度和宽度被传递到函数中，它必须循环转换每个像素。我必须找到的平均值是循环中当前正在转换的像素的一行和一列中每个像素的颜色值。</p><p id="ffc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着，如果像素在二维数组的一个角上(例如，想象一个四列长和四列宽的正方形)，那么平均值将是四个像素的值。如果像素在边上，那么它将是六个像素。如果它既不是角也不是边，那么它将是九个像素(包括具有要转换的值的像素、它左边的像素、它右边的像素、它正下方的像素、它上方的像素以及在它上面和下面的行中与左边和右边成对角线的像素，在原始图像内形成一个3×3的正方形)。</p><p id="82e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">制作副本</strong></p><p id="b3e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我要做的第一件事是创建一个空的嵌套数组，它将存储稍后用于转换图像的值。我必须这样做的原因是，如果我直接转换数组中的颜色值，那么随着循环的进行，取的平均值将是这些转换后的值，而不是原始值。下面的第三个数组长度为3，因为这是存储新颜色值的位置，红色的平均量在0位置，蓝色的平均量在1位置，绿色的平均量在2索引位置。在函数结束时，一旦finalArray充满了取自平均值的新值，就会再次循环“image ”,存储在finalArray中的颜色值将取代原始值。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="cbc1" class="lg lh iq lc b gy li lj l lk ll">int finalArray [height][width][3];</span></pre><p id="7286" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">回环回环</strong></p><p id="b650" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数从一个初始嵌套循环开始；外部“for循环”的设置如下:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7312" class="lg lh iq lc b gy li lj l lk ll">for (int i = 0; i &lt; height; i++)</span></pre><p id="53c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">内部循环开始于:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2273" class="lg lh iq lc b gy li lj l lk ll">for (int p = 0; p &lt; width; p++)</span></pre><p id="c8b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">内部循环允许在外部循环移动到下一列之前循环行中的每个项目。</p><p id="bfe1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">指定条件</strong></p><p id="ccf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过反复试验，我将问题分解为三个主要的if/else语句，其中嵌套了更多的if/else if语句。</p><p id="a34c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个条件是</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="22af" class="lg lh iq lc b gy li lj l lk ll">if (p == 0)</span></pre><p id="d0a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，还有另外三种情况:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6abd" class="lg lh iq lc b gy li lj l lk ll">if (i == 0)</span><span id="bd4c" class="lg lh iq lc b gy lm lj l lk ll">else if (i == height - 1)</span><span id="83fa" class="lg lh iq lc b gy lm lj l lk ll">else if (0 &lt; i &lt; height - 1)</span></pre><p id="e709" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果' p '和' I '都是零，这意味着循环在左上角。如果' p '是零，而' I '是高度- 1，那么循环在左下角。如果“p”是零，而“I”大于1但小于高度减1，则该循环在顶部边缘。</p><p id="a63f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个模式在另外两个条件下继续(p ==下一个的宽度- 1，0 &lt; p &lt; width - 1 for the one after that) and their own nested if/else if statements to cover the whole bitmap.</p><p id="a0a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">This is the first ‘if’ statement, with all of the variables having been initialized earlier on. The variables ‘middleRed’, ‘middleBlue’, and ‘middleGreen’ are the same for all of the conditions here and later in the function, because they are for the current pixel in the loop. That is why they come before the first ‘if’ statement — so they have a wider scope.</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b5f4" class="lg lh iq lc b gy li lj l lk ll">middleRed = image[i][p].rgbtRed;<br/>middleBlue = image[i][p].rgbtBlue;<br/>middleGreen = image[i][p].rgbtGreen;</span><span id="a000" class="lg lh iq lc b gy lm lj l lk ll">if (p == 0)<br/>            {<br/>                rightRed = image[i][p + 1].rgbtRed;<br/>                rightBlue = image[i][p + 1].rgbtBlue;<br/>                rightGreen = image[i][p + 1].rgbtGreen;</span><span id="af1e" class="lg lh iq lc b gy lm lj l lk ll">bottomRightRed = image[i + 1][p + 1].rgbtRed;<br/>                bottomRightBlue = image[i + 1][p + 1].rgbtBlue;<br/>                bottomRightGreen = image[i + 1][p + 1].rgbtGreen;</span><span id="a7f1" class="lg lh iq lc b gy lm lj l lk ll">topRightRed = image[i - 1][p + 1].rgbtRed;<br/>                topRightBlue = image[i - 1][p + 1].rgbtBlue;<br/>                topRightGreen = image[i - 1][p + 1].rgbtGreen;</span><span id="21b8" class="lg lh iq lc b gy lm lj l lk ll">belowRed = image[i + 1][p].rgbtRed;<br/>                belowBlue = image[i + 1][p].rgbtBlue;<br/>                belowGreen = image[i + 1][p].rgbtGreen;</span><span id="7e5f" class="lg lh iq lc b gy lm lj l lk ll">aboveRed = image[i - 1][p].rgbtRed;<br/>                aboveBlue = image[i - 1][p].rgbtBlue;<br/>                aboveGreen = image[i - 1][p].rgbtGreen;</span><span id="1368" class="lg lh iq lc b gy lm lj l lk ll">//top left corner<br/>                if (i == 0)<br/>                {<br/>                    averageRed = (middleRed + rightRed + bottomRightRed + belowRed) / 4.0;<br/>                    averageBlue = (middleBlue + rightBlue + bottomRightBlue + belowBlue) / 4.0;<br/>                    averageGreen = (middleGreen + rightGreen + bottomRightGreen + belowGreen) / 4.0;<br/>                }</span><span id="9f07" class="lg lh iq lc b gy lm lj l lk ll">//bottom left corner<br/>                else if (i == height - 1)<br/>                {</span><span id="ca8b" class="lg lh iq lc b gy lm lj l lk ll">averageRed = (middleRed + rightRed + topRightRed + aboveRed) / 4.0;<br/>                    averageBlue = (middleBlue + rightBlue + topRightBlue + aboveBlue) / 4.0;<br/>                    averageGreen = (middleGreen + rightGreen + topRightGreen + aboveGreen) / 4.0;<br/>                }</span><span id="a80c" class="lg lh iq lc b gy lm lj l lk ll">//left side edge<br/>                else if (0 &lt; i &lt; height - 1)<br/>                {<br/>                    averageRed = (middleRed + rightRed + bottomRightRed + topRightRed + aboveRed + belowRed) / 6.0;<br/>                    averageBlue = (middleBlue + rightBlue + bottomRightBlue + topRightBlue + aboveBlue + belowBlue) / 6.0;<br/>                    averageGreen = (middleGreen + rightGreen + bottomRightGreen + topRightGreen + aboveGreen + belowGreen) / 6.0;<br/>                }</span><span id="ed47" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="94e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Then, later on in the function, the averageRed, averageBlue, and averageGreen values for the pixel are rounded and added to finalArray.</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d139" class="lg lh iq lc b gy li lj l lk ll">finalArray[i][p][0] = round(averageRed);<br/>finalArray[i][p][1] = round(averageBlue);<br/>finalArray[i][p][2] = round(averageGreen);</span></pre><p id="f8ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">最终循环</strong></p><p id="63e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在所有“image”循环完毕且“finalArray”已满后，将运行与前一个循环具有相同结构的另一个嵌套循环，以将“image”中的红色、蓝色和绿色值设置为等于存储在finalArray中相应位置的平均值。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="c3a5" class="lg lh iq lc b gy li lj l lk ll">for (int v = 0; v &lt; height; v++)</span><span id="8ecb" class="lg lh iq lc b gy lm lj l lk ll">{</span><span id="80a7" class="lg lh iq lc b gy lm lj l lk ll">for (int l = 0; l &lt; width; l++)</span><span id="b188" class="lg lh iq lc b gy lm lj l lk ll">{</span><span id="258e" class="lg lh iq lc b gy lm lj l lk ll">image[v][l].rgbtRed = finalArray[v][l][0];<br/>            image[v][l].rgbtBlue = finalArray[v][l][1];<br/>            image[v][l].rgbtGreen = finalArray[v][l][2];</span><span id="824f" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="0f6a" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="ee9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧啊。你现在有一个模糊的图片。但这次是故意的。</p></div></div>    
</body>
</html>