# 了解 Laravel 宏

> 原文：<https://levelup.gitconnected.com/understanding-laravel-macros-e2f493484a38>

![](img/0d103ba0730a52871b917343342f5705.png)

Laravel 宏允许我们向 Laravel 核心组件或类添加自定义功能。换句话说，它们允许我们扩展 Laravel 类。

如果您以前从未听说过 Laravel 宏，您可能会疑惑:为什么我们需要一种不同的方法来扩展类，而不是默认的 PHP 对象继承方法？在这篇文章中，我将尝试向您展示是什么让 Laravel 宏如此独特，如何使用它们，以及它们如何在内部工作。

# 定义宏

假设您正在构建一个非常依赖于将数据导出为 CSV 文件的应用程序。如果我们能像这样做，岂不是很酷:‌

返回一个响应，其中包含根据提供的参数生成的 CSV 文件。

返回一个响应，其中包含根据提供的参数生成的 CSV 文件。

当然，Laravel 没有这个功能，它太具体了，把所有东西都装在 Laravel 里不好。

在实现 Laravel 宏之前，您需要确保您想要扩展的类使用了 trait。这就是你如何知道你可以使用宏来扩展一个类。在我们的例子中，我们将扩展`Illuminate\\Http\\Response`类，它肯定使用了 trait。因此，让我们在应用程序中添加新的功能。

这将使用提供的标题和行编写一个新的 CSV，并将其附加到响应中。

这将使用提供的标题和行编写一个新的 CSV，并将其附加到响应中。

# 在哪里定义宏？

宏可以在任何你想定义的地方定义，只是在你使用它之前要确保它已经被定义了。在相关的服务提供者中定义宏是一个很好的实践，但是如果你认为你的服务提供者在不久的将来会变得臃肿，你可以只为宏编写一个新的服务提供者。记得在`config/app.php`注册。

# 混合蛋白

您还可以将相关的宏包装成类，并使用`::mixin`方法扩展一个宏类。这个方法有两个参数:`$mixin`，一个是您想要混合的类的实例，另一个是`$replace`，一个布尔值，默认为 true，表明它是否应该覆盖这个宏，如果它之前已经声明过的话。

使用我们的例子，如果我们计划添加更多的宏来以不同的格式导出数据，我们可以创建一个新的类`ResponseMacros`，在这里我们可以定义我们想要添加到响应类的所有宏。另一个好的实践是将这些类存储在`app/Mixins`中。

这里有一个非常重要的注意事项:所有方法都应该返回一个[闭包或可调用的](https://stackoverflow.com/a/40942212)值。

使用 mixin 方法:

Laravel 将自动使类中所有公共的和受保护的方法作为宏可用。

# 解释宏背后的魔法

如果你像我一样，无法忍受好奇心，你可能会想“这听起来很酷，但它是如何工作的呢？怎么可能？”我不得不说，开始使用宏时，你不需要知道所有这些是如何工作的，但我会尽力向你解释。

如果你向下浏览到`Macroable`特征，你会发现所有这些神奇之处都包含在仅仅 117 行代码中(截至 2019 年 2 月 17 日)，所以让我们开始吧。

您首先会看到的是`$macros`属性的声明。

Laravel 用它来存储每个类的宏。请记住，所有这些都是直接注入到使用 trait 的类中，因此属性将驻留在每个类中，并且它们永远不会交叉。

其次，我们有`macro`功能。

这是我们在声明新宏时使用的函数。我们以前用过。它存储在$macros 数组中传递的匿名函数，使用作为键传递的名称。

之后，是`mixin`方法。

它使用 PHP 反射 API 来检查提供的对象`$mixin`，并提取 object 类中的所有公共或受保护的方法。Laravel 将遍历列表，使每个方法都可以访问，并使用方法名注册每个返回的可调用或闭包。如果你注意到，如果你不表示尊重以前注册的宏，Laravel 将覆盖它们。

然后，就是`hasMacro`法了。

一个很简单的方法。它检查一个宏是否已经注册。

好了，我们现在要深入了。

宏表特征中还有两个方法我们还没有谈到:`__call`和`__callStatic`。在 PHP 中，它们都被认为是[神奇的方法，这意味着你不能在你的任何类中拥有这些名字的函数，除非你想要与它们相关的神奇功能。](https://www.php.net/manual/en/language.oop5.magic.php)

你可以在 PHP 手册[中读到更多关于它们的内容。但本质上你应该知道的是:](https://www.php.net/manual/en/language.oop5.overloading.php#language.oop5.overloading.methods)

*   在对象上下文中调用不可访问的方法时触发。
*   `[__callStatic()](https://www.php.net/manual/en/language.oop5.overloading.php#object.callstatic)`在静态上下文中调用不可访问的方法时触发。

但是，**不可接近**是什么意思呢？根据 PHP 手册，这意味着那些方法没有被声明或者在你试图使用它们的范围内是不可见的。

用我们的例子，这意味着当我们写的时候

或者

我们实际上分别调用了`__call`和`__callStatic`，因为`Illuminate\\Http\\Response`类没有定义`csv`方法。拉勒维尔为我们处理所有的事情。

Laravel 是如何实现那些方法的？让我们看看。

在这两种情况下，它开始检查我们试图使用的方法是否注册为宏。如果没有，它将抛出一个异常。如果是这样，Laravel 将从$macros 数组中取出它。

现在 Laravel 知道我们注册了一个宏用于那些情况，它将检查这个宏是否是一个闭包。如果没有，它会认为它是可调用类型，然后用所有发送的参数执行并返回。但如果是这样的话:

*   我们从一个对象上下文中调用宏，__call()，就像`$object->macroName()`，它将闭包绑定到`$this`范围和我们正在扩展的类。在我们的例子中，如果我们创建一个新的响应实例。当调用`csv()`时，`$this`关键字将对该实例求值，并且该函数也可以访问响应类中的所有内容。
*   或者我们从静态上下文中调用宏，__callStatic()，就像`ClassName::macroName()`一样，它将闭包只绑定到类，对象范围将为空。在宏中不引用`$this`是合理的，因为它是未绑定的。

Laravel 宏是扩展框架类的传统方式的一个很好的替代方式，我希望你很快会使用它们。

感谢阅读。祝你好运。

*原载于 2020 年 2 月 17 日*[*https://leninpaulino . dev*](https://leninpaulino.dev/understanding-laravel-macros/)*。*