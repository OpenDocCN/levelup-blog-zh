<html>
<head>
<title>Pitfalls of Templates type deduction in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中模板类型演绎的陷阱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pitfalls-of-templates-type-deduction-in-c-272d66bc75aa?source=collection_archive---------10-----------------------#2020-05-25">https://levelup.gitconnected.com/pitfalls-of-templates-type-deduction-in-c-272d66bc75aa?source=collection_archive---------10-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b2beab597c1c8d34bee759394ba486ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WLtDmtYjN68qCdYj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@fatosi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法托斯Bytyqi </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3fa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">C++是一种严格类型化的语言。我们必须使用特定的类型声明每个变量、函数参数和函数返回值。如果预期的类型和实际使用的类型不兼容，它就不会编译。这带来了一个好处，即语言本身确保了“类型安全”,以防止开发人员犯将错误的对象、参数分配给错误的函数、运算符的错误。此外，这种检查是在编译时静态完成的，因此在运行时不会增加额外的性能成本。</p><p id="a2ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这种严格类型化的方面也使得c++不太灵活。假设你喜欢提供一个函数作为库，函数带两个输入参数，计算总和并返回。因为您无法预测库的用户在其上下文中需要的特定类型，所以您无法实现与可能需要的类型兼容的函数。此外，即使您确切地知道您的库需要支持哪些类型，您也需要准备多个采用不同类型(int、void、string、custom class等)的函数。在大多数情况下，该函数具有适用于所有类型的通用行为。因此，也会有很多重复。</p><p id="8343" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，C++编程语言提供了一个强大的特性，叫做模板。使用模板，我们可以实现一个通用函数或一个可以用于许多不同类型的类。事实上，模板在库开发中非常流行，许多C++标准库都在内部使用模板。</p><p id="6c87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将列举一些你在使用C++模板时可能会遇到的陷阱或意外。</p><h1 id="1444" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">简单的例子</h1><p id="2911" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">简单的模板函数定义和用法如下图所示，</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d62e" class="mq lf it mm b gy mr ms l mt mu">template &lt;class T&gt;<br/>void function(T arg) {<br/>// do something with arg<br/>}</span><span id="daa6" class="mq lf it mm b gy mv ms l mt mu">int main() {<br/>  <strong class="mm iu">int</strong> a = 1;<br/>  function(a);  <br/>}</span><span id="01c2" class="mq lf it mm b gy mv ms l mt mu"># # # Instantiated function # # #<br/># void function(<strong class="mm iu">int</strong> arg) {<br/>#  // do something with arg<br/># }</span></pre><p id="a9eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<em class="mw">函数(a) </em>为编译器读取的<em class="mw"> </em>时，<em class="mw"> </em>编译器从传递给<em class="mw">函数的变量<em class="mw"> a </em>中推导出<em class="mw"> T </em>的类型。</em>在这种情况下，<em class="mw"> T </em>推导为<em class="mw"> int。</em>结果，<em class="mw"> void function(int arg) </em>被实例化。</p><p id="cb31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">推演结果一点都不意外。现在，让我们看看下面的下一个案例，</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ad5e" class="mq lf it mm b gy mr ms l mt mu">template &lt;class T&gt;<br/>void function(T arg) {<br/>// do something with arg<br/>}</span><span id="673d" class="mq lf it mm b gy mv ms l mt mu">int main() {<br/>  int a = 1; <br/>  <strong class="mm iu">const int &amp;</strong> ref_to_const_int = a;<br/>  function(ref_to_const_int);<br/>}</span><span id="38f0" class="mq lf it mm b gy mv ms l mt mu"># # # Instantiated function # # #<br/># void function(<strong class="mm iu">int</strong> arg) {<br/>#  // do something with arg<br/># }</span></pre><p id="389a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，变量<em class="mw"> ref_to_const_int </em>被传递给了<em class="mw">函数。ref_to_const_int </em>是对<em class="mw"> const int </em>的引用(即<em class="mw"> const int &amp; </em>)。给定第一个例子的结果，很自然的猜测T会推导为<em class="mw"> const int &amp; </em>，与<em class="mw"> ref_to_const_int相同。</em>但是，<strong class="ki iu"> T会推导为“<em class="mw"> int”，</em>而不是<em class="mw">“const int&amp;”。</em> </strong>所以实例化的函数看起来和之前一模一样:<em class="mw"> void function(int arg)。</em></p><h1 id="c0bc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">自动类型“衰变”</h1><p id="ba0c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">发生这种意外是因为编译器在实例化<em class="mw">函数</em>时对传递的类型进行了某种转换。当我们将<em class="mw"> const int &amp; </em>参数传递给<em class="mw">函数</em>时，在推导<em class="mw"> T </em>的类型时，编译器将原参数中的“<em class="mw"> const </em>”和“<em class="mw"> &amp; </em>”去掉，将<em class="mw"> T </em>推导为“<em class="mw"> int </em>”。编译器的这种自动类型转换称为“衰减”。只有在将函数参数声明为按值传递时，才应用此规则。在我们的例子中，我们的<em class="mw">函数</em>声明采用<em class="mw"> T arg </em>，也就是像下面这样通过值传递，所以编译器应用了衰减规则。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0098" class="mq lf it mm b gy mr ms l mt mu">template &lt;class T&gt;<br/>void function(T arg) {  // <strong class="mm iu">pass-by-value </strong>        <br/>// do something with arg<br/>}</span></pre><p id="1f86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">衰减模式及其条件是，</p><p id="b70d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当将函数参数声明为按值传递时，</p><ol class=""><li id="fa81" class="mx my it ki b kj kk kn ko kr mz kv na kz nb ld nc nd ne nf bi translated">任何顶级引用都被删除:<em class="mw">int&amp;</em>-&gt;<em class="mw">int</em>。</li><li id="c3d6" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">数组类型转换为指针类型:<em class="mw">char</em>T46【10】-&gt;<em class="mw">char</em>*。</li><li id="db87" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">函数转换成函数指针类型:<em class="mw">int(int)</em>-&gt;-T52】int(*)(int)。</li><li id="3004" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">(如果2，3不适用)任何顶级cv限定符(<em class="mw"> const </em>，<em class="mw"> volatile </em>)都被删除:<em class="mw">const int</em>-&gt;<em class="mw">int，volatile int - &gt; int。</em></li></ol><p id="6572" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的案例中，应用了规则1和4。因此，编译器在实例化模板时将<em class="mw"> const int &amp; </em>转换为<em class="mw"> int </em>。</p><p id="a9b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看另一个衰变模式的例子。这次我们关注“数组类型到指针类型”衰减模式，</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="435f" class="mq lf it mm b gy mr ms l mt mu">template &lt;class T&gt;<br/>void function(T arg) {  // <strong class="mm iu">pass-by-value</strong><br/>// do something with arg<br/>}</span><span id="5187" class="mq lf it mm b gy mv ms l mt mu">int main() {<br/>  <strong class="mm iu">const char const_array[7]</strong> = "Hello!"; <br/>  function(str);<br/>}</span><span id="b8b4" class="mq lf it mm b gy mv ms l mt mu"># # # Instantiated function # # #<br/># void function(<strong class="mm iu">const</strong> <strong class="mm iu">char*</strong> arg) {  // Not const char[7]<br/>#  // do something with arg<br/># }</span></pre><p id="98a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，<em class="mw"> const_array </em>即<em class="mw"> const char [7] </em>类型被传递给了<em class="mw">函数</em>。因为没有参考限定词，衰变纲型1不适用。然后，由于它是一个数组类型，衰减模式2被应用，该模式将<em class="mw"> const char [7] </em>转换为<em class="mw"> const char* </em>。并且因为它不是函数，所以衰减模式3被跳过。最后，由于衰减模式2适用，衰减模式4也被跳过。因此，编译器将T <em class="mw"> </em>的类型推导为<em class="mw"> const char* </em>。这样，实例化的函数就是<em class="mw"> void函数(</em><strong class="ki iu"><em class="mw">const</em></strong><em class="mw"/><strong class="ki iu"><em class="mw">char *</em></strong><em class="mw">arg)</em>。</p><h1 id="dc94" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">防止自动类型衰减</h1><p id="ae24" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了避免编译器的这种自动类型衰减，可以将函数参数声明为按引用传递，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6ff4" class="mq lf it mm b gy mr ms l mt mu">template &lt;class T&gt;<br/>void function(T&amp; arg) {  // <strong class="mm iu">pass-by-reference</strong><br/>// do something with arg<br/>}</span><span id="6f40" class="mq lf it mm b gy mv ms l mt mu">int main() {<br/>  int a = 1; <br/>  const int &amp; ref_to_const_int = a;<br/>  function(ref_to_const_int);<br/>}</span><span id="de3a" class="mq lf it mm b gy mv ms l mt mu"># # # Instantiated function # # #<br/># void function(<strong class="mm iu">const int&amp;</strong> arg) {<br/>#  // do something with arg<br/># }</span></pre><p id="2c39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于函数参数被声明为<em class="mw"> T &amp; </em>(按引用传递)，因此不会应用衰减模式(记住，衰减仅在函数将其参数声明为按值传递时发生)。推导出的T的类型为<em class="mw"> const int </em>。因此编译器实例化的函数是<em class="mw"> void函数(const int &amp; arg)。</em></p><p id="00e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也能防止其他的腐烂模式。你可以在下面看到一个数组类型的例子。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="29b1" class="mq lf it mm b gy mr ms l mt mu">template &lt;class T&gt;<br/>void function(T&amp; arg) {  // <strong class="mm iu">pass-by-reference</strong><br/>// do something with arg<br/>}</span><span id="0682" class="mq lf it mm b gy mv ms l mt mu">int main() {<br/>  <strong class="mm iu">const char const_char_array[7]</strong> = "Hello!"; <br/>  function(<strong class="mm iu">const_char_array</strong>);<br/>}</span><span id="79e8" class="mq lf it mm b gy mv ms l mt mu"># # # Instantiated function # # #<br/># void function(<strong class="mm iu">const char(&amp;)[7]</strong> arg) {<br/>#  // do something with arg<br/># }</span></pre><p id="7632" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">推导出的T的类型是<em class="mw"> const char[7]，</em>不是<em class="mw"> const char*。</em>因此编译器实例化的函数是<em class="mw"> void函数(const char( &amp; )[7] arg)。</em></p><p id="1f45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这种类型的衰退行为看起来像是必须避免的负面事情，但它也可能是一种期望的行为，这取决于具体情况。例如，假设您想实现一个函数，它接受两个相同类型的输入，将它们打包成一个std::pair <t t="">并返回它的一个副本。这个模板如下所示。如您所见，它要求两个输入具有相同的t类型。</t></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6d8d" class="mq lf it mm b gy mr ms l mt mu">template &lt;class T&gt;<br/>std::pair&lt;T, T&gt; make_pair_function(T arg1, T arg2) {<br/>  return std::pair&lt;T, T&gt;(arg1, arg2);<br/>}</span></pre><p id="db42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你喜欢传递两个数组给<em class="mw"> make_pair_function。</em>如果您将函数参数声明为按值传递，即使您传递两个长度不同的数组(因此，它们是不同的类型)，由于编译器的自动衰减，这两种类型都被推导为<em class="mw"> const char* </em>。这就是为什么这是有效的，编译没有错误。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ceb7" class="mq lf it mm b gy mr ms l mt mu">template &lt;class T&gt;<br/>std::pair&lt;T, T&gt; make_pair_function(T arg1, T arg2) {<br/>  return std::pair&lt;T, T&gt;(arg1, arg2);<br/>}</span><span id="b732" class="mq lf it mm b gy mv ms l mt mu">int main() {<br/>  <strong class="mm iu">const char const_array1[7]</strong> = "Hello!";</span><span id="8c3b" class="mq lf it mm b gy mv ms l mt mu"><strong class="mm iu">  const char const_array2[8]</strong> = "World!!";</span><span id="e7e8" class="mq lf it mm b gy mv ms l mt mu">make_pair_function(const_array1<strong class="mm iu">, </strong>const_array2);<br/>}</span><span id="7c43" class="mq lf it mm b gy mv ms l mt mu"># # # Instantiated function # # #<br/>#  std::pair&lt;<strong class="mm iu">const char*</strong>, <strong class="mm iu">const char*</strong>&gt;<br/>#   function(<strong class="mm iu">const char*</strong> arg1, <strong class="mm iu">const char*</strong> arg2) {<br/>#  <!-- -->return std::pair&lt;<strong class="mm iu">const char*</strong>, <strong class="mm iu">const char*</strong>&gt;(a, b);<br/># }</span></pre><p id="cbfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您将函数参数声明为按引用传递，并将两个数组传递给<em class="mw"> make_pair_function </em>，它将不会编译。这是因为编译器将arg1和arg2的类型推断为不同的类型(<em class="mw"> const char[7] </em>，<em class="mw"> const char[8] </em>)，而没有模板<em class="mw"> make_pair_function </em>可以让<em class="mw"> </em>可以<em class="mw"> </em>接受两种不同的类型作为输入参数，或者没有非模板<em class="mw"> make_pair_function </em>可以接受(<em class="mw"> const char[7] </em>，<em class="mw"/></p><p id="4fce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这就是为什么自动类型衰减可以是有用的功能取决于情况。实际上，在标准库中定义了一个名为<em class="mw"> std::decay </em>的实用函数，这个函数<em class="mw"> </em>通过编译器有意地强制类型decay的行为。重要的是要意识到模板类型演绎下发生了什么，并根据需要进行调整。</p><h1 id="16ef" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="880f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这篇文章中，我解释了C++中模板类型演绎的陷阱。我解释了编译器自动类型衰减转换的概念，以及如何防止它。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="9d1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[1]:模板，<a class="ae kf" href="https://en.cppreference.com/w/cpp/language/templates" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/templates</a></p><p id="9cc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2]:简历限定词，<a class="ae kf" href="https://en.cppreference.com/w/cpp/language/cv" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/cv</a></p><p id="0278" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[3]: <em class="mw"> std::衰变，</em>T28】https://en.cppreference.com/w/cpp/types/decay</p></div></div>    
</body>
</html>