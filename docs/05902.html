<html>
<head>
<title>OOD in Python — Designing Classes with a Single Responsibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的OOD设计具有单一职责的类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ood-designing-classes-with-a-single-responsibility-80b32040ebeb?source=collection_archive---------8-----------------------#2020-10-11">https://levelup.gitconnected.com/ood-designing-classes-with-a-single-responsibility-80b32040ebeb?source=collection_archive---------8-----------------------#2020-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8994" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Sandi Metz写的《实用的面向对象设计》是一部关于永恒的和基本的OOD知识的杰作。为了加深理解，我总结了每一章，并用Python重写了样本代码。当然，如果你想得到更多的细节，请得到这本书。</p><p id="d067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是第2章“设计具有单一职责的类”的总结。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/35f33978b4f3559e44b7db12ccd21fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Es4ltH-AHKmKuUvVLjzPlQ.png"/></div></div></figure><p id="e6a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/shotin93/object-oriented-design-in-python" rel="noopener ugc nofollow" target="_blank">https://github . com/shotin 93/object-oriented-design-in-python</a></p><h1 id="ca8f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">决定什么属于一个类</h1><p id="2c24" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这一章的重点是如何决定什么属于类。</p><p id="f793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要将方法分类。然而，我们不能在项目的早期正确地做到这一点，因为我们的应用程序需要在未来改变。</p><p id="d70f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们必须将代码组织得易于更改。要做到这一点，代码应该遵循真实的原则；</p><ul class=""><li id="2525" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">透明:变化的结果应该在正在变化的代码中显而易见，并且在远处的代码依赖于它</li><li id="8280" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">合理:任何改变的成本都应该与改变所获得的收益成比例</li><li id="e2e1" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">可用:现有代码应该在新的和意想不到的环境中可用</li><li id="bb3c" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">示范性的:代码本身应该鼓励那些改变它的人保持这些品质</li></ul><p id="41df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真实原则确保每个类都有一个单一的责任。</p><h1 id="15dd" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建具有单一职责的类</h1><p id="488b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">代码示例是关于自行车及其齿轮的。齿轮有齿圈和轮齿，我们可以用齿圈除以齿轮的轮齿来计算传动比。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="923e" class="mu kz iq mq b gy mv mw l mx my">chainring = 52<br/>cog = 11<br/>ratio = chainring / float(cog)<br/>print(ratio) #4.7272727272727275</span><span id="7cc5" class="mu kz iq mq b gy mz mw l mx my">chainring = 30<br/>cog = 27<br/>ratio = chainring / float(cog)<br/>print(ratio) #1.1111111111111112</span></pre><p id="076b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你在代码中写东西时，名词是类的候选者，在这个例子中是自行车和齿轮。Bicycle可以是类，但是在这个例子中它没有数据或行为。另一方面，齿轮有，如链环，齿轮和比率，所以我们应该创建齿轮类。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="4125" class="mu kz iq mq b gy mv mw l mx my">class Gear:<br/>  def __init__(self, chainring, cog):<br/>    self.chainring = chainring<br/>    self.cog = cog</span><span id="3153" class="mu kz iq mq b gy mz mw l mx my">  def ratio(self):<br/>    return self.chainring / float(self.cog)</span><span id="ad2d" class="mu kz iq mq b gy mz mw l mx my">print(Gear(52, 11).ratio()) #4.7272727272727275<br/>print(Gear(30, 27).ratio()) #1.1111111111111112</span></pre><p id="db07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们计算了齿轮比，但骑自行车的人也想知道齿轮英寸。公式如下:</p><ul class=""><li id="6caa" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">齿轮英寸=车轮直径*齿轮比</li><li id="c11c" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">车轮直径=轮辋直径+两倍轮胎直径</li></ul><p id="3c3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以很容易地添加这个新行为:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="c96a" class="mu kz iq mq b gy mv mw l mx my">class Gear:<br/>  def __init__(self, chainring, cog):<br/>    self.chainring = chainring<br/>    self.cog = cog</span><span id="ea93" class="mu kz iq mq b gy mz mw l mx my">  def ratio(self):<br/>    return self.chainring / float(self.cog)</span><span id="0052" class="mu kz iq mq b gy mz mw l mx my">  def gear_inches(self):<br/>    return self.ratio() * (self.rim + (self.tire * 2))</span><span id="ca06" class="mu kz iq mq b gy mz mw l mx my">print(Gear(52, 11, 26, 1.5).gear_inches()) #32.22222222222222<br/>print(Gear(52, 11, 24, 1.25).gear_inches()) #29.444444444444446</span></pre><p id="a61c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们还是想知道比率，代码导致bug。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="5864" class="mu kz iq mq b gy mv mw l mx my">print(Gear(52, 11).ratio()) #TypeError: __init__() missing 2 required positional arguments: 'rim' and 'tire'</span></pre><p id="e9e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于这些，这是组织代码的最佳方式吗？如果你知道这个应用程序不会永远改变，这就足够了。然而，大多数应用程序都会改变，你也不知道会发生什么变化。</p><h1 id="08da" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">编写拥抱变化的代码</h1><p id="4e34" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这里有一些众所周知的技术，您可以使用它们来创建拥抱变化的代码。</p><h2 id="82db" class="mu kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">依靠行为，而不是数据</h2><p id="c809" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir">隐藏实例变量</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="f765" class="mu kz iq mq b gy mv mw l mx my">def cog(self):<br/>  return self.cog</span></pre><p id="b32b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现这个方法将cog从数据(到处引用)变为行为(定义一次)。如果cog被引用了10次，并且突然改变了它的规格，你不需要改变代码10个位置。</p><p id="2d43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">隐藏数据结构</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="f5e2" class="mu kz iq mq b gy mv mw l mx my">class ObscuringReference:<br/>  def __init__(self, data):<br/>    self.data = data</span><span id="e860" class="mu kz iq mq b gy mz mw l mx my">  def diameters(self):<br/>    return [cell[0] + (cell[1] * 2) for cell in self.data]</span><span id="fe6e" class="mu kz iq mq b gy mz mw l mx my">data = [<br/>  [622, 20],<br/>  [622, 23],<br/>  [559, 30],<br/>  [559, 40]<br/>]</span><span id="79cd" class="mu kz iq mq b gy mz mw l mx my">print(ObscuringReference(data).diameters()) # [662, 668, 619, 639]</span></pre><p id="5cac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子还不错，但是要做任何有用的事情，每个数据<em class="nl">的发送者都必须完全知道哪段数据在数组的哪个索引上。</em></p><p id="72e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，发送者必须知道轮辋在[0]，轮胎在[1]。如果数据结构改变了，那么这个代码也必须改变。rims在[0]的知识不应该在你的应用中重复，因为它不是干的(不要重复自己)。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="7a8a" class="mu kz iq mq b gy mv mw l mx my">from collections import namedtuple</span><span id="e9c9" class="mu kz iq mq b gy mz mw l mx my">class RevealingReference:<br/>  Wheel = namedtuple("Wheel", ("rim", "tire"))</span><span id="a2a4" class="mu kz iq mq b gy mz mw l mx my">  def __init__(self, data):<br/>    self.wheels = self.wheelify(data)</span><span id="4dc3" class="mu kz iq mq b gy mz mw l mx my">  def diameters(self):<br/>    return [wheel.rim + (wheel.tire * 2) for wheel in self.wheels]</span><span id="9506" class="mu kz iq mq b gy mz mw l mx my">  def wheelify(self, data):<br/>    return [RevealingReference.Wheel(cell[0], cell[1]) for cell in data]</span><span id="d750" class="mu kz iq mq b gy mz mw l mx my">data = [<br/>  [622, 20],<br/>  [622, 23],<br/>  [559, 30],<br/>  [559, 40]<br/>]</span><span id="884f" class="mu kz iq mq b gy mz mw l mx my">print(RevealingReference(data).diameters()) # [662, 668, 619, 639]</span></pre><p id="9254" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上实现，diameters方法现在不知道数组的内部结构。所有关于结构的知识都被隔离在wheelify方法中，所以如果结构改变，我们不需要改变代码，例如在[0]和[1]之间插入新数据。</p><h2 id="6e66" class="mu kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">处处实施单一责任</h2><p id="81b7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir">从方法中提取额外的责任</strong></p><p id="8260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个方法，RevealingReference类的diameters方法，有两个职责:</p><ul class=""><li id="04e1" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">在轮子上迭代</li><li id="d49b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">计算每个车轮的直径</li></ul><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="4f47" class="mu kz iq mq b gy mv mw l mx my">def diameters(self):<br/>  return [wheel.rim + (wheel.tire * 2) for wheel in self.wheels]</span></pre><p id="6722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过将代码分成两个方法来简化代码，每个方法有一个单独的职责。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="84d0" class="mu kz iq mq b gy mv mw l mx my">#Iterates over the wheels<br/>def diameters(self):<br/>  return [diameters(wheel) for wheel in self.wheels]</span><span id="9d3c" class="mu kz iq mq b gy mz mw l mx my">#Calculates the diameter of each wheel<br/>def diameter(self, wheel):<br/>  return wheel.rim + (wheel.tire * 2)</span></pre><p id="08b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们回忆齿轮类的gear_inches方法。这也有两个责任:</p><ul class=""><li id="a71a" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">在轮子上迭代</li><li id="adb0" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">计算每个车轮的直径</li></ul><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="243f" class="mu kz iq mq b gy mv mw l mx my">def gear_inches(self):<br/>  return ratio * (self.rim + (self.tire * 2))</span></pre><p id="92a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以这样简化:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="f148" class="mu kz iq mq b gy mv mw l mx my">def gear_inches(self):<br/>  return ratio * diameter</span><span id="130d" class="mu kz iq mq b gy mz mw l mx my">def diameter(self):<br/>  return self.rim + (self.tire * 2)</span></pre><p id="eab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们需要承担单一责任？这有以下好处:</p><ul class=""><li id="f259" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">暴露以前隐藏的品质</li><li id="1a43" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">避免评论的需要</li><li id="3495" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">鼓励重复使用</li><li id="ed1a" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">很容易转到另一个班级</li></ul><p id="0dfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">将额外的责任隔离在班级中</strong></p><p id="d958" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你简化了每个只有一个责任的方法，现在你就看到了类责任。</p><p id="2c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在齿轮类的齿轮英寸方法中计算直径，但直径更可能是轮的行为。因此，我们可以创建包含直径方法的Wheel类。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="fd2c" class="mu kz iq mq b gy mv mw l mx my">class Wheel:<br/>  def __init__(self, rim, tire):<br/>    self.rim = rim<br/>    self.tire = tire</span><span id="152e" class="mu kz iq mq b gy mz mw l mx my">  def diameter(self):<br/>    return self.rim + (self.tire * 2)</span><span id="69c8" class="mu kz iq mq b gy mz mw l mx my">print(Wheel(26, 1.5).diameter())</span></pre><p id="3099" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，现在我们可以通过轮类计算齿轮类的直径。</p><h1 id="a0b6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">最后</strong></h1><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="c275" class="mu kz iq mq b gy mv mw l mx my">class Gear:<br/>  def __init__(self, chainring, cog, wheel=None):<br/>    self.chainring = chainring<br/>    self.cog = cog<br/>    self.wheel = wheel</span><span id="6a51" class="mu kz iq mq b gy mz mw l mx my">  def ratio(self):<br/>    return self.chainring / float(self.cog)</span><span id="19a8" class="mu kz iq mq b gy mz mw l mx my">  def gear_inches(self):<br/>    return self.ratio() * self.wheel.diameter()</span><span id="4090" class="mu kz iq mq b gy mz mw l mx my">class Wheel:<br/>  def __init__(self, rim, tire):<br/>    self.rim = rim<br/>    self.tire = tire</span><span id="5834" class="mu kz iq mq b gy mz mw l mx my">  def diameter(self):<br/>    return self.rim + (self.tire * 2)</span><span id="0a30" class="mu kz iq mq b gy mz mw l mx my">wheel = Wheel(26, 1.5)<br/>print(Gear(52, 11, wheel).gear_inches())<br/>print(Gear(52, 11).ratio())</span></pre><p id="fd36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读！！</p></div></div>    
</body>
</html>