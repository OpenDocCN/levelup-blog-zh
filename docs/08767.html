<html>
<head>
<title>7 Object-Oriented Programming and Design Practical Tips (with Examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7面向对象编程和设计实用技巧(附例子)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-outstanding-practical-tips-with-examples-for-oop-software-developers-44f0d11b23df?source=collection_archive---------5-----------------------#2021-06-02">https://levelup.gitconnected.com/7-outstanding-practical-tips-with-examples-for-oop-software-developers-44f0d11b23df?source=collection_archive---------5-----------------------#2021-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8732" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改进软件应用程序设计的实践。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/118113f467b3780abe2ac8a2bde6a0ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EVv22hTv3rx0m33B"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">克拉克·蒂布斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="13fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面向对象编程与设计不是一个可以很快学会的东西。这就是艺术，这个题目要求软件开发人员阅读基础书籍，定期练习，解决现实世界的问题，向更有经验的队友学习，做其他事情。</p><p id="e745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇5分钟的文章不会让你成为OOP和OOP专家。然而，这篇文章收集了最常见的无效设计选择的例子和它们的更好的替代方案，你可以用它们来填补知识空白，并可能成为比现在稍微好一点的面向对象编程和设计的软件开发人员。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="65dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.使用返回值进行输入验证，而不是抛出异常</h1><p id="e6fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">异常可用于通知调用代码该方法的输入参数无效。这种方法有几个缺点:</p><ul class=""><li id="9c50" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">异常损害了代码的可读性，因为要回答问题<em class="ni">“方法抛出什么类型的异常或者它到底抛出什么类型的异常？”</em>开发者需要分析方法的整体。</li><li id="ed78" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">不正确地使用异常作为工具。异常应该只在异常情况下抛出，也就是说，在应用程序的正常流程中不应该出现的情况:没有数据库连接、空引用…</li><li id="82c5" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">抛出异常通常会影响应用程序的性能，因此应该尽可能少地只在异常情况下抛出异常。</li><li id="1859" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">基于异常的代码更难分析和调试。每当你看到<code class="fe no np nq nr b">throw</code>时，找到合适的<code class="fe no np nq nr b">catch</code>语句可能需要时间。您可能需要分析整个调用堆栈，直到应用程序的入口点。因此，异常通常等同于<code class="fe no np nq nr b">goto</code>陈述。</li></ul><h2 id="6b7a" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="8e7e" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自上传错误文件的用户的无效输入绝对不是例外情况，因此返回<code class="fe no np nq nr b">Result</code>对象是与调用代码交流验证结果的更好方式。</p><p id="5a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，与基于异常的实现相反，使用<code class="fe no np nq nr b">Result</code>对象允许代码积累错误消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="29de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.将贫乏的领域模型重构为丰富的领域模型</h1><p id="4381" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">贫血的域模型看起来像一个只有getters和setters的类，不包含任何逻辑。</p><p id="7c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与贫血的领域模型相关的业务逻辑被放在单独的类中，这些类的名称末尾通常有“Service”或“Manager”。这种方法会导致应用程序的不同服务之间的业务逻辑重复。</p><p id="6803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">贫血领域建模的另一个大问题是违反封装。贫血模型必须有公共设置器，因为可以改变模型状态的逻辑在一个单独的类中。</p><p id="ea20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个类有公共设置器时，迟早有人会因为不小心赋错值而违反它的不变量。</p><p id="5578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">贫血的领域模型可以重构为丰富的领域模型。</p><h2 id="5978" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="d1d4" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f9d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.使用自动计算的属性</h1><p id="cba1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">自动计算的只读属性是一种强大、简单且优雅的方式，可以简化外部客户端的类契约。</p><h2 id="f00d" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="c94e" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="de71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算雇员收入的业务规则封装在<code class="fe no np nq nr b">Employee</code>类中，因此它提高了代码的重用性，因为外部客户不再需要自己实现计算收入的逻辑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f3fd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.对外部客户端隐藏实现细节</h1><p id="6c4f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">开发人员应该以这样一种方式设计该类，即对于外部客户端来说，该类易于正确使用，而难以错误使用。这个原则是通过对外界隐藏实现细节来实现的，并且只提供客户端需要的最少功能。</p><h2 id="1872" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个反问:方法<code class="fe no np nq nr b">NormalizeComment</code>被创建<code class="fe no np nq nr b">Comment</code>实例的每个客户端100%调用的可能性有多大？</p><h2 id="37f1" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="b27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法<code class="fe no np nq nr b">NormalizeComment</code>是一个外部客户端甚至不需要知道的实现细节，所以该方法现在是私有的，每当一个值被赋给一个<code class="fe no np nq nr b">text</code>属性时就会被隐式调用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b7f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.在值对象中包装表示领域概念的基本类型</h1><p id="ad76" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">原始数据类型，如字符串、整数等。可以在对域实体建模时使用。</p><p id="2afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用原语可能需要开发人员定期验证它们，以确保它们包含正确的值。</p><p id="8c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决<a class="ae ky" href="https://blog.ploeh.dk/2011/05/25/DesignSmellPrimitiveObsession/" rel="noopener ugc nofollow" target="_blank">原语困扰</a>问题的方法是用值对象替换原语。</p><h2 id="4fde" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="f518" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe no np nq nr b">double</code>数据类型不同的是，<code class="fe no np nq nr b">Discount</code>数据类型将始终包含预期的值范围，这是由于验证逻辑的缘故，因此在成功创建<code class="fe no np nq nr b">Discount</code>对象后，您不再需要对其进行验证。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1682" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.使用DI容器创建单例，而不是传统的单例实现</h1><p id="fba8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">经典的单例实现有几个缺点，下面是主要的几个:</p><ul class=""><li id="0f25" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">实现singleton的类违反了单一责任原则，因为除了它的主要功能责任之外，它还负责创建自己。</li><li id="5837" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">不可能以多态的方式用另一个对象类型替换单例对象。</li><li id="792d" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">使用单例，很容易在代码中获得隐式依赖。</li></ul><h2 id="786e" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="955d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，开发人员可以从对象中移除所有与单例相关的逻辑，并使用依赖注入容器来实现相同的结果。</p><h2 id="515e" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="72d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以查看我的这篇文章，了解对单例优缺点的更详细的分析，以及实现它的各种方法:</p><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">在C#中实现单例设计反模式的5种方法</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">各有利弊</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="72fb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.仅在Void方法中改变状态</h1><p id="476b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">遵循以下简单的规则可以极大地提高代码的可维护性、可读性和可重用性:</p><ul class=""><li id="80da" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">Void方法会改变应用程序的状态。</li><li id="1413" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">非void方法应该只返回值而不改变应用程序的状态。</li></ul><h2 id="8404" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="a360" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="73d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">坏例子中的方法违反了单一责任原则，因为它检查和更新用户的状态，但是将方法一分为二解决了这个问题。</p><p id="abc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个更小的方法负责一项任务。从实用的角度来看，这种分离允许我们独立地重用它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a2d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7dea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">读完这篇文章后，你可能会立刻觉得有必要重构你的项目。但是等一下。想一想在你的特殊情况下选择一个解决方案而不是另一个解决方案会给你带来什么好处。写下当前和新解决方案的所有利弊。然后做一个重构，当然，如果你还觉得值得的话。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="47d5" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">我的其他文章</h2><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何专业地对Bug修复进行代码审查</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">审查bug修复时要问的几个重要问题。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">5种免费提高C#代码性能的方法</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">慢速代码是可选的。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="pa l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>