<html>
<head>
<title>Building a game with TypeScript. Game Loop 1/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。游戏循环1/2</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71?source=collection_archive---------1-----------------------#2020-07-25">https://levelup.gitconnected.com/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71?source=collection_archive---------1-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3e9c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">教程<a class="ae km" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">系列</a>中的第二章讲述了如何用TypeScript和本地浏览器API从头开始构建游戏</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/29f414bc9b541d480262c9579ce107d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOJkZ1KGwatTB_WDyhZk-w.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae km" href="https://www.freepik.com/free-photos-vectors/icon'" rel="noopener ugc nofollow" target="_blank">freepik创建的图标向量</a></figcaption></figure><p id="447a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">欢迎回来！这是我们讨论如何用TypeScript和本地浏览器API构建一个简单的回合制游戏的系列文章！第二章致力于为这个游戏建立一个游戏循环，其他章节可以在这里找到:</p><ul class=""><li id="046b" class="ld le iq jq b jr js jv jw jz lf kd lg kh lh kl li lj lk ll bi translated"><a class="ae km" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="5fb0" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated"><a class="ae km" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="c49f" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第二章。游戏循环(第一部分，<a class="ae km" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a></li><li id="e6f1" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第三章。绘制网格(<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第1部分</a>、<a class="ae km" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第2部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第3部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="e55d" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第四章。舰船(<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae km" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="5cec" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第五章输入系统(<a class="ae km" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae km" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae km" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="39cc" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第六章。寻路和移动(<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae km" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="dd68" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第七章。玛奇纳州</li><li id="0682" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第九章。比赛的输赢</li><li id="3a74" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第十章敌人AI</li></ul><p id="883f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><a class="ae km" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">上次</a>我们讨论了实体组件系统。我们将把它作为我们游戏的基本构件。今天我们将要准备几乎任何游戏的另一个关键部分:游戏循环。</p><blockquote class="lr ls lt"><p id="13d0" class="jo jp lu jq b jr js jt ju jv jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk kl ij bi translated">F <!-- --> eel自由切换到<a class="ae km" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe ly lz ma mb b"><em class="iq">ecs</em></code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="10fe" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">目录</h1><ol class=""><li id="0a73" class="ld le iq jq b jr nh jv ni jz nj kd nk kh nl kl nm lj lk ll bi translated">为什么我们需要一个游戏循环？</li><li id="76fe" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl nm lj lk ll bi translated">什么是游戏循环？</li><li id="a681" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl nm lj lk ll bi translated">可更新的实体和组件</li><li id="65c0" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl nm lj lk ll bi translated">让游戏开始吧！</li><li id="6554" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl nm lj lk ll bi translated">结论</li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="160a" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">为什么我们需要游戏循环？</h1><p id="631c" class="pw-post-body-paragraph jo jp iq jq b jr nh jt ju jv ni jx jy jz nn kb kc kd no kf kg kh np kj kk kl ij bi translated">当我们开发一个应该在浏览器中执行的应用程序时，我们非常依赖我们的用户。事实上，应用程序的几乎整个数据流都依赖于用户的输入:“单击这里”、“在那里键入”、“导航到那个页面”等等。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/a0f4526d0957e4e783fbfd0518d4b16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNdgxZttvxe5mh6tEOb4Aw.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae km" href="https://www.freepik.com/free-photos-vectors/design" rel="noopener ugc nofollow" target="_blank">free pik创建的设计向量</a></figcaption></figure><p id="6d78" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在游戏中，用户输入也是必不可少的。毕竟，如果没人玩，这个游戏就毫无意义。但是游戏作为软件，不管用户输入如何，都有很多事情要做。</p><p id="806e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们在这个系列中构建的游戏是一个回合制游戏。意思是每个玩家一个接一个地移动，而不是同时移动。AI控制了其中一个玩家。当人类玩家结束他们的移动时，游戏不会“停止”船只仍在飞行；人工智能进行计算，计时器开始计时，等等。大量的过程正在发生；其中一些对玩家来说是可见的，比如动画和计时器。有些是隐藏的。在任何情况下，它们都<em class="lu">独立于用户的输入</em>。在商业应用程序中，几乎所有的东西都在等待用户开始与它互动，与之相反，在某种意义上，游戏有自己的生活。</p><p id="1722" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">考虑到所有这些，我们必须有一种方法让游戏继续进行，即使一个人类玩家什么都不做。而<strong class="jq ir">游戏循环</strong>的存在正是为了帮助我们做到这一点。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="a56f" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">什么是游戏循环？</h1><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nq"><img src="../Images/9fcdcb85c070ffe133ede0ddec0e2d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LtJnwPXXs3p9TZk5CkmEg.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae km" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">宏向量</a>创建的背景向量</figcaption></figure><p id="0108" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这个想法很简单。我们运行一个无限循环，通知游戏的每一个部分每次迭代的开始。游戏循环本身不应用任何功能或逻辑。它只是说，“又一个时刻过去了。”</p><p id="00da" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">被通知的游戏的每一个元素都以它认为合适的方式处理这些信息。例如，飞船动画可能会稍微改变宇宙飞船在世界上的位置。AI引擎可能会考虑开始新一轮的计算。RPG角色的生命值或法力值可能会恢复一点</p><blockquote class="lr ls lt"><p id="a621" class="jo jp lu jq b jr js jt ju jv jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk kl ij bi translated">理解这是一个<strong class="jq ir">循环</strong>是至关重要的，它总是运行<strong class="jq ir">循环</strong>。关于性能，所有元素的所有操作都必须尽可能的轻量。</p></blockquote><p id="3356" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">什么样的元素应该收到关于新迭代的通知？循环可能事先不知道，坦率地说，它并不关心。在前一章中，我们利用了一种强大的架构方法:实体组件系统。我们现在可以扩展它来配合游戏循环。这样，ECS之后的每个游戏元素都会被循环更新。宇宙飞船会飞；敌人将能够思考，法力将会恢复！</p><h1 id="f4c5" class="mj mk iq bd ml mm nr mo mp mq ns ms mt mu nt mw mx my nu na nb nc nv ne nf ng bi translated">可更新的实体和组件</h1><p id="a95f" class="pw-post-body-paragraph jo jp iq jq b jr nh jt ju jv ni jx jy jz nn kb kc kd no kf kg kh np kj kk kl ij bi translated">我们所需要的是一种确保实体和组件可以更新的方法。最简单的方法是给抽象<code class="fe ly lz ma mb b">Entity</code>和接口<code class="fe ly lz ma mb b">IComponent</code>添加一个方法<code class="fe ly lz ma mb b">Update</code>。然后游戏循环将在每次迭代中调用这个方法，通知这些元素。就像一个电话！或者早上烦人的闹铃。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nw"><img src="../Images/d9a65a7c8d80a6dc5410f9188ea919e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PzEM-oxa2sdgeVn116KuBw.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae km" href="https://www.freepik.com/free-photos-vectors/background'" rel="noopener ugc nofollow" target="_blank">rawpixel.com创建的背景向量</a></figcaption></figure><p id="9cc6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">然而，这不是一个非常清晰的方法。这样，我们将可更新的行为和ECS紧密地耦合在一起。游戏循环确实可以更新每个实体和组件。但这并不意味着他们是唯一能够获得更新的人。更干净的方法是定义一个专用协议(读:<em class="lu">接口</em>)。谁符合谁就可以更新。</p><blockquote class="lr ls lt"><p id="feb7" class="jo jp lu jq b jr js jt ju jv jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk kl ij bi translated">注意，创建一个专用的接口很好地符合固体接口分离原则</p></blockquote><p id="d54d" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">实际的界面非常简单:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="20ec" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">注意参数<code class="fe ly lz ma mb b">deltaTime</code>。它包含自游戏循环的最后一次迭代以来所用时间的信息。拥有这个数字对于游戏的某些元素来说是非常方便的。</p><p id="8160" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">有了接口、实体和组件，就可以简单地实现它:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8083" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">然后实体可以调用其每个组件上的更新:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><blockquote class="lr ls lt"><p id="a13d" class="jo jp lu jq b jr js jt ju jv jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk kl ij bi translated">注意，如果有必要，特定的实体可以扩展甚至覆盖抽象实体的<code class="fe ly lz ma mb b"><em class="iq">Update</em></code>。然而，默认情况下，实体只是更新它的所有组件</p></blockquote><p id="d2f2" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们的操作破坏了测试，因为我们承诺每个实体和组件都有一个<code class="fe ly lz ma mb b">Update</code>方法。模拟实体和组件没有实现这个承诺。希望这很容易解决:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e0d8" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">既然我们就在附近，让我们也用测试覆盖<code class="fe ly lz ma mb b">Update</code>。这件事做起来相当简单。我们可以向模拟实体添加模拟组件，监视它们的<code class="fe ly lz ma mb b">Update</code>方法，并查看当我们执行实体的<code class="fe ly lz ma mb b">Update</code>时是否调用了它:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="86c6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果您在此时运行<code class="fe ly lz ma mb b">npm start</code>，您的代码应该编译无误。如果您在<code class="fe ly lz ma mb b">npm t,</code>之前运行测试，它们现在应该都是成功的。</p><p id="9fbc" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">但是我们仍然不知道谁以及多久在每个实体上调用一次Update。我们甚至没有游戏循环本身。是时候解决了！</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="bf0c" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">让游戏开始吧！</h1><p id="e9b4" class="pw-post-body-paragraph jo jp iq jq b jr nh jt ju jv ni jx jy jz nn kb kc kd no kf kg kh np kj kk kl ij bi translated">我将创建一个<code class="fe ly lz ma mb b">Game</code>实体。它将是游戏的根元素，是实体层级中最顶层的元素。这个实体将开始游戏循环并准备所有的游戏对象。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/4e6da51b58a54e4b5c1afc8b962aafe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmT3sDBltpDxJqdQQmXpfw.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae km" href="https://www.freepik.com/free-photos-vectors/technology" rel="noopener ugc nofollow" target="_blank">free pik创建的技术向量</a></figcaption></figure><p id="1027" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">让我们首先在src下的专用“game”文件夹中创建一个空实体:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c1a4" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">不要忘记桶文件:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a84c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">该游戏的行为与游戏的任何其他实体略有不同。它的更新方法不需要deltaTime。原因很简单:Game是根实体，所以它要<strong class="jq ir">计算</strong> deltaTime。为此，我们必须跟踪执行<code class="fe ly lz ma mb b">Update</code>的时间(读取:<em class="lu">最后一次迭代的时间戳</em>)。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2adf" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在每个<code class="fe ly lz ma mb b">Update</code>日，我们将比较该时间戳和当前时间，并计算差值:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6a75" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们现在可以将这个deltaTime传递给游戏的所有组件(也称为invoke parent的<code class="fe ly lz ma mb b">Update</code>,因为它就是这样做的):</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="42ef" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">之后，我们应该更新时间戳:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e23e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">为了结束这个循环，我们可以递归地调用Update:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8c3f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们有我们的游戏循环！恭喜你。</p><p id="d9bd" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">然而，每一次新的迭代都在前一次迭代之后立即开始。我们不需要如此频繁地重复。</p><p id="a0c6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们可以设置一个计时器，以某种基于时间的频率进行迭代，例如利用<code class="fe ly lz ma mb b">setTimer</code>或<code class="fe ly lz ma mb b">setInterval.</code>，每隔一个<code class="fe ly lz ma mb b">300ms</code>。事实上，在过去，这是我们实现定期执行的唯一方法。这种方法的问题是，不同设备上的玩家会体验到不同的游戏速度。</p><p id="b163" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">更好(也更常见)的方法是每隔<em class="lu">帧</em>重复一次循环，而不是只重复一小段时间。这将确保每个玩家以相同的频率进行迭代，无论他们使用什么设备玩游戏。</p><blockquote class="lr ls lt"><p id="a710" class="jo jp lu jq b jr js jt ju jv jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk kl ij bi translated">为了说明游戏在不同设备上保持一致的速度是多么重要，请考虑一个多人游戏。想象一下，你和你的朋友比赛，他的机器上运行的CPU比你快/慢得多。这意味着他们的本地版游戏可以在相同的时间内完成更多的循环。在这些循环中，他们可以获得更多的力量，聚集更多的资源，在战斗中对你造成更多的伤害。最终，这使得游戏变得不公平。谁会想玩这样的游戏？</p></blockquote><p id="7d4c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">对我们来说，希望现在的浏览器允许我们在每一帧执行代码，提供全局<code class="fe ly lz ma mb b">requestAnimationFrame</code>回调。</p><p id="5727" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">让我们用requestAnimationFrame替换Update的即时调用，并让我们的游戏循环运行每一帧:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1be2" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">唯一剩下的就是开始循环了。我们可以在构造函数的帮助下做到这一点:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6409" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">但是，让我先走一步，跳出目前的情况思考一下。</p><p id="2d40" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">正如我们在前一章中所确定的，组件被附加到实体上以便能够工作。我们也可以在实体的构造函数中这样做。但是之后就越来越臃肿了。保持构造函数精简并在专用方法中进行任何繁重的初始化通常是更好的做法。下次我们将从介绍这样一种方法开始。</p><blockquote class="lr ls lt"><p id="e1b0" class="jo jp lu jq b jr js jt ju jv jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk kl ij bi translated">Y <!-- -->你可以在<a class="ae km" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe ly lz ma mb b">game-loop-1</code>分支中找到这篇文章的完整源代码。</p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="b0e2" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">结论</h1><p id="7203" class="pw-post-body-paragraph jo jp iq jq b jr nh jt ju jv ni jx jy jz nn kb kc kd no kf kg kh np kj kk kl ij bi translated">厉害！在这一章中，我们学习了什么是游戏循环，以及我们如何将它与实体组件系统相结合。下一篇文章将致力于理解我们如何开始游戏循环，以及我们如何更新游戏的其他实体。</p><p id="7ecb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果您有任何意见、建议、问题或任何其他反馈，请不要犹豫，给我发私信或在下面留下评论！感谢您的阅读，我们下次再见！</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="7dad" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><em class="lu">这是系列教程“</em> <strong class="jq ir"> <em class="lu">用打字稿</em> </strong> <em class="lu">”中的第二章。其他章节可点击此处:</em></p><ul class=""><li id="3441" class="ld le iq jq b jr js jv jw jz lf kd lg kh lh kl li lj lk ll bi translated"><a class="ae km" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="7ae1" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated"><a class="ae km" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="2b23" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第二章。游戏循环(第一部分，<a class="ae km" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a></li><li id="ea72" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第三章。绘制网格(<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第一部分</a>、<a class="ae km" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第二部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第五部分</a>)</li><li id="563c" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第四章。舰船(<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae km" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae km" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="c356" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第五章输入系统(<a class="ae km" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae km" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae km" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="3610" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第六章。寻路和移动(<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">部分1 </a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">部分2 </a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">部分3 </a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">部分4 </a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">部分5 </a>、<a class="ae km" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">部分6 </a>、<a class="ae km" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">部分7 </a>)</li><li id="31c7" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第七章。玛奇纳州</li><li id="27f0" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第八章。攻击系统:生命和伤害</li><li id="52c3" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第九章。比赛的输赢</li><li id="8c13" class="ld le iq jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">第十章敌人AI</li></ul></div></div>    
</body>
</html>