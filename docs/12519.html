<html>
<head>
<title>How to test NgRx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试NgRx</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-test-ngrx-ccf6861fa708?source=collection_archive---------6-----------------------#2022-06-16">https://levelup.gitconnected.com/how-to-test-ngrx-ccf6861fa708?source=collection_archive---------6-----------------------#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/f85c85e5033d427c737ae715c4cc2249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*lbSHfzT8_L4HOlBcYUudcg.png"/></div></figure><p id="a9b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">NgRx是angular的一个框架，它有助于将后端逻辑从前端分离出来，使代码更容易、更干净。要了解更多关于它的工作原理和使用方法，请查看我以前的文章— <a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/ngrx-explained-3891da35eeea"> NgRx解释</a>。用NgRx进行测试非常简单，您只需要使用提供的模拟。</p><p id="5768" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，由于<code class="fe kt ku kv kw b">store</code>被注入到构造函数中，并且由于单元测试应该是隔离的，因此我们需要在配置测试模块时将<code class="fe kt ku kv kw b">provideMockStore()</code>添加到<code class="fe kt ku kv kw b">providers</code>数组中。然后我们可以创建对我们的<code class="fe kt ku kv kw b">store</code>的引用，声明为类型<code class="fe kt ku kv kw b">MockStore&lt;AppState&gt;</code>，并从<code class="fe kt ku kv kw b">TestBed</code>中注入它的值。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="3f4b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了存根来自<code class="fe kt ku kv kw b">selectors</code>的值，我们可以使用<code class="fe kt ku kv kw b">overrideSelector(&lt;Selector&gt;, &lt;Value&gt;)</code>方法和<code class="fe kt ku kv kw b">fixture.detectChanges()</code>来刷新数据。</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="3dc4" class="lh li iq kw b gy lj lk l ll lm">store.overrideSelector(Selector.books, sampleBooks);<br/>fixture.detectChanges()</span></pre><p id="18bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们需要重用被覆盖的选择器，我们可以将它赋给一个类似<code class="fe kt ku kv kw b">let showDetailSelector = store.overrideSelector(Selector.showDetail, true);</code>的变量。我们可以通过使用<code class="fe kt ku kv kw b">setResult(&lt;Value&gt;)</code>方法来更新这些值。但是之后我们需要调用<code class="fe kt ku kv kw b">store.refreshState()</code>来刷新商店。</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="62ef" class="lh li iq kw b gy lj lk l ll lm">showDetailSelector.setResult(false);<br/>store.refreshState();<br/>fixture.detectChanges();</span></pre><p id="bdab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于如何完成所有这些工作的示例，请访问<a class="ae ks" href="https://github.com/thecodinganalyst/bookstore/blob/master/src/app/app.component.spec.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/the coding analyst/book store/blob/master/src/app/app . component . spec . ts</a>。</p><h1 id="bc14" class="ln li iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">测试选择器</h1><p id="690c" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">假设我们有一个这样的选择器</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="edb1" class="lh li iq kw b gy lj lk l ll lm">const books = createSelector( bookStore, (bookStoreState =&gt; bookStoreState.books));</span></pre><p id="6d81" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了测试我们的选择器，我们可以使用选择器的<code class="fe kt ku kv kw b">projector(&lt;State&gt;)</code>方法来获得期望值。</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="bea9" class="lh li iq kw b gy lj lk l ll lm">it('should get the books', () =&gt; {<br/>  const result = Selector.books.projector(initialState.bookStore);<br/>  expect(result.length).toBe(5);<br/>});</span></pre><p id="b1fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完整的例子在<a class="ae ks" href="https://github.com/thecodinganalyst/bookstore/blob/master/src/app/state/books.selectors.spec.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/the coding analyst/book store/blob/master/src/app/state/books . selectors . spec . ts</a>上。</p><h1 id="2309" class="ln li iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">测试减速器</h1><p id="d905" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">因为<code class="fe kt ku kv kw b">reducers</code>是简单的纯函数，通过一个特定的动作从当前状态获得一个新的状态，我们只需要stub我们的状态并创建一个动作对象来传递给我们的reducer。</p><p id="91cd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设我们有这样一个行动</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="595c" class="lh li iq kw b gy lj lk l ll lm">const booksLoaded = createAction("[BookList] Books Loaded", props&lt;{ books: ReadonlyArray&lt;Book&gt; }&gt;())</span></pre><p id="e56c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以直接引用<code class="fe kt ku kv kw b">booksLoaded</code>动作，传入books参数- <code class="fe kt ku kv kw b">const action = BookStoreActions.booksLoaded({books: [sampleBook]});</code>。然后我们可以通过- <code class="fe kt ku kv kw b">const state = booksReducer(initialState, action);</code>将它传送到我们的reducer，并直接在状态对象上做断言。</p><p id="ead5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完整的例子在<a class="ae ks" href="https://github.com/thecodinganalyst/bookstore/blob/master/src/app/state/books.reducer.spec.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/the coding analyst/book store/blob/master/src/app/state/books . reducer . spec . ts</a>上。</p><h1 id="686b" class="ln li iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">测试效果</h1><p id="896e" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">我们需要添加真实的<code class="fe kt ku kv kw b">effects</code>，以及模拟的<code class="fe kt ku kv kw b">action</code>和<code class="fe kt ku kv kw b">store</code>。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="e6da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于一个动作— <code class="fe kt ku kv kw b">loadBooks</code>，这个动作的副作用是调用服务从数据库中加载书籍。在书籍被加载后，另一个动作- <code class="fe kt ku kv kw b">booksLoaded</code>被触发，书籍作为有效负载。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a033" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了测试上述效果，</p><ol class=""><li id="f61b" class="mp mq iq jw b jx jy kb kc kf mr kj ms kn mt kr mu mv mw mx bi translated">首先，我们在服务上放置一个间谍来返回一个模拟的图书列表，这样服务的工作就不会干扰我们的单元测试。</li><li id="972d" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated">然后我们触发动作— <code class="fe kt ku kv kw b">actions$ = of(BookStoreActions.loadBooks);</code>。</li><li id="4332" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated">然后我们同意这个效果，并把我们的断言</li></ol><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="ecc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完整示例可在<a class="ae ks" href="https://github.com/thecodinganalyst/bookstore/blob/master/src/app/state/books.effects.spec.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/the coding analyst/book store/blob/master/src/app/state/books . effects . spec . ts</a>上找到。</p><p id="9a6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nd">本文原载于</em><a class="ae ks" href="https://thecodinganalyst.github.io/knowledgebase/how-to-test-ngrx/" rel="noopener ugc nofollow" target="_blank"><em class="nd">https://the coding analyst . github . io/knowledge base/how-to-test-ngrx/</em></a></p></div></div>    
</body>
</html>