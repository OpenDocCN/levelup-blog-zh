<html>
<head>
<title>How to create a button like TikTok for Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Android创建一个像抖音一样的按钮</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-button-like-tiktok-2554280331bb?source=collection_archive---------9-----------------------#2021-07-22">https://levelup.gitconnected.com/how-to-create-a-button-like-tiktok-2554280331bb?source=collection_archive---------9-----------------------#2021-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="baae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建抖音克隆第1部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0824c438b6aa203640aa34ef76971ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEoYKHpVJvB5HMURbESSDA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">抖音按钮</figcaption></figure><h1 id="6270" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="8675" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这篇博客是开发抖音克隆应用系列的第一集。敬请关注！🥰</p><h1 id="259c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">必需的知识</h1><p id="5e98" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">自定义视图的一些基本概念。有关自定义视图组件的更多信息，请参考:</p><p id="4891" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae mr" href="https://developer.android.com/guide/topics/ui/custom-components" rel="noopener ugc nofollow" target="_blank">T13】https://developer . Android . com/guide/topics/ui/custom-componentsT15】</a></p><p id="31ea" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">和波特-达夫概念:</p><p id="9f1d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae mr" href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://developer . Android . com/reference/Android/graphics/porter duff。模式</em> </a></p><h1 id="ed76" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">编码部分</h1><p id="71ad" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我将编码部分分为2个步骤，如下所示:</p><ul class=""><li id="c9d2" class="mt mu it ls b lt mm lw mn lz mv md mw mh mx ml my mz na nb bi translated"><a class="ae mr" href="#ae5e" rel="noopener ugc nofollow">创建自定义视图。</a></li><li id="d1c0" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated"><a class="ae mr" href="#8297" rel="noopener ugc nofollow">处理OnDraw()方法。</a></li></ul><h1 id="ae5e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤1:创建自定义视图</h1><h2 id="0f93" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">a.创建视图类</h2><p id="1215" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您可以通过扩展<code class="fe nt nu nv nw b">View</code>类来创建您的自定义视图。虽然<code class="fe nt nu nv nw b">View</code>有许多方法来处理度量，但是我们的视图不需要对它的大小进行特殊控制，为了简单起见，它们不需要被覆盖。</p><p id="60ed" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">自定义视图最重要的部分是它的外观。第一步是覆盖<code class="fe nt nu nv nw b">onDraw()</code>方法。<code class="fe nt nu nv nw b">onDraw()</code>的参数是一个<code class="fe nt nu nv nw b">Canvas</code>对象，视图可以用它来绘制自己。这里有一个片段显示了框架结构:</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="cf7e" class="nh kz it nw b gy ob oc l od oe">class TikTokButton @JvmOverloads constructor(<br/>    context: Context,<br/>    attrs: AttributeSet? = null,<br/>    defStyle: Int = 0<br/>) : View(context, attrs, defStyle) {</span><span id="b1ba" class="nh kz it nw b gy of oc l od oe">    override fun onDraw(canvas: Canvas) {<br/>        super.onDraw(canvas)<br/>    }<br/>}</span></pre><p id="79c4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在Kotlin中，记得使用<code class="fe nt nu nv nw b">@JvmOverloads</code>注释来定义一个构造函数，而不是像Java中那样定义多个构造函数。</p><h2 id="c33e" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">b.将其添加到XML文件中</h2><p id="f056" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">接下来，用XML实例化我们的定制<code class="fe nt nu nv nw b">TikTokButton</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h1 id="8297" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤2:处理OnDraw()方法</h1><h2 id="02d8" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">1.在OnDraw()方法中创建骨架结构</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="efb4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">注意，我们使用了<code class="fe nt nu nv nw b">lazy</code>委托:</p><blockquote class="oi"><p id="48b9" class="oj ok it bd ol om on oo op oq or ml dk translated">对<code class="fe nt nu nv nw b">get()</code>的第一次调用执行传递给<code class="fe nt nu nv nw b">lazy()</code>的lambda并记住结果，对<code class="fe nt nu nv nw b">get()</code>的后续调用只是返回记住的结果— <a class="ae mr" href="https://kotlinlang.org/docs/delegated-properties.html#standard-delegates" rel="noopener ugc nofollow" target="_blank"> doc </a></p></blockquote><p id="75db" class="pw-post-body-paragraph lq lr it ls b lt os ju lv lw ot jx ly lz ou mb mc md ov mf mg mh ow mj mk ml im bi translated">如果我们分配了大量最终会被垃圾收集的新对象，我们的UI将不会流畅。在<code class="fe nt nu nv nw b">lazy</code>委托的帮助下，我们只创建一个然后重用。</p><p id="2ade" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在绘制任何东西之前，我们需要创建一个或多个<code class="fe nt nu nv nw b">Paint</code>对象。在这个例子中，我们只创建了一个画图，并使用<code class="fe nt nu nv nw b">getXXXPaint()</code>方法来更新颜色。</p><h2 id="e289" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">2.创建一个与视图大小相同的位图</h2><p id="ca64" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在<code class="fe nt nu nv nw b">onDraw()</code>触发的时候，我们已经知道了视图的大小。所以我们可以从这个大小创建一个位图:</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="d6dc" class="nh kz it nw b gy ob oc l od oe">val bm = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)<br/>val canvas = Canvas(bm)</span></pre><h2 id="d8db" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">3.画出正确的部分</h2><p id="ec1b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们使用<code class="fe nt nu nv nw b">drawRoundRect()</code>绘制指定的圆角，并使用<code class="fe nt nu nv nw b">radius</code>定义圆角椭圆的半径。</p><p id="9a78" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后我们在X轴上平移一点。有一个叫<code class="fe nt nu nv nw b">withTranslation()</code>的简便方法可以帮助我们自动保存和恢复画布。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="527b" class="nh kz it nw b gy ob oc l od oe">rectF.set(0f, 0f, width.toFloat() - spaceTiny, height.toFloat())<br/>getRightPaint().let {<br/>    canvas.withTranslation(x = spaceTiny) {<br/>        drawRoundRect(rectF, radius, radius, it)<br/>    }<br/>}</span></pre><p id="bf0c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">注意右上方区域，有一条消息叫做<code class="fe nt nu nv nw b">The preview is out of date</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/23e9306bfd537de4fef7375348cfc502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYRJuxLsQbkfhLkLXLOxWg.png"/></div></div></figure><p id="1f10" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">点击<code class="fe nt nu nv nw b">Build &amp; Refresh</code>查看结果，无需构建整个项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/6a65808e3aac34b88931aae97d74ca82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e50gzDhuXWpvxT76rPzVoA.png"/></div></div></figure><p id="625e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这就对了。🤟</p><h2 id="643c" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">4.画中心部分</h2><p id="c81d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们想在粉色矩形上面画一个白色矩形，但是去掉一些没有覆盖粉色矩形的部分。</p><p id="6ec7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这里我们使用PorterDuff模式<a class="ae mr" href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode#SRC_ATOP" rel="noopener ugc nofollow" target="_blank"> SRC_ATOP </a>，它完全符合我们的情况:</p><blockquote class="oi"><p id="a1a5" class="oj ok it bd ol om on oo op oq or ml dk translated">丢弃没有覆盖目标像素的源像素。在目标像素上绘制剩余的源像素。</p></blockquote><pre class="oz pa pb pc pd nx nw ny nz aw oa bi"><span id="2973" class="nh kz it nw b gy ob oc l od oe">getCenterPaint().let {<br/>    paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)<br/>    canvas.drawRoundRect(rectF, radius, radius, it)<br/>}</span></pre><p id="7ef1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">点击<code class="fe nt nu nv nw b">Build &amp; Refresh</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/ce21c0eb4aaaece6b26a1e00a8baf30b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMpx8wPHE3cQkulGuw5l5Q.png"/></div></div></figure><p id="c61e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">万岁！！🤟</p><h2 id="d6d0" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">5.画左边的部分</h2><p id="6829" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们想在白色和粉色的矩形下面画一个蓝色的矩形。让我们来看看<a class="ae mr" href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode#DST_OVER" rel="noopener ugc nofollow" target="_blank"> DST_OVER </a>模式:</p><blockquote class="oi"><p id="284c" class="oj ok it bd ol om on oo op oq or ml dk translated">源像素绘制在目标像素的后面。</p></blockquote><pre class="oz pa pb pc pd nx nw ny nz aw oa bi"><span id="1fcd" class="nh kz it nw b gy ob oc l od oe">getLeftPaint().let {<br/>    paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_OVER)<br/>    canvas.drawRoundRect(rectF, radius, radius, it)<br/>}</span></pre><p id="b170" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">同样，只需点击<code class="fe nt nu nv nw b">Build &amp; Refresh</code>即可查看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/fbadf54b5cb33e367d7d68e6bfb9a13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsMS1fufTJprWAFIL43o6Q.png"/></div></div></figure><p id="d40e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们快完成了！💪</p><h2 id="358c" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">6.绘制加号图标</h2><p id="5f60" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">最后一部分是在视图的中心绘制加号图标。这是一个特例。其实没有画但是很清楚。我们希望丢弃加号图标覆盖的像素。幸运的是，有一种模式适合我们的情况。这是一种<a class="ae mr" href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode#XOR" rel="noopener ugc nofollow" target="_blank">异或</a>模式:</p><blockquote class="oi"><p id="7c84" class="oj ok it bd ol om on oo op oq or ml dk translated">当源像素覆盖目标像素时，丢弃源像素和目标像素。绘制剩余的源像素。</p></blockquote><pre class="oz pa pb pc pd nx nw ny nz aw oa bi"><span id="442a" class="nh kz it nw b gy ob oc l od oe">plusIconBitmap.let {<br/>    paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.XOR)<br/>    canvas.drawBitmap(it, width / 2f - it.width / 2f, height / 2f - it.height / 2f, paint)<br/>}</span></pre><p id="eac9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">那就看看我们的产品吧！🥰</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/95a05e02b80d7a4d6d1928a8c8dc16f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DU1PsWrSh5GvOn_MK1XMpA.png"/></div></div></figure><h2 id="361f" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">7.清除端口缓冲Xfermode</h2><p id="1688" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当我们完成时，记得清除PorterDuff模式。这意味着我们又回到了正常的绘制方式，一层一层的绘制。</p><p id="5e1e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是一种编程习惯，当我们开始使用某个东西时防止bug，当我们不再需要它时清除bug。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="5602" class="nh kz it nw b gy ob oc l od oe">paint.<em class="ms">xfermode </em>= null</span></pre><h1 id="8948" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">这是一个总结！</h1><p id="600c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">下面是<code class="fe nt nu nv nw b">TikTokButton</code>类的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="11f1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果您在执行代码片段时发现问题，请查看GitHub repo获取帮助:</p><div class="pg ph gp gr pi pj"><a href="https://github.com/PhongHuynh93/TikTok/tree/feature/1/create_bottom_navigation" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">GitHub—phonghuynh 93/抖音at feature/1/create _ bottom _ navigation</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">在GitHub上创建一个帐户，为phonghuynh 93/抖音的发展做出贡献。</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">github.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ks pj"/></div></div></a></div></div><div class="ab cl py pz hx qa" role="separator"><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd"/></div><div class="im in io ip iq"><p id="f389" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如你所看到的，创建一个自定义视图并不难，尤其是我们可以从一个著名的应用程序如抖音创建一个按钮。这个类只有66行代码，很容易理解。</p><p id="5094" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="ms">如果你喜欢这个故事，请点击</em><strong class="ls iu"><em class="ms"/></strong>👏<strong class="ls iu"> <em class="ms">按钮，分享</em> </strong> <em class="ms">它来帮助别人！</em>关注我<a class="ae mr" href="https://mr-umbrella.medium.com/" rel="noopener">中</a>T15】获取更多牛逼安卓小技巧。也可以在<a class="ae mr" href="https://www.linkedin.com/in/huynh-phong-3649a7131/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。祝您愉快！😄</p><h1 id="a052" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">继续读Android的东西</h1><p id="efbe" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/android-button-morphing-animation-bc3bed740501">安卓按钮变形动画</a></p><p id="e45e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-like-button-animation-in-android-part-1-f99e2792143d">如何在Android中创建类似按钮的动画——第一部分</a></p><p id="cf11" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/shared-element-using-materialcontainertransform-in-android-6d420e74b122">Android中使用MaterialContainerTransform的共享元素</a></p><p id="8ff7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/motionlayout-collapsing-toolbar-d0ce8dd874b6">运动布局——折叠工具栏</a></p><h1 id="c3e2" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">Jetpack撰写</h1><p id="3a67" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/implement-android-snackbar-in-jetpack-compose-d83df5ff5b47">在Jetpack Compose中实现snack bar</a></p><p id="2342" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/implement-android-tablayout-in-jetpack-compose-e61c113add79">在Jetpack Compose中实现tab layout</a></p><p id="ffcf" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/implement-tablayout-with-viewpager-in-android-jetpack-compose-d509fc6e2d8e">在Jetpack Compose中用ViewPager实现talayout</a></p><p id="d129" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/create-an-auto-scroll-viewpager-with-transformation-and-ken-burns-effect-in-android-jetpack-compose-efdf46f2e8ed">在Jetpack Compose中创建一个带有变形和ken burns效果的自动滚动浏览器</a></p></div></div>    
</body>
</html>