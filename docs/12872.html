<html>
<head>
<title>7 Must-Know Python Built-In Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7个必须知道的Python内置库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-must-know-python-built-in-libraries-c03b06c7fb8d?source=collection_archive---------2-----------------------#2022-07-18">https://levelup.gitconnected.com/7-must-know-python-built-in-libraries-c03b06c7fb8d?source=collection_archive---------2-----------------------#2022-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d5c2393d09d6bf8634e6b6bad44e6e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSixfoP_zjf4FJQ578ZE-A.png"/></div></div></figure><div class=""/><p id="5e14" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python标准库通过提供广泛的功能，让我们程序员的生活变得更加轻松。我们选择了跨越数据结构、文件系统、数据持久性和函数式编程的几个库——我们认为这些库是最重要的——进行检查。无论你是在为面试做准备，还是仅仅想成为一名更熟练的Python程序员，这些都是我们最重要的7个必须知道的库。</p><h1 id="b96f" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.收集</h1><p id="96c5" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">集合模块定义了一些有用的数据结构，包括数组和字典的扩展。</p><h2 id="8ac3" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">收藏。计数器</h2><p id="c7a0" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">收藏。计数器很有用，因为它将不存在的键的默认值设置为零。可以像删除字典中的键一样删除键。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4c52" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt;<strong class="mu jf"> </strong>from collections import Counter<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>c = Counter()<br/>&gt;&gt;&gt; c['nonexistent_key']<br/>0<br/>&gt;&gt;&gt; c['a']=3<br/>&gt;&gt;&gt; c['b']=4 <br/>&gt;&gt;&gt; c<br/>Counter({'a': 3, 'b':4})<br/>&gt;&gt;&gt; del c['a']<br/>&gt;&gt;&gt; c <br/>Counter({'b'}:4)</span></pre><h2 id="a16f" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">Collections.deque</h2><p id="aed2" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">双端队列是一种双端队列。deque上最常见的操作是append、appendleft、pop和popleft。所有这些函数的运行时间都是O(1)，因为底层数据结构是一个链表。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="bc2f" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt;<strong class="mu jf"> </strong>from collections import deque<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>d.append('c')<br/>&gt;&gt;&gt; d.appendleft('b')<br/>&gt;&gt;&gt; d.appendleft('a')<br/>&gt;&gt;&gt; print(d)<br/>['a', 'b', 'c']</span></pre><h2 id="b3a2" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">Collections.defaultDict</h2><p id="f9b6" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">defaultDict允许您将字典的值设置为某个预先设置的值。默认的dict可以使用一种类型(比如list)来初始化，在这种情况下，值将被设置为</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7d68" class="md lb je mu b gy my mz l na nb">from collections import defaultdict<br/>s = [('a', 1), ('a', 2), ('b', 3)]<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>d = defaultdict(list)<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>for k, v in s:<br/><strong class="mu jf">... </strong>    d[k].append(v)<br/><strong class="mu jf">...</strong><br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>sorted(d.items())<br/>&gt;&gt;&gt; [('a':[1, 2]), ('b':[3])]</span></pre><h2 id="4d4c" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">Collections.orderedDict</h2><p id="aca0" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在一个常规的Python Dict对象中，键是没有顺序的。另一方面，OrderedDict维护键的顺序。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d14b" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; form collections import OrderedDict<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>d = OrderedDict.fromkeys('xyz')<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>d.move_to_end('x')<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>''.join(d)<br/>'yzx'<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>d.move_to_end('y', last=False)<br/>&gt;&gt;&gt;<strong class="mu jf"> </strong>''.join(d)<br/>'zxy'</span></pre><h1 id="8d21" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.Itertools</h1><p id="5c2f" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">当处理像排列和笛卡尔积这样的运算时，可以使用Itertools来代替定义自己的迭代器。尽管创建自己的迭代器并不难，但使用Itertools会使代码更简洁，而且被认为更符合习惯。</p><h2 id="97c7" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">Itertools.accumulate</h2><p id="e812" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">accumulate函数接受一个数组的前缀和。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1d97" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; from itertools import accumulate<br/>&gt;&gt;&gt; x = [1, 2 ,3]<br/>&gt;&gt;&gt; res = accumulate(x)<br/>&gt;&gt;&gt; for item in result:<br/>...    print(item)<br/>[1, 3, 6]</span></pre><h2 id="da74" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">Itertools.product</h2><p id="255b" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">product函数返回一个迭代器，它遍历两个或更多列表的笛卡尔积。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1251" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; from itertools import product<br/>&gt;&gt;&gt; x = [1, 2]<br/>&gt;&gt;&gt; y = ['a', 'b']<br/>&gt;&gt;&gt; res = product(x, y) <br/>&gt;&gt;&gt; for item in result:<br/>...    print(item)<br/>(1, 'a')<br/>(2, 'a')<br/>(1, 'b')<br/>(2, 'b')</span></pre><h2 id="18e6" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">Itertools .置换</h2><p id="5242" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">给你一个列表的所有排列。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f4fe" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; from itertools import permutations<br/>&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; res= permutations(x)<br/>&gt;&gt;&gt; for each in res:<br/>...    print(each)<br/>(1, 2, 3)<br/>(1, 3, 2)<br/>(2, 1, 3)<br/>(2, 3, 1)<br/>(3, 1, 2)<br/>(3, 2, 1)</span></pre><h2 id="e3c4" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">Itertools .重复</h2><p id="2305" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Itertools.repeat返回一个迭代器，该迭代器以设定的次数产生某个值。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c081" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; from itertools import product<br/>&gt;&gt;&gt; for i in itertools.repeat("a", 3):<br/>...    print(i)</span><span id="e65c" class="md lb je mu b gy nc mz l na nb">a<br/>a<br/>a</span></pre><h1 id="7723" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.把…分为两个部分</h1><h2 id="eee6" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">平分_左和平分_右</h2><p id="d073" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://docs.python.org/3/library/bisect.html#module-bisect" rel="noopener ugc nofollow" target="_blank">平分</a>给你超级有用的二分搜索法函数:平分_左和平分_右。例如，sector _ left返回插入项的最左边的索引(将其他元素推到右边)，以对数组进行排序。在最右边的索引处插入。</p><p id="25e1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">二分搜索法是一个常见的面试话题——您可以将这个内置函数用作子例程，这样您就不必从头开始实现自己的二分搜索法了！</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a695" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; from bisect import bisect_left<br/>&gt;&gt;&gt; x = [1, 2, 3, 3, 7, 9]<br/>&gt;&gt;&gt; bisect_left(x, 3)<br/>2</span></pre><h1 id="57d9" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.Heapq</h1><p id="9624" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">堆是最常见的数据结构之一。默认情况下，使用<em class="nd"> heapify </em>创建的堆是最小堆。堆推送和弹出操作具有对数时间复杂度。Min-heap也是编码面试中常用的数据结构。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1bc4" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; from heapq import heappush, heappop, heapify<br/>&gt;&gt;&gt; x = [6, 2, 1, 4, 5]<br/>&gt;&gt;&gt; heapify([x)<br/>&gt;&gt;&gt; x[0]<br/>1<br/>&gt;&gt;&gt; heappop(x) <br/>1 <br/>&gt;&gt;&gt; x[0]<br/>2</span></pre><h1 id="569a" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.操作系统（Operating System）</h1><p id="5118" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">os模块提供与操作系统相关的功能，包括操作文件系统的功能。</p><h2 id="b087" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">os.listdir</h2><p id="6028" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这个函数列出了一个路径中的所有文件和目录(到一个目录)。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4616" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; import os<br/>&gt;&gt;&gt; os.listdir("/my_project")<br/>.git <br/>.gitignore<br/>src<br/>tests</span></pre><h2 id="cf72" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">os.mkdir</h2><p id="2302" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">此功能允许您创建一个新目录。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8ff8" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; import os<br/>&gt;&gt;&gt; os.mkdir("/my_new_project")</span></pre><h2 id="674a" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">操作系统.重命名</h2><p id="9ed3" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">此函数将文件或目录从src重命名为dst。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7bf0" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; import os<br/>&gt;&gt;&gt; os.rename("/note1.txt", "/note2.txt")</span></pre><h2 id="0076" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">os。<strong class="ak"> is_dir &amp; os.is_file </strong></h2><p id="7bdf" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这些函数让你发现一个路径是否对应于一个文件或目录。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="60c3" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; import os<br/>&gt;&gt;&gt; os.is_file("/note.txt")<br/>true<br/>&gt;&gt;&gt; os.is_directory("/note.txt")</span></pre><h1 id="9365" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">6.舒蒂尔</h1><p id="9c34" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">shutil模块提供了对文件和目录的高级操作。</p><h2 id="9d96" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">shutil.copyfile</h2><p id="ab9b" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Copyfile将文件src复制到文件dst。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9749" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; import shutil<br/>&gt;&gt;&gt; src = "/tmp/note.txt"<br/>&gt;&gt;&gt; dst = "/usr/tom/note.txt"<br/>&gt;&gt;&gt; shutil.copyfile<!-- -->(src, dst)</span></pre><h2 id="56a5" class="md lb je bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">shutil.copy</h2><p id="3af8" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Copy将文件src复制到新文件或目录dst。</p><h1 id="e87f" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">7.泡菜</h1><p id="310b" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">数据序列化和反序列化在任何编程语言中都很重要。Pickle允许您将Python数据结构转换成字节流。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b854" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; import pickle<br/>&gt;&gt;&gt; owner_to_pets = { "fred": "bunny", "dawson": "dog" }<br/>&gt;&gt;&gt; pickle.dump(owner_to_pets, open( "save.p", "wb" ) )</span></pre><p id="0b7f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要加载pickle文件，我们使用load:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e0e6" class="md lb je mu b gy my mz l na nb">&gt;&gt;&gt; owner_to_pets = pickle.load(open( "save.p", "rb"))<br/>&gt;&gt;&gt; owner_to_pets<br/>{ "fred": "bunny", "dawson": "dog" }</span></pre><p id="01e0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“wb”和“rb”表示写二进制和读二进制。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="1daa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="195d" class="la lb je bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">分级编码</h1><p id="ac6d" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="0c45" class="nq nr je kd b ke kf ki kj km ns kq nt ku nu ky nv nw nx ny bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="3e67" class="nq nr je kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated">📰查看更多内容在<a class="ae kz" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">关卡升级编码</a></li><li id="852a" class="nq nr je kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated">🔔关注我们:<a class="ae kz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank"> Twitter </a> | <a class="ae kz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></li><li id="3925" class="nq nr je kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated">🚀👉<a class="ae kz" href="https://jobs.levelup.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf">软件工程师的顶级工作</strong> </a></li></ul></div></div>    
</body>
</html>