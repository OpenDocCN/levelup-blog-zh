<html>
<head>
<title>Learning C++: The STL and the deque Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL和deque类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-the-stl-and-the-deque-class-2d25b2975835?source=collection_archive---------16-----------------------#2020-04-11">https://levelup.gitconnected.com/learning-c-the-stl-and-the-deque-class-2d25b2975835?source=collection_archive---------16-----------------------#2020-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a951149206785edfce8cd6c680069f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m7JLZJPhhzWZrWAK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@adityachinchure?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aditya Chinchure </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c2d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">deque(发音像“一副”卡片)是一个双面队列，您可以在容器的前面或后面添加和删除数据。Deques不是一个非常常用的容器，但是在一些特殊的应用中有它的用途。当应用程序需要在容器两端添加和删除数据时，deque可能是首选容器。</p><p id="5c08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将演示如何使用deques，并为您提供一些关于它们在应用程序中的使用的文章。</p><h1 id="8201" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建德克</h1><p id="05ac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">与标准模板库(STL)中的其他类一样，<code class="fe mh mi mj mk b">deque</code>类也是一个模板类。您必须先导入它，然后才能在程序中使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ca8d" class="mt lf it mk b gy mu mv l mw mx">#include &lt;deque&gt;</span></pre><p id="9bdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用数据类型和名称声明了一个<code class="fe mh mi mj mk b">deque</code>实例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="930a" class="mt lf it mk b gy mu mv l mw mx">deque&lt;string&gt; words;<br/>deque&lt;int&gt; numbers;</span></pre><p id="c25b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以用一个列表初始化Deques:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="139b" class="mt lf it mk b gy mu mv l mw mx">deque&lt;string&gt; names = {"Cynthia", "Jonathan", "Raymond"};</span></pre><h1 id="276d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">向队列添加数据</h1><p id="64ae" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正如我提到的，数据可以添加在队列的前面或后面。其功能是<code class="fe mh mi mj mk b">push_front</code>和<code class="fe mh mi mj mk b">push_back</code>。下面是这些功能发挥作用的一个例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3b25" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  deque&lt;string&gt; names;<br/>  names.push_back("Cynthia");<br/>  names.push_front("Jonathan");<br/>  names.push_back("Danny");<br/>  names.push_front("Raymond");<br/>  for (const string s : names) {<br/>    cout &lt;&lt; s &lt;&lt; " "; // Raymond Jonathan Cynthia Danny<br/>  }<br/>  return 0;<br/>}</span></pre><p id="8b9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我包含了一个range <code class="fe mh mi mj mk b">for</code>循环来演示访问队列元素的顺序。</p><h1 id="ed2e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">访问队列的元素</h1><p id="eebe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我已经演示了一种访问deque元素的方法——range<code class="fe mh mi mj mk b">for</code>循环。如果想通过队列中的索引位置访问元素，可以使用<code class="fe mh mi mj mk b">at</code>函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d046" class="mt lf it mk b gy mu mv l mw mx">for (unsigned i = 0; i &lt; names.size(); i++) {<br/>  cout &lt;&lt; names.at(i) &lt;&lt; " ";<br/>}</span></pre><p id="8278" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以使用迭代器遍历一个队列:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="aa3e" class="mt lf it mk b gy mu mv l mw mx">for (auto iter = names.begin(); iter != names.end(); iter++) {<br/>  cout &lt;&lt; *iter &lt;&lt; " ";<br/>}</span></pre><p id="9770" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于更细粒度的访问，函数<code class="fe mh mi mj mk b">front</code>和<code class="fe mh mi mj mk b">back</code>分别用于访问队列前端和后端的元素。下面是它们用法的一个例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ebe5" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  deque&lt;string&gt; names;<br/>  names.push_back("Cynthia");<br/>  names.push_front("Jonathan");<br/>  names.push_back("Danny");<br/>  names.push_front("Raymond");<br/>  cout &lt;&lt; "Front of deque: " &lt;&lt; names.front() &lt;&lt; endl;<br/>  // Raymond<br/>  cout &lt;&lt; "Back of deque: " &lt;&lt; names.back() &lt;&lt; endl;<br/>  // Danny<br/>  return 0;<br/>}</span></pre><h1 id="19e5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">删除队列元素</h1><p id="d384" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">从队列中删除元素最常见的方法是调用<code class="fe mh mi mj mk b">pop_front</code>函数从队列的前面删除元素，调用<code class="fe mh mi mj mk b">pop_back</code>函数从队列的后面删除元素。这些是最常见的删除函数，因为使用deque的主要原因是为了快速有效地从前面或后面删除元素。如果您不需要这些效率，就不应该使用deque。</p><p id="1161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个在程序中使用<code class="fe mh mi mj mk b">pop_front</code>和<code class="fe mh mi mj mk b">pop_back</code>的例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="88a2" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  deque&lt;string&gt; names;<br/>  names.push_back("Cynthia");<br/>  names.push_front("Jonathan");<br/>  names.push_back("Danny");<br/>  names.push_front("Raymond");<br/>  cout &lt;&lt; "Removing the front of the deque: " &lt;&lt; endl;<br/>  names.pop_front();<br/>  cout &lt;&lt; "Removing the back of the deque: " &lt;&lt; endl;<br/>  cout &lt;&lt; "The front element is now: "<br/>       &lt;&lt; names.front() &lt;&lt; endl;  // front is Jonathan<br/>  cout &lt;&lt; "The back element is now: " &lt;&lt; names.back() &lt;&lt; endl;<br/>  // back is Danny<br/>  return 0;<br/>}</span></pre><p id="a192" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与其他容器一样，可以通过迭代器移除特定的元素。这里有一个例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f379" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  deque&lt;string&gt; names;<br/>  names.push_front("Mayo");<br/>  names.push_back("Cynthia");<br/>  names.push_front("Jonathan");<br/>  names.push_back("Danny");<br/>  names.push_front("Raymond");<br/>  for (const string s : names) {<br/>    cout &lt;&lt; s &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  string removeElement = "Mayo";<br/>  auto iter = names.begin();<br/>  while (*iter != "Mayo") {<br/>    iter++;<br/>  }<br/>  names.erase(iter);<br/>  for (const string s : names) {<br/>    cout &lt;&lt; s &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="63c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1afb" class="mt lf it mk b gy mu mv l mw mx">Raymond Jonathan Mayo Cynthia Danny</span><span id="dc68" class="mt lf it mk b gy my mv l mw mx">Raymond Jonathan Cynthia Danny</span></pre><h1 id="e3eb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查一个空的队列并清除一个队列</h1><p id="1c7e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">deque类有两个您可以使用的实用函数，<code class="fe mh mi mj mk b">empty</code>和<code class="fe mh mi mj mk b">clear</code>。<code class="fe mh mi mj mk b">empty</code>函数检查队列中是否有数据，返回<code class="fe mh mi mj mk b">true</code>或<code class="fe mh mi mj mk b">false</code>，<code class="fe mh mi mj mk b">clear </code>函数将删除队列中的所有数据。下面是一个使用这两个函数的程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5806" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  deque&lt;string&gt; names;<br/>  names.push_front("Mayo");<br/>  names.push_back("Cynthia");<br/>  names.push_front("Jonathan");<br/>  names.push_back("Danny");<br/>  names.push_front("Raymond");<br/>  cout &lt;&lt; "Size of deque: " &lt;&lt; names.size() &lt;&lt; endl;<br/>  if (!names.empty()) {<br/>    names.clear();<br/>  }<br/>  cout &lt;&lt; "Size of deque: " &lt;&lt; names.size() &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><h1 id="aaf4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Deque的示例应用程序</h1><p id="cd6f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">deque的一个用途是确定一个单词是否是回文。如果一个单词是通过把它的字母从后面压入deque而形成的，而一个新单词是通过把它的字母也从后面弹出而形成的，那么这个单词就是一个回文。</p><p id="eb8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序演示了这一点:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="086d" class="mt lf it mk b gy mu mv l mw mx">bool checkPal(string word) {<br/>  deque&lt;char&gt; letters;<br/>  string rword = "";<br/>  for (unsigned i = 0; i &lt; word.size(); i++) {<br/>    letters.push_back(word[i]);<br/>  }<br/>  while (!letters.empty()) {<br/>    rword += letters.back();<br/>    letters.pop_back();<br/>  }<br/>  if (word == rword) {<br/>    return true;<br/>  }<br/>  return false;<br/>}</span><span id="6ac9" class="mt lf it mk b gy my mv l mw mx">int main()<br/>{<br/>  string aWord;<br/>  cout &lt;&lt; "Enter a word: ";<br/>  cin &gt;&gt; aWord;<br/>  if (checkPal(aWord)) {<br/>    cout &lt;&lt; aWord &lt;&lt; " is a palindrome." &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; aWord &lt;&lt; " is not a palindrome." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="473d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的两次运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="05a6" class="mt lf it mk b gy mu mv l mw mx">Enter a word: radar<br/>radar is a palindrome.</span><span id="c9b8" class="mt lf it mk b gy my mv l mw mx">Enter a word: hello<br/>hello is not a palindrome.</span></pre><h1 id="0ae5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Deques的一些可能应用</h1><p id="f0fd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">像队列一样，deque的一个真正用途是在模拟中。一个可能的模拟是铁路调车场，其中有多条轨道供轨道车停放，但只有调车场末端的轨道允许轨道车进出。您可以使用队列来模拟这种情况，因为队列只允许从前面或后面输入和输出，模拟铁路站场的侧轨。</p><p id="31b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">双队列的另一个用途是跟踪网页浏览历史。被访问的新网站被放在队列的前面，一段时间后，旧的被访问网站被从队列的后面移除。</p><p id="5e76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">deque不是一个经常使用的容器，但是它确实有它的用途，应该考虑用于可以从容器的前端或后端添加和删除数据的应用程序。</p><p id="65e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请发送电子邮件提出意见和建议。</p></div></div>    
</body>
</html>