<html>
<head>
<title>Cool New Features Released in TypeScript 3.7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 3.7中发布的很酷的新功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cool-news-features-released-with-typescript-3-7-4d65adc8c994?source=collection_archive---------4-----------------------#2019-12-03">https://levelup.gitconnected.com/cool-news-features-released-with-typescript-3-7-4d65adc8c994?source=collection_archive---------4-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ea884014e1e6564f736df8e7f2fc77c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NdQUn5sZiIJ0ImV8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@joshrako?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Josh Rakower </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0f97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着TypeScript 3.7的发布，ES2020中包含的一些出色的新功能现已成为TypeScript的一部分。新特性包括可选链接、无效合并、检查未调用函数等等。</p><p id="7b5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将更详细地研究其中的一些。</p><h1 id="34ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可选链接</h1><p id="3a6a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">可选链接是一个特性，它让我们获得一个对象的深层嵌套属性，而不用担心任何属性是<code class="fe mh mi mj mk b">null</code>还是<code class="fe mh mi mj mk b">undefined</code>。</p><p id="8f9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">?.</code>操作符来获取对象的属性，而不是使用通常的点操作符。例如，不要写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="061d" class="mt lf it mk b gy mu mv l mw mx">let x = a.b.c.d;</span></pre><p id="f5f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="44d8" class="mt lf it mk b gy mu mv l mw mx">let x = a?.b?.c?.d;</span></pre><p id="8305" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用可选的链接操作符，我们不必担心属性<code class="fe mh mi mj mk b">b</code>或<code class="fe mh mi mj mk b">c</code>为空或未定义，这使我们不必编写大量代码来检查这些属性是否存在。</p><p id="a64b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果任何中间属性为空或未定义，则返回undefined，而不是使应用程序出错。</p><p id="2045" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们不再需要写这样的东西:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ddc4" class="mt lf it mk b gy mu mv l mw mx">let x = a &amp;&amp; a.b &amp;&amp; a.b.c &amp;&amp; a.b.c.d;</span></pre><p id="15a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe mh mi mj mk b">a</code>对象中获取<code class="fe mh mi mj mk b">d</code>属性。</p><p id="b1ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的一点是，如果<code class="fe mh mi mj mk b">strictNullChecks</code>标志为on，那么如果我们在一个函数中使用可选的链接操作符对一个表达式进行操作，而这个函数的参数将可选的参数作为操作数，那么我们将会得到错误。</p><p id="f270" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="13b1" class="mt lf it mk b gy mu mv l mw mx">let a = { b: { c: { d: 100 } } };<br/>const divide = (a?: { b: { c: { d: 100 } } }) =&gt; {<br/>  return a?.b?.c?.d / 100;<br/>}</span></pre><p id="8a3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到错误“对象可能是‘未定义的’”。(2532)'.</p><h1 id="f699" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">无效合并</h1><p id="1846" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">nullish合并操作符让我们在某个值为空或未定义时给它赋予一个默认值。</p><p id="527b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">带有无效合并的表达式如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="226a" class="mt lf it mk b gy mu mv l mw mx">let x = foo ?? bar;</span></pre><p id="7b84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<code class="fe mh mi mj mk b">??</code>是无效合并运算符。</p><p id="8615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d15c" class="mt lf it mk b gy mu mv l mw mx">let x = null;<br/>let y = x ?? 0;<br/>console.log(y); // 0</span></pre><p id="a2e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到0作为<code class="fe mh mi mj mk b">y</code>的值。</p><p id="bde7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很方便，因为替代方法是使用<code class="fe mh mi mj mk b">||</code>操作符来分配默认值。左操作数上的任何falsy值都会导致右操作数上的默认值被赋值，这可能并不总是我们想要的。</p><p id="6470" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">nullish合并运算符仅在左操作数为空或未定义时分配默认值。</p><p id="0246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="84c0" class="mt lf it mk b gy mu mv l mw mx">let x = 0;<br/>let y = x || 0.5;</span></pre><p id="0638" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，0是一个可以赋给<code class="fe mh mi mj mk b">y</code>的有效值，但是我们还是给它赋了默认值0.5，因为0是falsy，这是我们不希望的。</p><h1 id="2458" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">断言函数</h1><p id="48c2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript 3.7附带了<code class="fe mh mi mj mk b">asserts</code>关键字，允许我们编写自己的函数来对数据进行一些检查，如果检查失败，就会抛出一个错误。</p><p id="04cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来检查传递给断言函数的参数是否是数字:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5dc6" class="mt lf it mk b gy mu mv l mw mx">function assertIsNumber(x: any): asserts x is number {<br/>    if (typeof x === 'number') {<br/>        throw new Error('x is not a number');<br/>    }<br/>}<br/>assertIsNumber('1');<br/>assertIsNumber(1);</span></pre><p id="c7b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行上面的代码时，我们应该得到‘未捕获的错误:x不是一个数字’。</p><p id="fdd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mh mi mj mk b">asserts</code>关键字检查它后面的任何条件。</p><p id="3f6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个返回<code class="fe mh mi mj mk b">void</code>的函数，这意味着它不返回任何东西。它只能在不满足我们定义的条件时抛出错误。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/2ad3d8320a048944a41a18f520c2d6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8qoQfU01kMrE6vML"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">freestocks.org</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="6bb5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更好地支持返回Never类型的函数</h1><p id="9736" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在TypeScript 3.7中，现在TypeScript编译器识别出返回<code class="fe mh mi mj mk b">never</code>类型的函数运行在返回其他类型的函数中。</p><p id="bb8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，在TypeScript 3.7之前，我们必须编写以下代码来避免错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="71fc" class="mt lf it mk b gy mu mv l mw mx">const neverFn = (): never =&gt; { <br/>    throw new Error();<br/>};</span><span id="206e" class="mt lf it mk b gy mz mv l mw mx">const foo = (x: string | number): number =&gt; {<br/>    if (typeof x === 'string') {<br/>        return +x;<br/>    }<br/>    else if (typeof x === 'number') {<br/>        return x;<br/>    }<br/>    return neverFn();<br/>}</span></pre><p id="4596" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码会给我们一个错误“函数缺少结束返回语句，返回类型不包含‘undefined’。”因为我们确实在<code class="fe mh mi mj mk b">neverFn()</code>函数调用之前加了<code class="fe mh mi mj mk b">return</code>。</p><p id="555b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">早于3.7的TypeScript版本不将never函数识别为有效路径，因为如果指定了返回类型，它不允许在返回<code class="fe mh mi mj mk b">undefined</code>的代码中使用路径。</p><p id="f7ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果使用TypeScript 3.7来编译代码，删除<code class="fe mh mi mj mk b">return neverFn();</code>中的<code class="fe mh mi mj mk b">return</code>就可以了。</p><h1 id="2bd6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">允许一些递归类型别名</h1><p id="9c3c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript 3.7现在允许未分配给自身的类型别名。例如，以下内容仍然是不允许的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="806e" class="mt lf it mk b gy mu mv l mw mx">type Bar = Bar;</span></pre><p id="e3c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它只是用自己永远取代了<code class="fe mh mi mj mk b">Bar</code>类型。</p><p id="9454" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们试图编译上面的代码，我们会得到错误“类型别名‘Bar’循环引用自身”。(2456)".</p><p id="2461" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，现在我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="852b" class="mt lf it mk b gy mu mv l mw mx">interface Foo { };<br/>interface Baz { };<br/>type Bar = Foo | Baz | Bar[];</span></pre><p id="6cc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为<code class="fe mh mi mj mk b">Bar[]</code>类型没有直接替换<code class="fe mh mi mj mk b">Bar</code>，所以这种类型的递归是允许的。</p><h1 id="97cc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">AllowJs标志打开时生成声明文件</h1><p id="ec5f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在TypeScript 3.7之前，当<code class="fe mh mi mj mk b">--allowJs</code>标志打开时，我们不能生成声明文件，所以用JavaScript编译的TypeScript代码不能生成任何声明文件。</p><p id="e3b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着不能对正在编译的JavaScript文件进行类型检查，即使它们有JSDoc声明。</p><p id="817a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这个改变，现在可以用这些JavaScript文件进行类型检查了。</p><p id="42fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以用JSDoc带注释的JavaScript编写库，用同样的代码支持TypeScript用户。</p><p id="164c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从3.7开始，TypeScript编译器将从JSDoc注释中推断JavaScript代码的类型。</p><h1 id="95de" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">未调用的函数检查</h1><p id="6b20" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通过省略括号忘记调用函数是一个问题，有时会导致错误。例如，如果我们编写以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0df6" class="mt lf it mk b gy mu mv l mw mx">const foo = () =&gt; { };</span><span id="2527" class="mt lf it mk b gy mz mv l mw mx">const bar = () =&gt; {<br/>    if (foo) {<br/>        return true;<br/>    }<br/>}</span></pre><p id="ea7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会得到错误“这个条件总是返回真，因为函数总是被定义的。你的意思是叫它代替？(2774)“当我们写上面的代码，尝试用TypeScript 3.7编译器编译时。</p><p id="e38a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在3.7版本之前，这段代码不会给出任何错误。</p><h1 id="8824" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f982" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正如我们所看到的，TypeScript 3.7给了我们许多以前没有的有用的新特性。可选的链接和nullish联合操作符可以方便地避免null或未定义的错误。</p><p id="0985" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">识别返回<code class="fe mh mi mj mk b">never</code>类型的函数调用对于用不总是返回的路径编写代码也很方便。</p><p id="1580" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拥有递归类型别名有助于将某些类型组合成一个别名。</p><p id="cff9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于编写库的开发人员来说，通过检查JSDoc注释，TypeScript 3.7可以从用TypeScript编译器编译的JavaScript文件中推断类型。</p><p id="141a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，未调用的函数现在会被TypeScript编译器检查，如果它们被编写得像我们试图将它作为属性来访问一样。</p></div></div>    
</body>
</html>