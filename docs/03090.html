<html>
<head>
<title>Reactive Asynchronous Programming in Java using Reactor Core (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Reactor Core在Java中进行反应式异步编程(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reactive-asynchronous-programming-in-java-using-reactor-core-part-2-e9c6caeb8833?source=collection_archive---------0-----------------------#2020-04-19">https://levelup.gitconnected.com/reactive-asynchronous-programming-in-java-using-reactor-core-part-2-e9c6caeb8833?source=collection_archive---------0-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="4314" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="c308" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇博客文章是关于学习异步和反应式编程的两部分系列文章的第2部分。如果你还没有机会阅读<strong class="kq iu">第1部分</strong>，即使这不是必需的，我也强烈建议你这样做，以正确设置上下文。</p><p id="b8c7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/reactive-asynchronous-programming-in-java-using-reactor-core-part-1-cd516dd579fe"> <strong class="kq iu"> <em class="ls">【使用Reactor Core的Java反应式异步编程(上)</em> </strong> </a></p><p id="b058" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这一部分将<strong class="kq iu"> <em class="ls">更强烈一点，更长一点，</em> </strong>建立在我们目前已经看到的基础上。我尽量让解释简短，尽可能提供简单的例子。</p><p id="6b64" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在这一部分，我们将了解更多关于反应堆堆芯的构建模块(即<code class="fe lt lu lv lw b"><strong class="kq iu">Flux</strong> </code>和<code class="fe lt lu lv lw b"><strong class="kq iu">Mono</strong></code>)以及你如何将你的作品<strong class="kq iu">构建成一条由独立的可组合部分组成的流水线</strong>。我们将看看不同类型的发行商，如<code class="fe lt lu lv lw b">Hot Publisher</code>和<code class="fe lt lu lv lw b">Cold Publisher</code>，以及你想使用它们的一些场景。</p><p id="d867" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后，我们将围绕<strong class="kq iu"> <em class="ls">调度器</em> </strong>学习一些关键的思想和概念。<strong class="kq iu">调度器</strong>非常强大，<strong class="kq iu">它们允许我们以一种高效的方式在阻塞和非阻塞世界之间架起桥梁</strong>(稍后你会看到更多)。我们还将看到向这些<strong class="kq iu">发布者</strong>提供我们自己的定制<strong class="kq iu">调度程序</strong>是多么容易，他们可以在那些<strong class="kq iu">调度程序</strong>中运行他们的工作。但是，请记住一件事，调度程序本身不会神奇地完成工作，<strong class="kq iu">我们需要通过Publisher的<em class="ls"> subscribeOn </em>和<em class="ls">publish on</em>API</strong>将我们的工作管道连接到调度程序，这两者都非常强大，我们将看到如何在现实世界的场景中利用它们。</p><p id="72b4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">接下来，我们将学习<strong class="kq iu">错误处理</strong>以及我们如何处理<code class="fe lt lu lv lw b">try catch</code>和<code class="fe lt lu lv lw b">Exceptions</code>。您将会看到，不仅处理错误<strong class="kq iu">是多么容易，而且为一些优雅的恢复提供替代路径</strong>或再次重试该工作也是多么容易。我们将尝试对我们的强制异常处理进行一对一的映射，并查看它们在Reactor和一般反应式编程中的对应部分。</p><p id="093d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">最后，我们将学习返回通量或单声道函数的单元测试。在带有<strong class="kq iu"> <em class="ls"> StepVerifier </em> </strong>的Reactor中，它有助于针对这种反应式系统运行测试，我们可以验证所有类型的流及其预期，甚至不需要订阅(在测试期间，您不知道订阅会在哪里发生)。此外，在<strong class="kq iu"> <em class="ls">时间内，Flux是一个无限的事件/消息流，即使测试也可能需要很长时间，我们将利用助手来模拟时间</em> </strong>以进行有效和快速的测试，我们将看到使用<code class="fe lt lu lv lw b">withVirtualTime</code>我们可以使它变得真正简单)。</p><p id="998d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们有很多地方要去，所以不要再多说了，让我们一起踏上这段旅程吧。</p><blockquote class="lx ly lz"><p id="2a49" class="ko kp ls kq b kr lm kt ku kv ln kx ky ma lo lb lc mb lp lf lg mc lq lj lk ll im bi translated"><strong class="kq iu">注:</strong>为了说明一些概念，经<strong class="kq iu">西蒙·巴斯莱(</strong><a class="ae lr" href="https://twitter.com/simonbasle" rel="noopener ugc nofollow" target="_blank">@西蒙巴索</a> <strong class="kq iu"> ) </strong>从甲板上<a class="ae lr" href="https://speakerdeck.com/simonbasle/flight-of-the-flux" rel="noopener ugc nofollow" target="_blank">《飞流》</a>，你也可以在这里找到精彩的演讲<a class="ae lr" href="https://www.youtube.com/watch?v=hfupNIxzNP4" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><h1 id="6c10" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><em class="md">出版商通量</em>和Mono在行动</h1><p id="0a44" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是对前一篇文章的快速回顾，但我认为这是值得的，所以让我们快速回顾一下关于它们的更多细节，</p><p id="6fe9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">一个<code class="fe lt lu lv lw b"><strong class="kq iu">Publisher</strong></code>可以将新的值推送到它的<code class="fe lt lu lv lw b"><strong class="kq iu">Subscriber</strong></code>(通过调用<code class="fe lt lu lv lw b"><strong class="kq iu">onNext</strong></code>)，但也可以发出出错(通过调用<code class="fe lt lu lv lw b"><strong class="kq iu">onError</strong></code>)或完成(通过调用<code class="fe lt lu lv lw b"><strong class="kq iu">onComplete</strong></code>)的信号。错误和完成都会终止序列。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/b72a529a7f1b5b86cdc534f1209eb45c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tV1QoBH2TuluImRFSoctqQ.png"/></div></div></figure><p id="740d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">反应器中有两个主要的原语<strong class="kq iu">发布者</strong>，<strong class="kq iu"> <em class="ls">，</em> </strong>和<em class="ls">单色</em> </p><h1 id="1de6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">流量</h1><p id="1c9e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="kq iu"> Flux </strong>是Reactor中的一个通用标准发布器，它可以发布一个<code class="fe lt lu lv lw b">&lt;T&gt;</code>类型的数据/事件，并且可以异步产生从0到N的<strong class="kq iu">值。</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mq"><img src="../Images/5c9b236276f84d54eb547ae6be80af06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuQjkwEDvZzdtOSu7_uX2g.png"/></div></div></figure><p id="385b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> Flux </strong>自带一些工厂方法来构建Flux，比如。<code class="fe lt lu lv lw b"><strong class="kq iu">Flux#just()</strong> or <strong class="kq iu">Flux#fromIterable()</strong> or <strong class="kq iu">Flux#fromStream()</strong></code>等。很少有像<code class="fe lt lu lv lw b"><strong class="kq iu">Flux#range()</strong></code>或<code class="fe lt lu lv lw b"><strong class="kq iu">Flux#interval</strong></code>这样特别有趣的，我们会在这篇文章中反复使用。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c941" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">但是Flux的创建不仅仅局限于工厂方法，它的API提供了一个带有<code class="fe lt lu lv lw b">generate() and create()</code>方法的低级接口，在那里你可以生成任意的Flux。</p><p id="2683" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">以编程方式创建<code class="fe lt lu lv lw b">Flux</code>的最简单形式是通过<code class="fe lt lu lv lw b">generate</code>方法，该方法采用一个生成器函数。这是为了<strong class="kq iu">同步</strong>和<strong class="kq iu">逐个</strong>排放</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="600f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><code class="fe lt lu lv lw b"><strong class="kq iu">create</strong></code>提供更低层次的API，可以<strong class="kq iu">处理数据的异步多线程发送</strong>。这是解释从常规Java世界过渡到反应式世界的一种方法的绝佳场所。让我解释一下，假设你有一个常规的基于Java事件监听器的APIs)发送下一个需要处理的数据块(2)通知T21完成进程(2)。因此，问题是我们如何能得到这样的大块的流量，然后反应性地处理它们。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="ea98" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">单声道的</h1><p id="d8d4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lr" href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iu"> Mono </strong> </a>简单来说就是可以产生<strong class="kq iu">零或者最多产生一个值的发布者。</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mt"><img src="../Images/8ebd931c147ec499a536a95002140d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0T6q3gFGhQIuk6x_RGgZeQ.png"/></div></div></figure><p id="5f2b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你可能会问为什么只有一个值的发布者有一个特殊的类型，因为Flux可以处理任何数量的项目，包括一个值。基本上，<strong class="kq iu">原因在于可用性和上下文</strong>，大多数情况下，对于程序员和价值观的消费者来说，Mono与Flux之间的关系可以提供很多关于如何处理它们的信息。例如，来自http调用的<strong class="kq iu"> ServerResponse </strong>被建模为Mono。现在你可以想象在任何情况下，来自GET或POST调用的http ServerResponse都不可能是一个流，这使得很多东西更容易构建、编码和测试。(我们有用于流式传输的<strong class="kq iu"> SSEs </strong>，但我们不要深入讨论它)</p><p id="efa8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">工厂方法<strong class="kq iu"> <em class="ls">与焊剂</em> </strong>相似，但仅限于一个项目。在这篇文章的后面，你会看到Mono将阻塞呼叫转换为非阻塞响应呼叫的强大功能。</p><h1 id="1d20" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">发布服务器上的平面映射运算符</h1><p id="724c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">发布者通过操作者来转换数据、聚合数据、过滤数据，直到你找到订阅者。有很多运营商，像<code class="fe lt lu lv lw b">map() filter()</code>等。这对我们所有这些都有帮助。但是有一个操作符<code class="fe lt lu lv lw b">flatMap</code>被广泛使用，需要一些解释，至少我偶然发现过几次，</p><p id="d214" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所以，我决定花些精力来解释什么是<code class="fe lt lu lv lw b">flatMap</code>以及它如何有用。以后你会发现我们的例子里充满了<code class="fe lt lu lv lw b">flatMap</code> s。</p><p id="e401" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">从概念上讲，<code class="fe lt lu lv lw b">map</code>只是一次映射一个集合，对应的每个集合都会给映射器产生一个值。现在，产生的值有时本身是嵌套的集合或对象，除非被展平，否则不能用于下一个操作。因此，在这些情况下，我们首先<code class="fe lt lu lv lw b">map</code>，然后<code class="fe lt lu lv lw b">flatten</code>收集。</p><p id="278d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">考虑下面的例子，其中有一个<code class="fe lt lu lv lw b">List&lt;Parcel&gt;</code>，每个包裹可以包含不止一个商品。如果你想从所有的包中得到单个的项目，单独使用<code class="fe lt lu lv lw b">map</code>是不行的。你必须使用如图所示的<code class="fe lt lu lv lw b">flatMap</code>。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mu"><img src="../Images/154a54af2e4dfbe93f441d6eea9643da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrmBD3rE0csKcBvZCn7k6Q.jpeg"/></div></div></figure><p id="c8e1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，当我们将定义扩展到map 之后的异步操作时，这种扁平化变得<strong class="kq iu">非常强大，比如当您<code class="fe lt lu lv lw b">map</code>在集合上，并且每个映射的项目本身需要做一些异步操作(基本上，返回另一个发布者)来进行扁平化，然后它们才能在下一个链中单独使用或传递<code class="fe lt lu lv lw b">flatMap</code>变得非常有用。请看反应堆上的<strong class="kq iu">平面图</strong>的不同之处，</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mv"><img src="../Images/0ce8b53249e413a9a39a688ecc5ae62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBP15MIfrKGUvgW5R2Ewfg.png"/></div></div></figure><p id="8c6d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在上面的场景中，你可以看到，如果我们使用<code class="fe lt lu lv lw b">flatMap</code>，它不仅映射集合，而且对于每个集合，通过订阅发布者来完成异步任务，以提取值，然后将它们展平为我们的常规值。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mw"><img src="../Images/2f11ff1023ffa7f53ce1f4fb8b7d4a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Axtv6JKqjpzWGIrJu2-g7w.png"/></div></div></figure><p id="eece" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，你对<code class="fe lt lu lv lw b">flatMap</code>的用法有所了解了。我们可以说,<code class="fe lt lu lv lw b">flatMap</code>可以在发布者链中使用，只要我们需要在处理步骤中执行更多的异步操作，并在进入下一步之前完成所有操作。</p><p id="2d5d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，假设我们需要显示组织前10名员工的最爱，如果步骤是首先获取员工，获取前10名，然后获取他们每个人的偏好，然后将他们汇总在一起，您会看到这类事情的<code class="fe lt lu lv lw b">flatMap</code>。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="b6b4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">热门出版商和冷门出版商</h1><p id="4cc3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">到目前为止，我还没有谈到一个发布者<strong class="kq iu"> <em class="ls">发布给多个订阅者</em> </strong>。在<strong class="kq iu">发布/订阅模式</strong>中，这很有可能发生。这就是您订阅的发布者类型变得重要的地方。</p><p id="e248" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所以，Reactor中有两种发布者，<em class="ls">冷发布者</em>和<em class="ls">热发布者。</em>如果发布者为每个订阅重新生成数据，则该发布者被称为<strong class="kq iu">Cold。如果没有创建订阅，则永远不会生成数据。但是，每个新订阅都将从头开始获取全部数据。到目前为止，我们看到的例子都是冷冰冰的出版商。例如，考虑一个HTTP请求:每个新订户触发一个HTTP调用，但是如果没有人对结果感兴趣，就不会进行调用。</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mx"><img src="../Images/0ca4ff02b2c335a94cd7388448797f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P22ixN41LKzciJDVGKsdQ.png"/></div></div></figure><p id="0d53" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">另一方面，热门发布者</strong>不依赖于任何数量的订阅者。他们可能会立即开始发布数据，并在新的 <code class="fe lt lu lv lw b"><strong class="kq iu">Subscriber</strong></code> <strong class="kq iu">到来时继续发布<strong class="kq iu">(在这种情况下，订阅者只会看到在它订阅了</strong>的之后发出的<em class="ls">新元素)</em></strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi my"><img src="../Images/2ed5289694ea1c97afc9cd65fd40852a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xv6fXRe_vXarToHd8zkiFw.png"/></div></div></figure><p id="9001" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> <em class="ls">每一个出版者开始都是冷的</em> </strong>，我们可以在一个冷的出版者身上调用<code class="fe lt lu lv lw b">publish()</code>的方法使其变热。一旦publish被调用，您将获得一个<code class="fe lt lu lv lw b">ConnectableFlux&lt;T&gt;</code>作为发布者的返回值。当<code class="fe lt lu lv lw b">publish()</code>被调用时，你订阅这个<strong class="kq iu"> <em class="ls"> connectableFlux(在这个例子中是publisher)</em></strong>而不是原始的Flux来获得热发布。这样，现在可以订阅同一个发布者，它将在订阅后仅发出新数据。但是在这里，你必须使用<code class="fe lt lu lv lw b">connect()</code>来启动整个有意义的链，因为对于<strong class="kq iu"> HotPublishers </strong>我们必须告诉它何时应该开始发布数据。请看下面一个热门出版商的例子，</p><h2 id="1ffe" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">Cold Publisher示例</h2><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="614d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以在结果中看到，即使第二个订户在3秒钟后订阅，它仍然从开始开始设置值。这是Reactor中任何发布者的默认行为。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nl"><img src="../Images/49c3a93cf905e1be04afd83a1249f47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F36Mn8k6nUQJhDPmhamrtA.png"/></div></div></figure><h2 id="7cae" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">热门发布者示例</h2><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="63de" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以在结果中看到，第二个订户<strong class="kq iu">仅从3秒开始获取值，也就是从3秒开始</strong>，并且错过了0，1，2。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nm"><img src="../Images/326e615041e4d5928360b531a935a7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1xzMfwhTze_kDhZZ8bhNw.png"/></div></div></figure><h1 id="5148" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">订阅者</h1><p id="172c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Reactor中，当你写一个<code class="fe lt lu lv lw b"><strong class="kq iu">Publisher</strong></code>链时，默认情况下数据不会开始注入其中。相反，您可以创建异步流程的抽象描述(这有助于重用和组合)。</p><p id="c2ce" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> <em class="ls">你可以把它想象成一条汽车装配线，发行商链就是装配，每个操作者都是汽车(或其部件)的实际操作者，但在有人订购汽车之前，任何工作都没有完成。只有当有人订购汽车时，装配线才开始生产，并将材料和零件转化为一辆成熟的汽车。</em> </strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nn"><img src="../Images/0c35d0bcf44b61f56db613a021c490c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnnepLv-YG4w0O9LU7dNdQ.png"/></div></div></figure><p id="3e27" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我强调这个类比是因为<strong class="kq iu"> <em class="ls">我们将再次回到这个类比来理解并发性。</em> </strong></p><p id="48ef" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，通过<strong class="kq iu">订阅</strong>的行为，您将<code class="fe lt lu lv lw b"><strong class="kq iu">Publisher</strong></code>绑定到了一个<code class="fe lt lu lv lw b"><strong class="kq iu">Subscriber</strong></code>，这触发了整个链中的数据流。这是通过来自<code class="fe lt lu lv lw b"><strong class="kq iu">Subscriber</strong></code>的单个<code class="fe lt lu lv lw b"><strong class="kq iu">request</strong></code>信号在内部实现的，该信号向上游传播，一直回到信号源<code class="fe lt lu lv lw b"><strong class="kq iu">Publisher</strong></code>。</p><blockquote class="lx ly lz"><p id="64b4" class="ko kp ls kq b kr lm kt ku kv ln kx ky ma lo lb lc mb lp lf lg mc lq lj lk ll im bi translated"><strong class="kq iu"> <em class="it">在你订阅之前什么都不会发生</em> </strong></p></blockquote><p id="6732" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以用两种不同的形式定义<code class="fe lt lu lv lw b"><strong class="kq iu">Subscriber</strong></code> <strong class="kq iu"> </strong>，一种是基于lambda的表达式，另一种是完整的<code class="fe lt lu lv lw b"><strong class="kq iu">Subscriber</strong></code> <strong class="kq iu"> </strong>类型，您可以通过它进行更多的控制。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi no"><img src="../Images/5994c52ce1b8b114c2ce8881b2b92373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mI4QJny0WxkTbMYTTUaQTQ.png"/></div></div></figure><p id="42b6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">注意，你可以通过<code class="fe lt lu lv lw b">sub</code>句柄随意传递你想要的数据量。默认情况下，<strong class="kq iu">您会收到一个无限制的请求，但是您也可以向发布者</strong>请求特定数量的项目，这是一个非常强大的工具，用于管理<strong class="kq iu">背压</strong>和<strong class="kq iu">多订户场景</strong>。如上所述，定义订户的另一种方法是按类实现一个订户，</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi np"><img src="../Images/e065d07b6d94fcee30436528cc73f520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyUuasV-MrFNUiDe8GTL1A.png"/></div></div></figure><h1 id="b229" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">阻塞世界与非阻塞世界相遇</h1><p id="6913" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">获得一个<code class="fe lt lu lv lw b"><strong class="kq iu">Flux</strong></code>或者一个<code class="fe lt lu lv lw b"><strong class="kq iu">Mono</strong></code>并不一定意味着它运行在一个专用的<code class="fe lt lu lv lw b"><strong class="kq iu">Thread</strong></code>中。相反，大多数操作者继续在<code class="fe lt lu lv lw b"><strong class="kq iu">Thread</strong></code>中工作，上一个操作者已经在该处执行。</p><p id="f890" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">除非指定，最顶层的操作符(源)本身运行在发出<code class="fe lt lu lv lw b"><strong class="kq iu">subscribe()</strong></code>调用的<code class="fe lt lu lv lw b"><strong class="kq iu">Thread</strong></code>上。以下示例在新线程中运行一个<code class="fe lt lu lv lw b"><strong class="kq iu">Mono</strong></code>来显示该点:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="6e99" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">调度程序(并发抽象)</h1><p id="33ce" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Reactor中，执行模型和执行发生的位置由使用的<code class="fe lt lu lv lw b">Scheduler</code>决定，发布者链对此完全不可知。一个<code class="fe lt lu lv lw b"><a class="ae lr" href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html" rel="noopener ugc nofollow" target="_blank">Scheduler</a></code>有类似于一个<code class="fe lt lu lv lw b">ExecutorService</code>的调度职责，但是有一个专用的抽象让它做更多的事情，特别是作为一个时钟和支持更大范围的实现(测试的虚拟时间、蹦床或即时调度，等等)。</p><p id="cbd8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><code class="fe lt lu lv lw b"><a class="ae lr" href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html" rel="noopener ugc nofollow" target="_blank">Schedulers</a></code> helper类有静态工厂方法，可以轻松访问许多类型的执行上下文:</p><ul class=""><li id="fb62" class="nq nr it kq b kr lm kv ln kz ns ld nt lh nu ll nv nw nx ny bi translated"><code class="fe lt lu lv lw b">Schedulers.immediate()</code> —不旋转任何线程，提交的<code class="fe lt lu lv lw b">Runnable</code>将被直接执行，有效地在当前<code class="fe lt lu lv lw b">Thread</code>上运行</li><li id="0b8c" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe lt lu lv lw b">Schedulers.single()</code> —将产生一个可重用的线程，主要用于低风险、维护类的工作负载。如果您想要一个每个调用专用的线程，对每个调用使用<code class="fe lt lu lv lw b">Schedulers.newSingle()</code>。</li><li id="96ba" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe lt lu lv lw b">Schedulers.parallel()</code> —一个固定的工作线程池，针对并行工作进行了优化(主要受CPU限制)，它创建的工作线程数与您拥有的CPU内核数一样多。</li><li id="c348" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe lt lu lv lw b">Schedulers.elastic()</code> —一个无界的弹性线程池。随着<code class="fe lt lu lv lw b">Schedulers.boundedElastic()</code>的引入，这种方法不再是首选，因为它有隐藏背压问题并导致过多线程的趋势(见下文)。这主要用于I/O密集型操作。</li><li id="eef6" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe lt lu lv lw b">Schedulers.boundedElastic()</code> —像它的前身<code class="fe lt lu lv lw b">elastic()</code>一样，它根据需要创建新的工人池，并重用闲置的工人池。闲置时间过长(默认值为60秒)的工作池也会被释放。与它的前任<code class="fe lt lu lv lw b">elastic()</code>不同，它对可以创建的支持线程的数量有一个上限(默认为CPU核心数x 10)</li><li id="5a15" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated"><code class="fe lt lu lv lw b">Schedulers.fromExecutorService(ExecutorService)</code> —使用这个API，您可以从任何现有的<code class="fe lt lu lv lw b">ExecutorService</code>中创建一个<code class="fe lt lu lv lw b">Scheduler</code></li></ul><h1 id="542a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">具有发布和订阅的调度器的执行控制平面</h1><blockquote class="lx ly lz"><p id="25f7" class="ko kp ls kq b kr lm kt ku kv ln kx ky ma lo lb lc mb lp lf lg mc lq lj lk ll im bi translated">好了，有趣的事情从这里开始，如果你正在读这篇文章，那么到目前为止，你已经经历了一次漫长的旅程，给自己一些荣誉，准备好在这一部分看到所有的事情都走到一起。</p></blockquote><p id="bb22" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">发布者</strong>和<strong class="kq iu">调度者</strong>在需要做什么和需要如何做之间创建了一个清晰而独立的边界。现在，回到汽车装配线的类比，<strong class="kq iu">调度人员将像承包商一样，他们自己的工人准备好进行装配所需的特定步骤或工作单元</strong>，认为油漆是由这样的合同完成的。它为需要做什么和谁/如何做创造了一个非常清晰和分离的方法。如果<strong class="kq iu">承包商表现很差，我们不需要正确地改变装配线</strong>，另一方面，如果关于如何油漆的说明不清楚，如“如何完成”是低效的，<strong class="kq iu">您可以改变流程/说明，而不改变执行流程的承包商</strong>。总的来说，这是一种非常灵活的方法。</p><p id="abb1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">事实上，<strong class="kq iu">我喜欢Reactor，因为它更进一步</strong>，如果你有<strong class="kq iu">嵌套的发布者和订阅者，那么他们可以有他们自己的调度器</strong>，这将不受顶级发布者的影响。这就像一个大集会被分成许多小集会，每个小集会可以选择任何形式任何类型的合同和承包商为他们工作。</p><p id="170c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">那么我们如何将这两者结合在一起(即一个发布者和一个调度器)，我们在发布者上使用<code class="fe lt lu lv lw b">publishOn</code>和<code class="fe lt lu lv lw b">subscribeOn</code>API来完成。</p><h2 id="84ae" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">出版</h2><p id="3628" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lt lu lv lw b">publishOn</code>适用于用户链中间的任何其他运营商。它从上游获取信号，并在下游重放它们，同时从相关联的<code class="fe lt lu lv lw b">Scheduler</code>中对一个worker执行回调。因此，<strong class="kq iu">影响后续操作员执行</strong>的位置(直到另一个<code class="fe lt lu lv lw b">publishOn</code>被链接进来)，如下所示:</p><ul class=""><li id="56b1" class="nq nr it kq b kr lm kv ln kz ns ld nt lh nu ll nv nw nx ny bi translated">将执行上下文更改为由<code class="fe lt lu lv lw b">Scheduler</code>选择的一个<code class="fe lt lu lv lw b">Thread</code></li><li id="87cc" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated">根据规范，<code class="fe lt lu lv lw b">onNext</code>调用是按顺序发生的，所以这使用了一个线程</li><li id="5f3b" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated">除非他们在特定的<code class="fe lt lu lv lw b">Scheduler</code>上工作，否则<code class="fe lt lu lv lw b">publishOn</code>之后的操作符继续在同一线程上执行</li></ul><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oe"><img src="../Images/a53cc0dba663cc4ffa0d6bbb21abdb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GP9e09Eyq6xtWttfF8MyQ.png"/></div></div></figure><p id="c8a2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在上图中，我们有一个通量，它执行一些操作，然后在中间使用<code class="fe lt lu lv lw b">publishOn</code>，然后在它结束到订户之前再执行一些操作。这里，蓝色线程可以被认为是触发订阅的调用线程或主线程。</p><p id="87b7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">触发订阅的那个线程(主线程或这里的蓝色线程)将用于所有的工作，除非调度程序另有规定。所以，这里在<code class="fe lt lu lv lw b">publishOn</code>之后<strong class="kq iu">其余操作的执行都交给了指定的调度程序。</strong></p><h2 id="a7be" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">订阅</h2><p id="a817" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lt lu lv lw b">subscribeOn</code>适用于整个订阅流程，当构建后向链时。因此，无论您将<code class="fe lt lu lv lw b">subscribeOn</code>放在链中的哪个位置，<strong class="kq iu">都会影响源发射</strong>的上下文。然而，这并不影响对<code class="fe lt lu lv lw b">publishOn</code>的后续调用的行为——它们仍然切换后面部分链的执行上下文。</p><ul class=""><li id="6f07" class="nq nr it kq b kr lm kv ln kz ns ld nt lh nu ll nv nw nx ny bi translated">改变操作员<strong class="kq iu">全链</strong>订阅的<code class="fe lt lu lv lw b">Thread</code></li><li id="8eb2" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated">从<code class="fe lt lu lv lw b">Scheduler</code>中挑选一根线</li><li id="aff2" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated">实际上只考虑链中最早的<code class="fe lt lu lv lw b">subscribeOn</code>调用</li></ul><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi of"><img src="../Images/48bf3a63c688265b61205e5fd92ff19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhgcAHzLIbbXmaLtW2IHJQ.png"/></div></div></figure><p id="bfb6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在上面例子的<code class="fe lt lu lv lw b">subsribeOn</code>的情况下，手边的情况与<code class="fe lt lu lv lw b">publishOn</code>非常相似，但是<code class="fe lt lu lv lw b">subscribeOn</code>影响整个订阅，因为它在调度器上被调用。</p><p id="2629" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所以在这种情况下，所有的操作都将在<code class="fe lt lu lv lw b">subscribeOn</code>提供的调度程序上运行。</p><h2 id="2f6b" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">带订阅的出版(疯狂吧！)</h2><p id="9f0d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们甚至可以将它们结合起来，为我们在发布者上的整套操作获得我们想要的非常精细的执行模型。这里，<code class="fe lt lu lv lw b">subscribeOn</code>影响整个链，直到您点击另一个<code class="fe lt lu lv lw b">publishOn</code>，然后publishOn将在提供的新调度器上切换剩余的操作。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi og"><img src="../Images/8eee0a8803434e69fd61507bc2572dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orVDMXrTipT0LyESRt3aKw.png"/></div></div></figure><p id="a461" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">看看这个例子，事实上，在这里，订阅影响了整个链，然后发布接管。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oh"><img src="../Images/cefc9722ab98166603a01d6a64ebe74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfTmXtsGfQkzJBpFznc9Kg.png"/></div></div></figure><h1 id="f297" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">让我们用调度程序来实现阻塞调用和非阻塞调用</h1><p id="5047" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们学到了这么多，所以我们可以利用现有的应用程序<strong class="kq iu">,它很可能是一种阻塞类型的工作负载，并将它们转换为这些漂亮的异步发布器</strong>,这样我们就可以利用遗留代码的反应式编程的全部功能。</p><p id="02e2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">为了充分展示这一点，让我们添加一个阻塞方法，它将为我们模拟真实世界的操作，我们知道这实际上是阻塞IO、数据库调用、网络调用等。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c62b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">默认情况下没有任何调度程序，如果你试图通过一个Flux获得细节，我们的主线程会被使用并被阻塞，看看这段代码，</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="94a6" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">尝试#1</h2><p id="d100" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可能会想，哦，这很简单，我们只需添加一个调度程序就可以了。那么，让我们看看当我们添加一个调度程序时会发生什么，</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2ac4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您会看到调度程序中只有一个线程一次选取一个任务，然后返回结果。那么，发生了什么！这不是我们想要的，我们想要它并行地触发所有阻塞调用。</p><h2 id="7d59" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">尝试#2</h2><p id="232c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以尝试快速修复它，如果我们调用通量链本身的<code class="fe lt lu lv lw b">parallel()</code>，这将通量转换为并行通量，然后可以提交给调度器，用<code class="fe lt lu lv lw b">runOn</code>而不是<code class="fe lt lu lv lw b">publishOn</code>，看看这个代码，</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fc37" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你可以看到它的工作原理，如果你看看时间戳，你会注意到，6个任务中的4个都是并行发生的，但其中2个多花了2秒(这是阻塞调用的时间)，所以即使我们在调度程序池中有更多的线程，<code class="fe lt lu lv lw b">parallel()</code>也只会为你创建少量(CPU内核数)并行流，然后并行运行它们。所以在我们的例子中是4。</p><h2 id="b7b0" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">尝试#3</h2><p id="dfc1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以通过向<code class="fe lt lu lv lw b">parallel()</code>调用传递一个并行因子来解决这个问题，这将创建我们想要的那么多并行流。看一看，它确实按照我们期望的方式运行，</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7b31" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你可能不想再说，啊哈，我得到了我想要的。但对我来说，这也不是提高真正好的解决方案的门槛，原因如下:</p><ul class=""><li id="315b" class="nq nr it kq b kr lm kv ln kz ns ld nt lh nu ll nv nw nx ny bi translated">首先，<code class="fe lt lu lv lw b">parallel()</code>和调度器线程现在必须相互理解，如果并行流比工作线程多，那就没用了，反之亦然。</li><li id="4bf9" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated">总的来说，ParallelFlux是一个开销，首先是不需要的。</li></ul><h2 id="93ca" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">尝试#4</h2><p id="1adc" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以，我喜欢尝试另一种方法，它根本不需要创建一个平行流。这就是我们为这些出版商提供的工厂方法的力量。因此，我们将使用<code class="fe lt lu lv lw b"><strong class="kq iu">Mono.fromCallable()</strong></code>将一个阻塞调用建模成一个非阻塞调用，并为它给出一个调度器。</p><p id="418d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后我们将在Flux Publisher中使用它来自然地获得并发性。看看下面的代码，</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0e8a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这很美，不是吗？它可以根据需要生成尽可能多的线程，摆脱并行和顺序事务的干扰，并更好地控制每个子任务的包装方式，有些可能使用许多线程，有些可能使用很少的线程。<strong class="kq iu">如此干净高效(如有需要，在此暂停片刻，以便完全掌握！)</strong></p><h1 id="3a39" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">错误处理</h1><p id="15d5" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在反应流和反应器中，错误是终端事件。一旦出现错误，它就停止序列，并沿着操作符链传播到最后一步，即您定义的<code class="fe lt lu lv lw b">Subscriber</code>及其<code class="fe lt lu lv lw b">onError</code>方法。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oi"><img src="../Images/76b38bec9934c4946e56f2dbc434ced0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tc8ua6x5lPCBrrmSKEn4sA.png"/></div></div></figure><p id="fb2f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Reactor还提供了处理链中间错误的替代方法，如错误处理操作符。以下示例显示了如何实现这一点:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5be2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">为了更实际地理解和使用它们，我们将查看和对比常规的命令性错误/异常处理，并尝试查看相同的反应模式，</p><h2 id="3886" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">1.用静态回退值处理错误</h2><p id="af91" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这种情况下，我们想尝试一些可能会爆炸的危险的东西，如果你得到一个错误，你返回一个静态值上游消费自己的错误。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="08d4" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">2.用回退方法调用处理</h2><p id="025f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以扩展前一种情况，不仅返回一个值，而且调用一个方法(可以是阻塞的)并返回响应，让我们看一个例子，</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="1daa" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">3.处理Catch和Rethrow时出错</h2><p id="363d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有时你不想消耗错误，但你想像一个经典的捕捉和投掷一样将它向上冒泡到上游。看看我们是如何做到这一点的，</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="43dc" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">4.日志或反应在一边</h2><p id="89ab" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可能还想记录一个失败的度量，在将错误提交给上游之前做一些记录，这在Reactor中也可以很容易地完成，例如</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="27bc" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">5.最终块</h2><p id="8508" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，如果我们需要清理数据库连接等。在链的末端，就像最后一样，我们可以在通量/单声道上利用<code class="fe lt lu lv lw b">doFinally()</code>。例如</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d66e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">由于这些例子是不言而喻的，所以您可以看到以一种富有表现力和反应性的方式执行错误处理和处理异常是多么容易。一般来说，异常处理本身就是一个主题，关于这一点还有很多可以说的，但这将在以后的文章中讨论:)</p><h1 id="7798" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">测试</h1><p id="84b1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对反应器序列进行单元测试最常见的情况是在代码中定义一个<code class="fe lt lu lv lw b"><strong class="kq iu">Flux</strong></code>或一个<code class="fe lt lu lv lw b"><strong class="kq iu">Mono</strong></code>(例如，它可能由一个方法返回)并想测试它在被订阅时的行为。</p><p id="c5de" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这种情况可以很好地解释为定义一个<strong class="kq iu">“测试场景”，</strong>在这里，您根据事件一步一步地定义您的期望。您可以询问和回答如下问题:</p><ul class=""><li id="b175" class="nq nr it kq b kr lm kv ln kz ns ld nt lh nu ll nv nw nx ny bi translated">下一个预期事件是什么？</li><li id="9bdd" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated">你期望<code class="fe lt lu lv lw b">Flux</code>发出一个特定的值吗？</li><li id="0ac0" class="nq nr it kq b kr nz kv oa kz ob ld oc lh od ll nv nw nx ny bi translated">或者在接下来的300毫秒里什么都不做？</li></ul><p id="38c8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这就是<code class="fe lt lu lv lw b"><strong class="kq iu">StepVerifier</strong></code>派上用场的地方。这是一个助手类，可以帮助你处理以上所有的场景，甚至更多。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4114" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您还可以使用<code class="fe lt lu lv lw b"><strong class="kq iu">StepVerifier</strong></code>轻松测试和断言测试用例中的错误。查看文档了解更多相关信息。</p><h2 id="922a" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">操纵时间</h2><p id="dea3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">像通量这样的异步流的核心性质之一是它随着时间而发生，所以时间对于通量来说是一个非常重要的维度。但是，对于测试来说，它成了一个瓶颈，</p><p id="1a7c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">假设您有一个发布时间为5分钟的发布者，您想要验证流中的内容，通常您的测试会运行与Flux需要产生和终止的时间相同的时间。但是，<code class="fe lt lu lv lw b"><strong class="kq iu">StepVerifier</strong></code>有一个特殊的方法<code class="fe lt lu lv lw b"><strong class="kq iu">.withVirtualTime()</strong></code>来操纵时间，让它滴答得更快。看一下下面的例子，</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="7267" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="e9b6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我敢肯定，这是一个漫长的旅程，我花了很多努力才把这些放在一起，就像你一路来到这里一样，所以，我们在这里学到了很多东西，祝贺你。在第1部分中，我们通过一些例子了解了为什么我们首先需要不同的执行模型和反应系统。在这一部分中，我们通过学习如何使用Reactor这样的框架以一种反应式的方式对任务建模的构建模块、概念和示例，将它带到了一个新的层次。我们学习了如何进行错误处理、代码分支，以及如何将阻塞系统无缝集成到非阻塞生态系统中。请找出在你的工作领域中可以利用的用例及场景。天空是无限的！</p><h1 id="60ff" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">奖金</h1><p id="f352" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在亚马逊，我们说，除非你可以用现实世界中的数据来证明一个说法，否则一切都是好的理论。因此，可选地，在第2部分之后会有关于<strong class="kq iu">使用反应式编程</strong>对真实世界进行扩展和性能测试的额外帖子。我们将构建一个web应用程序(虽然很简单),并了解可伸缩的反应式系统如何消耗更少的机器资源并服务更多的请求。我们还将看到这种方法的灵活性，也就是说，即使请求非常高或达到峰值，您的性能也几乎不会受到影响，直到达到您的处理能力。</p><p id="eb5e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你将看到我们在Docker 中使用<strong class="kq iu"> Spring Boot构建了<strong class="kq iu">两个应用程序(这样当运行性能测试时，我们可以限制硬件并查看性能)，一个在SpringMVC上使用Tomcat(servlet 3.0)和Spring Data for Mongo </strong>作为传统选择，另一个使用<strong class="kq iu"> WebFlux、WebClient和Netty(servlet 3.1)和Reactive Spring Data for Mongo。</strong>两者都连接到Mongo容器进行数据访问。<strong class="kq iu"> <em class="ls">我们将在最后使用SoapUI进行负载测试</em> </strong>并测量性能，<strong class="kq iu"> JConsole </strong>将同时用于监控JVM的健康状况。请继续关注，我将透露一些细节，以保持你对未来阅读的兴趣。尽情享受吧！</strong></p></div></div>    
</body>
</html>