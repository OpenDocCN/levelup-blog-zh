<html>
<head>
<title>20 Git Commands I Use Nearly Every Day (With Examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我几乎每天都在使用的20个Git命令(有例子)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/20-git-commands-i-use-nearly-every-day-with-examples-70e6d9c2f1b3?source=collection_archive---------0-----------------------#2021-08-23">https://levelup.gitconnected.com/20-git-commands-i-use-nearly-every-day-with-examples-70e6d9c2f1b3?source=collection_archive---------0-----------------------#2021-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">git提交，git推送，git支付</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/81de93d4c783c5e0764dc8d39dd00f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*115voMAgQLdjXIiY"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="https://images.unsplash.com/photo-1577375729152-4c8b5fcda381?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1100&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="f1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">版本控制不过是现代技术堆栈中的一个救命稻草。它跟踪个人或团队对软件项目所做的变更，以便您可以在必要时回滚变更，并记录项目如何发展的历史。我甚至无法想象在2005年创建Git之前，软件工程师们在几十年前必须面对的困难。</p><p id="4e1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，版本控制是软件应用程序的必需品，Git是最受欢迎的选择之一。虽然有各种基于GUI的Git版本，如<a class="ae ky" href="https://www.gitkraken.com/" rel="noopener ugc nofollow" target="_blank"> GitKraken </a>，但我将坚持使用终端基础，因为这是我个人的饭碗。</p><blockquote class="me"><p id="7d39" class="mf mg it bd mh mi mj mk ml mm mn lu dk translated">话虽如此，我的一位经理却持相反意见——他用了我最喜欢的一句口头禅:</p><p id="d727" class="mf mg it bd mh mi mj mk ml mm mn lu dk translated"><em class="mo">“没有GUI，就没有do-ee。”</em></p></blockquote><p id="2c1d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">以下是我几乎每天都会用到的20个git命令，以及它们的用例示例。我从最基础的开始，然后逐步提高。</p><p id="baa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这些命令中的每一个都有可以传递的额外参数，我将涵盖最常见的示例，并将进一步的学习留给读者。:)</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="0d89" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated"><strong class="ak"> 1。git配置</strong></h2><p id="27f4" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在您开始与git源代码控制交互之前，您必须配置git以了解您是谁。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="f379" class="nb nc it oa b gy oe of l og oh">$ git config --global user.name "Darth Vader"<br/>$ git config --global user.email dvader42@deathstar.com</span></pre><p id="7343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以使用查看您的所有设置及其来源:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="169c" class="nb nc it oa b gy oe of l og oh">$ git config --list --show-origin</span></pre><h2 id="2967" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">2.git初始化</h2><p id="1450" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">现在您的设置已经配置好了，我们可以初始化我们自己的Git存储库了。这将跟踪本地变化，但它还没有连接到GitHub内部的远程存储库。因此，如果这个目录被删除，您的git版本历史和所有文件都会消失。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="937d" class="nb nc it oa b gy oe of l og oh">$ cd path/to/new/project<br/>$ git init<br/>Initialized empty Git repository in path/to/new/project/.git/</span></pre><h2 id="a13d" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">3.git克隆</h2><p id="f226" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果我们不想初始化我们自己的本地存储库，而是想从GitHub克隆一个现有代码的远程存储库，我们可以使用git clone。有两种协议可供选择，超文本传输协议安全(HTTPS)或安全外壳(SSH)。</p><blockquote class="oi oj ok"><p id="d8ba" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">不需要太多的细节，HTTPS是一种快速简单的方法来克隆一个存储库。但是，您每次都需要手动输入密码。通过SSH克隆需要用GitHub设置您自己的私钥对，但是更安全，并且不需要输入您自己的密码。</p></blockquote><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="d648" class="nb nc it oa b gy oe of l og oh">$ git clone <a class="ae ky" href="https://github.com/tensorflow/tensorflow.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tensorflow/tensorflow.git</a><br/>$ git clone <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:tensorflow/tensorflow.git</span></pre><h2 id="f737" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">4.git状态</h2><p id="cfa7" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">无论您是初始化了一个本地git存储库还是仅仅克隆了一个远程repo，您都可以运行<code class="fe op oq or oa b">git status</code>来检查您的工作区的状态。此命令将让您知道是否有尚未保存的更改，或者您的本地版本是否比远程版本旧。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="6e30" class="nb nc it oa b gy oe of l og oh">$ git status<br/>On branch master<br/>Your branch is ahead of 'origin/master' by 1 commit.<br/>  (use "git push" to publish your <strong class="oa iu">local</strong> commits)<br/><br/>Untracked files:<br/>  (use "git add &lt;file&gt;..." to include <strong class="oa iu">in</strong> what will be committed)<br/><br/>	README.txt<br/><br/>nothing added to commit but untracked files present (use "git add" to track)</span></pre><h2 id="9c86" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">5.获取git</h2><p id="5668" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在每个工作日的开始，我总是跑<code class="fe op oq or oa b">git fetch</code>。这个命令将检索新的分支和对存储库的任何更新，但是它还不会改变您的本地工作区。实际更新本地代码的命令是下一节中的<code class="fe op oq or oa b">git pull</code>。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="e9f6" class="nb nc it oa b gy oe of l og oh">$ git fetch<br/>remote: Counting objects: 43, done.<br/>remote: Compressing objects: 100% (36/36), done.<br/>remote: Total 43 (delta 10), reused 31 (delta 5)<br/>Unpacking objects: 100% (43/43), done.<br/>From https://github.com/some/repository<br/> * [new branch]      master     -&gt; master<br/> * [new branch]      feature    -&gt; feature</span></pre><h2 id="e84c" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">6.git拉</h2><blockquote class="oi oj ok"><p id="9fc8" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">用<code class="fe op oq or oa b">git fetch</code>检查更新后，您可以在对代码做任何更改之前运行<code class="fe op oq or oa b">git pull</code>。特别是如果你要从一个主要的master或者develop分支中分支，重要的是你的新分支要使用最新的版本，以防止合并冲突或者意外的问题。</p></blockquote><p id="a976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe op oq or oa b">git pull</code>，您基本上是在运行<code class="fe op oq or oa b">git fetch</code>，然后将新的更改合并到您的本地工作区。您可以指定要提取的分支，也可以不给出其他参数来更新您所在的当前分支。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5101" class="nb nc it oa b gy oe of l og oh">$ git pull</span></pre><h2 id="7e0c" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">7.git添加</h2><p id="099b" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">对分支进行本地更改后，您需要为提交准备这些更改。您可以使用<code class="fe op oq or oa b">git add</code>通过包含文件名作为参数来单独暂存更新的文件，或者您可以包含标志<code class="fe op oq or oa b">-a</code>来将所有更改的文件添加到暂存中。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5d70" class="nb nc it oa b gy oe of l og oh">$ git add -a</span></pre><h2 id="501b" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">8.git提交</h2><p id="9c0a" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">既然您已经准备好了变更，那么您可以添加一条提交消息来描述变更的目的。一个有用的标记是使用<code class="fe op oq or oa b">git commit --amend</code>，它允许您在之前的提交中添加额外的文件或更改提交消息。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="b900" class="nb nc it oa b gy oe of l og oh">$ git commit -m "did X to fix Y"</span></pre><h2 id="eb4f" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">9.git推送</h2><p id="1123" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">一旦您用提交消息添加了您的更改，就该推送您的代码了！这将采用您的本地更改并更新远程存储库。如果这是您第一次推送到远程分支，通常建议您设置上游——这意味着您需要指定您想要将您的更改推送到的分支。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="10c1" class="nb nc it oa b gy oe of l og oh">$ git push --set-upstream origin new-branch # first time<br/>$ git push                                  # now can just push</span></pre><h2 id="9f99" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">10.git差异</h2><p id="cad5" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您想要查看两个分支之间或者您未分级的变更和当前分支之间的差异，您可以使用<code class="fe op oq or oa b">git diff</code>。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="c577" class="nb nc it oa b gy oe of l og oh">$ git diff &lt;commit_a&gt; &lt;commit_b&gt;      # diff between two commits<br/>$ git diff &lt;commit_a&gt; &lt;commit_b&gt; file # diff b/w file in 2 commits<br/>$ git diff HEAD # diff between working directory and last commit</span></pre><h2 id="4571" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">11.git rm</h2><p id="8566" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Git存储库将识别何时对它所跟踪的文件执行了常规shell <code class="fe op oq or oa b">rm</code>命令。它将更新工作目录以反映删除。它不会用删除来更新暂存索引。必须对删除的文件路径执行额外的<code class="fe op oq or oa b">git add</code>命令，以将更改添加到暂存索引中。</p><p id="f071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or oa b">git rm</code>命令作为一种快捷方式，它将使用删除更新工作目录和暂存索引。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="1392" class="nb nc it oa b gy oe of l og oh">$ git rm README.txt</span></pre><h2 id="2a1c" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">12.git分支</h2><p id="9dd9" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">分支是版本控制最重要的功能之一。通过使用分支，你可以委派职责，比如一个分支负责修复UI，另一个分支负责增加测试，或者添加新的特性等等。注意，当您运行<code class="fe op oq or oa b">git branch</code>时，它将从您当前的分支克隆。因此，如果您想从主分支开始新的分支，请确保在分支时您在主分支上。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="ed59" class="nb nc it oa b gy oe of l og oh">$ git branch &lt;new branch name&gt;</span></pre><h2 id="be79" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">13.git检验</h2><p id="a7aa" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在创建一个新的分支之后，您不会自动切换到它——您需要签出那个分支。您还可以签出特定的提交，以进入代码的旧状态。如果你想获得最新信息，只需运行<code class="fe op oq or oa b">git checkout HEAD</code>。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5cf9" class="nb nc it oa b gy oe of l og oh">$ git checkout &lt;new branch name&gt;<br/>$ git checkout &lt;commit name&gt;<br/>$ git checkout HEAD</span></pre><h2 id="80b9" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">14.git合并</h2><p id="d7be" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">合并两个分支将它们的集体变化合并在一起。您所在的分支将成为目标分支。将master合并到您的特性分支中可以更新团队所做的任何更改，而将您自己的新特性分支合并到master中会将您的分支的更改添加到主源分支中。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="662c" class="nb nc it oa b gy oe of l og oh">$ git merge master       # merge master into new-feature<br/>$ git checkout master    # checkout the master branch<br/>$ git merge new-feature  # merge new-feature changes into master</span></pre><h2 id="c699" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">15.git日志</h2><p id="384f" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您想要快速查看最近的提交，您可以使用添加了标志<code class="fe op oq or oa b">--oneline -N</code>的<code class="fe op oq or oa b">git log</code>，其中<code class="fe op oq or oa b">N</code>是您想要列出的提交数量。如果你想要更多的细节，你可以去掉<code class="fe op oq or oa b">--oneline</code>标志。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="d2b8" class="nb nc it oa b gy oe of l og oh">$ git log --oneline -10<br/>a920b394 (HEAD -&gt; database) query database for user creds<br/>27228a0d (origin/database) add database connections<br/>75a9a3be stubbing out code<br/>26d06eb2 (origin/develop, origin/HEAD, develop) Merge branch 'user-store' into 'database'</span></pre><p id="22b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以按提交的作者、时间等进行过滤。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="6f52" class="nb nc it oa b gy oe of l og oh">$ git log --author &lt;name&gt;<br/>$ git log --after 2.days.ago<br/>$ git log --before 3.days.ago</span></pre><h2 id="40df" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">16.git show</h2><p id="5497" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">为了更深入地了解存储库的变化，您可以使用<code class="fe op oq or oa b">git show</code>。您可以列出一次提交中更改的所有文件(第一个命令)，或者显示给定提交范围内的所有提交(第二个命令)。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="0f2e" class="nb nc it oa b gy oe of l og oh">$ git show --pretty="" --name-only ab83kf92<br/>$ git show commitA...commitE</span></pre><h2 id="37ee" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">17.git贮藏</h2><p id="a85c" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您已经对一个分支进行了更改，并且需要保存它们以便您可以在其他地方工作，您可以使用<code class="fe op oq or oa b">git stash</code>。如果您的更改还没有准备好提交，这是一种保存更改的便捷方式。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="1ed2" class="nb nc it oa b gy oe of l og oh">$ git status<br/>On branch main<br/>Changes to be committed:<br/><br/>    new file:   hashing.go<br/><br/>Changes not staged for commit:<br/><br/>    modified:   main.go<br/><br/>$ git stash<br/>Saved working directory and index state WIP on main: 305f82m new hashing algorithm<br/>HEAD is now at 305f82m new hashing algorithm<br/><br/>$ git status<br/>On branch main<br/>nothing to commit, working tree clean</span></pre><p id="2272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想让您的更改回到您的工作区，您可以使用<code class="fe op oq or oa b">git stash pop</code>或<code class="fe op oq or oa b">git stash apply</code>。弹出会清除保存在您的存储中的任何内容，而应用会保持存储可用，即使您已经将更改应用回您的工作中。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="54f5" class="nb nc it oa b gy oe of l og oh">$ git stash pop<br/>On branch main<br/>Changes to be committed:<br/><br/>    new file:   hashing.go<br/><br/>Changes not staged for commit:<br/><br/>    modified:   main.go<br/><br/>Dropped refs/stash@{0} (dk3b28fm990mlm453m5m10al0029bf3e380cc6a)<br/><br/>$ git stash apply<br/>On branch main<br/>Changes to be committed:<br/><br/>    new file:   hashing.o<br/><br/>Changes not staged for commit:<br/><br/>    modified:   main.go</span></pre><h2 id="b9fb" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">18.git重置</h2><p id="a902" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您做出了不想保留的更改，您可以使用<code class="fe op oq or oa b">git reset</code>将您的工作空间恢复到之前的提交。您可以传递标志<code class="fe op oq or oa b">soft</code>、<code class="fe op oq or oa b">mixed</code>或<code class="fe op oq or oa b">hard</code>，这取决于您希望复位的强制程度。</p><p id="7cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于软件，转移的快照和工作目录不会更改。Mixed将更新对转移快照的指定提交，但工作目录不受影响。硬重置将更新快照和工作目录，并且可能有潜在的危险，因为您将不再能够访问以前的任何更改。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="dee6" class="nb nc it oa b gy oe of l og oh">$ git reset HEAD-2 hashing.go # reset to 2nd-to-last commit</span></pre><h2 id="3841" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">19.git遥控器</h2><p id="444f" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated"><code class="fe op oq or oa b">git remote</code>命令允许您修改到其他git存储库的连接。您可以将远程连接视为书签，因为它们不是真正的直接链接，而是对其他URL的引用。</p><p id="0105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以列出git repo的远程配置，添加另一个repo作为连接，然后通过指定的名称引用该连接。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="9209" class="nb nc it oa b gy oe of l og oh">$ git remote -v<br/>$ git remote add &lt;name&gt; &lt;url&gt;<br/>$ git remote rm &lt;name&gt;<br/>$ git remote rename &lt;old-name&gt; &lt;new-name&gt;</span></pre><p id="2d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最喜欢的远程命令之一是当我有一堆本地分支不再在远程存储库中时使用的。以下命令将删除任何不再位于远程存储库中的本地分支。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="7bad" class="nb nc it oa b gy oe of l og oh">$ git remote prune origin</span></pre><h2 id="d167" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">20.干净利落</h2><p id="ba06" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">最后，我们有<code class="fe op oq or oa b">git clean</code>，它可以高度补充<code class="fe op oq or oa b">git reset</code>和<code class="fe op oq or oa b">git checkout</code>。您可以使用git clean来修改工作区中未被跟踪的变更(也就是在您使用<code class="fe op oq or oa b">git add</code>之前)。第一个命令将列出git clean时要删除的文件。然后，您可以使用<code class="fe op oq or oa b">git clean -f</code>来删除文件。请注意，除非clean.requireForce配置设置为false，否则必须使用-f标志。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="a813" class="nb nc it oa b gy oe of l og oh">$ git clean -n<br/>Would remove untracked_file<br/>$ git clean -f<br/>Removing untracked_file</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="766a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的名单到此为止！你认为这里应该有什么git命令吗？如果有，请在下面留下评论！感谢阅读。=)</p></div></div>    
</body>
</html>