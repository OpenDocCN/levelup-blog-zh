<html>
<head>
<title>JavaScript Array Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数组方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-array-methods-d7adeab5c294?source=collection_archive---------11-----------------------#2020-08-18">https://levelup.gitconnected.com/javascript-array-methods-d7adeab5c294?source=collection_archive---------11-----------------------#2020-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/11ac991fe9b6f8a5507feb9a2b50d2ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ubgFI7IF0rKiTlbo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9da0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我把常见的JavaScript数组方法和一些小的描述和例子放在一起，作为快速指南和简单的参考。</p><p id="0e23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在讨论数组方法之前，我们先声明一个数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cad1" class="lk ll iq lg b gy lm ln l lo lp">const items = [<br/>  {<br/>    id: 1,<br/>    name: 'Cereal',<br/>    price: 4<br/>  },<br/>  {<br/>    id: 2,<br/>    name: 'Action Figure',<br/>    price: 7<br/>  },<br/>  {<br/>    id: 3,<br/>    name: 'Video Game',<br/>    price: 50<br/>  },<br/>  {<br/>    id: 4,<br/>    name: 'DVD',<br/>    price: 20<br/>  },<br/>  {<br/>    id: 5,<br/>    name: 'Tablet',<br/>    price: 500<br/>  },<br/>  {<br/>    id: 6,<br/>    name: 'Laptop',<br/>    price: 1000<br/>  },<br/>  {<br/>    id: 7,<br/>    name: 'Vacuum Cleaner',<br/>    price: 200<br/>  },<br/>  {<br/>    id: 8,<br/>    name: 'Microwave',<br/>    price: 200<br/>  },<br/>  {<br/>    id: 9,<br/>    name: 'Sunglasses',<br/>    price: 25<br/>  },<br/>  {<br/>    id: 10,<br/>    name: 'TV',<br/>    price: 750<br/>  },<br/>];</span></pre><p id="acd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好，让我们来看看方法。</p><h2 id="1b29" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">地图方法</h2><p id="c4df" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">返回从提供的函数返回的值的数组。<code class="fe mm mn mo lg b">map</code>方法对数组中的每个元素执行一次函数。它不会改变原始数组</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="157a" class="lk ll iq lg b gy lm ln l lo lp">const itemNames = items.map(item =&gt; item.name);</span><span id="785e" class="lk ll iq lg b gy mp ln l lo lp">console.log(itemNames);</span><span id="4af9" class="lk ll iq lg b gy mp ln l lo lp">/*<br/>[<br/>  'Cereal',<br/>  'Action Figure',<br/>  'Video Game',<br/>  'DVD',<br/>  'Tablet',<br/>  'Laptop',<br/>  'Vacuum Cleaner',<br/>  'Microwave',<br/>  'Sunglasses',<br/>  'TV'<br/>]<br/>*/</span></pre><h2 id="2fdd" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">过滤方法</h2><p id="1a26" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">返回一个值数组，该数组传递来自所提供函数的条件语句。<code class="fe mm mn mo lg b">filter</code>方法对数组中的每个元素执行一次函数。它不会改变原始数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c6e0" class="lk ll iq lg b gy lm ln l lo lp">const affordableItems = items.filter(item =&gt; item.price &lt; 100);</span><span id="7cc9" class="lk ll iq lg b gy mp ln l lo lp">console.log(affordableItems);</span><span id="bddd" class="lk ll iq lg b gy mp ln l lo lp">/*<br/>[<br/>  { id: 1, name: 'Cereal', price: 4 },<br/>  { id: 2, name: 'Action Figure', price: 7 },<br/>  { id: 3, name: 'Video Game', price: 50 },<br/>  { id: 4, name: 'DVD', price: 20 },<br/>  { id: 9, name: 'Sunglasses', price: 25 }<br/>]<br/>*/</span></pre><h2 id="3935" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">查找方法</h2><p id="fc75" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">返回从提供的函数传递条件语句的数组中第一项的值。一旦函数返回true，<code class="fe mm mn mo lg b">find</code>方法返回<code class="fe mm mn mo lg b">true</code>，并且不检查剩余的元素。它不会改变数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f573" class="lk ll iq lg b gy lm ln l lo lp">const foundItem = items.find(item =&gt; item.id === 3);</span><span id="39a1" class="lk ll iq lg b gy mp ln l lo lp">console.log(foundItem);</span><span id="b42e" class="lk ll iq lg b gy mp ln l lo lp">// { id: 3, name: 'Video Game', price: 50 }</span></pre><h2 id="adb3" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">一些方法</h2><p id="82cc" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">通过检查数组中的任何元素是否传递了所提供函数的条件语句，返回一个布尔值。一旦函数返回<code class="fe mm mn mo lg b">true</code>，方法<code class="fe mm mn mo lg b">some</code>返回<code class="fe mm mn mo lg b">true</code>并且不检查剩余的元素。它不会改变数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="beda" class="lk ll iq lg b gy lm ln l lo lp">const hasExpensiveItems = items.some(item =&gt; item.price &gt;= 500);</span><span id="9b1c" class="lk ll iq lg b gy mp ln l lo lp">console.log(hasExpensiveItems);</span><span id="1c30" class="lk ll iq lg b gy mp ln l lo lp">// true</span></pre><h2 id="d131" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">每一种方法</h2><p id="ee3e" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">通过检查数组中的所有元素是否都通过了所提供函数的条件语句，返回一个布尔值。一旦函数返回<code class="fe mm mn mo lg b">false</code>，<code class="fe mm mn mo lg b">every</code>方法返回<code class="fe mm mn mo lg b">false</code>并且不检查剩余的元素。它不会改变数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0310" class="lk ll iq lg b gy lm ln l lo lp">const allItemsExpensive = items.every(item =&gt; item.price &gt;= 500);</span><span id="ff92" class="lk ll iq lg b gy mp ln l lo lp">console.log(allItemsExpensive);</span><span id="1e38" class="lk ll iq lg b gy mp ln l lo lp">// false</span></pre><h2 id="1478" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">forEach方法</h2><p id="3f07" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">对数组中的每个元素执行一个函数。它不会改变数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2c02" class="lk ll iq lg b gy lm ln l lo lp">items.forEach(item =&gt; console.log(item.name));</span><span id="8503" class="lk ll iq lg b gy mp ln l lo lp">/*<br/>Cereal<br/>Action Figure<br/>Video Game<br/>DVD<br/>Tablet<br/>Laptop<br/>Vacuum Cleaner<br/>Microwave<br/>Sunglasses<br/>TV<br/>*/</span></pre><h2 id="4e39" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">还原方法</h2><p id="b66b" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">将数组缩减为单个值。为数组中的每个元素执行一个提供的函数，它是<code class="fe mm mn mo lg b">reduce</code>方法中的第一个参数。第二个参数是函数中使用的累加器变量的初始值。所提供的函数还需要两个参数—累加器变量和当前元素。随着每次迭代，累加器变成返回值，当循环完成时，累加器作为单个值返回。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="06a1" class="lk ll iq lg b gy lm ln l lo lp">const total = items.reduce((accumulatedTotal, item) =&gt; item.price + accumulatedTotal, 0);</span><span id="b349" class="lk ll iq lg b gy mp ln l lo lp">console.log(total);</span><span id="6f0e" class="lk ll iq lg b gy mp ln l lo lp">// 2756</span></pre><p id="f6a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，<code class="fe mm mn mo lg b">reduce</code>函数遍历<code class="fe mm mn mo lg b">items</code>数组，对每个元素执行所提供的函数。由于在<code class="fe mm mn mo lg b">reduce method</code>中传递了第二个参数，<code class="fe mm mn mo lg b">accumulatedTotal</code>的初始值为<code class="fe mm mn mo lg b">0</code>。在每次迭代中，当前商品的价格被添加到<code class="fe mm mn mo lg b">accumulatedTotal</code>中，然后返回<code class="fe mm mn mo lg b">accumulatedTotal</code>。一旦循环完成，函数<code class="fe mm mn mo lg b">reduce</code>将返回<code class="fe mm mn mo lg b">accumulatedTotal</code>。</p><h2 id="eab7" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">包括方法</h2><p id="6e27" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">通过检查数组是否包含其参数来返回布尔值。它不会改变数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8e8c" class="lk ll iq lg b gy lm ln l lo lp">const pets = ['dog', 'cat', 'rabbit', 'hamster', 'parrot', 'fish'];</span><span id="d96f" class="lk ll iq lg b gy mp ln l lo lp">const isFishIncluded = pets.includes('fish');</span><span id="bc73" class="lk ll iq lg b gy mp ln l lo lp">console.log(isFishIncluded);</span><span id="afbd" class="lk ll iq lg b gy mp ln l lo lp">// true</span></pre><h2 id="b03f" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">排序方法</h2><p id="5c96" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">对数组中的项目进行排序。默认情况下，<code class="fe mm mn mo lg b">sort</code>方法按照字母和升序将值排序为字符串。它改变了原来的数组。</p><p id="91b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将在前面的<code class="fe mm mn mo lg b">pets</code>数组中添加“doggy”来展示<code class="fe mm mn mo lg b">sort</code>如何按照字符串的升序对<code class="fe mm mn mo lg b">'dog'</code>和<code class="fe mm mn mo lg b">'doggy'</code>进行排序。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c2fb" class="lk ll iq lg b gy lm ln l lo lp">const pets2 = ['doggy', 'dog', 'cat', 'rabbit', 'hamster', 'parrot', 'fish'];</span><span id="d9e6" class="lk ll iq lg b gy mp ln l lo lp">pets2.sort();</span><span id="1987" class="lk ll iq lg b gy mp ln l lo lp">console.log(pets2);</span><span id="01ce" class="lk ll iq lg b gy mp ln l lo lp">// ['cat', 'dog', 'doggy', 'fish', 'hamster', 'parrot', 'rabbit']</span></pre><p id="6e45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe mm mn mo lg b">'dog'</code>排在<code class="fe mm mn mo lg b">'doggy'</code>之前。两个字符串都以相同的三个字母开头，但是由于<code class="fe mm mn mo lg b">'dog'</code>的长度较短，所以它首先按升序排序。</p><p id="d05e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于字符串很有效，然而，<code class="fe mm mn mo lg b">sort</code>方法的默认行为是将数字作为字符串排序，而不是按数字排序。例如，“20”比“100”大，因为<code class="fe mm mn mo lg b">sort</code>方法将“2”与“1”进行比较。为了解决这个问题，<code class="fe mm mn mo lg b">sort</code>方法接受一个函数来比较元素。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0069" class="lk ll iq lg b gy lm ln l lo lp">const numbers = [20, 100, 55, 8, 13];</span><span id="bb05" class="lk ll iq lg b gy mp ln l lo lp">// sort in ascending order<br/>numbers.sort((a, b) =&gt; a - b);</span><span id="c048" class="lk ll iq lg b gy mp ln l lo lp">console.log(numbers);</span><span id="7d58" class="lk ll iq lg b gy mp ln l lo lp">// [ 8, 13, 20, 55, 100 ]</span><span id="09ea" class="lk ll iq lg b gy mp ln l lo lp">// sort in descending order<br/>numbers.sort((a, b) =&gt; b - a);</span><span id="00f4" class="lk ll iq lg b gy mp ln l lo lp">console.log(numbers);</span><span id="3fb3" class="lk ll iq lg b gy mp ln l lo lp">// [ 100, 55, 20, 13, 8 ]</span></pre><h2 id="d13a" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">连接方法</h2><p id="ddb0" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">以字符串形式返回数组。它接受一个用作分隔符的可选参数。如果没有给定，则使用默认分隔符<code class="fe mm mn mo lg b">,</code>——逗号后面没有空格。如果不需要分隔符，可以传入一个空字符串。它不会改变数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6cba" class="lk ll iq lg b gy lm ln l lo lp">const drinks = ['Juice', 'Milk', 'Water', 'Coffee', 'Tea'];</span><span id="f9b0" class="lk ll iq lg b gy mp ln l lo lp">console.log(drinks.join());</span><span id="ead1" class="lk ll iq lg b gy mp ln l lo lp">// Juice,Milk,Water,Coffee,Tea</span><span id="97f5" class="lk ll iq lg b gy mp ln l lo lp">console.log(drinks.join(' and '));</span><span id="3a46" class="lk ll iq lg b gy mp ln l lo lp">// Juice and Milk and Water and Coffee and Tea</span><span id="fa0b" class="lk ll iq lg b gy mp ln l lo lp">console.log(drinks.join(''));</span><span id="fcb0" class="lk ll iq lg b gy mp ln l lo lp">// JuiceMilkWaterCoffeeTea</span></pre><h2 id="7dea" class="lk ll iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">反向方法</h2><p id="321f" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">反转数组中元素的顺序。它改变了原来的数组。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="bbf9" class="lk ll iq lg b gy lm ln l lo lp">const drinks = ['Juice', 'Milk', 'Water', 'Coffee', 'Tea'];</span><span id="e2e9" class="lk ll iq lg b gy mp ln l lo lp">console.log(drinks.reverse());</span><span id="5441" class="lk ll iq lg b gy mp ln l lo lp">// [ 'Tea', 'Coffee', 'Water', 'Milk', 'Juice' ]</span></pre></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="a38d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！希望你学到了新的东西，或者对你已经知道的东西有了更深的理解。如果需要，请随意参考。感谢阅读！做好人。</p></div></div>    
</body>
</html>