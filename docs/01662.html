<html>
<head>
<title>New Features in ES2020 — Modules, Promises, and Stable Array Sorting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2020的新特性—模块、承诺和稳定的数组排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/new-features-of-es2020-modules-promises-and-stable-array-sorting-c3581ac740f7?source=collection_archive---------11-----------------------#2020-01-20">https://levelup.gitconnected.com/new-features-of-es2020-modules-promises-and-stable-array-sorting-c3581ac740f7?source=collection_archive---------11-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e6198e17752ed2c5c9711bb0de62cfb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YVlcXeKBIjw_yLuP"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@turkkanirem?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">i̇rem·图尔克坎</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a00f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自2015年以来，JavaScript发展迅速，每次迭代都有许多新功能出现。JavaScript语言规范的新版本每年都在更新，新语言特性提案的完成速度比以往任何时候都快。</p><p id="894b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着新特性正以前所未有的速度融入现代浏览器和Node.js等其他JavaScript运行时引擎。2019年，有许多新功能处于“阶段3”阶段，这意味着它非常接近完成，浏览器现在开始支持这些功能。</p><p id="210f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想将它们用于生产代码，我们可以使用Babel之类的东西将它们转换成旧版本的JavaScript，以便在需要时可以在旧版本的浏览器中使用，如Internet Explorer。在本文中，我们将研究动态模块加载、稳定的排序结果和<code class="fe le lf lg lh b">Promise.allSettled</code>方法。</p><h1 id="daa2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">动态模块加载</h1><p id="b36b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript模块可以动态加载。这让我们只在需要的时候加载模块，而不是在应用运行的时候加载所有的模块。</p><p id="56b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们使用了返回承诺的<code class="fe le lf lg lh b">import()</code>函数。当参数中的模块被加载时，承诺就实现了。</p><p id="6d95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">promise解析为一个模块对象，然后可以被应用程序的代码使用。如果我们在<code class="fe le lf lg lh b">Person.js</code>中有了<code class="fe le lf lg lh b">Person</code>类，那么我们可以用下面的代码动态导入它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="92d9" class="mt lj it lh b gy mu mv l mw mx">import('./Person')<br/>.then((module)=&gt;{<br/>  const Person = module.Person;<br/>  const person = new Person('Jane', 'Smith');<br/>  person.sayHi();<br/>})</span></pre><p id="813e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者使用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>语法，我们可以把它放在一个函数中:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8600" class="mt lj it lh b gy mu mv l mw mx">const importPerson = async ()=&gt;{ <br/>  const module = await import('./Person');<br/>  const Person = module.Person;<br/>  const person = new Person('Jane', 'Smith');<br/>  person.sayHi();<br/>}<br/>importPerson();</span></pre><p id="700b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们可以在代码中动态地导入一个模块，而不是像现在这样通常的静态导入。有了动态导入，我们可以随心所欲地导入它，而不是像我们通常做的那样，在一切运行之前在模块文件的顶部导入模块。</p><p id="de4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为导入代码是静态的，所以我们可以用它来有条件地、迭代地或以任何其他我们想用代码做的方式导入。这是因为动态<code class="fe le lf lg lh b">import</code>函数返回一个承诺，我们可以用承诺允许的任何方式使用它们。</p><p id="7ab9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用动态导入，我们还可以从常规脚本中导入模块，而不仅仅是在其他模块中，因此我们可以在脚本标记中编写如下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d12e" class="mt lj it lh b gy mu mv l mw mx">&lt;script type="module"&gt;<br/>  const importPerson = async ()=&gt;{ <br/>    const module = await import('./Person');<br/>    const Person = module.Person;<br/>    const person = new Person('Jane', 'Smith');<br/>    person.sayHi();<br/>  }<br/>  importPerson();<br/>&lt;/script&gt;</span></pre><p id="d929" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面代码中的一切都是动态运行的，包括<code class="fe le lf lg lh b">import</code>函数。这在<code class="fe le lf lg lh b">import</code>语句中是不可能的。由于模块名是以字符串的形式传入的，所以我们也可以传入任何字符串，而不仅仅是静态字符串，就像下面的代码一样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b5d1" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; { <br/>  const moduleNames = ['Person', 'Animal'];<br/>  for await (const moduleName of moduleNames){<br/>    const module = await import(`./${moduleName}`);<br/>    const Thing = module[moduleName];<br/>    const thing = new Thing('Jane', 'Smith');<br/>    thing.sayHi();<br/>  }<br/>})();</span></pre><p id="f02f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们异步遍历模块路径并动态导入它们，然后我们得到我们想要的类，然后用构造函数创建它的一个新实例。在每个迭代器的末尾，我们调用了在每个模块中导出的每个模块的类中可用的<code class="fe le lf lg lh b">sayHi</code>方法。</p><h1 id="f8d9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">稳定排序</h1><p id="f332" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在此之前，JavaScript <code class="fe le lf lg lh b">sort</code>方法在不同的浏览器中实现是不同的。</p><p id="5402" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着<code class="fe le lf lg lh b">sort</code>算法可能会给出不同的排序结果，而这些结果本应是相同的。不同的浏览器对同一个<code class="fe le lf lg lh b">sort</code>方法返回不同的结果，并且传入了同一个用于比较的回调函数。</p><p id="44c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就导致了一个我们没有预料到的结果。例如，如果我们有以下代码，先按名称，然后按<code class="fe le lf lg lh b">age</code>对<code class="fe le lf lg lh b">people</code>数组进行排序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c5a5" class="mt lj it lh b gy mu mv l mw mx">const people = [{<br/>    name: 'Joe',<br/>    age: 19<br/>  },<br/>  {<br/>    name: 'Jane',<br/>    age: 19<br/>  },<br/>  {<br/>    name: 'John',<br/>    age: 18<br/>  },<br/>  {<br/>    name: 'Mary',<br/>    age: 22<br/>  },<br/>  {<br/>    name: 'Sam',<br/>    age: 18<br/>  },<br/>];</span><span id="5255" class="mt lj it lh b gy my mv l mw mx">people.sort((p1, p2) =&gt; {<br/>  if (p1.name &lt; p2.name) return -1;<br/>  if (p1.name &gt; p2.name) return 1;<br/>  return 0;<br/>});<br/>console.log(people.map(p =&gt; p.name));</span><span id="08d0" class="mt lj it lh b gy my mv l mw mx">people.sort((p1, p2) =&gt; {<br/>  return p1.age - p2.age<br/>});<br/>console.log(people.map(p =&gt; p.name));</span></pre><p id="2d9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在各种旧浏览器中，我们可能会得到不同的结果。然而，现在我们有不同的浏览器制造商同意他们的<code class="fe le lf lg lh b">sort</code>方法的稳定算法，所有的浏览器应该返回相同的排序结果，不管我们放入什么。</p><p id="effa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们为browser排序的数组的大小应该决定是否使用稳定的排序算法。</p><p id="b7e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有浏览器应该给出相同的结果，因为不管数组的大小如何，都使用稳定的排序算法，除非在早期的浏览器中，所使用的排序算法可能基于被排序的数组的大小，这增加了排序结果的不确定性。</p><p id="7a88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe le lf lg lh b">console.log</code>语句中，我们应该得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8006" class="mt lj it lh b gy mu mv l mw mx">[ "Jane", "Joe", "John", "Mary", "Sam" ]</span></pre><p id="a6b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第一个<code class="fe le lf lg lh b">console.log</code>，还有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="36cf" class="mt lj it lh b gy mu mv l mw mx">[ "John", "Sam", "Jane", "Joe", "Mary" ]</span></pre><p id="33ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于流行浏览器最新版本中的第二个<code class="fe le lf lg lh b">console.log</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/65a9d0b32410fbc851a94f2d3b687585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J6SgaSWpdmBSNcdK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sharonmccutcheon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="bf8a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">Promise.allSettled</code></h1><p id="9834" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">Promise.allSettled</code>返回一个承诺，该承诺在所有给定的承诺被解决或拒绝后解决。它接受一个带有承诺集合的iterable对象，例如，一个承诺数组。返回承诺的解析值是每个承诺最终状态的数组。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c907" class="mt lj it lh b gy mu mv l mw mx">const promise1 = Promise.resolve(1);<br/>const promise2 = Promise.reject(2);<br/>const promise3 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; reject(3), 1000);<br/>});<br/>Promise.allSettled([promise1, promise2, promise3])<br/>  .then((values) =&gt; {<br/>    console.log(values);<br/>  })</span></pre><p id="3d78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们运行上面的代码，那么我们会得到一个包含3个条目的数组，每个条目都是一个对象，具有已履行承诺的<code class="fe le lf lg lh b">status</code>和<code class="fe le lf lg lh b">value</code>属性，以及一个对象，具有被拒绝承诺的<code class="fe le lf lg lh b">status</code>和<code class="fe le lf lg lh b">reason</code>属性。</p><p id="c96d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如上面的代码会记录<code class="fe le lf lg lh b">{status: “fulfilled”, value: 1}</code>、<code class="fe le lf lg lh b">{status: “rejected”, reason: 2}</code>、<code class="fe le lf lg lh b">{status: “rejected”, reason: 3}</code>。记录成功承诺的<code class="fe le lf lg lh b">fulfilled</code>状态，记录拒绝承诺的<code class="fe le lf lg lh b">rejected</code>状态。</p><h1 id="fe50" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="9365" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript模块可以动态加载。这让我们只在需要的时候加载模块，而不是在应用运行的时候加载所有的模块。为此，我们使用了返回承诺的<code class="fe le lf lg lh b">import()</code>函数。</p><p id="de2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这让我们可以编写代码来有条件地导入、迭代导入以及JavaScript中异步代码允许的任何其他操作。在此之前，JavaScript <code class="fe le lf lg lh b">sort</code>方法在不同的浏览器中有不同的实现。</p><p id="d3ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着<code class="fe le lf lg lh b">sort</code>算法可能会给出不同的排序结果，而这些结果本应是相同的。</p><p id="10b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不同的浏览器对相同的<code class="fe le lf lg lh b">sort</code>方法返回不同的结果，相同的回调函数用于传入比较。这导致了我们没有预料到的结果。现在我们再也不用担心这个了。</p><p id="8204" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Promise.allSettled</code>返回一个承诺，该承诺在所有给定的承诺被解决或拒绝后解决。</p><p id="488a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它接受一个带有承诺集合的iterable对象，例如，一个承诺数组。返回承诺的解析值是每个承诺最终状态的数组。</p><p id="9444" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以等待承诺的解决，然后做我们想做的任何事情。</p></div></div>    
</body>
</html>