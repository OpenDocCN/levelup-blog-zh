<html>
<head>
<title>Learn Programming with Python — Introduction to Compound Data Types: Sets and Tuples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Python编程——复合数据类型简介:集合和元组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-programming-with-python-introduction-to-compound-data-types-sets-and-tuples-ac7466881bd5?source=collection_archive---------12-----------------------#2020-05-03">https://levelup.gitconnected.com/learn-programming-with-python-introduction-to-compound-data-types-sets-and-tuples-ac7466881bd5?source=collection_archive---------12-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fc835309ce4009c2107b52c2f4126d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9A8e1yWGIVMiaFjCAsCWA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片鸣谢@ kokilsh<a class="ae jg" href="https://www.pexels.com/@kokilsh" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/@kokilsh</a></figcaption></figure><div class=""/><p id="1a82" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们仔细看看Python中的复合数据类型。集合和元组允许我们构建和使用更丰富、更有表现力的程序。</p><h2 id="3c9f" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">Python中的集合数据类型</h2><p id="fdfd" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在之前的<a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-controlling-execution-flow-3755d8421d8" rel="noopener">系列文章</a>中，我向您介绍了<code class="fe mc md me mf b">set</code>复合数据类型。集合是共享某些共同事物的对象的无序集合。</p><p id="15b3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个<code class="fe mc md me mf b">set</code>，我们可以通过将它传递给一个<code class="fe mc md me mf b">for</code>循环语句来迭代它:</p><figure class="mg mh mi mj gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="015a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">set</code>数据类型有一些惊人的能力！这些都是直接从数学的<a class="ae jg" href="https://en.wikipedia.org/wiki/Set_theory" rel="noopener ugc nofollow" target="_blank"> <em class="mm">集合论</em>分支中推导出来的。从你已经知道的维恩图中，你会对这个非常熟悉。</a></p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/7ab6ab5488efa7778bbd3e111d2ec29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*Ubib7nklJKB5ZHSaxgYGYw.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">两个相交集合的维恩图。</figcaption></figure><p id="c38a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一些集合，看看它们在Python中是如何工作的。</p><figure class="mg mh mi mj gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="57bb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的代码编辑器中，我看到以下内容:</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mo"><img src="../Images/5e0cb4e15e2838cfb97eeeb5c18b2b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZ05uRd6x9B01KQ89bx1yw.png"/></div></div></figure><p id="0c86" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是怎么回事？</p><ul class=""><li id="3a8e" class="mp mq jj ki b kj kk kn ko kr mr kv ms kz mt ld mu mv mw mx bi translated">在第1、2和3行，我分别定义了一个包含相关元素的<code class="fe mc md me mf b">set</code>(使用一个<code class="fe mc md me mf b">:set</code>类型提示)。(你是植物学家就别拍我，我在尽力！).</li><li id="f651" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第6行，我打印出了<code class="fe mc md me mf b">treefruit</code>和<code class="fe mc md me mf b">cirtusfruit</code>的<code class="fe mc md me mf b">intersection</code>。这将返回两个集合中出现的所有元素。</li><li id="efaf" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第12行和第13行，我也打印交叉点。</li><li id="1ac7" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第15行，我创建了<code class="fe mc md me mf b">union</code>——两个集合的所有元素组合成一个新集合。</li><li id="b96f" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第18行，我找到了<code class="fe mc md me mf b">difference</code>——哪个<code class="fe mc md me mf b">stonefruit</code>和<code class="fe mc md me mf b">treefruit</code>不是<code class="fe mc md me mf b">citrusfruit</code>。</li></ul><p id="eb28" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用方法<code class="fe mc md me mf b">pop()</code>、<code class="fe mc md me mf b">remove()</code>和<code class="fe mc md me mf b">discard()</code>就地修改集合。<code class="fe mc md me mf b">pop()</code>返回集合中的一个随机元素，<code class="fe mc md me mf b">remove()</code>将从集合中移除给定元素，但如果它不存在则失败并出错，而<code class="fe mc md me mf b">discard()</code>将静默移除给定元素，但如果它不存在则不会失败并出错。请看下面的截图，我在第9行使用第4行已经弹出的水果在场景中使用<code class="fe mc md me mf b">remove() </code>产生了一个运行时错误。</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nd"><img src="../Images/221d5dfbd27f11902ad0f8eb5dffeedc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8MgSagti8DEhkT23pxZrA.png"/></div></div></figure><p id="32e2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为Python <code class="fe mc md me mf b">set</code>是基于<em class="mm">集合论</em>的，当程序员希望测试一个元素在多个集合中的成员资格时，或者简单地作为一种从集合中删除重复的简单方法时，他们经常使用集合。</p><p id="1d42" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python还为我们提供了<code class="fe mc md me mf b">frozenset</code>复合数据类型。例如，Frozensets不能使用<code class="fe mc md me mf b">discard()</code>修改它们的元素。</p><h2 id="a4c4" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">set()构造函数</h2><p id="bec6" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">到目前为止，我们只使用了花括号来创建一个新的集合:</p><pre class="mg mh mi mj gt ne mf nf ng aw nh bi"><span id="d08e" class="le lf jj mf b gy ni nj l nk nl">citrusfruit:set = {"oranges", "lemons", "limes", "satsumas", "nectarines"}</span></pre><p id="2ab5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，内置函数<code class="fe mc md me mf b">set() </code>可以根据给定的参数创建一个新的集合。这被称为<em class="mm">构造器</em>，因为它用于构造和返回新对象。例如，我们可以使用<code class="fe mc md me mf b">set()</code>创建一个基于字符串的新集合(记住:字符串是一个字符序列):</p><pre class="mg mh mi mj gt ne mf nf ng aw nh bi"><span id="96fc" class="le lf jj mf b gy ni nj l nk nl">characters:set = set("The quick brown fox jumped over the lazy dog.")</span><span id="6aad" class="le lf jj mf b gy nm nj l nk nl">print(len(characters))</span></pre><p id="e227" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">句子中有多少个独特的字符？一个代表英语字母表中的每个字母、一个空格和一个句点:28。</p><h2 id="59d9" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">Python中的元组数据类型</h2><p id="7f27" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><code class="fe mc md me mf b">tuple</code>复合数据类型包含一个或多个逗号分隔的元素，这些元素被认为构成了一个<em class="mm">记录</em>。当单个值不足以识别某些东西时，程序员经常使用元组。像房子的地址！在计算机科学中，我们可能会正式地这样说:<em class="mm">任何房子对象的身份都是由它的属性(街道名、门牌号、城市、邮政编码和国家)组成的</em>。房子身份的这5个属性可以很容易地用在一个包含5个元素的元组中——一个地址。</p><p id="b799" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前一篇文章中，我们考虑使用一个包含两个元素的元组来表示地球表面上一个点的地理位置，使用它的纬度和经度。</p><pre class="mg mh mi mj gt ne mf nf ng aw nh bi"><span id="9b2a" class="le lf jj mf b gy ni nj l nk nl">geolocation = (48.858093, 2.294694) #The Eiffel Tower</span></pre><p id="43a4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们创建<code class="fe mc md me mf b">set</code>数据类型时，我们用花括号<code class="fe mc md me mf b">{}</code>将它的值括起来。当我们创建一个<code class="fe mc md me mf b">tuple</code>时，我们使用标准括号<code class="fe mc md me mf b">()</code>将值括起来。</p><p id="15ed" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们创建了一个<code class="fe mc md me mf b">tuple</code>之后，我们可以使用它们的<em class="mm">索引</em>来访问它的元素。索引总是从0开始，并且总是用作用于变量(如<code class="fe mc md me mf b">geolocation[0]</code>)的方括号来表示。</p><pre class="mg mh mi mj gt ne mf nf ng aw nh bi"><span id="9f61" class="le lf jj mf b gy ni nj l nk nl">&gt;&gt;&gt; geolocation = (48.858093, 2.294694) #The Eiffel Tower<br/>&gt;&gt;&gt; print(f"Latitude: {geolocation[0]} Longitude: {geolocation[1]}")<br/>Latitude: 48.858093 Longitude: 2.294694</span></pre><p id="a3bf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于<code class="fe mc md me mf b">tuple</code>的一个有趣的事情是，一旦它被创建，就不能被修改。这种特殊的性质叫做<em class="mm">可变性</em>，每一个<code class="fe mc md me mf b">tuple</code>都是<em class="mm">不可变的</em>。试图改变<code class="fe mc md me mf b">tuple</code>索引0处的值将导致<code class="fe mc md me mf b">TypeError</code>:</p><pre class="mg mh mi mj gt ne mf nf ng aw nh bi"><span id="d853" class="le lf jj mf b gy ni nj l nk nl">&gt;&gt;&gt; geolocation[0] = 50.0000<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'tuple' object does not support item assignment</span></pre><p id="7ce6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python有一个秘密，藏在<code class="fe mc md me mf b">collections</code>模块里！记住元组中哪个索引包含哪个值可以是真正的PITA。索引元素0是纬度，还是经度？让我们使用一个名为tuple 的<em class="mm">来解决这个问题！要使用<code class="fe mc md me mf b">namedtuple</code>数据类型，我们首先需要从<code class="fe mc md me mf b">collections</code>模块导入包含的功能。</em></p><figure class="mg mh mi mj gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="9a22" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我的代码编辑器中的样子:</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/ad2dfb3f963ffe70f6620f3c10b5902e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRE072B30r3P3tkxeHRdxA.png"/></div></div></figure><p id="3073" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将一个元组转换成一个集合(丢失任何重复)或者将一个集合转换成一个元组非常简单:</p><figure class="mg mh mi mj gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="5317" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的代码编辑器中执行此操作后，我得到:</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/43e2e21b084e66eb5b6d5b76c40c9cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNSuR57D7qgAOnkQf4s09A.png"/></div></div></figure><p id="4cbf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是怎么回事？</p><ul class=""><li id="84f5" class="mp mq jj ki b kj kk kn ko kr mr kv ms kz mt ld mu mv mw mx bi translated">在第1行，我们定义了一个名为geolocation的变量，并暗示我们希望它是一个元组<code class="fe mc md me mf b">geolocation:tuple</code>。我们使用普通的括号来创建元组元素的逗号分隔列表。请注意，两个元素具有相同的值。</li><li id="cd2d" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第2行，我们定义了一个名为students的变量，并暗示我们希望它是一个集合。我们使用花括号来创建集合元素的逗号分隔列表。</li><li id="ead6" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第4行，我们使用了带有<code class="fe mc md me mf b">geolocation</code>元组的<code class="fe mc md me mf b">set()</code>函数作为它的参数。我们打印新的<code class="fe mc md me mf b">set</code>——它只有一个唯一的值。注意，输出使用花括号表示这是一个<code class="fe mc md me mf b">set</code>。</li><li id="6093" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第5行，我们使用了<code class="fe mc md me mf b">tuple()</code>函数，学生<code class="fe mc md me mf b">set</code>作为它的参数。我们打印新的<code class="fe mc md me mf b">tuple</code>，它包含了<code class="fe mc md me mf b">set</code>的所有元素。注意，输出使用普通括号表示这是一个<code class="fe mc md me mf b">tuple</code>。</li></ul><p id="9691" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于类型提示的一个注记。在其他编程语言中，暗示我们正在创建的变量的预期数据类型是不正常的。它要么是一个硬性要求(例如Java)，要么被视为毫无意义(例如Javascript)。尽管在第1行我们暗示了geolocation变量是一个元组，Python并不阻止我们在第4行给它赋值一个集合。类型提示是在<a class="ae jg" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank"> Python 3.5中引入的，文档</a>给了我们非常有用的文本:</p><pre class="mg mh mi mj gt ne mf nf ng aw nh bi"><span id="4bc8" class="le lf jj mf b gy ni nj l nk nl">Note</span><span id="75b1" class="le lf jj mf b gy nm nj l nk nl">The Python runtime does not enforce function and variable type annotations. They can be used by third party tools such as type checkers, IDEs, linters, etc.</span></pre><h2 id="b2bf" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">元组可以包含其他元组！</h2><p id="8cd6" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">您可能熟悉如何指定颜色的名称及其RGB值。这里有一张<a class="ae jg" href="https://www.w3schools.com/colors/colors_names.asp" rel="noopener ugc nofollow" target="_blank">常用HTML颜色名称</a>和它们的十六进制RGB值的表格。让我们使用元组来创建这个Pythonic！</p><figure class="mg mh mi mj gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="97de" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的代码编辑器中，这是我得到的输出:</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/624f15efe09a5213366e59e4114d0f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9sn3DCnhcc86YS5Z1TW4g.png"/></div></div></figure><p id="6cf1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是怎么回事？</p><ul class=""><li id="b806" class="mp mq jj ki b kj kk kn ko kr mr kv ms kz mt ld mu mv mw mx bi translated">首先，请注意我在第21行的打字错误。我写的是“娜内”，不是“名字”。每个人都会犯错！随便给我修；)</li><li id="eaa7" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第1行，我们再次导入了<code class="fe mc md me mf b">collections</code>模块。我已经喜欢上它了！</li><li id="49a3" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第3行和第4行，我们定义了两个新的命名元组。我们还指定索引[1]被命名为“rgbvalue”。在这个索引中，我们将在<code class="fe mc md me mf b">tuple</code>中存储一个完整的元组。</li><li id="9c3c" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第6行，我们定义了一个<code class="fe mc md me mf b">set</code>，它将保存我们接下来要定义的所有元组。</li><li id="e4b8" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第8、11、14和17行，我们创建了一个名为<code class="fe mc md me mf b">htmltuple</code>的变量。我们给这个变量分配一个新的<code class="fe mc md me mf b">namedtuple</code>。我们通过调用构造函数<code class="fe mc md me mf b">htmlcolour</code>并向其传递我们想要的值来创建元组值。第一个参数包含颜色的名称。第二个参数包含一个新的<code class="fe mc md me mf b">namedtuple</code>，这次是从第3行定义的<code class="fe mc md me mf b">rgbvalue</code> <code class="fe mc md me mf b">namedtuple</code>构造的。</li><li id="dc6a" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">请注意，我使用红色=、蓝色=、绿色=来代替索引。我还注意到，我稍微改变了一下顺序，以证明使用命名索引可以很好地工作。</li><li id="29e1" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">您已经注意到RGB值使用十六进制系统，其中十六进制FF等于十进制255。在Python中，我们可以通过在十六进制值前面加上符号<code class="fe mc md me mf b">0x</code>来直接使用它们。</li><li id="8594" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第9、12、15和18行，我们将新元组添加到名为<code class="fe mc md me mf b">colours</code>的集合中。</li><li id="2c79" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">在第21到25行，我打印出了一些用户友好的信息(针对颜色集合中的每个元素)。这一行对我的编辑器来说太长了，所以我用多个F字符串把它分成几行。</li><li id="08c9" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">注意，我使用点符号<code class="fe mc md me mf b">colour.rgbvalue.blue</code>继续深入挖掘元组。我觉得这比写<code class="fe mc md me mf b">colour[1][2] </code>达到blue的值对程序员更友好！</li></ul><h2 id="b9b0" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">我们取得了什么成就？</h2><p id="2c7e" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">真的，这么多！如果你已经走了这么远，你应该为你的成就感到骄傲！我希望你玩得开心。</p><ul class=""><li id="e733" class="mp mq jj ki b kj kk kn ko kr mr kv ms kz mt ld mu mv mw mx bi translated">我们已经讨论过集合和元组了。</li><li id="d23b" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">我们已经考虑了用于创建新对象的<em class="mm">构造函数</em>。</li><li id="ccdc" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">我们已经考虑了<em class="mm">可变性</em>，一个对象的属性告诉我们它是否是可修改的。</li><li id="c422" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">我们已经研究了<em class="mm">类型提示</em>，注意到它们只不过是一个有用的提示。</li><li id="a520" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">我们已经看到了<code class="fe mc md me mf b">frozenset</code>，一种<code class="fe mc md me mf b">set</code>数据类型的不可变变体。</li><li id="ff2d" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">我们探索了如何使用索引来访问元组中的特定元素。</li><li id="b8ac" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">我们已经使用了<code class="fe mc md me mf b">namedtuple</code>数据类型以一种可读性更好的方式来编写元组。</li><li id="c2d2" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated">我们已经学习了集合和元组之间的转换。</li></ul><p id="ad6a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢这个！如果你发现任何错误，请让我知道！在本系列的下一篇文章中，我们将探索两种非常有用的复合数据类型，<code class="fe mc md me mf b">list</code>和<code class="fe mc md me mf b">dict</code>。</p><h1 id="5672" class="nq lf jj bd lg nr ns nt lj nu nv nw lm nx ny nz lp oa ob oc ls od oe of lv og bi translated">到目前为止，本系列中的文章:</h1><ul class=""><li id="5702" class="mp mq jj ki b kj lx kn ly kr oh kv oi kz oj ld mu mv mw mx bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-an-introduction-ee9115d52dbd" rel="noopener">学习Python编程—简介</a></li><li id="20f1" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-functions-1a7213eda13d" rel="noopener">学习Python编程—函数介绍</a></li><li id="2af8" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-controlling-execution-flow-3755d8421d8" rel="noopener">学习Python编程——控制执行流程</a></li><li id="ad57" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-data-types-strings-c5c1f6295940" rel="noopener">学习Python编程—数据类型简介:字符串</a></li><li id="7e27" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-data-types-numbers-b777b100fd3" rel="noopener">学习Python编程—数据类型简介:数字</a></li><li id="fcd9" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-compound-data-types-sets-and-tuples-ac7466881bd5" rel="noopener">学习Python编程—复合数据类型简介:集合和元组</a></li><li id="afae" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-compound-data-types-lists-57b50e2633c6" rel="noopener">学习Python编程—复合数据类型简介:列表</a></li><li id="0759" class="mp mq jj ki b kj my kn mz kr na kv nb kz nc ld mu mv mw mx bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/learn-programming-with-python-introduction-to-compound-data-types-dictionaries-f9372369e37e">学习Python编程—复合数据类型简介:字典</a></li></ul></div></div>    
</body>
</html>