<html>
<head>
<title>gRPC Basics Part 2: Rest and Swagger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC基础第2部分:休息和昂首阔步</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-basics-part-2-rest-and-swagger-53ec2417b3c4?source=collection_archive---------1-----------------------#2019-07-01">https://levelup.gitconnected.com/grpc-basics-part-2-rest-and-swagger-53ec2417b3c4?source=collection_archive---------1-----------------------#2019-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f15309f193e12b20c7e99f31606eb6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wZkczapCXWq5O1Aoq56hXA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:https://grpc.io/</figcaption></figure><p id="b030" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我的同事<a class="ae kf" href="https://www.linkedin.com/in/scott-walker-38542a6a/" rel="noopener ugc nofollow" target="_blank">斯科特·沃克</a>和<a class="ae kf" href="https://www.linkedin.com/in/andrew-hayes-belfast/" rel="noopener ugc nofollow" target="_blank">我</a>正在撰写的gRPC系列文章的第二部分。这是第1部分的继续，我们将展示一些使用REST公开gRPC服务并为其自动生成swagger文件的例子。我们所有示例的完整代码都可以在我们的<a class="ae kf" href="https://github.com/scottyw/grpc-example" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到。</p><h1 id="5977" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第1部分不是说gRPC可以替代REST吗？</h1><p id="835e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">是的，但是有时候你必须休息。也许那是为了第三方集成到你的服务中，甚至是为了你的UI。幸运的是，我们可以使用“协议”生成REST端点，放在gRPC服务之上。</p><h1 id="6a37" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">示例b .向gRPC服务添加REST端点</h1><p id="df2a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这个例子，一个带有REST的基本gRPC客户端和服务器在这里:'<a class="ae kf" href="https://github.com/scottyw/grpc-example/tree/master/B.grpc-with-rest" rel="noopener ugc nofollow" target="_blank">gRPC-example/b . gRPC-with-REST</a>'。当添加REST端点时，我们需要告诉gRPC将哪个URL映射到'中的每个函数。“原型”文件。带有URL映射的MakeBox的更新定义如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6974" class="mq lf it mm b gy mr ms l mt mu">rpc MakeBox(BoxSpecification) returns (Box) {<br/>    option (google.api.http) = {<br/>        get: "/v1/make-box"<br/>    };        <br/>}</span></pre><p id="fed5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着当我们调用URI '/v1/make-box '时，它将被传递给MakeBox函数。为了利用我们需要再次生成代码的更改，在我们的示例repo中，您需要调用‘make generate’。所做的就是运行带有几个参数的“protoc”命令，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3ce3" class="mq lf it mm b gy mr ms l mt mu">protoc \<br/>  -I/usr/local/include \<br/>  -I. \<br/>  -I$(GRPC_GATEWAY_DIR)/third_party/googleapis \<br/>  --go_out=plugins=grpc:factory \<br/>  --grpc-gateway_out=logtostderr=true:factory \<br/>  --proto_path proto factory.proto</span></pre><p id="3de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像第1部分中的例子一样，这将为生成的go代码创建一个目录“工厂”。我们已经实现了所需的“go接口”。所以我们现在需要做的是启动一个HTTP服务器来接受其余的调用，并将它们传递给我们的gRPC服务。为此，我们将在“<a class="ae kf" href="https://github.com/scottyw/grpc-example/blob/master/B.grpc-with-rest/factoryserver/server.go" rel="noopener ugc nofollow" target="_blank">factory server/server . go</a>”文件中创建一个名为“startHTTP”的函数，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fd87" class="mq lf it mm b gy mr ms l mt mu">func startHTTP() {<br/> ctx := context.Background()<br/> ctx, cancel := context.WithCancel(ctx)<br/> defer cancel()</span><span id="6753" class="mq lf it mm b gy mv ms l mt mu">// Connect to the GRPC server<br/> conn, err := grpc.Dial("localhost:5566", grpc.WithInsecure())<br/> if err != nil {<br/>  log.Fatalf("fail to dial: %v", err)<br/> }<br/> defer conn.Close()</span><span id="8869" class="mq lf it mm b gy mv ms l mt mu">// Register grpc-gateway<br/> rmux := runtime.NewServeMux()<br/> client := factory.NewBoxFactoryClient(conn)<br/> err = factory.RegisterBoxFactoryHandlerClient(ctx, rmux, client)<br/> if err != nil {<br/>  log.Fatal(err)<br/> }<br/> log.Println("REST server ready...")<br/> err = http.ListenAndServe("localhost:8080", rmux)<br/> if err != nil {<br/>  log.Fatal(err)<br/> }<br/>}</span></pre><p id="0c46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这创建了一个HTTP多路复用器，将请求路由匹配到我们的gRPC函数。多路复用器向gRPC客户机注册，并将其连接到gRPC服务器。然后，在启动gRPC服务器时，我们需要启动HTTP服务器。在如下所示的'<a class="ae kf" href="https://github.com/scottyw/grpc-example/blob/master/B.grpc-with-rest/factoryserver/server.go" rel="noopener ugc nofollow" target="_blank"> factoryserver/server.go </a>'文件中:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cac8" class="mq lf it mm b gy mr ms l mt mu">func main() {<br/>  go startGRPC()</span><span id="96d7" class="mq lf it mm b gy mv ms l mt mu">  go startHTTP()</span><span id="3bd6" class="mq lf it mm b gy mv ms l mt mu">  // Block forever<br/>  var wg sync.WaitGroup<br/>  wg.Add(1)<br/>  wg.Wait()<br/>}</span></pre><p id="eec5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着HTTP请求现在被映射到适当的gRPC函数，这意味着我们现在有了MakeBox函数的REST端点。您可以通过在<a class="ae kf" href="https://github.com/scottyw/grpc-example/tree/master/B.grpc-with-rest" rel="noopener ugc nofollow" target="_blank">示例回购</a>中调用‘make all’来测试这一点。使用以下命令启动服务器:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6c04" class="mq lf it mm b gy mr ms l mt mu">./bin/server</span></pre><p id="12ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦服务器开始运行，您就可以使用curl来调用REST端点:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a96b" class="mq lf it mm b gy mr ms l mt mu">curl <a class="ae kf" href="http://localhost:8080/v1/make-box?height=1&amp;width=2&amp;depth=3" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/make-box?height=1&amp;width=2&amp;depth=3</a></span></pre><h1 id="5bc5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">示例c .使用gRPC生成Swagger</h1><p id="9f2e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Swagger是一个<a class="ae kf" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI规范</a>，用于以一种语言中立和人类可读的方式描述RESTful服务。因此，我们可以生成一个swagger文件，然后任何想要与我们的服务交互的人都可以毫不费力地理解它是如何工作的。它还可以用来生成文档，当我们更新服务时，我们再次生成swagger文件，我们的文档也随之更新。</p><p id="440d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<a class="ae kf" href="https://github.com/scottyw/grpc-example/tree/master/C.adding-swagger" rel="noopener ugc nofollow" target="_blank">示例repo </a>中，我们向Makefile中的“protoc”调用添加了一个'— swagger_out '参数，现在看起来像这样:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="94b5" class="mq lf it mm b gy mr ms l mt mu">protoc \<br/>  -I/usr/local/include \<br/>  -I. \<br/>  -I$(GRPC_GATEWAY_DIR)/third_party/googleapis \<br/>  --go_out=plugins=grpc:factory \<br/>  --swagger_out=logtostderr=true:factory \<br/>  --grpc-gateway_out=logtostderr=true:factory \<br/>  --proto_path proto factory.proto</span></pre><p id="c4a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们调用“make generate”时，这将把一个“factory.swagger.json”文件和generate go代码一起添加到“factory”目录中。然后，您可以使用它来生成文档，并帮助其他团队/用户了解如何与服务进行交互。</p><h1 id="9612" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">额外收获:添加Swagger UI</h1><p id="85d9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们在生成swagger文件时可以做的另一件事是添加Swagger UI。Swagger UI是一个开源工具，允许您使用其Swagger文件可视化服务并与之交互。您可以在这里下载它<a class="ae kf" href="https://swagger.io/tools/swagger-ui/download/" rel="noopener ugc nofollow" target="_blank">，但是我们已经将它添加到了我们的repo中的'</a><a class="ae kf" href="https://github.com/scottyw/grpc-example/tree/master/C.adding-swagger/www" rel="noopener ugc nofollow" target="_blank"> C.grpc-with-rest/www </a>'目录中。为了使用它，我们将我们的swagger文件复制到同一个目录中:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="23e2" class="mq lf it mm b gy mr ms l mt mu">cp factory/factory.swagger.json www/swagger.json</span></pre><p id="d102" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们需要告诉我们的HTTP服务器为这些文件以及gRPC端点提供服务。我们更新了server.go以包含一个服务于swagger文件的函数，并更新了startHTTP函数以服务于swagger-ui。看起来像这样:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d269" class="mq lf it mm b gy mr ms l mt mu">func serveSwagger(w http.ResponseWriter, r *http.Request) {<br/> http.ServeFile(w, r, "www/swagger.json")<br/>}</span><span id="ca63" class="mq lf it mm b gy mv ms l mt mu">func startHTTP() {<br/> ctx := context.Background()<br/> ctx, cancel := context.WithCancel(ctx)<br/> defer cancel()</span><span id="22d5" class="mq lf it mm b gy mv ms l mt mu"> // Connect to the GRPC server<br/> conn, err := grpc.Dial("localhost:5566", grpc.WithInsecure())<br/> if err != nil {<br/>   log.Fatalf("fail to dial: %v", err)<br/> }<br/> defer conn.Close()</span><span id="c38c" class="mq lf it mm b gy mv ms l mt mu"> // Register grpc-gateway<br/> rmux := runtime.NewServeMux()<br/> client := factory.NewBoxFactoryClient(conn)<br/> err = factory.RegisterBoxFactoryHandlerClient(ctx, rmux, client)<br/> if err != nil {<br/>   log.Fatal(err)<br/> }</span><span id="1f85" class="mq lf it mm b gy mv ms l mt mu"> // Serve the swagger-ui and swagger file<br/> mux := http.NewServeMux()<br/> mux.Handle("/", rmux)</span><span id="8e6f" class="mq lf it mm b gy mv ms l mt mu"> mux.HandleFunc("/swagger.json", serveSwagger)<br/> fs := http.FileServer(http.Dir("www/swagger-ui"))<br/> mux.Handle("/swagger-ui/", http.StripPrefix("/swagger-ui", fs))</span><span id="d1c2" class="mq lf it mm b gy mv ms l mt mu"> log.Println("REST server ready...")<br/> err = http.ListenAndServe("localhost:8080", mux)<br/> if err != nil {<br/>   log.Fatal(err)<br/> }<br/>}</span></pre><h1 id="e239" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">运行代码</h1><p id="2871" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要在我们的示例repo 中构建二进制文件，只需运行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0545" class="mq lf it mm b gy mr ms l mt mu">make all</span></pre><p id="5ff3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要启动服务器，我们需要运行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="541a" class="mq lf it mm b gy mr ms l mt mu">./bin/server</span></pre><p id="fda4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将启动gRPC服务器，但也会启动REST服务器。为了测试它，我们现在有几个选项。如果需要，我们可以运行gRPC客户端:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="60b7" class="mq lf it mm b gy mr ms l mt mu">./bin/client</span></pre><p id="c5ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在还可以使用curl与服务进行交互。为此，我们将运行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="972d" class="mq lf it mm b gy mr ms l mt mu">curl localhost:8080/v1/make-box?height=2&amp;width=2&amp;depth=3</span></pre><p id="1b4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者如果你更喜欢UI，你可以使用“swagger-ui”。只需在浏览器中打开网址，就可以使用“swagger-ui”与服务进行交互。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="71de" class="mq lf it mm b gy mr ms l mt mu">localhost:8080/swagger-ui/</span></pre></div></div>    
</body>
</html>