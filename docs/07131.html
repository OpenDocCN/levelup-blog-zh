<html>
<head>
<title>Understanding Proxy Pattern in Swift within 5 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在5分钟内了解Swift中的代理模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-proxy-pattern-in-swift-within-5-minutes-3b9ae19a6c99?source=collection_archive---------10-----------------------#2021-01-26">https://levelup.gitconnected.com/understanding-proxy-pattern-in-swift-within-5-minutes-3b9ae19a6c99?source=collection_archive---------10-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/536b9f8a089d53c0537620afd1d31666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEetpd65rHFATWNEyKjDtA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">作者声明:Michael Abadi S .</figcaption></figure><div class=""/><p id="a9a1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">代理模式是少数几个被低估的模式之一，在iOS中没有人真正谈论它。<strong class="kh jj">代理</strong>模式是一种结构化设计模式，允许您为另一个对象提供一个替代品或占位符。代理完全控制和访问原始对象，并让代理对象对原始对象做一些神奇的事情，并限制对它的访问，但是，使用代理对象的人不会有任何幕后知识。</p><p id="2fba" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">代理模式通常在移动开发之外使用，当一些请求想要将请求映射到一个特定的对象，而不暴露关于该对象的底层知识，因此它可以与符合原始对象的任何对象互换。然而，代理模式也可以用于移动开发。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ld"><img src="../Images/628f4ec35564def0f7b981dc2314785c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEKsNA_r0jrZ6vtV3YsMaw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">代理模式图</figcaption></figure><p id="c75f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">代理的好处是，它可以伪装成一个真实的对象，因为接口类似于真实的客户端对象，但是，我们不会中断原始对象，这意味着我们可以在代理中插入或删除某些内容，而不会损害原始对象。代理具有与操作的原始流程的网关相似的行为。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="e2c9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里让我们来看一个真实的用例。一个存储库对象想要调用一个API的网络请求，但是由于公司已经转移到新系统，他们想要逐渐从旧的REST API迁移到GraphQL端点。因此，为了使存储库仍然能够与现有的接口一起工作而不中断更改，我们将创建一个代理对象，它具有与原始对象相似的接口</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lp"><img src="../Images/70921e5efe3dae1425674f4f48013a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYR__y0tYSW59GeVp24b9g.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">代理类的结构</figcaption></figure><p id="7f3c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以代码很简单，定义你的服务接口。然后，为服务于使用REST API的旧系统和使用GraphQL的新系统的两个类创建真正的服务实现类。打电话的人是这样的。很简单，实例化你的代理类，然后调用代理方法。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/64806b9e541c55d89ed05f7c864870ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iuVaXSIoGaHtPRSmaOch3Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">实现类</figcaption></figure><p id="114e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">关于适配器和代理模式之间的区别，存在一些混淆。这个栈溢出<a class="ae lr" href="https://stackoverflow.com/questions/37692814/what-is-the-exact-difference-between-adapter-and-proxy-patterns" rel="noopener ugc nofollow" target="_blank">回答</a>对此有很好的回答。基本上，代理只是一个代理，它与原始对象有相似的接口，然而与适配器相反。适配器模式的目的是帮助访问者能够使用不能与新实现一起工作的旧系统，因此适配器对象和被适配器对象具有不同的接口。</p></div></div>    
</body>
</html>