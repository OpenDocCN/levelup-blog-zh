<html>
<head>
<title>Golang 2.0 Draft Feature — Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 2.0草图特征-错误处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-2-0-draft-feature-error-handling-c0a2332b9162?source=collection_archive---------2-----------------------#2022-01-03">https://levelup.gitconnected.com/golang-2-0-draft-feature-error-handling-c0a2332b9162?source=collection_archive---------2-----------------------#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="921f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Golang目前是1.17版本(2022年1月)。尽管还不清楚Golang 2.0将于何时发布，以及它将包含哪些功能，但有几个有趣的草案，很有可能至少其中一些草案功能将成为Golang 2.0的一部分。在这个系列中，我将总结Golang 2.0中的草稿特性，我们将从错误处理开始。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c2c6dcc82b8090da60722e735879f179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xZkF6mq2knNGxbaAHt2sw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@rojekilian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sarah Kilian </a>在<a class="ae le" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="2b28" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">错误处理</h1><p id="2f38" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Golang中的错误处理是讨论最多的话题之一。现在Golang强迫你——这很好——在调用任何产生书面结果的函数后检查错误</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="3470" class="mn lg it mj b gy mo mp l mq mr">if (err != nil) {<br/>    return err // or do something else<br/>}</span></pre><p id="bfe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我看来，Golang有这样一个显式的错误检查是件好事，因为它能让你意识到错误的处理。然而，这也导致了重复编写相同的代码，这是不理想的。</p><p id="7ea8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Golang 2.0草案通过引入一个新的关键字<code class="fe ms mt mu mj b">check</code>和<code class="fe ms mt mu mj b">handler</code>函数来解决这个问题。不是显式地检查每个错误，而是在函数前面添加关键字<code class="fe ms mt mu mj b">check</code>,表明这些返回值应该通过处理函数来检查。一个小例子看起来像这样</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="29c1" class="mn lg it mj b gy mo mp l mq mr">func foobar(a, b int) error {<br/>    handle err { return err } // This is our handler</span><span id="5213" class="mn lg it mj b gy mv mp l mq mr">    x := check foo(a, b) // check invokes the handle func<br/>    y := check bar(a, b) // this on as well</span><span id="e78b" class="mn lg it mj b gy mv mp l mq mr">    if (x &gt; y) {<br/>        return fmt.Errorf("This is an error")<br/>    }<br/>}</span></pre><p id="0e26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们一行一行地过一遍。首先，我们定义函数foobar，它将a和b作为输入，并返回一个错误。在下一行中，我们定义了由关键字<code class="fe ms mt mu mj b">handle</code>指示的错误处理函数。处理函数接受error类型的参数，并具有与封闭函数相同的返回签名。因此，当foobar只返回一个错误时，处理程序只能返回一个错误。如果foobar将返回<code class="fe ms mt mu mj b">(int, error)</code>，处理函数将需要返回例如<code class="fe ms mt mu mj b">0,err</code>。</p><p id="daea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关键字<code class="fe ms mt mu mj b">check</code>表示该函数应该使用预定义的错误处理函数进行检查。所以与其写作</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="5b44" class="mn lg it mj b gy mo mp l mq mr">x, err := foo(a, b)<br/>if (err != nil) {<br/>    return err<br/>}</span></pre><p id="9f55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只写<code class="fe ms mt mu mj b">x := check foo(a, b)</code>。这执行相同的代码流，但不会产生任何代码开销。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="d4de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">处理程序的一个好处是你可以链接处理程序。让我们看看下面的代码。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="4013" class="mn lg it mj b gy mo mp l mq mr">func foobar(a, b int) error {<br/>    handle err { return err } // This is our handler</span><span id="0da7" class="mn lg it mj b gy mv mp l mq mr">    x := check foo(a, b) // check invokes the first handle func<br/>    y := check bar(a, b) // this on as well</span><span id="a675" class="mn lg it mj b gy mv mp l mq mr">    if (x &gt; y) {<br/>        handle err { err = fmt.Errorf("doSomething with %x and %y, x, y) } // second handler<br/>        check doSomething(x, y) // invokes second handler and then the first<br/>    }<br/>    check doSomething(y, x) // invokes first handler<br/>    return nil</span><span id="56e5" class="mn lg it mj b gy mv mp l mq mr">}</span></pre><p id="063c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上面的代码所示，如果我们定义了多个处理函数，它们将以相反的顺序执行。请注意，处理函数只对定义它们的作用域有效。所以在<code class="fe ms mt mu mj b">if</code>块中定义的处理函数将只在作用域内被调用。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="0e68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">错误处理功能提案看起来很有前途。尽管我现在很喜欢Golang的显式错误处理，但我们可以减少代码开销，尤其是在大型项目中，这很好。我仍然不确定这是否会带来更多的复杂性而不是可读性，但我期待着测试它。</p><p id="bd64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您对更多Golang文章感兴趣，请查看以下内容</p><p id="a2bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://itnext.io/the-power-of-golang-keyword-defer-b31bdecf10b6" rel="noopener ugc nofollow" target="_blank">https://it next . io/the-power-of-golang-keyword-defer-b 31 bde cf 10b 6</a></p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="3a1a" class="lf lg it bd lh li nd lk ll lm ne lo lp lq nf ls lt lu ng lw lx ly nh ma mb mc bi translated">资源</h1><p id="ff24" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated"><a class="ae le" href="https://go.googlesource.com/proposal/+/master/design/go2draft.md" rel="noopener ugc nofollow" target="_blank">https://go . Google source . com/proposal/+/master/design/go 2d draft . MD</a></p></div></div>    
</body>
</html>