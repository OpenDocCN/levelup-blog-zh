<html>
<head>
<title>Understanding Isolation Levels in a Database Transaction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解数据库事务中的隔离级别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-isolation-levels-in-a-database-transaction-af78aea3f44?source=collection_archive---------2-----------------------#2022-06-05">https://levelup.gitconnected.com/understanding-isolation-levels-in-a-database-transaction-af78aea3f44?source=collection_archive---------2-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5f017d1e074b23dc3fc0686ea8da7cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SyTy_iC9aRRPnUnlzB5uAg.png"/></div></div></figure><p id="c9c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将讨论数据库事务中各种类型的隔离级别。首先，我们需要讨论“什么是数据库中的事务？”。数据库中的事务可以定义为ACID属性的实现。</p><p id="353b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> A </strong> —该属性指定数据库上的每个事务本质上都应该是原子的。事务中的一系列命令应该作为单个实体来执行，在出现任何异常的情况下，应该作为单个实体来回滚。不应该有部分执行事务的状态。</p><p id="98fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> C </strong> —酸中的C代表一致性。这意味着事务不应该违反数据库的任何约束。</p><p id="5b96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> I </strong> — I代表隔离，这意味着特定的事务应该将自己视为数据库中唯一的事务。</p><p id="2983" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> D </strong> — D代表耐久性。这意味着特定事务所做的更改应该是持久的，并且应该在磁盘上是持久的。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/70bc024e490e1db6b7bd36702fe98594.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*FEdFnZ0Yac4ZtwZ9sylIEQ.png"/></div></figure><p id="b560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当完成ACID属性的调整时，可以考虑数据库中的隔离级别。例如，如果我们想获得高级别的隔离，那么我们应该使用可序列化的隔离级别。数据库中有4种主要的隔离级别:</p><ol class=""><li id="45f5" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv lg lh li lj bi translated"><strong class="ka ir">读取已提交的</strong></li><li id="c3a4" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated"><strong class="ka ir">读取未提交的数据</strong></li><li id="dc68" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated"><strong class="ka ir">可重复读取</strong></li><li id="863f" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated"><strong class="ka ir">可序列化</strong></li></ol><p id="4c66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着逐一详细了解这些隔离级别。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="7e36" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">读取提交的隔离级别</h1><p id="bf5c" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">提交读取的隔离级别有两个属性:</p><ol class=""><li id="2b15" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv lg lh li lj bi translated"><strong class="ka ir">无脏读:</strong>这意味着数据库不会读取任何未提交的值</li></ol><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/178a262a4875ac3de1eebcc8f069f224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8E13WT_TotPkxV4ug3dFiQ.png"/></div></div></figure><p id="6e69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。没有脏写:</strong>这意味着数据库将接受已经有事务在其上运行的特定行上的任何事务。另一个事务必须等到提交行上的前一个事务，并且只有在此之后，任何其他事务才能够对特定行执行写操作。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/a30bc4f842f37f86beffc8a6ce7dd772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVGTRQv3PwMoqNUXWJbHPQ.png"/></div></div></figure><p id="09f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用MySQL的读提交隔离级别的示例可以在以下位置找到:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="4bcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。可重复读取隔离级别</strong></p><p id="f5b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当要对其执行事务的值在事务持续时间内发生变化时，将使用此隔离级别。例如，我们有一张个人账户余额表。现在，我们有一个事务在这个表上执行两种类型的任务:</p><ol class=""><li id="1826" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv lg lh li lj bi translated">计算交易的数量</li><li id="304a" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated">找出所有交易的总和</li></ol><p id="f065" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们假设一个场景，在执行查询1之后，在这个表上插入了任何值。现在，查询2的结果将受此影响。在这种情况下，我们更喜欢使用可重新读取的隔离级别，这可以保证参与事务的行数在整个事务中保持其当前值。数据库使用多版本并发控制实现相同的功能。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="f166" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。读取未提交的隔离级别</strong></p><p id="107e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们甚至需要行的未提交值时，就使用这种类型的隔离级别。任何未提交的更新和插入都应该反映在我们的事务中。这种类型的隔离级别在预订系统中大量使用，如果任何其他事务试图更新座位的可用性，即使该事务没有被提交，我们也应该能够看到这些变化。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="aad3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4。可序列化隔离级别</strong></p><p id="068c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是所有隔离级别中最强的，可以保证完全隔离。在这种类型的事务在数据库上运行之前，任何其他事务都不能读写值。这个隔离级别解决了前面讨论的所有3个隔离级别中的所有问题，但是由于它只允许在数据库上执行一个查询，因此限制了系统的可伸缩性。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div></div>    
</body>
</html>