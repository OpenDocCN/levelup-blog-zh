<html>
<head>
<title>The React and React Native Event System Explained: A Harmonious Coexistence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应和反应本土事件系统解释:和谐共存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-exactly-does-react-handles-events-71e8b5e359f2?source=collection_archive---------1-----------------------#2017-11-30">https://levelup.gitconnected.com/how-exactly-does-react-handles-events-71e8b5e359f2?source=collection_archive---------1-----------------------#2017-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e91" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你正在使用它。你喜欢它。但是您知道React的事件处理程序在做什么吗？</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/438bac357b1bb6aae68a38285fa123e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlfmccSmDYUJITMeQOhaow.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">如果你不知道它是如何工作的，事情有时会变得令人惊讶的混乱…</figcaption></figure><p id="a959" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多帖子解释如何使用React的事件处理系统，但没有多少解释<em class="ls">如何工作的</em>。我最近一直在做React Native，我在事件处理方面的挣扎提醒我准确理解<em class="ls">正在发生的事情是多么重要。因此，我决定收集尽可能多的关于React中事件处理的信息:以下是我在查看<a class="ae lt" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank">源代码</a>时发现的报告。</em></p><p id="4726" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们走吧！</p><h1 id="6e0d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">React中的事件处理:概述</h1><p id="3866" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">从概念上讲，React中的事件处理没有什么革命性。它唯一的目标是拦截各种事件(点击、触摸……)并触发程序员编写的相关回调。正是<em class="ls">实现</em>让React的事件处理系统脱颖而出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mr"><img src="../Images/2ebb692336fa58ef66d2b9a1a7e30180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ao9wxQ-msVx37_urlFKb7A.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">React事件处理流程概述</figcaption></figure><p id="ecfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React强调的一点是协调:跨浏览器的React web，跨平台的React Native。但是事件系统实际上把这个概念又向前推进了一步，为<em class="ls">React web和React Native提供了一个(几乎)相同的事件处理系统。没错:DOM和原生事件都是使用完全相同的代码</em>来处理的——减去一点点预处理。React是如何完成这个魔术的？这本身就可以成为一篇文章的主题，所以让我们尽量简短。</p><h1 id="3fac" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">欢迎来到纤维的神奇世界</h1><p id="304c" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">当一个应用程序更新时(比如说，点击一个按钮后)会发生什么？新的信息传播，应用程序必须用它再次渲染。现在，React (web或原生)背后的核心思想是将这一过程分为两个独立的阶段:“协调”——React计算差异并决定需要什么更新——和“渲染”——实际应用更新。看到这将我们引向何方了吗？你说得对。<strong class="ky ir">“协调”阶段不关心<em class="ls">如何</em>或<em class="ls">在哪里</em>渲染，只关心<em class="ls">应该渲染什么</em></strong>。因此，相同的过程可以用于React Native和React web。剩下唯一要做的工作是插入合适的渲染引擎。</p><p id="41d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事件处理是“协调”阶段的一部分，因此发生在同一个抽象世界中，其中浏览器事件和DOM组件与本机事件和组件没有什么不同。那个世界是什么样子的？这可能有点复杂，因为我们习惯于从可见的、有形的物体的角度来思考，但是在这个平行宇宙中，每一个组成部分都变成了一个<code class="fe ms mt mu mv b">Fiber</code>。事实上，由于React协调算法并不关心组件如何渲染，而只关心<em class="ls">在两次渲染迭代之间什么改变了</em>，组件本身并不重要。只有从组件的先前状态到新状态必须完成的工作才是重要的(如果没有发生变化，该工作也可以是无操作)。这就是<code class="fe ms mt mu mv b">Fiber</code>的含义:它不是一个物理实体，而是一个工作单元，是协调过程的大计划中的一小步。</p><p id="7e8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些对之前的<code class="fe ms mt mu mv b">Fiber</code> s的介绍感到好奇的人，我建议你多了解一下<code class="fe ms mt mu mv b">Fiber</code>和React Fiber！林·克拉克的这个有趣的视频演示是一个好的开始。对于其他人，不要担心:理解纤程绝对不是理解本文其余部分所必需的(转向纤程是最近的事，无论如何，事件管理系统在这个过程中没有经历任何重大变化)。需要记住的是:<strong class="ky ir"> React在一个“抽象的世界”中工作，在这个世界中，更新是独立于组件的物理表示而进行的:多个“现实世界”</strong>(浏览器、手机…) <strong class="ky ir">呈现组件的地方只是那个独特的、独立于设备的世界的投影。事件处理也不例外，几乎所有事情都发生在这个“抽象世界”中——无论事件最初来自DOM还是本地，都没有关系。</strong></p><p id="8a83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在事件处理的情况下，“监听、规范化和重新发射”阶段的存在正是为了将真实的事件和组件转换成它们的抽象对应物。它捕获来自组件的本地事件，并将它们转换成React所说的与<code class="fe ms mt mu mv b">Fiber</code>相关联的<code class="fe ms mt mu mv b">topLevelType</code>。因此，本地事件和组件本身对于下游事件处理系统来说实际上是不可见的，并且在“真实”环境中没有安装处理程序:一切都发生在虚拟DOM中。</p><h1 id="0d7c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">接收(监听)事件</h1><p id="84d3" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">好的，看上面的图，似乎在每种情况下，事件处理都是从监听阶段开始的。这不足为奇。毕竟，我们中的许多人习惯于在应用程序中定义自己的定制监听器——因为我们希望它只对<code class="fe ms mt mu mv b">click</code>做出反应，而不是对<code class="fe ms mt mu mv b">mousescroll</code>做出反应。但是为什么<em class="ls">会自己做出反应</em>需要监听所有事件呢？这是因为事件出现在它们的“自然”环境中:web应用程序的DOM，以及移动设备上的本机。React，无论是它的web版本还是本机版本，都是建立在这些基础环境之上的工具。因此，<strong class="ky ir">事件不会自然地经过React，它必须主动地监听它们</strong>。</p><h2 id="b97c" class="my lv iq bd lw mz na dn ma nb nc dp me lf nd ne mg lj nf ng mi ln nh ni mk nj bi translated">接收事件:React web</h2><p id="969f" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">对于React web，这个过程相当简单，使用<strong class="ky ir">顶级委托</strong>。这意味着React在<code class="fe ms mt mu mv b">document</code>级别监听每一个事件，这有一个有趣的含义:当任何React相关的代码被执行时，事件已经<em class="ls"/>通过了DOM树的第一个捕获/冒泡周期。</p><p id="35a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从浏览器接收到该事件后，React执行一个额外的跨浏览器协调步骤。作为对同一事件有不同名称的浏览器的一种变通方法，React定义了<code class="fe ms mt mu mv b">topLevelTypes</code>，它是特定于浏览器的事件的包装器。例如，<code class="fe ms mt mu mv b">transitionEnd</code>、<code class="fe ms mt mu mv b">webkitTransitionEnd</code>、<code class="fe ms mt mu mv b">MozTransitionEnd</code>和<code class="fe ms mt mu mv b">oTransitionEnd</code>都变成了<code class="fe ms mt mu mv b">topAnimationEnd</code>——通过整合有效地减轻了设计跨浏览器应用程序的部分痛苦。</p><h2 id="fdb0" class="my lv iq bd lw mz na dn ma nb nc dp me lf nd ne mg lj nf ng mi ln nh ni mk nj bi translated">接收事件:本地反应</h2><p id="7765" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">对于React Native，事件是通过将本机代码与React 链接起来的桥<strong class="ky ir">接收的。简而言之，每当创建一个<code class="fe ms mt mu mv b">View</code>时，React也会将其ID号传递给native，以便能够接收与该元素相关的所有事件。同样，在将(touch)事件传递到下游之前会进行一些小的修改，包括将<code class="fe ms mt mu mv b">touches</code>和<code class="fe ms mt mu mv b">changedTouches</code>数组添加到事件中，以使其符合<a class="ae lt" href="https://www.w3.org/TR/touch-events/#idl-def-TouchEvent" rel="noopener ugc nofollow" target="_blank"> W3的</a>。</strong></p><p id="1faf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，为了将它们与后面将要介绍的<code class="fe ms mt mu mv b">SyntheticEvents</code>区分开来，我们将称之为“事件”(即事件对象，来自本机或浏览器，经过轻微的修改)为“本机事件”</p><h1 id="13ab" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">React事件管理系统的内部结构</h1><p id="0d88" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们现在有了跨平台和浏览器的本地事件。太好了！我们现在准备开始真正的工作:将这些事件传递给适当的回调函数。这就是React事件系统的职责。让我们仔细看看。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nk"><img src="../Images/0d8b348f4205cf4d7e708f428e0e81d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkSaPCYDjvCHS2byF_Ifwg.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">React事件系统中的事件流</figcaption></figure><p id="a35a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">咻，到处都是东西。尽管如此，<code class="fe ms mt mu mv b">EventPluginHub</code>和它的事件插件还是脱颖而出。<code class="fe ms mt mu mv b">EventPluginHub</code>实际上是整个体系的基石，正如它:</p><ul class=""><li id="355b" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">为要注入的事件插件提供统一的接口。</li><li id="bf0e" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">每次接收到新的本地事件时，运行注入的插件，在分派它们之前收集返回的<code class="fe ms mt mu mv b">SyntheticEvents</code>。</li></ul><p id="f115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，事件插件都有相似的结构，并以本地事件作为输入，输出一个或几个<code class="fe ms mt mu mv b">SyntheticEvents</code>，完成一系列将在稍后阶段执行的分派(函数)。<code class="fe ms mt mu mv b">SyntheticEvent</code>是一个围绕本地事件的React特定包装器，本质上与您已经习惯的浏览器事件具有相同的接口，包括<code class="fe ms mt mu mv b">stopPropagation()</code>和<code class="fe ms mt mu mv b">preventDefault()</code>(有关更多信息，关于事件的官方文档有一个专门的页面<a class="ae lt" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank">这里是</a>)。</p><h2 id="75e7" class="my lv iq bd lw mz na dn ma nb nc dp me lf nd ne mg lj nf ng mi ln nh ni mk nj bi translated">事件插件</h2><p id="3040" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">尽管有各种各样不同的事件插件，包括<code class="fe ms mt mu mv b">SimpleEventPlugin</code>(处理<code class="fe ms mt mu mv b">onClick</code>、<code class="fe ms mt mu mv b">onTouch</code>等。)和著名的<code class="fe ms mt mu mv b"><a class="ae lt" href="https://facebook.github.io/react-native/docs/gesture-responder-system.html" rel="noopener ugc nofollow" target="_blank">ResponderEventPlugin</a></code>，它们都遵循同样的模式:</p><ol class=""><li id="f8e0" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nz nr ns nt bi translated">创建一个或多个<code class="fe ms mt mu mv b">SyntheticEvent</code>以响应本机事件。</li><li id="627f" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nz nr ns nt bi translated">收集与一个<code class="fe ms mt mu mv b">SyntheticEvent</code>(例如<code class="fe ms mt mu mv b">onTouchStart={doStuff}</code>中的<code class="fe ms mt mu mv b">doStuff</code>)关联的所有派单(即编码者提供的功能)。</li><li id="7807" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nz nr ns nt bi translated">返回每个<code class="fe ms mt mu mv b">SyntheticEvent</code>及其发货。</li></ol><p id="15d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里值得注意的是<strong class="ky ir">插件</strong>中实际上没有执行任何调度，因为它只收集函数本身。(大部分时间，也就是说，一些插件确实在收集阶段执行特定的分派，但这是例外而非常态)。这些<code class="fe ms mt mu mv b">SyntheticEvent</code>可以简单地镜像本地事件(如<code class="fe ms mt mu mv b">click</code>或<code class="fe ms mt mu mv b">drag</code>)，也可以更复杂(如<code class="fe ms mt mu mv b">touchTap</code>)，但在所有情况下都会返回它们的分派数组，以便“准备好进行处理”。</p><p id="529d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了收集分派，React运行组件(无论是本机还是DOM)树的双重遍历，其中捕获和冒泡阶段从根到嵌套目标(捕获阶段)再回到根(冒泡阶段)。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oa"><img src="../Images/04fc463824c93050855d27f9023f1967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-J3yN_X5IWOqhjQ6LnqYwQ.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">双重遍历</figcaption></figure><p id="432d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，对于<em class="ls">所有</em>不同的分派(在插件本身之外执行的分派，也就是说大多数分派)，双重遍历完全发生。诸如<code class="fe ms mt mu mv b">stopPropagation()</code>之类的中断将在调度时间生效<em class="ls">，有效阻止该<code class="fe ms mt mu mv b">SyntheticEvent</code>的后续功能的执行，仅</em>(见结论)。</p><h2 id="007f" class="my lv iq bd lw mz na dn ma nb nc dp me lf nd ne mg lj nf ng mi ln nh ni mk nj bi translated"><code class="fe ms mt mu mv b">EventPluginHub</code></h2><p id="aee3" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">当应用程序启动时，所有事件插件都被注入到<code class="fe ms mt mu mv b">EventPluginHub</code>中，插件按照配置文件排序。然后，在运行时，<code class="fe ms mt mu mv b">EventPluginHub</code>将在每次收到本机事件时执行以下操作:</p><ol class=""><li id="f472" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nz nr ns nt bi translated">对于每个插件(按顺序)，收集所有的<code class="fe ms mt mu mv b">SyntheticEvents</code>和它们的调度配置，并将它们存储在队列中。</li><li id="bcc8" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nz nr ns nt bi translated">对队列中的所有事件执行所有调度，有效地清除队列。</li></ol><p id="2bbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！您的回调用正确的事件执行。:)</p><h1 id="4e6c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">后果和结论</h1><p id="867a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">这个系统的一个有趣的结果是<strong class="ky ir">一个单独的本地事件可以(并且大多数时候会)生成多个</strong> <code class="fe ms mt mu mv b"><strong class="ky ir">SyntheticEvent</strong></code> <strong class="ky ir">，每个事件的范围都被限制在创建它的插件</strong>之内。这意味着:</p><ul class=""><li id="4e63" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">只有<code class="fe ms mt mu mv b">SyntheticEvent</code>的<code class="fe ms mt mu mv b">nativeEvent</code>部分会在插件间传递，所以虽然对<code class="fe ms mt mu mv b">nativeEvent</code>的修改会影响后续插件的执行，但对<code class="fe ms mt mu mv b">SyntheticEvent</code>的修改不会。</li><li id="94e1" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">由于<code class="fe ms mt mu mv b">SyntheticEvent</code>的作用范围有限，像<code class="fe ms mt mu mv b">stopPropagation()</code>这样的调用方法只对<em class="ls">一个</em>事件插件有效。</li></ul><p id="d604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为第二点的例子，让我们想象我们有两个插件，<code class="fe ms mt mu mv b">A</code>和<code class="fe ms mt mu mv b">B</code>，分别定义合成事件<code class="fe ms mt mu mv b">eventA</code>和<code class="fe ms mt mu mv b">eventB</code>。我们将假设这些事件有以下名称:<code class="fe ms mt mu mv b">onEventA</code>和<code class="fe ms mt mu mv b">onEventB</code>用于冒泡阶段，而<code class="fe ms mt mu mv b">onEventACapture</code>和<code class="fe ms mt mu mv b">onEventBCapture</code>用于捕获阶段。最后，两者都由同一个顶级类型(比如说，<code class="fe ms mt mu mv b">topClick</code>)触发，并被排序为<code class="fe ms mt mu mv b">[A, B]</code>。现在考虑React Native中的以下代码(对于React web，只需将<code class="fe ms mt mu mv b">View</code>替换为<code class="fe ms mt mu mv b">div</code>):</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2437" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何点击事件都将首先触发对<code class="fe ms mt mu mv b">eventA</code>的捕获阶段，在嵌套组件中调用<code class="fe ms mt mu mv b">stopPropagation()</code>并有效地阻止随后的冒泡阶段。不出所料，<code class="fe ms mt mu mv b">'onEventA'</code>不会出现。然而，由于<code class="fe ms mt mu mv b">eventB</code>已经在不同的插件中定义，因此依赖于不同的<code class="fe ms mt mu mv b">SyntheticEvent</code>，<code class="fe ms mt mu mv b"><strong class="ky ir">'onEventB'</strong></code> <strong class="ky ir">将最终被打印到控制台</strong>。虽然这可以说是一个非常极端的情况，但我可以看到这可能导致意外行为的情况。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="d379" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，关于React的事件处理系统还有更多要说的，例如<code class="fe ms mt mu mv b">SyntheticEvents</code> <a class="ae lt" href="https://reactjs.org/docs/events.html#event-pooling" rel="noopener ugc nofollow" target="_blank">实际上是池化的</a>，但是为了避免矫枉过正，我在这里避免了这些。</p><p id="437b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我确实从参观代码库(遗憾的是没有太多关于这个主题的深入文档)以及观看由<a class="mw mx ep" href="https://medium.com/u/db72389e89d8?source=post_page-----71e8b5e359f2--------------------------------" rel="noopener" target="_blank">肯特·c·多兹</a>、<a class="mw mx ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----71e8b5e359f2--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a> &amp;本·阿尔珀特制作的<a class="ae lt" href="https://www.youtube.com/watch?v=dRo_egw7tBc" rel="noopener ugc nofollow" target="_blank">精彩视频</a>中学到了很多。我希望你也能学到一些东西！</p><p id="b9ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，我将继续享受观察事物如何在引擎盖下工作的乐趣…</p></div></div>    
</body>
</html>