<html>
<head>
<title>Golang Error Inspection — Handle errors programmatically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang错误检查—以编程方式处理错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-error-inspection-handle-errors-programmatically-67595035d66?source=collection_archive---------5-----------------------#2022-09-13">https://levelup.gitconnected.com/golang-error-inspection-handle-errors-programmatically-67595035d66?source=collection_archive---------5-----------------------#2022-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a2b5cc0ed1684dd7c363460a493f983d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGvk-aniYEtuS8qncXo3Hw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@hhh13?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">傅甬 华</a> on <a class="ae kf" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a> (This is just to catch your attention)</figcaption></figure><p id="9f1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Golang目前处于1.19版本(2022年9月)——该树已经重新开放用于Go 1.20开发。也就是说，Golang 2.0离发布还很遥远。然而，对于Golang 2.0，有一些有趣的设计草案目前正在社区中讨论。我已经写了一篇关于“错误处理草案设计”的小文章——如果你对Golang 2.0 <em class="le">可能</em>的发展方向感兴趣，也可以随意看看这篇文章。</p><div class="lf lg gp gr lh li"><a rel="noopener  ugc nofollow" target="_blank" href="/golang-2-0-draft-feature-error-handling-c0a2332b9162"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">Golang 2.0草图特征-错误处理</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">Golang目前的版本是1.17。本文介绍了Golang 2.0的错误处理草稿特性。</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw jz li"/></div></div></a></div><p id="066e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章是关于Golang 2.0草案的一个特性，这个特性很久以前就已经被合并到Golang树中了:错误检查。在Go 1.13中，Golang增加了改进的错误检查功能。</p><h2 id="5981" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">错误检查</h2><p id="292d" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">与<em class="le">错误处理</em>相反，错误检查是以编程方式测试错误并对错误做出反应的能力。特别是对于较大的代码库来说，这一点非常重要——我刚刚参与了一个大型代码库的单元测试编写工作，这个代码库在Go 1.13之前已经开发了好几年了——因此涉及到了大量的遗留错误处理和检查代码。目前，有四种不同的方法来检查错误:</p><p id="20ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">使用</strong> <code class="fe mv mw mx my b"><strong class="ki iu">errors.Is</strong></code> <strong class="ki iu"> </strong> <br/>检查特定的标记错误当您定义自定义错误时，您可以使用<code class="fe mv mw mx my b">errors.Is</code>检查包装错误链中的任何错误是否与目标匹配。</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="c0ed" class="lx ly it my b gy nh ni l nj nk">var MyCustomError = errors.new("Bad Input")</span><span id="902d" class="lx ly it my b gy nl ni l nj nk">[...]</span><span id="dfec" class="lx ly it my b gy nl ni l nj nk">err := someFunctionThatReturnsAnError()<br/>if errors.Is(err, MyCustomError) {<br/>    fmt.Println("Bad Input Error")<br/>}</span></pre><p id="a22c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx my b">errors.Is</code>是Go 1.13中增加的功能之一，用于改进错误检查。它遍历包装器错误链，并检查是否有任何错误与给定的目标匹配。如果您正在检查非常具体的错误，例如，如果您正在编写单元测试并且确实想要引发一个具体的错误，那么应该使用这种方法。然而接下来我最喜欢的是。</p><p id="6478" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">使用</strong> <code class="fe mv mw mx my b"><strong class="ki iu">errors.As</strong></code> <strong class="ki iu"> <br/> </strong>检查错误类型与<code class="fe mv mw mx my b">Is()</code>相反，<code class="fe mv mw mx my b">As(err error, target interface{}) bool</code>检查包装器错误链中的任何错误是否具有<em class="le">特定类型</em>而不是特定错误。</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="5253" class="lx ly it my b gy nh ni l nj nk">type CustomError struct {<br/>    msg string<br/>}</span><span id="45d0" class="lx ly it my b gy nl ni l nj nk">var MyCustomError = CustomError{msg: "Bad Input"}</span><span id="8779" class="lx ly it my b gy nl ni l nj nk">[...]<br/>err := someFunctionThatReturnsAnError()<br/>if errors.As(err, &amp;CustomError) {<br/>    fmt.Println("%s\n", err.msg)<br/>}</span></pre><p id="c9b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mv mw mx my b">errors.As</code>,您可以检查更大范围的错误。显然，为了更大的范围，你牺牲了准确性——但是我发现大多数时候这是可以的。</p><p id="aa33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">使用类似</strong> <code class="fe mv mw mx my b"><strong class="ki iu">os.IsNotExist</strong></code> <strong class="ki iu"> <br/> </strong>的检查另一种检查错误的方式是使用类似<code class="fe mv mw mx my b">os.IsNotExist</code>的功能进行特别检查。这些特别的功能用于检查特定的错误和类型，例如<code class="fe mv mw mx my b">os.IsNotExist</code>检查“ErrNotExist以及一些系统调用错误”。这已经很模糊了，再加上文件已经说这是在<code class="fe mv mw mx my b">errors.Is</code>之前——所以<strong class="ki iu">不应该再用</strong>了。</p><p id="e6d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">在</strong> <code class="fe mv mw mx my b"><strong class="ki iu">err.Error()</strong></code> <strong class="ki iu"> </strong> <br/>报告的错误文本中进行子串搜索。如果您没有定制的错误类型，这可能是广泛使用的方法，因此<code class="fe mv mw mx my b">errors.As</code>不是一个选项——或者您需要支持许多遗留代码(并且不想重写它们)——或者只是没有预先考虑错误检查(并且也不想重写它)。然而，这很可能也是最不精确的检查错误的方法，应该只是你的最后一道防线。</p><h2 id="6e94" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">资源</h2><p id="b7cc" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated"><a class="ae kf" href="https://go.googlesource.com/proposal/+/master/design/go2draft.md" rel="noopener ugc nofollow" target="_blank">https://go . Google source . com/proposal/+/master/design/go2 draft . MD</a></p></div></div>    
</body>
</html>