<html>
<head>
<title>How to build a REST API client using Feign in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Spring Boot使用Feign构建一个REST API客户端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-rest-api-client-using-feign-in-spring-boot-50db38289420?source=collection_archive---------4-----------------------#2021-03-11">https://levelup.gitconnected.com/how-to-build-rest-api-client-using-feign-in-spring-boot-50db38289420?source=collection_archive---------4-----------------------#2021-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cdfc110e87816ce4732aef17d22eda11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rTI-BTj42v1yTcoy"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·阿拉贡</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="215f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您通过API构建和公开其功能的服务必须由某个客户端使用。这个客户端可能是一个浏览器应用程序，也可能是另一个需要与您的应用程序交互的后端服务。在唯一的客户端是浏览器应用程序的情况下，您不需要做任何额外的事情来简化需要在客户端完成的工作。</p><p id="33dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，当客户端是另一种服务，并且是基于Java的服务时，那么你可以通过使用一种我们将在本文中讨论的常见技术来相当地简化客户端。</p><p id="2d4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您正在构建一个API，它允许您使用一个公共类— <code class="fe le lf lg lh b">FileMetadata</code>来加载和存储文件。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="5752" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们公开一个<code class="fe le lf lg lh b">FileApi</code>，它有一些使用注释定义的端点，最终目标是让客户端能够调用这个API，就像说<code class="fe le lf lg lh b">FileApi.getFile()</code>一样简单。</p><p id="c792" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对服务器的HTTP调用以及一些重试逻辑将从客户端抽象出来。</p><p id="554f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果服务器端的任何端点发生变化，客户端会在<strong class="ki iu">编译时</strong>而不是在<strong class="ki iu">运行时</strong>意识到这一点。</p><p id="bfbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们将在客户端和服务器端使用一个流行的库，名为<a class="ae kf" href="https://github.com/OpenFeign/feign" rel="noopener ugc nofollow" target="_blank"> Feign </a>。</p><blockquote class="lo lp lq"><p id="2596" class="kg kh lr ki b kj kk kl km kn ko kp kq ls ks kt ku lt kw kx ky lu la lb lc ld im bi translated">此外，我们可以有选择地组织<strong class="ki iu">服务器</strong>项目，当它被构建时，产生2个jar文件——一个包含所有的服务数据，另一个只包含API定义。这样，客户机将只依赖于第二个带有API定义的jar文件，而第一个jar将用于运行服务器。这可以通过在您的服务器项目中引入一个子项目来实现，这个子项目可以包含所有的API定义。</p></blockquote><p id="7fa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以将项目作为一个单独的jar来构建和运行，但是因为客户端需要加载整个jar来定义API，所以不鼓励这样做。</p><p id="c031" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，无论使用哪种方式，当您更新服务器的API时，您都需要同时发布服务器和客户端，以防出现重大更改。但是，当您将客户机设置为使用最新的服务器jar时，如果对新更新的API的调用没有更新，客户机应用程序就不会构建。</p><p id="eb59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们在编译时发现并解决问题，如果可能的话，这总是首选。</p><p id="84eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图给出了上述整个流程的概述。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/62b8b4676a5bf4538264f54c3059c896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKMvqf8ZvlJMej9dVRiwQw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">数据流动</figcaption></figure><h2 id="7a47" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">假装入门</h2><p id="a689" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">Feign是一个库，允许你声明性地访问不同的API。它使用关于构建API的<code class="fe le lf lg lh b">JAX-RS</code>规范中指定的注释工作。</p><p id="969e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">JAX-RS</code>只是一个用Java实现REST web服务的规范。它带有一些定义好的注释，如<code class="fe le lf lg lh b"><a class="ae kf" href="http://twitter.com/Path" rel="noopener ugc nofollow" target="_blank">@Path</a></code>、<code class="fe le lf lg lh b"><a class="ae kf" href="http://twitter.com/GET" rel="noopener ugc nofollow" target="_blank">@GET</a></code>、<code class="fe le lf lg lh b"><a class="ae kf" href="http://twitter.com/POST" rel="noopener ugc nofollow" target="_blank">@POST</a></code>等。，这与我们在构建弹簧控制器时看到的类似。<code class="fe le lf lg lh b">JAX-RS</code>有几个实现，其中之一是<code class="fe le lf lg lh b">Jersey</code>——一个构建REST APIs的框架。</p><p id="de27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，我们使用Spring Boot，它自带了构建REST APIs的规范(Spring MVC注释，如<code class="fe le lf lg lh b"><a class="ae kf" href="http://twitter.com/RequestMapping" rel="noopener ugc nofollow" target="_blank">@RequestMapping</a></code>、<code class="fe le lf lg lh b"><a class="ae kf" href="http://twitter.com/GetMapping" rel="noopener ugc nofollow" target="_blank">@GetMapping</a></code>、<code class="fe le lf lg lh b"><a class="ae kf" href="http://twitter.com/PostMapping" rel="noopener ugc nofollow" target="_blank">@PostMapping</a></code>、<code class="fe le lf lg lh b"><a class="ae kf" href="http://twitter.com/PathVariable" rel="noopener ugc nofollow" target="_blank">@PathVariable</a></code>等)。).所以为了使用Feign和定义API，我们将使用<code class="fe le lf lg lh b">spring-cloud-starter-openfeign</code>库，它提供了对Spring MVC注释的支持。</p><p id="e089" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要将这个依赖项和<code class="fe le lf lg lh b">spring-cloud-dependencies</code>一起添加到我们的项目中，如下所示:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="bfd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们能够使用Feign之前，我们需要修改我们以前定义的API，用使用的Spring MVC注释定义一个接口，然后注册一个实现该接口的bean，如下面的代码所示。</p><p id="0fc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们必须确保<code class="fe le lf lg lh b">FileController</code>将在Spring中注册为控制器bean，因此我们必须使用<code class="fe le lf lg lh b"><a class="ae kf" href="http://twitter.com/RestController" rel="noopener ugc nofollow" target="_blank">@RestController</a>()</code>注释该类。下面的两个代码片段演示了这一点。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="84b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据这一变化，我们仍然可以使用Postman或另一个客户端来使用API。</p><p id="f5b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不同之处在于，我们现在提取了一个带有API规范的接口，Feign可以使用它。现在您知道了，Feign允许您通过简单地指定一个接口并使用<code class="fe le lf lg lh b">JAX-RS</code>注释(在我们的例子中是Spring MVC注释，因为我们添加了<code class="fe le lf lg lh b">spring-cloud-starter-openfeign</code>依赖项)来构建声明式客户端。</p><p id="b70d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构建假后台API非常简单，如下面的代码所示。这个方法将是一个工厂类的一部分，这个工厂类可以是服务器API子项目的一部分，但是我们将在一分钟后讨论它。</p><ol class=""><li id="d033" class="mu mv it ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated">它需要服务的URL，如下所示静态地指定它并不是一个好主意，相反，您应该通过一个环境变量传递该URL。为了简单起见，它是静态定义的。</li><li id="ef5a" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">为了让Feign识别Spring MVC注释，您必须指定要使用的契约为<code class="fe le lf lg lh b">SpringMvcContract</code>。</li><li id="e1ec" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">指定的目标是您之前定义的实际接口。</li></ol><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><h2 id="0959" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">编码器和解码器</h2><p id="1f51" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">这个简单的假装配置不允许您发送类型安全的请求体，也不完全允许您检索类型安全的响应。</p><p id="2d9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果服务器有一个预定义的POJO作为要反序列化的请求体结构，或者当服务器返回一个POJO作为响应时，您可能会遇到序列化和反序列化问题。</p><p id="542e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，我们使用了一个<code class="fe le lf lg lh b">FileMetadata</code>类，它也使用了<code class="fe le lf lg lh b">LocalDateTime</code>。序列化&amp;反序列化<code class="fe le lf lg lh b">LocalDateTime</code>需要特别小心。由于这个原因，我们必须指导Feign如何处理这个问题。我们通过指定额外的配置来做到这一点— <strong class="ki iu">编码器&amp;解码器</strong>。</p><p id="c9ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用Jackson来处理序列化和反序列化，所以我们可以通过指定一个自定义的<code class="fe le lf lg lh b">ObjectMapper</code>来使用<code class="fe le lf lg lh b">feign.jackson.JacksonEncoder</code>和<code class="fe le lf lg lh b">feign.jackson.JacksonDecoder</code>。</p><p id="d430" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为在我们的应用程序中我们有自定义的日期格式，我们需要定义自定义的<code class="fe le lf lg lh b">LocalDateTimeSerializer</code>和<code class="fe le lf lg lh b">LocalDateTimeDeerializer</code>来处理特定的日期格式，将它们注册到自定义的<code class="fe le lf lg lh b">Module</code>中，并将其添加到自定义的<code class="fe le lf lg lh b">ObjectMapper</code>中，如下所示。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><h2 id="1aa5" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">同步和异步API调用</h2><p id="6b2e" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我们通过Feign定义的API是同步的——这意味着它阻塞了对服务器的调用。Feign还允许我们轻松地定义异步APIs利用幕后的<code class="fe le lf lg lh b">CompletableFutures</code>。</p><p id="2f2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们需要为我们的<code class="fe le lf lg lh b">FilesAPI</code>定义另一个接口，它将返回<code class="fe le lf lg lh b">CompletableFutures</code>，并使用上述方法将其绑定为异步FeignAPI。</p><p id="8492" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Feign库提供了<code class="fe le lf lg lh b">AsyncFeign</code>，我们可以像使用<code class="fe le lf lg lh b">Feign</code>构造一样使用它。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="52e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在服务器的子项目中定义了所有这些之后，您就可以发布jar并在客户端代码中使用它了。</p><p id="647a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码展示了一个简单的客户端应用程序，它依赖于服务器API的已发布jar。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="1aa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来API是客户端中的某个类，我们正在调用这个类。</p><p id="2642" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假装让它变得如此简单！</p><p id="45bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，希望这篇文章对您有用。</p><p id="3e32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当心</p></div></div>    
</body>
</html>