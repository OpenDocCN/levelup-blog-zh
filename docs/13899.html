<html>
<head>
<title>What to Return from Repositories: IQueryable, IEnumerable or IReadOnlyList?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从存储库返回什么:IQueryable、IEnumerable或IReadOnlyList？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-to-return-from-repositories-iqueryable-ienumerable-or-ireadonlylist-91c0647fe5e1?source=collection_archive---------0-----------------------#2022-10-16">https://levelup.gitconnected.com/what-to-return-from-repositories-iqueryable-ienumerable-or-ireadonlylist-91c0647fe5e1?source=collection_archive---------0-----------------------#2022-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在项目中构建健壮的数据访问层。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/650e95054d43675050494d024abc43f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WutbfpDsYg0X6Ky2"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/es/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在存储库中实现get方法时，它应该返回一组域对象(<code class="fe lv lw lx ly b">GetUsers, GetProducts, GetWhatever</code>)，开发人员可以在几种返回类型之间进行选择:</p><ul class=""><li id="6ce6" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code></li><li id="54fd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code></li><li id="6bb4" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">IReadOnlyList&lt;T&gt;</code>或任何其他物化集合。</li></ul><p id="b581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择这些返回类型之一会影响应用程序的性能、设计和可维护性。因此，有意识的选择是在项目中创建健壮的数据访问层的重要部分。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="241f" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">示例定义</h2><p id="f181" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们需要定义一个简单的领域模型，<code class="fe lv lw lx ly b">DbContext</code>实现，并在进入本文主题之前播种一些简单的数据。</p><p id="c661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是代码(我用的是实体框架6):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了上面的代码，首先我们可以开始分析作为存储库get方法的返回类型的<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="aacd" class="nu mv it bd mw nv nw nx mz ny nz oa nc jz ob ka nf kc oc kd ni kf od kg nl oe bi translated">IQueryable <t>返回类型</t></h1><p id="12bc" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口允许您将C#表达式转换成T-SQL查询，以便直接在数据库端执行。</p><p id="bfbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个简单的用户存储库，为其消费者提供一个<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您从存储库方法返回<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>类型时，每个域服务或其他消费者可以对其应用必要的过滤器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe lv lw lx ly b">SendNotifications</code>方法的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/c0b12198adbe48c87825689ae052d07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5m6M9GBRwYoApyk10bmMA.png"/></div></div></figure><p id="b587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几件需要注意的事情:</p><ul class=""><li id="8bd4" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">只有在实际请求结果时，才执行对数据库的查询(只有在调用<code class="fe lv lw lx ly b">Count()</code>方法时，而不是<code class="fe lv lw lx ly b">GetUsers()</code>)。</li><li id="6405" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">SQL查询包含<code class="fe lv lw lx ly b">IsActive</code>标志，这意味着当表达式被添加到<code class="fe lv lw lx ly b">IQueryable&lt;User&gt;</code>对象时，最终查询被构造。</li><li id="16c3" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">存储库不需要定义任何其他get方法，比如<code class="fe lv lw lx ly b">GetInactiveUsers</code>或<code class="fe lv lw lx ly b">GetUserByEmail.</code><code class="fe lv lw lx ly b">IUsersRepository</code>的消费者可以自己构建任何查询。</li></ul><p id="0f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当在一个大项目中从您的存储库中公开一个<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口时，会出现许多问题:</p><h2 id="26bf" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">1.重复的域规则</h2><p id="a15f" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">向活动用户发送通知是在<code class="fe lv lw lx ly b">SendNotifications</code>方法中实现的业务规则。</p><p id="2b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，真实的系统将有几十个与活跃用户相关的规则在不同的域服务中实现。例如，另一个域服务可以为每个活跃用户提供折扣。</p><p id="0d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是明天需求可能会改变。例如，企业可能决定不为系统的所有活跃用户发送通知并给予折扣，而只为一年前注册的活跃用户提供折扣。</p><p id="1ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>的实现，开发者将不得不进入每一个与活跃用户打交道的域服务，并由此修改代码</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="e313" class="mu mv it ly b gy ok ol l om on">var activeUsersCount = <em class="oo">users<br/>    .Where(user =&gt; user.IsActive)<br/>    .Count();</em></span></pre><p id="bfd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="4da0" class="mu mv it ly b gy ok ol l om on">var minusYearDate = DateTime.UtcNow.AddYears(-1);</span><span id="16d4" class="mu mv it ly b gy op ol l om on">var activeUsersCount = users<br/>    .Where(user =&gt; user.IsActive <strong class="ly iu">&amp;&amp;</strong> <strong class="ly iu">user.CreatedAt &lt; minusYearDate</strong>)<br/>    .Count();</span></pre><p id="e4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，代码库变得更加难以维护，因为有几个地方需要更新，而且很容易遗漏一些东西。</p><h2 id="16a3" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">2.数据访问细节泄露到域层</h2><p id="8c80" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>从存储库中公开时，消费者不能使用他们习惯的所有LINQ表达式，因为不是每个表达式都可以转换成T-SQL查询。例如，试图在<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>类型上执行简单的<code class="fe lv lw lx ly b">LastOrDefault</code>方法将导致运行时异常:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="ec01" class="mu mv it ly b gy ok ol l om on">Console.WriteLine("Executing GetUsers()...");</span><span id="067c" class="mu mv it ly b gy op ol l om on">User user = _usersRepository.GetUsers().<strong class="ly iu">LastOrDefault()</strong>;</span></pre><p id="68e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/a1864950dff6b162a1d627650be8ebec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*grlUaC3PKF6s1W4d13uBEw.png"/></div></div></figure><p id="4f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，T-SQL不包含从表中读取最后一行的特殊语句。最后一行只能使用定制的T-SQL代码进行检索，该代码必须按照主键对表记录进行降序排序，然后对排序后的集合应用<code class="fe lv lw lx ly b">TOP (1)</code>操作符。这就是标准的<code class="fe lv lw lx ly b">LastOrDefault</code>实现抛出<code class="fe lv lw lx ly b">NotSupportedException.</code>的原因</p><p id="a663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，执行<code class="fe lv lw lx ly b">FirstOrDefault</code>方法将会成功，因为它可以很容易地转换成标准的<code class="fe lv lw lx ly b">SELECT TOP (1)…</code> T-SQL查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/cf4ed56b47fc4b4077ccc180bf90b4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5M6Qvg4H7Maz6W8fp8Ykig.png"/></div></div></figure><p id="2fa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有许多其他的LINQ语句不能编译成T-SQL。因此，使用<code class="fe lv lw lx ly b">IQueryable</code>存储库的域服务需要知道哪些语句可以转换成T-SQL并在数据库端执行，哪些不能。他们应该知道实现<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口的数据库提供者的实现细节。<strong class="lb iu">但事实上，这一切都不应该是域服务</strong>所关心的。</p><h2 id="d048" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">3.从IQueryable <t>到IEnumerable <t>的隐式转换</t></t></h2><p id="7589" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口继承自<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>。因此，从<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>到<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>的隐式转换是可能的，这会导致意外的数据库调用。</p><p id="4e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设代码库中有一个简单的助手扩展方法:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="fdad" class="mu mv it ly b gy ok ol l om on">public static IEnumerable&lt;T&gt; WhereNotNull&lt;T&gt;(<br/>    this IEnumerable&lt;T&gt; items) <br/>{     <br/>    return items.Where(x =&gt; x != null); <br/>}</span></pre><p id="02ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>类型上可以无意识地调用<code class="fe lv lw lx ly b">WhereNotNull</code>扩展方法:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="4d7f" class="mu mv it ly b gy ok ol l om on">IQueryable&lt;User&gt; users = _usersRepository.GetUsers();</span><span id="3cf0" class="mu mv it ly b gy op ol l om on">var notNullUsersCount = users.<strong class="ly iu">WhereNotNull()</strong>.Count();</span></pre><p id="e488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的代码将在开始用<code class="fe lv lw lx ly b">WhereNotNull</code>方法执行内存过滤之前从数据库加载所有用户。这可能会导致系统性能意外下降。</p><h2 id="93ce" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">4.冗余数据库调用</h2><p id="4597" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">存储库的消费者应该记得具体化结果，以避免意外的数据库查询。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="127a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上述代码将导致两次数据库调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/29d6445aac0e70a12c62c0c4b3b06e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hd1ADBuCelu3FLyDUvf4g.png"/></div></div></figure><p id="8901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，通过在一次数据库调用中将更多数据加载到内存中，可以很容易地解决这个问题，因此所有后续的过滤都将只在内存中进行:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="623b" class="mu mv it ly b gy ok ol l om on">IEnumerable&lt;User&gt; users = _usersRepository.GetUsers()<strong class="ly iu">.ToList()</strong>;</span></pre><p id="19d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这样的事情在大项目中很容易被忽略。因此，由许多数据库调用引起的性能问题会经常发生。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="53a9" class="nu mv it bd mw nv nw nx mz ny nz oa nc jz ob ka nf kc oc kd ni kf od kg nl oe bi translated">IEnumerable <t>返回类型</t></h1><p id="c165" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>接口是一个标准。NET接口，该接口允许您循环访问元素集合。它是<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口的另一种替代，作为存储库get方法的返回类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0e1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们试着通过简单地切换到<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>接口来理解对于存储库消费者来说有哪些<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>问题得到了解决:</p><h2 id="3ba2" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">1.重复的域规则仍然是一个问题吗？</h2><p id="71b7" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>存储库方法的域服务仍然可以获得<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>集合，然后应用必要的过滤器，就像使用<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>一样。</p><p id="f936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，应用于<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>集合的过滤器不会被转换成T-SQL查询。过滤将在内存中进行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="82c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/0884f5fd84158f5bb711bba4232609b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXRt6zCMKGgHtxUJep04JQ.png"/></div></div></figure><p id="6199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，T-SQL查询中没有<code class="fe lv lw lx ly b">IsActive</code>过滤器，就像在<code class="fe lv lw lx ly b">IQueryable</code>示例中一样。</p><p id="cf77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这如何解决域规则重复的问题呢？</p><p id="5372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中以<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>的方式使用<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>接口会从表中加载大量冗余数据，导致性能问题。在我们的例子中，表中的所有用户都将被加载到内存中，尽管只需要活动用户。</p><p id="90e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免这种性能问题的常见方法是在存储库方法中封装过滤器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="45ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe lv lw lx ly b">GetActiveUsers</code>方法的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/68380fdf2c713d7811ce0b74101bca19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJiU3bP8WTlVZXG5n18QXw.png"/></div></div></figure><p id="636a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在域服务或其他消费者不需要执行任何过滤，只需要从存储库中调用<code class="fe lv lw lx ly b">GetActiveUsers</code>方法，这将使用<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口创建一个高效的T-SQL查询。</p><p id="6863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于活动用户的意思的知识仅包含在<code class="fe lv lw lx ly b">GetActiveUsers</code>方法中。更改需求只会导致更新该方法中的代码。这提高了系统的可维护性。</p><h2 id="e7c0" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">2.数据访问细节是否仍然被泄露到域级别？</h2><p id="49bd" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这个问题不再与<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>接口相关。在上面的例子中，只有存储库处理<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口。域服务或存储库的其他消费者不再知道<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>，而只是在内存收集中处理<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>。</p><h2 id="5d86" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">3.从IQueryable <t>到IEnumerable <t>的隐式转换？</t></t></h2><p id="394e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">对于存储库消费者来说，这不再是一个问题。</p><h2 id="f336" class="mu mv it bd mw mx my dn mz na nb dp nc li nd ne nf lm ng nh ni lq nj nk nl nm bi translated">4.冗余的数据库调用怎么办？</h2><p id="f32b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">从存储库中公开一个<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>仍然会导致意外的数据库调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/9ee597d08b335fc89b2d4e330b69dd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gt0vPWfuGLD9M90KKjIcBw.png"/></div></div></figure><p id="ce7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您从profiler结果中看到的，忘记及时物化一个<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>集合<em class="oo">(例如，通过在第2行调用</em> <code class="fe lv lw lx ly b"><em class="oo">ToList</em></code> <em class="oo">方法)</em>会导致多次从数据库表中加载大量数据。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6bf6" class="nu mv it bd mw nv nw nx mz ny nz oa nc jz ob ka nf kc oc kd ni kf od kg nl oe bi translated">IReadOnlyList <t>返回类型</t></h1><p id="2623" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">除了与冗余数据库调用相关的性能风险，返回一个<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>并不总是一个好的设计决策。</p><p id="a2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>接口由许多人实现。NET collections提供了非常有限的功能——向前迭代元素集合。然而，有时存储库消费者可能需要其他功能，比如通过索引或键访问元素。</p><p id="1be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，任何从存储库中获得<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>集合的人都可以将其转换成任何其他需要的类型——列表、数组、字典等。</p><p id="e035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是请这样想:从项目中的每个方法返回<code class="fe lv lw lx ly b">object</code>类型，而不是返回更具体的类型，如<code class="fe lv lw lx ly b">int</code>、<code class="fe lv lw lx ly b">string</code>等等，这样可以吗？从技术上讲这是可能的，因为<code class="fe lv lw lx ly b">object</code>是。NET，但至少会导致:</p><ul class=""><li id="a244" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">由于相同的方法签名，降低了代码的可读性。</li><li id="e3db" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">由于大量的类型转换降低了系统性能。</li></ul><p id="ec88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当总是从每个存储库get方法返回<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>接口时，也会出现同样的问题。所以应该返回一个更具体的类型，可以是<code class="fe lv lw lx ly b">IReadOnlyList&lt;T&gt;</code>接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="907e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们通过从存储库中返回一个<code class="fe lv lw lx ly b">IReadOnlyList&lt;User&gt;</code>(或任何其他物化集合)来实现什么呢？</p><ul class=""><li id="3bb7" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">对存储库get方法的一次调用将总是导致一次数据库调用。消费者不需要记住物化结果，因为存储库现在负责物化它们。</li><li id="2f3f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>接口和相关代码封装在存储库中。它消除了存储库消费者的复杂性，因为他们只处理常规的。净收藏。</li><li id="101f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">存储库将最具体的类型返回给消费者，因此他们不需要强制转换返回的结果。此外，从方法中返回最具体的类型有助于获得清晰的方法签名。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b377" class="nu mv it bd mw nv nw nx mz ny nz oa nc jz ob ka nf kc oc kd ni kf od kg nl oe bi translated">摘要</h1><p id="a5e3" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">关键要点:</p><ul class=""><li id="06ad" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">从存储库中返回最具体的物化集合，以避免潜在的性能和设计问题。</li><li id="9355" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">避免从存储库中暴露<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>类型。然而，在存储库中使用<code class="fe lv lw lx ly b">IQueryable&lt;T&gt;</code>类型有助于构建好的查询。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="f369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="ow ox gp gr oy oz"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-implement-repository-pattern-in-c-e12565e4d4a2"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">C#中五大存储库模式实现的比较</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">一个成熟的软件工程师通常知道解决同一个编程问题的几种方法，并做出选择…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ks oz"/></div></div></a></div><p id="5005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以考虑订阅我的电报频道<a class="ae ky" href="https://t.me/sd_daily" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">软件开发日报</strong> </a>从我这里获取更多内容。</p><p id="ddac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，考虑成为<a class="ae ky" href="https://esashamathews.medium.com/membership" rel="noopener">中等会员</a>。</p></div></div>    
</body>
</html>