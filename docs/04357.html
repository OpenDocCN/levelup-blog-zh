<html>
<head>
<title>Recursion: Tackling a Tricky Concept</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归:处理一个棘手的概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tackling-the-tricky-concept-of-recursion-d8608817f520?source=collection_archive---------17-----------------------#2020-06-22">https://levelup.gitconnected.com/tackling-the-tricky-concept-of-recursion-d8608817f520?source=collection_archive---------17-----------------------#2020-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f42e3d2c231464158ae4d5b29ee1b5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4jj7BKtr0b4d5l9pQvnhw.png"/></div></div></figure><p id="ef11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">对一些人来说，货币兑换可能是一个棘手的话题，但是一旦你得到了它，你就会得到<strong class="ka ir"><em class="lf"/></strong>它。在本文中，我将简要介绍什么是递归，它是如何工作的，以及为什么它很重要。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="af72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我第一次了解递归的概念时，我很纠结。我想:“对我来说，学习编写函数的细节已经够难的了，现在你要我在函数内部编写函数？”对我来说，这是一个很难理解的概念，但就像软件工程中的许多其他事情一样，一旦它成功了，它就成功了。</p><p id="59c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们开始解释和举例之前，让我们简单地讨论一下什么是递归，以及为什么你应该关注递归。</p><blockquote class="ln"><p id="90f1" class="lo lp iq bd lq lr ls lt lu lv lw kv dk translated">对于一些人来说，递归可能是一个难以理解的话题，但是一旦你理解了，你就明白了。</p></blockquote></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="7405" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">到底什么是递归？</h1><p id="c5e6" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">本质上，递归是一个调用自身的过程。在本文中，我们将在JavaScript函数的上下文中探索这个概念。</p><p id="3c51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以这种方式调用函数有几个不同的原因。有时它使事情变得简单，有时它使事情变得不必要的复杂，但是在它使事情变得简单的情况下，知道如何实现是非常重要的。</p><p id="be39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速回顾一下递归重要的一些原因，以及你可能会发现它有用的上下文。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="86f0" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">为什么递归很重要？</h1><p id="cc56" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">递归对于<strong class="ka ir">很重要，原因有多种:</strong></p><h2 id="635f" class="na ly iq bd lz nb nc dn md nd ne dp mh kj nf ng ml kn nh ni mp kr nj nk mt nl bi translated">DOM遍历算法</h2><p id="c542" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">DOM可以被看作一个树状结构。这棵树有许多分支，每个分支又有许多分支，如此循环往复。(想象一下div中的div…)。当使用递归函数时，遍历这样的复杂对象会变得更容易/更快。</p><h2 id="5647" class="na ly iq bd lz nb nc dn md nd ne dp mh kj nf ng ml kn nh ni mp kr nj nk mt nl bi translated">对象遍历</h2><p id="7a68" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">与上面的观点类似，对象本身可以变得非常复杂，并且有大量的数据相互嵌套。递归使得访问这些数据更容易/更快。</p><h2 id="93a6" class="na ly iq bd lz nb nc dn md nd ne dp mh kj nf ng ml kn nh ni mp kr nj nk mt nl bi translated">从复杂的数据结构中访问数据</h2><p id="c9b6" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">遍历涉及树或图的结构(或搜索数据)通常涉及利用递归的解决方案。</p><h2 id="a4a2" class="na ly iq bd lz nb nc dn md nd ne dp mh kj nf ng ml kn nh ni mp kr nj nk mt nl bi translated">有时一个更干净、更简单的迭代替代方案</h2><p id="d768" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">并不总是这样，但有时递归为通常涉及迭代的问题提供了一个更简单的解决方案(这将在后面的例子中变得更清楚)。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="d475" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用递归的主要规则和常见错误。</h1><p id="4998" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">当使用递归时，有几个常见的错误会导致你的函数失控。</p><h2 id="896e" class="na ly iq bd lz nb nc dn md nd ne dp mh kj nf ng ml kn nh ni mp kr nj nk mt nl bi translated">规则1:递归函数需要一个端点</h2><p id="5fed" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">就像“while”循环需要有一个停止的地方一样，递归函数需要有一个“基本情况”。递归的第一个主要规则是<strong class="ka ir">需要有一个端点。</strong>否则，函数不知道什么时候停止，它将永远继续下去(准确地说是无限)，创建一个无限循环。</p><h2 id="37b0" class="na ly iq bd lz nb nc dn md nd ne dp mh kj nf ng ml kn nh ni mp kr nj nk mt nl bi translated">规则2:递归函数在递归调用时需要不同的输入</h2><p id="ac79" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">请这样想:如果一个函数在它自己内部被调用，而函数的输入没有改变，那么这个函数会一次又一次地在同一个输入上被调用，并且没有办法到达一个端点。这将我们引向一个类似无限循环的情况，类似于上面提到的情况。</p><blockquote class="ln"><p id="1330" class="lo lp iq bd lq lr ls lt lu lv lw kv dk translated">递归的第一个主要规则是需要有一个端点。递归的第二个主要规则是，每次调用时它们需要不同的输入。</p></blockquote></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="413f" class="na ly iq bd lz nb nc dn md nd ne dp mh kj nf ng ml kn nh ni mp kr nj nk mt nl bi translated">示例#1:</h2><p id="4a77" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated"><strong class="ka ir">让我们编写一个简单的递归函数，它接受一个整数，每次通过时将该整数减1，并在控制台中记录每个数字。</strong></p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6928" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能发现“基本情况”吗？每次通过的输入差异怎么样？</p><p id="9d2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们先来谈谈基地的情况。</strong>记住，需要一个基础案例来给功能一个停止的地方。这通常包括一个条件语句，后面跟着一个返回，就像我们在函数开头的‘if’语句中看到的那样。如果不在这里，我们的函数将无处可停，将继续记录超过0的数字，进入负数，并被遗忘，直到超过最大调用堆栈大小。</p><p id="1377" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">接下来，让我们看看每次通过时的不同输入。</strong>在我们console.log我们的“num”之后，我们可以看到这个整数减1，然后我们的函数在这个新的数字上再次被调用。这也防止了无限循环类型的情况，因为如果我们每次都没有不同的数字，我们的函数将不断地在相同的数字上调用自己，直到像上面一样，超过了最大调用堆栈大小。</p><h2 id="7b65" class="na ly iq bd lz nb nc dn md nd ne dp mh kj nf ng ml kn nh ni mp kr nj nk mt nl bi translated">示例2:</h2><p id="1dd1" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated"><strong class="ka ir">这是一个经典的递归函数，它接受一个整数，并求出给定整数的阶乘。(对于那些需要复习阶乘是什么的人来说，一个例子是“3！”。我不是在这里喊3。意思是3 * 2 * 1。)</strong></p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6f3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">再次尝试找出“基本情况”,以及输入的变化！</strong></p><p id="7908" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的基本情况是，再次，在函数的开始，我们指定一个带有返回值的条件。在这种情况下，我们需要确保函数停止在1，这样它:a .)不会继续超过1而被遗忘，b .)不会让我们最终乘以0，c .)允许乘法本身在“阶乘”被调用“num”次后发生。</p><p id="e657" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们详细阐述一下最后一点。一旦<code class="fe ns nt nu nv b">factorial</code>被一遍又一遍地调用，直到它返回1，它实际上仍然没有产生任何其他整数。这意味着我们被调用的递归函数一直“等待”到1，然后它们开始执行我们一直在等待的乘法运算。有道理吗？换句话说，现在每个被调用的<code class="fe ns nt nu nv b">factorial(num — 1)</code>都有一个实际值(一个整数)供前面的<code class="fe ns nt nu nv b">num</code>相乘。</p><p id="0f8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住，每次调用递归函数时都有不同的输入也很重要。在这种情况下，当我们从“num”中减去1时，这发生在函数调用本身的输入中。这意味着每次调用我们的函数时，它都有一个新的输入。这种模式每次都在继续，直到我们的输入为1，然后我们爆发。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="ff69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你对什么是递归，为什么递归很重要，什么时候有用，递归函数的经典陷阱/规则有了一个大致的了解，并且看了几个例子。</p><p id="98c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">一个小提示:</strong>你可能听说过“助手方法递归”，这在本文中没有提到。这也是一个重要的主题，但是，由于递归本身就很难深入研究，所以我决定把这篇文章写得轻松一些，这样它就可以是一个不错的介绍，不会让人不知所措。我们改天再谈那个话题！</p><p id="2879" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><div class="nm nn no np gt nw"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">编写面试问题</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">技术开发</p></div></div><div class="of l"><div class="og l oh oi oj of ok jw nw"/></div></div></a></div></div></div>    
</body>
</html>