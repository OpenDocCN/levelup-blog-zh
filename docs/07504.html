<html>
<head>
<title>JavaScript Call Stack Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了JavaScript调用堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-call-stack-explained-a6e0ae1574be?source=collection_archive---------18-----------------------#2021-02-22">https://levelup.gitconnected.com/javascript-call-stack-explained-a6e0ae1574be?source=collection_archive---------18-----------------------#2021-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="69c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript的调用栈、事件循环和事件队列介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/71388486bfef0517d255faeef3488a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J0kXP_fkaKLt3jJE"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@kellbork?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Bork </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8275" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是调用栈？</h1><blockquote class="lo lp lq"><p id="e1ba" class="lr ls lt lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated"><strong class="lu ir">调用栈</strong>是一种解释器(就像web浏览器中的JavaScript解释器)跟踪其在调用多个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Function" rel="noopener ugc nofollow" target="_blank">函数</a>的脚本中的位置的机制——当前正在运行什么函数，以及从该函数中调用了什么函数，等等。— <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="6653" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated"><strong class="lu ir">调用栈</strong>跟踪要执行的函数。当我们调用一个函数时，它被添加，或者说<em class="lt">将</em>推到调用堆栈的顶部。当函数返回时，它被移除，或者说<em class="lt">从调用堆栈中弹出</em>。任何异步函数(<code class="fe mr ms mt mu b">fetch</code>、<code class="fe mr ms mt mu b">setTimeout</code>、<code class="fe mr ms mt mu b">async</code>等)。)被移动到<strong class="lu ir">事件队列</strong>(稍后将详细介绍)。</p><p id="b5e6" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">很可能，当抛出错误时，您已经在控制台中看到了调用堆栈。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/d8270bc3458bc785bedd635c744f6aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*VfDw3zl_pBlEaEvuEw15KQ.png"/></div></figure><p id="5449" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">从上图中，我们可以看到调用栈(a，b，c)的当前状态以及错误发生的时间。</p><h1 id="725e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">调用栈是如何工作的？</h1><p id="cfd3" class="pw-post-body-paragraph lr ls iq lu b lv mw jr lx ly mx ju ma mo my md me mp mz mh mi mq na ml mm mn ij bi translated">你可能听说过JavaScript是单线程的。这意味着它只有一个调用堆栈，并且一次只能处理一条语句。调用堆栈遵循LIFO(后进先出)原则，这意味着它总是首先处理堆栈顶部的调用。</p><p id="6feb" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">当一个函数被调用时，它被添加到堆栈中。当一个函数调用另一个函数时，它被添加到调用函数之上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/53ae7d741ea3a9371131a509f1b21638.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*jqXatjSzbcVQV-fxm6F7eA.png"/></div></figure><p id="9d8c" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">给定上面的代码块，我们可以断言:</p><ol class=""><li id="434e" class="nc nd iq lu b lv lw ly lz mo ne mp nf mq ng mn nh ni nj nk bi translated">首先，<code class="fe mr ms mt mu b">sayHi</code>被调用，<em class="lt">将</em>添加到调用堆栈中(<code class="fe mr ms mt mu b">sayHi</code>尚未解决)。</li><li id="d8cf" class="nc nd iq lu b lv nl ly nm mo nn mp no mq np mn nh ni nj nk bi translated"><code class="fe mr ms mt mu b">sayHi</code>然后调用<code class="fe mr ms mt mu b">sayBye</code>并且<em class="lt">将</em> <code class="fe mr ms mt mu b">sayBye</code>添加到调用堆栈中(两个函数仍然未解决)。</li><li id="d763" class="nc nd iq lu b lv nl ly nm mo nn mp no mq np mn nh ni nj nk bi translated">此时，调用堆栈状态当前为:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4b7225ce82416a93c06bc5d77f161b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*msd99sgOp9pBDGs2ia9jMg.jpeg"/></div></figure><p id="86ac" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">4.<code class="fe mr ms mt mu b">sayBye</code>现在位于调用堆栈的顶部。它将执行并打印出“再见”到控制台。然后，将它从调用堆栈的顶部移除。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/da6a795c22248a669e1995d0ad084a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*yrjWgvYCQzGJciWMaaG_7w.jpeg"/></div></figure><p id="cfe6" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">5.现在，<code class="fe mr ms mt mu b">sayHi</code>位于调用堆栈的顶部。它将在控制台上打印出“Hi ”,然后从调用堆栈中移除。调用堆栈现在是空的。</p><p id="d44c" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">6.最终输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1c4fc45551e861d62085f0beafc9a3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*Xbcd1pk4xuUksHdgh_sbsg.png"/></div></figure><h1 id="7db2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">事件循环是如何工作的？</h1><p id="14ce" class="pw-post-body-paragraph lr ls iq lu b lv mw jr lx ly mx ju ma mo my md me mp mz mh mi mq na ml mm mn ij bi translated">当调用异步函数时，它不会进入调用堆栈。相反，它被转发到<strong class="lu ir">事件队列</strong>。调用堆栈和事件队列之间的连接通过<strong class="lu ir">事件循环</strong>实现。事件循环不断检查调用堆栈。如果调用堆栈为空，它会将事件队列中的第一个函数添加到调用堆栈中以供执行。否则，它继续处理调用堆栈中的代码。</p><h1 id="e681" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是事件队列？</h1><p id="43fc" class="pw-post-body-paragraph lr ls iq lu b lv mw jr lx ly mx ju ma mo my md me mp mz mh mi mq na ml mm mn ij bi translated">事件队列是异步代码等待执行的地方。与调用堆栈不同的是，<strong class="lu ir">事件队列</strong>遵循FIFO(先入先出)原则，这意味着它总是按照调用被添加到队列的顺序来处理调用。</p><p id="82ec" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">需要注意的是，只有当调用堆栈为空时，事件队列才会开始执行。如果调用堆栈已经在处理代码，事件循环将不会从事件队列中添加任何函数。在调用堆栈清除之前，事件循环不会继续。</p><p id="0fc8" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">看一下下面的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fe305cb8022d4d5874c9ba599e9bed9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*VMDs7dqBCqWaz2-pUixCnA.png"/></div></figure><p id="11f1" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">不出所料，上面的代码会立即在控制台中打印出<code class="fe mr ms mt mu b">‘foo’</code>。然后，1秒钟后它会打印出<code class="fe mr ms mt mu b">‘bar’</code>。</p><p id="133c" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">下面的代码怎么样？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/eed072b831e22dad7fce11bdfea6474b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVei_jYM1X2ZY1bIhG2g4g.png"/></div></div></figure><p id="27ca" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">在这里，<code class="fe mr ms mt mu b">setTimeout</code>被设置为<code class="fe mr ms mt mu b">0</code>。因此，你可能认为<code class="fe mr ms mt mu b">bar()</code>会立即执行，导致<code class="fe mr ms mt mu b">‘bar’</code>在<code class="fe mr ms mt mu b">‘foo’</code>之前被打印。但事实并非如此。这两个代码片段都将导致:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/5c8048b9596348aad058344c52584e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngwT2Jk3feikeo9vNyzioQ.png"/></div></div></figure><p id="b4b4" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">尽管<code class="fe mr ms mt mu b">setTimeout</code>被设置为<code class="fe mr ms mt mu b">0</code>，它仍然被转发到事件队列。这意味着在调用堆栈完全清除之前，它无法执行。</p><h1 id="a6fc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">额外资源</h1><div class="nv nw gp gr nx ny"><a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">✨♻️ JavaScript可视化:事件循环</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">哦，事件循环。这是每个JavaScript开发人员都必须以某种方式处理的事情之一…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">开发到</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://felixgerschau.com/javascript-event-loop-call-stack/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">解释了JavaScript事件循环和调用堆栈</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">我写这篇文章的目的是教你JavaScript如何在浏览器中工作。尽管我一直在和…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">felixgerschau.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om kp ny"/></div></div></a></div></div></div>    
</body>
</html>