<html>
<head>
<title>How to merge NoSQL and SQL using AWS Glue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用AWS Glue合并NoSQL和SQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-merge-nosql-and-sql-using-aws-glue-ec83c6f02137?source=collection_archive---------9-----------------------#2020-01-05">https://levelup.gitconnected.com/how-to-merge-nosql-and-sql-using-aws-glue-ec83c6f02137?source=collection_archive---------9-----------------------#2020-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1059" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何同时报告来自NoSQL和SQL的数据而不至于发疯</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/24811f036bc3d4c0b6d7465460842bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgURA_mxKSXDr31dwT5sOA.jpeg"/></div></div></figure><p id="3bbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的一个项目涉及为一家食品配送公司创建一个生成报告的平台。它运行在微服务架构上，每个服务都有自己的数据库。大多数有一个MySQL数据库，但一些由实时事件驱动的(例如，驱动程序在哪里)有一个NoSQL蒙戈数据库，所有这些都生活在AWS上。</p><p id="45e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该项目是创建一个自治平台，将定期创建报告，前端用户界面可以消化和显示一些漂亮的图形业务人员。所以最终结果应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/b76192eb85500fc231f89a2bfb1adf45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdifpMKGQOi8aF_ykxANew.png"/></div></div></figure><p id="3919" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中一份报告是关于系统的预计到达时间与司机到达目的地的实际时间相比有多准确。ETA数据和用于计算它的数据(交通状况、距离和时间)存储在一个MySQL数据库中，而司机所走的实际时间和路线存储在一个Mongo数据库中。</p><h1 id="4293" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">第一步:获取数据</h1><p id="251b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">假设我们的数据存在于Mongo的两个文档和MySQL的两个表中。要解决的第一个问题是如何获得我们需要的数据来制作报告，并且仅仅是这些数据。毕竟，这些都是海量的数据库，我们读得越少，查询就越快。</p><p id="adce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有两种选择来获取数据:</p><p id="6da9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">选项A: </strong>我们可以设置触发器，在数据进来的时候创建视图，或者把数据吐到另一个Mongo和MySQL数据库里。但是，这种方法的问题是，即使它不会增加编写数据库的任何成本，它也会使处理数据库的服务有责任维护这些触发器，因此这种责任就落在了处理这些服务的团队身上。因此，考虑到业务需要独立于其他团队进行报告，这个选项就是<strong class="kt ir">失败</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/91f820a16f2574be37609da5785399f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3YqWp75cCB2iIEVLpwyGg.png"/></div></div></figure><p id="8b32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">选项B: </strong>如果我们不能让持续的事件从我们所追求的数据源中发出，那么我们需要自己去读取它们。我们可以设置一些对这些数据库有读取权限的外部服务，并且能够运行查询来获得报告所需的数据。该服务将需要使用某些索引来提高读取效率，而管理主要服务的团队只需要在他们的数据库中创建索引，这是一件容易得多的事情。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/94e44d875ae802b2ca5020fa55fc358f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oP-xGcgvgPe7qA0zZoqd2A.png"/></div></div></figure><p id="db8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们决定将这个读取服务称为<strong class="kt ir"> Bob </strong>，我们还决定在AWS Lambda函数上构建Bob，并让它将查询结果导出为S3桶中的CSV文件，因为Bob不会连续运行，可能每天/每周/每月运行一次。这使得企业可以灵活地决定何时运行Bob，而不必担心在Bob不做任何事情时必须为Bob付费。</p><p id="a1b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Bob现在由四个不同的lambda函数组成，我们需要从Mysql/Mongo中读取的每个表/文档都有一个函数。每个函数都连接到数据库，并在被触发读取数据时运行查询。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/afcd8ad14d7acca466f097e735936fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmaGpJV13Ag9wmq9ddQ5nw.png"/></div></div></figure><p id="d061" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们有了所需的数据，可以将它们合并在一起，形成一个大blob，供报告服务读取和报告。</p><h1 id="6b0c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">第二步:合并数据</h1><p id="7c1f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">棘手的部分来了。我们有来自Mongo的以嵌套对象表示的数据，也有来自MySQL的平面数据</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="69af" class="mt lp iq mp b gy mu mv l mw mx">// NoSQL</span><span id="2750" class="mt lp iq mp b gy my mv l mw mx">{</span><span id="5b0c" class="mt lp iq mp b gy my mv l mw mx">tripId: abc,</span><span id="1b3e" class="mt lp iq mp b gy my mv l mw mx">timeFrom: 123123123,</span><span id="8d09" class="mt lp iq mp b gy my mv l mw mx">timeTo: 123123123,</span><span id="58bf" class="mt lp iq mp b gy my mv l mw mx">  travelPath: [</span><span id="01c3" class="mt lp iq mp b gy my mv l mw mx">    {</span><span id="e6ef" class="mt lp iq mp b gy my mv l mw mx">      lat: 123123123A</span><span id="8d73" class="mt lp iq mp b gy my mv l mw mx">      lng: 123123123B</span><span id="9ff3" class="mt lp iq mp b gy my mv l mw mx">    },</span><span id="7db6" class="mt lp iq mp b gy my mv l mw mx">    {</span><span id="dbf2" class="mt lp iq mp b gy my mv l mw mx">      lat: 123123123C,</span><span id="deb7" class="mt lp iq mp b gy my mv l mw mx">      lng: 123123123D</span><span id="8803" class="mt lp iq mp b gy my mv l mw mx">    },</span><span id="264f" class="mt lp iq mp b gy my mv l mw mx">    {</span><span id="6360" class="mt lp iq mp b gy my mv l mw mx">      lat: 123123123E,</span><span id="fff0" class="mt lp iq mp b gy my mv l mw mx">      lng: 123123123F</span><span id="2bca" class="mt lp iq mp b gy my mv l mw mx">    }</span><span id="ef15" class="mt lp iq mp b gy my mv l mw mx">  ]</span><span id="4249" class="mt lp iq mp b gy my mv l mw mx">}</span><span id="c76d" class="mt lp iq mp b gy my mv l mw mx">// SQL</span><span id="a57b" class="mt lp iq mp b gy my mv l mw mx">{</span><span id="46e1" class="mt lp iq mp b gy my mv l mw mx">  tripId: abc,</span><span id="d7d7" class="mt lp iq mp b gy my mv l mw mx">  driver: Mr X,</span><span id="cc99" class="mt lp iq mp b gy my mv l mw mx">  deliveringFrom: Tekehashi Store</span><span id="32ee" class="mt lp iq mp b gy my mv l mw mx">}</span></pre><p id="4db4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了将它们合并在一起，我们需要首先通过分解对象的嵌套对象并将它们都放在一行来展平Mongo数据。</p><p id="6196" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面到:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="d4a3" class="mt lp iq mp b gy mu mv l mw mx">// NoSQL<br/>{</span><span id="0641" class="mt lp iq mp b gy my mv l mw mx">  tripId: abc,</span><span id="242b" class="mt lp iq mp b gy my mv l mw mx">  timeFrom: 123123123,</span><span id="6779" class="mt lp iq mp b gy my mv l mw mx">  timeTo: 123123123,</span><span id="eb49" class="mt lp iq mp b gy my mv l mw mx">  lat: 123123123A,</span><span id="fb90" class="mt lp iq mp b gy my mv l mw mx">  lng: 123123123B</span><span id="f0ed" class="mt lp iq mp b gy my mv l mw mx">},</span><span id="f616" class="mt lp iq mp b gy my mv l mw mx">{</span><span id="48db" class="mt lp iq mp b gy my mv l mw mx">  tripId: abc,</span><span id="9c2c" class="mt lp iq mp b gy my mv l mw mx">  timeFrom: 123123123,</span><span id="36da" class="mt lp iq mp b gy my mv l mw mx">  timeTo: 123123123,</span><span id="50d6" class="mt lp iq mp b gy my mv l mw mx">  lat: 123123123C,</span><span id="688c" class="mt lp iq mp b gy my mv l mw mx">  lng: 123123123D</span><span id="a560" class="mt lp iq mp b gy my mv l mw mx">},</span><span id="0041" class="mt lp iq mp b gy my mv l mw mx">{</span><span id="4148" class="mt lp iq mp b gy my mv l mw mx">  tripId: abc,</span><span id="48a5" class="mt lp iq mp b gy my mv l mw mx">  timeFrom: 123123123,</span><span id="e57f" class="mt lp iq mp b gy my mv l mw mx">  timeTo: 123123123,</span><span id="7926" class="mt lp iq mp b gy my mv l mw mx">  lat: 123123123E,</span><span id="5765" class="mt lp iq mp b gy my mv l mw mx">  lng: 123123123F</span><span id="fb56" class="mt lp iq mp b gy my mv l mw mx">}</span></pre><p id="6ac5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们使用<code class="fe mz na nb mp b">tripId</code>将数据从MySQL映射到Mongo，将它们放在同一行中，并存储在一个新的数据仓库中。为此，我们使用AWS Glue服务。</p><p id="d636" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">AWS Glue是一个ETL，<em class="nc"> Extract-Transform -Load，</em>服务，用于将不同来源的数据“粘合”在一起。</p><p id="ee4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在AWS Glue上编写了一个Python脚本，该脚本基于<code class="fe mz na nb mp b">tripId</code>进行映射，并让Glue将最终结果导出到AWS Redshift数据仓库中，在这里将会发生神奇的报告。让我们称那部分为帕特丽夏。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/6b166d3e403f5a84b71b0738409f3591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BFhd6g2c6W9_AKcG1jPKg.png"/></div></div></figure><p id="f9af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让Bob与Patricia交谈，Patricia从Bob导出的S3存储桶中读取CSV文件并映射它们。</p><h1 id="dc22" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">第三步:编排</strong></h1><p id="ed52" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在一切就绪，这应该可以工作了。但是，Bob和Patricia是不通信的不同服务。S3存储桶保存Bob导出和Patricia需要的数据。然而，我们需要另一个服务来告诉Bob开始，等到Bob完成，然后告诉Patricia数据准备好了，等到Patricia完成，然后升起一个标志，让每个人都知道数据查询和合并已经完成，可以报告了。</p><p id="3403" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该服务需要知道管道(Bob和Patricia)何时开始运行，何时结束，以便防止数据重叠，并告诉Bob开始查询我们知道尚未收集的新数据。</p><p id="7a0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即</p><ol class=""><li id="7f75" class="ne nf iq kt b ku kv kx ky la ng le nh li ni lm nj nk nl nm bi translated">鲍勃开始查询从<code class="fe mz na nb mp b">timestampA</code>到现在他的<code class="fe mz na nb mp b">timestampB</code>的数据</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/ec99f6e848d2a15a994b082f3eb324d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYQqnJpm2cgN1qr7_WB0bg.png"/></div></div></figure><p id="bb91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.<code class="fe mz na nb mp b">timestampB</code>被保存在某个地方供以后参考(这样我们就知道鲍勃在做什么)</p><p id="a244" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.后来，有人要求另一份报告。新的编排服务将要求Bob从<code class="fe mz na nb mp b">timestampB</code>开始查询，直到现在<code class="fe mz na nb mp b">timestampC</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e28cf5b149673a926bbf064d8a4fbd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkwlXhmJSlt-x2d6tg9yPg.png"/></div></div></figure><p id="ba87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让Bob工作，我们需要做的就是触发Bob拥有的每个lambda函数或一个“启动”函数。一旦Bob的所有函数都完成并将其数据导出到S3，我们现在就可以触发Patricia的AWS Glue并让它运行。为了做到这一切，我们创建了一个lambda函数，并将其命名为<strong class="kt ir">弗兰克叔叔</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/25cff6179ce365d483da6f01e0481465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5cIv9A7nyqrZRCzysw9CQ.png"/></div></div></figure><p id="a7cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了不让Frank一直等到Bob的所有lambda函数都完成，我们让Bob在一个查询或函数完成其工作时调用Frank，我们为Frank创建了另一个lambda函数来保存每次“我完成了！”调用一个带有时间戳的轻量级Dynamo数据库，检查是否所有的工作都完成了，一旦所有的工作都完成了，Frank就调用Patricia。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/17978bf0778348ef9cf59ac1d594fa32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9U6dQ59TPSPg0mXd7R0fA.png"/></div></div></figure><p id="b0be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们只有一个文件进入S3，我们可以用S3 <strong class="kt ir">上的触发器来代替Frank对Patricia的调用，但是因为我们有四个不同的文件可以以不同的顺序上传，所以我们需要一个外部服务来进行监控，并在四个文件都准备好被消化后采取行动</strong></p><p id="b835" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Frank的数据库看起来像这样:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="1706" class="mt lp iq mp b gy mu mv l mw mx">{</span><span id="c895" class="mt lp iq mp b gy my mv l mw mx">  reportType: “ETA”,</span><span id="5f47" class="mt lp iq mp b gy my mv l mw mx">  jobTimestamp: &lt;timestamp&gt;</span><span id="9922" class="mt lp iq mp b gy my mv l mw mx">  BobMySQL:</span><span id="cc71" class="mt lp iq mp b gy my mv l mw mx">    {</span><span id="92bc" class="mt lp iq mp b gy my mv l mw mx">      A: &lt;timestamp&gt;,</span><span id="b5bb" class="mt lp iq mp b gy my mv l mw mx">      B: null</span><span id="11c5" class="mt lp iq mp b gy my mv l mw mx">    }</span><span id="7b65" class="mt lp iq mp b gy my mv l mw mx">  BobMongo:</span><span id="344d" class="mt lp iq mp b gy my mv l mw mx">    {</span><span id="1dac" class="mt lp iq mp b gy my mv l mw mx">      A: &lt;timestamp&gt;</span><span id="25a9" class="mt lp iq mp b gy my mv l mw mx">      B: &lt;timestamp&gt;</span><span id="64bb" class="mt lp iq mp b gy my mv l mw mx">    }</span><span id="5b86" class="mt lp iq mp b gy my mv l mw mx">}</span></pre><p id="05ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意在这个例子中,<code class="fe mz na nb mp b">BobMysql.B</code>没有时间戳。因此，可以有把握地认为它还没有完成这些工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/e26ac8fa224798f4dc9ab8dadb657c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZDRXHDgh15YEvJftQNjy2Q.png"/></div></div></figure><p id="7283" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次Bob调用Frank时，Frank都会检查是否所有的表都已完成，并触发Patricia。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/d17fa99a8c76d6f2c2ef11a9bf9c6917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3qpr3rIAmfDciDpE6WZJA.png"/></div></div></figure><p id="9c57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们为Patricia实现了相同的逻辑，并让Frank存储Patricia何时完成胶合工作。我们这样做是为了能够告诉任何其他正在等待报告的服务它已经完成了。我们用社交网络把它传达给任何一个在听的人。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/9d95166b834c33c1f40d53a5d5db8c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dT0RfXE6Zi8NYSsPa74rwQ.png"/></div></div></figure><p id="a67b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们为Frank创建了一个基于时间的云观察触发器，因此它可以在每天午夜运行报告。我们还为Frank创建了一个SSM参数存储来保存上次运行报告的时间戳，这样当Frank运行时，它会将该时间戳传递给Bob，Bob会基于该时间戳查询所有数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/f83eccac5a18b5d4cf7047f6c990e05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VG1KCmTycqdEmWox4c0YAA.png"/></div></div></figure><h1 id="1e5a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">第四步:缩放</strong></h1><p id="9775" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">第四步也是最后一步是为我们的每一份报告重复这一过程。为此，我们为Bob(即Sabrina)创建了另一组函数，为Patricia创建了另一个Python脚本，其余部分可重用，同时记住Frank需要了解每份报告以及获取该报告所涉及的查询，以便知道何时调用Patricia的特定粘合函数。</p><p id="2b4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，假设我们有另一个合并了三个MySQL表和一个Mongo表的报表，我们的流程应该是这样的</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/2acc38d0dee6f1b43eeaf072f09f70f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uko_4QvjWHGLekLrMtsvxA.png"/></div></div></figure><p id="3a0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在该模型中，我们有另一个名为Sabrina的服务，它执行三个MySQL查询和一个Mongo查询，Patricia有另一个胶合映射脚本，它将最终结果与第一个脚本放在同一个数据仓库中。</p><p id="70bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Frank的架构仍然相同，但编排功能知道有一个名为Bob的服务在完成之前有2个SQL和2个NoSQL作业，还有一个名为Sabrina的服务在完成之前有3个SQL和1个NoSQL作业。它还知道每个服务/报告的合适的粘合工作。</p></div></div>    
</body>
</html>