<html>
<head>
<title>Closing Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关闭观察点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/closing-observables-e612803517dc?source=collection_archive---------0-----------------------#2022-09-16">https://levelup.gitconnected.com/closing-observables-e612803517dc?source=collection_archive---------0-----------------------#2022-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ebc0daec22e04a382561a56428c205ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t6dDZ_lN8eH9Sooq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">蒂姆·莫斯霍尔德在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4c61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Angular中，我们在任何地方都可以使用RxJs。在反应式编程范例中，我们认为数据流要么是懒惰的，要么是急切的，当不再需要时，可以订阅和必须取消订阅。否则，我们将面临不必要行为的风险，在最坏的情况下，甚至会出现内存泄漏。幸运的是，有很多方法可以退订可观的东西，但有些方法肯定比其他方法好。</p><h2 id="30c4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">显式描述</h2><p id="8066" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">作为RxJs的初学者，最常见的关闭可观测量的方法是显式方法。当调用subscribe方法时，会返回一个订阅，我们可以在ngOnDestroy生命周期挂钩中取消订阅。我们可以只创建一个订阅对象，并将具体的订阅添加到类属性中，而不是将这些订阅对象保存在多个类属性中。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">订阅对象</figcaption></figure><p id="a977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用subscription对象并将订阅添加到其中，代码变得更加简洁，但是老实说，这并不是明智的终结，因为它迫使您在代码中进行订阅，实际上一点也不被动。</p><h2 id="f87e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">隐式退订</h2><p id="14f0" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">更好的退订方式是隐式退订，或者换句话说:被动退订。在这种情况下，我们不必保存任何订阅并明确取消订阅。我们唯一要做的，就是利用关闭管道操作符，比如:</p><ul class=""><li id="ae18" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">直到</li><li id="cdc9" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">拿</li><li id="5344" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">投掷误差</li></ul><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">被动退订</figcaption></figure><p id="9e69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，这是真正的反应性，在使用RxJs时，这始终是一个可实现的目标。当主题第一次发出时，takeUntil运算符将取消订阅。另一方面，take运算符有一个固定的排放量，在达到该量后关闭。</p><h2 id="dba8" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">异步管道</h2><p id="a4c8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">绝对最好和最简单的方法是在模板中使用异步管道，因为它自动订阅和取消订阅可观察对象，因此我们编写的代码要少得多。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">异步管道</figcaption></figure><p id="098d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用ng-container和ngIf来解包可观察对象的值，这是一个很好的实践，可以确保可观察对象已经发出了一个值，而不需要创建额外的DOM元素。请注意，不要在代码中订阅可观察对象，因为异步管道会自动订阅。</p><h2 id="5e2c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">取消订阅热门观察</h2><p id="6ac1" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">另一个经常被遗忘的重要案例是关于热可观测量。之前，我们研究了冷的可观察对象，但通常我们需要通过使用share或shareReplay管道操作符将冷的可观察对象变成热的，该操作符将一个主题连接到原始可观察对象，并将内部主题公开为可观察对象，这样就确实是热的。使用share不会有问题，但是使用shareReplay时如果不小心，可能会遇到问题。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">热vs冷</figcaption></figure><p id="368d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把连接一个主体到冷可观察对象的过程叫做<strong class="kf ir"> connect </strong>，这样我们也有一个叫做<strong class="kf ir"> disconnect </strong>的过程，当所有对热可观察对象的订阅都被关闭时，它取消对冷可观察对象的订阅。Share确实会为我们自动断开连接，但是shareReplay可能会很麻烦，因为refCount参数必须设置为true，这样它就会自动断开连接。</p><h1 id="8bc9" class="mt lc iq bd ld mu mv mw lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj bi translated">结论</h1><p id="abaf" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有许多方法可以取消订阅，而最好的方法是使用异步管道，或者当您需要在代码中订阅时使用反应式取消订阅。你应该始终确保你所有的订阅将在某一点被取消订阅，否则你会遇到内存泄漏或不必要的行为的风险。</p><p id="44de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Pro提示:</strong>通过查看DevTools中的Memory选项卡并创建一个堆快照，您可以很容易地查看当前订阅了多少observable，这样您就可以搜索observable并查看有多少实例是活动的。</p><h2 id="fc8d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">推荐链接</h2><p id="5061" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果你喜欢这篇文章，我很乐意分享我的<strong class="kf ir">推荐链接</strong>:</p><div class="nk nl gp gr nm nn"><a href="https://medium.com/@stefan.haas.privat/membership" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">通过我的推荐链接-斯特凡·哈斯加入媒体</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">阅读斯特凡·哈斯的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接支持…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob jw nn"/></div></div></a></div><h2 id="63df" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">其他有趣的阅读:</strong></h2><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/refactoring-angular-applications-be18a7ee65cb"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">重构角度应用程序</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">重构是软件工程中最重要的技术之一，因为它是项目进行的唯一方式</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob jw nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-dont-use-functions-in-templates-f33d67db18da"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">Angular:不要在模板中使用函数</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在这篇简短的博文中，我将向你展示Angular的一个核心概念，这是每个Angular开发者都应该知道的…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="od l ny nz oa nw ob jw nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/moduliths-in-angular-with-nx-b8b0076794fb"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">以Nx为单位的角度模数</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">使用DDD和Monorepos创建可持续应用</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="oe l ny nz oa nw ob jw nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/your-first-angular-microfrontend-58950768a465"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">你的第一个角形微前端</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">这是一个关于如何创建一个简单的angular应用程序来使用另一个应用程序的模块的分步指南…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="of l ny nz oa nw ob jw nn"/></div></div></a></div></div></div>    
</body>
</html>