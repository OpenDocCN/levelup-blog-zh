<html>
<head>
<title>Soft-Token Authentication with AWS Amplify, Cognito and Material-UI React with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Amplify、Cognito和Material-UI与Typescript进行反应的软令牌身份验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/guide-soft-token-authentication-with-aws-amplify-cognito-and-material-ui-react-with-typescript-31094f96968b?source=collection_archive---------3-----------------------#2020-06-17">https://levelup.gitconnected.com/guide-soft-token-authentication-with-aws-amplify-cognito-and-material-ui-react-with-typescript-31094f96968b?source=collection_archive---------3-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f29a8238a033aca2c8858522366357bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0GCSd5NOPsgajd4v"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱门特·H</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="01a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在创业时有一个需求，要构建一个Web应用程序来与我们的核心数据科学服务进行交互。我使用React (JS)和AWS Amplify启动了这个web应用程序的第一个版本，这样我们就可以在几周内为用户提供一个版本。</p><p id="f4e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个版本已经足够了，但随着功能需求的增长，我意识到我们需要构建一个更专业的认证层，与应用程序的其余部分保持一致。此外，随着代码库的增长，我意识到我在运行时花费了过多的时间来调试代码。经过一些阅读和与其他开发人员的讨论，我得出结论，我必须首先迁移到TypeScript。</p><p id="7cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦TypeScript迁移完成，我开始尝试使用AWS Amplify Authenticator组件，却发现它充满了陷阱，使用了继承(违反了<a class="ae kc" href="https://reactjs.org/docs/composition-vs-inheritance.html" rel="noopener ugc nofollow" target="_blank"> React指南</a>)并利用了我完全避免的类组件。</p><p id="a299" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我觉得坚持使用单一的UI库更好，因为我已经使用了Material-UI，所以我开始想我应该构建自己的身份验证组件，这样我就可以完全控制流程。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="e0c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要求:</p><ul class=""><li id="a805" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">必须通过Cognito发送的包含用户名和临时密码的电子邮件邀请用户登录</li><li id="fa2f" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">他们将能够在他们的移动设备上使用他们选择的身份验证应用程序的用户名、密码和TOTP进行登录。</li><li id="7b36" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">首次登录时，必须提示用户更改密码并提供昵称</li><li id="6508" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">在设置他们的第一个密码时，他们将被重定向到使用QR码设置多因素身份验证</li><li id="ee06" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">用户必须能够通过点击按钮退出</li></ul><h1 id="8f77" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">邀请电子邮件</h1><p id="08f4" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">幸运的是，Cognito CLI和GUI允许您设置邀请用户的设置。在CLI中运行Amplify Auth Update(或在首次尝试时添加)后，邀请电子邮件文本会升级。如果您喜欢使用GUI，只需登录AWS &gt;转到您的用户池&gt;单击消息定制，然后向下滚动到此处:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/24d228835bdf6990e558ec06ea92eeaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joDKWA-bCwaxtOJakYsloA.png"/></div></div></figure><p id="b884" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是显而易见的，但是你可以在这里复制粘贴一些HTML，生成一个更丰富更好的邀请邮件。</p><h1 id="cd75" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">认证包装</h1><p id="dde9" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">如果你不熟悉<a class="ae kc" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">提升状态的概念</a>或者没有读过《反应中的思考<a class="ae kc" href="https://reactjs.org/docs/thinking-in-react.html" rel="noopener ugc nofollow" target="_blank"/>，我强烈建议你这么做，因为这将极大地提高你使用反应的能力。</p><p id="0652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这些文章的基础上，我创建了一个身份验证包装器，作为所有身份验证工作流阶段的父组件。它将使用React 16.8中引入的<code class="fe ne nf ng nh b">UseState()</code>钩子来存储两个关键状态值。</p><p id="6994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定存储的两个值是:</p><ul class=""><li id="379e" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">用户</li><li id="4333" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">授权阶段</li></ul><p id="6c30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些状态将利用回调函数来设置，回调函数将作为道具传递给每个子组件。回调函数被用来代替使用<code class="fe ne nf ng nh b">UseReducer()</code>钩子，因为认证组件只有一层深度，所以简单的回调来控制兄弟之间的状态被认为是足够的。</p><p id="26b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我的身份验证包装器的要点:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="a28b" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">签到</h1><p id="6fd1" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">以下是登录组件的要点:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d0d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们分离出一些干扰，并关注这里的关键元素:</p><p id="871d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">signInStatus和User作为道具传递给登录组件:</p><pre class="na nb nc nd gt nk nh nl nm aw nn bi"><span id="407e" class="no lx iq nh b gy np nq l nr ns">signInStatus: (stage: string) =&gt; void;    <br/>user: (user: any) =&gt; void;</span></pre><p id="2fd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在handlechallenge函数中访问它们，并将其设置为将用户和signInStatus返回给AuthWrapper，以便在登录工作流的条件呈现中使用。</p><pre class="na nb nc nd gt nk nh nl nm aw nn bi"><span id="b4f7" class="no lx iq nh b gy np nq l nr ns">else if (user.challengeName === 'SMS_MFA' ||                user.challengeName === 'MFA_SETUP' ||                user.challengeName === undefined) <br/>{<br/>props.user(user);<br/>props.signInStatus('TOTPSetup');<br/>}</span></pre><p id="460e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你熟悉react，那么上面的内容可能很简单，你还没有学到多少。</p><p id="cadd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后对每个sign in阶段重复这个过程，将状态传递回包装器和route app.tsx组件。基于身份验证阶段，应用程序有条件地呈现相关组件。</p><h1 id="e2a9" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">首次登录</h1><p id="d57e" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">当用户首次尝试登录时，他们必须重置密码，然后设置MFA。我们将集中讨论外交部的设立。这是要点。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们详细介绍一下，因为我还没有看到关于如何使用Cognito/React实现这一点的详细指南。</p><p id="3fb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须做的第一件事是使用UseEffect钩子在页面加载时触发二维码的生成。这行代码实现了这一点:</p><pre class="na nb nc nd gt nk nh nl nm aw nn bi"><span id="140b" class="no lx iq nh b gy np nq l nr ns">useEffect(() =&gt; {generateQRCode();}, []);</span></pre><p id="48b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">generateQRCode函数定义如下:</p><pre class="na nb nc nd gt nk nh nl nm aw nn bi"><span id="a5c5" class="no lx iq nh b gy np nq l nr ns">const generateQRCode = (): void =&gt; {<br/>const username = props.user.username;        Auth.setupTOTP(props.user).then(code =&gt; {            const generatedQrCode = 'otpauth://totp/AWSCognito:' + username + '?secret=' + code + '&amp;issuer=Atreides';            setQrCode(generatedQrCode);        <br/>});    <br/>};</span></pre><p id="55ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里发生了什么？</p><p id="e85c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将传入的用户作为props，并在其JSON结构中访问用户名。</p><p id="f6a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，我们使用cogn ITO auth . setup topp方法并传入这个用户。这将返回我们创建QRCode图像所需的代码。</p><p id="b4a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三，我们使用这个响应为我们的TOTP设置创建QR码。</p><p id="15b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，使用setQRCode将QRCode信息存储在应用程序状态中。</p><p id="bbb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是用户拿出他们的手机和他们最喜欢的令牌应用程序，扫描他们在屏幕上看到的代码。一旦他们这样做，计时器将启动，他们将能够输入他们看到的代码。一旦他们输入代码并提交以下功能将</p><pre class="na nb nc nd gt nk nh nl nm aw nn bi"><span id="6409" class="no lx iq nh b gy np nq l nr ns">const verifyTOTPCode = (): void =&gt; {        Auth.verifyTotpToken(props.user, totpCode)            .then(() =&gt; {                Auth.setPreferredMFA(props.user, 'TOTP').then(() =&gt; {                    props.signInStatus('SignedIn');                    Auth.enableSMS(props.user);                });            })            .catch(</span></pre><p id="da27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里显示了一个重要的问题，请注意这一行:</p><pre class="na nb nc nd gt nk nh nl nm aw nn bi"><span id="993e" class="no lx iq nh b gy np nq l nr ns">Auth.enableSMS(props.user);</span></pre><p id="85c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我意识到，除非启用smsMFA，否则工作流将无法工作，因为Cognito的登录质询方法不会返回MFA质询。这是Cognito的一个问题，所以我的解决方法是在设置过程中触发设置。这似乎是可行的，因为用户没有设置手机号码，所以不会发送短信。</p><p id="ac7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！我试图把重点放在重要的关键点上，如果你需要进一步的信息或帮助，请在下面评论。</p><p id="2b96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你觉得这很有帮助，请在下面评论。如果您有任何改进或建议，也请评论。我总是乐于学习！</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><div class="na nb nc nd gt nt"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">编写面试问题</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">技术开发</p></div></div><div class="oc l"><div class="od l oe of og oc oh jw nt"/></div></div></a></div></div></div>    
</body>
</html>