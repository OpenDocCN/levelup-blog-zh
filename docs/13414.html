<html>
<head>
<title>GraphQL vs REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL与REST</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-vs-rest-e918d9e0e271?source=collection_archive---------13-----------------------#2022-09-02">https://levelup.gitconnected.com/graphql-vs-rest-e918d9e0e271?source=collection_archive---------13-----------------------#2022-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">何时选择一个或另一个</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6e5a5edb07f2ed7754fe765bbc9877e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1D_2ZLR4diYaq_xpIYPHA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">中途“想象”出来的神经网络</figcaption></figure><p id="c0e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候一起探索GraphQL和REST的奇妙世界了！</p><p id="da31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看什么是GraphQL，什么是REST，以及什么时候应该选择一个而不是另一个。他们存在服务的需求是什么？它们是用来做什么的？为什么以及如何使用它们？这么多问题！</p><p id="5f23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将看到GraphQL相对于REST-ful风格的API的四个优势。</p><p id="256e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后是在GraphQL中使用或创建API时必须注意的<strong class="la iu"> 2主要缺点</strong>。</p><p id="50a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但在此之前，让我们从头说起:</p><h1 id="eacc" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">GraphQL是什么？</h1><p id="cb0d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">GraphQL是创建web APIs的一种方式。我已经写了关于API的文章<a class="ae mr" href="https://medium.com/gitconnected/what-is-a-rest-api-6471b08eb575" rel="noopener">，特别是REST web APIs】。</a></p><p id="7bdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然REST标准是组织API的标准方式，但GraphQL正在稳步挑战这种主导地位。为了理解GraphQL，以及它的用途，我们将把它与REST APIs的组织方式进行比较。</p><p id="8afb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢最终的结果…</p><p id="c2fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">说实话，你几乎可以说GraphQL存在<em class="ms">是因为</em>的“喜欢”。GraphQL出生在脸书。它的建立是为了满足社交网络的特殊需求。“喜欢按钮”本身体现的一个问题。</p><p id="8632" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为GraphQL的主要目的是<strong class="la iu">导航一个关系网络</strong>。</p><h1 id="5fdc" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.GraphQL更适合关系数据</h1><p id="c36f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我这么说是什么意思？REST特别适合经典的基于表的数据库设置，其中每一行代表一个对象。毕竟，REST代表代表性的状态转移。</p><p id="5605" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单来说，REST的目的是传递数据库中集合或表的一个或几个项目。在REST术语中，这些分别被称为“资源”和“资源集合”。例如，我们请求服务器向我们提供给定书籍或书籍集的数据。</p><p id="ed93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是社交网络是关于不同类型的物品之间的关系。谁是我朋友的朋友？他们喜欢什么内容？他们看什么？他们对什么类型的内容作出回应？</p><p id="16e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从概念上讲，友谊、关注和喜欢是链接。它们是事物之间的关系。</p><p id="9fbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些链接组合在一起，形成一个图表，其中节点(用户、页面)链接在一起(通过喜欢、关注、查看和访问……)。</p><p id="3ac4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GraphQL提供了创建遍历这个图的<strong class="la iu">查询的方法，跨越不同种类的对象。与REST不同，在REST中，一个请求通常只能获得一种“类型”的项目。</strong></p><p id="c564" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是GraphQL这个名字的含义，它代表“<strong class="la iu">图形查询语言</strong>”。</p><p id="2bf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与REST不同，GraphQL真正是一种查询语言，例如结构化查询语言(也称为SQL)。</p><p id="af60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在REST中，入口点(调用的URL和使用的HTTP动词)决定服务器的响应。在GraphQL中，你只能与一个入口点对话。怎么会？</p><p id="77a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们发送一个HTTP请求，其中包含一页用GraphQL编写的描述我们的查询的文本。</p><p id="cc60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些请求主要有两种类型。您可以发送一个读请求，称为“查询”，或者一个写请求，称为“变异”。</p><p id="1376" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我是边做边学的忠实粉丝，我们将使用《星球大战》的GraphQL API，如果你喜欢，你可以<a class="ae mr" href="https://github.com/apollographql/starwars-server" rel="noopener ugc nofollow" target="_blank">跟随。你所需要做的就是git克隆一个yarn安装和yarn开发！</a></p><p id="1c78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们尝试一个简单的查询。在read查询中，我们列出了我们想要返回的所有字段。例如，在上面刚刚安装的StarWars API中，我们可以:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ca14" class="my lv it mu b gy mz na l nb nc">query {<br/>  hero {<br/>    id<br/>    name<br/>  }<br/>}</span></pre><p id="80dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们要求主要英雄的日期，特别是他的身份证和他的名字。众所周知，这部电影的主角是… R2-D2，很明显</p><h1 id="73e3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.GraphQL允许客户端日期整形</h1><p id="73ef" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这里我们看到了GraphQL的<strong class="la iu">第二个优势</strong>:客户端定义了它希望数据呈现的形状。那有什么意义？</p><p id="aa30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">特别是对于移动用户，但一般来说在网络上，要传输的数据量是有成本的，从时间、带宽和交互性来衡量。现在让我们更进一步。</p><p id="75de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我前面提到的，我们可以在同一个查询中浏览关系图的链接。在本例中，我们可以检索英雄的朋友，再次指定我们希望返回的字段:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="dba5" class="my lv it mu b gy mz na l nb nc">{ hero {<br/>    id name<br/>      friends { id name }<br/>   }<br/> }</span></pre><p id="9dc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们得到了英雄的朋友，以及他们的id和名字。</p><p id="c02c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我在编辑器(GraphQL playground)中键入代码时，它会给我一些建议。更重要的是，游乐场提供文档</p><p id="3a4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这之所以可能是因为<em class="ms">自省</em>，这是GraphQL的第三个优势。</p><h1 id="0cb1" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.GraphQL是自文档化的</h1><p id="e6cc" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">什么是自省？GraphQL有一个内置的特殊特性(建立在处理REST的挫败感上)。</p><p id="5237" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它有内置的查询，允许您通过GraphQL本身记录哪些字段和查询是可能的。</p><p id="7ba1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">playground运行这些查询来显示它的建议。</p><p id="eb6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我发送以下查询</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="aeb3" class="my lv it mu b gy mz na l nb nc">query { <br/>  __schema {<br/>    queryType {<br/>      fields {<br/>        name<br/>        type { kind name }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="e8e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该查询返回根节点上可能的查询列表。包括上面看到的英雄请求。</p><p id="0f30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个特性是对REST的一个最大缺陷的回应:你需要外部文档来使用它。外部文档容易出错、不完整且过时。</p><p id="b067" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">已经有<em class="ms">尝试在REST中创建自文档格式。因为没有标准化的实现，所以它们都没有被接受。休息是一个准则。在GraphQL中，自文档是规范的一部分，并融入到协议中。</em></p><p id="1b01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们来谈谈类型。</p><h1 id="320a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4.GraphQL是一种类型化语言</h1><p id="b196" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果我们回到前面的查询，我们会看到自省文档以及文档选项卡显示返回值。</p><p id="6a18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在GraphQL中，事物有一个类型。而<strong class="la iu">强打字是GraphQ的第四个优势</strong>。</p><p id="43bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们的API中有哪些不同的类型？这些类型是如何工作的？</p><p id="ae4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，这种强类型与GraphQL的自省结合得很好，它将能够回答我们。</p><p id="5a19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们运行以下查询:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cbe4" class="my lv it mu b gy mz na l nb nc">query { <br/>    __schema {<br/>    types { kind name }<br/>  }<br/>}</span></pre><p id="96ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到几个标量类型的字段。这些是基本类型。他们有五个人:</p><ul class=""><li id="555f" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">字符串，</li><li id="7d6e" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">布尔代数学体系的</li><li id="ac4c" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">Int(整数)，</li><li id="9ea2" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">浮动(浮动)</li><li id="2a47" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">和ID(可以是字符串或整数)</li></ul><p id="e24a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您浏览GraphQL文档，您还会看到另外两种符号:感叹号和方括号。</p><p id="d1df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方括号表示返回的是一个列表或数组。</p><p id="ffab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感叹号表示返回的内容不能为空</p><p id="ac77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们还可以看到特定的类型，如(在星球大战API的情况下)人类或机器人，同样，我们可以使用内省来查看这些更复杂对象的类型。</p><p id="db12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这允许我们同时看到如何在查询中传递参数。</p><p id="b7aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果我们在寻找名为Human的类型，我们查询对象的字段并获取类型。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="32be" class="my lv it mu b gy mz na l nb nc">query {<br/>  __type(name: "Human") {<br/>    fields { <br/>	name <br/>	description <br/>	type {<br/>        	kind<br/>        	name<br/>        	ofType { <br/>			name <br/>		}<br/>      	}<br/><br/>    }<br/>}}</span></pre><p id="1520" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，我们可以直接从GraphQL API中检索对象类型。因此，GraphQL的强类型特别适用于一般的类型脚本和类型语言(比如Flutter)。</p><p id="fba6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经看到了GraphQL相对于RESTfull风格的4个主要优势:</p><ul class=""><li id="db71" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">关系图查询，</li><li id="6955" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">自省，</li><li id="0c73" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">打字，</li><li id="5266" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">和客户端数据整形</li></ul><p id="5f96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但并非一切都是美好的。GraphQL的长处GraphQL也有弱点。</p><h1 id="5a21" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">GraphQL的问题是</h1><p id="69fb" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">客户端定义数据形状的事实使得缓存查询(和优化)更加困难。</p><p id="94c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是第二个缺陷更麻烦。这就是所谓的N+1问题，这是由于让客户端决定查询有多重。</p><p id="f07e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果客户机愿意的话(如果服务器没有任何额外的配置)，它可以在一个请求中运行所有的查询。</p><p id="d7b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就其本身而言，虽然不算大，但也不一定是戏剧性的，复杂性仍然是相当线性的。</p><p id="bc04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">真正的问题是，通过搜索孩子的孩子，你最终会得到一个成倍增长的复杂性。</p><p id="19e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，没有什么可以阻止我，在GraphQL中，寻找我朋友的朋友的朋友，等等。没什么，除了我冒着让数据库崩溃的风险。</p><p id="723b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，前端开发人员就有责任确保数据库不会过载。</p><p id="70ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个潜在的可怕前景。</p><h1 id="b040" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">我个人的看法</h1><p id="fc12" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">幸运的是，<em class="ms">一些</em>实现可以阻止这种级别的嵌套，GraphQL的优势——特别是通过检查的类型化和自文档化——带来了更好的开发人员体验。</p><p id="673a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种更流畅、更流畅的体验让GraphQL变得更有趣。</p><p id="eb4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你是这里的常客，你会知道我热衷于理解是什么让代码变得有趣。</p><p id="0c78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您还不是一个常客，但是您已经做到了这一步，那么这是您创建一个由图形组成的链接的机会，请为本文鼓掌，或者，恕我直言，请关注我以获得更多与代码相关的内容！</p><p id="d63f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论如何，回头见！</p></div></div>    
</body>
</html>