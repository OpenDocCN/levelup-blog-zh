<html>
<head>
<title>React 18 — the trickiness of useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应18——使用效果的棘手之处</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-18-the-trickiness-of-useeffect-fadfa65fa4b4?source=collection_archive---------0-----------------------#2022-05-15">https://levelup.gitconnected.com/react-18-the-trickiness-of-useeffect-fadfa65fa4b4?source=collection_archive---------0-----------------------#2022-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解在React 18中使用严格模式时useEffect hook的棘手行为</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/fd02267e612c9b6bc3db8a82f5ed1846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5dEDQr--TBamjT9V"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com/@punttim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·高</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6b36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React 18已经上市几周了。虽然它带来了一些改进，但是它给最常用的钩子之一引入了一个非常奇怪的行为。想知道那是什么吗？开始了…</p><p id="f71a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应该只在初始挂载时运行的useEffect()运行了两次！</p><p id="1e0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，你没听错！如果你在严格模式下使用React 18，下面这段代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="4926" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">会产生这样的输出:</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="0369" class="lj lk iq lf b gy ll lm l ln lo">Hello there!<br/>Hello there!</span></pre><p id="31fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为什么会这样？</strong></p><p id="929d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如<a class="ae lb" href="https://reactjs.org/docs/strict-mode.html#ensuring-reusable-state" rel="noopener ugc nofollow" target="_blank">文档</a>中所述，React 18引入了一个新的开发专用的严格模式检查。每当第一次装载组件时，这种新的检查自动<strong class="jp ir">卸载</strong>并且<strong class="jp ir">重新装载</strong>每个组件，在第二次装载时恢复先前的状态。</p><p id="2cde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React团队做出了这样的决定，因为在未来，他们希望添加一个特性，允许React在保留状态的同时添加和删除UI的部分。由于它要求组件对多次安装和破坏的影响具有弹性，因此引入了额外的检查。</p><p id="35dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">所以每个组件都被安装，然后卸载，最后再重新安装一次？🤔</strong></p><p id="99c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，现在就是这样。如果我们像这样使用<code class="fe lp lq lr lf b">useEffect()</code>钩子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="e3e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">刷新页面后，输出将是</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="ba9d" class="lj lk iq lf b gy ll lm l ln lo">Mounting...<br/>Unmounting...<br/>Mounting...</span></pre><p id="25dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能真的令人困惑，因为它还没有在<a class="ae lb" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">使用效果文档</a>中提及。幸运的是，丹·阿布拉莫夫已经<a class="ae lb" href="https://github.com/facebook/react/issues/24502#issuecomment-1118846544" rel="noopener ugc nofollow" target="_blank">回复了Github的一个问题</a>，这个棘手的行为将在React文档的新版本中描述。他还介绍了在使用<code class="fe lp lq lr lf b">useEffect()</code>钩子获取数据时处理它的方法，这样它就不会获取两次。</p><p id="3496" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总结</strong></p><p id="001b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React 18引入了一个新的开发专用的严格模式检查。该检查自动卸载和重新装载组件，使useEffect挂钩在初始装载时触发两次。</p></div></div>    
</body>
</html>