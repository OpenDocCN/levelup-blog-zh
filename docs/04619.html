<html>
<head>
<title>Dynamic Graphics Generation: The Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态图形生成:画布</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamic-graphics-generation-the-canvas-cac98ace99c3?source=collection_archive---------4-----------------------#2020-07-06">https://levelup.gitconnected.com/dynamic-graphics-generation-the-canvas-cac98ace99c3?source=collection_archive---------4-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/529032d46541593e52b344dfb7078d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2Ar7H7FTYN1hUqqPChCbw.png"/></div></div></figure><p id="4ae8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">HTML5是最新的、得到普遍支持的、向后兼容的HTML版本，也是增加了<strong class="ka ir"> canvas </strong>元素的版本。简而言之，它创建了一个绘图空间，用于创建各种各样的动态图形，只使用基本级别的HTML和普通脚本。</p><p id="4f68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，为了清楚地理解canvas的核心要点，我们将介绍最常用的方法、属性和形状。接下来，您需要知道开始构建自己的交互式动画画布页面的步骤。然后简单地说，canvas如何与类似功能的其他选项相比较，以及该领域中更高级开发的下一步可能会带您到哪里。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="d1a6" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">能力</h1><p id="7ea1" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">实际上，您可以使用HTML5 Canvas元素构建数量惊人的东西。因为它让您可以在如此详细的级别上控制绘图区域，所以可以创建从静态图像和图表到各种复杂的动画和完全充实的2D游戏(或者，甚至是借助外部Javascript API(特别是WebGL，将在本文后面讨论)的3D)的任何东西。</p><p id="134f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">用例:</strong></p><ul class=""><li id="d6f9" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">任何种类的动画或动态图形</li><li id="5069" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">离线和在线游戏(在过去你可能必须使用Flash来创建)</li><li id="f047" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">互动的音频和视频</li><li id="dc05" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">静态图像、图表或其他特征</li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="392b" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">基本画布术语</h1><p id="9e01" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated"><strong class="ka ir">上下文— </strong>这是在开始使用canvas元素之前需要为其设置的绘图/渲染上下文。基本上，它决定了绘图区域的具体用途。</p><p id="6316" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为准备使用的canvas元素建立上下文的方法是通过<strong class="ka ir"> getContext </strong>方法。该方法返回一个“超级对象”,其中堆叠了所有操作所选上下文的特性所需的东西(2d组件、3d渲染、图像位图等)。).</p><p id="bf2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">路径— </strong>由线连接的点的列表。用画布形成除了矩形以外的任何东西将通过把一个或多个路径的一些版本放在一起使用。</p><p id="9571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">网格原点— </strong>你可以看出，画布创建的绘图空间内部本质上是一个网格，其中每个网格单元等同于一个画布像素。画布内所有内容的定位都基于其相对于网格原点(即左上角点或坐标(0，0))在任何方向上的相对距离。</p><h2 id="7146" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">添加书签的方法:</h2><p id="eb10" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">具体来看一下2D上下文的用法，这是本文中的焦点画布示例，您需要熟悉几个方法，只是为了了解您使用它们的频率。</p><p id="1177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦您将前面提到的<strong class="ka ir"> canvas.getContext('2d') </strong>的结果保存到一个变量中，这些方法就可用了。</p><p id="0c7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">填充— </strong>。填充()<br/>采取一个形状，并给予内部区域固体内容。<br/>根据你要画的形状，可能会有一种特定的填充方法来画出一个形状并立即填充它(矩形用fillRect ),而不是使用<strong class="ka ir">。画完形状后填充</strong>。</p><p id="d660" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">笔画— </strong>。stroke() <br/>为形状创建轮廓，而不是实心的填充内容。<br/>这里最重要的是(与fill方法相同)，即使你成功地将对象绘制到画布上，<strong class="ka ir">在调用填充或描边之前，不会显示任何对象。</strong></p><h2 id="8f2b" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">属性:</h2><p id="3c8f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated"><strong class="ka ir">风格— </strong>。填充样式<strong class="ka ir">或</strong>。strokeStyle <br/>这些属性控制形状的“样式”或颜色，无论是形状的内部填充还是轮廓，分别为^.<br/>这里要设置的值将是一个CSS颜色类型的字符串，它可以是您可以在实际CSS中设置的任何内容:</p><ul class=""><li id="2980" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">CSS颜色名称(“橙色”)</li><li id="e374" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">十六进制代码(" #RRGGBB ")</li><li id="1659" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">十进制代码(' rgb(R，G，B)')</li><li id="6c14" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">渐变对象</li><li id="9651" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">模式对象</li></ul><p id="1b14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果在调用fill或stroke方法之前没有设置fillStyle或strokeStyle，形状的默认颜色将是黑色。</p><p id="3b21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦用这些方法中的任何一种设置了任何样式，每个进行中的形状都将采用最后设置的颜色。所以请记住，如果你想让单个元素有不同的颜色，你必须在元素填充或笔画调用之前直接调用合适的样式方法。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="487a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">它是如何工作的？</h1><p id="bc97" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">要获得一个支持画布的页面，使静止的或移动的、可变的元素运行起来，所需要的只是一个HTML文件(正如你<strong class="ka ir">应该</strong>有一个单独的脚本文件，其中有你很可能必须添加的大量代码，但技术上来说没有必要，可以将它们全部包含在HTML中的&lt;脚本&gt;部分)。</p><p id="1874" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">HTML</strong></p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8c63bf96409a57629aa5f97574f51188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*w31O6moIXILz-vxp1Bvz-w.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">在index.html中设置，画布元素首先在这里创建。</figcaption></figure><p id="f006" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里很容易看到，因为画布基本上只是另一个HTML元素:</p><ul class=""><li id="ebde" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">它必须像往常一样创建。<strong class="ka ir"><em class="np">&lt;canvas&gt;&lt;/canvas&gt;</em></strong><em class="np"/>标签具有相同的可添加的公共属性，如id、类等。</li><li id="d7f7" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">元素本身的任何样式都可以在头部的style标记中进行(这是为画布设置边框、将显示的背景颜色从白色更改为白色、删除在页面周边和侧面之间创建间隙的边距等操作的地方)。).或者如果还有更多，你显然可以选择创建和链接一个外部CSS文件。</li><li id="80f8" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">然后，像往常一样，我们链接负责JavaScript代码的文件，这些代码将控制我们在画布中构建的任何东西。</li></ul><p id="7a43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还应该承认，在上面的index.html示例中，已经设置了一个默认显示值(“Canvas不能在这个浏览器版本中使用”)。虽然canvas是HTML 5(HTML的最新版本)的一部分，但它在大多数较旧版本的浏览器中不受支持。还有一种情况是，一些浏览器禁用了JavaScript，在这种情况下，canvas元素也不会显示。<br/> <strong class="ka ir">最好的做法是通过一些伪值通知用户，为什么页面上没有呈现任何东西。</strong></p><p id="81fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">JavaScript</strong></p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/8a1db4b3e962d272bc2e37c65fb4044d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pR85X70nZva7wTpRw99pxA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">为画布元素设置。这些事情应该在任何对象创建尝试之前完成。</figcaption></figure><p id="8e7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，已经在HTML中创建了canvas元素，接下来必须识别它，在实际代码中保存对它的引用，以便可以管理它的所有方面。在这里我们:</p><ul class=""><li id="d13e" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">找到我们想要使用的特定画布(这个例子只需要找到canvas元素就可以了，因为在这个例子中，页面上只存在一个元素。如果有更多的，id可以被设置，他们会发现这种方式代替。)并设置为canvas变量。</li><li id="5a5e" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">安排画布的大小以适合整个屏幕，而不是画布及其绘图区域大小默认为的<br/><em class="np">300 px</em><strong class="ka ir">W</strong><strong class="ka ir">x</strong><em class="np">150 px</em><strong class="ka ir">H</strong>。</li><li id="f055" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">设置画布的上下文，确定哪个对象将被返回并被设置为c变量(c实际上通常被用作上下文的缩写名称，因为它在整个代码中被频繁使用，所以一位数的长度更为理想)。</li></ul><p id="f218" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从那以后，它实际上主要是一些简单的几何问题。理解一个非常基础的层次将允许您在画布上创建任意数量的对象，并同时或单独控制它们，设置它们在指定区域内如何移动和移动到哪里的限制，以及它们如何相互反应，以及(可选)用户输入。</p><p id="60d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><h2 id="b2e8" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">创建简单形状:</h2><p id="9b9d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">canvas包含了两种形状的创建功能:<strong class="ka ir">矩形</strong> &amp; <strong class="ka ir">路径</strong>。作为简单到更复杂绘图的基础构件，这两个图元可用于形成您可能需要的任何形状。</p><p id="f13c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本着提供足够有用的形状的精神，同时仍然给你一些容易动画的东西，我们将看看这三个主要的:矩形，直线和圆形。</p><p id="60f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">长方形</strong></p><p id="93a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于矩形，有两种主要方法来绘制形状:</p><ul class=""><li id="9c37" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">。rect() </strong>是创建矩形的基本方式。接下来你必须调用<strong class="ka ir"> stroke() </strong>或<strong class="ka ir"> fill() </strong>来查看你的矩形出现在页面上。</li><li id="c8d7" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">第二种也是更快捷的方法是使用一种结合绘制和填充/描边步骤的方法。也就是说，您不必继续调用另一个方法来查看它在画布中的显示。<br/>在一组快捷选项中，你可以选择画一个空心或实心的矩形:用<strong class="ka ir"> strokeRect </strong>或<strong class="ka ir"> fillRect </strong>。</li></ul><p id="5fe4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论您决定使用哪一种，矩形函数的所有版本都采用相同的参数来创建形状:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/aa7d36df503cca08ea21e0c965d4c575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PF9Zo9s-gPqzF4kPrmCt8Q.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">用于设置矩形左上角的(x，y)坐标相对于画布的左上角(网格的“原点”)。</figcaption></figure><p id="25d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">线条</strong></p><p id="47d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">路径用于在画布上画线，在画布上，它们可以在任何点被其他线扩展，并添加在该路径的相关<strong class="ka ir"> endPath() </strong>调用之前出现的新的点坐标集。</p><p id="e24b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很容易想象，如果你把它想象成你在纸上手工画一条线:</p><ul class=""><li id="269a" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">你决定划清界限。<br/>(在画布中:这是通过<strong class="ka ir"> beginPath() </strong>完成的，表示一条路径即将被创建，并将通过调用<strong class="ka ir"> stroke() </strong>或<strong class="ka ir"> fill() </strong>继续)</li><li id="797d" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">你选择一个起点，把你的铅笔移向它。<br/>(在canvas中:您将使用<strong class="ka ir"> moveTo() </strong>传递线条开始的坐标，这将把绘图光标移动到网格上的该点并开始绘制线条)</li><li id="2e10" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">当你画线的时候，你就决定了线中包含的点。<br/>(在画布中:我们将它们标识为子路径，并将使用<strong class="ka ir"> lineTo() </strong>方法添加它们，该方法获取当前线段的“端点”,并将前一个点连接到它)</li><li id="2298" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">一旦你到达终点，你就选择了终点。<br/>(在画布中:我们想表示当前路径(线)已经完成，此时不会再添加。我们希望确保我们的线条出现，我们调用<strong class="ka ir"> stroke() </strong>或<strong class="ka ir"> fill() </strong>。)</li></ul><p id="b239" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> moveTo </strong>和<strong class="ka ir"> lineTo </strong>函数都接受(x，y)坐标参数。在我们上面提到的常规画线过程之外，还有一个<strong class="ka ir"> closePath() </strong>，它可以在最后一个<strong class="ka ir"> lineTo </strong>之后调用，并将连接线条的终点和初始起点(这可以用于多种不同的用途，但创建三角形是最有用的用途之一)。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/8853c8bc5f015e08e41267ff3209a953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xyTgfgeNVn0sMaN44ysig.png"/></div></div></figure><p id="e167" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">圆圈</strong></p><p id="1aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">画布没有指定的圆形，但允许创建圆弧。通过一些非常简单的操作，我们可以使用arc类型来绘制一些圆，并将它们放在页面上，这样我们就可以开始制作它们的动画了。</p><ul class=""><li id="3ac5" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">你仍然从<strong class="ka ir"> beginPath() </strong>，<strong class="ka ir"> </strong>开始，就像你在画一条上面显示的直线一样。</li><li id="9de2" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">。arc() </strong>是负责将曲线绘制到画布上的方法，它接受x坐标、y坐标、半径以及开始和结束“角度”(这意味着作为弧度而不是实际的角度传递)。</li><li id="f490" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">在绘制出弧线之后，您可以设置样式(可选)并像往常一样调用<strong class="ka ir"> stroke() </strong>或<strong class="ka ir"> fill() </strong>方法，使其着色并显示在页面上。</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/894a462b719d3e46e88414d347c907fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*mA6878ZM-rpZ0ALa9HqHeA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">上例中显示的arc的最后一个参数是可选参数，它允许逆时针绘制弧线。它默认为false(将它设置为顺时针绘制。虽然true会将它设置为逆时针绘制弧线)，但仍作为false包含在上面，以表明它是一个可能的添加参数。</figcaption></figure><p id="18ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><h2 id="b8b1" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">创建简单的动画:</h2><p id="127c" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">对于动画和交互性代码示例和解释，我们将保持简洁，只关注如何在画布上为一个圆形元素实现这些目标，而不是为上面创建的所有三个形状。</p><p id="3476" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一部分将分为两部分:</p><ol class=""><li id="510d" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv nu mm mn mo bi translated">内在的运动:看一看画布本身的变换。</li><li id="3856" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv nu mm mn mo bi translated">自定义动画:创建自己的动画和运动。</li></ol><p id="3c3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">内置机芯</strong></p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/89b81c268c98fdb44ba688b2b19cd47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcqBl-Ih_y8KuvPa4Bb1Hw.png"/></div></div></figure><p id="375c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些转换包含在从代码开头的<strong class="ka ir">get context(</strong>‘2d’<strong class="ka ir">)</strong>返回的上下文对象中。在我们到目前为止看到的例子中，它们将通过"<strong class="ka ir"> c </strong>"变量来访问(见下文)。</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="203c" class="mu le iq nx b gy ob oc l od oe">const canvas = document.querySelector('canvas');<br/>const c = canvas.getContext(“2d”);</span><span id="0861" class="mu le iq nx b gy of oc l od oe">c.rotate(20 * Math.PI / 180); <br/>c.fillRect(200, 40, 100, 50);</span></pre><p id="ab66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">* *具体来说，Where rotate将只影响调用rotate方法后创建的形状。**</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="77f0" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">下一关</h1><p id="9892" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">从画布包含的2D背景过渡到3D开发并不是一个巨大的飞跃，你已经看到了这一点。WebGL是一个API，允许渲染2D或3D web内容，因为它是为了与canvas一起工作而创建的，所以它可以作为我们在本文开始时了解的上下文函数的参数选项。</p><p id="d4b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着在开始使用WebGL之前，您需要修改的canvas脚本代码中的唯一一行是getContext行。它可能看起来像这样:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e887c7a2abbc61cfb9415cd1e58daf2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*Pkxh_GXxRlZzXxxAtKrIyA.png"/></div></figure><p id="b2a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要认识到，有许多框架简化了WebGL的功能，使构建相同的三维游戏和应用程序变得更加容易(three.js是最著名的一个)。但是，这并没有降低知道如何独立使用框架种子的价值(毕竟，你认为three.js和其他类似的框架是如何构建的)。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="1169" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论:</h1><ul class=""><li id="07f1" class="mg mh iq ka b kb mb kf mc kj oh kn oi kr oj kv ml mm mn mo bi translated">Canvas是HTML中的嵌入式元素，这意味着它本质上是DOM的一部分，可以与DOM和其中的任何其他元素进行交互。这将使它自动位于任何嵌入的外部文件之前。</li><li id="2170" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">作为HTML5的一部分，canvas本身受到web浏览器的支持，不需要任何类型的插件安装(像Flash这样的其他选项需要)，也不需要用户承担任何保持安装版本的责任。</li><li id="36e5" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">学习如何使用只需要很少的时间，因为它只是模糊地熟悉一些用于创建图形的技术，对于任何已经知道脚本语言的人来说，他们已经拥有了添加功能的技能。</li></ul><p id="d1dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会惊讶地发现，一些没有任何外部API帮助的动画是多么的先进；以及在3D附加组件的帮助下你能走多远。值得一试这些严肃的画布使用的例子，并为你自己的画布项目获取一些灵感。</p><p id="6c79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ok" href="https://code.tutsplus.com/articles/21-ridiculously-impressive-html5-canvas-experiments--net-14210" rel="noopener ugc nofollow" target="_blank">画布项目</a><br/>T3】web GL&amp;画布项目</p><h2 id="1e11" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">感谢您的阅读！</h2></div></div>    
</body>
</html>