<html>
<head>
<title>How to Create AWS Lambda in Java 11</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java 11中创建AWS Lambda</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-aws-lambda-in-java-11-9b034a73d399?source=collection_archive---------8-----------------------#2021-07-10">https://levelup.gitconnected.com/how-to-create-aws-lambda-in-java-11-9b034a73d399?source=collection_archive---------8-----------------------#2021-07-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="2f8d" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">以下是Lambda部署所需的内容</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/5c8755b5070b3ac74d5120d30e7e1c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XmXXlPXxNksBx7m_.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://medium.com/kredx-engineering/aws-lambda-best-practices-e15724fd02d3" rel="noopener">来源</a></figcaption></figure><p id="dbd7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">部署AWS Lambda很难。从我自己的经验来看，用Java实现Lambda更难。</p><p id="3bde" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本教程将帮助您创建Lambda并将其部署到AWS。这里是你在Java 11中构建Lambda所需要的。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="f8e0" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">Lambda代码是什么？</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="8c75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Lambda实现了类<code class="fe my mz na nb b">RequestHandler&lt;IN, OUT&gt;</code>。Type <code class="fe my mz na nb b">IN</code>是lambda的输入类型。式中<code class="fe my mz na nb b">OUT</code>是λ结果的类型。您需要为类型<code class="fe my mz na nb b">IN</code>提供Jackson反序列化。类型<code class="fe my mz na nb b">OUT</code>可以是一个简单的字符串化JSON。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">请求体输入模型</figcaption></figure><p id="6db6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要定位端点，因此需要配置<code class="fe my mz na nb b">WebClient</code>。对于本教程，SSL设置为不安全。在生产中，应该设置安全<code class="fe my mz na nb b">TrustManagerFactory</code>。要配置HttpClient进行日志记录，我们可以使用<code class="fe my mz na nb b">wiretap</code>方法。部署时，日志将在<code class="fe my mz na nb b">CloudWatch</code>中提供。</p><p id="c1a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一个请求需要一个自定义表单作为主体。我们在主体中设置了<code class="fe my mz na nb b">Mono#just</code>。如果没有问题，我们继续第二个请求。</p><p id="ad4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二个请求没有请求体，但有一个查询参数。我们使用<code class="fe my mz na nb b">WebClient#uri</code>方法放置参数。在<code class="fe my mz na nb b">retrieve</code>完成之后，我们以<code class="fe my mz na nb b">String</code>的格式返回响应。</p><p id="a2a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">端点在<code class="fe my mz na nb b">Dockerfile</code>中。另一种选择是使用<code class="fe my mz na nb b">application.properties</code>。因为简单的覆盖，我使用了Docker属性。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="664b" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">属国</h1><p id="6b77" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">AWS所需要的就是<code class="fe my mz na nb b">aws-lambda-java-runtime-interface-client</code>依赖性。这包含了<code class="fe my mz na nb b">RequestHandler</code>，以及我们稍后将使用的错误处理异常。</p><p id="2a9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我的lambda会触发两个端点。如果第一个端点成功，则定位第二个端点。我将使用<code class="fe my mz na nb b">WebClient</code>来处理HTTP请求。为了包含<code class="fe my mz na nb b">WebClient</code>，我们需要<code class="fe my mz na nb b">spring-boot-starter-webflux</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="f1c0" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">容器图像</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="e21b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker文件包含环境属性和命令。我将使用<code class="fe my mz na nb b">openjdk11</code>而不是15。前两个属性是env属性，都是我需要定位的端点。</p><p id="155e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将<code class="fe my mz na nb b">JAVA_TOOL_OPTIONS</code>设置为<a class="ae kz" href="https://stackoverflow.com/a/57892679/5999670" rel="noopener ugc nofollow" target="_blank">启用网络性能优化</a>。这些选项将允许访问netty的内部模块。lambda不一定要工作，但是你会得到警告。</p><p id="74e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们复制目标依赖项，并复制应用程序的实际jar。第一次复制操作将发生在依赖关系更改之后。当依赖关系没有变化时，Docker映像的创建速度会更快。第二个将打包的项目复制到docker映像中。</p><p id="7f16" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要将<code class="fe my mz na nb b">function/</code>和<code class="fe my mz na nb b">AWSLambda</code>放在类路径中。<em class="lw">为什么？</em>所以我们可以在<code class="fe my mz na nb b">Dockerfile</code>的<code class="fe my mz na nb b">CMD</code>中调用<code class="fe my mz na nb b">handleRequest</code>方法。<code class="fe my mz na nb b">CMD</code>将与<code class="fe my mz na nb b">ENTRYPOINT</code>连接，这将执行我们的处理程序。</p><p id="e87b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看构建过程是如何工作的。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="71b0" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">构建流程</h1><p id="8ea9" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">构建jar文件是用<code class="fe my mz na nb b">mvn compile package</code>完成的。下面是pom.xml。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://rieckpil.de/java-aws-lambda-container-image-support-complete-guide/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="a657" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">完成后，你需要创建<code class="fe my mz na nb b">Docker</code>图像。</p><pre class="kk kl km kn gu nh nb ni nj aw nk bi"><span id="ccdb" class="nl mf iu nb b gz nm nn l no np">docker build . -t test-lambda:latest</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="dd7d" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">如何在本地进行测试</h1><p id="1fc5" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">你需要先为你的机器安装Docker。为了在本地测试，你需要AWS Lambda RIE。安装RIE，把可执行文件放到path中，然后你就可以运行docker容器了。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="e70d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个命令将旋转一个监听端口<code class="fe my mz na nb b">9000</code>的Docker容器。与Dockerfile中的一样，您需要使用<code class="fe my mz na nb b">-cp</code>将类放到类路径中。最后一个类<code class="fe my mz na nb b">(com.zivce.aws.TestLambda)</code>是实现AWS <code class="fe my mz na nb b">RequestHandler</code>的类。</p><p id="308f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">如何测试实现？以下是方法。</em></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="fe53" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你需要用<code class="fe my mz na nb b">requestBody</code>瞄准端口<code class="fe my mz na nb b">9000</code>。<code class="fe my mz na nb b">requestBody</code>的类型需要是<code class="fe my mz na nb b">RequestBody</code>。</p><p id="6b2c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来处理错误。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="8d2c" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">如何处理Lambda错误</h1><p id="ed2e" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">使用<code class="fe my mz na nb b">WebClient#onStatus</code>方法进行错误处理。<code class="fe my mz na nb b">onStatus</code>的消费者有以下签名<code class="fe my mz na nb b">Function&lt;ClientResponse, Mono&lt;? extends Throwable&gt;&gt; errorHandler</code>。</p><p id="0d77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">错误处理程序的输入是保存错误的<code class="fe my mz na nb b">ClientResponse</code>。输出是<code class="fe my mz na nb b">Mono&lt;Throwable&gt;</code>，在我们的例子中，它是<code class="fe my mz na nb b">LambdaRuntimeClientException</code>的子类。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="056b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你应该有异常内的<code class="fe my mz na nb b">statusCode</code>。<em class="lw">为什么？</em>因为错误过滤，你需要在API网关上做。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="7cd9" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">如何将Lambda部署到ECR</h1><p id="7b1c" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">首先，您需要登录AWS ECR。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="8b1d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为您的<code class="fe my mz na nb b">Docker</code>图像创建存储库。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="178c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构建、标记和推送您的图像到ECR。</p><p id="2743" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">连接容器镜像和API网关在这里<a class="ae kz" href="https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/" rel="noopener ugc nofollow" target="_blank">描述</a>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="8bec" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">参考</h1><p id="e163" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">[1] <a class="ae kz" href="https://rieckpil.de/java-aws-lambda-container-image-support-complete-guide/" rel="noopener ugc nofollow" target="_blank"> Java AWS Lambda容器教程</a></p></div></div>    
</body>
</html>