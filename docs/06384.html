<html>
<head>
<title>The Decorator Pattern In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的装饰模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-decorator-pattern-in-go-66ed951b0f7c?source=collection_archive---------4-----------------------#2020-11-20">https://levelup.gitconnected.com/the-decorator-pattern-in-go-66ed951b0f7c?source=collection_archive---------4-----------------------#2020-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="96f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终产品出奇地令人满意。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b5ecc55b92931e697e43a813193e6c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5o1BE0cajXpIXH7Z.jpg"/></div></div></figure><p id="5d17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi la translated">装饰模式是创建前瞻性代码的一种非常有用和灵活的技术。它允许您在运行时而不是编译时动态地向对象添加功能。这意味着您不必手动编写新代码来扩展对象的特性集，您可以简单地使用decorator模式来添加您需要的行为！</p><p id="c3fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它还解决了被广泛的子类架构所限制的问题。装饰模式没有迷失在继承中，而是使用了许多更小的类(在Go的情况下是structs ),以便将功能包装在其他对象周围。这样，我们可以拥有许多具有不同功能的对象，而不必定义每个单独的类。</p><p id="cd60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将把这篇文章分成三个部分，包括用例、UML图和装饰模式的实现。</p><h2 id="1051" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">用例</h2><p id="3713" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">装饰器模式可以应用于各种各样的情况和场景。其中包括:</p><ul class=""><li id="7c75" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">购物车——每个商品都可以包装在一个中央客户订单对象上，以便跟踪总订单价格。</li><li id="4e0a" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">数据流—当您传输数据时，您可能会发现您需要加密、压缩或格式化行为的各种组合，这取决于客户端的需求。</li><li id="461d" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">遗留代码——如果您有一个无法更改但需要扩展其功能的对象，那么您可以使用Decorator模式来实现。</li></ul><h2 id="8bf6" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">UML图</h2><p id="07ea" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这种模式需要一个非常紧凑的图表。从顶层开始，组件接口需要实现方法<code class="fe mv mw mx my b">operation()</code>。这是由ConcreteComponent和Decorator对象本身完成的。注意Component和Decorator之间的聚合关系，这意味着一个组件可以有零到多个Decorator，但是一个Decorator不能没有Component而存在。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/e8e59297810ebdf3421a9237eca1affe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TasvPb0Saw7IvluM.png"/></div></div></figure><p id="2ca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本质上，我们有一个组件接口，其最基本的形式是由ConcreteComponent实现的。然后装饰器可以由ConcreteDecorator实现，并包装在ConcreteComponents周围。</p><h2 id="471b" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">Go中的实现</h2><p id="af14" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">想象一下，你拥有一家比萨饼店，必须处理任何一种比萨饼的价格。你能定义每一种可能的比萨饼并决定每一种的价格吗？不要！你可能会在一个普通比萨饼上标明价格，然后根据添加的配料提高价格。这就是Decorator成为一个非常有用的模式的原因。</p><p id="48aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们构建我们的项目结构。</p><pre class="kp kq kr ks gt na my nb nc aw nd bi"><span id="b883" class="lj lk it my b gy ne nf l ng nh">$ mkdir decorator-pattern-go<br/>$ cd decorator-pattern-go<br/>$ touch main.go pizza.go toppings.go</span></pre><h2 id="2682" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">披萨，去吧</h2><p id="ae4f" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">首先，我们用<code class="fe mv mw mx my b">getPrice()</code>和<code class="fe mv mw mx my b">getCalories()</code>方法定义了一个<code class="fe mv mw mx my b">pizza</code>接口，作为我们的组件。然后，我们定义了代表具体组件的<code class="fe mv mw mx my b">cheesePizza</code>结构。这是我们将要制作的比萨饼的最基本版本。</p><p id="2c6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们用<code class="fe mv mw mx my b">newCheesePizza()</code>创建Go版本的构造函数，该构造函数返回对一个<code class="fe mv mw mx my b">cheesePizza</code>的引用，该引用包含卡路里数及其价格的初始值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6101" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们通过将对<code class="fe mv mw mx my b">cheesePizza</code>的引用传递给<code class="fe mv mw mx my b">getPrice()</code>方法来实现<code class="fe mv mw mx my b">pizza</code>接口。由于<code class="fe mv mw mx my b">cheesePizza</code>是我们的基本具体组件，我们只返回它的价格(我们稍后将添加它)。</p><h2 id="6fa8" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">浇头，开始</h2><p id="ee7d" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">接下来我们定义浇头。这里没有发生太多的事情，实际上只是一些我们一遍又一遍重新定义的操作。</p><p id="fcd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们定义给定配料的不变价格和卡路里数。接下来，我们将topping定义为一个结构，并从它扩展<code class="fe mv mw mx my b">pizza</code>接口。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1b3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们通过向<code class="fe mv mw mx my b">getCalories()</code>和<code class="fe mv mw mx my b">getPrice()</code>方法传递一个toppings引用来实现<code class="fe mv mw mx my b">pizza</code>接口。它们只是返回基本的比萨饼价格/卡路里数，然后添加我们定义的常数。很简单吧？</p><h2 id="4ba5" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">main.go</h2><p id="acc5" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">为了完成我们的项目，我们可以实现作为客户端的main.go文件。你看到我们是如何从底部开始，然后用浇头包裹它的吗？每次我们这样做，我们就增加了比萨饼的总热量和价格。这是装修！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="be9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，当我们用浇头包装<code class="fe mv mw mx my b">cheesePizza</code>时，<code class="fe mv mw mx my b">getPrice()</code>和<code class="fe mv mw mx my b">getCalories()</code>方法执行添加到基础价格和卡路里值的调用链。</p><p id="52a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们运行这个项目，我们将得到以下输出。</p><pre class="kp kq kr ks gt na my nb nc aw nd bi"><span id="080c" class="lj lk it my b gy ne nf l ng nh">$ go run *.go<br/>Price of theBombPizza is $15.25 with 1050 calories.<br/>Price of pepperoniPizza is $11.75 with 700 calories.</span></pre><p id="7c78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我个人认为，当你得到最终结果时，装饰者模式是如此令人满意。:)</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="6582" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">装饰模式允许我们动态地向对象添加功能。这避免了我们需要定义无数特定的结构/类类型，并允许我们的代码更加动态。然而，某些缺点可能包括大量的辅助对象和重复代码，所以明智地选择您的模式吧！</p><p id="5c38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢阅读这篇文章，并学到一些新的东西。如果有你喜欢的或想听更多的部分，请在下面留下评论！感谢阅读。</p></div></div>    
</body>
</html>