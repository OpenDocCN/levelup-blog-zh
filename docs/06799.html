<html>
<head>
<title>React template for JWT authentication with private routes and redirects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用私有路由和重定向进行JWT身份验证的React模板</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-template-for-jwt-authentication-with-private-routes-and-redirects-f77c488bfb85?source=collection_archive---------0-----------------------#2021-01-03">https://levelup.gitconnected.com/react-template-for-jwt-authentication-with-private-routes-and-redirects-f77c488bfb85?source=collection_archive---------0-----------------------#2021-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/115f9baca94b210b8d59799022aacb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTo1mO1-x7zwzVrLPaAc6g.png"/></div></div></figure><p id="a60c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本指南是在React与MERN应用程序中使用JWT身份验证的模板。此代码可以用作模板，并根据需要进行调整，以用于具有JWT身份验证的React应用程序。完整的代码库是<a class="ae kw" href="https://github.com/jawblia/auth" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="f16e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模板用于将用户数据存储在仅HTTP的cookie(非localStorage)中，并通过该cookie访问用户的JWT令牌。我们不能在浏览器中直接读取cookie，所以我们必须从后端获取JWT信息，使用这个配方和<strong class="ka ir"> React定制钩子、React前端组件、</strong>和一个<strong class="ka ir">服务器</strong> <strong class="ka ir">调用:</strong></p><ul class=""><li id="10d5" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir"> React自定义钩子:</strong>前端(客户端)向后端(服务器)发出读取cookie的请求。</li><li id="68d9" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">服务器调用:</strong>后端通过API调用读取cookie，解码JWT(如果有的话)，并将结果发送给前端。</li><li id="da5f" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> React frontend组件:</strong>如果用户被返回，它们被存储在frontend的全局上下文中。该上下文允许应用程序引用用户并允许他们访问受保护的路线。如果用户未返回，他们将无法访问受保护的路由。</li></ul><p id="3f0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下图解释了我的FE组件如何与我的定制钩子交互:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/21e020614509018e7f96bbc553de0de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CasLcsRmlZatfYAbe2RVVA.png"/></div></div></figure><p id="1859" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个应用程序的后端是一个<strong class="ka ir"> Express服务器</strong>，数据库是<strong class="ka ir"> MongoDB </strong>。自定义钩子将处理我的状态(没有状态管理库)。路由由<strong class="ka ir"> React路由器处理。由<strong class="ka ir"> Axios </strong>处理的API调用。本指南将主要关注前端的React部分，不会深入到后端。但是，我将展示我为身份验证制作的API。如果您只对前端感兴趣，请跳过<strong class="ka ir">认证API </strong>部分，转到<strong class="ka ir">步骤1。</strong></strong></p><p id="9609" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有步骤:</p><ol class=""><li id="0ef0" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lq ld le lf bi translated"><strong class="ka ir">创建上下文来存储用户，</strong>这样他们就可以在整个应用程序中被访问。</li></ol><p id="5138" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2a。<strong class="ka ir"> Cookie一个用户，并在登录或注册时将他们存储在上下文中</strong>，这样他们的会话将会持续。</p><p id="aa11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2b。创建一个<strong class="ka ir">定制钩子，检查用户到达站点时是否有会话cookie </strong>。</p><p id="319f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.将用户存储在<strong class="ka ir">全局上下文中。</strong></p><p id="7acc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.为认证用户创建<strong class="ka ir">私有路由</strong>。</p><p id="f91a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.<strong class="ka ir">重定向用户并根据验证状态有条件地呈现组件</strong>。</p><h2 id="83eb" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated"><strong class="ak">先决条件:认证API </strong></h2><p id="c71c" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我必须使用不同的路由器:<strong class="ka ir"> viewRouter </strong>，用于页面视图上的调用(检查用户是否登录)，以及<strong class="ka ir"> authRouter </strong>，用于注册、登录和注销。这个在我的app.js里。</p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="2146" class="lr ls iq mq b gy mu mv l mw mx">app.use('/', viewRouter);</span><span id="923d" class="lr ls iq mq b gy my mv l mw mx">app.use('/auth/', authRouter);</span></pre><p id="ae38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">T28】auth router . js</strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="39e1" class="lr ls iq mq b gy mu mv l mw mx">const express = require('express');<br/>const authController = require('./../controllers/authController');<br/>const router = express.Router();</span><span id="0f92" class="lr ls iq mq b gy my mv l mw mx">router.post('/register', authController.registerUser);<br/>router.post('/login', authController.loginUser);<br/>router.get('/logout', authController.logoutUser);</span><span id="0f5a" class="lr ls iq mq b gy my mv l mw mx">module.exports = router;</span></pre><p id="bb95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> &gt; viewRouter.js </strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="c4cc" class="lr ls iq mq b gy mu mv l mw mx">const express = require('express');<br/>const authController = require('../controllers/authController');<br/>const router = express.Router();</span><span id="7fce" class="lr ls iq mq b gy my mv l mw mx">router.get('/user', authController.checkUser);</span><span id="0ab2" class="lr ls iq mq b gy my mv l mw mx">module.exports = router;</span></pre><p id="fc0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些逻辑都在我的authController组件中处理，它有不同的功能用于<strong class="ka ir">登录、注册、注销、设置令牌和签名令牌。我将把这段代码留在下面，但是其余的样板文件，比如用户模式和错误处理，将放在<a class="ae kw" href="https://github.com/jawblia/auth" rel="noopener ugc nofollow" target="_blank">代码库中</a>。</strong></p><p id="bc3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> &gt; authController.js </strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="ab02" class="lr ls iq mq b gy mu mv l mw mx">const User = require('./../models/userModel');<br/>const AppError = require('./../utils/AppError');<br/>const catchAsync = require('./../utils/catchAsync');<br/>const jwt = require('jsonwebtoken');<br/>const { promisify } = require('util');</span><span id="47d8" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">//sign JWT token for authenticated user<br/></strong>const signToken = id =&gt; {<br/>   return jwt.sign({ id }, process.env.JWT_SECRET, {<br/>          expiresIn: process.env.JWT_EXPIRES_IN<br/>   });<br/>}<br/></span><span id="66ec" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">//create JWT token for authenticated user</strong><br/>const createUserToken = async(user, code, req, res) =&gt; {<br/>    const token = signToken(user._id);<br/>    //set expiry to 1 month<br/>    let d = new Date();<br/>    d.setDate(d.getDate() + 30);<br/>  <br/>     //first-party cookie settings<br/>    res.cookie('jwt', token, {<br/>       expires: d,<br/>       httpOnly: true,<br/>       secure: req.secure || req.headers['x-forwarded-proto'] ===   'https',<br/>       sameSite: 'none'<br/>    });</span><span id="ae55" class="lr ls iq mq b gy my mv l mw mx">    //remove user password from output for security<br/>    user.password = undefined;<br/>    res.status(code).json({<br/>       status: 'success',<br/>       token,<br/>       data: {<br/>          user<br/>        }<br/>      });<br/>    };<br/></span><span id="d59f" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">//create new user<br/></strong>exports.registerUser = async(req, res, next) =&gt; {<br/>     //pass in request data here to create user from user schema<br/>     try {<br/>       const newUser = await User.create({<br/>           username: req.body.username,<br/>           email: req.body.email,<br/>           password: req.body.password,<br/>           passwordConfirm: req.body.passwordConfirm<br/>      });</span><span id="406a" class="lr ls iq mq b gy my mv l mw mx">     createUserToken(newUser, 201, req, res);</span><span id="fc8b" class="lr ls iq mq b gy my mv l mw mx">     //if user can't be created, throw an error<br/>     } catch(err) {<br/>         next(err);<br/>     }<br/>   };</span><span id="c42e" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">//log user in</strong></span><span id="1aa9" class="lr ls iq mq b gy my mv l mw mx">exports.loginUser = catchAsync(async(req, res, next) =&gt; {<br/>     const { username, password } = req.body;<br/>     <br/>     //check if email &amp; password exist<br/>     if (!username || !password) {<br/>     return next(new AppError('Please provide a username and password!', 400));<br/>}</span><span id="0022" class="lr ls iq mq b gy my mv l mw mx">    //check if user &amp; password are correct<br/>    const user = await User.findOne({ username }).select('+password');<br/>     if (!user || !(await user.correctPassword(password, user.password))) {<br/>     return next(new AppError('Incorrect username or password', 401));<br/>    }</span><span id="f088" class="lr ls iq mq b gy my mv l mw mx">    createUserToken(user, 200, req, res);</span><span id="34af" class="lr ls iq mq b gy my mv l mw mx">});</span><span id="344e" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">//check if user is logged in</strong></span><span id="b9e9" class="lr ls iq mq b gy my mv l mw mx">exports.checkUser = catchAsync(async(req, res, next) =&gt; {<br/>    let currentUser;</span><span id="a847" class="lr ls iq mq b gy my mv l mw mx">    if (req.cookies.jwt) {<br/>       const token = req.cookies.jwt;<br/>       const decoded = await promisify(jwt.verify)(token, process.env.JWT_SECRET);<br/>       currentUser = await User.findById(decoded.id);<br/>   } else {<br/>     currentUser =  null;<br/>  }<br/>   res.status(200).send({ currentUser });<br/>});</span><span id="273f" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">//log user out</strong></span><span id="6364" class="lr ls iq mq b gy my mv l mw mx">exports.logoutUser = catchAsync(async (req, res) =&gt; {<br/>    res.cookie('jwt', 'loggedout', {<br/>    expires: new Date(Date.now() + 10 * 1000),<br/>    httpOnly: true<br/>});</span><span id="1cf0" class="lr ls iq mq b gy my mv l mw mx">    res.status(200).send('user is logged out');<br/>});</span></pre><p id="4ef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是足够的样板文件——同样，整个服务器可以在<a class="ae kw" href="https://github.com/jawblia/auth" rel="noopener ugc nofollow" target="_blank">代码库中找到。本指南并没有涵盖<em class="mz">JWT是如何工作的，但是在底部会有更多的资源。</em></a></p><h1 id="f79e" class="na ls iq bd lt nb nc nd lw ne nf ng lz nh ni nj mc nk nl nm mf nn no np mi nq bi translated">步骤1:创建存储用户的上下文。</h1><p id="d9d4" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">将用户存储在上下文中允许在整个应用程序中访问他们的数据。</p><p id="ca3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要使用React的createContext和useContext挂钩将该用户存储在应用程序的全局上下文中。首先，我们必须使用createContext创建一个上下文实例:</p><p id="0725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> src &gt;钩子&gt; UserContext.js </strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="e3a6" class="lr ls iq mq b gy mu mv l mw mx">import { createContext } from 'react';</span><span id="535c" class="lr ls iq mq b gy my mv l mw mx">export const UserContext = createContext(null);</span></pre><p id="bcf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们的整个用户上下文。将UserContext的初始值设置为<strong class="ka ir"> null </strong>，因为最初没有用户。<em class="mz">注意:上下文实例是用大写字母命名的(像一个组件)，而不是小写字母(像一个钩子)。我将上下文实例存储在我的hooks文件夹中，因为它们的功能类似于钩子。</em></p><h1 id="5016" class="na ls iq bd lt nb nc nd lw ne nf ng lz nh ni nj mc nk nl nm mf nn no np mi nq bi translated">步骤2a: Cookie一个用户，并在登录或注册时将它们存储在上下文中。</h1><p id="9e00" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">当用户登录或注册时，会发生四件事:</p><ol class=""><li id="7943" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lq ld le lf bi translated">他们的浏览器中设置了一个带有JWT令牌和一个月预期寿命的cookie。</li><li id="2d80" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lq ld le lf bi translated">浏览器读取用户的JWT令牌。</li><li id="2928" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lq ld le lf bi translated">解码的用户是在应用程序的全局上下文中设置的。</li><li id="37f4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lq ld le lf bi translated">新认证的用户被推送到他们的主页。</li></ol><p id="8313" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经有两个不同的组件来处理登录和注册。每个人将使用两个自定义挂钩:1。useForm，它处理表单输入和状态，以及2。useAuth，它处理身份验证。我们将专注于使用授权。作为一个例子，我将显示注册，但登录的工作方式相同。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/aa980f66841648fd02a1341013949cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1UioVfa3GFtDfM28V-WSg.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">这是我的登记表</figcaption></figure><p id="10b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是上面页面的代码:</p><p id="c4d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> src &gt;页面&gt; Register.js </strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="4824" class="lr ls iq mq b gy mu mv l mw mx">import React from 'react';<br/>import { Link } from 'react-router-dom';<br/>import FormInput from './../components/FormInput';<br/>import CTA from './../components/CTA';<br/>import Prompt from './../components/Prompt';<br/>import ConfirmPasswordInput from './../components/ConfirmPasswordInput';<br/>import Error from './../components/Error';<br/>import useForm from './../hooks/useForm';<br/><strong class="mq ir">import useAuth from './../hooks/useAuth';</strong></span><span id="e790" class="lr ls iq mq b gy my mv l mw mx">export default function Register() {<br/>   const { values, handleChange} = useForm({<br/>        initialValues: {<br/>          email: '',<br/>          username: '',<br/>          password: '',<br/>          passwordConfirm: ''<br/>        }<br/>      });</span><span id="70d4" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">const { registerUser, error } = useAuth();</strong></span><span id="814b" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">const handleRegister = async (e) =&gt; {<br/>   e.preventDefault();<br/>   await registerUser(values);<br/>}</strong></span><span id="7b83" class="lr ls iq mq b gy my mv l mw mx">return(<br/>   &lt;div className="page" style={{justifyContent:'center'}}&gt;<br/>     &lt;div className="inlineForm"&gt;<br/>     &lt;h3&gt;Register&lt;/h3&gt;<br/>        &lt;div className="inlineForm__notif"&gt;<br/>           {error &amp;&amp; &lt;Error error={error.messages}/&gt;}<br/>        &lt;/div&gt;<br/><strong class="mq ir">     &lt;form onSubmit={handleRegister}&gt;<br/>         </strong>&lt;FormInput type={"text"} <br/>                    placeholder={"Email"}<br/>                    name={"email"}<br/>                    value={values.email}<br/>                    handleChange={handleChange} /&gt;<br/><strong class="mq ir">          </strong>&lt;FormInput type={"text"} <br/>                    placeholder={"Username"}<br/>                    name={"username"}<br/>                    value={values.username}<br/>                    handleChange={handleChange} /&gt;<br/>         &lt;ConfirmPasswordInput type={"password"} <br/>                    placeholder={"Password"}<br/>                    name={"password"}<br/>                    value={values.username}<br/>                    handleChange={handleChange} /&gt;<br/>       &lt;div className="inlineForm__submit"&gt;<br/>         &lt;Link to='/login'&gt;<br/>           &lt;Prompt prompt={"Existing account? Log in."}/&gt;<br/>         &lt;/Link&gt;<br/>         &lt;CTA name={"register"} type={"submit"}/&gt;<br/>      &lt;/div&gt;<br/>    &lt;/form&gt;<br/>   &lt;/div&gt;<br/> &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="1451" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在提交表单时，在页面中调用一个异步函数来防止默认行为发生(提交时页面刷新),并调用useAuth自定义钩子中的两个函数。到目前为止，该挂钩具有以下功能:</p><p id="ec74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> src &gt;挂钩&gt;使用权限</strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="8cd9" class="lr ls iq mq b gy mu mv l mw mx">import { useState, useContext } from 'react';<br/>import { useHistory } from 'react-router-dom';<br/>import axios from 'axios';<br/>import { UserContext } from './UserContext';</span><span id="3c1f" class="lr ls iq mq b gy my mv l mw mx">export default function useAuth() {<br/>   let history = useHistory();<br/>   const { setUser } = useContext(UserContext);<br/>   const [error, setError] = useState(null);</span><span id="10ae" class="lr ls iq mq b gy my mv l mw mx">   <strong class="mq ir">//set user in context and push them home</strong><br/>   const setUserContext = async () =&gt; {<br/>   return await axios.get('/user').then(res =&gt; {<br/>       setUser(res.data.currentUser);<br/>       history.push('/home');<br/>     }).catch((err) =&gt; {<br/>       setError(err.response.data);<br/>   })<br/>  }</span><span id="9c53" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">//register user<br/></strong>  const registerUser = async (data) =&gt; {<br/>     const { username, email, password, passwordConfirm } = data;<br/>     return axios.post(`auth/register`, {<br/>        username, email, password, passwordConfirm<br/>     }).then(async () =&gt; {<br/>         await setUserContext();<br/>     }).catch((err) =&gt; {<br/>         setError(err.response.data);<br/>      })<br/>    };</span><span id="4e21" class="lr ls iq mq b gy my mv l mw mx">return {</span><span id="42de" class="lr ls iq mq b gy my mv l mw mx">   registerUser,<br/>   error</span><span id="6586" class="lr ls iq mq b gy my mv l mw mx">   }<br/>}</span></pre><p id="c946" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个钩子用这两个函数做几件事。</p><ul class=""><li id="db65" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">register user:</strong>POST请求由<code class="fe nw nx ny mq b">/auth/register</code>端点发出，请求体中包含用户数据。用户在用户数据库中创建。他们还用第一方的曲奇饼干烹制，保质期为30天。(参见后端功能的先决条件步骤中的API代码。)</li><li id="beec" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">setUserContext :发出GET请求，检查是否有会话cookie。如果存在，从JWT返回的用户将存储在上下文中，并使用React路由器的useHistory钩子将用户推送到<code class="fe nw nx ny mq b">/home</code>。</li><li id="fef4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">错误处理</strong>:如果这些功能无法执行，<code class="fe nw nx ny mq b">catch</code>模块会设置一条错误信息。有关错误处理的更多信息，请参见<a class="ae kw" href="http://Handling errors in Mongoose/Express for display in React" rel="noopener ugc nofollow" target="_blank">这里的</a>。</li></ul><p id="9edf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>可以<strong class="ka ir"/>将POST请求返回的用户设置为存储在上下文中的用户。将它分成两个调用似乎是不必要的:一个是创建用户的POST，另一个是获取相同用户并存储它们的GET。然而，当用户通过认证后到达站点时，我们将总是存储来自GET请求的用户。<strong class="ka ir">为了获得一致的用户体验，始终存储相同的用户对象很重要，这可以通过这里的GET请求来实现。</strong></p><p id="e25c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">登录过程与登录组件上的注册相同，我们将登录函数添加到useAuth钩子中。</p><p id="3295" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> src &gt;挂钩&gt;使用权限</strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="0b3e" class="lr ls iq mq b gy mu mv l mw mx">import { useState, useContext } from 'react';<br/>import { useHistory } from 'react-router-dom';<br/>import axios from 'axios';<br/>import { UserContext } from './UserContext';</span><span id="6510" class="lr ls iq mq b gy my mv l mw mx">export default function useAuth() {<br/>   let history = useHistory();<br/>   const { setUser } = useContext(UserContext);<br/>   const [error, setError] = useState(null);</span><span id="216c" class="lr ls iq mq b gy my mv l mw mx">//set user in context and push them home<br/>   const setUserContext = async () =&gt; {<br/>   return await axios.get('/user').then(res =&gt; {<br/>       setUser(res.data.currentUser);<br/>       history.push('/home');<br/>     }).catch((err) =&gt; {<br/>       setError(err.response.data);<br/>   })<br/>  }</span><span id="e6ce" class="lr ls iq mq b gy my mv l mw mx">//register user<strong class="mq ir"><br/></strong>  const registerUser = async (data) =&gt; {<br/>     const { username, email, password, passwordConfirm } = data;<br/>     return axios.post(`auth/register`, {<br/>        username, email, password, passwordConfirm<br/>     }).catch((err) =&gt; {<br/>         setError(err.response.data);<br/>      })<br/>    };</span><span id="776f" class="lr ls iq mq b gy my mv l mw mx"><strong class="mq ir">//login user</strong><br/>const loginUser = async (data) =&gt; {<br/><strong class="mq ir"> </strong>const { username, password } = data;<br/>     return axios.post(`auth/login`, {<br/>        username, password<br/>     }).then(async () =&gt; {<br/>         await setUserContext();<br/>     }).catch((err) =&gt; {<br/>         setError(err.response.data);<br/>}</span><span id="c5d0" class="lr ls iq mq b gy my mv l mw mx">return {</span><span id="e812" class="lr ls iq mq b gy my mv l mw mx">   registerUser,<br/>   <strong class="mq ir">loginUser,</strong>   <br/>   error</span><span id="75e6" class="lr ls iq mq b gy my mv l mw mx">}<br/>}</span></pre><h1 id="3842" class="na ls iq bd lt nb nc nd lw ne nf ng lz nh ni nj mc nk nl nm mf nn no np mi nq bi translated">步骤2b:创建一个<strong class="ak">定制钩子来检查用户到达站点时是否有会话cookie </strong>。</h1><p id="fbff" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">当用户到达一个网站时，他们并不总是登录或注册。大多数情况下，用户的身份验证状态是由他们通过身份验证后创建的<em class="mz">cookie读取的。如果不能读取用户的cookie，他们将在每次硬刷新时被注销。因此，应用程序必须<em class="mz">总是</em>在用户到达站点时检查他们是否已经被认证。这可以通过在首次呈现应用程序时运行useFindUser()自定义钩子来实现。</em></p><p id="610c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> src &gt;钩子&gt; useFindUser.js </strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="abac" class="lr ls iq mq b gy mu mv l mw mx">import { useState, useEffect } from 'react';<br/>import axios from 'axios';</span><span id="5afa" class="lr ls iq mq b gy my mv l mw mx">export default function useFindUser() {<br/>   const [user, setUser] = useState(null);<br/>   const [isLoading, setLoading] = useState(true);</span><span id="00d0" class="lr ls iq mq b gy my mv l mw mx">useEffect(() =&gt; {<br/>   async function findUser() {<br/>     await axios.get('/user')<br/>        .then(res =&gt; {<br/>        setUser(res.data.currentUser);<br/>        setLoading(false);<br/>     }). catch(err =&gt; {<br/>        setLoading(false);<br/>    });<br/>  }</span><span id="092e" class="lr ls iq mq b gy my mv l mw mx">   findUser();<br/>}, []);</span><span id="ffb6" class="lr ls iq mq b gy my mv l mw mx">return {<br/>   user,<br/>   isLoading<br/>   }<br/>}</span></pre><p id="11ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个调用使用两种状态:当没有用户时，<strong class="ka ir">用户</strong>，<strong class="ka ir"> </strong>设置为空<strong class="ka ir"/>，在检查用户的调用完成之前，<strong class="ka ir">正在加载，</strong>为真<strong class="ka ir"/>。这个函数对于认证是最重要的。用户一到达站点，<strong class="ka ir"> useEffect </strong>钩子就会运行它。如果有用户，承诺将被解析，用户将被设置为<strong class="ka ir">用户</strong>状态。如果没有用户，承诺将被拒绝，用户将正确地保持为空。无论哪种方式，isLoading都将为<strong class="ka ir">假。</strong></p><p id="8ae5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当进行这个axios调用时，后端将在<code class="fe nw nx ny mq b">/user</code>路由上使用checkUser()函数来解码并从用户浏览器的cookie中读取JWT令牌，就像它在登录和注册时所做的那样。</p><p id="a6bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们调用useFindUser()自定义钩子，并将返回值存储在应用程序顶层的全局上下文中。在这种情况下(以及大多数情况下)，这是<strong class="ka ir"> App.js </strong>文件。</p><p id="0735" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">src &gt; App.js</p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="b39a" class="lr ls iq mq b gy mu mv l mw mx">const { user, setUser, isLoading } = useFindUser();</span></pre><p id="b053" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一行被添加到App.js的return语句之前。完整的App.js代码如下。</p><h1 id="9699" class="na ls iq bd lt nb nc nd lw ne nf ng lz nh ni nj mc nk nl nm mf nn no np mi nq bi translated">步骤3:将返回的用户存储在应用程序的全局上下文中。</h1><p id="22bf" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">无论用户以何种方式存储在上下文中useAuth挂钩或useFindUser挂钩——他们的数据都需要在整个应用程序中可访问。我们将整个应用程序包装在上下文<strong class="ka ir">提供者</strong>中，这使得数据对其中的任何组件都可用:</p><p id="37cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> src &gt; App.js </strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="c885" class="lr ls iq mq b gy mu mv l mw mx">import './App.css';<br/>import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';<br/><strong class="mq ir">import { UserContext } from './hooks/UserContext';<br/></strong>import Register from './pages/Register';<br/>import Login from './pages/Login';<br/>import Landing from './pages/Landing';<br/>import NotFound from './pages/NotFound';<br/>import useFindUser from './hooks/useFindUser';</span><span id="c887" class="lr ls iq mq b gy my mv l mw mx">function App() {</span><span id="b152" class="lr ls iq mq b gy my mv l mw mx">const { user, setUser, isLoading } = useFindUser();</span><span id="08c2" class="lr ls iq mq b gy my mv l mw mx">return (<br/> &lt;Router&gt;<br/><strong class="mq ir"> &lt;UserContext.Provider value={{ user, setUser, isLoading }}&gt;<br/></strong>   &lt;Switch&gt;<br/>     &lt;Route exact path="/" component={Landing}/&gt;<br/>     &lt;Route path="/register" component={Register}/&gt;<br/>     &lt;Route path="/login" component={Login}/&gt;<br/>     &lt;Route component={NotFound}/&gt;<br/>  &lt;/Switch&gt;<br/><strong class="mq ir"> &lt;/UserContext.Provider&gt;<br/></strong>&lt;/Router&gt;<br/>);<br/>}</span><span id="6967" class="lr ls iq mq b gy my mv l mw mx">export default App;</span></pre><p id="58fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在可以在上面的任何组件中访问作为value属性的数据集。</p><p id="2def" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果是console.log(用户)，我会在控制台中看到这个对象:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/47259538f9801501e1c4d96a9be0c35d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0Q0-aMHCNv7K9Oxhq4o6A.png"/></div></div></figure><p id="ad8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在可以像任何典型的对象一样访问它，我可以返回<code class="fe nw nx ny mq b">user.username</code>或<code class="fe nw nx ny mq b">user.email</code>来获得单独的属性。</p><p id="6329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>切勿在上下文中存储原始用户密码。散列密码(如我上面所做的)或删除密码字段！</p><h1 id="48d4" class="na ls iq bd lt nb nc nd lw ne nf ng lz nh ni nj mc nk nl nm mf nn no np mi nq bi translated">步骤4:为经过身份验证的用户创建私有路由组件。</h1><p id="0684" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在有身份验证的应用程序中，有一些“受保护的路由”，只有那些登录的用户才能访问。为了防止未经身份验证的用户访问某些路由，我们可以创建一个PrivateRoute组件来“筛选”用户的身份验证状态并做出相应的响应。</p><p id="139f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户通过了身份验证，他们就可以继续前进到路由，该路由位于PrivateRoute组件内部。如果用户没有通过身份验证，我们会通过将他们定向到一个通用的公共路由来处理他们。</p><p id="a084" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">src&gt;pages&gt;private route . js</strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="a822" class="lr ls iq mq b gy mu mv l mw mx">import React, { useContext } from 'react';<br/>import { Route, Redirect } from 'react-router-dom';<br/>import { UserContext } from './../hooks/UserContext';<br/>import Loading from './../components/Loading';</span><span id="e15e" class="lr ls iq mq b gy my mv l mw mx">export default function PrivateRoute(props) {</span><span id="51fe" class="lr ls iq mq b gy my mv l mw mx">   const { user, isLoading } = useContext(UserContext);<br/>   const { component: Component, ...rest } = props;</span><span id="a9ef" class="lr ls iq mq b gy my mv l mw mx">   if(isLoading) {<br/>      return &lt;Loading/&gt;<br/>   }</span><span id="827a" class="lr ls iq mq b gy my mv l mw mx">   if(user){<br/>      return ( &lt;Route {...rest} render={(props) =&gt; <br/>           (&lt;Component {...props}/&gt;)<br/>            }<br/>         /&gt;<br/>       )}</span><span id="5f45" class="lr ls iq mq b gy my mv l mw mx">   //redirect if there is no user <br/>   return &lt;Redirect to='/login' /&gt;<br/>}</span></pre><p id="09ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是PrivateRoute组件，当用户试图访问受保护的路由时，用户将被定向到该组件。通过身份验证的用户将看到的React组件作为一个属性传递给这个组件。所以如果<code class="fe nw nx ny mq b">Home</code>组件被保护，它将作为这里的<code class="fe nw nx ny mq b">&lt;Component/&gt;</code>被传递。</p><p id="83f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>渲染<code class="fe nw nx ny mq b">&lt;Route/&gt;</code>中的组件很重要，而不仅仅是<code class="fe nw nx ny mq b">return &lt;Component/&gt;</code>。如果只返回组件，用户将被正确引导，但他们将无法从React Router访问属性，如useHistory、useParams或Link组件的state。</p><p id="918a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">私人路线有三种可能的结果:1 .加载，在这种情况下会显示一个加载屏幕(或者你可以返回<code class="fe nw nx ny mq b">null</code>如果你不想显示一个加载屏幕)，2。未加载并且找到了用户，在这种情况下，它们被路由到组件，以及3 .未加载且找不到用户，在这种情况下，他们将被定向到登录页面。</p><p id="2b7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向我们的App.js添加PrivateRoute组件很简单:</p><p id="6187" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> src &gt; App.js </strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="e06f" class="lr ls iq mq b gy mu mv l mw mx">import './App.css';<br/>import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';<br/>import { UserContext } from './hooks/UserContext';<strong class="mq ir"><br/>import PrivateRoute from './pages/PrivateRoute';<br/></strong>import Register from './pages/Register';<br/>import Login from './pages/Login';<br/>import Landing from './pages/Landing';<br/>import Home from './pages/Home';<br/>import NotFound from './pages/NotFound';<br/>import useFindUser from './hooks/useFindUser';</span><span id="d601" class="lr ls iq mq b gy my mv l mw mx">function App() {</span><span id="62c4" class="lr ls iq mq b gy my mv l mw mx">const { user, setUser, isLoading } = useFindUser();</span><span id="6f91" class="lr ls iq mq b gy my mv l mw mx">return (<br/> &lt;Router&gt;<br/> &lt;UserContext.Provider value={{ user, setUser, isLoading }}&gt;<strong class="mq ir"><br/></strong>   &lt;Switch&gt;<br/>     &lt;Route exact path="/" component={Landing}/&gt;<br/>     &lt;Route path="/register" component={Register}/&gt;<br/>     &lt;Route path="/login" component={Login}/&gt;<br/><strong class="mq ir">     &lt;PrivateRoute path="/home" component={Home}/&gt;<br/></strong>     &lt;Route component={NotFound}/&gt;<br/>  &lt;/Switch&gt;<br/> &lt;/UserContext.Provider&gt;<strong class="mq ir"><br/></strong>&lt;/Router&gt;<br/>);<br/>}</span><span id="eb7f" class="lr ls iq mq b gy my mv l mw mx">export default App;</span></pre><p id="0656" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我向新用户注册时，他们会立即被带到这里:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/9575c089c610371383d42f13d1f3a486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qf2mwByneyUZFQ9BBTWhoQ.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">只有登录的用户才能访问</figcaption></figure><p id="7fe3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个组件是从私人路线返回的家。</p><h1 id="ada7" class="na ls iq bd lt nb nc nd lw ne nf ng lz nh ni nj mc nk nl nm mf nn no np mi nq bi translated">步骤5:重定向用户并根据身份验证状态有条件地呈现组件。</h1><p id="ce47" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated"><em class="mz">有些组件是所有用户都可以访问的</em>、<em class="mz">，但是应该根据认证状态而改变。</em>这可以通过重定向和条件渲染来处理。</p><h2 id="1bde" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">重定向经过身份验证的用户</h2><p id="32b1" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">如果我们有一个未认证用户的公共登录页面，我们可能不希望认证用户看到它。经过身份验证的用户应该被重定向到他们的个性化的私人主页。</p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="bf0e" class="lr ls iq mq b gy mu mv l mw mx">import React, { useContext } from 'react';<br/>import Header from '../sections/Header';<br/>import { Redirect } from 'react-router-dom';<br/>import { UserContext } from '../hooks/UserContext';</span><span id="9af5" class="lr ls iq mq b gy my mv l mw mx">export default function Landing() {<br/>   const { user } = useContext(UserContext);<br/>   <br/> <strong class="mq ir">  if(user) {<br/>      &lt;Redirect to='/home'/&gt;<br/>   }</strong></span><span id="4d7d" class="lr ls iq mq b gy my mv l mw mx">  return (<br/>    &lt;div className="page"&gt;<br/>      &lt;Header/&gt;<br/>      &lt;h3&gt;This is the public landing page&lt;/h3&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="ae3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有用户，他们将立即被重定向到私有的<code class="fe nw nx ny mq b">/home</code>路径，然后return语句会向他们显示通用的公共登录页面。</p><h2 id="8764" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">条件渲染</h2><p id="dac1" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">公共路由和私有路由可能需要相同组件的不同版本。条件呈现的典型用例是一个动作调用按钮:未知用户应该看到一个登录按钮，而已知用户应该看到一个注销按钮。然而，在许多情况下，对于已知用户和未知用户，相同的组件会发生变化。</p><p id="8919" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的应用程序中的一个例子是Header组件。如果存储了一个用户，那么标题反映出我已经登录:显示注销按钮而不是登录按钮，并且动态填充我的用户名(从上下文中检索)。</p><p id="a70b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> src &gt;节&gt; Header.js </strong></p><pre class="lm ln lo lp gt mp mq mr ms aw mt bi"><span id="5ddf" class="lr ls iq mq b gy mu mv l mw mx">import React, { useContext } from 'react';<br/>import InlineButton from './../components/InlineButton';<br/>import { UserContext } from '../hooks/UserContext';<br/>import useLogout from './../hooks/useLogout';</span><span id="00c6" class="lr ls iq mq b gy my mv l mw mx">export default function Header() {<br/>   <strong class="mq ir">const { user } = useContext(UserContext);<br/>   </strong>const { logoutUser } = useLogout();</span><span id="57f1" class="lr ls iq mq b gy my mv l mw mx">return(<br/>&lt;header&gt;<br/>{<strong class="mq ir">user <br/>    ? </strong><br/>    &lt;&gt;<br/>       Hello, {user.username}<br/>       &lt;InlineButton name={'logout'} handleClick={logoutUser} /&gt;<br/>    &lt;/&gt;<br/>    <strong class="mq ir">: </strong><br/>     &lt;div className='btnGroup'&gt;<br/>        &lt;Link to = "/login"&gt;<br/>            &lt;InlineButton name={"login"}/&gt;<br/>       &lt;/Link&gt;<br/>       &lt;Link to = "/register"&gt;<br/>            &lt;InlineButton name={"register"}/&gt;<br/>       &lt;/Link&gt;<br/>    &lt;/div&gt;<br/>}<br/>&lt;/header&gt;<br/>    )<br/> }</span></pre><p id="d9e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我的基本header组件，它使用一个三元运算符来有条件地呈现两个不同版本的Header，无论是否有用户。如你所见，当有用户时，我使用<code class="fe nw nx ny mq b">user.username</code>用我的用户名个性化页面。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/9575c089c610371383d42f13d1f3a486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qf2mwByneyUZFQ9BBTWhoQ.png"/></div></div></figure><h1 id="f9a2" class="na ls iq bd lt nb nc nd lw ne nf ng lz nh ni nj mc nk nl nm mf nn no np mi nq bi translated">结论</h1><p id="5983" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">基本模板就这么多了！认证还有更多的内容，但是我希望这个模板提供一个相当大的基础。如果有人有更优雅的模式，我会感谢任何相关资源。我发现很难找到许多全面的认证指南。总的来说，这里涵盖的内容有:</p><ul class=""><li id="913f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">在全局上下文中存储已验证的用户。</li><li id="b4fb" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">根据用户的纯HTTP cookie/JWT令牌检查用户是否登录。</li><li id="4b69" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">仅为经过身份验证的用户保护路由。</li><li id="42fc" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">根据用户的身份验证状态重定向用户和条件呈现。</li></ul><p id="165c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/jawblia/auth" rel="noopener ugc nofollow" target="_blank">项目回购</a></p><p id="f200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我使用的一些资源&amp;发现很有帮助:</strong></p><ul class=""><li id="8267" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae kw" href="https://darutk.medium.com/understanding-id-token-5f83f50fa02e" rel="noopener">基于令牌的认证及其工作原理。</a></li><li id="5849" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">将JWT储存在饼干里。</li><li id="a04b" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">使用上下文挂钩和上下文提供者</a> <a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">文档</a>。</li><li id="c403" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">Ben Awad关于从JWT检索用户的视频教程。</li><li id="d121" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">Ben Awad的<a class="ae kw" href="https://www.youtube.com/watch?v=lhMKvyLRWo0" rel="noopener ugc nofollow" target="_blank">视频教程</a>关于在全球背景下存储用户。</li><li id="145a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://ui.dev/react-router-v5-protected-routes-authentication/" rel="noopener ugc nofollow" target="_blank">建立一个私人路线</a>——目前为止我找到的最好的指南，其他的不包括&lt;路线/ &gt;部分。</li></ul></div></div>    
</body>
</html>