<html>
<head>
<title>Python Dependency Injection with flask-injector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用flask-injector的Python依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-dependency-injection-with-flask-injector-50773d451a32?source=collection_archive---------0-----------------------#2020-01-16">https://levelup.gitconnected.com/python-dependency-injection-with-flask-injector-50773d451a32?source=collection_archive---------0-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d509426b2560134f83c29f7832366e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Or7asYhKEZ4EH0lf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>拍摄的照片</figcaption></figure><p id="ba2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python的<a class="ae kf" href="https://github.com/alecthomas/flask_injector" rel="noopener ugc nofollow" target="_blank"> flask-injector </a>包没有完整的文档，网上关于如何实现它的例子也很少。我没有找到一个好的教程来说明如何在真实的flask应用程序中使用flask-injector进行依赖注入，所以当我想通了之后，我决定自己写一个。</p><h1 id="9890" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是依赖注入？</h1><p id="15d9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">依赖注入(DI)最初是由Martin Fowler作为一种设计模式提出的。他的文章值得一读，但我花了一段时间才完全理解。他分享了一些Java代码作为例子。在本教程中，我将向您展示如何为Python Flask应用程序实现DI。</p><p id="3626" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您已经知道什么是依赖注入，那么您可以直接跳到安装和实现部分。</p><p id="6dfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">依赖注入用于将组件相互连接起来。我们使用组件来确保我们的应用程序有一个干净的架构。每个组件都是一段独立的封装代码，其接口与实现相分离。</p><p id="694d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是最终，组件需要相互通信。</p><p id="76d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解DI的最好方法是将它应用到你目前正在试图解决的问题中。假设您正在构建一个包含与另一个类“有”关系的类。例如，您有一个需要连接到数据库的服务类。</p><p id="1252" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个MyService类在变量“db”中有一个MySqlDatabase。当初始化MyService类的新实例时，创建MySqlDatabase类的实例并将其传入。</p><p id="ebfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子被高度简化以展示DI是如何工作的。下面是一些没有依赖注入的代码<em class="mh">。</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="eea7" class="mr lf it mn b gy ms mt l mu mv">class MyService():<br/>   def __init__(self, db):<br/>      self.db = db</span><span id="5fca" class="mr lf it mn b gy mw mt l mu mv">class MySqlDatabase:        <br/>   def __init__(self, connection_string):<br/>       self.connection_string = connection_string</span><span id="db45" class="mr lf it mn b gy mw mt l mu mv">   def connect():<br/>       # implementation for a MySQL database connection</span><span id="0506" class="mr lf it mn b gy mw mt l mu mv">@app.route('/thing')<br/>my_flask_route():<br/>   database = MySqlDatabase(os.getenv("CONNECTION_STRING"))<br/>   service = MyService(database)<br/>   service.do_the_thing()</span></pre><p id="fc72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">MyService类<em class="mh">依赖于MyDatabase类</em>，因此MyDatabase类被认为是MyService类的<em class="mh">依赖关系</em>。该路由还依赖于MyService。该组件也必须手动创建。</p><p id="f47e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了<em class="mh">将<em class="mh">依赖关系</em> MySqlDatabase注入到MyService类中，我们必须手动创建MySqlDatabase对象，并在每次使用MyService类时将其传递给MyService构造函数。</em></p><p id="ed3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将会很好的工作；然而，在较大的应用程序中，这会带来一些问题。</p><ul class=""><li id="0dff" class="mx my it ki b kj kk kn ko kr mz kv na kz nb ld nc nd ne nf bi translated">创建服务的代码现在变得凌乱不堪，可读性不如预期。</li><li id="386a" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">MySqlDatabase类现在与MyService类紧密耦合。您可能希望使您的代码具有可扩展性，以便将来支持其他数据库类型，如PostgreSQL或MS SQL Server。</li><li id="7674" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">单元测试比它需要的更复杂。</li></ul><p id="883d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用依赖注入模式有助于将接口从实现中分离出来。使用依赖注入，您的代码将如下所示。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ef48" class="mr lf it mn b gy ms mt l mu mv">class MyService():<br/>   def __init__(self, db: MySqlDatabase):<br/>      self.db = db</span><span id="f532" class="mr lf it mn b gy mw mt l mu mv">class MySqlDatabase:        <br/>   def __init__(self, connection_string):<br/>       self.connection_string = connection_string</span><span id="29df" class="mr lf it mn b gy mw mt l mu mv">   def connect():<br/>       # implementation for a MySQL database connection</span><span id="710c" class="mr lf it mn b gy mw mt l mu mv">@app.route('/thing')<br/>my_flask_route(service: MyService):<br/>    service.do_the_thing()</span></pre><p id="f6cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要担心幕后发生的事情；我一会儿会描述一下。现在我们知道服务<em class="mh">依赖</em>将<em class="mh">注入</em>到您的flask route中，反过来，数据库类将<em class="mh">注入</em>到服务类<em class="mh">中。</em></p><p id="c716" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更进一步，您可以通过为您的数据库类创建一个抽象基类来使您的代码可扩展。这样，我们可以在以后快速添加对其他数据库的支持，而无需修改当前的组件。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="484f" class="mr lf it mn b gy ms mt l mu mv">from abc import ABC, abstractmethod</span><span id="1dbe" class="mr lf it mn b gy mw mt l mu mv">class MyService():<br/>   def __init__(self, db: DatabaseBase):<br/>      self.db = db</span><span id="11f5" class="mr lf it mn b gy mw mt l mu mv">class DatabaseBase(ABC):<em class="mh"><br/>    </em>def __init__(self):<br/>        pass</span><span id="35ca" class="mr lf it mn b gy mw mt l mu mv">    @abstractmethod<br/>    def connect(self):<br/>        pass</span><span id="82a8" class="mr lf it mn b gy mw mt l mu mv">class MySqlDatabase(DatabaseBase):        <br/>   def __init__(self, connection_string):<br/>      super.__init__()      <br/>      self.connection_string = connection_string</span><span id="db26" class="mr lf it mn b gy mw mt l mu mv">   def connect():<br/>       # implementation for a MySQL database connection</span><span id="7a64" class="mr lf it mn b gy mw mt l mu mv">class PostgreSqlDatabase(DatabaseBase):        <br/>   def __init__(self, connection_string):<br/>      super.__init__()      <br/>      self.connection_string = connection_string</span><span id="e20a" class="mr lf it mn b gy mw mt l mu mv">   def connect():<br/>       # implementation for a PostgreSQL database connection</span><span id="4b24" class="mr lf it mn b gy mw mt l mu mv">@app.route('/thing')<br/>my_flask_route(service: MyService):<br/>    service.do_the_thing()</span></pre><p id="46d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，我们现在正在将DatabaseBase传递到MyService构造函数中。然后，我们可以在运行时传递我们需要的任何数据库类。</p><p id="5d3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样做可以确保你遵循了面向对象设计的坚实原则。“O”代表开闭原则。如果从一开始就以这种方式设置代码，那么它就可以针对不同类型的数据存储进行扩展。</p><blockquote class="nl nm nn"><p id="d468" class="kg kh mh ki b kj kk kl km kn ko kp kq no ks kt ku np kw kx ky nq la lb lc ld im bi translated">开闭原则声明“对象或实体应该对扩展开放，但对修改关闭。”</p></blockquote><h1 id="7bc4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python和Flask的依赖注入</h1><p id="ed05" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">毫无疑问，你可以用Python快速实现你自己的解决方案，或者使用Python的<a class="ae kf" href="https://github.com/alecthomas/injector" rel="noopener ugc nofollow" target="_blank">注入器</a>包，让它为你的Flask API工作，但是这需要额外的全局变量。</p><p id="5e2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们通常会尽量避免在应用程序中添加更多的全局变量，所以我选择了<em class="mh"> flask-injector。</em></p><h1 id="1ac7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">安装和实施</h1><p id="2390" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果您还没有为您的项目设置Python虚拟环境，现在是时候了。点击阅读如何操作<a class="ae kf" href="https://medium.com/swlh/how-to-setup-your-python-projects-1eb5108086b1" rel="noopener">。</a></p><p id="137d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，确保您的虚拟环境被激活，并将flask-injector安装到您的项目中。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d132" class="mr lf it mn b gy ms mt l mu mv">source venv/bin/activate</span><span id="2dc5" class="mr lf it mn b gy mw mt l mu mv">pip install flask-injector</span></pre><p id="6165" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先创建我们的模型，就像我们上面做的那样。</p><p id="c982" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个名为MyDatabase.py的文件，并添加以下代码。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3b52" class="mr lf it mn b gy ms mt l mu mv">from abc import ABC, abstractmethod<br/></span><span id="fe20" class="mr lf it mn b gy mw mt l mu mv">class DatabaseBase(ABC):<br/>    def __init__(self):<br/>        pass</span><span id="94fa" class="mr lf it mn b gy mw mt l mu mv">    @abstractmethod<br/>    def connect(self):<br/>        pass</span><span id="ff3e" class="mr lf it mn b gy mw mt l mu mv">    @abstractmethod<br/>    def get(self):<br/>        pass<br/></span><span id="db02" class="mr lf it mn b gy mw mt l mu mv">class MySqlDatabase(DatabaseBase):<br/>    def __init__(self):<br/>        super().__init__()</span><span id="cb8e" class="mr lf it mn b gy mw mt l mu mv">    def connect(self):<br/>        # <em class="mh">TODO: implementation for a MySQL database connection<br/>        </em>print("Successfully connected to MySQL database!")</span><span id="e2f8" class="mr lf it mn b gy mw mt l mu mv">    def get(self):<br/>        return "success"  # TODO: Query the database here</span></pre><p id="bacf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个名为MyService.py的文件，并添加以下代码。导入数据库基类并<em class="mh">将</em>注入到MyService构造函数中。注意，注入工作需要<strong class="ki iu"> @inject </strong>装饰器。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a35a" class="mr lf it mn b gy ms mt l mu mv">from injector import inject</span><span id="24eb" class="mr lf it mn b gy mw mt l mu mv">from MyDatabase import DatabaseBase<br/></span><span id="35a3" class="mr lf it mn b gy mw mt l mu mv">class MyService:<br/>    <strong class="mn iu">@inject</strong><br/>    def __init__(self, db: DatabaseBase):<br/>        print(f"DatabaseBase instance is {db}") <br/>        self.db = db</span><span id="0ede" class="mr lf it mn b gy mw mt l mu mv">    def get_data(self):<br/>        return self.db.get()</span></pre><p id="1d6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在使用flask-injector来配置依赖项。configure函数使用一个绑定器将接口(MyService，Database)绑定到实现(to=MyService，to=MySQLDatabase)。如您所见，scope变量告诉flask-injector何时创建类的新实例。singleton作用域只为应用程序的每个实例创建一个新实例，并且在应用程序的整个生存期内存在。请求范围为每个对Flask API的请求创建一个新实例。</p><p id="90d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个名为dependencies.py的文件，并添加以下代码。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bd73" class="mr lf it mn b gy ms mt l mu mv">from injector import singleton</span><span id="98cb" class="mr lf it mn b gy mw mt l mu mv">from MyDatabase import DatabaseBase, MySqlDatabase<br/>from MyService import MyService<br/></span><span id="b5f4" class="mr lf it mn b gy mw mt l mu mv">def configure(binder):<br/>    binder.bind(MyService, to=MyService, scope=singleton)<br/>    binder.bind(DatabaseBase, to=MySqlDatabase, scope=singleton)</span></pre><p id="329a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了，你快到了。</p><p id="1e57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以创建您的Flask应用程序。</p><p id="6e14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简单起见，我只在API中添加了一条路线。您可以看到，我们正在从依赖项中导入configure函数，这样当我们在底部创建FlaskInjector时，可以将它作为一个模块添加。请注意，在声明了所有的<em class="mh">视图</em>之后，必须实例化FlaskInjector。</p><p id="8493" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用以下代码创建一个名为app.py的文件。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7e48" class="mr lf it mn b gy ms mt l mu mv">from flask import Flask<br/>from flask_injector import FlaskInjector<br/>from injector import inject</span><span id="d1b6" class="mr lf it mn b gy mw mt l mu mv">from MyService import MyService<br/>from dependencies import configure</span><span id="9c15" class="mr lf it mn b gy mw mt l mu mv">app = Flask(__name__)<br/></span><span id="bdaa" class="mr lf it mn b gy mw mt l mu mv">@inject<br/>@app.route('/data')<br/>def get_data(service: MyService):<br/>    print(f"MyService instance is {service}")<br/>    return service.get_data()<br/></span><span id="e557" class="mr lf it mn b gy mw mt l mu mv"># Setup Flask Injector, this has to happen AFTER routes are added<br/>FlaskInjector(app=app, modules=[configure])</span></pre><p id="208e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这段代码中，您可以看到MyService被直接注入到您的Flask API路由中。</p><p id="8640" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，运行您的Flask应用程序。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7b3d" class="mr lf it mn b gy ms mt l mu mv">flask run</span></pre><p id="c3cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，导航到<a class="ae kf" href="http://localhost:5000/data" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/data</a>，然后刷新浏览器第二次运行请求。您应该看到，在第一次调用时，创建了数据库对象，然后是服务对象。在第二次调用时，因为我们在configure函数中使用了“singleton”作用域，所以相同的服务对象被重用，并且数据库对象不需要再次创建。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/6521a73e7bbe0d4a2d8e082d4f47cf8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2BaaATA15A_4SBpq-k0Bw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">两个请求的MyService实例是相同的，因为它有一个单独的作用域</figcaption></figure><p id="4b0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果将每个绑定的范围更改为“请求”，flask-injector会为每个请求注入一个新实例。更改依赖项文件中的代码。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e352" class="mr lf it mn b gy ms mt l mu mv">binder.bind(MyService, to=MyService, scope=<strong class="mn iu">request</strong>)<br/>binder.bind(DatabaseBase, to=MySqlDatabase, scope=<strong class="mn iu">request</strong>)</span></pre><p id="aa78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重新运行应用程序。然后，给<a class="ae kf" href="http://localhost:5000/data" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/data</a>打几次电话。现在，您应该可以看到每次创建的每个对象都有一个新的唯一位置。Flask-injector为每个请求注入一个新实例。如您所见，数据库也是为每个请求创建的。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/a8be55e4b0f99b38f4900c6197f5c2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPwqYkjmdzY2XGak2YkGXw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这一次，MyService对象每次都有一个惟一的位置，因为它有一个请求范围</figcaption></figure><p id="189b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:当您向类构造函数(__init__)添加参数时，事情会变得更加复杂。在这种情况下，您可以创建一个provider方法，告诉FlaskInjector您希望如何实例化您的对象(使用必需的参数)。否则，你会得到一个注射器。UnkownProvider异常。如果发生这种情况，这意味着flask-injector无法正确实例化您的对象。在这种情况下，您应该使用模块来绑定您的类。参见<a class="ae kf" href="https://github.com/alecthomas/flask_injector" rel="noopener ugc nofollow" target="_blank">烧瓶注射器文档</a>了解如何操作。</p><p id="16c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你发现这是有用的，虽然烧瓶注射器文档不是最好的；一旦你让它工作，它会非常方便。虽然依赖注入在Python中不是必需的，但是如果您习惯使用这种模式，那么使用依赖注入是很好的。</p><p id="d462" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在以下位置找到代码:<a class="ae kf" href="https://github.com/jperilla/Tutorials/tree/master/dependency-inject-flask" rel="noopener ugc nofollow" target="_blank">https://github . com/jperilla/Tutorials/tree/master/dependency-inject-flask</a></p><p id="7cc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！</p></div></div>    
</body>
</html>