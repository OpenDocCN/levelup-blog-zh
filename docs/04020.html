<html>
<head>
<title>JavaScript Antipatterns —Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript反模式—循环</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-antipatterns-loops-702e9fa368ae?source=collection_archive---------20-----------------------#2020-06-05">https://levelup.gitconnected.com/javascript-antipatterns-loops-702e9fa368ae?source=collection_archive---------20-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c6802c08d0118d07202f0544ba7138f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N3a2VLeIqZzjtErn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">rafael Souza 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4e5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="9766" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些在编写JavaScript循环时应该避免的反模式。</p><h1 id="84bc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对于循环</h1><p id="fc99" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">for循环对于迭代数组和类似数组的对象非常方便。</p><p id="1081" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0e86" class="mq lf it mm b gy mr ms l mt mu">const arr = [1, 2, 3];<br/>for (let i = 0; i &lt; arr.length; i++) {<br/>  // do something with arr[i]<br/>}</span></pre><p id="02b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将循环<code class="fe mv mw mx mm b">arr</code>数组的索引，并让我们对每个条目做一些事情。</p><p id="6804" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也适用于类似数组的对象。节点列表是类似数组的对象。</p><p id="6905" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以调用以下方法来获得一个包含多个DOM元素的Nodelist:</p><ul class=""><li id="18e9" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">document.querySelectorAll()</code></li><li id="f09f" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">document.getElementsByName()</code></li><li id="ebda" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">document.getElementsByClassName()</code></li><li id="2fe1" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">document.getElementsByTagName()</code></li></ul><p id="93d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">document.querySelectorAll()</code>是最通用的，因为它接受任何CSS选择器。</p><p id="a582" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">document.getElementsByName</code>仅返回具有给定名称属性的项目。</p><p id="2e5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">document.getElementsByClassName</code>只返回给定类名的项目。</p><p id="2864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">document.getElementsByTagName</code>返回具有给定标记名的项目。</p><p id="8672" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，文档的以下属性具有特定的项目</p><ul class=""><li id="9bbc" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">document.images</code> —页面上的所有<code class="fe mv mw mx mm b">img </code>元素</li><li id="fb31" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">document.links</code> —所有<code class="fe mv mw mx mm b">a</code>元素</li><li id="98ac" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">document.forms</code> —所有表格</li><li id="34fa" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">document.forms[0].elements</code> —表单中的所有字段</li></ul><p id="125b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下循环遍历它们:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6079" class="mq lf it mm b gy mr ms l mt mu">for (let i = 0; i &lt; document.links.length; i++) {<br/>  // do something with document.links[i]<br/>}</span></pre><p id="8dbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mv mw mx mm b">for</code>循环，我们可以在第一个表达式中定义所有的初始条件，因此我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="25d0" class="mq lf it mm b gy mr ms l mt mu">for (let i = 0, max = arr.length; i &lt; max; i++) {<br/>  // do something with arr[i]<br/>}</span></pre><p id="09ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与以下内容相同:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="749e" class="mq lf it mm b gy mr ms l mt mu">for (let i = 0; i &lt; arr.length; i++) {<br/>  // do something with arr[i]<br/>}</span></pre><p id="92e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">i++</code>与<code class="fe mv mw mx mm b">i = i + 1</code>或<code class="fe mv mw mx mm b">i += 1</code>相同。</p><p id="0de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将它分配给某样东西，可能会很棘手。</p><p id="1f66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">i++</code>返回<code class="fe mv mw mx mm b">i</code>的原始值，而不是更新值。</p><p id="d861" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e606" class="mq lf it mm b gy mr ms l mt mu">let i = 1;<br/>const a = i++;</span></pre><p id="604d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mv mw mx mm b">a</code>是1。</p><h1 id="ac74" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">for-in循环</h1><p id="64b0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">for-in循环对于遍历对象及其原型的关键点非常有用。</p><p id="e810" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们只想遍历对象的非继承键，我们必须使用<code class="fe mv mw mx mm b">hasOwnProperty</code>方法。</p><p id="89a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3ebb" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2<br/>}</span><span id="1086" class="mq lf it mm b gy nm ms l mt mu">for (const key in obj) {<br/>  if (obj.hasOwnProperty(key)) {<br/>    //...<br/>  }<br/>}</span></pre><p id="8753" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将只遍历非继承的键，因为<code class="fe mv mw mx mm b">hasOwnProperty</code>会检查。</p><p id="d858" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以如下调用<code class="fe mv mw mx mm b">hasOwnProperty</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="030f" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2<br/>}</span><span id="5ebf" class="mq lf it mm b gy nm ms l mt mu">for (const key in obj) {<br/>  if (Object.prototype.hasOwnProperty.call(obj, key)) {<br/>    //...<br/>  }<br/>}</span></pre><p id="5aeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将避免当<code class="fe mv mw mx mm b">obj</code>对象重新定义<code class="fe mv mw mx mm b">hasOwnProperty</code>为其他对象时出现的问题。</p><p id="45d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1789" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2<br/>}</span><span id="ed47" class="mq lf it mm b gy nm ms l mt mu">const hasOwn = Object.prototype.hasOwnProperty;<br/>for (const key in obj) {<br/>  if (hasOwn.call(obj, key)) {<br/>    //...<br/>  }<br/>}</span></pre><p id="ee5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来缓存<code class="fe mv mw mx mm b">hasOwnProperty </code>方法。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/2b15d414becb504ec8fc6a6925c5937b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*keCjQmRTybzAnWGl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@taffy_apple?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莎拉·奥利芙</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8a82" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">for-of循环</h1><p id="1e13" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">for-of循环比其他循环更加通用。这对于遍历数组和类似数组的对象很有用。</p><p id="05e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，对于遍历这些对象，这是for循环的一个很好的替代方法。</p><p id="4c25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还支持上面列出的所有<code class="fe mv mw mx mm b">document</code>属性，以及像集合和映射这样的新数据结构。</p><p id="b6dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6ad2" class="mq lf it mm b gy mr ms l mt mu">for (const link of document.links) {<br/>  // do something with link<br/>}</span></pre><p id="13c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于数组，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8cf1" class="mq lf it mm b gy mr ms l mt mu">for (const a of arr) {<br/>  // do something with a<br/>}</span></pre><p id="2c5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还使用析构赋值语法:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="46f7" class="mq lf it mm b gy mr ms l mt mu">for (const { foo, bar } of arr) {<br/>  // do something with foo and bar<br/>}</span></pre><p id="9320" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还适用于集合和地图:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e4e0" class="mq lf it mm b gy mr ms l mt mu">for (const s of set) {<br/>  // do something with a<br/>}</span></pre><p id="f5f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于地图，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e9ce" class="mq lf it mm b gy mr ms l mt mu">const map = new Map([<br/>  ['a', 1],<br/>  ['b', 2]<br/>])</span><span id="f35b" class="mq lf it mm b gy nm ms l mt mu">for (const [key, value] of map) {<br/>  // do something with key and value<br/>}</span></pre><h1 id="82fc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="ca42" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">for循环非常适合在数组和类似数组的对象中循环。</p><p id="678d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，for循环通过让我们循环遍历任何可迭代的对象而击败了它。</p><p id="c127" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">for-in循环在遍历对象中的键时用途有限。如果我们也想遍历他们原型的键，那么我们可以使用它。</p></div></div>    
</body>
</html>