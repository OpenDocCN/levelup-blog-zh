<html>
<head>
<title>Validating Request Data with Koa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Koa验证请求数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/validating-request-data-with-koa-7189ae04cf50?source=collection_archive---------19-----------------------#2020-05-29">https://levelup.gitconnected.com/validating-request-data-with-koa-7189ae04cf50?source=collection_archive---------19-----------------------#2020-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1c3e6920a94c1e37c6e80711270a33bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EHEucE7E8psFi-p1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@wimpieb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维姆·博伦</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="dd84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Koa是一个小框架，让我们可以创建在Node.js平台上运行的后端应用程序。</p><p id="b9d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何用Koa验证请求数据类型。</p><h1 id="8cea" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用request.is方法验证请求数据类型</h1><p id="3afc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用我们正在检查的数据类型的字符串调用<code class="fe mh mi mj mk b">ctx.is</code>方法，以检查来自<code class="fe mh mi mj mk b">Content-Type</code>头的值的数据类型是否与我们在参数中拥有的匹配。</p><p id="1188" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以采用一种或多种数据类型。例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="661e" class="mt lf it mk b gy mu mv l mw mx">const Koa = require('koa');<br/>const app = new Koa();</span><span id="a834" class="mt lf it mk b gy my mv l mw mx">app.use(async (ctx, next) =&gt; {<br/>  if (ctx.is('text/*', 'text/html')){<br/>    ctx.body = 'valid';<br/>  }<br/>  else {<br/>    ctx.body = 'invalid';<br/>  }<br/>});</span><span id="cb9d" class="mt lf it mk b gy my mv l mw mx">app.listen(3000);</span></pre><p id="6d28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用两个数据类型的字符串调用了<code class="fe mh mi mj mk b">ctx.is</code>方法，这两个数据类型是<code class="fe mh mi mj mk b">‘text/*’</code>和<code class="fe mh mi mj mk b">‘text/html’</code>，以检查传入的请求是否有这些值作为其<code class="fe mh mi mj mk b">Content-Type</code>头的值。</p><p id="5d23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果包含这些值中的一个，那么它返回<code class="fe mh mi mj mk b">'valid'</code>作为响应体。</p><p id="8450" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则返回<code class="fe mh mi mj mk b">'invalid'</code>。</p><h1 id="edd4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">内容协商</h1><p id="0418" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">内容协商是一种机制，用于从同一URL提供不同的资源表示。我们可以使用用户代理来指定哪个最适合用户。</p><p id="5571" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当向客户机发出请求时，我们可以在请求中使用<code class="fe mh mi mj mk b">Accept</code>、<code class="fe mh mi mj mk b">Accept-Charset</code>、<code class="fe mh mi mj mk b">Accept-Encoding</code>或<code class="fe mh mi mj mk b">Accept-Language</code>头，让服务器知道客户机接受哪种数据。</p><p id="b865" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些数据，服务器可以返回一个响应，其中包含最适合客户端的数据类型。</p><p id="f03e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="859c" class="mt lf it mk b gy mu mv l mw mx">const Koa = require('koa');<br/>const app = new Koa();</span><span id="d08f" class="mt lf it mk b gy my mv l mw mx">app.use(async (ctx, next) =&gt; {<br/>  if (ctx.accepts('html')){<br/>    ctx.body = 'accepts html';<br/>  }<br/>  else if (ctx.accepts('application/json')){<br/>    ctx.body = 'accepts json';<br/>  }<br/>  else if (ctx.accepts('image/png')){<br/>    ctx.body = 'accepts png';<br/>  }<br/>  else {<br/>    ctx.body = 'accepts everything';<br/>  }<br/>});</span><span id="ab3d" class="mt lf it mk b gy my mv l mw mx">app.listen(3000);</span></pre><p id="02d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用content-type字符串调用了<code class="fe mh mi mj mk b">ctx.accepts</code>方法，我们希望在上面列出的那些头中检查该字符串，这样我们就可以返回相应的响应。</p><p id="0bf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们向我们的应用程序发出一个请求，其中一个头的值是<code class="fe mh mi mj mk b">application/json</code>,然后我们得到返回的字符串<code class="fe mh mi mj mk b">'accepts json'</code>作为响应。</p><h1 id="6306" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查客户端接受的编码</h1><p id="548c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">ctx.acceptsEncodings</code>方法来检查客户端接受哪种编码。</p><p id="0b02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它接受一个或多个编码类型字符串作为其参数，或者它可以是一个编码类型字符串数组。</p><p id="c876" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="15aa" class="mt lf it mk b gy mu mv l mw mx">const Koa = require('koa');<br/>const app = new Koa();</span><span id="dd7f" class="mt lf it mk b gy my mv l mw mx">app.use(async (ctx, next) =&gt; {  <br/>  if (ctx.acceptsEncodings('gzip') === "gzip"){<br/>    ctx.body = 'accepts gzip';<br/>  }<br/>  else {<br/>    ctx.body = 'does not accept gzip';<br/>  }</span><span id="6b6d" class="mt lf it mk b gy my mv l mw mx">});</span><span id="be70" class="mt lf it mk b gy my mv l mw mx">app.listen(3000);</span></pre><p id="6156" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用参数<code class="fe mh mi mj mk b">'gzip'</code>调用了<code class="fe mh mi mj mk b">ctx.acceptEncodings</code>方法。该方法返回最佳匹配的编码。</p><p id="d702" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们用<code class="fe mh mi mj mk b">Accept-Encoding</code>头<code class="fe mh mi mj mk b">gzip, deflate, br</code>向我们的应用程序发出请求，我们将从应用程序得到响应<code class="fe mh mi mj mk b">'accepts gzip'</code>。</p><p id="4248" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有给定参数，则返回所有接受的编码。</p><h1 id="fa07" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查客户端接受的字符集</h1><p id="d726" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以调用<code class="fe mh mi mj mk b">acceptsCharsets</code>来检查客户端接受的字符集。</p><p id="cf4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还接受一个或多个字符串作为接受的字符集名称，或者一个包含这些字符集名称的字符串数组。</p><p id="b9f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d9bc" class="mt lf it mk b gy mu mv l mw mx">const Koa = require('koa');<br/>const app = new Koa();</span><span id="d044" class="mt lf it mk b gy my mv l mw mx">app.use(async (ctx, next) =&gt; {</span><span id="63df" class="mt lf it mk b gy my mv l mw mx">  if (ctx.acceptsCharsets('utf-8') === 'utf-8'){<br/>    ctx.body = 'accepts utf-8';<br/>  }<br/>  else {<br/>    ctx.body = 'does not accept utf-8';<br/>  }</span><span id="112d" class="mt lf it mk b gy my mv l mw mx">});</span><span id="1bc1" class="mt lf it mk b gy my mv l mw mx">app.listen(3000);</span></pre><p id="a5d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码类似于<code class="fe mh mi mj mk b">acceptEncodings</code>代码。</p><p id="e6ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们发出一个不包含包含<code class="fe mh mi mj mk b">utf-8</code>的<code class="fe mh mi mj mk b">Accept-Charset</code>头的请求，那么我们将得到作为响应返回的<code class="fe mh mi mj mk b">‘does not accept utf-8’</code>。</p><p id="03ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，无论我们是否使用以<code class="fe mh mi mj mk b">utf-8</code>为值的<code class="fe mh mi mj mk b">Accept-Charset</code>头显式地发出请求，我们都将得到<code class="fe mh mi mj mk b">'accepts utf-8'</code>的返回。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/799e233a12575e1c1baa282d31d6cf29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8gcVzmS7HbdrUTCj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">吉勒·魅兰-蒙奈在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4f55" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查请求的语言</h1><p id="bdd4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">ctx.acceptsLanguages</code>让我们根据<code class="fe mh mi mj mk b">Accept-Language</code>头检查请求的语言。</p><p id="08f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它类似于上面的另外两个方法，只是带有参数和返回内容。</p><h1 id="7d6d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">获取任何标题字段</h1><p id="52d4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">ctx.get</code>方法获得任何请求头字段。例如，我们可以编写以下代码来实现这一点:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="aada" class="mt lf it mk b gy mu mv l mw mx">const Koa = require('koa');<br/>const app = new Koa();</span><span id="5cc3" class="mt lf it mk b gy my mv l mw mx">app.use(async (ctx, next) =&gt; {<br/>  ctx.body = ctx.get('foo');<br/>});</span><span id="65fa" class="mt lf it mk b gy my mv l mw mx">app.listen(3000);</span></pre><p id="7f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用标题名<code class="fe mh mi mj mk b">'foo'</code>调用了<code class="fe mh mi mj mk b">get</code>方法。如果存在，它返回<code class="fe mh mi mj mk b">'foo'</code>头的值。</p><p id="a0d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们用带有值<code class="fe mh mi mj mk b">bar</code>的<code class="fe mh mi mj mk b">foo</code>头发出请求时，我们将看到作为响应返回的<code class="fe mh mi mj mk b">'bar'</code>。</p><h1 id="8d33" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="8d64" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">ctx.is</code>方法来验证发送到服务器的数据类型。</p><p id="6071" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">做内容协商，可以用<code class="fe mh mi mj mk b">accepts</code>的方法。要检查语言、编码或字符集，有一些方法可以做到。</p><p id="d0d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以用<code class="fe mh mi mj mk b">get</code>方法获得任何请求头的值。</p></div></div>    
</body>
</html>