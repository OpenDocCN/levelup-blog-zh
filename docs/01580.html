<html>
<head>
<title>TypeScript Advanced Types — Nullable Types and Type Aliases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript高级类型—可空类型和类型别名</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-advanced-types-nullable-types-and-type-aliases-847f03b08fae?source=collection_archive---------5-----------------------#2020-01-14">https://levelup.gitconnected.com/typescript-advanced-types-nullable-types-and-type-aliases-847f03b08fae?source=collection_archive---------5-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8a1d1f1ff41ec4d0fd8767de0b9fce01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xIsCxpw7MCYL3-kK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kris_ricepees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gary Bendig </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e3a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript具有许多高级类型功能，这使得编写动态类型代码变得容易。它还有助于采用现有的JavaScript代码，因为它允许我们在使用TypeScript的类型检查功能的同时保留JavaScript的动态功能。TypeScript中有多种高级类型，如交集类型、联合类型、类型保护、可空类型和类型别名等等。在本文中，我们研究可空类型和类型别名。</p><h1 id="761f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可空类型</h1><p id="631a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了让我们将<code class="fe mh mi mj mk b">undefined</code>赋给带有<code class="fe mh mi mj mk b">--strictNullChecks</code>标志的属性，TypeScript支持可空类型。当标志打开时，我们不能将<code class="fe mh mi mj mk b">undefined</code>赋给没有附加可空操作符的类型成员。要使用它，我们只需在我们想要使用的类型的成员名称后加上一个问号。</p><p id="ba11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们打开了<code class="fe mh mi mj mk b">strictNullChecks</code>标志，并将一个属性值设置为<code class="fe mh mi mj mk b">null</code>或<code class="fe mh mi mj mk b">undefined</code>，那么就像我们在下面的代码中做的那样:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="22c9" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="a270" class="mt lf it mk b gy my mv l mw mx">let p: Person = {<br/>  name: 'Jane',<br/>  age: null<br/>}</span></pre><p id="39ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到以下错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f46f" class="mt lf it mk b gy mu mv l mw mx">Type 'null' is not assignable to type 'number'.(2322)</span><span id="2c26" class="mt lf it mk b gy my mv l mw mx">input.ts(3, 3): The expected type comes from property 'age' which is declared here on type 'Person'</span></pre><p id="eac4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们关闭了<code class="fe mh mi mj mk b">strictNullChecks</code>，上面的错误就不会出现，TypeScript编译器将允许代码被编译。</p><p id="af79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们打开了<code class="fe mh mi mj mk b">strictNullChecks</code>标志，并且我们希望能够将<code class="fe mh mi mj mk b">undefined</code>设置为一个属性的值，那么我们可以将该属性设置为able。例如，我们可以使用以下代码将接口的成员设置为可空:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fbe5" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string;<br/>  age?: number;<br/>}</span><span id="95c4" class="mt lf it mk b gy my mv l mw mx">let p: Person = {<br/>  name: 'Jane',<br/>  age: undefined<br/>}</span></pre><p id="9a73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe mh mi mj mk b">Person</code>接口中的<code class="fe mh mi mj mk b">age</code>成员后添加了一个问号，使其可为空。那么当我们定义对象的时候，就可以把<code class="fe mh mi mj mk b">age</code>设置为<code class="fe mh mi mj mk b">undefined</code>。我们仍然不能将<code class="fe mh mi mj mk b">age</code>设置为<code class="fe mh mi mj mk b">null</code>。如果我们尝试这样做，我们会得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1340" class="mt lf it mk b gy mu mv l mw mx">Type 'null' is not assignable to type 'number | undefined'.(2322)</span><span id="6086" class="mt lf it mk b gy my mv l mw mx">input.ts(3, 3): The expected type comes from property 'age' which is declared here on type 'Person'</span></pre><p id="26a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，可空类型只是我们声明的类型和<code class="fe mh mi mj mk b">undefined</code>类型之间的联合类型。这也意味着我们可以像其他联合类型一样使用类型保护。例如，如果我们想只获取已定义的年龄，我们可以编写以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4dcd" class="mt lf it mk b gy mu mv l mw mx">const getAge = (age?: number) =&gt; {<br/>  if (age === undefined) {<br/>    return 0<br/>  }<br/>  else {<br/>    return age.toString();<br/>  }<br/>}</span></pre><p id="68ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">getAge</code>函数中，我们首先检查<code class="fe mh mi mj mk b">age</code>参数是否为<code class="fe mh mi mj mk b">undefined</code>。如果是，那么我们返回0。否则，我们可以在它上面调用<code class="fe mh mi mj mk b">toString()</code>方法，该方法可用于给对象编号。</p><p id="7116" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以用类似的代码消除<code class="fe mh mi mj mk b">null</code>值，例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c5b9" class="mt lf it mk b gy mu mv l mw mx">const getAge = (age?: number | null) =&gt; {<br/>  if (age === null) {<br/>    return 0<br/>  }  <br/>  else if (age === undefined) {<br/>    return 0<br/>  }<br/>  else {<br/>    return age.toString();<br/>  }<br/>}</span></pre><p id="2646" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很方便，因为可空类型排除了将<code class="fe mh mi mj mk b">null</code>赋值为开<code class="fe mh mi mj mk b">strictNullChecks</code>的情况，所以如果我们希望<code class="fe mh mi mj mk b">null</code>能够作为<code class="fe mh mi mj mk b">age</code>参数的值传入，那么我们需要将<code class="fe mh mi mj mk b">null</code>添加到联合类型中。我们也可以将前两个<code class="fe mh mi mj mk b">if</code>模块合并成一个:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c9dc" class="mt lf it mk b gy mu mv l mw mx">const getAge = (age?: number | null) =&gt; {<br/>  if (age === null || age === undefined) {<br/>    return 0<br/>  }<br/>  else {<br/>    return age.toString();<br/>  }<br/>}</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/139a16a48327e1b8877b285809114744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7TIWPQekymm6lUMk"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@linneasandbakk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Linnea Sandbakk </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8bd4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">键入别名</h1><p id="a537" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们想为一个现有的类型创建一个新的名称，我们可以给这个类型添加一个类型别名。这可以用于许多类型，包括原语、联合、元组和任何其他我们可以手写的类型。要创建类型别名，我们可以使用<code class="fe mh mi mj mk b">type</code>关键字来完成。例如，如果我们要向联合类型添加别名，我们可以编写以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f417" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="c5b8" class="mt lf it mk b gy my mv l mw mx">interface Employee {<br/>  employeeCode: number;<br/>}</span><span id="f468" class="mt lf it mk b gy my mv l mw mx">type Laborer = Person &amp; Employee;<br/>let laborer: Laborer = {<br/>  name: 'Joe',<br/>  age: 20,<br/>  employeeCode: 100<br/>}</span></pre><p id="15f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">laborer</code>的声明与直接使用交集类型来类型化<code class="fe mh mi mj mk b">laborer</code>对象是一样的，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="424a" class="mt lf it mk b gy mu mv l mw mx">let laborer: Person &amp; Employee = {<br/>  name: 'Joe',<br/>  age: 20,<br/>  employeeCode: 100<br/>}</span></pre><p id="d439" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像声明其他类型一样声明基本类型的类型别名。例如，我们可以用不同的基元类型创建一个联合类型，如下面的代码所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f6b9" class="mt lf it mk b gy mu mv l mw mx">type PossiblyNumber = number | string | null | undefined;<br/>let x: PossiblyNumber = 2;<br/>let y: PossiblyNumber = '2';<br/>let a: PossiblyNumber = null;<br/>let b: PossiblyNumber = undefined;</span></pre><p id="5f15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mh mi mj mk b">PossiblyNumber</code>类型可以是数字、字符串、<code class="fe mh mi mj mk b">null</code>或<code class="fe mh mi mj mk b">undefined</code>。如果我们尝试像下面的代码那样将一个无效的布尔值赋给它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e9ae" class="mt lf it mk b gy mu mv l mw mx">let c: PossiblyNumber = false;</span></pre><p id="f355" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到以下错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="07b5" class="mt lf it mk b gy mu mv l mw mx">Type 'false' is not assignable to type 'PossiblyNumber'.(2322)</span></pre><p id="fcc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像任何其他无效的赋值一样。</p><p id="f45b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以在类型别名中包含泛型类型标记。例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e6cc" class="mt lf it mk b gy mu mv l mw mx">type Foo&lt;T&gt; = { value: T };</span></pre><p id="94b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">泛型类型别名也可以在类型的属性中引用。例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="187c" class="mt lf it mk b gy mu mv l mw mx">type Tree&lt;T&gt; = {<br/>  value: T;<br/>  left: Tree&lt;T&gt;;<br/>  center: Tree&lt;T&gt;;<br/>  right: Tree&lt;T&gt;;<br/>}</span></pre><p id="1ec2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以像在下面的代码中一样使用<code class="fe mh mi mj mk b">Tree</code>类型:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="06fb" class="mt lf it mk b gy mu mv l mw mx">type Tree&lt;T&gt; = {  <br/>  value: T,<br/>  left: Tree&lt;T&gt;;<br/>  center: Tree&lt;T&gt;;<br/>  right: Tree&lt;T&gt;;<br/>}</span><span id="f178" class="mt lf it mk b gy my mv l mw mx">let tree: Tree&lt;string&gt; = {} as Tree&lt;string&gt;;<br/>tree.value = 'Jane';</span><span id="a0f8" class="mt lf it mk b gy my mv l mw mx">tree.left = {} as Tree&lt;string&gt;<br/>tree.left.value = 'Joe';<br/>tree.left.left = {} as Tree&lt;string&gt;;<br/>tree.left.left.value = 'Amy';<br/>tree.left.right = {} as Tree&lt;string&gt;<br/>tree.left.right.value = 'James';</span><span id="9c16" class="mt lf it mk b gy my mv l mw mx">tree.center = {} as Tree&lt;string&gt;<br/>tree.center.value = 'Joe';</span><span id="57dc" class="mt lf it mk b gy my mv l mw mx">tree.right = {} as Tree&lt;string&gt;<br/>tree.right.value = 'Joe';</span><span id="6a82" class="mt lf it mk b gy my mv l mw mx">console.log(tree);</span></pre><p id="2712" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一行的<code class="fe mh mi mj mk b">tree</code>对应的<code class="fe mh mi mj mk b">console.log</code>应该会让我们:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0928" class="mt lf it mk b gy mu mv l mw mx">{<br/>  "value": "Jane",<br/>  "left": {<br/>    "value": "Joe",<br/>    "left": {<br/>      "value": "Amy"<br/>    },<br/>    "right": {<br/>      "value": "James"<br/>    }<br/>  },<br/>  "center": {<br/>    "value": "Joe"<br/>  },<br/>  "right": {<br/>    "value": "Joe"<br/>  }<br/>}</span></pre><p id="0502" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的TypeScript编译器配置中，当<code class="fe mh mi mj mk b">strictNullChecks</code>标志为on时，我们希望能够将<code class="fe mh mi mj mk b">undefined</code>赋给一个属性，可空类型是有用的。它只是你拥有的任何类型和<code class="fe mh mi mj mk b">undefined</code>之间的联合类型。它由属性名后的问号表示。这意味着我们可以像其他联合类型一样使用类型保护。注意，可空类型不允许将<code class="fe mh mi mj mk b">null</code>值赋给它，因为只有当<code class="fe mh mi mj mk b">strictNullChecks</code>标志打开时才需要可空类型。类型别名让我们为已经存在的类型创建一个新的名称。我们也可以使用带有类型别名的泛型，但是我们不能将它们作为独立的类型使用。</p></div></div>    
</body>
</html>