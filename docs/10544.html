<html>
<head>
<title>Morris Traversal for Binary Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树的Morris遍历</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/morris-traversal-for-binary-trees-e36e43a665cf?source=collection_archive---------11-----------------------#2021-12-19">https://levelup.gitconnected.com/morris-traversal-for-binary-trees-e36e43a665cf?source=collection_archive---------11-----------------------#2021-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/45b64e51615bd40488074fed5daf8317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xoj9kYYOpGYIASmF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">宝琳·伯恩菲尔德在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f31f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">二叉树是求职面试中常见的问题，尤其是各种树的遍历。这里我们将讨论从左到右或从右到左的遍历。</p><h2 id="a863" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">深度优先搜索</h2><p id="55bb" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果我们需要以一种有序的方式遍历一棵二叉树，默认的解决方案是深度优先搜索，它使用一个堆栈。</p><p id="ac53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以使用递归调用堆栈或显式使用集合(例如，Java中的Deque)。在这两种情况下，算法都具有O(n)时间复杂度和O(n)空间复杂度。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">递归深度优先搜索</figcaption></figure><h2 id="c051" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">莫里斯遍历</h2><p id="fbac" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们能做得更好吗？在实际项目中，可能不会。但是如果我们谈论的是工作面试，那么是的。用于有序遍历的Morris算法允许你以O(n)时间和O(1)空间复杂度遍历一棵树。但是它需要在运行时改变树。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/1fa0cb00f8a1b6fb06454e094ba97090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*b6r0bBc0LdHciOuSG7v9tg.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">非动画幻灯片在这里是<a class="ae kc" href="https://drive.google.com/drive/folders/166o6q9cIKB7ZTE0jk6bEMXX7CwlKFSzY?usp=sharing" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="0aee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关键是向左走之前要记住当前节点。当我们注意到已经创建了这样一个连接时，删除它并访问节点。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="91d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来计算一下复杂度。我们不使用任何其他集合，所以空间复杂度是O(1)。并且每个节点最多被访问3次，所以具有O(3n)=O(n)的时间复杂度。</p><p id="afcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很难用在实际项目中，应该是非常具体的案例。在大多数情况下，现有的集合更适合。但是在工作面试的时候可能会被问到。</p></div></div>    
</body>
</html>