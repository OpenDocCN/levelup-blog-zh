# 软件开发中单元测试的再思考

> 原文：<https://levelup.gitconnected.com/rethinking-unit-testing-in-software-development-11b948483ed>

说到单元测试，硬币总是有两面的。单元测试有回报吗？值得吗？

![](img/198174c8748b686b87a174856f897fb9.png)

来源:https://github.com/egonelbre/gophers

> 对你的单元测试所能达到的目标要谦虚，除非你对被测试的单元有外在的需求。在一个合理的测试周期内，单元测试不太可能测试超过任何给定方法的万亿分之一的功能。
> 
> —James O . Coplien 关于“为什么大多数单元测试都是浪费”

![](img/3af579408d173638221aa639c362b47e.png)

由[在](https://unsplash.com/@nbb_photos?utm_source=medium&utm_medium=referral) [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的拉齐·斯莱扎克的照片。单元测试可能会让你像这位女士一样感到压力。她扔掉了所有的 TDD 书籍，因为 TDD 有时会很累。

这篇文章谈到了我对单元测试的想法。如果你想亲自动手，我很快会有一个 Go 语言教程“ *Gorm for SQL in Go* ”。如果您是单元测试的新手，我建议您阅读其中的一些内容，然后尝试两种不同的练习:

*   尝试构建一个简单的项目，并在任何可测试的时候添加单元测试。例如建立停车场系统。这里有一个简单的问题，overkilled solution +在 [my github](https://github.com/iqDF/Parking-Lot-OOP) 中的单元测试。此处不允许第三方库。
*   尝试构建应用程序。比如用极简的 web 框架+ ORM /数据库连接器库构建一个 web 应用。现在记住，单元测试是关于隔离测试的，但是你的代码现在依赖于其他组件。如何添加单元测试？它给你带来了什么好处？

# 目录

**一、单元测试—** 什么是单元测试，什么不是单元测试？

**二。单元测试的优势—** 一个写得好的单元测试有多大价值？

**三。对单元测试优势的误解——它永远不会给你什么。**

**四。单元测试的成本—** 单元测试的成本和编写糟糕单元的风险。

那么什么时候单元测试有价值呢？— 然后你应该做其他种类的测试吗？

## 这篇文章是关于什么的？

我要谈一点关于单元测试的内容，因为我认为值得停下来思考一下:

*   单元测试是必须的吗？我看到过许多不值得做的事情，而跳过功能测试是非常值得的。这也不是一种规范，尽管许多书籍和资源鼓励单元测试甚至 TDD。作为一名软件工程师，你不能盲目地跟随书本、导师或者你的技术领导所说的。
*   但这只是单元测试，对吗？不是很简单快捷吗？答案是一个很大的**否**但是当然这要看情况。对于我的大多数后端应用程序来说，这是一个很大的 **NO** 并且编写一个写得很好的单元测试是很乏味的。我说的只是单元测试，还不是功能或集成测试。

## 这不是为了什么？

*   这是**不是**反单元测试，我也不建议你删除你的测试代码。
*   这是关于如何编写测试的教程。

# 单元测试

我认为迟早我们将不得不谈论单元测试以及为什么它非常困难。单元测试并不像我想的那么容易。它需要一个模块与其外部依赖项(如数据库层或 API 客户端)隔离开来。

我采访过的许多开发人员误解了什么是单元测试，什么是单元测试。对于其中的一些人来说，单元测试被描述为“只是测试一个单一的功能”，这与事实相差甚远，而且一旦你创建了一个相当复杂的应用程序，这并不容易。

![](img/9e23ef6e854718b91628bc8034af145b.png)

Jon Flobrant 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。当单元测试让你紧张时，穿着比基尼沉思有助于减轻你的思想负担。但是你知道还有什么帮助吗？

有许多正式的定义和文章解释了什么是集成测试和单元测试。以下是我用自己的语言总结的内容:

*   *集成测试:*测试多个组件以及它们如何一起工作。例如，另一个系统如何与您的系统交互，或者数据库如何与您的数据抽象层交互。通常这需要一个完全安装的系统，尽管在最纯粹的形式中并不需要。
*   *单元测试*:是软件**测试**的一个层次，测试软件的单个**单元** /组件。目的是验证软件的每个**单元**是否按设计执行。单元是任何软件中最小的部分。它通常有一个或几个输入和一个输出，我们称之为函数或方法。

简而言之，单元测试需要三个要点:

*   **白盒测试**。这意味着对于已知的输入和边缘情况，代码会按预期执行。例如，如果您正在测试应用程序的数据层，您需要测试由 ORM 生成的 SQL 或查询。然后看看在使用 ORM 库时，查询是否与您想要的完全一样。
*   **极度模块化和代码拆分**。这与做白盒测试齐头并进。单元测试是关于测试任何软件中可能的最小单元。当您可以从最小的、可重用的单元开始构建更复杂的功能时，模块化代码可以提高可测试性。然而，代码分割可能会破坏您之前设计的软件架构。
*   **孤立和嘲弄**。任何对其他组件的依赖，无论是外部的还是内部的，都应该被嘲笑。这是 TDD 开发者的强硬路线。在我看来，嘲讽是最难的部分。您的代码必须结构良好，并遵循坚实的原则。你的*类*和*模块*的*范围*必须被很好地定义，这样当它们被测试时，你就可以模拟依赖关系，反之亦然。

# 良好实现的单元测试的优势

努力工作一定会有回报，不是吗？嗯，这要视情况而定，但我可以肯定的是，测试更少，但可以说是一个大脑难题，更多的是艰苦的工作。那么你从这些单元测试中得到什么呢？

在我看来，从长远来看，单元测试有两个主要优点。多久才算长？取决于你的冲刺，但对我来说，从第二个冲刺周期开始，我已经感受到了以下好处:

1.  *自动捕捉 bug*。我不认为这是一个惊喜，也不需要解释。代码冲刺中的团队协作意味着大量的代码被推送，大量的变更，因此需要在合并新功能、修复 bug、重构、配置变更等之前进行自动化测试。
2.  *可解释、可解释的错误调试*。这是我认为最有价值的部分。对我来说，做单元测试的成本只有在它让我从几天的调试中解脱出来时才是值得的。写得好的代码可以立即查明错误发生的确切原因，在哪个模块的哪个特定函数/方法中。然而，这个特性要求你设计好你的单元测试并开发好测试代码，包括结果记录和测试标签。
3.  *非官方指南或文件*。好的测试也可以作为使用界面的非正式指南。这个好处实际上适用于任何类型的测试。写得好的测试清楚地展示了如何使用你的 API 以及预期的结果是什么。

# 对单元测试优势的误解

1.  *更多报道！=提高代码质量*。一个设计良好的测试，最多，提供了一个当前实现缺少什么来实现理想系统的洞察力。另一方面，好的系统设计和编程可以做到。
2.  *先写考卷让人思路更清晰。*相反，在编写实现时，在增加复杂性之前执行 TDD 或编写测试。似乎测试中的信息比代码中的信息要多。我已经实践 TDD 年了，在成为后端工程师之前，我是测试自动化的软件工程师，编写了 100 个单元测试和 67 个端到端集成测试。我可以肯定，TDD 训练不会让一个人成为更好的程序员。实践好的设计和编程！
3.  *故障更少，更安全*。如果您有全面的单元测试，但是在系统测试中仍然有很高的失败率，或者在现场的质量很低。或许是时候重新思考你的设计方案了，而不是增加更多的单元测试和错误修复。我不能强调一个好的设计比到处进行测试有多重要。

# 单元测试的成本和黑暗面

> …程序能做什么在某种程度上与开始执行时磁带上的位数有关。如果你想彻底地测试那个程序，你需要一个至少有相同信息量的测试…
> 
> —James O . Coplien 关于“为什么大多数单元测试都是浪费”

1.  *时间*。单元测试通常比实际实现花费更多的时间。在我作为后端开发人员的情况下，我平均花费了两倍的时间来实现一个应用程序，尽管我已经熟悉了测试套件或我正在使用的 web 应用程序框架。对一些人来说，这可能需要
2.  *强制重构和代码拆分*。大多数时候，单元测试需要分割你的算法，仅仅是为了满足单元测试的一致性，而不是为了模块化。这可能意味着破坏您的系统架构和代码理解，以更好的粒度进行测试。
3.  糟糕的笔试让人困惑。写得不好的测试会导致混乱，并给进一步的改变制造不必要的障碍。糟糕的测试也有在你的软件中引入错误的风险，如果测试(逻辑、结果记录等)设计得不好，可能会污染测试结果。有多少次你执行单元测试，但是当测试失败时，你仍然需要执行英勇的调试？
4.  *又一堆干草*。如果写得不好，你的单元测试只会告诉你的代码是否在某个地方出了问题，但是这个地方是你的测试代码引入的一堆 hays 加上另一堆 hays 中的一根针。你将会看到一堆被追踪的错误，而没有任何关于是什么破坏了你的代码的提示。

# 什么时候单元测试达到最大收益呢？

> …一些系统具有关键算法，如网络路由算法，可针对单个 API 进行测试。正如我在上面所说的，有一个正式的 oracle 来派生这种 API 的测试。所以那些单元测试是有价值的。
> 
> —James O . Coplien 关于“为什么大多数单元测试都是浪费”*(第 11 页)*

复杂的算法从单元测试中受益匪浅。算法程序有明确定义的步骤和输入输出，但同时它们可能有复杂的边缘情况需要处理。您希望尽可能地确保您的实现完全符合纸上设计的算法，并处理所有预期的边缘情况。

## 给我举个例子！

现在，让我们说已经很好地理解了算法，你准备实施部分。该算法可以分解成几个部分，每个部分的实现可以从添加一个简单的测试开始，然后是实现。

例如，如果你正在实现 Dijkstra 算法，你这个算法可以分解成五个步骤:

1.  入门:初始化相关数据结构:PriorityQueue(最小堆)和距离表
2.  初始化距离关联表，StartNode 的距离为零，其他的为无穷大(例如 MAX_INT)
3.  广度优先搜索，但是有点扭曲:使用 MinHeap(优先级队列)代替普通的队列结构

4.检查是否到达目的节点，返回并退出

5.当没有到达目的节点时，如果我们发现一个更短的距离，则将下一个节点推到优先队列。

## 我们怎么做迪杰斯特拉？

您可以为这些步骤实现 TDD，并添加一个相当简单的测试用例来确保它们的行为符合您的算法设计，很好地处理所有边缘情况。我建议进行参数化测试。Elliot Chance 写了一篇关于 go 中[参数化测试的博客。](http://elliot.land/post/go-data-driven-or-parameterized-tests)

1.  `TestMinHeapPop()`:确保`minHeap.Pop()`总是将数组中的最后一个元素排队的测试。堆推送操作确保最后一个元素是堆中所有节点中距离最小的元素。
2.  `TestMinHeapPush()`:确保`minHeap.Push()`添加了项目并重组堆的测试，使得堆数组中的最后一个项目是包含离节点最小距离的项目。
3.  `TestEnqueueNextNode()`:`TestEnqueueNextNode()`是独立的，孤立的。如果您碰巧使用其他库中的实现来实现`MinHeap`，您可能也想模仿它

当你完成一个实现时，将边缘案例测试添加到你的软件中，并构建更复杂的算法部分，直到一切都完成。您可能希望确保单元测试涵盖一些重要的步骤。

然后功能测试可以在你完成后添加到上面。在任何类似 CP 或 LeetCode 的实践中，您的功能测试可以像 sphere online judge 一样工作。他们将整个算法作为一个组件进行测试。

这是一个组件测试，但是很适合添加到你的测试中。用参数化测试来测试你的 dijkstra 算法。把你能想到的边缘案例也放进去。

*提示:*我还建议在开发期间将`TestDijkstra()`标记为对`TestEnqueueNextNode()`的依赖测试，这样如果`TestEnqueueNextNode()`失败，这个测试将被跳过，直到你首先修复了依赖测试。这样做的目的是让你的测试结果不那么混乱，并且更容易找到导致错误的原因。