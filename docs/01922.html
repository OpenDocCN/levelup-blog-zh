<html>
<head>
<title>Write Better Python by Learning Elm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过学习Elm写出更好的Python</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-better-python-by-learning-elm-66c391fa3fec?source=collection_archive---------8-----------------------#2020-02-06">https://levelup.gitconnected.com/write-better-python-by-learning-elm-66c391fa3fec?source=collection_archive---------8-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0e39cc502a3377cda4190ce13c86429c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOh-K6GhX2z0Mhtw-1ELRg.jpeg"/></div></div></figure><p id="f15e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我用<a class="ae kw" href="https://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>构建了一个小型的辅助项目，这是一种用于前端的函数式编程语言，以其极端的健壮性而闻名。回到Python，我注意到我对这门语言的看法已经发生了变化。</p><p id="7a33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我重点介绍了Python中一些常见的反模式，并提出了一些替代方案，使您的代码不容易出错。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a48e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是Elm，我为什么要关心？</h1><p id="ced3" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">那么关于Elm的炒作到底是怎么回事呢？Elm是一种用于前端的函数式编程语言，具有出色的性能和一些独特的特性:</p><h2 id="cf35" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">没有运行时异常</h2><p id="2b90" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">最重要的是，它以没有运行时异常而自豪。让这件事过去一会儿。尤其是在使用像Python这样的动态类型语言处理大型应用程序时，您(和您的用户)多久一次？)看到类似<code class="fe mt mu mv mw b">TypeError: argument of type 'NoneType' is not iterable</code>或<code class="fe mt mu mv mw b">KeyError: 'code'</code>的隐晦错误信息？</p><p id="16d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行时异常是在运行时引发的异常，这意味着编译器在运行代码之前无法捕捉它们。即使有很好的测试覆盖率，一些问题也会从缝隙中溜走，只有当有人使用你的应用程序时才会被发现。此时修复它们是一个漫长而乏味的过程，因为您需要经历一个完整的</p><ol class=""><li id="db97" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">重现bug</li><li id="2dd4" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">潜在地编写测试用例</li><li id="3313" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">实际的代码更改</li><li id="8a5b" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">代码审查</li><li id="be8a" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">合并</li><li id="4107" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">部署</li><li id="8f07" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">以及又一轮点击/用户测试。</li></ol><p id="98e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，如果我们的编译器能够在编译时捕获这些错误，它们就永远不会出现在我们的主分支中，我们将节省大量的时间。没有运行时异常的承诺是巨大的！</p><h2 id="7d00" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">编译器驱动的开发</h2><p id="3196" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">还有更多有趣的特性，比如友好的指导性错误消息，它不仅会告诉你编译器哪里出错了，还会轻轻地把你推向解决问题的正确方向。Elm社区通常将此称为编译器驱动的开发:您更改一些代码，尝试编译，然后迭代地解决问题，直到编译器满意为止。一旦达到这种状态，您的代码就会运行。</p><p id="43f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我看来，这就是榆树的伟大之处。一旦编译器对你的程序感到满意，你就可以对它相当有信心了。与Python相比，在处理大型要素时。即使有很高的测试覆盖率和同行评审，当在试运行的第一次用户测试中出现问题时，您也不会感到太惊讶。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="7a89" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">外卖</h1><p id="3130" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">作为一名皮达主义者，学习榆树对我来说是一次屈辱的经历。在深入研究具体的反模式之前，我想提一下两个关键的见解:</p><h2 id="d3fd" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">社区</h2><p id="ae23" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">首先，我现在更加欣赏Python这个庞大而成熟的社区。当你遇到问题时，你可以谷歌一下，99%的情况下，你会找到一个人的帖子，他有同样的问题和多个很好的解决方案。在Elm这样的新兴语言中，情况并不总是这样。你将需要搜索更长的时间，关于最佳实践的智能博客文章越来越少，语言本身仍在经历许多突破性的变化，这意味着一年前有效的解决方案现在可能已经过时。</p><h2 id="244b" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">灵活性是有代价的</h2><p id="d062" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">其次，我对我为Python的灵活性所付出的代价有了更好的认识。动态类型既可以是礼物，也可以是负担。当你只是想抽出一些代码来让原型工作时，隐式是很好的，但是特别是当构建更大的应用程序时，它会带来很多麻烦。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="1687" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">反模式和替代方案</h1><p id="6cec" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在本节中，我们将继续不断地重构一些Python代码，以提高其健壮性和可理解性。</p><h2 id="16fb" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">脆弱代码</h2><p id="8438" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">让我们看看下面的<code class="fe mt mu mv mw b">is_paid</code>函数，它使用一个字典并检查是否设置了<code class="fe mt mu mv mw b">"paid_date"</code>值:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="1c0b" class="mh lf iq mw b gy nt nu l nv nw">def is_paid(invoice):<br/>    return invoice["paid_date"] is not None</span></pre><p id="5543" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能看出这个功能最大的问题吗？没错。你不能保证<code class="fe mt mu mv mw b">"paid_date"</code>在字典里有。调用这个函数可能会导致一个<code class="fe mt mu mv mw b">KeyError: 'paid_date'</code>。这段代码相当脆弱，你需要在重构时密切关注。</p><p id="c508" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更安全的方法是将其重写为</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="1e66" class="mh lf iq mw b gy nt nu l nv nw">def is_paid(invoice):<br/>    return invoice.get("paid_date") is not None</span></pre><p id="c8e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会在这里讨论更多的细节，但是如果你感兴趣的话，一定要查看一下<a class="ae kw" href="https://github.com/dry-python/returns" rel="noopener ugc nofollow" target="_blank"> returns </a>。这个库通过向Python引入一个类似Elm的<code class="fe mt mu mv mw b">Maybe</code>容器，为这类问题提供了一个非常优雅的解决方案。</p><h2 id="7a7c" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">打字模块</h2><p id="e669" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我们再来看看<code class="fe mt mu mv mw b">is_paid</code>:你怎么知道<code class="fe mt mu mv mw b">invoice</code>是什么？一点都不明显。它可能是一本字典。它也可以是实现<code class="fe mt mu mv mw b">.get</code>方法的自定义类型。您只能通过研究调用该函数的代码库的其他部分来获得答案。</p><p id="984b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更具体的一个好方法是Python的<code class="fe mt mu mv mw b">typing</code>模块。我们通常使用一种混合的方法，在这种方法中，我们不一定要输入整个代码库，而是关注关键的、复杂的或不明显的部分。它将记录你的代码并节省大量时间，特别是当新的开发人员加入你的团队时。</p><p id="bef2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个改进的版本是:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="590d" class="mh lf iq mw b gy nt nu l nv nw">from typing import Dict</span><span id="2fcf" class="mh lf iq mw b gy nx nu l nv nw">def is_paid(invoice: Dict[str, Any]) -&gt; bool:<br/>    return invoice.get("paid_date") is not None</span></pre><p id="930a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在很明显，invoice被期望成为一个字典，并且<code class="fe mt mu mv mw b">.get</code>的行为变得很明显。</p><p id="b7fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您使用像<a class="ae kw" href="https://www.jetbrains.com/de-de/pycharm/" rel="noopener ugc nofollow" target="_blank"> PyCharm </a>这样的IDE，这将为您带来<a class="ae kw" href="https://www.jetbrains.com/help/pycharm/type-hinting-in-product.html#validate-type-hints" rel="noopener ugc nofollow" target="_blank">额外的代码检查和警告</a>的好处。</p><p id="871e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你想学习更多关于打字的知识时，我推荐阅读realpython.com关于这个主题的伟大指南。</p><h2 id="3a78" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">自定义类型</h2><p id="bf59" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">知道发票是一本字典更好，但是我们仍然对它的内容一无所知。<code class="fe mt mu mv mw b">invoice</code>应该有哪些键？<code class="fe mt mu mv mw b">"paid_date"</code>键是否总是可用？我们对发票的内容缺乏明确的定义。这需要一个自定义类型！</p><p id="a905" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尤其是因为Python的类语法可能相当笨拙，所以很容易陷入反模式，即没有定义足够多的自定义类型，而是过于依赖字典或元组之类的原生类型。</p><p id="b3ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，让我们的发票由三个属性组成:<code class="fe mt mu mv mw b">amount</code>、<code class="fe mt mu mv mw b">paid_date</code>和<code class="fe mt mu mv mw b">status</code>。当把它定义为一个常规类时，你会得到这样的结果:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="e5e2" class="mh lf iq mw b gy nt nu l nv nw">class Invoice:<br/>    def __init__(self, amount, paid_date, status):<br/>        self.amount = amount<br/>        self.paid_date = paid_date<br/>        self.status = status</span></pre><p id="1a01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，这是相当多的杂乱和重复…因此非常不和谐。幸运的是，有更简洁的定义方法。这里有一个使用<code class="fe mt mu mv mw b">dataclasses</code>的例子:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="dc8e" class="mh lf iq mw b gy nt nu l nv nw">from dataclasses import dataclass<br/>from datetime import datetime<br/>from typing import Optional</span><span id="1def" class="mh lf iq mw b gy nx nu l nv nw">@dataclass<br/>class Invoice:<br/>    id: int<br/>    amount: float<br/>    paid_date: Optional[datetime]<br/>    status: str</span></pre><p id="fc72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">利用这一点，我们可以重构代码，只接受新的自定义类型:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="ad34" class="mh lf iq mw b gy nt nu l nv nw">def is_paid(invoice: Invoice) -&gt; bool:<br/>    return invoice.paid_date is not None</span></pre><p id="aee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ny">注意:</em> </strong> <em class="ny">在这一点上，你也可以仅仅让它成为</em> <code class="fe mt mu mv mw b"><em class="ny">Invoice</em></code> <em class="ny">的一个属性，但是我把这个练习留给有野心的读者；)</em></p><p id="4457" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意<code class="fe mt mu mv mw b">dataclasses</code>只有Python 3.7以后才有。好的替代品是<a class="ae kw" href="https://github.com/python-attrs/attrs" rel="noopener ugc nofollow" target="_blank"/><code class="fe mt mu mv mw b"><a class="ae kw" href="https://github.com/python-attrs/attrs" rel="noopener ugc nofollow" target="_blank">attr</a></code><a class="ae kw" href="https://github.com/python-attrs/attrs" rel="noopener ugc nofollow" target="_blank">项目</a>或<a class="ae kw" href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noopener ugc nofollow" target="_blank">命名的双</a>项目，尽管它们在其他特性上也有所不同。</p><p id="c1f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想深入这个主题，我推荐<a class="ae kw" href="https://www.youtube.com/watch?v=T-TwcmT6Rcw" rel="noopener ugc nofollow" target="_blank"> Raymond Hettinger关于PyCon2018的数据类的演讲</a>和<a class="ae kw" href="https://realpython.com/python-data-classes/" rel="noopener ugc nofollow" target="_blank"> realpython.com的“终极指南”</a>。</p><h2 id="8bd7" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">可变性:</h2><p id="6163" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">Python这样的语言的另一个问题是可变性。列表和字典是可变的，这会在你的代码中引起令人惊讶的错误。对于函数或方法中的<a class="ae kw" href="https://docs.quantifiedcode.com/python-anti-patterns/correctness/mutable_default_value_as_argument.html" rel="noopener ugc nofollow" target="_blank">可变默认参数</a>，您很可能至少遇到过一次这种情况。我不会在这里深入讨论细节，但至少我想提一下，<code class="fe mt mu mv mw b">dataclasses</code>和<code class="fe mt mu mv mw b">attr</code>都支持一个可选的<code class="fe mt mu mv mw b">frozen</code>关键字来使你的类(<a class="ae kw" href="https://docs.python.org/3/library/dataclasses.html#frozen-instances" rel="noopener ugc nofollow" target="_blank">几乎是</a>)不可变。</p><h2 id="bc07" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">枚举:</h2><p id="def5" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在大多数应用程序中，您会发现枚举值的用例，例如，一个属性应该只有有限的一组可能值。我们的<code class="fe mt mu mv mw b">Invoice.status</code>就是一个很好的例子。当然，这个字段只允许一小组值，例如<code class="fe mt mu mv mw b">"Draft"</code>、<code class="fe mt mu mv mw b">"Sent"</code>、<code class="fe mt mu mv mw b">"Paid"</code>和<code class="fe mt mu mv mw b">"Cancelled"</code>。在我们当前的实现中，这些只是字符串。虽然这种方法有效，但它对输入错误的抵抗力不是很强。</p><p id="70eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑下面的例子:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="b350" class="mh lf iq mw b gy nt nu l nv nw">def is_open(invoice: Invoice) -&gt; bool:<br/>    return invoice.status == "Send"</span></pre><p id="cd3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你看出问题了吗？我们输入了<code class="fe mt mu mv mw b">"Send"</code>而不是<code class="fe mt mu mv mw b">"Sent"</code>。在最坏的情况下，这可能会导致过期发票被标记为已支付，您的公司会损失相当多的钱。吓人！当您使用enum时，您可以更好地防范这些错误:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="df36" class="mh lf iq mw b gy nt nu l nv nw">...<br/>from enums import Enum</span><span id="2a05" class="mh lf iq mw b gy nx nu l nv nw">class InvoiceStatus(Enum):<br/>    DRAFT = "Draft"<br/>    SENT = "Sent"<br/>    PAID = "Paid"<br/>    CANCELLED = "Cancelled"</span><span id="c570" class="mh lf iq mw b gy nx nu l nv nw">@dataclass<br/>class Invoice:<br/>    ...<br/>    status: InvoiceStatus</span></pre><p id="d0e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的<code class="fe mt mu mv mw b">is_open</code>函数变成了</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="95a4" class="mh lf iq mw b gy nt nu l nv nw">def is_open(invoice: Invoice) -&gt; bool:<br/>    return invoice.status === InvoiceStatus.SEND</span></pre><p id="a9eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在调用该函数时引发一个<code class="fe mt mu mv mw b">AttributeError: SEND</code>。因此，即使您只有一个调用该功能的测试用例，您也一定会在部署之前发现这个bug。</p><h2 id="7b77" class="mh lf iq bd lg mi mj dn lk mk ml dp lo kj mm mn ls kn mo mp lw kr mq mr ma ms bi translated">模糊类型</h2><p id="97f5" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">最后但同样重要的是，我想强调使用模糊参数或返回类型的问题。它们将不可避免地增加代码的复杂性，如果您在处理它们时不太注意的话，还会导致许多错误。</p><p id="3cca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下面的例子为例，我们添加了一个新的<code class="fe mt mu mv mw b">InvoiceMeta</code>类型，它携带了一些发票的元数据(这是一个玩具示例，但我希望您能明白这一点):</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="4055" class="mh lf iq mw b gy nt nu l nv nw">def get_meta(invoice, metas):<br/>    for meta in metas:<br/>        if invoice.id == meta.id:<br/>            return meta</span><span id="68b1" class="mh lf iq mw b gy nx nu l nv nw">meta = get_meta(invoice, metas)<br/>print(meta.recipient)</span></pre><p id="fbdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有什么问题？代码隐含地假设所有的发票都有一个相应的元实体。但是如果这个假设不成立，我们就会遇到一个例外:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="b321" class="mh lf iq mw b gy nt nu l nv nw">AttributeError: 'NoneType' object has no attribute 'recipient'</span></pre><p id="a654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">啪！好的，如果我们完全使用类型注释，我们会发现这一点，因为返回类型必须是<code class="fe mt mu mv mw b">Optional[InvoiceMeta]</code>。但即使这样，你也会发现自己在编写更复杂的代码，因为你总是需要检查meta是<code class="fe mt mu mv mw b">InvoiceMeta</code>还是<code class="fe mt mu mv mw b">None</code>:</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="91f1" class="mh lf iq mw b gy nt nu l nv nw">meta = get_meta(invoice, metas)<br/>if meta is None:<br/>    print("Recipient unknown as no InvoiceMeta was recorded.")<br/>else:<br/>    print(meta.recipient)</span></pre><p id="213f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如在<a class="ae kw" href="https://docs.quantifiedcode.com/python-anti-patterns/maintainability/returning_more_than_one_variable_type_from_function_call.html" rel="noopener ugc nofollow" target="_blank"> Python反模式</a>中所建议的，更好的方法是直接在<code class="fe mt mu mv mw b">get_meta</code>中引发异常，然后在代码的不同层处理错误。</p><pre class="nl nm nn no gt np mw nq nr aw ns bi"><span id="b52b" class="mh lf iq mw b gy nt nu l nv nw">def get_meta(invoice, metas):<br/>    for meta in metas:<br/>        if invoice.id == meta.id:<br/>            return meta<br/>    raise LookupError(f"No InvoiceMeta available for {invoice.id}")</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="8fa9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9c15" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">尽管我没有过多地谈论它，但潜入Elm是一次很棒的经历和许多乐趣！希望以后能多找时间陪它玩。同时，我很感激我在软件开发中获得的新观点。</p><p id="5356" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这些模式能帮助您编写更健壮的代码。试着在代码评审中找出它们，并与你的队友分享。</p></div></div>    
</body>
</html>