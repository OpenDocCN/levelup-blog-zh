<html>
<head>
<title>Managing File Uploads in React with Ant Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React与Ant Design中管理文件上传</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-file-uploads-with-ant-design-6d78e592f2c4?source=collection_archive---------0-----------------------#2019-04-15">https://levelup.gitconnected.com/managing-file-uploads-with-ant-design-6d78e592f2c4?source=collection_archive---------0-----------------------#2019-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/6073753577fd66b3e2e45195a1c123a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*gX7NSK5N52hUVsWobmb_dA.gif"/></div></figure><p id="b50a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在最近的一个项目中，我必须为React应用程序创建一个表单组件，其中一个表单项需要允许用户上传文件。Ant Design的<a class="ae kv" href="https://ant.design/components/upload/" rel="noopener ugc nofollow" target="_blank">上传</a>组件使得这个过程变得非常容易，因为你需要的大部分前端文件管理都内置在其中。</p><p id="97a2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kw kx ky kz b">Upload</code>不依赖于Ant Design的<code class="fe kw kx ky kz b">Form</code>组件。你可以在模态中使用它，也可以单独使用它。对于我的情况，一位同事建议我说，<code class="fe kw kx ky kz b">Form</code>组件可能比带有输入的模型更好，因为我将不得不更少地依赖本地状态。我不得不说<code class="fe kw kx ky kz b">Form</code>组件相当健壮。</p><p id="e131" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">稍后我会更深入地介绍我是如何使用<a class="ae kv" href="https://ant.design/components/form/" rel="noopener ugc nofollow" target="_blank">表单组件</a>的，但是虽然<code class="fe kw kx ky kz b">Form</code>组件很健壮，但是<code class="fe kw kx ky kz b">Upload</code>组件在React应用中工作所需要的只是<a class="ae kv" href="https://www.npmjs.com/package/antd" rel="noopener ugc nofollow" target="_blank">安装ant设计依赖项</a>并从中导入<code class="fe kw kx ky kz b">Upload</code>。安装完依赖项后，在组件顶部包含这两行:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="792f" class="li lj it kz b gy lk ll l lm ln">import "antd/dist/antd.css";</span><span id="e6e5" class="li lj it kz b gy lo ll l lm ln">import {Upload} from "antd";</span></pre><p id="7c4f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你打算用Webpack加载样式，请查看这个StackOverflow <a class="ae kv" href="https://stackoverflow.com/questions/52634183/react-ant-design-styles-not-loading" rel="noopener ugc nofollow" target="_blank">问答</a>。有关Ant Design入门的更多信息，请单击此处的<a class="ae kv" href="https://ant.design/docs/react/getting-started" rel="noopener ugc nofollow" target="_blank"/>。一旦所有东西都被导入，我们就可以开始使用它了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lp"><img src="../Images/ae731052b830cc091b1b5facf4e11882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbx-hrboTXntfRf_l7wQYQ.png"/></div></div></figure><p id="45fa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kw kx ky kz b">Form.Item</code>组件允许我们使用<code class="fe kw kx ky kz b">Form</code>组件提供的<code class="fe kw kx ky kz b">props</code>来更好地处理表单的输入。它提供的道具之一就是<code class="fe kw kx ky kz b">getFieldDecorator</code>。</p><p id="43f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kw kx ky kz b">getFieldDecorator</code> <em class="lu"> </em>允许对我们的表单进行双向绑定。这使我们能够在不使用本地状态的情况下管理输入。通过在<code class="fe kw kx ky kz b">getFieldDecorator</code>、<em class="lu">、</em>中包装我们的<code class="fe kw kx ky kz b">Upload</code>组件，我们可以将参数传递给我们的输入以改进表单处理。如上图所示，我们用它来传递一个<code class="fe kw kx ky kz b">initialValue</code>参数(与默认值同义)以及一个<code class="fe kw kx ky kz b">valuePropName</code> <em class="lu"> </em>参数<strong class="jz iu"> </strong>(用于区分表单项中的数据)。我传递给<code class="fe kw kx ky kz b">getFieldDecorator</code> <em class="lu"> </em>的最后一个参数是<code class="fe kw kx ky kz b">getValueFromEvent</code>。</p><p id="42af" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是一个将参数作为函数的参数，可用于分析用户上传文件时触发的事件中的数据。我们将使用它来确定什么信息被传递给我们的<code class="fe kw kx ky kz b">Upload</code>组件，并根据我们的需要操纵它(比如限制一次可以上传的文件数量)。在<code class="fe kw kx ky kz b">getFieldDecorator</code>中，您还可以使用其他参数，如规则(即，使输入成为必需，如果输入未被填充则添加消息，分配可接受的数据类型等)，以及其他表单输入验证器和自定义功能。</p><p id="dfaa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，回到<code class="fe kw kx ky kz b">Upload</code>组件。</p><p id="c3bc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kw kx ky kz b">Upload</code>组件具有类似于类型为“file”的HTML输入元素的属性，例如<code class="fe kw kx ky kz b">name</code>和<code class="fe kw kx ky kz b">accept</code>。在我的情况下，只接受压缩文件。</p><p id="e081" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在一个<code class="fe kw kx ky kz b">Upload</code>组件中，你通常需要有一个动作。该操作包括上传URL，允许我们查看您的文件将被发送到哪里。因为我将文件和表单中的其他数据一起传递到数据库中的一个特定端点，所以不需要这个动作。为了避开动作需求，我正在实现<code class="fe kw kx ky kz b">customRequest</code>。</p><p id="887f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个函数什么也不做。</p><p id="ca20" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">说真的。它只是一个动作占位符，所以我不会得到一个上传错误。这是我的<code class="fe kw kx ky kz b">customRequest</code>，恰如其分地命名为<strong class="jz iu"> dummyRequest </strong>。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/a723ec9da72867ce1da6949f9f532063.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*VsG7nN1FE7xLleVWkid-1A.png"/></div></figure><p id="2d17" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就是这样。它的工作只是欺骗<code class="fe kw kx ky kz b">Upload</code>组件，让它认为包含了一个动作。<code class="fe kw kx ky kz b">customRequest</code><em class="lu"/><em class="lu"/><em class="lu"/>不仅仅是用来欺骗<code class="fe kw kx ky kz b">Upload</code>组件，但是对于我们的例子来说，欺骗是我们唯一需要使用的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/cb11d356cc9870cc15aeb4083e93d657.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*RYvtDfV4VBW4s5WVSI_jkg.gif"/></div></figure><p id="5894" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们文件的数据可以传递给<code class="fe kw kx ky kz b">Form</code>而不会抛出动作错误。</p><p id="87da" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">还记得我们的<code class="fe kw kx ky kz b">getValueFromEvent</code> <em class="lu"> </em>道具和我们传递给它的函数吗？在这里我们不仅可以看到<code class="fe kw kx ky kz b">fileList</code>(所选文件对象的数组)，还可以看到当前所选文件的数据。下面是我们将其记录到控制台时的样子:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lx"><img src="../Images/850d7ccc62a9710c875b27c9ce1c8933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0uuf4LMJLLTwGIpJHYWUrg.png"/></div></div></figure><p id="beb7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如您所见，第一个值是一个对象——当前正在上传的文件。这个对象包含一些属性。</p><p id="63a9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们要看的第一个属性是<code class="fe kw kx ky kz b">originalFileObj</code>，它是包含文件数据的实际文件对象。这个对象中的一些属性非常简单，比如文件<code class="fe kw kx ky kz b">name</code>、文件<code class="fe kw kx ky kz b">type</code>、<code class="fe kw kx ky kz b">size</code>(用字节表示)，以及修改信息。其他不太明显的属性，<code class="fe kw kx ky kz b">uid</code>和<code class="fe kw kx ky kz b">webkitRelativePath</code>现在我们不太关心。但是如果您感兴趣，可以查看MDN web文档的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener ugc nofollow" target="_blank">文件</a>部分。</p><p id="04ea" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的事件对象的第一个值中的一些其他属性也可以在<code class="fe kw kx ky kz b">originalFileObj</code>中找到，但是这里有一些不是:</p><p id="cedc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">百分比</strong>:上传完成的百分比。</p><p id="1100" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">状态</strong>:文件是否上传或完成。</p><p id="4507" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">响应</strong>:我们从上传请求中得到的响应。</p><p id="ce49" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">错误</strong>:如果上传过程中出现错误。</p><p id="9112" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">另一种查看文件数据的方式是使用<code class="fe kw kx ky kz b">beforeUpload</code>道具。这个属性是一个钩子函数，在文件上传之前执行。如果您计划使用组件状态而不是表单的数据绑定，这很好。下面是一个<code class="fe kw kx ky kz b">beforeUpload</code>函数的例子:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ly"><img src="../Images/241fb7b2b52ce9a73ac814cc3fe23771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkcHOO6TbGq7LpfGm2OB3g.png"/></div></div></figure><p id="a16a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您记录这些数据，您会看到:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lz"><img src="../Images/8235ac08df08e47b4221b9fa4f1ed46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Zxw3sfOY_g8w9wBgMIHNg.png"/></div></div></figure><p id="d4a4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该对象类似于由我们的<code class="fe kw kx ky kz b">normFile</code> <em class="lu"> </em>函数捕获的上传事件中的第一个值，但不包括状态、响应、错误或百分比。这些是在事件中找到的属性。</p><p id="3889" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">记住:一个事件通常包含比事件捕获的输入数据更多的信息。客观地说，为了获得在HTML文本输入框中键入字母的结果，您需要使用<code class="fe kw kx ky kz b">event.target.value</code>。这是因为事件本身包含的不仅仅是输入数据。你可以在这里了解更多关于事件接口<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Event" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="81b7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你还和我在一起吗？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/2f6b61b4cab45f1544d9422ebbc87c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*kM_MrcqDx9Jc8FK52rnJCQ.gif"/></div></figure><p id="41c2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，回到我们在<code class="fe kw kx ky kz b">normFile</code>中的事件对象。</p><p id="f624" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">事件对象中的第二个值是<code class="fe kw kx ky kz b">fileList</code>。该对象包含一个file对象数组。这些文件对象代表已经上传的文件，属于<code class="fe kw kx ky kz b">Upload</code>组件。<code class="fe kw kx ky kz b">fileList</code> <strong class="jz iu"> </strong>是<code class="fe kw kx ky kz b">Upload</code>组件用来区分数据的属性名。</p><p id="3d38" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所有这些都是在表单数据的文件选择事件(更改)中捕获的数据。虽然这里没有使用，但是您也可以将<code class="fe kw kx ky kz b">onChange</code> <strong class="jz iu"> </strong>事件处理程序与<code class="fe kw kx ky kz b">Upload</code>组件一起使用。</p><p id="ee2d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="lu"> </em> <code class="fe kw kx ky kz b">normFile</code> <em class="lu"> </em>函数除了能够检查上传事件中发现的数据之外，还有另一个重要的功能。见下文。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/218c21cdd11b89692045a6aa6e44031a.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*SaOLtay9PmlXuuO2uMRLrw.png"/></div></figure><p id="ffb5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">文件上传的全部目的是让用户能够上传包含与由<code class="fe kw kx ky kz b">Form</code>提交创建的对象实例相关的数据的文件。这允许用户用初始数据实例化一个对象，而不是创建一个具有空属性的对象，以后只需手动添加文件中的数据。根据数据量的不同，很难说这样可以节省多少时间。</p><p id="e4e6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这和<code class="fe kw kx ky kz b">normFile</code>有什么关系？好吧，如果数据集是从一个来源的数据建模的，允许用户一次上传多个文件可能会导致组合、重复或完全不正确的数据。想象一下，试图通过上传文件而不是依赖数据输入来使事情变得简单，但是您意外地(或有意地)选择了多于您需要的文件。现在你被一个无用的杂乱文件怪物困住了。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/55667caaf6f719a283f45b19c927cfa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*l-E2-DF0A_6YkzxLlG9wIg.gif"/></div></figure><p id="df15" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好吧，我太夸张了。实际上，如果文件列表太长，端点可以通过抛出一个一般错误或一些参数错误来处理这个问题。也有一次上传多个文件的真实用例(想想电子邮件附件、带有多张图片的Instagram帖子等。).但对我来说，这只会制造冲突，所以需要解决。</p><p id="8c9e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了解决这个问题，我们可以从端点使用错误处理，让用户尝试重新上传正确的文件。或者，我们可以在提交数据之前将文件列表的长度限制为一个文件。它的操作方式与要求输入的方式相同。这样，如果需要数据，或者需要满足特定的要求，就可以提前处理数据，而不是让端点抛出一个错误，说“嘿，笨蛋，你需要这样做……”。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f25164d52a24983b6bdb64c007079f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*AUeCZR7zHwOT0cg-GEFsNA.gif"/></div></figure><p id="63de" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<code class="fe kw kx ky kz b">normFile</code>函数中，我们可以检查<code class="fe kw kx ky kz b">fileList</code>的长度，如果它大于1，我们可以通过<code class="fe kw kx ky kz b">fileList.shift()</code>删除第一个索引处的项。你也可以只写<code class="fe kw kx ky kz b">fileList[1]</code>来获取最近上传的文件。为什么我们要省略第一个索引处的文件？好了，让我们看看<code class="fe kw kx ky kz b">fileList</code> <em class="lu"> </em>尝试上传第二个文件后的情况。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mc"><img src="../Images/b37b3206a88bf2aac1f1f39dc179bc90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZrCHfJYyaGO1m2yD0czvQ.png"/></div></div></figure><p id="e8b0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如你所见，我们有两个对象。但是看看他们每个人的状态和回应。第一个索引<code class="fe kw kx ky kz b">fileList</code>处的对象状态为“完成”，响应为“正常”。第二个对象的状态为“上传”,响应未定义。这告诉我们什么？</p><p id="d015" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">第一个索引处的对象是前一个文件。它已经被上传了(因此状态为“done”)，并且实际上有一个响应(意味着请求被解析并返回一个响应来表明这一点)。我们的第二个对象字面上说它仍在“上传”,意思是它在进程中。而回应呢？嗯，没有。因为请求正在进行中。</p><p id="517f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">根据您的喜好，您可以选择删除最近添加的文件，而只是默认使用以前的文件。但这需要某种通知，这样用户就知道“嘿，你试图上传一个文件，但你不能上传多个，所以我们默认为较早的一个。”但是，如果用户知道他们上传了一个不正确的文件，并想简单地重新上传一个新的文件呢？他们可以删除之前上传的文件。或者，我们可以让它变得简单一点。当他们上传一个新文件时，它会覆盖旧文件。这就是我在这里决定要做的，也是为什么我要在数组的第一个索引(shift)处移除file对象。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/802641a145fa1d12000755231a073012.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/1*2vRiMNN41nspNE54kWoXeg.gif"/></div></figure><p id="961e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，您可以高效地处理文件上传。通过捕获文件对象，您可以将此信息发送到存储数据的任何地方。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="87fb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><a class="ae kv" href="https://matt-croak.medium.com/membership" rel="noopener"> <em class="lu">在此处将您的免费媒体会员升级为付费会员</em> </a> <em class="lu">，每月只需5美元，您就可以收到各种出版物上数千名作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h2 id="6eaf" class="li lj it bd ml mm mn dn mo mp mq dp mr ki ms mt mu km mv mw mx kq my mz na nb bi translated">参考</h2><div class="nc nd gp gr ne nf"><a href="https://ant.design/docs/react/getting-started" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">蚂蚁设计——一种用户界面设计语言</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">一种企业级UI设计语言和基于React的实现，具有一组高质量的React组件，一个…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">蚂蚁设计</p></div></div><div class="no l"><div class="np l nq nr ns no nt jv nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://www.npmjs.com/package/antd" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">antd</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">一种企业级UI设计语言和基于React的实现</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.npmjs.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt jv nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://stackoverflow.com/questions/52634183/react-ant-design-styles-not-loading" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">反应和设计风格不加载</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">stackoverflow.com</p></div></div><div class="no l"><div class="nv l nq nr ns no nt jv nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://ant.design/components/upload/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">蚂蚁设计——一种用户界面设计语言</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">一种企业级UI设计语言和基于React的实现，具有一组高质量的React组件，一个…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">蚂蚁设计</p></div></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://ant.design/components/form/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">蚂蚁设计——一种用户界面设计语言</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">一种企业级UI设计语言和基于React的实现，具有一组高质量的React组件，一个…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">蚂蚁设计</p></div></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">文件</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">文件接口提供关于文件的信息，并允许网页中的JavaScript访问其内容。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">developer.mozilla.org</p></div></div><div class="no l"><div class="nw l nq nr ns no nt jv nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">事件</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">事件接口表示发生在DOM中的事件。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">developer.mozilla.org</p></div></div><div class="no l"><div class="nx l nq nr ns no nt jv nf"/></div></div></a></div></div></div>    
</body>
</html>