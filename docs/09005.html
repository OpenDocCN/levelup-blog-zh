<html>
<head>
<title>Sorting Python Dictionaries for Fun and Profit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">出于兴趣和利益对Python字典进行排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sorting-python-dictionaries-for-fun-and-profit-fedb60951212?source=collection_archive---------17-----------------------#2021-06-27">https://levelup.gitconnected.com/sorting-python-dictionaries-for-fun-and-profit-fedb60951212?source=collection_archive---------17-----------------------#2021-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="47cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python字典是一个强大的数据结构，由非可变数据类型索引的键值对组成。它们本质上是无序的，但是会保留添加项目的顺序。没有办法直接对python字典进行排序，所以我们必须有点创意。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b1ae986972b28ba09af6d247c4da713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YiVaIvKHI30KlTQ2L7o6Nw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.overcoded.net" rel="noopener ugc nofollow" target="_blank">过度编码</a></figcaption></figure><p id="1f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">幸运的是，我们可以通过将Python字典转换成可排序的类型(比如列表)来对其进行排序。这涉及到一个中间步骤，或者一个大胆的一行程序，但是相对简单。我将带您了解一些基本的问题、注意事项和值得注意的选项。对于那些从谷歌这里得到快速答案的人，请查看TL；以下博士:</p><p id="537b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">TL；DR </strong> —使用带有lambda表达式的内置排序函数作为键。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="3cea" class="mj mk it mf b gy ml mm l mn mo"># Create a dictionary with randomly ordered keys<br/>d = {5: 'f', 3: 'd', 0: 'a', 2: 'c', 6: 'g', 1: 'b'}</span><span id="944a" class="mj mk it mf b gy mp mm l mn mo"># Sort by converting to list using lambda<br/>d = sorted(d.items(), key=lambda x: x[0])</span><span id="a0dc" class="mj mk it mf b gy mp mm l mn mo">&gt;&gt;&gt; [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (5, 'f'), (6, 'g')]</span><span id="4b8b" class="mj mk it mf b gy mp mm l mn mo"># Covert back to a dictionary (if needed)<br/>d = {k: v for k, v in d}</span><span id="76e1" class="mj mk it mf b gy mp mm l mn mo">&gt;&gt;&gt; {0: 'a', 1: 'b', 2: 'c', 3: 'd', 5: 'f', 6: 'g'}</span></pre><h1 id="1416" class="mq mk it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">快速介绍</h1><p id="340c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">Python字典是一种非常类似于传统哈希表的数据结构。它将不可变对象的集合(比如整数、字符串或浮点数)与成对的值配对，这些值<em class="nm">可以</em>是可变的，甚至是值的集合。</p><p id="4a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python字典是高效的，并且打包了大量有用的内置方法来帮助完成常见任务。在Java等其他语言中，字典有点像枚举，但是有一些显著的不同。</p><h1 id="8a56" class="mq mk it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">对Python字典进行排序</h1><p id="d6d3" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">很像最初的TL；例如，我们将从创建一个随机排序的字典开始。有了这些，我们将能够了解一些有效的方法，以及一些无效的方法。在我们开始之前，我会花一点时间建议您阅读官方Python字典文档。最好列出Python字典结构提供的许多方法，我们不会在这里讨论。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="cce4" class="mj mk it mf b gy ml mm l mn mo"># Create a randomly-ordered dictionary<br/>d = {5: 'f', 3: 'd', 0: 'a', 2: 'c', 6: 'g', 1: 'b'}</span><span id="41d7" class="mj mk it mf b gy mp mm l mn mo"># Sort the dictionary<br/>sorted(d)</span><span id="1e2a" class="mj mk it mf b gy mp mm l mn mo">&gt;&gt;&gt; [0, 1, 2, 3, 5, 6]</span></pre><p id="ed49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇哦。那个<em class="nm">几乎</em>看起来好像起作用了。在这个场景中，Python将字典表示为键，因为(需要引用版本号。)同样值得注意的是，自从<a class="ae ky" href="https://www.python.org/dev/peps/pep-0448/" rel="noopener ugc nofollow" target="_blank"> PEP448 </a>以来，人们可以使用解包指令来产生这样的列表:<code class="fe nn no np mf b"> l = [*d]</code>这将产生一个列表，尽管没有排序:<code class="fe nn no np mf b">[5, 3, 0, 2, 6, 1]</code>。只是一些有趣的事实。让我们看看这是什么样子:</p><h1 id="3a61" class="mq mk it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">理解排序</h1><p id="95d7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated"><a class="ae ky" href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noopener ugc nofollow" target="_blank"> Python列表理解</a>是我爱上这种<a class="ae ky" href="https://www.overcoded.net/most-popular-programming-languages-184015/" rel="noopener ugc nofollow" target="_blank">编程语言</a>的原因之一。它让人们以高度优化的方式使用一行逻辑实现令人印象深刻的工作负载。对我来说，还不清楚Python是否也支持开箱即用的字典理解。的确如此，我们还将展示如何用它来对Python中的字典进行排序！</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="38e0" class="mj mk it mf b gy ml mm l mn mo"># Create a randomly-ordered dictionary<br/>d = {5: 'f', 3: 'd', 0: 'a', 2: 'c', 6: 'g', 1: 'b'}</span><span id="ea32" class="mj mk it mf b gy mp mm l mn mo"># Sort using dictionary comprehension<br/>d = {k: v for k, v in sorted(d.items())}</span><span id="eec8" class="mj mk it mf b gy mp mm l mn mo">&gt;&gt;&gt; {0: 'a', 1: 'b', 2: 'c', 3: 'd', 5: 'f', 6: 'g'}</span></pre><p id="2795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们不仅通过sorted(d.items())方法将字典转换成一个列表，从而对字典进行了排序，而且还将它转换回了字典。都在一条线上！<strong class="lb iu">注意</strong>:我们<em class="nm">技术上</em>把它转换成了一个中间生成器对象，而不是一个列表。</p><p id="7ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来很不错，但是让我们更进一步，引入一个自定义键，我们的字典将根据这个键进行排序。例如，假设我们希望字典根据键的平均值按绝对值排序。</p><p id="8793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们是否能找到一个适合这个任务的一行程序！为此，我将使用一组稍长的值来引用通过字符串模块可用的<a class="ae ky" href="https://www.overcoded.net/ascii-table-512119/" rel="noopener ugc nofollow" target="_blank"> ASCII小写字母</a>:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="5a0e" class="mj mk it mf b gy ml mm l mn mo"># Create a randomly-ordered dictionary<br/>alpha = {k: v for k, v in zip(range(len(string.ascii_lowercase)), list(string.ascii_lowercase))}</span><span id="4745" class="mj mk it mf b gy mp mm l mn mo">&gt;&gt;&gt; {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j', 10: 'k', 11: 'l', 12: 'm', 13: 'n', 14: 'o', 15: 'p', 16: 'q', 17: 'r', 18: 's', 19: 't', 20: 'u', 21: 'v', 22: 'w', 23: 'x', 24: 'y', 25: 'z'}</span><span id="9a70" class="mj mk it mf b gy mp mm l mn mo"># Order by distance from an calculated value<br/>s = {k: v for k, v in sorted(alpha .items(), key=lambda x: abs(sum(alpha) / len(alpha) - x[0]))}</span><span id="c91d" class="mj mk it mf b gy mp mm l mn mo">&gt;&gt;&gt; {12: 'm', 13: 'n', 11: 'l', 14: 'o', 10: 'k', 15: 'p', 9: 'j', 16: 'q', 8: 'i', 17: 'r', 7: 'h', 18: 's', 6: 'g', 19: 't', 5: 'f', 20: 'u', 4: 'e', 21: 'v', 3: 'd', 22: 'w', 2: 'c', 23: 'x', 1: 'b', 24: 'y', 0: 'a', 25: 'z'}</span></pre><p id="82ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，关键参数、Python lambda函数和字典理解的组合可以做很多工作。在这种情况下，我按照接近平均位置对字母表的字典进行了排序。为什么问这个问题？因为Python让它变得如此简单！</p><p id="d006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong> : <a class="ae ky" href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="noopener ugc nofollow" target="_blank"> Python集合模块中的OrderedDict类</a>是一个常用的对象替代物，因为它保留了插入顺序。从3.7开始，标准的<code class="fe nn no np mf b">dict</code>对象已经提供了这个功能，并且在很多情况下已经取代了对<code class="fe nn no np mf b">OrderedDict</code>的需求。<code class="fe nn no np mf b">OrderedDict</code>在某些情况下仍然有一些性能优势，我认为不应该完全忽略。</p><h1 id="e460" class="mq mk it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">逮到你了</h1><p id="b288" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">Python字典可以使用元组作为键，但是元组不能包含可变对象。例如，元组本身<em class="nm">是</em>不可变的，但是可能包含像列表或对象这样的结构。</p><h1 id="0f69" class="mq mk it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">最后的想法</h1><p id="6d01" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">Python的字典结构是一个难以置信的散列映射工具，我一直在使用它们。当我在本地或云中存储凭证，处理查询时间比顺序更重要的集合，以及序列化数据时使用<em class="nm">尤其是</em>时，我通常会使用它们。Python字典和JSON格式的字符串之间的转换非常容易(这里看一下<em class="nm"> you </em> Java。)</p><p id="ddfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使字典的用例很强大，我也发现需要得到一个集合的排序版本，或者至少从键的排序顺序中获得一些值。使用本文概述的方法，我发现可以有效地完成任务——通常是在一行程序中。我希望这篇文章对大家有所帮助，并敦促大家认识到我们只涉及了Python字典数据类型的一小部分用例、使用含义和方法。<a class="ae ky" href="https://www.overcoded.net/python-set-update-method-044711/" rel="noopener ugc nofollow" target="_blank">还有<em class="nm">多</em>多了解他们</a>！</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="c96a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文章<a class="ae ky" href="https://www.overcoded.net/sorting-python-dictionary-291211/" rel="noopener ugc nofollow" target="_blank"> <em class="nm">整理Python字典取乐&amp;盈利</em> </a>最初出现在<a class="ae ky" href="https://www.overcoded.net" rel="noopener ugc nofollow" target="_blank">过度编码网站</a>上，经允许在此转载。</p></div></div>    
</body>
</html>