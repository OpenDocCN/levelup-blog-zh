<html>
<head>
<title>Use Immer to Manage Your Immutable React State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Immer来管理您不可变的React状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-immer-to-manage-your-immutable-react-state-519f4555fb8c?source=collection_archive---------11-----------------------#2020-06-01">https://levelup.gitconnected.com/use-immer-to-manage-your-immutable-react-state-519f4555fb8c?source=collection_archive---------11-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/921e8fb871b7f0885c22a2e35f6ab3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tj_HSJ9SSzqYO8fuS1k1wA.png"/></div></div></figure><p id="69ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您使用过React，或者坦率地说，任何JavaScript框架，您可能都遇到过保持状态“不可变”的想法。换句话说，在处理状态时，您希望避免在修改特定值时改变状态对象。不变性是面向对象和函数式编程的核心概念，所以在我深入了解Immer的神奇之处之前，我只想花一点时间来阐述什么是不变性，以及为什么它在我们构建的应用程序中很重要。</p><h1 id="8323" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是“不变性”？</h1><p id="382d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">不管编程环境如何，不可变的根本含义就是不可改变。基本上，木已成舟，没有回头路。教科书定义和纲领性定义的不同之处在于，不是<em class="mc">能不能</em>你的问题，而是<em class="mc">应该</em>你的问题？</p><p id="d20b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我的编程知识非常局限于web领域，所以任何关于不可变编程实践的进一步讨论都将在JavaScript的上下文中进行。</p><p id="eedc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我认为对JS中变异的一个常见误解是重新分配一个已经声明的变量。</p><p id="ece9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bf18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这是不正确的，因为可变性严格处理<code class="fe mj mk ml mm b">object</code>原始类型，因此将<code class="fe mj mk ml mm b">name</code>重新分配给<code class="fe mj mk ml mm b">age</code>不是突变。顺便提一下，如果这是您想要阻止的行为，要么考虑使用TypeScript，将<code class="fe mj mk ml mm b">name</code>指定为<code class="fe mj mk ml mm b">const</code>，要么两者都用(我的偏好)。</p><h1 id="f289" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">React促进不可变的状态交互</h1><p id="7b9a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果您曾经使用过React，您可能已经知道该框架是不变性的倡导者和采纳者。文档<a class="ae mn" href="https://reactjs.org/docs/update.html" rel="noopener ugc nofollow" target="_blank">进一步讨论了这一点，但是我可以给你TL；博士像React这样的JS框架的终极目标就是“反应式”。换句话说，当一个JavaScript值改变时，对它做出反应！这可以是更改按钮颜色、数值，或者可能是项目列表中的一个项目。让我们以这种状态结构为例:</a></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="41ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想为Bob添加一个爱好，考虑到这个结构，您可以直接推送到他的<code class="fe mj mk ml mm b">hobbies</code>数组:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4bfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这种方法的缺点是，您无法知道自从该对象的前一个副本被覆盖以来，该状态对象中哪些特定的<em class="mc">属性发生了变化。这就是当您深入一个对象以更新一个属性而不关心该对象的其他属性时所发生的情况。</em></p><p id="f0c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现代钩子时代无疑改变了我们在React应用中处理状态的方式。最值得注意的是，我们不再需要将组件的所有状态存储在一个巨大的对象中。<code class="fe mj mk ml mm b">useState</code>钩子允许我们在给定的组件中逐项列出我们的状态对象。如果您和我一样，我非常喜欢将相关的组件状态组合在一个<code class="fe mj mk ml mm b">useState</code>钩子中。换句话说，我经常使用多个<code class="fe mj mk ml mm b">useState</code>钩子来处理对象，而不是单一值。</p><p id="22ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我最常用的方法之一，用来更新在<code class="fe mj mk ml mm b">useState</code>钩子中定义的给定状态对象的状态:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="18ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当我在状态对象中更新一个值时，我必须确保不要改变整个对象。提供给从<code class="fe mj mk ml mm b">useState</code>返回的两个值中的第二个值的初始参数是基于作为参数传递的值的先前状态。</p><p id="faa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这不是那么糟糕，对不对？非常简洁，如果你熟悉箭头函数、隐式返回和对象扩展的话，可读性很好，但这是最简单的情况。如果我们处理的不是一个表单，而是一组用户对象，比如:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d621" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当用户确认他们的电子邮件时，我们希望为他们的用户对象更新<code class="fe mj mk ml mm b">emailConfirmed</code>属性。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="79ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，当映射到以前的用户状态时，当我们发现用户的id等于<code class="fe mj mk ml mm b">confirmedUserId</code>时，我们希望扩展到该对象并更新其<code class="fe mj mk ml mm b">emailConfirmed</code>属性。同样，这并不疯狂，但是你可以看到当你的状态嵌套得越多，你的应用程序变得越复杂，这就变得越麻烦。</p><h1 id="2288" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Immer是来帮忙的</h1><p id="394a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我知道，我花了一秒钟去Immer，但我想为我为什么喜欢使用它设置场景。在过去的几年里，它在React领域越来越受欢迎。Immer基于<a class="ae mn" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank">写时复制</a>范式运行，这基本上意味着它能够创建状态的草稿副本，对于对该副本所做的任何修改，将基于这些修改发布新的状态。我将从<a class="ae mn" href="https://immerjs.github.io/immer/docs/introduction" rel="noopener ugc nofollow" target="_blank"> Immer文档</a>中窃取一幅插图，因为我想不出更好的可视化流程:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/b2532e9c88842ef8bafd7a4a3829b356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jlmsx2doan2aDLYTkCxrPw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">资料来源:https://immerjs.github.io/immer/docs/introduction</figcaption></figure><p id="5431" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以Immer的关键是它的“产生”函数，该函数接受你的原始状态副本作为参数，然后用该状态的草稿版本进行回调。在这个回调中，你可以随心所欲地修改草稿，Immer将确保最终结果保持不变。很酷，对吧？我也这么认为让我们看看如何使用<code class="fe mj mk ml mm b">produce</code>来更新用户的<code class="fe mj mk ml mm b">emailConfirmed</code>属性:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="0fe8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在某个点击处理程序中，我们会像这样使用这个生成器:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="747f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像这样，我们能够更直接地更新状态，从我们的角度来看，改变目标用户的对象(即使Immer在这方面支持我们)。不过，在我看来，这有点笨拙。另一种我们可以达到同样效果并且更简洁的方法是通过编写一个<a class="ae mn" href="https://immerjs.github.io/immer/docs/curried-produce" rel="noopener ugc nofollow" target="_blank">curred producer</a>。我不会深入探讨JavaScript中的currying是什么，但基本上curried producer只需要一个状态来产生一个新值，以及与操作相关的任何附加参数。上面定义的<code class="fe mj mk ml mm b">updateUsers</code>的一个简化版本是:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5d50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意普通制作人和咖喱制作人之间的区别:</p><pre class="md me mf mg gt mt mm mu mv aw mw bi"><span id="ff90" class="mx la it mm b gy my mz l na nb"><em class="mc">regular: produce(state, recipe) =&gt; nextState</em></span><span id="9479" class="mx la it mm b gy nc mz l na nb"><em class="mc">currying: produce(recipe) =&gt; state =&gt; nextState</em></span></pre><p id="701e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想提取组件之外的功能进行单元测试，这可能很好，但是我个人并不经常使用这种方法。有一个名为<a class="ae mn" href="https://www.npmjs.com/package/use-immer" rel="noopener ugc nofollow" target="_blank"> use-immer </a>的小软件包是由immer的作者创建和维护的，它提供了一个<code class="fe mj mk ml mm b">useImmer</code>(和<code class="fe mj mk ml mm b">useImmerReducer</code>)钩子，允许你像使用<code class="fe mj mk ml mm b">useState</code>一样使用组件状态。在我使用Immer的大多数情况下，我使用的是<code class="fe mj mk ml mm b">useImmer</code>钩子。因此，复制我们最初用<code class="fe mj mk ml mm b">useImmer</code>更新用户数组的方法看起来会像这样:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="b6f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就我个人而言，我喜欢将从这个钩子返回的值命名为不同于我用常规的<code class="fe mj mk ml mm b">useState</code>钩子所命名的值，只是为了区分这两者。此外，有了这个钩子，我不再觉得有必要详细列举/分组状态，因为不管状态对象如何嵌套，用Immer更新它都相对简单。</p><h1 id="64c1" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">补丁</h1><p id="fb63" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Immer还允许您使用<a class="ae mn" href="https://immerjs.github.io/immer/docs/patches" rel="noopener ugc nofollow" target="_blank">补丁</a>来跟踪状态的增量变化。当然，并不是每个状态对象都需要这样，但是对于某些用例来说，这可能非常方便，特别是当您希望拥有撤销/重做功能的时候。这不一定与不变性有关，但我认为这是Immer的一个非常好的选择加入特性。这里有一个简单的例子，说明如何使用Immer的<code class="fe mj mk ml mm b">produceWithPatches</code>将补丁合并到上面的状态设置中。请记住，您必须稍微调整一下函数的结构，以处理它返回的元组:</p><p id="768a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:为了使包尽可能小，默认情况下，Immer禁用补丁。如果您希望启用它们，请在应用程序的根目录下调用Immer的<code class="fe mj mk ml mm b">enablePatches() </code>方法</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="c364" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们的<code class="fe mj mk ml mm b">nextState</code>将是更新后的状态对象，<code class="fe mj mk ml mm b">patches</code>将是应用于状态的变更的详细列表，如果凯文的<code class="fe mj mk ml mm b">emailConfirmed</code>属性被更新，它将看起来像这样:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="cf79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而<code class="fe mj mk ml mm b">inversePatches</code>就是这样一个函数——撤销<code class="fe mj mk ml mm b">patches</code>中包含的所有更改。很漂亮，对吧？至少我是这样认为的。如果你想玩玩<code class="fe mj mk ml mm b">produceWithPatches</code>，看看这个<a class="ae mn" href="https://stackblitz.com/edit/react-gxzkyx" rel="noopener ugc nofollow" target="_blank">沙盒</a>。</p><p id="3d33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最喜欢Immer的部分是它做的很少。它提供了这样一个最小的API，在浏览完文档后，从零知识到开始运行是非常容易的。这无疑让我在React中的开发经历变得更加愉快，我希望在这之后你会愿意尝试一下！当然，除非你喜欢自己处理不变性；)</p><p id="6b2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，关于Immer，Sebastian Markbå ge说:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="nd mi l"/></div></figure><p id="bbfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这不是一种认可，我不知道什么是。</p><p id="bf6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的倾听👋🏻</p></div></div>    
</body>
</html>