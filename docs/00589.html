<html>
<head>
<title>Web Components in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之，Web组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/web-components-in-a-nutshell-1e114aa971b9?source=collection_archive---------1-----------------------#2019-05-21">https://levelup.gitconnected.com/web-components-in-a-nutshell-1e114aa971b9?source=collection_archive---------1-----------------------#2019-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fc24" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">本机浏览器Web组件的基础知识以及如何创建它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8f009a0ec4e0607a98c1117c3f51f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*farIT5K_01tofCXI8rQqTQ.png"/></div></div></figure><p id="a21d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在web开发中，代码的可重用性已经成为一个焦点。作为一名开发人员，我们可能经历过这样的场景:我们不得不在多个地方使用代表自定义UI控件的代码段。如果我们不能仔细地编写它们，可能会使我们的整个代码结构变得难以管理。Web组件提供了一个本地API来构建可重用的UI块。</p><h1 id="b5b6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">什么是Web组件？</h1><p id="cc14" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Web组件是一个<strong class="kw iu">低级浏览器API的集合，帮助我们创建可重用的、封装的定制HTML UI元素</strong>。Web组件被认为好得多，因为它们可以通过使用任何库或框架来创建，并且您可以立即开始使用普通JavaScript编写自己的web组件。</p><p id="fb63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用web组件的一个好处是，它们可用于除Microsoft Edge之外的所有浏览器，但我们不需要担心这一点，因为我们有<a class="ae mn" href="https://github.com/webcomponents/webcomponentsjs" rel="noopener ugc nofollow" target="_blank"> Polyfills </a>来解决这个问题。</p><p id="d8a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Web组件由三种主要技术组成。它们是可以用作API来构建web组件的主要支柱。</p><ul class=""><li id="e4fe" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated"><strong class="kw iu">自定义元素</strong></li><li id="0136" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><strong class="kw iu">模板</strong></li><li id="485b" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><strong class="kw iu">阴影DOM </strong></li></ul><p id="0ff4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们深入了解这些技术。</p><h2 id="5270" class="nc lr it bd ls nd ne dn lw nf ng dp ma ld nh ni mc lh nj nk me ll nl nm mg nn bi translated">1.自定义元素</h2><p id="1a30" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这些是一套JavaScript APIs，帮助你创建你自己的HTML元素，控制你的DOM及其行为。我们可以建立他们的等级制度，并规定他们如何应对行为的变化。例如，您可以创建一个像这样的元素<code class="fe no np nq nr b">&lt;my-element&gt;&lt;/my-element&gt;</code>。</p><h2 id="80eb" class="nc lr it bd ls nd ne dn lw nf ng dp ma ld nh ni mc lh nj nk me ll nl nm mg nn bi translated">2.模板</h2><p id="de47" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">模板是用户定义的标记，仅在页面加载时呈现。稍后，通过创建组件的实例，可以多次重用这些组件。</p><h2 id="752a" class="nc lr it bd ls nd ne dn lw nf ng dp ma ld nh ni mc lh nj nk me ll nl nm mg nn bi translated">3.阴影DOM</h2><p id="5300" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">影子DOM是JavaScript APIs的组合，用于连接封装的DOM。这将与主文档对象模型分开呈现，并且它们的行为特征将保持私有，以便代码段不会与代码结构的其他部分冲突。使用Shadow DOM，CSS和JavaScript可以像一个<code class="fe no np nq nr b">&lt;iframe&gt;</code>标签一样被隔离。</p><h2 id="c9fc" class="nc lr it bd ls nd ne dn lw nf ng dp ma ld nh ni mc lh nj nk me ll nl nm mg nn bi translated">生命周期回调</h2><p id="a653" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">生命周期回调是在自定义元素的类定义中定义的函数。他们有自己独特的目的。它们用于操纵我们的自定义元素的行为。</p><ul class=""><li id="7be4" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated"><code class="fe no np nq nr b">connectedCallback</code>:当我们的自定义元素最初连接到DOM时，这个特定的函数将被调用。</li><li id="7329" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe no np nq nr b">adoptedCallback</code>:当我们的自定义元素被移动到一个新的文档中时，这个函数将被调用。</li><li id="33ef" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">如果我们的定制元素的属性发生了变化，比如一个属性被更改、添加或删除，这个特定的函数将被调用。</li><li id="8622" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe no np nq nr b">disconnectedCallback</code>:当我们的定制元素与DOM断开连接时，这个特定的函数被调用。</li></ul><p id="3c3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看看如何使用普通的JavaScript创建一个web组件。通过这样做，你将对web组件有一个清晰的了解。</p><h1 id="f66b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">我们要建造什么？</h1><p id="c95b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们将构建一个包含当前趋势gif图像的web组件。我们将使用Giphy API来获取gif。在实现结束时，您的代码结构将如下所示。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6506" class="nc lr it nr b gy nw nx l ny nz">--index.html<br/>--card.js<br/>--services.js</span></pre><h1 id="7549" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">我们开始吧！</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">学分:Giphy.com</figcaption></figure><p id="8123" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们必须创建一个包含我们将要构建的web组件的行为的类。创建一个名为<code class="fe no np nq nr b">card.js</code>的文件，并创建一个如下所示的类。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="ccc1" class="nc lr it nr b gy nw nx l ny nz">class CardComponent extends HTMLElement {<br/>    constructor (){<br/>        super();<br/>        <br/>        //Your implementaion goes here<br/>    <br/>    }<br/>}</span></pre><p id="c6a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在类的构造函数中，需要使用<code class="fe no np nq nr b">Element.attachShadow()</code>方法将影子DOM的影子根附加到文档的当前HTML元素上。然后我们需要在我们的<code class="fe no np nq nr b">index.html</code>文件中使用<code class="fe no np nq nr b">&lt;template&gt;</code> <em class="og"> </em>标签创建一个HTML模板。该模板看起来会像这样</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e649" class="nc lr it nr b gy nw nx l ny nz">&lt;template id="card-view"&gt;<br/>   &lt;h1&gt;Web Component&lt;/h1&gt;<br/>   &lt;p id="card-title"&gt;Example&lt;/p&gt;<br/>   &lt;img id="gif-view"/&gt;<br/>&lt;/template&gt;</span></pre><p id="950e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将它添加到我们的<code class="fe no np nq nr b">index.html</code>文件后，我们可以使用DOM方法克隆上面的模板，并将其附加到我们的影子DOM。这应该写在构造函数内部。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6066" class="nc lr it nr b gy nw nx l ny nz">class CardComponent extends HTMLElement {<br/>    constructor (){<br/>        super();<br/>        const shadow =<em class="og"> this</em>.attachShadow({mode: 'open'});<br/>       <br/>        <em class="og">// Clone the template so that it can be attched to the <br/>        shadowroot</em>                     <br/>        const template = document.getElementById('card-view');<br/>        const templateInstance = template.content.cloneNode(true);<br/>        shadow.appendChild(templateInstance);<br/>    }</span><span id="c78b" class="nc lr it nr b gy oh nx l ny nz">}</span></pre><p id="41fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我前面提到的，我们还应该编写一个函数来从Giphy API获取gif。从API中，我们将获得一个当前的趋势gif及其标题，该标题由特定gif的上传者提供。在我们开始编写函数之前，创建一个名为<code class="fe no np nq nr b">services.js</code>的单独文件来放置URL和API键。创建该文件，并使用来自Giphy API的API密钥添加以下代码</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="499d" class="nc lr it nr b gy nw nx l ny nz">const API_KEY = '*YOUR_API_KEY*';</span><span id="ed51" class="nc lr it nr b gy oh nx l ny nz">const url = `http://api.giphy.com/v1/gifs/trending?api_key=` + API_KEY + `&amp;limit=1`;</span><span id="5304" class="nc lr it nr b gy oh nx l ny nz">export {API_KEY, url}; // <em class="og">export the url so that i can be used extrnally.</em></span></pre><p id="008f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建完<code class="fe no np nq nr b">services.js</code>文件后，将下面的代码添加到<code class="fe no np nq nr b">card.js</code>文件的顶部，这样您就可以使用URL来获取gif。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7e22" class="nc lr it nr b gy nw nx l ny nz">import { url } from './services.js';</span></pre><blockquote class="oi oj ok"><p id="fe9b" class="ku kv og kw b kx ky ju kz la lb jx lc ol le lf lg om li lj lk on lm ln lo lp im bi translated">要获得您自己的API密钥，请访问以下站点。<a class="ae mn" href="https://developers.giphy.com/" rel="noopener ugc nofollow" target="_blank">https://developers.giphy.com/</a></p></blockquote><p id="b835" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们跳回我们的<code class="fe no np nq nr b">card.js</code>文件并添加以下函数。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="cf61" class="nc lr it nr b gy nw nx l ny nz">render(shadowElem, data){<br/>    const shadowRoot = shadowElem.shadowRoot;<br/>    shadowRoot.getElementById('card-title').innerHTML = data.name;<br/>    shadowRoot.getElementById('gif-view').src = data.url;<br/>}<br/></span><span id="e963" class="nc lr it nr b gy oh nx l ny nz">async fetchFromGiphy (){<br/>  const res = await fetch(url);<br/>  const json = await res.json();</span><span id="ef1b" class="nc lr it nr b gy oh nx l ny nz">  const gifUrl = json['data']['0'].images['fixed_height_small'].url;<br/>  const gifName = json['data']['0'].title;</span><span id="a16a" class="nc lr it nr b gy oh nx l ny nz">  const gifObject = {<br/>     name: gifName,<br/>     url: gifUrl<br/>  }<br/>  return gifObject;<br/>}</span></pre><p id="ef77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我来解释一下这些功能。</p><p id="4b88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe no np nq nr b">fetchFromGiphy()</code>:这个函数获取趋势gif和特定gif的标题，并使用async/await将它们作为一个对象返回。</p><p id="eea9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe no np nq nr b">render()</code>:这个函数用于在影子DOM的元素中注入值。</p><p id="227f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们在生命周期回调中调用这些函数。实际上，当我们的定制元素连接到DOM时，我们需要调用上面的两个函数。我们有<code class="fe no np nq nr b">connectedCallback()</code> <em class="og"> </em>函数来实现这一点。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="02a5" class="nc lr it nr b gy nw nx l ny nz">async connectedCallback (){<br/>    <em class="og">this</em>.gifObj = await<em class="og"> this</em>.fetchFromGiphy();<br/>    <em class="og">this</em>.render(<em class="og">this</em>,<em class="og"> this</em>.gifObj);<br/>}</span></pre><p id="6bbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们使用<code class="fe no np nq nr b">customElements.define()</code> <strong class="kw iu"> <em class="og"> </em> </strong>函数来定义我们的定制元素。当定义一个定制元素时，我们应该记住一些基本规则。<code class="fe no np nq nr b">define()</code> <em class="og"> </em>函数的第一个参数应该是一个代表我们自定义元素名称的字符串。它们不能是一个单词，所以应该包含一个<code class="fe no np nq nr b">-</code>字符。第二个参数是我们的类对象，它定义了元素的行为。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7db1" class="nc lr it nr b gy nw nx l ny nz">customElements.define(‘card-component’, CardComponent);</span></pre><p id="2bc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您已经定义了您的组件，将您的<code class="fe no np nq nr b">card.js</code>文件添加到您的<code class="fe no np nq nr b">index.html</code>文件中。您可以在HTML文档的任何地方使用下面的元素<code class="fe no np nq nr b">&lt;card-component&gt;</code>。在这段旅程的最后，你的<code class="fe no np nq nr b">index.html</code> <strong class="kw iu"> <em class="og"> </em> </strong>文件会是下面这样的。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a6f5" class="nc lr it nr b gy nw nx l ny nz">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;</span><span id="1cbf" class="nc lr it nr b gy oh nx l ny nz">&lt;head&gt;<br/>&lt;title&gt;Web Component&lt;/title&gt;<br/>&lt;/head&gt;</span><span id="b21e" class="nc lr it nr b gy oh nx l ny nz">&lt;body&gt;<br/>  <br/>&lt;template id="card-view"&gt;<br/>    &lt;h1&gt;Web Component&lt;/h1&gt;<br/>    &lt;p id="card-title"&gt;Example&lt;/p&gt;<br/>    &lt;img id="gif-view"/&gt;<br/>&lt;/template&gt;<br/>  <br/>&lt;card-component&gt;&lt;/card-component&gt;</span><span id="5827" class="nc lr it nr b gy oh nx l ny nz">&lt;script src="./card.js" type="module"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="0793" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要运行这个，你需要一个服务器。从命令行工具全局安装<code class="fe no np nq nr b">static-server</code></p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8e9d" class="nc lr it nr b gy nw nx l ny nz">npm install -g static-server</span></pre><p id="5600" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从web组件项目的工作区运行<code class="fe no np nq nr b">static-server</code> <strong class="kw iu"> <em class="og"> </em> </strong>命令。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4d80" class="nc lr it nr b gy nw nx l ny nz">static-server</span></pre><p id="e135" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">恭喜你。你现在有自己的成分了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">学分:Giphy.com</figcaption></figure><h1 id="897e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">结论</strong></h1><p id="ae9a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">本文总结了web组件的基础知识。这就是web组件的理论和实现。Web组件非常有用，因为它们有助于代码的重用。你可以在这里查看这个小项目的全部代码。</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ow"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">50大JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">gitconnected.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div></div></div>    
</body>
</html>