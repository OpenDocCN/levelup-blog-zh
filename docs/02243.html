<html>
<head>
<title>Create custom Rx.js operator: Aggregating events for a length of time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自定义Rx.js运算符:聚合一段时间内的事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-custom-rx-js-operator-aggregating-events-for-a-length-of-time-eda8da889c51?source=collection_archive---------15-----------------------#2020-02-28">https://levelup.gitconnected.com/create-custom-rx-js-operator-aggregating-events-for-a-length-of-time-eda8da889c51?source=collection_archive---------15-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="45d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Rx.js提供了很多现成的操作符，但有时候，你只能自己动手。</p><p id="cc57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我需要通过键盘命令在Angular应用程序中处理<a class="ae ko" href="https://torsten-muller.dev/angular/navigation-in-an-angular-application-using-keyboard-shortcuts/" rel="noopener ugc nofollow" target="_blank">导航的功能时，我就遇到了这种情况。具体来说，我需要听多键命令，比如<code class="fe kp kq kr ks b">rev</code>，例如，它们应该<em class="kt">反转</em>表格中的顺序。当前实现的Rx链的相关部分如下所示:</a></p><pre class="ku kv kw kx gt ky ks kz la aw lb bi"><span id="5b6b" class="lc ld it ks b gy le lf l lg lh">this.obsRef = this.keyPressObservable<br/>  .pipe(<br/>    filter(this.permitKey),<br/>    map(this.convertToString)<br/>  )<br/>  .subscribe(<br/>    this.reactToKeyPress.bind(this),<br/>  );</span></pre><p id="d692" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，它监听按键事件，过滤掉不需要的按键，然后将有关该按键的信息(即<code class="fe kp kq kr ks b">KeypressEvent</code>)转换为唯一的字符串标识符。它为每一次按键执行这些动作。</p><p id="3e46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一段时间内事件的预期聚合介于<code class="fe kp kq kr ks b"><a class="ae ko" href="https://rxjs-dev.firebaseapp.com/api/operators/scan" rel="noopener ugc nofollow" target="_blank">scan()</a></code>操作符和<code class="fe kp kq kr ks b"><a class="ae ko" href="https://rxjs-dev.firebaseapp.com/api/operators/debounceTime" rel="noopener ugc nofollow" target="_blank">debounceTime()</a></code>操作符的功能之间，前者不断聚合事件，后者抑制在开发人员指定的时间间隔内相继发生的事件。在大理石图中，<code class="fe kp kq kr ks b">aggregate</code>的功能如下所示:</p><figure class="ku kv kw kx gt lj gh gi paragraph-image"><div class="gh gi li"><img src="../Images/197da9c71ed7242adb7319c2f2170b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*iNsxJAd3DHDyFFMtT5j9TA.png"/></div></figure><h1 id="767d" class="lm ld it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">设置运营商基础设施</h1><p id="dc08" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">为了开始我们的实现，我们可以使用下面的shell:</p><pre class="ku kv kw kx gt ky ks kz la aw lb bi"><span id="08f1" class="lc ld it ks b gy le lf l lg lh">export function aggregate&lt;T&gt;(stopAggregationIn: number) {<br/>  return function(source: Observable&lt;T&gt;): Observable&lt;T[]&gt; {<br/>    return new Observable( (subscriber: Subscriber&lt;T[]&gt;) =&gt; {<br/>      // Functionality here<br/>    });<br/>  };<br/>}</span></pre><p id="d96f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义了一个新的操作符<code class="fe kp kq kr ks b">aggregate()</code>，它接受一个<code class="fe kp kq kr ks b">number</code>作为参数，类似于<code class="fe kp kq kr ks b">debounceTime()</code>操作符，它只传递一个事件，如果它发生在事件之间经过了指定的时间量之后(<a class="ae ko" href="https://rxjs-dev.firebaseapp.com/api/operators/debounceTime" rel="noopener ugc nofollow" target="_blank">Rx documentation for de bounce time()</a>)。</p><p id="abc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">aggregate()</code>是一个可扩展的函数，它返回一个接受源可观察值并返回一个不同类型的可观察值的函数，这里是一个包含聚合Rx事件的数组，位于第3行。这是<em class="kt">不变性</em>的一个例子，因为可观察对象不仅仅改变源可观察对象的值，而是创建一个新的可观察对象，它将包含我们操作的结果。</p><p id="3255" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个基本的实现，我们就可以开始实现的核心部分了。</p><h1 id="cf5c" class="lm ld it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">聚合值</h1><p id="1155" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">第一步，我将重新实现scan操作符的功能，在某种程度上，传入的每个事件都将无限期地聚合到一个数组中。有了这个功能，我们的自定义操作符可能如下所示:</p><pre class="ku kv kw kx gt ky ks kz la aw lb bi"><span id="ccaf" class="lc ld it ks b gy le lf l lg lh">export function aggregate&lt;T&gt;(stopAggregationIn: number) {</span><span id="a75c" class="lc ld it ks b gy mo lf l lg lh">  let aggregatedEventValues: T[] = [];</span><span id="2e5e" class="lc ld it ks b gy mo lf l lg lh">  return function(source: Observable&lt;T&gt;): Observable&lt;T[]&gt; {<br/>    return new Observable( (subscriber: Subscriber&lt;T[]&gt;) =&gt; {<br/>      source.subscribe({<br/>        next(value) {<br/>          if (value !== undefined &amp;&amp; value !== null) {<br/>            aggregatedEventValues.push(value);<br/>            subscriber.next(aggregatedEventValues);<br/>          }<br/>        },<br/>        error(error) {<br/>          subscriber.error(error);<br/>        },<br/>        complete() {<br/>          subscriber.complete();<br/>        }<br/>      });<br/>    });<br/>  };<br/>}</span></pre><p id="f5a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">新功能在第3行和第7–20行。在第3行，我们定义了一个类型为<code class="fe kp kq kr ks b">T</code>的数组，当聚集的事件进来时，它将成为这些事件的家。</p><p id="302f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">真正的实现从第7行开始，我们用Rx.js提供的三个操作函数的对象订阅了<code class="fe kp kq kr ks b">source</code>可观察对象。<code class="fe kp kq kr ks b">onError</code>和<code class="fe kp kq kr ks b">onCompleted()</code>事件只是修补到链中的下一个可观察对象(或者订阅，如果我们是管道中的最后一个操作符)。</p><p id="c860" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe kp kq kr ks b">onNext</code>方法中，我们确定我们有一个有效值，如果我们有，我们将它添加到<code class="fe kp kq kr ks b">agggregatedEventValues</code>属性中，并传递给第11行的下一个可观察对象。</p><p id="c4b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">概括一下:到目前为止我们的实现</p><ol class=""><li id="3277" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">监听事件</li><li id="8b80" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">推送(聚合)数组中的事件</li><li id="4847" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">将包含新值的扩充数组传递给Rx链中的下一个操作符。</li><li id="dcd0" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">传递任何错误或完成事件</li></ol><h1 id="a3aa" class="lm ld it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">集合一段时间内的值</h1><p id="aced" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">按照现在的状态实现，我们将永远聚集在一起，并总是传递更大的事件数组，如下图所示:</p><figure class="ku kv kw kx gt lj gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/47b8d8d76382996ffc3b5a1b97183984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*JkLcbbmmJfQeIOI5RLb1_g.png"/></div></figure><p id="a25b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了限制我们聚合事件的时间，我们需要重构实现来使用一个定时器，在经过之后，它将聚合值(事件数组)发送给下一个观察者，并清除聚合数组。</p><p id="bac5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些额外的部分，我们的最终操作符如下所示:</p><pre class="ku kv kw kx gt ky ks kz la aw lb bi"><span id="c0d0" class="lc ld it ks b gy le lf l lg lh">export function aggregate&lt;T&gt;(stopAggregationIn: number) {</span><span id="8285" class="lc ld it ks b gy mo lf l lg lh">  let aggregatedEventValues: T[] = [];<br/>  let timerRef = null;</span><span id="9bfe" class="lc ld it ks b gy mo lf l lg lh">  const handleTimeout = (subscriber: Subscriber&lt;T[]&gt;) =&gt; {<br/>    return (): void =&gt; {<br/>      const keyEventsCopy = aggregatedEventValues.slice(0);<br/>      aggregatedEventValues = [];<br/>      subscriber.next(keyEventsCopy);<br/>    };<br/>  };</span><span id="a282" class="lc ld it ks b gy mo lf l lg lh">  return function(source: Observable&lt;T&gt;): Observable&lt;T[]&gt; {<br/>    return new Observable( (subscriber: Subscriber&lt;T[]&gt;) =&gt; {<br/>      source.subscribe({<br/>        next(value) {<br/>          if (value !== undefined &amp;&amp; value !== null) {<br/>            if (timerRef) clearTimeout(timerRef);<br/>            timerRef = setTimeout(<br/>                 handleTimeout(subscriber), <br/>                 stopAggregationIn);</span><span id="e7cf" class="lc ld it ks b gy mo lf l lg lh">            aggregatedEventValues.push(value);<br/>          }<br/>        },<br/>        error(error) {<br/>          subscriber.error(error);<br/>        },<br/>        complete() {<br/>          subscriber.complete();<br/>        }<br/>      });<br/>    });<br/>  };<br/>}</span></pre><p id="fbdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">超时功能在第19行和第20行的<code class="fe kp kq kr ks b">onNext</code>方法中实现。在第4行，我们定义了一个属性<code class="fe kp kq kr ks b">timerRef</code>，它将保存对当前活动计时器实例的引用。在调用<code class="fe kp kq kr ks b">setTimeout()</code>之前，我们首先检查定时器是否存在，并使用JavaScript <code class="fe kp kq kr ks b">clearTimeout()</code>函数停止它。</p><p id="d82e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在清除之后，我们立即重启一个新的计时器，其持续时间传递给<code class="fe kp kq kr ks b">aggregate()</code>操作器。作为当时要调用的方法，我们在第6-12行定义了一个新函数<code class="fe kp kq kr ks b">handleTimeout</code>。这也是一个定制函数，它接受一个类型为<code class="fe kp kq kr ks b">Subscriber&lt;T[]&gt;</code>的订户实例，并返回一个</p><ol class=""><li id="25dd" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">复制包含所有先前事件的数组(第8行)</li><li id="0b23" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">清空原始列表，以便我们为另一组按键重置操作符(第9行),最后，</li><li id="6f31" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">将收集的事件副本作为当前可观察对象(第10行)上的<code class="fe kp kq kr ks b">onNext()</code>事件提供给其订户。</li></ol><p id="a18c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与实现的前一个状态相比，这一个将对<code class="fe kp kq kr ks b">onNext()</code>的调用从直接在向事件数组添加一个新项目后移到一个在计时器到期后被调用的方法中。因此，我们为这个操作符实现了一个异步机制，因为它接受输入，并在未来的某个时刻触发一个事件——当用户停止输入<code class="fe kp kq kr ks b">stopAggregationIn</code>毫秒时，我们操作符的参数。</p><h1 id="b1a0" class="lm ld it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用运算符</h1><p id="1586" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">这一切都是因为我需要为Angular app <a class="ae ko" href="https://torsten-muller.dev/angular/navigation-in-an-angular-application-using-keyboard-shortcuts/" rel="noopener ugc nofollow" target="_blank">实现一个机制，允许使用快捷键</a>来导航和执行命令。在该实现中，我使用了这样一个Rx链:</p><pre class="ku kv kw kx gt ky ks kz la aw lb bi"><span id="443c" class="lc ld it ks b gy le lf l lg lh">public ngOnInit() {<br/>    this.obsRef = this.keyServiceRef.keyEventObs<br/>      .pipe(<br/>        filter(this.permitKey),<br/>        map(this.convertToString.bind(this)),<br/>      )<br/>      .subscribe(<br/>        this.reactToKeyPress.bind(this),<br/>      );<br/>  }</span></pre><p id="57b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，它过滤掉不需要的键，然后构建一个自定义标识符，用于组件中触发操作。这对于单键指令/命令很有效，但现在我要扩展它，让用户可以盲目地键入组合键，并让该组合键触发某种动作。</p><p id="8cc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我需要在管道中添加新的<code class="fe kp kq kr ks b">aggregate()</code>操作符(第3行),两次击键之间的收集超时为300毫秒，很像<code class="fe kp kq kr ks b">debounceTime()</code>操作符:</p><pre class="ku kv kw kx gt ky ks kz la aw lb bi"><span id="bb5c" class="lc ld it ks b gy le lf l lg lh">.pipe(<br/>    filter(this.permitKey),<br/>    aggregate(300),<br/>    map(this.convertToString.bind(this)),<br/>  )</span></pre><p id="e06f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并修改<code class="fe kp kq kr ks b">convertToString()</code>方法，现在接受一个<code class="fe kp kq kr ks b">KeyboardEvent</code>的数组，而不是单个事件。现在实现如下所示:</p><pre class="ku kv kw kx gt ky ks kz la aw lb bi"><span id="0d30" class="lc ld it ks b gy le lf l lg lh">public convertToString(keyEventList: KeyboardEvent[]): string {<br/>    if (keyEventList.length &gt; 1) {<br/>      return this.generateMultiKeyString(keyEventList);<br/>    } else {<br/>      const modifiers = this.modifierKeysToString(keyEventList[0]);<br/>      return `${ modifiers }-${ keyEventList[0].code }`;<br/>    }<br/>  }</span><span id="d7b4" class="lc ld it ks b gy mo lf l lg lh">  public generateMultiKeyString(keyEventList: KeyboardEvent[]) {<br/>    const prefix = this.modifierKeysToString(keyEventList[0], 's-');<br/>    let keySequence = '';<br/>    for (const event of keyEventList) {<br/>      keySequence += event.key.toLowerCase();<br/>    }<br/>    return `${prefix}-${keySequence}`;<br/>  }</span><span id="6e0e" class="lc ld it ks b gy mo lf l lg lh">  private modifierKeysToString(keypress, prefix = 'k-'): string {<br/>    const modifierKeys = ['altKey', 'ctrlKey', 'shiftKey'];<br/>    let keyCode = prefix;<br/>    for (const code of modifierKeys) {<br/>      if (keypress[code]) keyCode += code.substr(0, 1);<br/>    }<br/>    return keyCode;<br/>  }</span></pre><p id="6e41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能已经注意到了<code class="fe kp kq kr ks b">pipe()</code>中的<code class="fe kp kq kr ks b">this.convertToString.bind(this)</code>调用。<code class="fe kp kq kr ks b">bind()</code>将传递给<code class="fe kp kq kr ks b">map()</code>的函数的执行上下文更改为包含第二个清单中调用的方法<code class="fe kp kq kr ks b">generateMultiKeyStrokeString()</code>和<code class="fe kp kq kr ks b">modifierKeysToString()</code>的类。如果没有这个<code class="fe kp kq kr ks b">bind()</code>，前面清单中的<code class="fe kp kq kr ks b">this</code>引用将不起作用。</p><p id="063a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一功能很快得到解释:</p><ol class=""><li id="6835" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated"><code class="fe kp kq kr ks b">convertToString()</code>方法现在区分了多键命令和单键命令，其中多指的是按顺序的多个键，而不是像Ctrl那样同时按下的键。</li><li id="5ef9" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">当在<code class="fe kp kq kr ks b">generateMultiKeystrokeString()</code>中生成ID字符串时，我们用<code class="fe kp kq kr ks b">s-</code>作为结果字符串的前缀，然后继续解析修改键并构建一个已经使用的键的字符串。</li><li id="24da" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><code class="fe kp kq kr ks b">modifierKeysToString()</code>方法与它先前的化身没有改变。</li></ol><p id="d4c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在该实现中，值得注意的是，假设第一次按键时的特殊键对于所有后续事件也有效，如该行(11)所示:</p><p id="f8ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">const prefix = this.modifierKeysToString(keyEventList[0], 's-');</code></p><p id="7ce3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它只传递数组中的第一个事件来分析特殊键，并传递前缀<code class="fe kp kq kr ks b">s-</code>。</p><p id="d0c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一个清单中的其余代码应该是不言自明的。</p><h1 id="5294" class="lm ld it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="5032" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">在这篇文章中，我展示了如何实现一个异步Rx.js操作符，它将Rx链中的事件聚合到一个具有指定超时的数组中，然后释放一个包含一个数组的事件，该数组包含一个<code class="fe kp kq kr ks b">onNext()</code>事件中的所有缓冲事件。</p><p id="b5ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经展示了如何在之前基于Rx.js的实现中使用该操作符<a class="ae ko" href="https://torsten-muller.dev/angular/navigation-in-an-angular-application-using-keyboard-shortcuts/" rel="noopener ugc nofollow" target="_blank">将按键事件转换成唯一的字符串</a>。</p><p id="b33e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个实现的代码可以在bitbucket 上找到<a class="ae ko" href="https://bitbucket.org/tmuller/keypress-navigation/src/master/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>