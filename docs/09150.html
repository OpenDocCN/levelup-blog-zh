<html>
<head>
<title>What is HEAD in Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git中的HEAD是什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-head-in-git-4459b811ad40?source=collection_archive---------17-----------------------#2021-07-10">https://levelup.gitconnected.com/what-is-head-in-git-4459b811ad40?source=collection_archive---------17-----------------------#2021-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="00b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HEAD回答了这个问题:我现在在存储库中的什么位置？它是一个指向当前检出分支或提交的指针！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2e351d0df7c826c6dcd0761d3a448871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4NS5j55PktaWcrCC"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@fallonmichaeltx?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">法伦·迈克尔</a> / <a class="ae lb" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="7759" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">原载于2021年7月10日https://blog.git-init.com</em><a class="ae lb" href="https://blog.git-init.com/what-is-head-in-git/" rel="noopener ugc nofollow" target="_blank"><em class="lc"/></a><em class="lc">。</em></p><p id="6bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ld le lf lg b">HEAD</code>回答问题:<strong class="jp ir"> <em class="lc">我现在在存储库中的什么位置？</em> </strong>它是一个指向当前已签出的分支或提交的指针，其中包含在给定时间你的整个代码库的<a class="ae lb" href="https://blog.git-init.com/immutable-snapshot-in-git/" rel="noopener ugc nofollow" target="_blank">不可变快照</a>。无论提交<code class="fe ld le lf lg b">HEAD</code>是直接引用(使用散列)还是通过引用(使用分支)，它总是任何本地更改所基于的提交。</p><p id="052a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，但这一切到底意味着什么？在这篇文章中，我会用插图更详细地解释上面的陈述，展示<code class="fe ld le lf lg b">HEAD</code>是如何运作的。</p><h1 id="a2dc" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">连接和分离状态</h1><p id="0bea" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">首先，必须知道<code class="fe ld le lf lg b">HEAD</code>指针可以有两种状态:<strong class="jp ir"> <em class="lc">附着</em> </strong>或<strong class="jp ir"> <em class="lc">脱离</em> </strong>。默认状态是<strong class="jp ir"> <em class="lc">附属</em> </strong>，历史的任何操作都会自动记录到<code class="fe ld le lf lg b">HEAD</code>当前引用的分支。在<strong class="jp ir"> <em class="lc">分离</em> </strong>状态下，可以在不影响任何现有分支的情况下进行实验性改变，因为<code class="fe ld le lf lg b">HEAD</code>直接引用底层提交，并且不“附加”到特定分支。</p><p id="090e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还是，迷惑？放心吧！下图以并列比较的方式展示了这两种状态。注意，我们的历史只包含两个提交(<strong class="jp ir"><em class="lc">C0</em></strong>&amp;<strong class="jp ir"><em class="lc">C1</em></strong>)和一个分支(<strong class="jp ir"> <em class="lc">主</em> </strong>)及其远程对应(<strong class="jp ir"><em class="lc">o/主</em> </strong>)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/8789e7b46d342a58e074134e24bf73f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iK5XBpe05kjPZOqF.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">左侧为头部处于连接状态的历史，右侧为头部处于分离状态的历史。在连接状态下，通过本地主分支引用C1，而在分离状态下，直接通过其哈希“14ko3”引用。</figcaption></figure><p id="1210" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在左侧，<code class="fe ld le lf lg b">HEAD</code>处于默认状态，任何变化都会自动记录到分支；在这个特例中，本地的<code class="fe ld le lf lg b">master</code>分支。在右边，<code class="fe ld le lf lg b">HEAD</code>处于稍微不常见的状态，直接使用它的惟一散列<code class="fe ld le lf lg b">14ko3</code>引用提交。</p><p id="70b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是要明白，不管底层提交是如何被引用的(直接还是通过引用)，其内容在签出时都会自动解包并镜像到您的本地<em class="lc">工作树</em>(例如，您计算机上的文件和文件夹)。在上面的例子中，本地<em class="lc">工作树</em>在两种情况下是相同的，包含<code class="fe ld le lf lg b">14ko3</code>的快照。</p><p id="a7d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们知道了<code class="fe ld le lf lg b">HEAD</code>如何直接或通过引用指向提交；让我们看看，如果我们通过在<strong class="jp ir"><em class="lc"/></strong>之上创建一个新的提交(<strong class="jp ir"> <em class="lc"> C2 </em> </strong>)来操纵历史，会发生什么。同样，为了便于比较，这两个状态是并排的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/ec6ac1d4a77c7a8072b297b2ef06ba5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YdbRhmibQPmEDSHj.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在左侧，C2以附加状态提交，主分支自动跟随。在右边，C2承诺在分离状态，让所有其他分支保持原样。</figcaption></figure><p id="a3d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在上面看到的，新的提交<strong class="jp ir"> <em class="lc"> C2 </em> </strong>在两种情况下都是通过<code class="fe ld le lf lg b">commit</code>操作创建的。主要区别在于，在<strong class="jp ir"> <em class="lc">附加</em> </strong>状态下，变化自动记录在<code class="fe ld le lf lg b">master</code>分支中。相比之下，在<strong class="jp ir"> <em class="lc">分离</em> </strong>状态下，变更不会影响任何现有分支，并且<code class="fe ld le lf lg b">master</code>仍然引用<strong class="jp ir"><em class="lc"/></strong>。</p><p id="1f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果使用回滚操作，类似的事情也会发生，比如<code class="fe ld le lf lg b">reset</code>，但是这种情况适合在以后的博客文章中讨论！</p><p id="af47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看如何知道<code class="fe ld le lf lg b">HEAD</code>当前引用的是什么。</p><h1 id="77f4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">HEAD指的是什么？</h1><p id="a991" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如上所述，大多数时候你的<code class="fe ld le lf lg b">HEAD</code>引用将指向一个分支，因此处于附加状态。每当在分支上创建新的提交时，<code class="fe ld le lf lg b">HEAD</code>将自动跟随。但是，在某些情况下，在某些过程中，您会发现自己与<code class="fe ld le lf lg b">HEAD</code>处于分离状态，它直接引用提交而不是分支。</p><p id="0aad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，每次您使用提交的散列显式地签出提交，或者如果您签出标签，<code class="fe ld le lf lg b">HEAD</code>将进入分离状态。还有其他操作，如互动<code class="fe ld le lf lg b">rebase</code>可能会让你与<code class="fe ld le lf lg b">HEAD</code>分离。</p><p id="7832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论何时你想知道<code class="fe ld le lf lg b">HEAD</code>当前处于哪个状态以及它引用了什么，最简单的方法就是在你的终端中输入<code class="fe ld le lf lg b">$ git status</code>。然后Git会让您知道整个<em class="lc">工作树的状态，</em>包括<em class="lc">索引</em>(暂存区)，还有<code class="fe ld le lf lg b">HEAD</code>的状态。</p><p id="9b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个简短的序列，展示了Git如何总是试图通知您<code class="fe ld le lf lg b">HEAD</code>的当前状态。在这个例子中，首先使用它的散列(<code class="fe ld le lf lg b">t57lk</code>)检查提交，让<code class="fe ld le lf lg b">HEAD</code>分离。</p><pre class="km kn ko kp gt ml lg mm bn mn mo bi"><span id="60b7" class="mp li iq lg b be mq mr l ms mt">$ git checkout t57lk<br/>Switching to 't57lk', you are now in 'detached HEAD' state.<br/><br/>$ git status<br/>HEAD detached at t57lk</span></pre><p id="5faa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查<code class="fe ld le lf lg b">HEAD</code>指向什么的另一个简单方法是使用命令<code class="fe ld le lf lg b">$ git show HEAD --oneline</code>。它会告诉您<code class="fe ld le lf lg b">HEAD</code>当前引用的是什么，但也会列出所有其他也引用相同提交的分支；注意下面最后一行括号内的<code class="fe ld le lf lg b">HEAD -&gt; master</code>，表示<code class="fe ld le lf lg b">HEAD</code>指向<code class="fe ld le lf lg b">master</code>——因此间接表示<code class="fe ld le lf lg b">HEAD</code>处于附着状态。</p><pre class="km kn ko kp gt ml lg mm bn mn mo bi"><span id="b796" class="mp li iq lg b be mq mr l ms mt">$ git checkout master<br/>Switched to branch 'master'<br/><br/>$ git show HEAD --oneline<br/>t57lk (HEAD -&gt; master, o/master) C2</span></pre><h1 id="85d6" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">你处于‘分离的头’状态</h1><p id="68ec" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">许多git初学者认为消息<code class="fe ld le lf lg b">You are in 'detached HEAD' state</code>是一个错误，但实际上，正如我们刚刚看到的，它只是描述了你的<code class="fe ld le lf lg b">HEAD</code>指针的状态。从分离的<code class="fe ld le lf lg b">HEAD</code>状态中“恢复”很简单:切换回一个现有的分支，或者从您当前所在的位置创建一个新的分支。</p><h1 id="db83" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">显式检查头指针(过度)</h1><p id="dc58" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如果你想明确地看到<code class="fe ld le lf lg b">HEAD</code>引用的是什么，你总是可以检查<code class="fe ld le lf lg b">.git/HEAD</code>文件，这是git内部用来管理<code class="fe ld le lf lg b">HEAD</code>的实际文件。根据<code class="fe ld le lf lg b">HEAD</code>是否分离，文件包含分支或提交散列的名称。</p><p id="18d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显式检查<code class="fe ld le lf lg b">HEAD</code>通常是你永远不会做的事情，但是出于教育目的，知道这一点是有好处的。在下面的例子中，使用了<a class="ae lb" href="https://en.wikipedia.org/wiki/Cat_(Unix)?ref=the-pragmatic-git" rel="noopener ugc nofollow" target="_blank"> cat </a>，但是您可以使用常规的文本编辑器来查看该文件。</p><pre class="km kn ko kp gt ml lg mm bn mn mo bi"><span id="cc0d" class="mp li iq lg b be mq mr l ms mt">$ cat .git/HEAD<br/>ref: refs/heads/master</span></pre><p id="5405" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">的内容。git/HEAD文件当处于<strong class="jp ir"> <em class="lc">附加</em> </strong>状态时，在这种情况下引用主分支。</p><pre class="km kn ko kp gt ml lg mm bn mn mo bi"><span id="341e" class="mp li iq lg b be mq mr l ms mt">$ cat .git/HEAD<br/>t57lk60b4b4aece5915caf5c68d12f560a9fe3e4</span></pre><p id="98fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">的内容。git/HEAD文件当处于<strong class="jp ir"> <em class="lc">分离</em> </strong>状态时，在这种情况下显式引用提交散列。</p><h2 id="6f51" class="mu li iq bd lj mv mw dn ln mx my dp lr jy mz na lv kc nb nc lz kg nd ne md nf bi translated">@ —新的头像别名</h2><p id="bb79" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">从Git的<code class="fe ld le lf lg b">1.8.4</code>版本开始，为了方便起见，<code class="fe ld le lf lg b">@</code>符号可以和<code class="fe ld le lf lg b">HEAD</code>互换使用。例如，不要输入<code class="fe ld le lf lg b">$ git show HEAD --oneline</code>，你可以改为写<code class="fe ld le lf lg b">$ git show @ --oneline</code>。</p><h1 id="9298" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="b56c" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">那么，为什么理解<code class="fe ld le lf lg b">HEAD</code>两种状态的概念如此重要呢？</p><p id="e3a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对<code class="fe ld le lf lg b">HEAD</code>指针有了很好的理解，您可以快速浏览您的存储库的历史，并执行您认为合适的操作。您再也不会迷失在时间中，或者将信息误解为错误！</p><p id="7d46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个简短的备忘单，说明了<code class="fe ld le lf lg b">HEAD</code>的概念；下载吧！=)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/57c4d6e20cd5ba5f038d6dbe03cb6e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zI749MoR7US_XK2O.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">说明HEAD概念的备忘单，突出显示两种状态:连接和分离。</figcaption></figure><p id="c722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了充分理解<code class="fe ld le lf lg b">HEAD</code>的工作原理，还必须理解<code class="fe ld le lf lg b">HEAD</code>、<em class="lc">工作树</em>和<em class="lc">索引</em>(暂存区)之间的关系。对这种相互关系的深入探究将在以后的文章中发表！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="fdbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然您已经知道了什么是<code class="fe ld le lf lg b">HEAD</code>以及它是如何操作的，我希望您在浏览您的存储库的历史时会更有信心。</p><p id="ef59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读，祝您好运，提高您的源代码管理技能！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="db39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">📫如果你想要更多这样的文章，请访问实用Git博客并注册新闻订阅！</p><p id="fc1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会在收件箱里直接看到有趣的Git主题，并访问会员专用的内容。</p><p id="1cd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">☝️:有任何问题或建议，试着在推特上联系我— <a class="ae lb" href="https://twitter.com/Stjaertfena?ref=the-pragmatic-git" rel="noopener ugc nofollow" target="_blank"> @Stjaertfena </a></p></div></div>    
</body>
</html>