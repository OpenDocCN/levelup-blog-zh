<html>
<head>
<title>Pattern matching with Python is genius. Here’s why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python做模式匹配简直是天才。原因如下</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pattern-matching-with-python-is-genius-heres-why-86e57090f922?source=collection_archive---------1-----------------------#2022-08-23">https://levelup.gitconnected.com/pattern-matching-with-python-is-genius-heres-why-86e57090f922?source=collection_archive---------1-----------------------#2022-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="666b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解析数据有了新的好朋友</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42847255024d280f1152e61576d9ff63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xoaJSAeLWjpQFpW89QYmlw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">最后，Python可以进行适当的模式匹配。</figcaption></figure><p id="da83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">历经三十年的发展，Python终于找到了一种优雅的方式来匹配一个值与许多可能条件中的一个。早就该这样了，但我们得到的是非常棒的。</p><p id="1478" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模式匹配不仅过期了，因为其他语言早就有了。在C和C++中，它被称为<a class="ae ml" href="https://www.cprogramming.com/tutorial/c/lesson5.html" rel="noopener ugc nofollow" target="_blank">开关/外壳结构</a>。在Rust里叫<a class="ae ml" href="https://doc.rust-lang.org/book/ch18-00-patterns.html" rel="noopener ugc nofollow" target="_blank">模式匹配</a>。</p><p id="af6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于Python用户来说，这不仅仅是一种绕过丑陋的<code class="fe mm mn mo mp b">if...elif...else</code>语句的方法。<a class="ae ml" href="https://peps.python.org/pep-0636/" rel="noopener ugc nofollow" target="_blank">所谓的结构模式匹配</a>，不仅仅帮助匹配文字字符串。您还可以使用它来处理精确的模式(因此得名)，方法是指定变量名、类型，甚至是您可能想要匹配的对象。</p><p id="5b69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本语法非常类似于C语言的switch/case语句。关键字<code class="fe mm mn mo mp b">match</code>获取一个对象，根据一个或多个匹配模式对其进行测试，如果找到匹配模式，它就执行这种情况下需要的任何操作。</p><p id="5e5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个基本的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/53951cb52301d51cef99a32b259f2bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfrAHTjP_5PUUw0CgLGMhw.png"/></div></div></figure><p id="2cee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看到这有多美了吗？这种类型的语法正是函数式编程教科书所推荐的。另外一个例子是<a class="ae ml" href="https://towardsdatascience.com/why-developers-are-falling-in-love-with-functional-programming-13514df4048e" rel="noopener" target="_blank"> Python变得越来越实用</a>。</p><p id="1e05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码之所以如此有趣，是因为它基本上是<code class="fe mm mn mo mp b">if</code>——伪装的语句。然而，它要优雅得多，因为它可以同时检查多个对象，如上面包含<code class="fe mm mn mo mp b">article</code>和<code class="fe mm mn mo mp b">sentiment</code>的示例所示。</p><p id="6160" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">万一像<code class="fe mm mn mo mp b">article</code>或<code class="fe mm mn mo mp b">sentiment</code>这样的部分或全部信息丢失，我们不需要依赖不确定的<code class="fe mm mn mo mp b">else</code>语句。我们只是优雅地处理每个案子。</p><p id="0929" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以检查类型，就像上面用<code class="fe mm mn mo mp b">str()</code>做的那样，以及各种其他属性，包括字符串的<code class="fe mm mn mo mp b">isupper()</code>。当然，也可以检查其他数据类型的其他属性。</p><p id="b992" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了我们使用字典的例子之外，您还可以将列表、元组、对象等放入模式匹配中。这与上面的例子非常相似。</p><p id="8df3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以使用or运算符<code class="fe mm mn mo mp b">|</code>将多个案例组合在一起。这个的语法是<code class="fe mm mn mo mp b">case ("a"|"b"|"c")</code>。</p><p id="02b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们看看我们的例子是如何工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/89afb6f7aedf7eaaa5f5dc902f2e9622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEUy8rkmggqNLo8Fkctq_g.png"/></div></div></figure><p id="9c17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想要同样漂亮的功能，但试图在没有新模式匹配的情况下生存，我们会得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/6f56a10db0b33ab231ef8f4f3ab2bc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nn7HQJqhElzG2irOlZSVKA.png"/></div></div></figure><p id="0b79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了完全公开，我懒得自己写这么难看的代码，所以我采用了来自<a class="ae ml" href="https://www.inspiredpython.com/course/pattern-matching/mastering-structural-pattern-matching" rel="noopener ugc nofollow" target="_blank">这篇优秀文章</a>的方法。此外，我甚至没有填充所有内容，因为我不想让你淹没在这样的代码中。</p><p id="8cb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不用说，很明显，在这种情况下，新的<code class="fe mm mn mo mp b">match</code>声明更容易使用和阅读。</p><p id="2e6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些批评家<a class="ae ml" href="https://benhoyt.com/writings/python-pattern-matching/" rel="noopener ugc nofollow" target="_blank">指出</a>然而<code class="fe mm mn mo mp b">match</code>语句比某些<code class="fe mm mn mo mp b">if...else</code>语句有更陡峭的学习曲线。这无疑是对的，但我要说，花15分钟的时间来掌握这一点是非常值得的，而不是花30分钟来编写维护性差的代码。</p><h2 id="e771" class="mt mu it bd mv mw mx dn my mz na dp nb lh nc nd ne ll nf ng nh lp ni nj nk nl bi translated">结构模式匹配的创造性应用</h2><p id="1c39" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">Python模式匹配的批评者也指出，它可能没有太多的用例。</p><p id="d80a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上，它适用于有许多不同的可能模式要匹配的场景，以及关于这些模式的许多细节非常重要的场景。过去解决这个问题的方法是通过冗长的嵌套表达式。</p><p id="f0c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在其他情况下，结构模式匹配是有用的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/cc07ed3522678013b3351368b4bd10a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJvss9lGHgJ41xBYGf1uIA.png"/></div></div></figure><p id="12ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我从这里的<a class="ae ml" href="https://python-course.eu/python-tutorial/structural-pattern-matching.php" rel="noopener ugc nofollow" target="_blank">偷了这个可爱的例子</a>。不过这是一件相当琐碎的事情，在<code class="fe mm mn mo mp b">math</code>包中有一个内置函数。因此，您可以很容易地用下面的代码替换上面的代码:</p><pre class="kj kk kl km gt ns mp nt nu aw nv bi"><span id="ee33" class="mt mu it mp b gy nw nx l ny nz">import math</span><span id="124b" class="mt mu it mp b gy oa nx l ny nz">for i in range(6):<br/>    print(i, math.factorial(i))</span></pre><p id="8288" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也比上面的代码快了大约12倍，至少在我的电脑上是这样。(它花了0.13秒，而当我试图在我的机器上计算<code class="fe mm mn mo mp b">factorial(6)</code>时，上面的函数花了大约1.5秒。)</p><p id="5057" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，通过难看的<code class="fe mm mn mo mp b">if...else</code>语句定义阶乘函数也需要1.5秒。这表明——尽管这不是证据！——嵌套的<code class="fe mm mn mo mp b">if...else</code>语句和<code class="fe mm mn mo mp b">match</code>语句几乎一样快。</p><p id="d473" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，当您在没有内置解决方案的地方定义函数时，您可能不会通过使用结构化模式匹配来降低代码速度。</p><h2 id="ca34" class="mt mu it bd mv mw mx dn my mz na dp nb lh nc nd ne ll nf ng nh lp ni nj nk nl bi translated">关于令人敬畏的模式匹配的一句话</h2><p id="2b82" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在Python中还有另一种方式可以进行模式匹配。从3.7版本开始，软件包<code class="fe mm mn mo mp b">apm</code>，即<a class="ae ml" href="https://pypi.org/project/awesome-pattern-matching/" rel="noopener ugc nofollow" target="_blank"> Awesome Pattern Matching </a>的缩写，一直在提供自己的方式来避开丑陋的代码片段，同时引入优秀的功能。</p><p id="3e09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作者声称<code class="fe mm mn mo mp b">apm</code>中还有一些内置模式匹配没有的功能；然而，这些用例似乎很少见。一个<a class="ae ml" href="https://github.com/scravy/awesome-pattern-matching/blob/main/docs/pep634_vs_different_apm_styles.py" rel="noopener ugc nofollow" target="_blank">深入的比较</a>揭示了大部分的语法差异。</p><p id="b9cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我个人更喜欢内置模式匹配的语法。但是对于那些喜欢使用<code class="fe mm mn mo mp b">apm</code>的人来说，你当然可以自由地使用它。</p><h2 id="b2e3" class="mt mu it bd mv mw mx dn my mz na dp nb lh nc nd ne ll nf ng nh lp ni nj nk nl bi translated">吹牛</h2><p id="804e" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">模式匹配在Python中仍然是相当新的，但很可能许多开发人员会很快采用它。</p><p id="ace7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这当然很容易声称，因为事实上这是一个社区非常需要的特性。但是这种说法不仅仅如此。与其他特征相比，结构模式匹配可能具有相对陡峭的学习曲线；然而，如果你对意大利面条式的代码过敏，这是非常值得的。).</p><p id="5f19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它简洁，优雅，写起来很甜，易于阅读和维护。</p><p id="bc7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">人们还能期望什么呢？</p><p id="d7ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ob">感谢</em> <a class="ae ml" href="https://orell-garten.medium.com" rel="noopener"> <em class="ob">奥瑞尔·加滕</em> </a> <em class="ob">启发了这个故事！</em></p><p id="c71b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ob">成为</em> <a class="ae ml" href="https://arijoury.medium.com/membership" rel="noopener"> <em class="ob">中等会员</em> </a> <em class="ob">获取我的全部内容。</em></p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="023c" class="oj mu it bd mv ok ol om my on oo op nb jz oq ka ne kc or kd nh kf os kg nk ot bi translated">分级编码</h1><p id="ee86" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="c7dc" class="ou ov it la b lb lc le lf lh ow ll ox lp oy lt oz pa pb pc bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="2fa2" class="ou ov it la b lb pd le pe lh pf ll pg lp ph lt oz pa pb pc bi translated">📰查看<a class="ae ml" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="f767" class="ou ov it la b lb pd le pe lh pf ll pg lp ph lt oz pa pb pc bi translated">🔔关注我们:<a class="ae ml" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ml" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae ml" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="d27b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">🚀👉<a class="ae ml" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>