<html>
<head>
<title>SOLID Principles Simplified with Examples in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PHP中的例子简化坚实的原理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solid-principles-simplified-php-examples-based-dc6b4f8861f6?source=collection_archive---------0-----------------------#2019-08-23">https://levelup.gitconnected.com/solid-principles-simplified-php-examples-based-dc6b4f8861f6?source=collection_archive---------0-----------------------#2019-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0b0d80ba4712104583c9f45ff267ab4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BYjprma5eQpGV08e"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@_zachreiner_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扎克·赖纳</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="1014" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SOLID是<strong class="ki iu">前五个面向对象设计(OOD)原则的首字母缩写</strong>和<strong class="ki iu"> </strong>是一系列指导原则，开发人员可以使用它们以一种易于维护和扩展的方式构建软件。理解这些概念将使您成为更好的开发人员，并使您能够避免代码味道。</p><p id="1915" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实心代表:</p><ul class=""><li id="0fea" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">单一责任原则</li><li id="007c" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu"> O: </strong>开闭原理</li><li id="9e7e" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu"> L: </strong>利斯科夫替代原理</li><li id="d5f3" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu"> I: </strong>界面偏析原理</li><li id="87a8" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu"> D: </strong>依存倒置原则</li></ul><p id="86a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们更深入地了解这些原则！</p><h1 id="58d4" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">单一责任原则</h1><blockquote class="mq"><p id="df7f" class="mr ms it bd mt mu mv mw mx my mz ld dk translated">一个类应该有且只有一个改变的理由，这意味着一个类应该只有一个作业。</p></blockquote><p id="fa7b" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">这意味着如果我们的类承担不止一个责任，我们将有一个高耦合。原因是我们的代码在任何变化下都是脆弱的。</p><p id="2776" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个用户类，如下所示:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="558e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，方法<code class="fe nl nm nn no b">store</code>超出了范围，这个职责应该属于管理数据库的类。这里的解决方案是创建两个类，每个类都有适当的职责。</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="59da" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">开闭原理</h1><blockquote class="mq"><p id="f24e" class="mr ms it bd mt mu mv mw mx my mz ld dk translated">对象或实体应该对扩展开放，但对修改关闭。</p></blockquote><p id="b2ed" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">根据这一原则，软件实体必须<strong class="ki iu">易于扩展新功能，而不必修改其使用中的现有代码</strong>。</p><p id="fa72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们必须计算一些物体的总面积，为此我们需要一个<em class="np"> AreaCalculator </em>类，它只计算每个形状面积的总和。这里的问题是每个形状都有不同的方法来计算自己的面积。</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="15a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们添加另一个形状，如<em class="np">圆</em>，我们必须改变<em class="np">面积计算器</em>来计算新形状的面积，这是不可持续的。这里的解决方案是创建一个简单的<em class="np">形状</em>接口，该接口具有area方法，并将由所有其他形状实现。这样，我们将只使用一种方法来计算总和，如果我们需要添加一个新的形状，它将只实现<em class="np">形状</em>接口。</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="d2f4" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">利斯科夫替代原理</h1><blockquote class="mq"><p id="7698" class="mr ms it bd mt mu mv mw mx my mz ld dk translated">设q(x)是关于t类型的对象x的一个可证明的性质，那么q(y)对于S类型的对象y应该是可证明的，其中S是t的子类型。</p></blockquote><p id="b838" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">原则上说<strong class="ki iu">对象必须可以被其子类型的实例替换，而不改变我们系统</strong>的正确功能。</p><p id="4839" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一下管理两种类型的咖啡机。根据用户计划，我们将使用基本或高级咖啡机，唯一的区别是高级机器比基本机器做出更好的香草咖啡。两台机器的主程序行为必须相同。</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="53e3" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">界面分离原理</h1><blockquote class="mq"><p id="ad2e" class="mr ms it bd mt mu mv mw mx my mz ld dk translated">永远不要强迫客户端实现它不使用的接口，也不要强迫客户端依赖它们不使用的方法。</p></blockquote><p id="e713" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">这个原则定义了<strong class="ki iu">一个类不应该实现不使用</strong>的接口。在这种情况下，意味着在我们的实现中，我们将拥有不需要的方法。解决方法是<strong class="ki iu">开发专用接口，而不是通用接口</strong>。</p><p id="89b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一下，我们发明了既能飞行又能驾驶的未来汽车</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0734" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，主要问题是<em class="np">汽车</em>和<em class="np">飞机</em>有不使用的方法。解决方案是将<em class="np">车辆接口</em>分成两个更具体的接口，仅在必要时使用，如下所示:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="3b49" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">从属倒置原则</h1><blockquote class="mq"><p id="eba6" class="mr ms it bd mt mu mv mw mx my mz ld dk translated">实体必须依赖抽象，而不是具体。它声明高级模块不能依赖于低级模块，但是它们应该依赖于抽象。</p></blockquote><p id="b908" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">这个原则意味着<strong class="ki iu">一个特定的类不应该直接依赖于另一个类，而是依赖于这个类的抽象</strong>。这个原则允许解耦和更多的代码可重用性。</p><p id="f830" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看第一个<em class="np"> UserDB </em>类的例子。该类可能依赖于数据库连接:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3287" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，<em class="np"> UserDB </em>类直接依赖于MySQL数据库。这意味着，如果我们要改变正在使用的数据库引擎，我们需要重写这个类，违反了开闭原则。</p><p id="d5d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案是开发数据库连接的抽象:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="b179" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些原则代表了代码质量的艺术状态，遵循这些原则可以让你写出易于扩展、重用和重构的软件。</p><p id="5da9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇文章能帮助你更好地理解什么是代码质量，也许还能提高你的编码能力！编码快乐！😄</p></div></div>    
</body>
</html>