<html>
<head>
<title>Let’s Be More Reactive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们更积极地应对</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-be-more-reactive-7b1a1554e6da?source=collection_archive---------6-----------------------#2020-02-11">https://levelup.gitconnected.com/lets-be-more-reactive-7b1a1554e6da?source=collection_archive---------6-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0dc78d97110e5d2c5507a924f5d6a68c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXA_eIsmABYZ1GHZJTVJIQ.png"/></div></div></figure><p id="8ae7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated"><span class="l la lb lc bm ld le lf lg lh di"> "R </span>活动编程？"—这是新事物吗？编程的下一件大事？</p><p id="b929" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你现在也对这个术语感到好奇，并在互联网上搜索，你可能会看到这样的定义:</p><p id="d01a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">“反应式编程是一种异步编程范式，关注数据流和变化的传播。”</strong></p><p id="68e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">互联网上有很多不好的解释和定义。<a class="ae li" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a>和往常一样过于笼统和理论化。<a class="ae li" href="http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>的规范回答显然不适合我这样的新人。这一切让我更加好奇，最终迫使我尝试以更简单的方式展开这个话题。</p><p id="85df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反应式编程并不是什么新东西。它已经存在很长时间了，但最近由于多种原因，它开始吸引开发人员，许多人正试图将他们的思想从典型的编程思维模式转变为反应式编程范式(如果不参考正确的内容，这可能不会那么容易)。</p><h2 id="bae1" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">那么什么是反应式编程呢？</h2><p id="fa3c" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">这里有一个真实的例子。比如说，今天是星期五，约翰想和他的朋友鲍勃一起度过这个晚上，吃披萨，看一集《黑客帝国》。让我们概括一下他的选择:</p><p id="b324" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">约翰完成了他的工作。然后去点披萨，一直等到做好。然后他抱起他的朋友。最后(带着鲍勃和披萨)回到家，去看电影。这将是<strong class="kd iu"> <em class="mh">同步</em> </strong> <em class="mh"> </em>的方法，而且耗时太长。到那个时候，约翰会想取消这件事的。</p><p id="dcee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">方法2: </strong>约翰在网上订了比萨饼，打电话给鲍勃，邀请他来。他回到家，叫了外卖披萨，开始看电影(吃披萨),没有等鲍勃出现。这就是使用<strong class="kd iu"> <em class="mh">异步</em> </strong> <em class="mh"> </em>方法可能发生的情况。</p><p id="389e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">方法3: </strong>约翰点了披萨，打电话给鲍勃，邀请他来家里，然后让他的披萨外卖到了。但是这一次，他等到鲍勃来了，然后才打开电影。这就是<strong class="kd iu"> <em class="mh">反应式方法</em> </strong>的内容。你一直等到所有的异步动作都完成了(披萨送到了，Bob也到了)，然后继续下一步动作(打开GOT剧集)。</p><p id="3204" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有这个现实生活中的例子，但我不清楚同样的事情在技术世界中是如何工作的。</p><blockquote class="mi"><p id="f4c5" class="mj mk it bd ml mm mn mo mp mq mr ky dk translated">让我们理解上述第1点，即<em class="ms">同步方法</em></p></blockquote><p id="375f" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">例如，假设我们有一个部署在apache tomcat服务器上的web应用程序，它为用户提供一些内容。因此，对于每个用户请求，都会创建一个新的servlet线程，它会进行一些处理，然后调用数据库来查询一些内容。当数据库执行查询时，线程处于等待状态，可能有几毫秒。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/79229a23de26ce05bf68c22a871bab77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mW_1FvYAAa5vQps90atysw.png"/></div></div></figure><p id="248c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果我们的web应用程序开始获得更多数量的并发请求会怎么样。通常，servlet线程池大小为200。因此，如果有200个并发请求，那么我们将创建200个线程，每个请求一个线程，正如我们所见(<strong class="kd iu"> <em class="mh">每个请求一个线程模型</em> </strong>)，所有这200个线程将等待数据库操作完成。如果我们同时收到更多的请求，每个请求都需要等到前面的线程完成它们的任务。这是阻塞I/O —线程将进入阻塞状态。线程池的大小可以增加到适合任何数量(有硬件限制)，但这样也会带来上下文切换、缓存刷新等开销。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/d36cb480baa79330a7178de962079533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLEKZ-TP-VU2refwXmIoVg.png"/></div></div></figure><p id="3dac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同步处理请求的问题是，它会导致线程(执行繁重的任务)在响应发出之前运行很长时间。如果这种情况大规模发生，Servlet容器最终会耗尽线程。长时间运行的线程会导致线程饥饿。这是我们达到可伸缩性极限的地方。</p><p id="9cf6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可伸缩性限制包括耗尽内存或耗尽容器线程池。要创建可伸缩的web应用程序，您必须确保没有与请求相关联的线程处于空闲状态，这样容器就可以使用它们来处理新的请求。</p><p id="5a3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">线程池的大小可以增加到适合任何数量(有硬件限制)，但这样也会带来上下文切换、缓存刷新等开销。</p><p id="0cd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有没有更好的方法可以在不增加容器线程池大小的情况下处理更多的并发用户？是的，当然，我们可以使用异步方法来实现。</p><blockquote class="mi"><p id="723d" class="mj mk it bd ml mm mn mo mp mq mr ky dk translated">让我们理解第二点，即异步方法</p></blockquote><p id="7e7b" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">我们知道servlet容器是如何随着时间的推移而发展的，现在Servlet 3.0支持异步的、非阻塞的范例。回到同一个web应用程序多并发用户请求-响应场景，假设应用程序服务器接收到第一个新的用户请求，将会产生一个新的servlet线程来服务这个请求。然后，该线程将请求传递给另一个后台线程，后者将负责处理请求并将响应发送回客户端。初始线程一旦将请求传递给后台线程，就会返回到线程池，这样它就可以处理另一个请求了。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/c0c22adc92d6d4bcabd4267fb62bab9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQOdyX5X3sj375-72eEdrw.png"/></div></div></figure><p id="f36e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦数据库执行了查询并准备好响应，它将进行回调，同一线程或其他空闲线程将被分配来将该响应发送回最终用户。我们可以对所有线程使用类似的异步模型，避免在同步方法中遇到的问题。不再有线程切换，更高效地使用CPU，更多并发请求。</p><blockquote class="nf ng nh"><p id="7a8f" class="kb kc mh kd b ke kf kg kh ki kj kk kl ni kn ko kp nj kr ks kt nk kv kw kx ky im bi translated">异步HTTP的主要用例是客户端向服务器轮询延迟响应的情况。<br/>通常的例子是一个AJAX聊天客户端，你想从客户端和服务器端推/拉。<br/>这些场景让客户端长时间阻塞在服务器的套接字上，等待新消息。</p></blockquote><blockquote class="mi"><p id="35e4" class="mj mk it bd ml mm nl nm nn no np ky dk translated">让我们理解最后一点#3，即反应式方法</p></blockquote><p id="bf2a" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">反应式编程是异步编程的一种形式。<br/>异步编程只是意味着你正在编写的代码不会立即执行，就像命令式编程一样，而是在“未来的某个时刻”。</p><p id="67a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反应式编程的特点是异步代码的执行由要执行的数据的到达触发。不管代码是否准备好处理数据，数据都会到达。它被“推入”应用程序。</p><blockquote class="nf ng nh"><p id="7a21" class="kb kc mh kd b ke kf kg kh ki kj kk kl ni kn ko kp nj kr ks kt nk kv kw kx ky im bi translated">它是“推式”的。与之相反的是“拉式”。基于拉的代码不对到达的数据作出反应，相反，它准备好处理数据，只有在那时它才会请求数据。</p></blockquote><p id="e1ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在经历了同步、异步编程、阻塞和非阻塞I/O等一些非常重要的重载词汇之后，我希望我们都已经对“反应式”的含义有了基本的概念理解。</p><blockquote class="mi"><p id="f0df" class="mj mk it bd ml mm mn mo mp mq mr ky dk translated">当使用反应式编程时，数据流将成为应用程序的核心。事件、消息、呼叫甚至故障都将通过数据流来传递。使用反应式编程，您可以观察这些流，并在发出值时做出反应。</p></blockquote><p id="19df" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">因此，在您的代码中，您将创建任何内容和来自任何内容的数据流:点击事件、HTTP请求、摄取的消息、可用性通知、变量的更改、缓存事件、来自传感器的测量——实际上是任何可能更改或发生的内容。</p><p id="27ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在理解了什么是反应式编程之后，最重要的问题出现在脑海中，什么时候使用它，什么时候不使用它。让我试着回答这个问题。</p><p id="47a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">何时使用反应式编程方法？</strong></p><p id="4936" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当涉及到特定类型的<em class="mh">高负载</em> <strong class="kd iu"> </strong>或<strong class="kd iu"> <em class="mh">多用户应用</em> </strong> <em class="mh"> : </em>时，被动提供了一个优雅的解决方案</p><ul class=""><li id="5cf2" class="nq nr it kd b ke kf ki kj km ns kq nt ku nu ky nv nw nx ny bi translated"><em class="mh">社交网络、聊天</em></li><li id="5142" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated"><em class="mh">游戏</em></li><li id="7067" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated"><em class="mh">音频和视频应用</em></li></ul><p id="d585" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以及任何应用程序类型的下列组件:</p><ul class=""><li id="e91d" class="nq nr it kd b ke kf ki kj km ns kq nt ku nu ky nv nw nx ny bi translated"><em class="mh">服务于高度交互式UI元素的服务器代码</em></li><li id="0257" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated"><em class="mh">代理服务器、负载平衡器</em></li><li id="2c92" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated"><em class="mh">人工智能，机器学习</em></li><li id="48ab" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky nv nw nx ny bi translated"><em class="mh">实时数据流</em></li></ul><p id="4826" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">何时不使用反应式编程方法？</strong></p><p id="97e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，不要在没有必要的情况下尝试应用RP，例如，没有“实时”数据、高负载或大量用户同时更改数据的情况。</p><h1 id="9caa" class="oe lk it bd ll of og oh lo oi oj ok lr ol om on lu oo op oq lx or os ot ma ou bi translated"><strong class="ak">用Spring WebFlux构建反应式Rest API</strong></h1><p id="4ae4" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">Spring 5通过引入一个名为Spring WebFlux的全新反应式框架，拥抱了反应式编程范式。</p><p id="c3dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Spring WebFlux是一个自下而上的异步框架。它可以在使用Servlet 3.1非阻塞IO API的Servlet容器上运行，也可以在netty或undertow等其他异步运行时环境上运行。</p><p id="fb76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Spring WebFlux使用一个名为Reactor的库来提供反应式支持。Reactor是<a class="ae li" href="https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams" rel="noopener ugc nofollow" target="_blank">反应流</a>规范的一个实现。</p><p id="1b80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反应器提供两种主要类型，称为<code class="fe ov ow ox oy b">Flux</code>和<code class="fe ov ow ox oy b">Mono</code>。这两种类型都实现了由反应流提供的<code class="fe ov ow ox oy b">Publisher</code>接口。<code class="fe ov ow ox oy b">Flux</code>用来表示一个0流..n个元素和<code class="fe ov ow ox oy b">Mono</code>用来表示一个0的流..1个元素。</p><p id="1074" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Spring WebFlux支持两种类型的编程模型:</p><ol class=""><li id="89f4" class="nq nr it kd b ke kf ki kj km ns kq nt ku nu ky oz nw nx ny bi translated">传统的基于注释的模型，带有<code class="fe ov ow ox oy b">@Controller</code>、<code class="fe ov ow ox oy b">@RequestMapping</code>，以及您在Spring MVC中一直使用的其他注释。</li><li id="6f7d" class="nq nr it kd b ke nz ki oa km ob kq oc ku od ky oz nw nx ny bi translated">一个全新的基于Java 8 lambdas的函数式模型，用于路由和处理请求。</li></ol><p id="6ba8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经使用spring boot和spring webflux创建了一个简单的演示项目。你可以在<a class="ae li" href="https://github.com/jd268/reactor" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">我的github库</strong> </a>中找到完整的代码。请随意叉项目和工作。</p><p id="b8cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个小型的社交媒体应用程序。该应用程序将只有一个名为<code class="fe ov ow ox oy b">Post</code>的域模型。每个帖子都有一个<code class="fe ov ow ox oy b">text</code>和一个<code class="fe ov ow ox oy b">createdAt</code>字段。它使用mongodb和反应式MongoDB驱动程序作为我们的数据存储。它有REST APIs来创建、检索、更新和删除Tweet。所有的REST APIs都将是异步的，并将返回一个发布者。</p><p id="c3da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住:<strong class="kd iu"><em class="mh">权力越大，责任越大</em></strong>😎</p><p id="9279" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在做所有这些的时候，记住事情不会变得混乱，因为当你试图使用任何现代库如Java Rx、Java Spring Reactor、Spring WebFlux、BaconJS来实现反应式编程时，事情会变得有点复杂。反应式范式不同于命令式编程，反应式库提供了如此多的操作符和函数，以至于在编写代码时，你可能会觉得自己像个忍者，但很难理解和维护。所以请尽量保持事情简单。</p><h2 id="82de" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">包裹</h2><p id="89d8" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">“反应式编程”不再是一个时髦的词，但仍然没有明确的定义。我希望下一次你遇到这个术语时，它不会让你困惑，因为现在你知道它只是另一种编码风格，集中于有效管理异步数据流的变化。不要反应过度也很重要。在没有实际需求的情况下轻率地使用反应式方法只会用不必要的复杂性毁掉应用程序。</p></div></div>    
</body>
</html>