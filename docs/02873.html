<html>
<head>
<title>A guide to bash commands redirecting, chaining, and nesting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">bash命令重定向、链接和嵌套指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-bash-commands-redirecting-chaining-and-nesting-f0c752c62eca?source=collection_archive---------6-----------------------#2020-04-08">https://levelup.gitconnected.com/a-guide-to-bash-commands-redirecting-chaining-and-nesting-f0c752c62eca?source=collection_archive---------6-----------------------#2020-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/58dd270fefad81040aae3fc13eb4d41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFwZ-eQshhiocRROMr5bUw.jpeg"/></div></div></figure><p id="22c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你对如何使用shell命令有了一些基本的实践知识，你就开始倾向于在执行任务时节省一些时间。无论是在终端中还是使用像<a class="ae kw" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> jenkins </a>这样的自动化工具。在这篇文章中(或者这里的<a class="ae kw" href="https://youtu.be/UXM8KNTC3aY" rel="noopener ugc nofollow" target="_blank">视频版本</a>)，我们将讨论一些信号，也就是<strong class="ka ir"> <em class="kx">开关</em> </strong>，它们将帮助你做到这一点。</p><h1 id="2c3c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用&amp;&amp;和||链接命令</h1><p id="92dc" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">有时，您需要使用一行执行多个命令，而不是等待每个命令完成后再键入下一个命令。在这种情况下，你需要<strong class="ka ir"> &amp; &amp; </strong>开关。它执行由该开关链接的所有命令:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4047" class="mk kz iq mg b gy ml mm l mn mo">$ sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install tree</span></pre><p id="cae0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能还需要知道链接的命令将按照编写的顺序工作。除非其中一个命令返回错误，否则它不会停止。</p><p id="6807" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<strong class="ka ir"> || </strong>有点与此相反。只有当第一个命令失败时，它才执行第二个命令。</p><h1 id="38d3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用&gt;、&gt;&gt;和&lt;</h1><p id="e4ac" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">Redirecting is another useful tool for channeling a certain command output into a file. For instance, you may know the following command:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6238" class="mk kz iq mg b gy ml mm l mn mo">$ cp test.txt test2.txt</span></pre><p id="3a95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">The command above copies a file test.txt to another file test2.txt. You can perform this command using one of our new tools:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2a84" class="mk kz iq mg b gy ml mm l mn mo">$ cat test.txt &gt; test2.txt</span></pre><p id="6f6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">If you know the basics of shell commands, you probably know how <em class="kx"> cat </em>进行重定向有效。然而，&gt;符号不是将文件的输出打印到屏幕上，而是将输出重定向到一个新文件。如果文件已经创建，并且其中有一些您不想覆盖的数据，那么您可以使用以下命令追加数据:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="12fa" class="mk kz iq mg b gy ml mm l mn mo">$ cat test3.txt &gt;&gt; test2.txt</span></pre><p id="3f8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以基本上<strong class="ka ir"> &gt; </strong>的意思是创建和写入，而<strong class="ka ir"> &gt; &gt; </strong>的意思只是追加。太好了！现在只剩下一个与我们之前讨论的相反的东西，那就是输入开关(&lt;)。考虑以下git命令:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a451" class="mk kz iq mg b gy ml mm l mn mo">$ git commit -m 'test commit'</span></pre><p id="a587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们根据目前所学的内容再练习一会儿命令:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="396c" class="mk kz iq mg b gy ml mm l mn mo">$ echo "test commit" &gt; commit.txt &amp;&amp; git commit &lt; commit.txt</span></pre><p id="7d63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个命令只是创建一个名为commit.txt的新文件，并在其中写入“test commit”。第二个命令执行git命令git commit，该命令期待一条消息，我们可以通过刚刚创建的文件传递这条消息。</p><blockquote class="mp mq mr"><p id="991d" class="jy jz kx ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated">请注意，重定向比链接具有更高的优先级。因此，您可以这样阅读上面的命令:</p></blockquote><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3046" class="mk kz iq mg b gy ml mm l mn mo">$ ( echo "test commit" &gt; commit.txt ) &amp;&amp; ( git commit &lt; commit.txt )</span></pre><h1 id="65ff" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">管道带有|</h1><p id="1c15" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">使用管道可能对自动化非常有帮助。例如，很多时候当你在Debian/Ubuntu上安装一个包，在安装过程中需要你用y/n字母确认。所以你可以像下面这样传递一个强制的“y”字母:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="669f" class="mk kz iq mg b gy ml mm l mn mo">$ echo "y" | sudo apt install tree</span></pre><p id="92e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，当终端希望用户输入任何内容时，它会自动将通过管道<strong class="ka ir"> | </strong>传递的内容分配给终端，然后继续执行命令。</p><p id="5ec1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在执行第二个命令时，它不一定总是<em class="kx"> stdin </em>或用户输入。您可以将第一个命令的输出作为第二个命令中的参数传递，如下所示:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2023" class="mk kz iq mg b gy ml mm l mn mo">$ ls / | grep 'index.php'</span></pre><p id="6925" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，你传递一个根目录下的文件和目录列表，然后在其中搜索一个名为index.php<em class="kx">的文件。</em></p><h1 id="ebf3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用$(command)和` command `的嵌套命令</h1><p id="0caa" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">您可以在命令中嵌套命令，以便命令的输出可以是外部命令中的参数。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4484" class="mk kz iq mg b gy ml mm l mn mo">$ ls | cat $(grep -E ‘*.txt’ $1)</span></pre><p id="6999" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的命令将把所有的内容打印到屏幕上。txt文件存在于当前目录中。如果当前目录包含test1.txt和test2.txt，它相当于下面的命令:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2d21" class="mk kz iq mg b gy ml mm l mn mo">$ cat test1.txt test2.txt</span></pre><p id="94a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有前面的例子都是非常基础的，但是如果您每天都使用bash命令，特别是如果您执行许多DevOps任务，您会发现使用这些工具的非常有趣的方法。</p></div></div>    
</body>
</html>