<html>
<head>
<title>Producer-Consumer Problem Using Mutex in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中使用互斥体的生产者-消费者问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/producer-consumer-problem-using-mutex-in-c-764865c47483?source=collection_archive---------0-----------------------#2020-12-16">https://levelup.gitconnected.com/producer-consumer-problem-using-mutex-in-c-764865c47483?source=collection_archive---------0-----------------------#2020-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6adc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生产者-消费者问题是并发程序设计中一个经典的多线程同步问题。今天，我们将尝试用C++中的互斥体来解决这个问题。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/122fc6d2f108b016d15a09fb9d5d4708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YmxnoQS3iO4cqyLd-A0_Lg.png"/></div></div></figure><p id="fe15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程由三部分组成。首先，我们定义并分析测验的挑战部分。在第二部分，我们解释并学习在C++中使用互斥体。最后，我们应用互斥来完成我们的解决方案。</p><h1 id="5b6b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">问题陈述</strong></h1><p id="3ab2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">生产者-消费者问题是一组有许多变量的问题。在本教程中，我们关注最简单的版本:</p><ol class=""><li id="ae1b" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">系统有一个生产者线程和一个消费者线程。</li><li id="9639" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">生产者和消费者之间的缓冲区大小正好是1。换句话说，生产者会等消费者消费完产品再生产下一个。</li></ol><p id="2d98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关键点是生产者和消费者都需要访问共享资源(缓冲区),而不知道对方在做什么。我们必须正确地处理同步，以便生产者提供的数据不会丢失(生产者在消费者接受之前生成下一个产品)或重复(生产者在消费者获得下一个产品之前无法更新)。为了实现这一目标，理想的解决方案应该保证:</p><ol class=""><li id="545a" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">两个线程对数据的访问是互斥的。当一个正在访问数据时，另一个必须被阻止。</li><li id="904a" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">生产者和消费者活动以“乒乓”模式交替进行。在高效的实现中，消费者在生产者完成后立即启动，反之亦然。</li></ol><p id="d9d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在解决这个问题之前，我们需要研究如何使用互斥体。</p><h1 id="5557" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">互斥</strong></h1><p id="8739" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在多线程编程中，必须小心处理线程间的资源共享，因为可能会发生数据竞争。我们需要一种机制来保证对共享资源的访问是T4互斥的。互斥体就是为此而设计的。下面展示了C++中互斥体的常见用法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="0e46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">std::mutex(来自header <mutex>)被声明为全局变量，并在不同的线程间引用。每个线程可以触发lock()和unlock()来标记一个<em class="mq">临界段</em>的开始和结束。</mutex></p><p id="7d07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">临界区包括需要保护和避免并发访问的操作。在生产者-消费者的例子中，生产(写入共享资源)和消费(读取共享资源)的代码必须受到保护。</p><p id="0302" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现代C++中(从C++11开始)，对互斥体进行了增强。</p><h2 id="9c19" class="mr ky iq bd kz ms mt dn ld mu mv dp lh jy mw mx ll kc my mz lp kg na nb lt nc bi translated">将互斥与std::unique_lock一起使用</h2><p id="9ae8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">std::unique_lock是std::mutex的一个<a class="ae nd" href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii" rel="noopener ugc nofollow" target="_blank"> RAII </a>包装器。它获得了RAII的好处:在构造中自动锁定互斥体，在被析构时解锁，提供异常安全。开发人员也可以手动解锁/锁定它。下面是上面例子的重写版本，带有std::unique_lock:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不懂RAII，不要担心，不影响本教程。现在只需记住，将std::unique_lock与std::mutex一起使用是对原始互斥体的改进。在本文的其余部分，我们将遵循这种做法。</p><p id="2644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有锤子了，现在让我们来解决这个问题吧！</p><h1 id="a89f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">带有互斥的生产者-消费者解决方案</h1><p id="0218" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这段代码片段演示了解决方案的核心逻辑:(它排除了读者不必关注的部分:主函数、启动线程等。)</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6616" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该系统包含一个消费者函数和一个生产者函数，每个函数都执行一个无限循环来保持生成/接受数据。</p><p id="1e89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在顶部，声明了三个全局变量以便于线程之间的通信:</p><ol class=""><li id="12e2" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">g_mutex是互斥变量(第1行)。</li><li id="0057" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">g_ready是一个标志，用来通知另一个线程“我已经完成了我的工作”(第2行)。</li><li id="c431" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">g_data是用于存储数据的单一大小的缓冲区(第3行)。</li></ol><p id="01f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在执行期间，生成器执行:</p><ol class=""><li id="21b7" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">锁定临界区(第20行)。</li><li id="f86c" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">产生数据(第22行)。</li><li id="b1ab" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">将标志g_ready设置为真(第23行)。</li><li id="e770" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">解锁临界区(第24行)，期望消费者接受它并更改标志。</li><li id="4e80" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">继续等待，直到g_ready为假(第25行)。</li></ol><p id="e60c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和消费者行为:</p><ol class=""><li id="ab5f" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">等待g_ready为真(第8行),表示生产者完成了它的工作。</li><li id="71e0" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">锁定临界区(第11行)(超出范围时在第14行自动解锁)。</li><li id="72ab" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">消费数据。(第12行)。</li><li id="6ad3" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">将标志g_ready设置为false(第13行),通知其工作已完成。</li></ol><p id="b4ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意到我们必须在两端引入while循环来等待另一个线程。这种策略被称为<em class="mq">【忙等待】</em>。忙等待是低效的，因为它花费处理器时间做无用的活动，应该避免。我们可以在每个循环中添加一个sleep命令，以减少检查全局状态g_ready的频率。</p><p id="7619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是带有“休眠等待”的完整版本代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="01a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个程序每秒钟都会在生产者和消费者之间切换。</p><p id="363c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会发现这还不够完美，因为我们无法知道一般情况下生成/使用数据需要多长时间，线程应该“休眠”。设置随机等待时间不是最佳选择。我们将在<a class="ae nd" href="https://domiyanyue.medium.com/producer-consumer-problem-using-condition-variable-in-c-6c4d96efcbbc" rel="noopener">这个教程</a>中解决这个问题。</p><h1 id="df37" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h1><p id="d651" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在本文中，我们了解到:</p><ol class=""><li id="b8ae" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">生产者-消费者问题的挑战:线程间的同步/协调。</li><li id="44b5" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">在C++中使用std::mutex和std::unique_lock来保护线程中的临界区。</li><li id="88c9" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">用互斥体解决生产者-消费者问题。</li></ol><h1 id="7cab" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参考</h1><ol class=""><li id="0d7a" class="ma mb iq jp b jq lv ju lw jy ne kc nf kg ng kk mf mg mh mi bi translated"><a class="ae nd" href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" rel="noopener ugc nofollow" target="_blank">生产者-消费者问题</a></li><li id="9673" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">cppreference.com</li><li id="7cf8" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">cppreference.comT4【STD::unique _ lock】</li><li id="ecd9" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><a class="ae nd" href="https://en.cppreference.com/w/cpp/language/raii" rel="noopener ugc nofollow" target="_blank"> RAII </a></li></ol></div></div>    
</body>
</html>