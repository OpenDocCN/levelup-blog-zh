<html>
<head>
<title>How I built a version control system (VCS) using pure Go 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用pure Go构建一个版本控制系统(VCS)🚀</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-was-i-build-a-version-control-system-vcs-using-pure-go-83ec8ec5d4f4?source=collection_archive---------5-----------------------#2022-04-14">https://levelup.gitconnected.com/how-was-i-build-a-version-control-system-vcs-using-pure-go-83ec8ec5d4f4?source=collection_archive---------5-----------------------#2022-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="95ea" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">与软件创建相关的每一个工件都应该在版本控制之下。[1]</p><p id="fe74" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">VCS是一种跟踪文件随时间的修订(版本)的系统。[2]</p></blockquote><h1 id="732a" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">演示</h1><p id="265d" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated"><a class="ae lv" href="https://asciinema.org/a/487303" rel="noopener ugc nofollow" target="_blank">https://asciinema.org/a/487303</a></p><h1 id="9b0e" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">源代码</strong></h1><p id="65c1" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated"><a class="ae lv" href="https://github.com/Abdulsametileri/vX" rel="noopener ugc nofollow" target="_blank">https://github.com/Abdulsametileri/vX</a></p><h1 id="fb6c" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">动机</strong></h1><p id="dddc" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated">当我阅读一本漂亮的书[3]来更好地理解<a class="ae lv" href="https://en.wikipedia.org/wiki/Event-driven_architecture" rel="noopener ugc nofollow" target="_blank">事件驱动系统</a>和<a class="ae lv" href="https://microservices.io/patterns/data/event-sourcing.html" rel="noopener ugc nofollow" target="_blank">事件源</a>的想法时，我看到了一个很好的例子</p><p id="a0c1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">打个比方，我想象你正在构建一个像SVN或Git一样的版本控制系统。当用户第一次提交文件时，系统会将整个文件保存到磁盘。随后的提交反映了对该文件的更改，可能只保存增量，也就是说，只保存添加、更改或删除的行。然后，当用户签出某个版本时，系统打开版本0文件并应用所有后续增量，以便导出用户要求的版本。”[3] </p><p id="fdcc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">我只是想用这个策略实现一个VCS系统。于是我开始了一个叫做<a class="ae lv" href="https://github.com/Abdulsametileri/vX" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> vX </strong> </a>的实验性爱好项目。所有这些只是我三天的努力。😅</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="dc08" class="kp kq iq bd kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li mh lk ll lm bi translated">体系结构</h1><p id="613b" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated">首先，所有相关文件都在<code class="fe mi mj mk ml b">.vx</code>文件夹内。<em class="js">(Go工具会忽略任何名称以“_”或“.”开头的目录或文件)</em></p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="727f" class="mu kq iq ml b gy mv mw l mx my">.vx<br/>├── checkout<br/>│ ├── v1<br/>│ └── v2<br/>├── commit<br/>│ ├── v1<br/>│ └── v2<br/>├── staging-area.txt<br/>└── status.txt</span></pre><p id="aa54" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">v1, v2, .., vN </code>是提交版本。我将在这些文件夹的下一节中详细介绍。</p><p id="1840" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">checkout</code>是一个文件夹，包含了所有文件合并指定提交版本的结果。例如，<code class="fe mi mj mk ml b">checkout/v2</code>包括<code class="fe mi mj mk ml b">commit/v1</code> + <code class="fe mi mj mk ml b">commit/v2</code>的组合。</p><p id="cecb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">创建一个签出目录是合理的，因为“<em class="js">在UNIX世界中，一个好的实践是将应用程序的每个版本部署到一个新的目录中，并有一个指向当前版本的符号链接[1]”。目前，我还没有实现这个行为，但是它已经准备好了。</em></p><p id="4083" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">staging area</code>是将成为下一次提交的一部分的文件。在这种情况下，它只是一个带有<strong class="jt ir">仅追加</strong>模式的基本文本文件。因为我们在创作之后会做一些更新。例如，这个文件的一部分内容被格式化为<code class="fe mi mj mk ml b">file path | file modification time | File Status</code></p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="813e" class="mu kq iq ml b gy mv mw l mx my">"testdata/status.txt|2022-04-14 05:42:15|Created",<br/>"testdata/z.go|2022-04-14 05:11:04|Created",<br/>"README.md|2022-04-14 05:42:11|Created",<br/>"testdata/a1.txt|2022-04-13 06:58:03|Created",<br/>"README.md|2022-04-14 05:49:09|Updated",</span></pre><p id="595c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">例如，<code class="fe mi mj mk ml b">README.md</code>一种在提交操作前添加两次，修改时间和状态不同的文件。所以这个文件的最新状态是<code class="fe mi mj mk ml b">2022-04-14 05:49:09</code>的<code class="fe mi mj mk ml b">Updated</code>。这非常类似于<em class="js">事件采购的理念；也就是说，将数据库的更改表示为不可变的日志。[4].</em></p><p id="eaf1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">status</code>是一个持续跟踪所有文件的文本文件。成功提交后，我清除了<code class="fe mi mj mk ml b">staging area</code>的内容。所以我需要将文件持久地保存在版本控制系统下。</p><h2 id="fa8c" class="mu kq iq bd kr mz na dn kv nb nc dp kz lp nd ne ld lr nf ng lh lt nh ni ll nj bi translated">项目结构</h2><p id="e1bf" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated">I <a class="ae lv" href="https://github.com/spf13/cobra/blob/master/user_guide.md" rel="noopener ugc nofollow" target="_blank">遵循为任何基于<a class="ae lv" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank"> Cobra的应用</a>推荐的项目结构</a>。</p><p id="35e9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">我用的是<code class="fe mi mj mk ml b">testdata</code>目录。<em class="js">(Go工具会忽略任何名为</em> <code class="fe mi mj mk ml b"><em class="js">testdata</em></code> <em class="js">的目录，编译应用程序时会忽略这些脚本。)</em></p><h2 id="d39f" class="mu kq iq bd kr mz na dn kv nb nc dp kz lp nd ne ld lr nf ng lh lt nh ni ll nj bi translated">不支持的操作</h2><p id="aa73" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated">目前，我不知道如何检测删除的文件，所以我只是跟踪创建和修改的文件。此状态基于文件系统提供的文件修改时间。</p><p id="50e3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">目前，为了提供签出功能，实现仅存储更改并在需要时合并它们是一项非常困难的工作，所以我将这项任务推迟到另一个版本。经过一番研究，我找到了适合这份工作的rsync。因此，在每次提交操作时，我都将文件作为一个整体保存在临时区域。</p><h1 id="2616" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">命令</h1><p id="6701" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated"><code class="fe mi mj mk ml b">init</code>:创建目录和文件。</p><p id="2170" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">status</code>:读取暂存区文本文件并以适当的结构解析它们，并使用<a class="ae lv" href="https://github.com/olekukonko/tablewriter" rel="noopener ugc nofollow" target="_blank"> tablewriter </a>显示结果。如果你仔细看，我用<code class="fe mi mj mk ml b">io.Writer</code>接口创建了函数。在单元测试中，我很容易通过<code class="fe mi mj mk ml b">bytes.Buffer</code>并断言。我推荐阅读这篇关于围棋界面的伟大文章。</p><p id="bdfe" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">history</code>:显示所有提交。为了实现这个功能，我在每个提交目录中都保存了一个<code class="fe mi mj mk ml b">metadata.txt</code>文件。在这个目录中，我存储提交消息和用<code class="fe mi mj mk ml b">|</code>分隔的时间。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="f2d4" class="mu kq iq ml b gy mv mw l mx my">.<br/>├── v1<br/>│   ├── ..<br/>│   ├── metadata.txt<br/>└── v2<br/>├── ...<br/>└── metadata.txt</span></pre><p id="a4ad" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">add</code>:将指定的文件和目录添加到<code class="fe mi mj mk ml b">status.txt</code>和<code class="fe mi mj mk ml b">staging-area.txt</code>中。如前所述，为了显示一些文件的更新状态，我保存了文件<code class="fe mi mj mk ml b">status.txt</code>的最新状态，所以我每次都截断并写入新数据。<code class="fe mi mj mk ml b">staging-area.txt</code>是只追加数据，所以不需要做任何操作，只需追加新数据。重复数据没问题。成功提交后，我计算最新状态。</p><p id="302c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">commit</code>:读取<code class="fe mi mj mk ml b">staging-area.txt</code>文件，用特定提交目录(v1，v2)复制，操作完成后截断<code class="fe mi mj mk ml b">staging-area.txt</code>。</p><p id="df7b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">例如，让我们假设在v1提交中，用户添加了<code class="fe mi mj mk ml b">README.md</code> <code class="fe mi mj mk ml b">testdata/ </code>，而在v2提交中，用户添加了<code class="fe mi mj mk ml b">Makefile</code>。因此，提交文件夹将如下所示</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e675" class="mu kq iq ml b gy mv mw l mx my">├── commit<br/>│   ├── v1<br/>│   │   ├── README.md<br/>│   │   ├── metadata.txt<br/>│   │   └── testdata<br/>│   │       └── example<br/>│   │           ├── a1.txt<br/>│   │           ├── a2.txt<br/>│   │           ├── example.go<br/>│   │           ├── src<br/>│   │           │   └── hello.js<br/>│   │           └── z.go<br/>│   └── v2<br/>│       ├── Makefile<br/>│       └── metadata.txt</span></pre><p id="b9d1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated"><code class="fe mi mj mk ml b">checkout</code> : rsync从提交/到具有特定提交id的签出/目录。rsync也为我们合并了两个相同的文件。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="0f84" class="mu kq iq ml b gy mv mw l mx my">├── checkout<br/>│   ├── v1<br/>│   │   ├── README.md<br/>│   │   └── testdata<br/>│   │       └── example<br/>│   │           ├── a1.txt<br/>│   │           ├── a2.txt<br/>│   │           ├── example.go<br/>│   │           ├── src<br/>│   │           │   └── hello.js<br/>│   │           └── z.go</span></pre><h1 id="527f" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">源代码</h1><p id="30b4" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated"><a class="ae lv" href="https://github.com/Abdulsametileri/vX" rel="noopener ugc nofollow" target="_blank">https://github.com/Abdulsametileri/vX</a></p><h1 id="f35f" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参考</h1><p id="79ae" class="pw-post-body-paragraph jq jr iq jt b ju ln jw jx jy lo ka kb lp lq ke kf lr ls ki kj lt lu km kn ko ij bi translated">[1]Andrew Glover，Paul Duvall和Steve Matyas的《持续集成:提高软件质量和降低风险》</p><p id="8525" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">[2]谷歌的软件工程从编程中学到的经验</p><p id="e712" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">[3]Ben Stopford的《设计事件驱动系统》</p><p id="5a32" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lr kh ki kj lt kl km kn ko ij bi translated">[4]Martin Kleppmann的《理解流处理》</p></div></div>    
</body>
</html>