<html>
<head>
<title>Exploring Double Equality in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索科特林的双重平等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/double-equality-in-kotlin-f99392cba0e4?source=collection_archive---------3-----------------------#2019-10-25">https://levelup.gitconnected.com/double-equality-in-kotlin-f99392cba0e4?source=collection_archive---------3-----------------------#2019-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e59b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能知道我们可能不应该使用<code class="fe kl km kn ko b">==</code>来检查浮点等式，因为浮点表示并不精确。那么检查等式的最佳方法是什么呢？答案是，视情况而定。</p><p id="06ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，让我们先检查一下这是否确实是一个问题！让我们运行这段代码:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="1b93" class="kx ky iq ko b be kz la l lb lc">val a = .1 + .1<br/>val b = .2<br/>println("===Let's see the values")<br/>println("$a and $b")<br/>println("${a - b} and ${0.0}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="60b7" class="kx ky iq ko b be kz la l lb lc">===output===<br/>===Let's see the values<br/>0.2 and 0.2<br/>0.0 and 0.0</span></pre><p id="9f5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦哇！他们是平等的，没有问题，对不对？怎么样:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="3c05" class="kx ky iq ko b be kz la l lb lc">val a = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>val b = .8<br/><br/>println("===Let's see the values")<br/>println("$a and $b")<br/>println("${a - b} and ${0.0}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="784b" class="kx ky iq ko b be kz la l lb lc">===output===<br/>===Let's see the values<br/>0.7999999999999999 and 0.8<br/>-1.1102230246251565E-16 and 0.0</span></pre><p id="9fdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">啊。好了，这很简单，让我们谷歌一下如何做等式检查！</p><h1 id="774c" class="le ky iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">有些人比其他人更平等</h1><p id="79c3" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果您在Stackoverflow上搜索，您可能会找到一堆使用<code class="fe kl km kn ko b">==</code>的解决方案/替代方案:</p><ul class=""><li id="d42f" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">使用<code class="fe kl km kn ko b">Double.compareTo</code></li><li id="b7f3" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">使用<code class="fe kl km kn ko b">Double.compare</code></li><li id="2657" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">使用<code class="fe kl km kn ko b">Double.doubleToLongBits</code></li></ul><p id="6344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些都不是<em class="mu">完全</em>正确的，对于前2个，你可以从阅读<a class="ae mv" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" rel="noopener ugc nofollow" target="_blank">文档</a>中看到:<code class="fe kl km kn ko b">compareTo</code>和<code class="fe kl km kn ko b">compare</code>都返回“如果d1在数值上等于d2，则为0”，实际上使其与<code class="fe kl km kn ko b">==</code>相同。</p><p id="382f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次看看代码(为了完整起见，添加了<code class="fe kl km kn ko b">.equals()</code>):</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="90ae" class="kx ky iq ko b be kz la l lb lc">val a = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>val b = .8<br/><br/>println("===Let's see the values")<br/>println("$a and $b")<br/>println("${a - b} and ${0.0}")<br/><br/>println("===Let's compare")<br/>println("==: ${a == b}")<br/>println("equals: ${a.equals(b)}")<br/>println("Double.compareTo: ${a.compareTo(b) == 0}")<br/>println("Double.compare: ${java.lang.Double.compare(a, b) == 0}")<br/>println("Double.doubleToLongBits : ${java.lang.Double.doubleToLongBits(a) == java.lang.Double.doubleToLongBits(b)}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="1451" class="kx ky iq ko b be kz la l lb lc">===output===<br/>===Let's see the values<br/>0.7999999999999999 and 0.8<br/>-1.1102230246251565E-16 and 0.0<br/>===Let's compare<br/>==: false<br/>equals: false<br/>Double.compareTo: false<br/>Double.compare: false<br/>Double.doubleToLongBits : false</span></pre><figure class="kp kq kr ks gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mw"><img src="../Images/a475a33ff69a0b90b56bc0689892f370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyEL27_DRQ8T-NjQdNs37g@2x.jpeg"/></div></div></figure><h2 id="7026" class="ne ky iq bd lf nf ng dn lj nh ni dp ln jy nj nk lr kc nl nm lv kg nn no lz np bi translated">边注</h2><p id="3cfa" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">浮点等式是棘手的，不是因为不精确表示本身，而是因为对不精确表示“相加”所做的算术。相反，如果我们从两个相同的浮点值开始，不进行算术运算，或者如果完成的算术运算是相同的，那么使用<code class="fe kl km kn ko b">==</code>进行相等比较是可行的。</p><p id="4083" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果我们从<code class="fe kl km kn ko b">0.8</code>开始:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="131f" class="kx ky iq ko b be kz la l lb lc">val a = .8<br/>val b = .8<br/>&lt;...same comparison code as above&gt;</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="35ac" class="kx ky iq ko b be kz la l lb lc">===output===<br/>===Let's see the values<br/>0.8 and 0.8<br/>0.0 and 0.0<br/>===Let's compare<br/>==: true<br/>equals: true<br/>Double.compareTo: true<br/>Double.compare: true<br/>Double.doubleToLongBits : true</span></pre><p id="3850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者如果我们有相同的算术:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="dadc" class="kx ky iq ko b be kz la l lb lc">val a = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>val b = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>&lt;...same comparison code as above&gt;</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="47b1" class="kx ky iq ko b be kz la l lb lc">===output===<br/>===Let's see the values<br/>0.7999999999999999 and 0.7999999999999999<br/>0.0 and 0.0<br/>===Let's compare<br/>==: true<br/>equals: true<br/>Double.compareTo: true<br/>Double.compare: true<br/>Double.doubleToLongBits : true</span></pre><h1 id="4aa6" class="le ky iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">如何检查等式？</h1><p id="3865" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">推荐的方法是使用一个阈值，它是一个足够小的值，如果<code class="fe kl km kn ko b">a</code>和<code class="fe kl km kn ko b">b</code>只相差这个量，我们可以安全而实际地说它们相等。<code class="fe kl km kn ko b">threshold</code>又称<code class="fe kl km kn ko b">epsilon</code>或<code class="fe kl km kn ko b">delta</code>。通常的公式是:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="1007" class="kx ky iq ko b be kz la l lb lc">abs(a - b) &lt; delta  // pseudocode</span></pre><p id="8a92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们稍后将讨论如何选择<code class="fe kl km kn ko b">delta</code>。假设我们选择了<code class="fe kl km kn ko b">0.000001</code>，在Kotlin中，我们可以在<code class="fe kl km kn ko b">Double</code>上编写一个扩展函数并使用它:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="ed46" class="kx ky iq ko b be kz la l lb lc">fun Double.equalsDelta(other: Double) = abs(this - other) &lt; 0.000001<br/><br/>val a = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>val b = .8<br/><br/>println("===Let's see the values")<br/>println("$a and $b")<br/>println("${a - b} and ${0.0}")<br/>println("===Let's compare with delta")<br/>println("a.equalsDelta(b): ${a.equalsDelta(b)}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="5d16" class="kx ky iq ko b be kz la l lb lc">===output===<br/>===Let's see the values<br/>0.7999999999999999 and 0.8<br/>-1.1102230246251565E-16 and 0.0<br/>===Let's compare with delta<br/>a.equalsDelta(b): true</span></pre><p id="ad48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">IBM的另一个可能的公式是这样的:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="14a5" class="kx ky iq ko b be kz la l lb lc">abs(a/b - 1) &lt; delta</span></pre><p id="aace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这比<code class="fe kl km kn ko b">(a — b)</code>方法更稳健，因为取两个数字的比值“抵消”了它们的比例对delta的影响。(也就是说，如果a和b真的很小，那么与<code class="fe kl km kn ko b">(a — b)</code>相比，delta最终可能会非常大。在科特林:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="b1ef" class="kx ky iq ko b be kz la l lb lc">fun Double.equalsDelta(other: Double) = abs(this/other - 1) &lt; 0.000001</span></pre><h2 id="e831" class="ne ky iq bd lf nf ng dn lj nh ni dp ln jy nj nk lr kc nl nm lv kg nn no lz np bi translated">达美怎么选？</h2><p id="52eb" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果我们知道操作数的小数位数，我们可以设置一个足够小的<strong class="jp ir">固定增量</strong>。</p><p id="8c47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们不知道比例，那么一种方法是使用<strong class="jp ir">相对增量</strong>。相对增量是根据操作数缩放的固定增量。这实际上非常类似于<code class="fe kl km kn ko b">abs(a/b — 1)</code>方法，它考虑了操作数的规模。一个简单的实现可以是:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="6e47" class="kx ky iq ko b be kz la l lb lc">val delta = max(abs(a), abs(b)) * fixedDelta  // pseudocode<br/><br/>fun Double.equalsDelta(other: Double) = abs(this - other) &lt; 0.000001 * max(abs(this), abs(other))</span></pre><p id="e505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种方法是从<code class="fe kl km kn ko b">ulp</code> ( <a class="ae mv" href="https://en.wikipedia.org/wiki/Unit_in_the_last_place" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">最小精度单位</strong> </a>)计算增量。简而言之，<code class="fe kl km kn ko b">ulp</code>是一个给定数字和它相邻的更大数字之间的差距。Kotlin(通过Java)有一个方法让<a class="ae mv" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#ulp-double-" rel="noopener ugc nofollow" target="_blank">返回一个数字的ulp</a>:<code class="fe kl km kn ko b">Math.ulp(double)</code>。我们可以根据操作数的<code class="fe kl km kn ko b">ulp</code>设置增量。例如，基于此<a class="ae mv" href="https://stackoverflow.com/a/29900125/4212710" rel="noopener ugc nofollow" target="_blank">回答</a> ( <code class="fe kl km kn ko b">steps</code>指我们感到舒适的<code class="fe kl km kn ko b">ulp</code>“步骤”的数量):</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="cfba" class="kx ky iq ko b be kz la l lb lc">val delta = max(Math.ulp(a), Math.ulp(b)) * steps // pseudocode<br/><br/>fun Double.equalsDelta(other: Double) = abs(this - other) &lt; max(Math.ulp(this), Math.ulp(other)) * 2</span></pre><h1 id="98cd" class="le ky iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">其他对比呢？</h1><p id="7bf5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">像<code class="fe kl km kn ko b">&lt;</code>和<code class="fe kl km kn ko b">&gt;</code>这样的比较一般不是问题，因为通常在这些情况下我们并不在乎数字完全相同，只在乎一个比另一个少/多。</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="64bc" class="kx ky iq ko b be kz la l lb lc">val x = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>val y = .7999<br/>println("$x and $y")<br/>println("${x &gt; y}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="0faf" class="kx ky iq ko b be kz la l lb lc">===output===<br/>0.7999999999999999 and 0.7999<br/>true</span></pre><p id="e591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而<code class="fe kl km kn ko b">≤</code>和<code class="fe kl km kn ko b">≥</code>有点棘手。</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="80bc" class="kx ky iq ko b be kz la l lb lc">val x = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>val y = .8<br/>println("$x and $y")<br/>println("${x &gt;= y}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="6cab" class="kx ky iq ko b be kz la l lb lc">===output===<br/>0.7999999999999999 and 0.8<br/>false</span></pre><p id="c314" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能是也可能不是一个问题。经验法则是，如果<code class="fe kl km kn ko b">y</code>作为x的“极限”,那么<code class="fe kl km kn ko b">≥</code>的含义类似于<code class="fe kl km kn ko b">&gt;</code>,所以这不是一个真正的问题。然而，如果我们经常遇到<code class="fe kl km kn ko b">x</code>和<code class="fe kl km kn ko b">y</code>确实相等的情况(并且我们需要知道它们相等)，那么推荐使用<code class="fe kl km kn ko b">(a &gt; b) || (a == b) </code>而不是<code class="fe kl km kn ko b">a ≥ b</code>，使用上述方法之一来实现<code class="fe kl km kn ko b">==</code>。</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="602c" class="kx ky iq ko b be kz la l lb lc">fun Double.ge(other: Double) = this &gt; other || this.equalsDeltaFixed(other)<br/><br/>val x = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>val y = .8<br/>println("$x and $y")<br/>println("&gt;=: ${x &gt;= y}")<br/>println("ge(): ${x.ge(y)}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="c2ed" class="kx ky iq ko b be kz la l lb lc">===output===<br/>0.7999999999999999 and 0.8<br/>&gt;=: false<br/>ge(): true</span></pre><h2 id="e3e5" class="ne ky iq bd lf nf ng dn lj nh ni dp ln jy nj nk lr kc nl nm lv kg nn no lz np bi translated">边注</h2><p id="eb0c" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">我们可以使用Kotlin的<a class="ae mv" href="https://kotlinlang.org/docs/reference/functions.html#infix-notation" rel="noopener ugc nofollow" target="_blank">中缀符号</a>来创建流畅的方法:</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="454c" class="kx ky iq ko b be kz la l lb lc">infix fun Double.eq(other: Double) = abs(this - other) &lt; 0.000001<br/>infix fun Double.ge(other: Double) = this &gt; other || this.eq(other)<br/><br/>val x = .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1<br/>val y = .8<br/>println("$x and $y")<br/>println("==: ${x == y}")<br/>println("eq: ${x eq y}")<br/>println("&gt;=: ${x &gt;= y}")<br/>println("ge: ${x ge y}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="bf2d" class="kx ky iq ko b be kz la l lb lc">===output===<br/>0.7999999999999999 and 0.8<br/>==: false<br/>eq: true<br/>&gt;=: false<br/>ge: true</span></pre><h1 id="d748" class="le ky iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">有其他选择吗？</h1><p id="12ef" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果我们不太依赖于<code class="fe kl km kn ko b">Double</code>，当涉及到精确的数量时，使用<code class="fe kl km kn ko b">BigDecimal</code>通常是更好的方法。如果可能，在进行算术运算之前，使用<code class="fe kl km kn ko b">BigDecimal</code>和/或从<code class="fe kl km kn ko b">Double</code>转换。(<em class="mu">当然，</em> <code class="fe kl km kn ko b">BigDecimal</code> <em class="mu">也有自己的告诫</em>)</p><pre class="kp kq kr ks gt kt ko ku bn kv kw bi"><span id="f109" class="kx ky iq ko b be kz la l lb lc">val _1 = BigDecimal.valueOf(.1)<br/>val a = _1.add(_1).add(_1).add(_1).add(_1).add(_1).add(_1).add(_1)<br/>val b = BigDecimal.valueOf(.8)<br/>println("$_1 and $a and $b")<br/>println("compareTo: ${a.compareTo(b) == 0}")</span></pre><pre class="ld kt ko ku bn kv kw bi"><span id="3afe" class="kx ky iq ko b be kz la l lb lc">===output===<br/>0.1 and 0.8 and 0.8<br/>compareTo: true</span></pre><h1 id="8448" class="le ky iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">参考</h1><ul class=""><li id="66a5" class="mg mh iq jp b jq mb ju mc jy nq kc nr kg ns kk ml mm mn mo bi translated"><a class="ae mv" href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/" rel="noopener ugc nofollow" target="_blank">https://randomascii . WordPress . com/2012/02/25/comparing-floating-point-numbers-2012-edition/</a></li><li id="e40c" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">【jessesquires.com/blog/floating-point-swift-ulp-and-epsilon】</li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h2 id="b4e3" class="ne ky iq bd lf nf ng dn lj nh ni dp ln jy nj nk lr kc nl nm lv kg nn no lz np bi translated">你可能喜欢的其他故事</h2><ul class=""><li id="2fda" class="mg mh iq jp b jq mb ju mc jy nq kc nr kg ns kk ml mm mn mo bi translated"><a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/write-fluent-code-in-kotlin-133647f2a869">用Kotlin写流畅的代码</a></li><li id="4247" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/opinion-software-estimates-are-a-two-sided-relationship-6247108ace41">软件评估是一种双边关系</a></li><li id="bb07" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mv" href="https://medium.com/dont-code-me-on-that/use-java-nullability-annotations-to-facilitate-conversion-to-kotlin-7196f0cee9e9" rel="noopener">使用Java可空性注释来简化到Kotlin的转换</a></li></ul></div></div>    
</body>
</html>