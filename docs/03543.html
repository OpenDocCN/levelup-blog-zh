<html>
<head>
<title>5 JavaScript Tips I Learned From Vue Source Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我从Vue源代码中学到的5个JavaScript技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-javascript-tips-i-learned-from-vue-source-code-6095df4e9bc1?source=collection_archive---------2-----------------------#2020-05-15">https://levelup.gitconnected.com/5-javascript-tips-i-learned-from-vue-source-code-6095df4e9bc1?source=collection_archive---------2-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f994" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从流行的JS框架的源代码中学习JavaScript。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4930f15c3e96278c13ce4441acdbe02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jn9YOcEjFrEmvywx"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道，阅读知名框架的源代码可以有效提高编程水平。最近看了vue2.x源码，学到了很多JS相关的小技巧。然后我写了这篇文章，希望对你有帮助。</p><h1 id="8269" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.确定任何对象的具体类型</h1><p id="c874" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">众所周知，JavaScript中有六种原语数据类型(Boolean、Number、String、Null、Undefined、Symbol)和一种object数据类型。但是你知道对象数据类型可以细分成很多种子类型吗？对象可以是数组、函数、映射等。如果我们想得到对象的具体类型，应该怎么做？</p><p id="dd17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，让我们看看另一个问题:</p><blockquote class="ms"><p id="83a8" class="mt mu it bd mv mw mx my mz na nb lu dk translated"><code class="fe nc nd ne nf b">Object.prototype.toString.call(arg)</code>和<code class="fe nc nd ne nf b">String(arg)</code>有什么区别？</p></blockquote><p id="42ca" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这两个表达式都试图将参数转换为字符串，但它们之间有所不同。</p><p id="0864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">String(arg)</code>会尝试调用<code class="fe nc nd ne nf b">arg.toString()</code>或者<code class="fe nc nd ne nf b">arg.valueOf()</code>，所以如果arg或者arg原型重写这两个方法，<code class="fe nc nd ne nf b">Object.prototype.toString.call(arg)</code>和<code class="fe nc nd ne nf b">String(arg) </code>会得到不同的结果。</p><pre class="kj kk kl km gt nl nf nm nn aw no bi"><span id="8a78" class="np lw it nf b gy nq nr l ns nt">const _toString = Object.prototype.toString<br/>var obj = {}</span><span id="97ea" class="np lw it nf b gy nu nr l ns nt">obj.toString()  // [object Object]<br/>_toString.call(obj) // [object Object]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/a21fa03e571b1057a9c3033d3b577469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CIhg_IgVLtzyZeGYq10jA.png"/></div></div></figure><p id="a28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<code class="fe nc nd ne nf b">String(arg)</code>和<code class="fe nc nd ne nf b">Object.prototype.toString.call(arg)</code>的作用是一样的。</p><pre class="kj kk kl km gt nl nf nm nn aw no bi"><span id="f5d6" class="np lw it nf b gy nq nr l ns nt">const _toString = Object.prototype.toString<br/>var obj = {}</span><span id="481d" class="np lw it nf b gy nu nr l ns nt">obj.toString = () =&gt; '111'</span><span id="0df0" class="np lw it nf b gy nu nr l ns nt">obj.toString()  // 111<br/>_toString.call(obj) // [object Object]</span><span id="4670" class="np lw it nf b gy nu nr l ns nt">/hello/.toString() // /hello/<br/>_toString.call(/hello/) // [object RegExp]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/8cd06027a8a2cce62c8378afdcb692f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14oYOdt-A7SdJ1hVJyCOYA.png"/></div></div></figure><p id="e5a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<code class="fe nc nd ne nf b">String(arg)</code>和<code class="fe nc nd ne nf b">Object.prototype.toString.call(arg)</code>会有不同的结果。</p><p id="2552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ECMAScript具有以下规则:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/79e0f00fe37c8f4feaa86f202d08c086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MyvcNd6NioOEI5Bb.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自EcmaScript</figcaption></figure><p id="3cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于不同的对象，调用<em class="ny">object . prototype . tostring()</em>时会返回不同的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/3102855d3ebc257788031d476254238e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*31b7oZHjI8Lmiw5h.png"/></div></div></figure><p id="2c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且<em class="ny">object . prototype . tostring()</em>的返回值始终是'<strong class="lb iu"> <em class="ny">【对象</em></strong><em class="ny">'</em>+'<strong class="lb iu"><em class="ny">标签</em></strong><em class="ny">'</em>+'<strong class="lb iu"><em class="ny">]</em></strong>'。如果只想要中间的<em class="ny">标签</em>，可以通过正则表达式或者<em class="ny"> String.prototype.slice()删除两边的字符。</em></p><pre class="kj kk kl km gt nl nf nm nn aw no bi"><span id="2481" class="np lw it nf b gy nq nr l ns nt">function toRawType (value) {<br/>    const _toString = Object.prototype.toString<br/>    return _toString.call(value).slice(8, -1)<br/>}</span><span id="8f66" class="np lw it nf b gy nu nr l ns nt">toRawType(null) // "Null"<br/>toRawType(/sdfsd/) //"RegExp"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/eabdcda4143e73daa88306a18e27425e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4nI5ejlHGBXS4-90aCnng.png"/></div></div></figure><p id="919b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过上面的函数，我们可以得到一个JavaScript变量的类型。</p><p id="d18e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在以下位置找到该函数的Vue源代码:</p><div class="ob oc gp gr od oe"><a href="https://github.com/vuejs/vue/blob/6fe07ebf5ab3fea1860c59fe7cdd2ec1b760f9b0/src/shared/util.js" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">vuejs/vue</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">🖖 Vue.js是一个渐进的、可增量采用的JavaScript框架，用于在web上构建UI。- vuejs/vue</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><p id="d7ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(第62行)</p><h1 id="77ad" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.缓存函数计算结果</h1><p id="7e7f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果有这样的功能:</p><pre class="kj kk kl km gt nl nf nm nn aw no bi"><span id="0eb8" class="np lw it nf b gy nq nr l ns nt">function computed(str) {    <br/>    // Suppose the calculation in the funtion is very time consuming        <br/>    console.log('2000s have passed')<br/>    return 'a result'<br/>}</span></pre><p id="d667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要缓存函数操作的结果。以后调用时，如果参数相同，就不再执行该函数，而是直接返回缓存中的结果。我们能做什么？</p><p id="01e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写一个<code class="fe nc nd ne nf b">cached</code>函数来包装我们的目标函数。这个缓存函数将目标函数作为参数，并返回一个新的包装函数。在<code class="fe nc nd ne nf b">cached</code>函数中，我们可以用<code class="fe nc nd ne nf b">Object</code>或<code class="fe nc nd ne nf b">Map</code>缓存前一次函数调用的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="f9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/d87fe9ec1036e46adf620e0615b1d885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iLTBkgsiO05dd_XZ.png"/></div></div></figure><p id="833e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在以下位置找到该函数的Vue源代码:</p><div class="ob oc gp gr od oe"><a href="https://github.com/vuejs/vue/blob/6fe07ebf5ab3fea1860c59fe7cdd2ec1b760f9b0/src/shared/util.js" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">vuejs/vue</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">🖖 Vue.js是一个渐进的、可增量采用的JavaScript框架，用于在web上构建UI。- vuejs/vue</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><p id="e5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(第153行)</p><h1 id="d954" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.将hello-world样式转换为helloWorld样式</h1><p id="71fb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们需要在大型项目上合作时，通用的代码风格是必要的。有些人可能习惯写<code class="fe nc nd ne nf b">helloWorld</code>，有些人可能习惯写<code class="fe nc nd ne nf b">hello-world</code>。为了解决这个问题，我们可以写一个将<code class="fe nc nd ne nf b">hello-world</code>统一转换为<code class="fe nc nd ne nf b">helloWorld</code>的函数。</p><pre class="kj kk kl km gt nl nf nm nn aw no bi"><span id="eb42" class="np lw it nf b gy nq nr l ns nt">const camelizeRE = /-(\w)/g</span><span id="b6a7" class="np lw it nf b gy nu nr l ns nt">const camelize = cached((str) =&gt; {<br/>  return str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : '')<br/>})</span><span id="f721" class="np lw it nf b gy nu nr l ns nt">camelize('hello-world')<br/>// "helloWorld"</span></pre><div class="ob oc gp gr od oe"><a href="https://github.com/vuejs/vue/blob/6fe07ebf5ab3fea1860c59fe7cdd2ec1b760f9b0/src/shared/util.js" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">vuejs/vue</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">🖖 Vue.js是一个渐进的、可增量采用的JavaScript框架，用于在web上构建UI。- vuejs/vue</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><p id="f0bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(第164行)</p><h1 id="a119" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.确定JS运行环境</h1><p id="6292" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">今天，随着前端的快速发展，我们的JavaScript代码可能会在不同的运行时环境中执行。为了更好地适应各种运行时环境，我们需要确定当前代码正在哪个运行时环境中执行。我们来看看Vue是如何决定运行环境的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="3fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在以下位置找到该函数的Vue源代码:</p><div class="ob oc gp gr od oe"><a href="https://github.com/vuejs/vue/blob/dev/src/core/util/env.js" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">vuejs/vue</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">🖖 Vue.js是一个渐进的、可增量采用的JavaScript框架，用于在web上构建UI。- vuejs/vue</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="ow l op oq or on os ks oe"/></div></div></a></div><p id="ecaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(第6行)</p><h1 id="7eca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.确定函数是本机的还是用户定义的</h1><p id="0f94" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们知道，JavaScript中有两种类型的函数，一种由主机环境提供，另一种由用户自定义。这两个函数在转换为字符串时会有不同的结果。</p><pre class="kj kk kl km gt nl nf nm nn aw no bi"><span id="642d" class="np lw it nf b gy nq nr l ns nt">Array.isArray.toString() // "function isArray() { [native code] }"</span><span id="dd0c" class="np lw it nf b gy nu nr l ns nt"><strong class="nf iu">function</strong> <strong class="nf iu">fn</strong>(){} <br/>fn.toString() // "function fn(){}"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/782bb009ce77acba34c9d53e337f3c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1AQ0Hn6u-R-kMM9dAHsjA.png"/></div></div></figure><p id="88ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本机函数toString的结果总是采用<code class="fe nc nd ne nf b">function fnName() { [native code] }</code>格式。我们可以用这个来区分它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="f135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在以下位置找到该函数的Vue源代码:</p><div class="ob oc gp gr od oe"><a href="https://github.com/vuejs/vue/blob/a9a303009a4267b7f12b956741b4e34dfdc6566f/src/core/util/env.js" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">vuejs/vue</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">🖖 Vue.js是一个渐进的、可增量采用的JavaScript框架，用于在web上构建UI。- vuejs/vue</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oy l op oq or on os ks oe"/></div></div></a></div><p id="0bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(第58行)</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><h1 id="e8b7" class="lv lw it bd lx ly pg ma mb mc ph me mf jz pi ka mh kc pj kd mj kf pk kg ml mm bi translated">相关文章</h1><div class="ob oc gp gr od oe"><a href="https://medium.com/javascript-in-plain-english/learn-javascript-from-vue-source-code-d9d8516ea9c4" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">从Vue源代码学习JavaScript</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">阅读这篇文章不需要Vue的背景知识。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="pl l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>