<html>
<head>
<title>Angular — GitLab pipeline with AWS S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular —带AWS S3的GitLab管道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-gitlab-pipeline-with-aws-s3-9e4ae887ff2b?source=collection_archive---------3-----------------------#2022-08-14">https://levelup.gitconnected.com/angular-gitlab-pipeline-with-aws-s3-9e4ae887ff2b?source=collection_archive---------3-----------------------#2022-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设计您自己的管道，将工件直接交付到您的AWS环境中。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/13ec2acb1b2c4f465a4e3dc407ad6b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*amlhff7QYpjDYpdW"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@selimarda?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Selim Arda </a>拍摄的照片</figcaption></figure><p id="58d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用像Git这样的版本控制被认为是一种很好的实践。Git存储库有助于将代码保存在一个中心位置，并有助于在同一个代码库上与多个开发人员合作。此外，它使您能够为提交到存储库中的变更建立一个自动化的部署。在本文中，我将简要解释持续集成和部署(CI/CD)的概念，并通过展示如何使用GitLab管道将Angular应用程序部署到亚马逊S3来演示这一过程。</p><h2 id="bce6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">连续累计</h2><p id="c7e7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当使用Git存储库(例如GitLab)时，您可以设置脚本，在每次有人向存储库推送更改时自动构建和测试您的应用程序。这有助于确保高质量并避免应用程序中的错误。</p><p id="0aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种实践被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Continuous_integration" rel="noopener ugc nofollow" target="_blank">持续集成</a>。提交给应用程序的每个变更都是自动地、持续地构建和测试的。该过程验证所有测试是否成功完成，并确保遵守您为应用程序设置的任何策略和标准。</p><h2 id="d36f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">持续部署</h2><p id="cd95" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Continuous_deployment" rel="noopener ugc nofollow" target="_blank">持续部署</a>扩展持续集成。使用这种方法，应用程序将在成功集成后自动部署，无需人工干预。</p><h2 id="1d96" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">GitLab CI/CD</h2><p id="152f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我们将使用GitLab创建一个CI/CD管道，Git lab是一个流行的Git存储库，它提供了很好的工具来将管道完全集成到您的项目中，而不需要外部服务。</p><p id="5823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要为GitLab项目定义管道，您需要做的就是创建一个<a class="ae ky" href="https://docs.gitlab.com/ee/ci/yaml/" rel="noopener ugc nofollow" target="_blank"> gitlab-ci.yml </a>文件。在这个文件中，定义了管道的各个步骤。但是，在我们深入讨论这个细节之前，让我们先来看看我们将在本文中创建的最终管道:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/415ce5b7e8fa38d7e708d8d683656212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBb3e22oYIX6ePgofygtCg.png"/></div></div></figure><p id="8bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例将包括以下四个阶段，</p><ul class=""><li id="5936" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><strong class="lb iu">依赖关系</strong> —在此阶段，管道将运行npm install并缓存node_modules以在阶段之间共享。</li><li id="abc2" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu">质量</strong> — <strong class="lb iu"> </strong>覆盖单元测试和此阶段角度应用的皮棉。</li><li id="96ee" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu">组装</strong> —构建用于生产的angular应用程序，并将dist/folder内容标记为最终发布的工件。</li><li id="1c4c" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu">部署</strong>——将最终的神器转移到AWS S3</li></ul><p id="ddc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ni">当然，这只是一个基本的例子，您应该根据自己的需求改进您的管道。</em></p><h1 id="790e" class="nj lw it bd lx nk nl nm ma nn no np md jz nq ka mg kc nr kd mj kf ns kg mm nt bi translated">管道</h1><p id="ffd1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们开始创建新的渠道。我们将经历上面提到的四个阶段。要定义阶段，只需将以下内容添加到gitlab-ci.yml文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="95a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个阶段可以包含任意数量的作业来执行命令。</p><h2 id="7696" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">依赖阶段</h2><p id="7a7a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">好的，因为我们没有将node_modules文件夹提交到我们的git存储库，所以我们使用第一个阶段通过npm install来安装模块。我们可以为该阶段定义一个作业，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们设置想要使用的<strong class="lb iu">图像</strong>。在这种情况下，我们需要<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>来运行npm命令。只需从<a class="ae ky" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>中选择一个，它将从gitlab runner机器中动态分配。我们以<strong class="lb iu">节点:18-阿尔卑斯山</strong>图像为例。</p><p id="2871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们指定应该执行该步骤的<strong class="lb iu">阶段</strong>。</p><p id="4a37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们使用<strong class="lb iu">脚本</strong>来指定跑步者要执行的命令。这是每个工作的必需关键字。这个任务的命令是<code class="fe nw nx ny nz b">npm ci</code>，它类似于<code class="fe nw nx ny nz b">npm install</code>，除了它意味着在自动化环境中使用，比如测试平台、持续集成和部署，在这些环境中，您想要确保您正在对您的依赖项进行干净的安装。</p><p id="4ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们添加了<strong class="lb iu">缓存</strong>关键字来将node_modules保存在缓存中，然后只在package-lock.json文件发生变化时重新创建它。</p><h2 id="ac09" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">质量阶段</h2><p id="47a2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来是分析代码库的阶段。这里，我们将为此定义两个作业。一方面，执行应用程序的单元测试，另一方面，检查林挺规则。此外，还可以在此添加SonarQube扫描作业。</p><p id="e323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先看看单元测试的工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d6b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用与之前相同的<strong class="lb iu">图像</strong>并再次定义<strong class="lb iu">阶段</strong>。然后，我们有了这个作业的新关键字— <strong class="lb iu">需求</strong>，我们可以用它来表达依赖关系。在这种情况下，该作业应该在成功的<strong class="lb iu">安装</strong>作业之后运行。</p><p id="7b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们指定运行测试所需的命令。</p><p id="1569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了共享前期设置的缓存node_modules，我们再次添加了<strong class="lb iu">缓存</strong>关键字。但是，这一次将策略设置为“拉”，因为我们只想下载缓存的文件。</p><p id="3916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来看看棉绒。在这里，我们可以验证为我们的项目定义的林挺规则。作业的设置与测试基本相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="673d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">组装阶段</h2><p id="dfd4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这个阶段，我们构建我们的应用程序并生成/dist文件夹。将以下内容添加到gitlab-ci.yml中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="553e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这个任务与前面的任务非常相似，我们只是运行一个不同的命令。这次是<code class="fe nw nx ny nz b">npm run build</code>，它执行package.json中定义的构建脚本。</p><p id="6518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，最后阶段更有趣一些。</p><h2 id="8a7e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">部署阶段</h2><p id="4716" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">正如开始提到的，我们希望将应用程序部署到AWS。但是，本文并不涉及配置AWS服务(如S3 ),而是只关注现有AWS基础设施的部署。</p><p id="a4ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始管道作业之前，我们需要将AWS访问键存储在GitLab CI/CD变量中。在GitLab项目中打开“设置”&gt;“CI/CD”&gt;“变量”,并添加以下变量:</p><ul class=""><li id="deac" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">AWS_ACCESS_KEY_ID:添加IAM用户的访问密钥ID</li><li id="5968" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">AWS_SECRET_ACCESS_KEY:添加IAM用户的秘密访问密钥</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0e21a9fcd809b8311e3859e3e70533f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*1BYPL1DJSTw1ruRAbXkkrA.png"/></div></figure><p id="d263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里阅读更多信息<a class="ae ky" href="https://docs.gitlab.com/ee/ci/cloud_deployment/#authenticate-gitlab-with-aws" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="56b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以按如下方式定义部署作业:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次我们需要一个安装<a class="ae ky" href="https://aws.amazon.com/de/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>的映像。这里，我们利用python映像并使用<strong class="lb iu"> before_script </strong>关键字在运行我们的命令之前安装cli。</p><p id="1093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<strong class="lb iu">脚本</strong>,我们只需要<code class="fe nw nx ny nz b">aws s3 sync</code>命令，它执行源文件和目标文件之间的同步。AWS CLI将使用GitLab CI/CD变量中存储的凭证，并复制<strong class="lb iu">。/dist </strong>文件夹到给定的桶中。使用<code class="fe nw nx ny nz b">--delete</code>选项，该命令还会删除目标中存在但不在源文件中的文件。</p><h2 id="2f6c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">改进部署阶段</h2><p id="1d5f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我以前的一篇文章中，我演示了一种在运行时将环境变量注入Angular应用程序的方法。我们可以在这里找到这篇文章，并为管道中的各个环境注入不同的配置文件。</p><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-environment-configuration-at-runtime-b44e230da585"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">角度—运行时的环境配置</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">构建一次应用程序，并在运行时为任何阶段注入环境配置</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><p id="6479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，最后一步，让我们扩展管道以支持多种环境的部署。对于这个展示，我们只需添加一个额外的任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="aebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们简单讨论一下不同之处:</p><p id="5d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有<strong class="lb iu">。部署</strong>任务来设置各种部署所需的一切。在这里，您还可以添加<strong class="lb iu"> only </strong>关键字来告诉管道这个作业应该在特定的分支上执行。</p><p id="81e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们现在有两个作业，这两个作业都扩展了常规作业。</p><p id="51db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于AWS凭证，我们使用另一个GitLab变量。为了方便地为多个环境添加凭据，我们可以利用以下变量:</p><ul class=""><li id="9f90" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">AWS_SHARED_CREDENTIALS_FILE</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/20429dd1416bd4def3fbe0b71a679c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUtkV5ABH-y4DywDIbo01Q.png"/></div></div></figure><p id="0aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了选择作业要使用的凭证，我们使用带有相应值的<code class="fe nw nx ny nz b">AWS_PROFILE</code>变量。</p><p id="6290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们再次使用我们的<strong class="lb iu"> script </strong>关键字，正如前面提到的，用相应环境的配置文件覆盖配置文件。多次部署的最终结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/94bf0e72740767b30a883a0c90bbc47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlWtFCt7BooXPPXgq2eYqg.png"/></div></div></figure><p id="378d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的<strong class="lb iu"> gitlab-ci.yaml </strong>文件现在看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完成了我们的管道，每次我们提交到存储库的时候都会触发一个新的构建。当然，这个基本的例子现在可能被进一步开发和改进。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="6d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://saackef.com/" rel="noopener ugc nofollow" target="_blank"> Medium </a>或<a class="ae ky" href="https://twitter.com/sw3eks" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，阅读更多关于Angular的内容！</p></div></div>    
</body>
</html>