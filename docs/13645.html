<html>
<head>
<title>Next.js — A brief overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js简要概述</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/next-js-a-brief-overview-78ede74a22b9?source=collection_archive---------2-----------------------#2022-09-25">https://levelup.gitconnected.com/next-js-a-brief-overview-78ede74a22b9?source=collection_archive---------2-----------------------#2022-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">js是一个灵活的React框架，它为我们提供了创建快速web应用程序的构件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0bab5fa2d5c5750a75295e7932093c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOoga42iuLkWxj_tKIzYYg.jpeg"/></div></div></figure><p id="6b55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js是一个构建在Node.js之上的开源框架，以React为基础。</p><p id="c21d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文假设您熟悉<a class="ae kx" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>，并且已经使用了一段时间，现在想要将<a class="ae kx" href="https://nextjs.org/learn/foundations/about-nextjs" rel="noopener ugc nofollow" target="_blank"> Next.js </a>添加到您的工具集中。</p><p id="4925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js旨在提供一流的开发人员体验和许多内置功能，例如:</p><ul class=""><li id="313c" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">自动代码分割加快页面加载速度</li><li id="e95e" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">具有优化预取的客户端路由</li><li id="2820" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">直观的基于页面的路由系统(支持动态路由)</li><li id="b6b0" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">预渲染，静态生成(SSG)和服务器端渲染(SSR)都是基于每页支持的。</li><li id="722f" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">内置的CSS和Sass支持以及对任何CSS-in-JS库的支持。</li><li id="86e7" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">支持快速刷新的开发环境</li><li id="c946" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">使用无服务器功能构建API端点的API路由</li><li id="51f5" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">完全可扩展。</li></ul><p id="be47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还不熟悉Next.js，您可能会想知道所有这些东西是什么意思。让我们对其中一些进行详细阐述。</p><h1 id="1441" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">代码拆分</strong></h1><p id="6a4c" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">Next.js自动执行<strong class="jp ir">代码拆分</strong>，因此每个页面只加载该页面所必需的内容。这意味着，当加载主页时，最初不会提供其他页面的代码。这确保了即使我们有数百个页面，主页也能快速加载。</p><p id="ec2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只为我们请求的页面加载代码也意味着页面变得孤立。如果某个页面抛出错误，应用程序的其余部分仍将按预期工作。</p><h1 id="3f51" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">客户端导航</h1><p id="f5e6" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在Next.js中，我们在<code class="fe mp mq mr ms b">pages</code>下创建路径作为文件，并使用内置的<code class="fe mp mq mr ms b">Link</code>组件链接到它们。不需要路由库。</p><h1 id="1e60" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">预取</h1><p id="31b2" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在Next.js的生产版本中，每当一个<code class="fe mp mq mr ms b">Link</code>组件(Next.js版本的&lt; a &gt;标签)出现在浏览器的视窗中，Next.js就会自动在后台预取链接页面的代码。因此，当用户点击链接时，目标页面的代码已经在后台加载，页面转换几乎是即时的。</p><blockquote class="mt mu mv"><p id="e0ab" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">因此，Next.js通过代码分割、客户端导航和预取自动优化我们的应用程序以获得最佳性能。</p></blockquote><h1 id="8851" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">预渲染</h1><p id="8c04" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">默认情况下，Next.js会预先呈现每个页面。也就是说，Next.js预先为每个页面生成HTML，而不是由客户端JavaScript来完成。预渲染可以带来<strong class="jp ir">更好的性能</strong>和<strong class="jp ir"> SEO </strong>。</p><p id="b629" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个生成的HTML都与该页面所需的最少JavaScript代码相关联。当浏览器加载一个页面时，它的JavaScript代码运行并使页面完全交互。这个过程叫做<strong class="jp ir">水合</strong>。</p><p id="684e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js有两种形式的预渲染:<strong class="jp ir">静态生成</strong>和<strong class="jp ir">服务器端渲染</strong>。区别在于它何时为页面生成HTML。</p><ul class=""><li id="efc1" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated"><strong class="jp ir">静态生成</strong>是在<em class="mw">构建时</em>生成HTML的预渲染方法。然后在每个请求中重用预先呈现的HTML。</li><li id="db56" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><strong class="jp ir">服务器端呈现</strong>是在每个请求上生成HTML的预呈现方法。</li></ul><p id="c225" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js让我们选择每个页面使用哪种预渲染方法。我们可以创建一个“<strong class="jp ir"> <em class="mw">混合</em></strong>”next . js应用程序，对大多数页面使用<strong class="jp ir">静态生成</strong>，对其他页面使用<strong class="jp ir">服务器端呈现</strong>。</p><p id="f511" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议尽可能使用静态生成(有数据和无数据),因为我们的页面可以构建一次并由CDN提供服务，这比让服务器在每次请求时呈现页面要快得多。</p><p id="7bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果我们不能在用户请求之前预先呈现页面，静态生成就不是一个好主意。也许我们的页面显示频繁更新的数据，并且页面内容在每次请求时都会改变。</p><p id="1d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们可以使用<strong class="jp ir">服务器端渲染</strong>。它会慢一些，但是预渲染的页面将总是最新的。或者我们可以完全跳过预渲染，使用<strong class="jp ir">客户端JavaScript </strong>来填充频繁更新的数据。</p><h1 id="396c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">客户端渲染</h1><p id="3cd6" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">如果我们不需要预渲染数据，我们也可以使用一种叫做<strong class="jp ir">客户端渲染</strong>的策略，它:</p><ul class=""><li id="624e" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">静态生成(预呈现)不需要外部数据的页面部分。</li><li id="148f" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">当页面加载时，使用JavaScript从客户端获取外部数据，并填充其余部分。</li></ul><h1 id="4342" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">API路线</h1><p id="2076" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">Next.js支持API路由，这让我们可以轻松地创建一个API端点作为Node.js的无服务器函数。我们可以通过在<code class="fe mp mq mr ms b">pages/api</code>目录中创建一个函数来做到这一点。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="1255" class="lm ln iq bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated">结论</h1><p id="8cc0" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在本文中，我试图用非常简单的术语来解释Next.js的一些主要构建块。对于一直在使用Next.js但尚未真正掌握这些构建块的人来说，本文也可以作为一个复习工具。</p><p id="d68d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这篇文章，请留下几个或很多的掌声。谢了。</p></div></div>    
</body>
</html>