<html>
<head>
<title>Mocking Outbound HTTP Calls in Golang — net/http/httptest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang-net/HTTP/HTTP test中模拟出站HTTP调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mocking-outbound-http-calls-in-golang-net-http-httptest-bc5629cd3c3e?source=collection_archive---------4-----------------------#2022-10-06">https://levelup.gitconnected.com/mocking-outbound-http-calls-in-golang-net-http-httptest-bc5629cd3c3e?source=collection_archive---------4-----------------------#2022-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb1bcef7cc73e9cd4a933da2cd47d702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9Cbw9s4WSa1gV5UnY_kQA.png"/></div></div></figure><p id="c7f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不久前，我写了一篇名为“<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/mocking-outbound-http-calls-in-golang-9e5a044c2555">用Golang </a>模拟出站HTTP调用”的文章，展示了如何使用HTTP接口模拟下游HTTP调用。目标是展示如何在不进行任何实际HTTP调用的情况下测试任何代码。这种方法非常有效，但是随着我编写越来越多的代码，并接触到不同的模拟方法，我发现是时候用另一种方式来模拟您的调用了。这两种方法都是有效的，都应该被考虑，但是我发现自己经常使用这个例子，因为它太简单了。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="e949" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">设置</h1><p id="f207" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">出于本文的目的，我有意使我的代码尽可能简单。我想把重点放在对电话的嘲讽上，而不是别的。因此，这是一个单一功能的Golang项目，它将调用GitHub来检索给定用户的所有回购。简单扼要。GitHub API可以在未经认证的情况下使用，所以这样更好！让我们从<code class="fe mk ml mm mn b">github.go</code>文件开始:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="9eba" class="mw li it mn b gy mx my l mz na">package github</span><span id="4e9d" class="mw li it mn b gy nb my l mz na">import (<br/> "encoding/json"<br/> "fmt"<br/> "net/http"<br/>)</span><span id="6fa2" class="mw li it mn b gy nb my l mz na">// GetRepos takes a username and retreives<br/>func GetRepos(username string) ([]map[string]interface{}, error) {<br/> <br/> url := fmt.Sprintf("https://api.github.com/users/%s/repos?sort=created&amp;direction=desc", username)</span><span id="3734" class="mw li it mn b gy nb my l mz na">request, err := http.NewRequest(http.MethodGet, url, nil)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="fec7" class="mw li it mn b gy nb my l mz na">client := &amp;http.Client{}<br/> response, err := client.Do(request)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="1543" class="mw li it mn b gy nb my l mz na">defer response.Body.Close()</span><span id="50c9" class="mw li it mn b gy nb my l mz na">m := []map[string]interface{}{}<br/> err = json.NewDecoder(response.Body).Decode(&amp;m)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="9c53" class="mw li it mn b gy nb my l mz na">return m, nil<br/>}</span></pre><p id="d219" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里没有太多内容，但还是让我们解开这段代码:</p><ul class=""><li id="461d" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">首先，该函数将GitHub用户名作为一个参数，并立即将其放入一个格式化的URL中，请求返回按回购的“创建日期”降序排序的结果。</li><li id="f24e" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">接下来，我们有正常的出站HTTP调用代码:创建一个请求，创建一个客户机，然后进行调用。</li><li id="98f9" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">最后，我们将响应的主体映射到一个<code class="fe mk ml mm mn b">[]map[string]interface{}</code>，以便从函数中返回JSON。对于这个例子来说，这并不是真正需要的，但是它使得编写测试变得更加容易；)</li></ul><p id="5c06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们来看看<code class="fe mk ml mm mn b">github_test.go</code>文件:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="f74d" class="mw li it mn b gy mx my l mz na">package github</span><span id="af63" class="mw li it mn b gy nb my l mz na">import (<br/> "testing"<br/>)</span><span id="d757" class="mw li it mn b gy nb my l mz na">func TestGitHubCallSuccess(t *testing.T) {<br/> result, err := GetRepos("atkinsonbg")<br/> if err != nil {<br/>  t.Error("TestGitHubCallSuccess failed.")<br/>  return<br/> }</span><span id="02c9" class="mw li it mn b gy nb my l mz na">if len(result) == 0 {<br/>  t.Error("TestGitHubCallSuccess failed, array was empty.")<br/>  return<br/> }</span><span id="7d27" class="mw li it mn b gy nb my l mz na">if result[0]["full_name"] != "atkinsonbg/unittest-outbound-http-calls-golang" {<br/>  t.Error("TestGitHubCallSuccess failed, array was not sorted correctly.")<br/>  return<br/> }<br/>}</span><span id="6b9d" class="mw li it mn b gy nb my l mz na">func TestGitHubCallFail(t *testing.T) {<br/> _, err := GetRepos("atkinsonbgthisusershouldnotexist")<br/> if err == nil {<br/>  t.Error("TestGitHubCallFail failed.")<br/>  return<br/> }<br/>}</span></pre><p id="70f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里没有太多要测试的，但是我们也将打开这个:</p><ul class=""><li id="0abb" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">TestGitHubCallSuccess调用我们的<code class="fe mk ml mm mn b">GetRepos</code>函数，传递一个有效的用户名。它首先检查JSON数组中是否有内容，然后获取第一个结果以确保我们期望的名称存在。</li><li id="c8cd" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">TestGitHubCallFail也调用我们的<code class="fe mk ml mm mn b">GetRepos</code>函数，传入一个非常无效的用户名。它确保函数抛出适当的错误。</li></ul><p id="cb56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以运行一个<code class="fe mk ml mm mn b">go test -v</code>命令，看到我们得到了85.7%的覆盖率！不算太寒酸！！</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="7624" class="mw li it mn b gy mx my l mz na">Users-Air:unittest-outbound-http-calls-golang user$ go test -v ./... -coverpkg ./... -coverprofile cover.out<br/>=== RUN   TestGitHubCallSuccess<br/>--- PASS: TestGitHubCallSuccess (0.35s)<br/>=== RUN   TestGitHubCallFail<br/>--- PASS: TestGitHubCallFail (0.04s)<br/>PASS<br/>coverage: 85.7% of statements in ./...<br/>ok      _/Users/user/Documents/GitHub/atkinsonbg/unittest-outbound-http-calls-golang    0.411s  coverage: 85.7% of statements in ./...</span></pre><p id="9b1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，这个测试有一个明显的问题。我们在测试中实际调用了GitHub。这是站不住脚的。现在让我们继续，模拟这个调用，同时仍然实现我们的高代码覆盖率！</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="acbf" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">嘲笑它直到你成功</h1><p id="cedf" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">一般来说，在Go中，如果你想模仿某个东西，你可以创建一个接口。反之亦然，如果你有一个接口，你可以很容易地嘲笑它。<em class="nq">(抱歉打哑谜，很快就清楚了。)</em> Go关于接口的官方文档可以在这里找到<a class="ae kz" href="https://golang.org/doc/effective_go.html#interfaces" rel="noopener ugc nofollow" target="_blank">，它提供了一个很好的解释:</a></p><blockquote class="nr ns nt"><p id="f4e1" class="kb kc nq kd b ke kf kg kh ki kj kk kl nu kn ko kp nv kr ks kt nw kv kw kx ky im bi translated">Go中的接口提供了一种指定对象行为的方式:如果某个东西可以做<em class="it">这个</em>，那么它就可以用<em class="it">这里</em>。</p></blockquote><p id="08a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://www.linkedin.com/in/nathanleclaire/" rel="noopener ugc nofollow" target="_blank"> Nathan LeClaire </a>在Golang中写了一篇关于接口和有效测试的<a class="ae kz" href="https://nathanleclaire.com/blog/2015/10/10/interfaces-and-composition-for-effective-unit-testing-in-golang/" rel="noopener ugc nofollow" target="_blank">好文章，他总结道:</a></p><blockquote class="nr ns nt"><p id="98dd" class="kb kc nq kd b ke kf kg kh ki kj kk kl nu kn ko kp nv kr ks kt nw kv kw kx ky im bi translated">接口让你定义一组方法，一个类型(通常是<code class="fe mk ml mm mn b"><em class="it">struct</em></code>)必须定义这些方法才能被认为是接口的实现。</p><p id="f077" class="kb kc nq kd b ke kf kg kh ki kj kk kl nu kn ko kp nv kr ks kt nw kv kw kx ky im bi translated">当任何给定的类型实现了该接口的所有方法时，Go编译器自动知道它被允许作为该类型使用。</p></blockquote><p id="2c90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这基本上就是我们在之前的文章中所做的，我们在HTTP客户端接口上实现了<code class="fe mk ml mm mn b">Do</code>函数，这允许我们在稍后的测试中模拟它。现在让我们看看如何用另一种方法来做这件事。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="5854" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">构建结构</h1><p id="18c2" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">首先，我们将重构我们的<code class="fe mk ml mm mn b">github.go</code>文件并引入一个结构:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="ef8e" class="mw li it mn b gy mx my l mz na">type GitHubManager struct {<br/>    BaseUrl string<br/>    Client http.Client<br/>}</span></pre><p id="5387" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常简单的直接结构，简单地命名为<code class="fe mk ml mm mn b">GitHubManager</code>，它有两个字段:</p><ul class=""><li id="eb04" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated"><strong class="kd iu">客户端</strong>:这基本上可以让我们大量清理代码。它还提供了一种方法来注入一个定制的HTTP客户端，就像一个定制的传输，等等。</li><li id="b8e7" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated"><strong class="kd iu"> BaseUrl </strong>:这个字段提供了一种方法来覆盖调用GitHub所使用的基本Url。在我们之前的代码中，这个URL是<code class="fe mk ml mm mn b"><a class="ae kz" href="https://api.github.com," rel="noopener ugc nofollow" target="_blank">https://api.github.com</a></code> <a class="ae kz" href="https://api.github.com," rel="noopener ugc nofollow" target="_blank">，</a>然而，为了支持嘲讽，我们希望能够控制这个，你将在后面的帖子中看到。</li></ul><p id="8c9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们针对这些变化更新代码:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="be68" class="mw li it mn b gy mx my l mz na">func (ghm *GitHubManager) GetRepos(username string) ([]map[string]interface{}, error) {<br/>   url := fmt.Sprintf("%s/users/%s/repos?sort=created&amp;direction=desc", ghm.BaseUrl, username)<br/><br/>   request, err := http.NewRequest(http.<em class="nq">MethodGet</em>, url, nil)<br/>   if err != nil {<br/>      return nil, err<br/>   }<br/><br/>   response, err := ghm.Client.Do(request)<br/>   if err != nil {<br/>      return nil, err<br/>   }<br/><br/>   defer response.Body.Close()<br/><br/>   m := []map[string]interface{}{}<br/>   err = json.NewDecoder(response.Body).Decode(&amp;m)<br/>   if err != nil {<br/>      return nil, err<br/>   }<br/><br/>   return m, nil<br/>}</span></pre><p id="1825" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要更新我们的<code class="fe mk ml mm mn b">url</code>变量，以利用新的struct字段:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="0594" class="mw li it mn b gy mx my l mz na">url := fmt.Sprintf("%s/users/%s/repos?sort=created&amp;direction=desc", ghm.BaseUrl, username)</span></pre><p id="721e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们可以访问该结构的<code class="fe mk ml mm mn b">http.Client</code>,向GitHub发出请求:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="755a" class="mw li it mn b gy mx my l mz na">response, err := ghm.Client.Do(request)</span></pre><p id="a985" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些变化使我们的代码更加灵活，但在使用这个结构/方法时，确实引入了少量的前期配置。这没什么大不了的，对于更复杂的交互来说，这是一个很好的模式。现在让我们看看这是如何使测试变得如此容易的。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="e1bc" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">使用httptest进行测试。新闻服务器</h1><p id="7e9c" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">Go提供了一个名为<code class="fe mk ml mm mn b"><a class="ae kz" href="https://pkg.go.dev/net/http/httptest" rel="noopener ugc nofollow" target="_blank">httptest</a></code>的非常好的包，在他们的文档中被描述为“<em class="nq">包httptest提供了用于HTTP测试的实用程序</em>”。非常简单的解释，但真的是这样。在这个包中有<code class="fe mk ml mm mn b">Server</code>，它被描述为“<em class="nq">服务器是一个HTTP服务器，监听本地环回接口上系统选择的端口，用于端到端HTTP测试</em>。你没看错，这提供了一种启动真正的本地服务器来响应真正的HTTP请求的方法，特别是来自测试的请求。</p><p id="1583" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一个使用<code class="fe mk ml mm mn b">Server</code>的简单测试，然后分解它:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1e91" class="mw li it mn b gy mx my l mz na">package github</span><span id="6065" class="mw li it mn b gy nb my l mz na">import (<br/> "net/http"<br/> "net/http/httptest"<br/> "testing"</span><span id="a016" class="mw li it mn b gy nb my l mz na">"github.com/stretchr/testify/assert"<br/>)</span><span id="36dc" class="mw li it mn b gy nb my l mz na">func TestGitHubCallSuccess(t *testing.T) {</span><span id="f7a8" class="mw li it mn b gy nb my l mz na">// build our response JSON<br/> jsonResponse := `[{<br/>   "full_name": "mock-repo"<br/>  }]`</span><span id="6344" class="mw li it mn b gy nb my l mz na">// create a new server with that JSON<br/> server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>  w.WriteHeader(200)<br/>  _, _ = w.Write([]byte(jsonResponse))<br/> }))<br/> defer server.Close()</span><span id="857a" class="mw li it mn b gy nb my l mz na">ghm := GitHubManager{<br/>  BaseUrl: server.URL,<br/> }</span><span id="736f" class="mw li it mn b gy nb my l mz na">result, err := ghm.GetRepos("atkinsonbg")<br/> if err != nil {<br/>  t.Error("TestGitHubCallSuccess failed.")<br/>  return<br/> }</span><span id="ef82" class="mw li it mn b gy nb my l mz na">assert.True(t, len(result) &gt; 0)<br/>assert.Equal(t, result[0]["full_name"], "mock-repo")<br/>}</span></pre><p id="f966" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们从github.com/stretchr/testify/assert<a class="ae kz" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank"/>导入所有需要的包:<code class="fe mk ml mm mn b">net/http,</code> <code class="fe mk ml mm mn b">net/http/httptest,</code> <code class="fe mk ml mm mn b">testing,</code>和<code class="fe mk ml mm mn b">assert</code>。Assert只是提供了一些很好的函数来执行测试断言，如果您以前没有使用过它，绝对推荐您去看看。</p><p id="30f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来是我们的测试函数，<code class="fe mk ml mm mn b">TestGitHubCallSuccess</code>，它将使用一个测试服务器来模拟我们的GitHub调用，让我们来分析一下它在做什么:</p><ul class=""><li id="d77d" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">首先，我们创建一个模拟json响应，希望我们的代码能够处理它。现在，我们的代码除了将JSON发送回我们之外没有做更多的事情，但是如果您的代码确实对JSON有效负载做了一些事情，那么您可以在这里制作您喜欢的任何东西，它将从测试服务器返回。</li><li id="7137" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">接下来，我们使用<code class="fe mk ml mm mn b">httptest.NewServer().</code>创建一个新的测试服务器，这上面的签名有点多，因为<code class="fe mk ml mm mn b">NewServer</code>带有一个<code class="fe mk ml mm mn b">http.HandlerFunc</code>，它带有一个接受<code class="fe mk ml mm mn b">http.ResponseWriter</code>的<code class="fe mk ml mm mn b">func</code>和一个指向<code class="fe mk ml mm mn b">http.Request.</code>的指针。好消息是，这几乎是样板文件，任何时候你需要一个新的服务器，这就是签名。</li><li id="b749" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">在<code class="fe mk ml mm mn b">func</code>中，我们可以访问<code class="fe mk ml mm mn b">http.ResponseWriter,</code>和<code class="fe mk ml mm mn b">w</code>变量，这是所有魔法发生的地方。我们从设置<code class="fe mk ml mm mn b">w.WriteHeader(200)</code>开始，它设置了我们想要返回的状态代码。如果你想要一个200，你不必指定这个。然而，它提供了对提供201、400、404、500、503等等的强大控制。你甚至可以使用<code class="fe mk ml mm mn b">w.Header().Add("key", “value").</code>来指定自定义标题</li><li id="4efe" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">接下来，我们用<code class="fe mk ml mm mn b">_,_ = w.Write([]byte(jsonResponse)).</code>提供响应的主体。这非常简单，我们需要以字节数组的形式向编写器提供主体，我们简单地忽略返回变量，因为这是我们测试中的受控环境，我们不需要它们。</li><li id="6511" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">最后我们调用一个<code class="fe mk ml mm mn b">defer server.Close()</code>来清理资源。</li></ul><p id="9185" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是设置测试服务器并提供模拟响应所要做的全部工作。现在让我们看看你如何使用它。</p><p id="9a1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们创建了一个采用<code class="fe mk ml mm mn b">BaseUrl</code>参数的结构，我们可以简单地像这样使用服务器:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="c90a" class="mw li it mn b gy mx my l mz na">ghm := GitHubManager{<br/>   BaseUrl: server.URL,<br/>}<br/><br/>result, err := ghm.GetRepos("atkinsonbg")</span></pre><p id="ed94" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，我们简单地将<code class="fe mk ml mm mn b">server.URL</code>传递给我们的结构，当我们调用<code class="fe mk ml mm mn b">ghm.GetRepos()</code>时，测试服务器将被调用，而不是实际的GitHub API URL。最后，我们根据传入的模拟JSON检查结果:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1f6a" class="mw li it mn b gy mx my l mz na">assert.True(t, len(result) &gt; 0)<br/>assert.Equal(t, result[0]["full_name"], "mock-repo")</span></pre><p id="01aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们对我们的回购运行<code class="fe mk ml mm mn b">go test -v</code>,我们应该看到我们所有的测试都通过了:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="d74e" class="mw li it mn b gy mx my l mz na">(base) ➜  unittest-outbound-http-calls-golang-2 git:(main) ✗ go test -v<br/>=== RUN   TestGitHubCallSuccess<br/>--- PASS: TestGitHubCallSuccess (0.00s)<br/>=== RUN   TestGitHubCallFail<br/>--- PASS: TestGitHubCallFail (0.00s)<br/>PASS<br/>ok      github.com/atkinsonbg/unittest-outbound-http-calls-golang-2     0.367s</span></pre><p id="d164" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意我在GitHub repo中有一个额外的测试来测试调用失败；)</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="b3eb" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">包扎</h1><p id="0b6b" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">在这篇文章中，我们看到了如何使用<code class="fe mk ml mm mn b">net/http/httptest</code>包轻松模拟出站HTTP调用进行测试。这个包非常简单，同时又非常强大。我们仅仅触及了它的表面，它已经提供了大量的价值。因此，如果您发现自己需要测试下游HTTP调用，不用再找了，这个包可以解决您的问题。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h2 id="34ce" class="mw li it bd lj nx ny dn ln nz oa dp lr km ob oc lv kq od oe lz ku of og md oh bi translated">资源</h2><ul class=""><li id="7a71" class="nc nd it kd b ke mf ki mg km oi kq oj ku ok ky nh ni nj nk bi translated"><a class="ae kz" href="https://github.com/atkinsonbg/unittest-outbound-http-calls-golang-2" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li><li id="c6e7" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated"><a class="ae kz" href="https://pkg.go.dev/net/http/httptest" rel="noopener ugc nofollow" target="_blank"> net/http/httptest </a></li><li id="6a73" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated"><a class="ae kz" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">断言</a></li><li id="bad1" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated"><a class="ae kz" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">回复作者</a></li></ul></div></div>    
</body>
</html>