<html>
<head>
<title>Implementing the State Pattern (Part 6)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现状态模式(第6部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-the-state-pattern-part-6-7631a532c0ea?source=collection_archive---------9-----------------------#2021-03-21">https://levelup.gitconnected.com/implementing-the-state-pattern-part-6-7631a532c0ea?source=collection_archive---------9-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/f56304e6a017e72d558bcf5f3e3cd1fe.png" data-original-src="https://miro.medium.com/v2/format:webp/0*55eLFcyH1xpMZ5Mf.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">礼貌:timeanddate.com</figcaption></figure><p id="83d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到本系列的第6部分:“强大的设计模式来创建一个惊人的秒表应用程序”。我们的秒表应用程序就要完成了。我们只需要给它画龙点睛。我们的应用程序当前版本的问题是:它不可扩展。看一下我们在以下状态下处理按钮按压的方式:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="44e0" class="lf lg iq lb b gy lh li l lj lk">private void handleStartPress() {<br/>    if(currentState==NOT_RUNNING)<br/>    {<br/>        sw =  new Stopwatch();<br/>        sw.registerObserver(this);<br/>        sw.start();<br/>        start.setText("Pause");<br/>        stop.setVisible(true);<br/>        currentState=RUNNING;<br/>    }<br/>    else if(currentState==RUNNING)<br/>    {<br/>        sw.stop();<br/>        start.setText("Resume");<br/>        currentState=PAUSED;<br/>    }<br/>    else if(currentState==PAUSED)<br/>    {<br/>        sw.start();<br/>        start.setText("Pause");<br/>        currentState=RUNNING;<br/>    }<br/><br/>}</span></pre><p id="dfeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太多if-else语句。如果我们试图添加更多的状态，我们必须在很多地方进行修改，当我们忘记更新甚至一个地方时，这可能会引入错误。我们必须考虑如何让这个应用程序可扩展且易于理解。</p><h1 id="a462" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">之前的教程</h1><p id="7c2b" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">如果您是第一次阅读这一部分，那么您一定要看看本系列的第5部分。</p><ul class=""><li id="e587" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated"><a class="ae mw" href="https://github.com/rajtilakls2510/Stopwatch/tree/S5_Adding_functions_to_the_APP" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">代号</strong> </a>直到现在。</li><li id="8714" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated"><a class="ae mw" href="https://rajtilakls2510.medium.com/adding-start-pause-resume-and-stop-to-our-app-part-5-dd562d82d0a3" rel="noopener">第五部</a></li></ul></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="7f47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顾名思义，我们将实现状态模式。警告:这种模式包括添加许多新的java文件，可能有点难以理解。但是我会尽我所能让你明白，所以继续读下去直到最后。</p><p id="a5c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回想一下我们的应用程序的状态图:</p><figure class="kw kx ky kz gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/634b1ef262e23b6b65aa6eda932a8ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ag0L8fpt--aRLer5bHUUsg.png"/></div></div></figure><p id="b096" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住这个图表，因为我们将使用它来构建我们的模式。在进入该模式之前，让我们先确定一些当按下start按钮时执行的常见任务。这是当用户在非运行状态下按下开始按钮时运行的代码:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3a7a" class="lf lg iq lb b gy lh li l lj lk">if(currentState==NOT_RUNNING)<br/>{<br/>    sw =  new Stopwatch();<br/>    sw.registerObserver(this);<br/>    sw.start();<br/>    start.setText("Pause");<br/>    stop.setVisible(true);<br/>    currentState=RUNNING;<br/>}</span></pre><p id="5beb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能说出这里的一些常见任务吗？</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="aadc" class="lf lg iq lb b gy lh li l lj lk">sw =  new Stopwatch();<br/>sw.registerObserver(this);<br/>sw.start();</span></pre><p id="e452" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这三条线明确表明我们正在用秒表做一些事情。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="66d1" class="lf lg iq lb b gy lh li l lj lk">start.setText("Pause");<br/>stop.setVisible(true);</span></pre><p id="2e98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两行表明我们正在更新UI。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="584f" class="lf lg iq lb b gy lh li l lj lk">currentState=RUNNING;</span></pre><p id="a3d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一行表明我们正在改变状态。</p><p id="5b6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常类似地，您可以在每个状态中识别这三类任务:</p><ul class=""><li id="6704" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">手柄秒表</li><li id="dee4" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">handleUI</li><li id="085a" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">变更状态</li></ul><p id="f6c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看下面这张图。</p><figure class="kw kx ky kz gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/ecab6c93d1bf9bd3c44e8fdac63973c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUsY-jc92R_mgGcJOx62mA.png"/></div></div></figure><p id="1a6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们了解一下状态模式。有一个公共的接口状态，具体的类从这个接口状态派生它们的方法。这个状态接口有一些适用于所有状态的通用方法。状态模式的类图如下所示:</p><figure class="kw kx ky kz gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/084c31377400212cc92e85973459e592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyy-WH9BeFWSFqPIpGkQHg.png"/></div></div></figure><p id="7a42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到有一个接口状态，它有一个方法句柄()。所有的派生类都重写handle()并放置它们自己的功能。这包括做自己的事情和改变状态(很重要)。</p><p id="5128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上下文是具有这些状态的类，这些状态随时间变化。这个上下文有一个request()方法，它只接受当前状态并调用它的handle()方法。无论当前状态如何，都会调用适当的handle()方法并实现所有任务。</p><p id="febd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正式定义:</p><p id="7b7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">状态模式允许一个对象在其内部状态改变时改变其行为。该对象看起来会改变它的类。</p><p id="8691" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的应用程序中，每个状态都有三个常见的任务，我们将把这些任务放在每个状态的各自的方法中。状态接口将定义这些公共方法，处理这些公共方法的内部内容将是相应状态的责任。让我们从绘制我们的应用程序的类图开始，这样会给你更多的感觉。</p><figure class="kw kx ky kz gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/bb759a3decad9556165f11f8342f8e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oz1u8A_IuztyLloXPpcPwg.png"/></div></div></figure><p id="3c80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过使接口StopwatchState来陈述。制作一个java文件StopwatchState.java</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0ebe" class="lf lg iq lb b gy lh li l lj lk">public interface StopwatchState {<br/><br/>    public void handleStopwatch();<br/>    public void handleUI();<br/>    public void changeState();<br/>}</span></pre><p id="8c90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，handleStopwatch()、handleUI()和changeState()需要按顺序调用。所以，我们再做一个封装这个算法的方法:execute()。你可能想知道如何在一个接口的方法中编写代码？方法不是抽象的吗？我们将利用java8中Java提供的<strong class="ka ir">默认</strong>关键字。这个关键字让你写一个接口方法的方法体。我们在这里并没有做太多的事情，我们只是写了当它必须改变状态时，这些方法需要被调用的顺序。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="910e" class="lf lg iq lb b gy lh li l lj lk">public interface StopwatchState {</span><span id="a0e8" class="lf lg iq lb b gy nq li l lj lk">    default void execute()<br/>    {<br/>        handleStopwatch();<br/>        handleUI();<br/>        changeState();<br/>    }<br/>    public void handleStopwatch();<br/>    public void handleUI();<br/>    public void changeState();<br/>}</span></pre><p id="c7f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">execute()方法的优点是StopwatchSwing只需对currentState调用execute，它的所有秒表任务都将被处理，它的所有UI内容都将被处理，状态将自动改变。</p><p id="8235" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使其处于不运行状态。创建一个java文件NotRunningStopwatchState.java，并编写:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="cfa5" class="lf lg iq lb b gy lh li l lj lk">public class NotRunningStopwatchState implements StopwatchState{<br/>   <br/><br/>    @Override<br/>    public void handleStopwatch() {<br/>       <br/>    }<br/><br/>    @Override<br/>    public void handleUI() {<br/>    }<br/><br/>    @Override<br/>    public void changeState() {<br/>    }<br/>}</span></pre><p id="8a84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经覆盖了StopwatchState接口及其所有方法。现在，我们需要一个对上下文类的引用，这里的上下文类是StopwatchSwing类。因此，我们将创建一个类变量来保存StopwatchSwing对象，并在构造函数中初始化它。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3b1c" class="lf lg iq lb b gy lh li l lj lk"><br/>public class NotRunningStopwatchState implements StopwatchState{<br/>    StopwatchSwing stopwatchSwing;<br/><br/>    public NotRunningStopwatchState(StopwatchSwing stopwatchSwing) {<br/>        this.stopwatchSwing = stopwatchSwing;<br/>    }<br/><br/>   ....<br/>}</span></pre><p id="0617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们稍后将填充这些被覆盖的方法。让我们首先创建另外两个状态:RunningStopwatchState和PausedStopwatchState。</p><p id="d9cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PausedStopwatchState.java</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e281" class="lf lg iq lb b gy lh li l lj lk"><br/>public class PausedStopwatchState implements StopwatchState{<br/>    StopwatchSwing stopwatchSwing;<br/><br/>    public PausedStopwatchState(StopwatchSwing stopwatchSwing) {<br/>        this.stopwatchSwing = stopwatchSwing;<br/>    }<br/><br/>    @Override<br/>    public void handleStopwatch() {<br/>    }<br/><br/>    @Override<br/>    public void handleUI() {<br/>    }<br/><br/>    @Override<br/>    public void changeState() {<br/>    }<br/>}<br/></span></pre><p id="ed3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RunningStopwatchState.java</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="bdf8" class="lf lg iq lb b gy lh li l lj lk"><br/>public class RunningStopwatchState implements StopwatchState{<br/>    StopwatchSwing stopwatchSwing;<br/><br/>    public RunningStopwatchState(StopwatchSwing stopwatchSwing) {<br/>        this.stopwatchSwing = stopwatchSwing;<br/>    }<br/><br/>    @Override<br/>    public void handleStopwatch() {<br/>    }<br/><br/>    @Override<br/>    public void handleUI() {<br/>    }<br/><br/>    @Override<br/>    public void changeState() {<br/>    }<br/>}</span></pre><p id="0916" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在后面填充所有这些被覆盖的方法。首先，让我们转到StopwatchSwing类，并在那里创建州。用给定代码替换以下代码:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="41a1" class="lf lg iq lb b gy lh li l lj lk">//Replace this<br/>public class StopwatchSwing implements Observer {<br/><br/>    ...<br/>    final int NOT_RUNNING=0, RUNNING=1, PAUSED=2;<br/>    int currentState;<br/>    ....</span><span id="c106" class="lf lg iq lb b gy nq li l lj lk">}</span><span id="93f7" class="lf lg iq lb b gy nq li l lj lk">// Replace it with this</span><span id="f546" class="lf lg iq lb b gy nq li l lj lk">public class StopwatchSwing implements Observer {</span><span id="9e09" class="lf lg iq lb b gy nq li l lj lk">    ....<br/>    StopwatchState notRunningState;<br/>    StopwatchState runningState;<br/>    StopwatchState pausedState;<br/><br/>    StopwatchState currentState;</span><span id="6334" class="lf lg iq lb b gy nq li l lj lk">    .....<br/>}</span></pre><p id="216d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建了三个状态，它们的类型是StopwatchState，因为我们知道它们将实现StopwatchState。让我们在StopwatchSwing的构造函数中创建它们各自的对象，并首先用NotRunningStopwatchState对象初始化currentState(与之前用final integers实现时相同):</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="48a5" class="lf lg iq lb b gy lh li l lj lk">StopwatchSwing()<br/>{<br/>    // Remove this<br/>    currentState = NOT_RUNNING;<br/>    sw = new Stopwatch();<br/>    sw.registerObserver(this);</span><span id="8774" class="lf lg iq lb b gy nq li l lj lk">    // Add this<br/>    notRunningState = new NotRunningStopwatchState(this);<br/>    runningState = new RunningStopwatchState(this);<br/>    pausedState = new PausedStopwatchState(this);<br/>    currentState = notRunningState;<br/>    .... </span><span id="8f74" class="lf lg iq lb b gy nq li l lj lk">}</span></pre><p id="e1f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们在每个状态的构造函数中传递上下文，因为它们需要上下文来更新UI元素和秒表。</p><p id="b7da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将向StopwatchSwing添加一些状态访问器方法，以便这些状态类可以访问类变量。非常简单，只需添加这些getter和setter方法:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="2626" class="lf lg iq lb b gy lh li l lj lk">public class StopwatchSwing implements Observer {<br/><br/>    ....<br/><br/>    <em class="np">// &lt;-------------------- Accessor Methods -------------------&gt;<br/>    </em>public void setState(StopwatchState state)<br/>    {<br/>        currentState = state;<br/>    }<br/><br/><br/>    public StopwatchState getState()<br/>    {<br/>        return currentState;<br/>    }<br/><br/>    public void setStopwatch(Stopwatch sw)<br/>    {<br/>        this.sw =sw;<br/>    }<br/>    public StopwatchState getNotRunningState() {<br/>        return notRunningState;<br/>    }<br/><br/>    public StopwatchState getRunningState() {<br/>        return runningState;<br/>    }<br/><br/>    public StopwatchState getPausedState() {<br/>        return pausedState;<br/>    }<br/>    ....<br/>}</span></pre><p id="f1b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们有一个设置当前状态的setState()方法，获取当前状态的getState()方法，设置新秒表的setStopwatch()方法，获取未运行状态对象的getNotRunningState()方法，以及类似的其他getter方法。</p><p id="ed97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们去填充状态类的未完成的覆盖方法。从NotRunningStopwatchState开始。代码类似且易于理解:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1d0f" class="lf lg iq lb b gy lh li l lj lk">public class NotRunningStopwatchState implements StopwatchState{<br/>    StopwatchSwing stopwatchSwing;<br/><br/>    public NotRunningStopwatchState(StopwatchSwing stopwatchSwing) {<br/>        this.stopwatchSwing = stopwatchSwing;<br/>    }<br/><br/>    @Override<br/>    public void handleStopwatch() {<br/>        Stopwatch sw = new Stopwatch();<br/>        stopwatchSwing.setStopwatch(sw);<br/>        sw.registerObserver(stopwatchSwing);<br/>        sw.start();<br/>    }<br/><br/>    @Override<br/>    public void handleUI() {<br/>        stopwatchSwing.start.setText("Pause");<br/>        stopwatchSwing.stop.setVisible(true);<br/>    }<br/><br/>    @Override<br/>    public void changeState() {<br/>        stopwatchSwing.setState(stopwatchSwing.getRunningState());<br/>    }<br/>}</span></pre><p id="6ba8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在handleStopwatch()方法中看到，我们正在创建一个新的秒表，并将其设置为stopwatchwangobjects Stopwatch变量。我们正在注册观察器并启动它。在handleUI()方法中，我们正在更新StopwatchSwing类的UI。最后注意改变状态的方法。它从上下文类中获取运行状态，并使用StopwatchSwing类的setState()方法更新它。</p><p id="e09c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有其他州的代码几乎相同，我将只给出它们而不做任何解释:</p><p id="8faf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PausedStopwatchState.java:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c14a" class="lf lg iq lb b gy lh li l lj lk">public class PausedStopwatchState implements StopwatchState{<br/>    StopwatchSwing stopwatchSwing;<br/><br/>    public PausedStopwatchState(StopwatchSwing stopwatchSwing) {<br/>        this.stopwatchSwing = stopwatchSwing;<br/>    }<br/><br/>    @Override<br/>    public void handleStopwatch() {<br/>        stopwatchSwing.sw.start();<br/>    }<br/><br/>    @Override<br/>    public void handleUI() {<br/>        stopwatchSwing.start.setText("Pause");<br/>    }<br/><br/>    @Override<br/>    public void changeState() {<br/>        stopwatchSwing.setState(stopwatchSwing.getRunningState());<br/>    }<br/>}</span></pre><p id="10e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RunningStopwatchState.java:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="853d" class="lf lg iq lb b gy lh li l lj lk">public class RunningStopwatchState implements StopwatchState{<br/>    StopwatchSwing stopwatchSwing;<br/><br/>    public RunningStopwatchState(StopwatchSwing stopwatchSwing) {<br/>        this.stopwatchSwing = stopwatchSwing;<br/>    }<br/><br/>    @Override<br/>    public void handleStopwatch() {<br/>        stopwatchSwing.sw.stop();<br/>    }<br/><br/>    @Override<br/>    public void handleUI() {<br/>        stopwatchSwing.start.setText("Resume");<br/>    }<br/><br/>    @Override<br/>    public void changeState() {<br/>        stopwatchSwing.setState(stopwatchSwing.getPausedState());<br/>    }<br/>}</span></pre><p id="caaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在只剩下两件事:更新两个按钮监听器方法。在handleStartPress()方法中，删除所有内容并编写:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1989" class="lf lg iq lb b gy lh li l lj lk">private void handleStartPress() {<br/>    currentState.execute();<br/><br/>}</span></pre><p id="9e2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这么简单，对吧？</p><p id="24b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在handleStopPress()方法中，只需替换行currentState = NOT_RUNNING:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="f0f5" class="lf lg iq lb b gy lh li l lj lk">private void handleStopPress(){<br/>    ...<br/>    // Replace this</span><span id="9a79" class="lf lg iq lb b gy nq li l lj lk">    currentState=NOT_RUNNING;<br/>    <br/>    // Replace it with <br/>    currentState = notRunning;</span><span id="decc" class="lf lg iq lb b gy nq li l lj lk">}</span></pre><p id="bf83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，如果您运行代码，它将像以前一样运行，但这次我们实现了状态模式。我们将很快对此进行一次演练。首先，让我们再次看看handleStopPress()方法。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4c55" class="lf lg iq lb b gy lh li l lj lk">private void handleStopPress(){<br/>    if(sw!=null)<br/>        sw.stop();<br/>    sw = null;<br/>    timerDisplay.setText("Time: "+formatTime(0L));<br/>    start.setText("Start");<br/>    stop.setVisible(false);<br/>    currentState=notRunningState;<br/>}</span></pre><p id="3937" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，是同样的问题。我们手动更改秒表和手动更新UI，而其他状态自己处理这些事情。我们必须改变这种实现方式，但是我们能做些什么呢？</p><p id="81ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想创造另一个国家，你是对的。鉴于我们已经实现了State模式，向它添加一个新的状态应该很简单。只需创建一个新类，实现StopwatchState，覆盖这些方法并填充它们。在StopwatchSwing类中，进行适当的修改，然后嘣:我们完成了。</p><p id="be85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个新的国家:StopPressedStopwatchState.java</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="bcc4" class="lf lg iq lb b gy lh li l lj lk">public class StopPressedStopwatchState implements StopwatchState{<br/>    StopwatchSwing stopwatchSwing;<br/><br/><br/>    public StopPressedStopwatchState(StopwatchSwing stopwatchSwing)      {<br/>        this.stopwatchSwing = stopwatchSwing;<br/>    }<br/><br/>    @Override<br/>    public void handleStopwatch() {<br/>        if(stopwatchSwing.sw != null)<br/>            stopwatchSwing.sw.stop();<br/>        stopwatchSwing.sw =null;<br/>    }<br/><br/>    @Override<br/>    public void handleUI() {<br/>        stopwatchSwing.timerDisplay.setText("Time: "+ stopwatchSwing.formatTime(0L));<br/>        stopwatchSwing.start.setText("Start");<br/>        stopwatchSwing.stop.setVisible(false);<br/>    }<br/><br/>    @Override<br/>    public void changeState() {<br/>        stopwatchSwing.setState(stopwatchSwing.getNotRunningState());<br/>    }<br/>}</span></pre><p id="5e87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们已经编写了当用户在这种状态下按下Stop按钮时将执行的所有逻辑。最后，此状态将状态更改为NotRunningState。</p><p id="b143" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在StopwatchSwing类中创建一个新的状态变量:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="78dd" class="lf lg iq lb b gy lh li l lj lk">public class StopwatchSwing implements Observer {<br/><br/>    ...<br/>    StopwatchState notRunningState;<br/>    StopwatchState runningState;<br/>    StopwatchState pausedState;<br/>    StopwatchState stopPressedStopwatchState; // New State<br/><br/>    StopwatchState currentState;<br/>    ....<br/>}</span></pre><p id="91db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在构造函数中初始化它，并使用以下stopPressedStopwatchState初始化currentState:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b09f" class="lf lg iq lb b gy lh li l lj lk">StopwatchSwing()<br/>{<br/>    notRunningState = new NotRunningStopwatchState(this);<br/>    runningState = new RunningStopwatchState(this);<br/>    pausedState = new PausedStopwatchState(this);<br/>    stopPressedStopwatchState = new StopPressedStopwatchState(this);<br/>    currentState = stopPressedStopwatchState;<br/>    currentState.execute();<br/>    ....<br/>}</span></pre><p id="53d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们正在调用stopPressedStopwatchState对象的execute()方法，该对象立即处于当前状态。这将初始化秒表对象，初始化按钮和timerDisplay等UI元素，然后将状态更改为NotRunningState。</p><p id="b4cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还记得我们为什么做出这个新状态吗:减少handleStopPress()方法中的代码。现在我们更新一下:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="104b" class="lf lg iq lb b gy lh li l lj lk">private void handleStopPress(){<br/>    currentState = stopPressedStopwatchState;<br/>    currentState.execute();<br/>}</span></pre><p id="bc5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们转换到stopPressedStopwatchState，然后调用execute()方法。这将初始化所有内容，并将状态更改为未运行。</p><p id="e373" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以运行这段代码了。但是一旦运行它，就会得到一个NullPointerException。你能猜到原因吗？</p><p id="5911" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">原因是，我们在创建任何UI元素之前调用了currentState.execute()方法。当我们调用execute()方法时，它试图更新尚未创建的timerDisplay。因此应用程序崩溃。我们必须将currentState.execute()方法移动到所有UI元素都已初始化的位置(到构造函数的最后)。因此，将这几行移到构造函数的末尾，您的应用程序就会运行良好:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="d166" class="lf lg iq lb b gy lh li l lj lk">notRunningState = new NotRunningStopwatchState(this);<br/>runningState = new RunningStopwatchState(this);<br/>pausedState = new PausedStopwatchState(this);<br/>stopPressedStopwatchState = new StopPressedStopwatchState(this);<br/>currentState = stopPressedStopwatchState;<br/>currentState.execute();</span></pre><p id="e152" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！这是我们所有的代码。</p><p id="11a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会注意到构造函数中有太多的代码，对于第一次看到它的人来说可能很难理解。因此，让我们将它们放在单独的功能中:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8338" class="lf lg iq lb b gy lh li l lj lk">StopwatchSwing()<br/>{<br/>    initializeJFrame();<br/>    setUpPanels();<br/>    addButtonListeners();<br/>    initializeStates();<br/>    frame.setVisible(true);<br/>}<br/><br/>public void initializeJFrame()<br/>{<br/>    <em class="np">// Initializing the JFrame<br/>    </em>frame = new JFrame("Stopwatch");<br/>    frame.setSize(300,300);<br/>    frame.setMinimumSize(new Dimension(300,300));<br/>    frame.setLayout(new GridLayout(2,1));<br/>    frame.setDefaultCloseOperation(JFrame.<em class="np">EXIT_ON_CLOSE</em>);<br/>}<br/>public void setUpPanels()<br/>{<br/>    <em class="np">// Setting Up Panels<br/>    </em>panel1 = new JPanel();<br/>    panel1.setLayout(new FlowLayout(FlowLayout.<em class="np">CENTER</em>, 0, 50));<br/><br/>    timerDisplay = new JLabel();<br/>    Font font = timerDisplay.getFont();<br/>    timerDisplay.setFont(new Font(font.getFontName(), font.getStyle(), 18));<br/><br/>    panel1.add(timerDisplay);<br/><br/><br/>    panel2 = new JPanel();<br/>    panel2.setLayout(new FlowLayout(FlowLayout.<em class="np">CENTER</em>));<br/>    start = new JButton("Start");<br/>    stop = new JButton("Stop");<br/>    stop.setVisible(false);<br/>    panel2.add(start);<br/>    panel2.add(stop);<br/><br/>    frame.add(panel1);<br/>    frame.add(panel2);<br/>}<br/>public void addButtonListeners()<br/>{<br/>    <em class="np">// Adding Listeners to the Buttons<br/><br/>    </em>start.addActionListener(new ActionListener() {<br/>        @Override<br/>        public void actionPerformed(ActionEvent e) {<br/>            handleStartPress();<br/>        }<br/>    });<br/><br/>    stop.addActionListener(new ActionListener() {<br/>        @Override<br/>        public void actionPerformed(ActionEvent e) {<br/>            handleStopPress();<br/>        }<br/>    });<br/>}<br/><br/>public void initializeStates()<br/>{<br/>    <em class="np">// Initializing states<br/>    </em>notRunningState = new NotRunningStopwatchState(this);<br/>    runningState = new RunningStopwatchState(this);<br/>    pausedState = new PausedStopwatchState(this);<br/>    stopPressedState = new StopPressedStopwatchState(this);<br/>    currentState=stopPressedState;<br/>    currentState.execute();<br/>}</span></pre><p id="d373" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我已经将所有JFrame创建和初始化代码移动到一个函数中，将所有面板创建和初始化代码移动到一个函数中，将所有按钮监听器移动到一个函数中，并将所有状态初始化移动到一个函数中。最后，我调用frame.visible(true)。</p><p id="fec9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是秒表应用程序的最终代码。</p><p id="cbcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们浏览一下整个过程:</p><ul class=""><li id="b2ff" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">首先，我们的JFrame正在被创建和初始化。</li><li id="7ca1" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">然后，我们添加两个面板，并向其中添加JLabel和JButtons。</li><li id="f8a1" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">然后，我们向它添加按钮监听器。</li><li id="30f2" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">我们正在初始化所有状态，并将当前状态设置为stopPressedStopwatchState。</li><li id="ec35" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">在currentState上调用execute时，初始化所有UI元素，如JLabel和Jbuttons，并将状态更改为NotRunningStopwatchState。</li><li id="5226" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">每当用户按下开始按钮时，我们就调用curentState的execute()方法。我们甚至不必考虑改变州和所有的废话，因为它是由各州自己照顾。</li><li id="0cfd" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">在状态对象上按下execute()方法时，它依次调用handleStopwatch()、handleUI()和changeState()方法。</li><li id="7a09" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">每当用户按下stop按钮时，我们只需将stopPressedStopwatchState设为当前状态，并调用其execute()方法。</li><li id="86fd" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">因为这个StopwatchSwing类是一个注册的观察者，所以当秒表运行时，它会自动得到时间变化的通知。</li></ul><p id="1e1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！这就是我们所关心的。</p><p id="d6bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回顾一下我们到目前为止所做的工作，并理解我们为什么要走这条路:</p><ul class=""><li id="d74d" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">首先，我们创建了运行在不同线程上的核心秒表类。</li><li id="8c66" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">我们实现了Observer模式，不让StopwatchSwing类创建不同的线程来查看秒表时间。</li><li id="9b50" class="mn mo iq ka b kb mx kf my kj mz kn na kr nb kv ms mt mu mv bi translated">我们实现了状态模式，以减少每当有状态转换时手动更改UI的负载。</li></ul><p id="38d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="np">不知不觉中我们又实现了一个模式:模板模式。回想一下，状态接口的执行方法。我们已经在execute方法中定义了算法，并将其他方法保持抽象，以便可以根据派生类的需要填充它们。这是模板模式。</em>T3】</strong></p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="f93e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">设计模式的威力只有在与探索性的编程风格相比较时才能看到。这就是为什么我已经给它一个尝试。这是相同版本的秒表，但是没有使用任何设计模式:</strong></p><p id="b01c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Stopwatch2.java</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8b0e" class="lf lg iq lb b gy lh li l lj lk">public class Stopwatch2 {<br/>    private long offset, currentStart;<br/>    private boolean isStopped;<br/>    public Stopwatch2()<br/>    {<br/>        offset = 0L;<br/>        currentStart = System.<em class="np">currentTimeMillis</em>();<br/>        isStopped = true;<br/>    }<br/>    public void start()<br/>    {<br/>        if(isStopped)<br/>            currentStart = System.<em class="np">currentTimeMillis</em>() - offset;<br/>        isStopped = false;<br/>    }<br/>    public void stop()<br/>    {<br/>        if(!isStopped)<br/>            offset = System.<em class="np">currentTimeMillis</em>() - currentStart;<br/>        isStopped = true;<br/>    }<br/>    public long getTime()<br/>    {<br/>        if(!isStopped)<br/>            return System.<em class="np">currentTimeMillis</em>() - currentStart;<br/>        else<br/>            return offset;<br/>    }<br/>    public boolean isStopped(){<br/>        return isStopped;<br/>    }<br/>}</span></pre><p id="92e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个类很简单。这里没有使用任何重物。</p><p id="a457" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">StopwatchSwing2.java</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ca4b" class="lf lg iq lb b gy lh li l lj lk">import javax.swing.*;<br/>import java.awt.*;<br/>import java.awt.event.ActionEvent;<br/>import java.awt.event.ActionListener;<br/><br/>public class StopwatchSwing2 implements Runnable {<br/>    Stopwatch2 sw;<br/><br/>    <em class="np">// UI Widgets<br/>    </em>JFrame frame;<br/>    JPanel panel1, panel2;<br/>    JLabel timerDisplay;<br/>    JButton start, stop;<br/><br/>    final int NOT_RUNNING=0, RUNNING=1, PAUSED=2;<br/>    int currentState;<br/><br/>    Thread th;<br/><br/>    public StopwatchSwing2()<br/>    {<br/>        currentState = NOT_RUNNING;<br/><br/>        <em class="np">// Initializing the JFrame<br/>        </em>frame = new JFrame("Stopwatch");<br/>        frame.setSize(300,300);<br/>        frame.setMinimumSize(new Dimension(300,300));<br/>        frame.setLayout(new GridLayout(2,1));<br/>        frame.setDefaultCloseOperation(JFrame.<em class="np">EXIT_ON_CLOSE</em>);<br/><br/>        <em class="np">// Setting Up Panels<br/>        </em>panel1 = new JPanel();<br/>        panel1.setLayout(new FlowLayout(FlowLayout.<em class="np">CENTER</em>, 0, 50));<br/><br/>        timerDisplay = new JLabel("Time: "+formatTime(0L));<br/>        Font font = timerDisplay.getFont();<br/>        timerDisplay.setFont(new Font(font.getFontName(), font.getStyle(), 18));<br/><br/>        panel1.add(timerDisplay);<br/><br/><br/>        panel2 = new JPanel();<br/>        panel2.setLayout(new FlowLayout(FlowLayout.<em class="np">CENTER</em>));<br/>        start = new JButton("Start");<br/>        stop = new JButton("Stop");<br/>        stop.setVisible(false);<br/>        panel2.add(start);<br/>        panel2.add(stop);<br/><br/>        frame.add(panel1);<br/>        frame.add(panel2);<br/><br/><br/>        <em class="np">// Adding Listeners to the Buttons<br/><br/>        </em>start.addActionListener(new ActionListener() {<br/>            @Override<br/>            public void actionPerformed(ActionEvent e) {<br/>                handleStartPress();<br/>            }<br/>        });<br/><br/>        stop.addActionListener(new ActionListener() {<br/>            @Override<br/>            public void actionPerformed(ActionEvent e) {<br/>                handleStopPress();<br/>            }<br/>        });<br/>        frame.setVisible(true);<br/>    }<br/><br/>    private void handleStartPress(){<br/>        if(currentState==NOT_RUNNING)<br/>        {<br/>            sw =  new Stopwatch2();<br/>            th = new Thread(this);<br/>            sw.start();<br/>            th.start();<br/>            start.setText("Pause");<br/>            stop.setVisible(true);<br/>            currentState=RUNNING;<br/>        }<br/>        else if(currentState==RUNNING)<br/>        {<br/>            th = null;<br/>            sw.stop();<br/><br/>            start.setText("Resume");<br/>            currentState=PAUSED;<br/>        }<br/>        else if(currentState==PAUSED)<br/>        {<br/>            sw.start();<br/>            th = new Thread(this);<br/>            th.start();<br/>            start.setText("Pause");<br/>            currentState=RUNNING;<br/>        }<br/>    }<br/>    private void handleStopPress()<br/>    {<br/>        th=null;<br/>        if(sw!=null)<br/>            sw.stop();<br/>        sw = null;<br/>        timerDisplay.setText("Time: 000");<br/>        start.setText("Start");<br/>        stop.setVisible(false);<br/>        currentState=NOT_RUNNING;<br/>    }<br/><br/>    String formatTime(long time)<br/>    {<br/>        int time1 = (int)time;<br/>        int milis=0, secs = 0, minutes = 0, hours = 0;<br/>        String formattedTime="";<br/><br/>        milis = time1%1000;<br/>        time1 = time1 / 1000;<br/>        secs = time1 % 60;<br/>        time1 = time1 / 60;<br/>        minutes = time1 % 60;<br/>        time1 = time1 / 60;<br/>        hours = time1 % 60;<br/><br/>        formattedTime = String.<em class="np">format</em>("%02d", secs) + ":" +String.<em class="np">format</em>("%03d", milis);<br/>        if(minutes&gt;0)<br/>            formattedTime = String.<em class="np">format</em>("%02d", minutes) + ":" + formattedTime;<br/>        if(hours&gt;0)<br/>            formattedTime = String.<em class="np">format</em>("%02d", hours) + ":" + formattedTime;<br/>        return formattedTime;<br/><br/>    }<br/>    public static void main(String[] args) {<br/>        SwingUtilities.<em class="np">invokeLater</em>(new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                new StopwatchSwing2();<br/>            }<br/>        });<br/>    }<br/><br/>    @Override<br/>    public void run() {<br/>        while(sw!=null &amp;&amp; !sw.isStopped())<br/>        {<br/>            timerDisplay.setText("Time: "+ formatTime(sw.getTime()));<br/>            try {<br/>                Thread.<em class="np">sleep</em>(10);<br/>            } catch (InterruptedException e) {<br/>                e.printStackTrace();<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="2ebc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">乍一看，您可能会说这段代码比我们实现设计模式的代码要少得多。你是对的，但是看看我们展示代码的方式。一个月后当我回到这里时，我甚至会忘记我写了什么。一切都是非结构化的，一切都是手动的。</p><p id="95ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是设计模式的美妙之处，我很高兴能够让您清楚地了解如何在现实应用中使用它们。</p><h1 id="5be4" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">完整代码:</h1><p id="fa6a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">完整的代码在这里。</p><h1 id="c73b" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">参考资料:</h1><ul class=""><li id="9f89" class="mn mo iq ka b kb mi kf mj kj nr kn ns kr nt kv ms mt mu mv bi translated">书籍:<a class="ae mw" href="https://www.oreilly.com/library/view/head-first-design/0596007124/" rel="noopener ugc nofollow" target="_blank"> Head First设计模式</a>，作者埃里克弗里曼、伊丽莎白罗布森、伯特贝茨、凯西塞拉。</li></ul></div></div>    
</body>
</html>