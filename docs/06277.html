<html>
<head>
<title>Cache those API tokens (feat. Gfycat): Optimising Django: Part 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存那些API令牌(专长。Gfycat):优化Django:第6部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cache-those-api-tokens-feat-gfycat-optimising-django-part-6-cf493d978ef1?source=collection_archive---------7-----------------------#2020-11-10">https://levelup.gitconnected.com/cache-those-api-tokens-feat-gfycat-optimising-django-part-6-cf493d978ef1?source=collection_archive---------7-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4ad7cc21c670e249378030fa321f9714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wnq2knXquf7dynBl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约什·格劳泽在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="40d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接到第三方API时的一个常见任务是必须处理API令牌。通常，这些令牌最容易通过对API的单个客户端身份验证调用来获得。此外，它们有固定的寿命，需要你定期更新。如果没有任何缓存，您很可能会为每个服务调用创建一个新的令牌，从而导致许多冗余的令牌请求，进而在不必要的API调用上浪费时间。</p><p id="f92a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将解释如何设置一个健壮的系统，该系统可以在您的服务器上自动缓存和更新API令牌。为此，我将使用Gfycat作为我的示例，因为它使用基于令牌的身份验证，并且其令牌的生命周期很短，只有一个小时(在撰写本文时)。想了解更多关于Gfycat开发者API的信息，你可以查看他们的网站，<a class="ae kc" href="https://developers.gfycat.com/api/" rel="noopener ugc nofollow" target="_blank">developers.gfycat.com</a>。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="298e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在我们继续之前…</h1><p id="443e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">本文假设您已经知道如何在Django服务器中缓存数据。如果你想了解更多，我已经在这里写了一篇关于这个的文章！撇开这个不谈，让我们开始吧。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="1c52" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">那么要点是什么呢？(适用于懒人)</h1><p id="0a06" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我知道你们中的一些人可能会先复制粘贴要点(我知道我会的)，所以在这里。不要担心，如果你对它的工作方式感兴趣，我会进一步解释，并确保它按照你需要的方式运行。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="2c01" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">这是怎么回事？</h1><p id="90e4" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">您会注意到该脚本被分解为3个函数:</p><ol class=""><li id="741b" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">获取和缓存令牌。我们大部分的注意力都会在这里。</li><li id="80b1" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">形成Gfycat头，它从第一个函数中获取令牌，以及</li><li id="fe62" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">一个简单的Gfycat API调用，通过它的ID获取Gfycat的数据，从第二个函数中获取所需的Gfycat头。</li></ol><p id="41e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更仔细地检查一下<code class="fe nk nl nm nn b">get_gfycat_auth_header</code>。</p><pre class="ml mm mn mo gt no nn np nq aw nr bi"><span id="4ce6" class="ns lj iq nn b gy nt nu l nv nw">def get_gfycat_auth_header():<br/>    token = cache.get(GFYCAT_TOKEN_CACHE_KEY)<br/>    if not token:<br/>        # Get the token!<br/>        data = {<br/>            'client_id': settings.GFYCAT_API_KEY,<br/>            'client_secret': settings.GFYCAT_API_SECRET,<br/>            'grant_type': 'client_credentials'<br/>        }<br/>        resp = requests.post(GFYCAT_TOKEN_URL,<br/>                             data=json.dumps(data))<br/>        if resp.status_code &lt; 300:<br/>            resp_data = resp.json()<br/>            token = resp_data['access_token']<br/>            cache.set(GFYCAT_TOKEN_CACHE_KEY, token,<br/>                      resp_data['expires_in'])<br/>        else:  # bad things have happened, error handling goes here.<br/>            return None<br/>    return {'Authorization': 'Bearer {}'.format(token)}</span></pre><p id="6cb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数执行以下操作:</p><ol class=""><li id="cc3c" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">如果缓存的令牌已经存在，请尝试获取它。如果令牌在那里，就返回它。如果没有，</li><li id="2e74" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">使用API密钥和秘密，对Gfycat进行适当的API调用。如果调用有效，缓存令牌并返回它。</li></ol><p id="bf2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果由于某种原因，错误经常发生，您可能希望添加错误处理。否则你应该完成这一部分。</p><p id="0b4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正在执行的一个关键操作是缓存超时。这是从客户端auth响应中获得的，通常以秒为单位(在Gfycat的例子中，超时值是在<code class="fe nk nl nm nn b">'expires_in'</code>键下给出的。</p><pre class="ml mm mn mo gt no nn np nq aw nr bi"><span id="6c17" class="ns lj iq nn b gy nt nu l nv nw">cache.set(GFYCAT_TOKEN_CACHE_KEY,  # Cache key<br/>          token,                   # Token value<br/>          resp_data['expires_in']) # Timeout (taken from response)</span></pre><p id="5a7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置超时值可确保令牌仅在前一个过期后生成。</p><p id="89bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令牌超时通常以秒为单位给出，但是如果它以其他形式给出，比如时间戳，或者根本没有给出，那么您必须相应地调整这个段。</p><h1 id="897a" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">什么使这成为一个好的解决方案？</h1><p id="a0d4" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">首先，获得令牌的网络成本虽然很小，但也不是微不足道的。生成一个令牌可能不需要整整一分钟(如果您每小时都在重建一个大的缓存，可能会出现这种情况！)，但是如果没有这个解决方案，您每次调用第三方API的往返时间会增加大约20-100ms。</p><p id="e574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过添加一个小的缓存值，我们可以消除大部分额外的开销。为这样的效率提高付出一点点代价绝对值得努力实现，尤其是如果您的服务频繁使用API的话。</p><h1 id="25db" class="li lj iq bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">感谢您阅读本文！</h1><p id="be51" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">正如您在“第6部分”中看到的，我已经写了几篇关于如何提高Django服务器性能的文章。如果你想知道如何提高你的Django管理性能，<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-multiple-massive-tables-in-a-single-admin-optimizing-django-part-3-2c4ee2fec142?source=friends_link&amp;sk=96a35d8e435719670b356ca4c4606c1c">点击这里。</a>或者如果你想了解n+1问题以及如何解决它，<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=your_stories_page-------------------------------------">点击这里！</a></p></div></div>    
</body>
</html>