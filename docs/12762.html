<html>
<head>
<title>Scale your Apps using KEDA in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes中的KEDA扩展您的应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scale-your-apps-using-keda-in-kubernetes-a1f2142ecc20?source=collection_archive---------1-----------------------#2022-07-06">https://levelup.gitconnected.com/scale-your-apps-using-keda-in-kubernetes-a1f2142ecc20?source=collection_archive---------1-----------------------#2022-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7674" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp kq kr bm ks kt ku kv kw di"> K </span> <strong class="js iu"> EDA </strong>(或者，<strong class="js iu"> Kubernetes事件驱动自动缩放</strong>)是一个基于Kubernetes事件驱动的Pods自动缩放器。有了KEDA，我们可以轻松地扩展我们的应用程序，然后回退到0，这在Kubernetes的默认HPA(水平Pod自动缩放器)中是不可能的。对于HPA，我们只能将其降低到1个pod，而不是0个，因为只有CPU &amp;内存提供度量支持。然而，KEDA拥有强大的外部指标/服务支持，可以作为事件源，提供事件数据来扩展应用程序。例如，我们可以有<strong class="js iu"> KEDA </strong> <strong class="js iu">缩放器</strong>像AWS SQS、Datadog、RabbitMQ、Kafka、CloudWatch、DynamoDB、Elasticsearch等等。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/ef08732da1cb03be9f7f7e43f82755c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eJfIjtEX-j06ai-T.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">KEDA</figcaption></figure><p id="dc40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与简单的Kubernetes HPA相比，KEDA的主要优势在于</p><ol class=""><li id="1b14" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn ls lt lu lv bi translated">支持用于扩展的多个指标/事件</li><li id="15c7" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">吊舱可以缩小到零</li></ol><h2 id="fd28" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">建筑:</h2><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mu"><img src="../Images/9d003cf91d1466f1035a3d762f47e935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v2Ev4YfLlUoV74P_.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">科达</figcaption></figure><p id="78c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将看到如何使用KEDA来根据在AWS SQS(简单队列服务)中收到的消息，扩展在AWS EKS(弹性Kubernetes服务)中运行的应用程序。</p><h2 id="dee8" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">步骤1:创建一个EKS集群(可选，以防集群不可用)</h2><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="d6ab" class="mb mc it mw b gy na nb l nc nd">apiVersion: eksctl.io/v1alpha5<br/>kind: ClusterConfig<br/>metadata:<br/> name: eks-keda-test<br/> region: us-east-2<br/> version: '1.21'<br/>managedNodeGroups:<br/> - name: ng<br/>   instanceType: m4.xlarge<br/>   minSize: 1<br/>   maxSize: 2</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ne"><img src="../Images/5edbaee624e5e572e7d5af5fb0133240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVeAncnkS-L6zmbeNO4jog.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">AWS EKS集群</figcaption></figure><h2 id="9a6c" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">步骤2:使用Helm在Kubernetes中安装KEDA</h2><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="0b38" class="mb mc it mw b gy na nb l nc nd">#Adding the Helm repo<br/>helm repo add kedacore <a class="ae nf" href="https://kedacore.github.io/charts" rel="noopener ugc nofollow" target="_blank">https://kedacore.github.io/charts</a></span><span id="d9a4" class="mb mc it mw b gy ng nb l nc nd">#Update the Helm repo<br/>helm repo update</span><span id="5c37" class="mb mc it mw b gy ng nb l nc nd">#Install Keda helm chart<br/>kubectl create namespace keda<br/>helm install keda kedacore/keda --namespace keda</span></pre><p id="8668" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查KEDA运算符和度量API服务器是否在KEDA命名空间中:-</p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="96ec" class="mb mc it mw b gy na nb l nc nd">kubectl get pod -n keda</span><span id="78ff" class="mb mc it mw b gy ng nb l nc nd">NAME                                               READY   STATUS    RESTARTS   AGE<br/>keda-operator-68cd48977c-swztq                     1/1     Running   0          23h<br/>keda-operator-metrics-apiserver-7d888bf9b5-s2fqs   1/1     Running   0          23h</span></pre><h2 id="60a8" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">步骤3:在Kubernetes集群中部署一个测试应用程序</h2><p id="5b3c" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">在这里，我用1个副本运行nginx部署</p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="858a" class="mb mc it mw b gy na nb l nc nd">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/> labels:<br/>  app: my-nginx<br/> name: my-nginx<br/>spec:<br/> replicas: 1<br/> selector:<br/>  matchLabels:<br/>   app: my-nginx<br/> strategy: {}<br/> template:<br/>   metadata:<br/>     labels:<br/>       app: my-nginx<br/>   spec:<br/>     containers:<br/>     - image: nginx<br/>       name: nginx<br/>       resources: {}<br/>       status: {}</span></pre><h2 id="903b" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">步骤4:创建一个AWS SQS队列(标准队列)</h2><p id="48b4" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">转到AWS控制台-&gt; AWS SQS并创建一个标准队列。复制其区域、队列URL</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nm"><img src="../Images/3d5a15deeaf0c4f01c37ad64eb47a93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYCknsWL0u0x0scs6zKccw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">AWS SQS —标准队列</figcaption></figure><h2 id="3efa" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">步骤5:使用ScaledObject创建KEDA缩放器(SQS)</h2><p id="7c3e" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated"><em class="nn">(注意，基于KEDA SQS Scaler的不同类型的集成Scaler(比如CloudWatch，Datadog等)，请参考官方文档</em> <a class="ae nf" href="https://keda.sh/docs/2.7/deploy/" rel="noopener ugc nofollow" target="_blank"> <em class="nn">这里</em> </a> <em class="nn">。)</em></p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="5e5f" class="mb mc it mw b gy na nb l nc nd">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/> name: aws-sqs-queue-scaledobject<br/> namespace: default<br/>spec:<br/> scaleTargetRef:<br/>   name: my-nginx<br/> pollingInterval: 5 #Interval for polling<br/> cooldownPeriod: 10<br/> idleReplicaCount: 0 # When idle, scale-in to 0 pods<br/> minReplicaCount: 1<br/> maxReplicaCount: 3<br/> fallback: # Fallback strategy when metrics are unavailable for the apps<br/> failureThreshold: 5 #when metrics are unavailable, match the desired state of replicas -&gt; 2<br/>replicas: 2 #Keep this desired state when metrics are unavailable<br/>triggers:<br/>- type: aws-sqs-queue<br/>  authenticationRef:<br/>    name: keda-trigger-auth-aws-credentials<br/>  metadata:<br/>    queueURL: <a class="ae nf" href="https://sqs.us-east-2.amazonaws.com/711164302624/my-sqs-keda" rel="noopener ugc nofollow" target="_blank">https://sqs.us-east-2.amazonaws.com/711164302624/my-sqs-keda</a><br/>    queueLength: "5" #batch size<br/>    awsRegion: "us-east-2"<br/>    identityOwner: operator #when node role has required permission</span></pre><p id="3910" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">KEDA既支持<strong class="js iu"> ScaledObjects </strong>(比如Kubernetes部署、StatefulSet、自定义资源)也支持<strong class="js iu"> ScaledJobs ( </strong>比如Kubernetes Job)。上面的例子是基于ScaledObject进行部署的。</p><p id="4cba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的ScaledObject中，有几件事需要注意</p><ol class=""><li id="78c3" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn ls lt lu lv bi translated">ScaledObject将在默认的名称空间中创建</li><li id="a6fe" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">它将管理名为'<strong class="js iu"> my-nginx </strong>'的部署</li><li id="62bd" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">事件源是AWS SQS，队列URL为<a class="ae nf" href="https://sqs.us-east-2.amazonaws.com/711164302624/my-sqs-keda" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">https://SQS . us-east-2 . amazonaws . com/711164302624/my-SQS-keda</strong></a>在地区<strong class="js iu"> us-east-2 </strong>。注意，您也可以给出队列名称。如果有任何歧义，最好使用URL。</li><li id="0ed9" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">队列长度为<strong class="js iu"> 5 </strong>,这意味着一旦5条消息的批量到达队列，它将被触发。</li><li id="4162" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">身份所有者是<strong class="js iu">操作员</strong>(或者默认为<strong class="js iu"> pod </strong>)，这意味着EKS节点角色应该有与SQS通信的权限。所需的策略是附加到其节点角色的<strong class="js iu"> sqs:GetQueueAttributes </strong>。</li><li id="634a" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated"><strong class="js iu"> idleReplicaCount </strong>为0，这使pod在空闲时降至0</li></ol><h2 id="09f5" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">步骤6:创建KEDA触发器身份验证(可选)</h2><p id="9287" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">如果KEDA操作员要求对源事件(在我的例子中是SQS)进行认证，那么我们需要遵循以下认证机制之一</p><p id="fdc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.1) <strong class="js iu">使用附加到EKS节点的IAM角色— </strong>这是最简单的方法，创建一个<strong class="js iu"> sqs:GetQueueAttributes </strong>的IAM策略，然后将它与现有/新的IAM角色一起附加到节点实例。我们需要确保在ScaledObject中将I<strong class="js iu">identity owner</strong>作为<strong class="js iu"> operator </strong>(我上面的例子就是这样)。这使得KEDA可以访问SQS来获取度量数据。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi no"><img src="../Images/0cf1580ad07da6be8273a2bf55da68a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zL5n5xFhIYoKjB7FAGmxoQ.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">IAM策略</figcaption></figure><p id="3f0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.2) <strong class="js iu">使用IAM用户凭证</strong> —在这里，我们需要在AWS中创建一个IAM用户，在Kubernetes中创建一个密码，在Kubernetes中创建一个TriggerAuthentication，并在Kubernetes中的ScaledObject中使用这个TriggerAuthentication，如下所示</p><p id="ea28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(a)在AWS中创建一个IAM用户，其策略是访问SQS。记下它的Base64编码版本的访问和秘密访问密钥，并使用它来创建秘密。</p><p id="8d06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(b)用IAM用户的BASE64编码访问和秘密访问密钥在Kubernetes中创建一个秘密</p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="1a4a" class="mb mc it mw b gy na nb l nc nd">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: iam-user-secret<br/>  namespace: default<br/>data:<br/>  AWS_ACCESS_KEY_ID: &lt;base64-encoded-key&gt;<br/>  AWS_SECRET_ACCESS_KEY: &lt;base64-encoded-secret-key&gt;</span></pre><p id="d486" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建触发身份验证</p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="eab0" class="mb mc it mw b gy na nb l nc nd">apiVersion: keda.sh/v1alpha1<br/>kind: TriggerAuthentication<br/>metadata:<br/>  name: keda-trigger-auth-aws-credentials<br/>  namespace: default<br/>spec:<br/>  secretTargetRef:<br/>  - parameter: awsAccessKeyID     # Required.<br/>    name: iam-user-secret         # Required.<br/>    key: AWS_ACCESS_KEY_ID        # Required.<br/>  - parameter: awsSecretAccessKey # Required.<br/>    name: test-secrets            # Required.<br/>    key: AWS_SECRET_ACCESS_KEY    # Required.</span></pre><p id="aec0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(d)使用TriggerAuthentication创建ScaledObject</p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="c098" class="mb mc it mw b gy na nb l nc nd">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: aws-sqs-queue-scaledobject<br/>  namespace: default<br/>spec:<br/>  scaleTargetRef:<br/>    name: my-nginx<br/>  minReplicaCount: 0<br/>  maxReplicaCount: 2<br/>  triggers:<br/>  - type: aws-sqs-queue<br/>    authenticationRef:<br/>      name: keda-trigger-auth-aws-credentials<br/>    metadata:<br/>      queueURL: <a class="ae nf" href="https://sqs.us-east-2.amazonaws.com/711164302624/my-sqs-keda" rel="noopener ugc nofollow" target="_blank">https://sqs.us-east-1.amazonaws.com/012345678912/Queue</a><br/>      queueLength: "5"<br/>      awsRegion: "us-east-2"</span></pre><p id="7e12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">瞧啊。现在都准备好了。来测试一下吧:)</p><h1 id="fdc1" class="np mc it bd md nq nr ns mg nt nu nv mj nw nx ny mm nz oa ob mp oc od oe ms of bi translated">演示时间:-</h1><p id="ae90" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated"><strong class="js iu">步骤1</strong>——将部署保持在观察模式</p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="601a" class="mb mc it mw b gy na nb l nc nd">kubectl get deploy --watch</span><span id="fd38" class="mb mc it mw b gy ng nb l nc nd">NAME       READY   UP-TO-DATE   AVAILABLE   AGE<br/>my-nginx   0/0     0            0           4h52m</span></pre><p id="ef86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">步骤2 </strong> —将一些消息添加到SQS队列中(注意，将超过5条消息放入队列中，因为ScaledObject中给定的批处理大小是5)</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi og"><img src="../Images/cbfab8e83a9c45e19095aadd137db5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kgjr4QJygMbTc9wNVcqc9A.png"/></div></div></figure><h2 id="493b" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">结果:-</h2><p id="82cc" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">当消息到达队列时，KEDA自动将应用程序扩展到2个副本。</p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="7437" class="mb mc it mw b gy na nb l nc nd">NAME       READY   UP-TO-DATE   AVAILABLE   AGE<br/>my-nginx   0/0     0            0           4h52m<br/>my-nginx   0/1     0            0           4h54m<br/>my-nginx   0/1     0            0           4h54m<br/>my-nginx   0/1     0            0           4h54m<br/>my-nginx   0/1     1            0           4h54m<br/>my-nginx   1/1     1            1           4h54m<br/>my-nginx   1/2     1            1           4h54m<br/>my-nginx   1/2     1            1           4h54m<br/>my-nginx   1/2     1            1           4h54m<br/>my-nginx   1/2     2            1           4h54m<br/>my-nginx   2/2     2            2           4h54m</span></pre><p id="0d0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在空闲状态下过一会儿，pod将自动按比例缩小到0。</p><pre class="ky kz la lb gt mv mw mx my aw mz bi"><span id="33ed" class="mb mc it mw b gy na nb l nc nd">my-nginx   0/0     0            0           4h57m</span></pre><h1 id="2c79" class="np mc it bd md nq nr ns mg nt nu nv mj nw nx ny mm nz oa ob mp oc od oe ms of bi translated">总结:</h1><p id="3b48" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">在本文中，我们看到了如何使用KEDA根据外部指标/事件，尤其是基于AWS SQS队列中的消息，将我们的应用程序从0个副本扩展到“n”个副本。</p><p id="d604" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和往常一样，您可以在GitHub链接中找到本文中使用的全部源代码</p><p id="2e65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae nf" href="https://github.com/vinod827/k8s-nest/tree/main/iac/aws/eks/keda" rel="noopener ugc nofollow" target="_blank">https://github . com/vinod 827/k8s-nest/tree/main/IAC/AWS/eks/ked</a>a</p><p id="94ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随时分叉这个项目，并添加更多的IaC(基础设施作为代码)，反馈，在它的问题。</p><h1 id="cce6" class="np mc it bd md nq nr ns mg nt nu nv mj nw nx ny mm nz oa ob mp oc od oe ms of bi translated">参考:</h1><p id="ab1f" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated"><a class="ae nf" href="https://keda.sh/docs/2.7/deploy/" rel="noopener ugc nofollow" target="_blank">https://keda.sh/docs/2.7/deploy/</a></p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="1639" class="np mc it bd md nq oo ns mg nt op nv mj nw oq ny mm nz or ob mp oc os oe ms of bi translated">分级编码</h1><p id="2a95" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">感谢您成为我们社区的一员！更多内容请参见<a class="ae nf" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae nf" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae nf" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae nf" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="js iu">升一级正在改造理工大招聘➡️ </strong> <a class="ae nf" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>