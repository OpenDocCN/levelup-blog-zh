<html>
<head>
<title>Parallel Tasks in a Non-Blocking System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非阻塞系统中的并行任务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/parallel-tasks-in-a-non-blocking-system-66c195aba56d?source=collection_archive---------11-----------------------#2021-01-26">https://levelup.gitconnected.com/parallel-tasks-in-a-non-blocking-system-66c195aba56d?source=collection_archive---------11-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec78" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用Project Reactor的线程/非阻塞混合模型。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3af28d8eb2068b6ca40b814427fde643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZNuGoiQDcUhrSrRVb9drQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1391681" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/hpgruesen-2204343/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1391681" rel="noopener ugc nofollow" target="_blank"> Erich Westendarp </a></figcaption></figure><p id="7f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般在Node.js和JavaScript中，只有一个线程(虽然我觉得Node.js新版本允许线程？).这带来了如何处理异步调用的整个生态系统，从async/await到基本承诺和低级回调。当Java通过像<a class="ae ky" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> Project Reactor </a>这样的框架加入非阻塞异步处理时，它坚持使用非阻塞I/O和线程的混合模型来实现并发。线程被烤成了Java馅饼，没有办法摆脱它们。</p><p id="f723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是Project Reactor提供了一组非常丰富的方法来处理并发性，而不必处理诸如执行器或裸线程之类的低级构造。在我的上一篇文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/creating-a-flux-of-fluxes-with-project-reactors-group-by-method-37200bfc2a?source=your_stories_page-------------------------------------">通过方法</a>用Project Reactor的组创建Flux of Fluxes中，我通过在不同类型上执行三个不同的处理函数，然后将它们与处理结果连接在一起，从而谈到了并发性。</p><p id="2311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，假设您必须并行运行三个不同的任意任务，并让它们将每个并行轨道的输出合并到一个项目中，以便进一步处理。只要所有的任务都返回一个给出每个任务结果的<code class="fe lv lw lx ly b">Mono&lt;T&gt;</code>，其中<code class="fe lv lw lx ly b">T</code>是某种类型(或者基于单个接口<code class="fe lv lw lx ly b">T</code>的不同类型)，你就可以很容易地使用<code class="fe lv lw lx ly b">Flux.combineLatest</code>变体之一来完成任务。</p><p id="b789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将继续使用我在以前的文章中整理的二手车系统来演示您将如何做这件事。我将关注从消息队列接收<code class="fe lv lw lx ly b">Vehicle.Car</code>类型并对其做进一步处理的服务。在第一次迭代中，它通过查询数据库，添加汽车应该存放的“lot ”,并简单地记录汽车的收据，来检查汽车是否有相应的采购订单。下面是实现这一点的代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c004" class="md me it ly b gy mf mg l mh mi">Receiver carReceiver = RabbitFlux.createReceiver(roptions);<br/>carReceiver<br/>  .consumeAutoAck(CAR_QUEUE_NAME)<br/>  .timeout(Duration.ofSeconds(10))<br/>  .doFinally((s) -&gt; {<br/>          log("Car consumer in finally for signal " + s);<br/>          carReceiver.close();<br/>          sender.close();<br/>  })<br/>  .map(j -&gt; readCarJson(new String(j.getBody())))<br/>  .flatMap(o -&gt; Mono.justOrEmpty(o))<br/>  .flatMap(v -&gt; reactiveCollection<br/>     .get(v.getPo().getId())<br/>     .doOnNext(j -&gt; log("po for car " <br/>              + v.getPo().getId() <br/>              + " confirmed"))<br/>     .map(j -&gt; v)<br/>     .single()<br/>     .onErrorReturn(v))<br/>  .map(c -&gt; new Vehicle.Car(c.getPo(),"car lot a"))<br/>  .subscribe(c -&gt; log("received car " + c));</span></pre><p id="9be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这没有意义，您可能应该回到我在本系列中的原始文章,<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-reactive-java-e8aaee9a204b?source=your_stories_page-------------------------------------">理解反应式Java </a>来复习一下。</p><p id="3c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一部分是确认汽车采购订单的部分:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b125" class="md me it ly b gy mf mg l mh mi">.flatMap(v -&gt; reactiveCollection<br/>          .get(v.getPo().getId())<br/>          .doOnNext(j -&gt; log("po for car " <br/>              + v.getPo().getId() <br/>              + " confirmed"))<br/>          .map(j -&gt; v)<br/>          .single()<br/>          .onErrorReturn(v))</span></pre><p id="e8a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想改变这一点，以便在将汽车对象插入另一个数据库的同时完成确认。我将假设，如果在数据库中找不到采购订单，验证不应该停止处理，而应该记录日志或做其他事情。所以我可以并行运行这两个任务。为了使代码更容易阅读，我将读取和写入数据库，并将它们放入自己的函数中。这是我想到的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6b68" class="md me it ly b gy mf mg l mh mi">private static Mono&lt;Vehicle.Car&gt; verifyCar(Vehicle.Car car) {<br/>  return poReactiveCollection<br/>     .get(car.getPo().getId())<br/>     .doOnNext(c -&gt; log("po for car " <br/>         + car <br/>         + " confirmed"))<br/>     .doOnError((t) -&gt; log("error verifying car"))<br/>     .map(j -&gt; car)<br/>     .single()<br/>     .onErrorReturn(car);<br/>    }<br/>    <br/>private static Mono&lt;Vehicle.Car&gt; writeCar(Vehicle.Car car) {<br/>  return carReactiveCollection<br/>     .upsert(car.getPo().getId(), car)<br/>     .doOnNext(c -&gt; log("inserted car " <br/>         + car <br/>         + " into car database"))<br/>     .doOnError((t) -&gt; log("error inserting car"))<br/>     .map(j -&gt; car)<br/>     .single()<br/>     .onErrorReturn(car);<br/>}</span></pre><p id="1268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写车和看订单很像，只是作用于不同的集合。为了简单起见，除了日志之外，不提供任何错误处理。在这两个函数中，返回类型都是<code class="fe lv lw lx ly b">Mono&lt;Vehicle.Car&gt;</code>。</p><p id="5efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们如何将这些并行运行呢？我们将修改原始代码，并更改如下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="79f8" class="md me it ly b gy mf mg l mh mi">   .flatMap(v -&gt; reactiveCollection<br/>...</span></pre><p id="dde1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新代码将如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bc65" class="md me it ly b gy mf mg l mh mi">.flatMap(v -&gt; Flux.combineLatest((r) -&gt; r[0], <br/>                   verifyCar(v), <br/>                   writeCar(v)))</span></pre><p id="707b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们将使用版本的<code class="fe lv lw lx ly b">Flux.combineLatest</code>，它采用一个合并函数和一个<code class="fe lv lw lx ly b">Publisher</code>类型的变量列表，并返回一个<code class="fe lv lw lx ly b">Flux</code>。由于<code class="fe lv lw lx ly b">Publisher</code>接口是由<code class="fe lv lw lx ly b">Mono</code>和<code class="fe lv lw lx ly b">Flux</code>实现的，我们可以使用方法<code class="fe lv lw lx ly b">verifyCar</code>和<code class="fe lv lw lx ly b">writeCar</code>，因为它们都返回<code class="fe lv lw lx ly b">Mono&lt;Vehicle.Car&gt;</code>。<code class="fe lv lw lx ly b">flatMap</code>将移除外部的<code class="fe lv lw lx ly b">Flux</code>，因此我们回到<code class="fe lv lw lx ly b">Flux&lt;Vehicle.Car&gt;</code>作为流程项目。</p><p id="5fbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">merge函数将一个项目数组作为参数，并返回一些其他项目作为结果。数组中的项目数由传入的变量<code class="fe lv lw lx ly b">Publisher</code>对象数决定。在我们的例子中，数组是一个由<code class="fe lv lw lx ly b">Vehicle.Car</code>对象组成的数组，它只返回数组中的第一个项目，因为所有的<code class="fe lv lw lx ly b">Publisher</code>对象都返回相同的<code class="fe lv lw lx ly b">Mono&lt;Vehicle.Car&gt;</code>。如果您看一下日志，您可以看到每个<code class="fe lv lw lx ly b">Publisher</code>在一个单独的线程上运行:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="61d2" class="md me it ly b gy mf mg l mh mi">cb-io-kv-5-3 inserted car Vehicle(po=PurchaseOrder(id=6470945cca029936, price=92071.46, type=Car, time=2021-01-23T19:44:40.885663Z), lot=car lot a) into car database<br/>cb-io-kv-5-2 po for car Vehicle(po=PurchaseOrder(id=6470945cca029936, price=92071.46, type=Car, time=2021-01-23T19:44:40.885663Z), lot=car lot a) confirmed</span></pre><p id="e03e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个线程都源自Couchbase。正在发生的是插入和查询操作被启动，然后链的其余部分在Couchbase驱动程序提供的线程上执行，当它返回一个结果时。这是因为Couchbase驱动程序是被动的。</p><p id="1026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您想要执行的任务没有反应库，会发生什么呢？有许多库在没有非阻塞替代方案的情况下执行阻塞操作。答案是，您可以很容易地将阻塞操作转换成一个<code class="fe lv lw lx ly b">Mono</code>，然后可以在与非阻塞任务相同的流程中对其进行处理。</p><p id="7c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们创建一个名为“浪费时间”的任务，睡眠50毫秒。为了并行运行它，您将它包装在一个Mono中，并将其分配给一个调度程序在另一个线程上运行。这是我想到的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="db23" class="md me it ly b gy mf mg l mh mi">private static Mono&lt;Vehicle.Car&gt; wasteTime(Vehicle.Car car) {<br/>   return Mono.fromCallable(() -&gt; { <br/>      Thread.sleep(50);<br/>      return car;<br/>   })<br/>   .subscribeOn(Schedulers.boundedElastic())<br/>   .doOnNext(c -&gt; log("wasting time on car " + c));<br/>}</span></pre><p id="b016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以将它添加到要并行运行的<code class="fe lv lw lx ly b">Publisher</code>对象列表中:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4457" class="md me it ly b gy mf mg l mh mi">.flatMap(v -&gt; Flux.combineLatest((r) -&gt; r[0], <br/>    verifyCar(v), <br/>    writeCar(v), <br/>    wasteTime(v)))</span></pre><p id="fd8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回类型仍然只是第一个发布者的返回，<code class="fe lv lw lx ly b">verifyCar</code>。现在，如果我们查看日志，我们可以看到浪费时间完全是在另一个线程上执行的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d043" class="md me it ly b gy mf mg l mh mi">boundedElastic-7 wasting time on car Vehicle(po=PurchaseOrder(id=36ef40d5b598c2be, price=13969.15, type=Car, time=2021-01-23T19:44:40.885632Z), lot=car lot a)<br/>boundedElastic-7 received car Vehicle(po=PurchaseOrder(id=36ef40d5b598c2be, price=13969.15, type=Car, time=2021-01-23T19:44:40.885632Z), lot=car lot a)</span></pre><p id="18ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe lv lw lx ly b">boundedElastic-7</code>线程是执行最终subscribe lambda方法的线程。这应该让您了解调度程序是如何处理线程的；只要没有非阻塞调用介入，它就允许同一个线程继续处理链中的下一项。</p><p id="bba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在，您应该能够并行运行尽可能多的任务，只要它们都在相同的时间返回(可能是一些结果类型，可能包含特定于返回它的特定任务的信息)，并且它们都可以以某种合理的方式合并(在我们的例子中，我们采用了第一个，而放弃了另外两个)。合并的结果不必与输入数组的类型相同。</p><p id="871b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是本文附带的代码:</p><div class="mj mk gp gr ml mm"><a href="https://github.com/rkamradt/usedvehicles/tree/v0.3" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">rkamradt/二手车辆</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">在GitHub上创建一个帐户，为rkamradt/usedvehicles的开发做出贡献。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><p id="4a40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是本文提到的一些文章:</p><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-reactive-java-e8aaee9a204b"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">理解反应式Java</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">因为你的线程阻碍了我的表现。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mv l"><div class="nb l mx my mz mv na ks mm"/></div></div></a></div><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/creating-a-flux-of-fluxes-with-project-reactors-group-by-method-37200bfc2a"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">用Project Reactor的Group By方法创建通量通量</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">什么通量？</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mv l"><div class="nc l mx my mz mv na ks mm"/></div></div></a></div></div></div>    
</body>
</html>