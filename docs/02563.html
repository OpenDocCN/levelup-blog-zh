<html>
<head>
<title>How I trained a machine learning model to identify dog breeds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何训练一个机器学习模型来识别狗的品种</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-trained-a-machine-learning-model-to-identify-dog-breeds-7f3e8d406d35?source=collection_archive---------6-----------------------#2020-03-22">https://levelup.gitconnected.com/how-i-trained-a-machine-learning-model-to-identify-dog-breeds-7f3e8d406d35?source=collection_archive---------6-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1b7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇博文会告诉你所有你需要知道的自己动手做！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/23e9909ffd78ab6c85dae21f5860e5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BStrLZWZV_hcI50HtEgrsQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">模型做出的示例预测</figcaption></figure><p id="94f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用于这个项目的代码可以在Github库中找到。</p><p id="48ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">骨架代码由Udacity提供，作为数据科学Nanodegree的一部分。</p><h1 id="dfb7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">项目定义</h1><p id="4ff6" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这个项目中，我们希望创建一个深度学习模型，它可以接收一张狗的照片，并识别它是什么品种的狗。这是一个有趣的问题，因为如果成功，它可能有助于减少对大量未标记图像数据进行分类所需的人工工作量。</p><p id="f997" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了确定我们的模型是否成功，我们将考察我们的模型对未知数据的准确性。我们的模型将根据大部分数据进行训练，并尝试在测试数据中预测狗的品种。我们的精确度可以定义为:</p><p id="915d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(正确预测数)/(预测总数)</p><h1 id="ba6c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数据分析</h1><p id="2a92" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们可以访问包含133个不同品种的8351张狗图片的标签数据集。确保每个品种都有相似数量的图像是很重要的。下面的直方图显示了每个品种的图片数量。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/41c5fef42911f540160ba0a6a4ffe968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zj48RATr71fyBw6wnuYI-w.png"/></div></div></figure><p id="a4eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有品种都有33到96张图片。理想情况下，我们希望所有的品种都有相同数量的照片，但是对于我们的目的来说，这种分布是令人满意的。</p><h1 id="e478" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数据预处理</h1><p id="ed5e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们的图像需要转换成深度学习模型可以解释的数字格式。为此，我们执行以下步骤:</p><ul class=""><li id="7aee" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">从文件路径加载图像，并将其大小调整为224 x 224像素。</li><li id="345d" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">将其转换为形状为(224，224，3)的3D张量，其中3个值表示像素的RGB值。</li><li id="cf31" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">将其转换为形状为(1，224，224，3)的4D张量，以便深度学习模型可以正确解释它。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/fa98a82715db64beb60244ad2f827862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eq_y8udKcnJQaIWSiQj2CA.png"/></div></div></figure><h1 id="5104" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">履行</h1><p id="7e17" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这个项目中，我们研究了两种方法。首先，我们从头开始创建自己的CNN来对狗的品种进行分类。在此之后，我们采用ResNet50预训练模型，并应用迁移学习来允许它从我们的数据集中对狗的品种进行分类。</p><h2 id="14c9" class="my lg it bd lh mz na dn ll nb nc dp lp kb nd ne lt kf nf ng lx kj nh ni mb nj bi translated">CNN从零开始</h2><p id="d5e4" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们首先通过运行以下代码初始化我们的模型:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/48c1f05ec5b6b243f5fc86950e042985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcFuebZJ-rX0X0TzioQZow.png"/></div></div></figure><p id="8759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦完成了这些，我们就可以使用“model.add(…)”向我们的深度学习模型添加层。我们遵循Udacity笔记本中的模型示例，代码如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/1f68d2712c76c7b97a50a8b44d1cb664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNH3aoK2lO09qKQb_-xmgg.png"/></div></div></figure><p id="c95f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这给我们留下了下面的模型总结:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/3fc90dc9ab142d85b36084fd08a30f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bhlbZpAGb1_-MF0VkKVFg.png"/></div></div></figure><p id="23bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们这里有四种不同的图层类型，其中一些已经使用了多次。</p><ul class=""><li id="57fd" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">conv2d是一个标准的卷积层，它采用一组平方值，并将每个值乘以一个核值，以给出一个单一数字的输出，供下一层使用。这是从图像中提取特征的主要方法，因为可以用它来检测边缘和形状。</li><li id="29f2" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">max_pooling_2d通过从一组方形像素中获取最大值来移除小值。</li><li id="d98b" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">global_average_pooling2d取27 x 27 x 64并取27 x 27切片的平均值，以给出形状为(1，1，64)的张量，该张量被整形为大小为64的1D向量。这用于显著减少训练模型所需的参数数量，而不会丢失太多信息</li><li id="c71b" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">最后，我们应用一个稠密层，它给出了我们的最终预测。我们使用输出大小为133的“softmax”激活。这将给我们133个值，加起来等于1，代表133个品种中的每一个成为照片中所示品种的预测概率。</li></ul><p id="4e7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着我们的模型的创建，我们对其进行了5个时期的训练。一个时期是数据集的完整运行，因此模型将运行所有训练数据5次，并将最佳权重保存在hdf5文件中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/ca2bbd611510a15ad376c00d0941f79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lB-u5c5ZnUQu5ntA2mzSRg.png"/></div></div></figure><p id="38f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了评估模型，我们通过模型运行测试照片，看看哪个品种被预测，并将其与照片的真实情况进行比较。我们使用argmax函数取最大的预测概率来决定所选的品种。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi no"><img src="../Images/89bcc3cffd051829d9feda15b3c48f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJXN6xfiQmyYBUGHBKRuUQ.png"/></div></div></figure><p id="b0e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到有133种不同的品种，我们的基线模型仅仅猜测将会给我们0.75%的准确率。我们得到了1.9%的精度，这无疑是一个进步，但不是很好。</p><p id="652f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的主要缺点是我们必须花费大量的时间来设计和训练一个模型。在Udacity提供的GPU上训练这个模型只需要2分钟左右。如果有更多的时间来测试不同的层组合，调整参数和运行更复杂的模型，我们将能够获得更高的分数。</p><h2 id="525e" class="my lg it bd lh mz na dn ll nb nc dp lp kb nd ne lt kf nf ng lx kj nh ni mb nj bi translated">迁移学习</h2><p id="8105" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">但是，既然已经有非常好的模式可以利用，为什么还要付出那么多努力呢？迁移学习允许我们采用更通用的图像识别模型，并将其应用于我们特定的数据集和用例。这是一个关键的方法，可以让人们不费吹灰之力就训练出高质量的深度学习模型，所以让我们试一试。</p><p id="06de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先下载ResNet50模型，并获得用于训练或建模的瓶颈特征。我们使用与前面相同的命令实例化我们的模型，并向其中添加一个GlobalAveragePooling2D层。这将输入数据的要素转换为一个矢量，该矢量可输入到进行预测的完全连接的密集图层中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/775dcdcdc3838a076ba50a7d0971b96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhsDdQT6aLKtAP3C5l-Q5A.png"/></div></div></figure><p id="a9f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们训练这个迁移学习模型类似于我们之前的模型20个时期。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/688e04169d63bc2b8fb8fadaae22e7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsT0u2UO4CjuC6ZfobosJA.png"/></div></div></figure><p id="903b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这给了我们一个难以置信的提高，准确率达到了79.6%！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/f65dc516475835a7dfd5c1dc5e2dd8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieJkbcigqZoprRwb-XPKYA.png"/></div></div></figure><p id="9951" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">利用这一点，我创建了一个算法，可以识别是否有狗或人脸，然后尝试识别出现的是什么品种(或人类看起来最像什么品种)。下面是一些输出的例子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/17d35e1ca466c0e953b679f574ff6995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUqXfusAq6_JPhGWLzhhkA.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/58a76660f95d689d81a73c0eb0a77a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpyX8X_CdUTxhwAIcr6ZOA.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/ec97ca8bbfb33fc8bf2a0cf328fe07e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1GcmQRXwy_bO2iJHUfH5tA.png"/></div></div></figure><h1 id="d073" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="add5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">总的来说，我认为迁移学习模式的结果非常好。深度学习是一个非常有趣的话题，因为有太多不同的方法可以添加到模型中，很难找到完美的组合。</p><p id="0286" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果有更多的时间，我会努力改进以下几点:</p><ul class=""><li id="f788" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">增加训练时间，该模型在Udacity GPU上的训练时间约为2分钟。通过增加历元数来花费更多的时间训练可以提高其准确性。</li><li id="b536" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">通过添加更多层或更复杂的层(如Dropout)来增加模型的复杂性。这可以允许模型创建更好的关联。</li><li id="0d1f" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">扩充数据将为我们提供更多样化的训练数据集，这将使模型更好地泛化。</li></ul></div></div>    
</body>
</html>