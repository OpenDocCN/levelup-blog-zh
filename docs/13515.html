<html>
<head>
<title>Java HashMap Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java HashMap解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-hashmap-explained-a601c48ddc44?source=collection_archive---------6-----------------------#2022-09-12">https://levelup.gitconnected.com/java-hashmap-explained-a601c48ddc44?source=collection_archive---------6-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ace5152bf5ae640c94c81c89bee2bbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/0*TaC2P062slR3GugM.png"/></div></figure><p id="376e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">java hashmap的实现细节对于java开发人员来说是一个非常常见的面试问题，尽管我强烈反对在面试中问这样的问题(因为这就像在驾驶测试中问汽车发动机如何工作一样)，我在这里试图尽可能简单地解释它，因为我在网上找不到最简单准确的解释。这篇文章是写给有基本编程知识，能够使用数组、链表和散列表的人的。</p><p id="b1e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">TLDR；</strong> <em class="ks">这是一个链表数组。理想情况下，数组中的每一项都是一个只有1个节点的链表。所以你可以通过哈希hashmap的</em> <code class="fe kt ku kv kw b"><em class="ks">key</em></code> <em class="ks">来计算数组的</em> <code class="fe kt ku kv kw b"><em class="ks">index</em></code> <em class="ks">从而得到</em> <code class="fe kt ku kv kw b"><em class="ks">O(1)</em></code> <em class="ks">复杂度来执行</em><code class="fe kt ku kv kw b"><em class="ks">get</em></code><em class="ks"/><code class="fe kt ku kv kw b"><em class="ks">put</em></code><em class="ks">，并得到链表中的单项。但是，因为散列函数不必为不同的值创建唯一的散列码，所以当不止一个键具有相同的散列码时，它们被添加到链表中。因此，为了得到正确的键，您需要遍历链表并逐个比较键，因此对于那些具有相同散列码的键，复杂性为</em> <code class="fe kt ku kv kw b"><em class="ks">O(n)</em></code> <em class="ks">。</em></p><p id="ced3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了理解hashmap是如何工作的，我们首先需要理解我们想要达到的目标。然后，我们利用现有的资源来实现目标。</p><p id="94a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">目标:</strong>通过使用一个尽可能简单的非数字键来存储和检索数据列表。</p><p id="e9d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">什么是可用的:数组，链表，集合，树</p><p id="47c8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一种简单的方法是将键值对存储在上面的任何数据结构中，并逐个迭代和比较节点中的键。但是这样效率不高，导致复杂度为O(n)。复杂度最低的可能是O(1)，可通过使用数组来实现。我们只需要知道数组中确切的索引。然而，因为我们想要一个非数字的键作为散列表，这并不简单。</p><p id="c6f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以通过将密钥转换成整数来实现。怎么会？<a class="ae kx" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()" rel="noopener ugc nofollow" target="_blank"> hashCode() </a>。每个java对象都有一个hashcode()函数，将对象散列成一个整数。但是一定要注意合同。</p><ol class=""><li id="181b" class="ky kz iq jw b jx jy kb kc kf la kj lb kn lc kr ld le lf lg bi translated">hashcode函数必须为应用程序中相同的未修改对象返回相同的值。尽管相同的对象在不同的应用程序中运行时不需要返回相同的值。</li><li id="e1d9" class="ky kz iq jw b jx lh kb li kf lj kj lk kn ll kr ld le lf lg bi translated">如果两个对象用<code class="fe kt ku kv kw b"><a class="ae kx" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" rel="noopener ugc nofollow" target="_blank">equals()</a></code>函数返回true，它们必须有相同的hashCode值。</li><li id="d3b1" class="ky kz iq jw b jx lh kb li kf lj kj lk kn ll kr ld le lf lg bi translated">不同的对象可以返回相同的hashcode，即使它们不相等。</li></ol><p id="8e7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，使用hashCode函数，我们可以从任何类型的键生成一个整数。然而，这个整数会非常大，比如99162322。我们不能创建一个最大整数大小的数组，而只使用几个槽。事实上，默认情况下，java hashmaps只使用大小为16的数组创建。但是它有一个内置的机制，当数组填充75%时，它会将数组的大小加倍。所以对散列执行一个简单的具有当前数组大小的<code class="fe kt ku kv kw b">bitwise AND operation</code>来确定索引。</p><p id="b3f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">举个例子，假设你有一个键<code class="fe kt ku kv kw b">hello</code>，hash是<code class="fe kt ku kv kw b">99162322</code>，位值会是<code class="fe kt ku kv kw b">101111010010001100011010010</code>，当前数组的大小正好是16。所以我们要做一个按位AND运算<code class="fe kt ku kv kw b">101111010010001100011010010 &amp; 1111</code>，得到<code class="fe kt ku kv kw b">0010</code>，也就是2。所以我们将把键<code class="fe kt ku kv kw b">hello</code>分配给数组的索引2。</p><blockquote class="lm ln lo"><p id="3e10" class="ju jv ks jw b jx jy jz ka kb kc kd ke lp kg kh ki lq kk kl km lr ko kp kq kr ij bi translated">注意我们<code class="fe kt ku kv kw b">bitwise AND</code> 15也就是<code class="fe kt ku kv kw b">1111</code>，而不是16因为程序员从0开始计数，所以第16个索引实际上是15。</p></blockquote><p id="fac4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Tada！但是你不认为不同的键可以有相同的hashCode吗，因为我们只取最后几个字节？是的，但这没关系，因为数组中的每一项都是一个链表。所以当这种情况发生时，我们只需将它添加到链表中。在链表的每个节点中，我们存储hashmap条目的<code class="fe kt ku kv kw b">key</code>和<code class="fe kt ku kv kw b">value</code>。因此，如果链表中有1个以上的节点，我们需要遍历链表并逐个比较<code class="fe kt ku kv kw b">key</code>。</p><p id="e350" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以上是hashmap如何工作的一般概念，有很多调整可以使它更有效，例如:</p><ol class=""><li id="c47e" class="ky kz iq jw b jx jy kb kc kf la kj lb kn lc kr ld le lf lg bi translated">hashmap不直接使用键的散列作为索引，而是在按位AND操作之前对键应用另一个散列函数<code class="fe kt ku kv kw b">(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>,以减少冲突的可能性(多个键具有相同的索引)。</li><li id="d9db" class="ky kz iq jw b jx lh kb li kf lj kj lk kn ll kr ld le lf lg bi translated">当一个链表中有超过8个节点时，它将转换为使用树。</li></ol><p id="a8ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是上面的信息应该足够了，毕竟，编写软件是关于重用可用的东西，你不应该为了使用它们而需要知道所有的节点依赖是如何工作的。</p><p id="9813" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了进一步说明这一点，假设一个hashmap包含以下键值对，下表显示了从键生成的hashCode、hash和index。</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ls"><img src="../Images/0b7493a796fa9d24ad0d7fd43b61114d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PPHuWpU6wJz4MiFg.png"/></div></div></figure><p id="3387" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">数组和链表组合的结果hashmap就是这样。</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/618796c9f617f6b5fc74babd9d773ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/0*toC-6HIa5pvI-ZCh.png"/></div></figure><p id="52d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">生成密钥的代码可以在我的<a class="ae kx" href="https://gist.github.com/thecodinganalyst/caa2830f4d6a96f08afb84f85b0d3df2" rel="noopener ugc nofollow" target="_blank"> github gist </a>上找到</p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure></div></div>    
</body>
</html>