<html>
<head>
<title>3 ways of styling SwiftUI views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计SwiftUI视图的3种方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-ways-of-styling-swiftui-views-d32c40cbc667?source=collection_archive---------0-----------------------#2021-05-24">https://levelup.gitconnected.com/3-ways-of-styling-swiftui-views-d32c40cbc667?source=collection_archive---------0-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="87d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设计视图是构建漂亮用户界面最重要的部分。当谈到实际的代码语法时，我们希望在代码中有可重用的、可定制的和干净的解决方案。</p><p id="1859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章将向你展示这三种设计风格的方法:</p><ol class=""><li id="8ebd" class="ks kt it js b jt ju jx jy kb ku kf kv kj kw kn kx ky kz la bi translated">基于初始值的配置</li><li id="6275" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">使用返回自身的方法链接</li><li id="d5ef" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">环境中的样式</li></ol><p id="4dbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，任何方法都是可行的。最后，它归结为您的一般代码风格指南和个人偏好。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/eb09447ca75ba93384650f4e2e0d835a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Kk_v9ER65tuYvoK0aCeIw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">你将在第3章“环境中的样式”中找到的属性包装器</figcaption></figure><h1 id="bad7" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">1.基于初始值的配置</h1><p id="f593" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">这是一个简单的例子，可以很快地形象化:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f0f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个视图有两个参数<code class="fe ko kp kq kr b">backgroundColor</code>和<code class="fe ko kp kq kr b">textColor</code>，这两个参数在实例化结构时都是必需的。它们也是常量<code class="fe ko kp kq kr b">let</code>值，因为视图很可能不会发生变化(此时)。</p><p id="944b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">方便的是，Swift自动合成(内部)所需的初始化程序，但它们也可以由我们手动定义:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="nb nc nd"><p id="ea50" class="jq jr ne js b jt ju jv jw jx jy jz ka nf kc kd ke ng kg kh ki nh kk kl km kn im bi translated"><strong class="js iu">快速提示:</strong> <br/> Xcode还为我们提供了一个生成成员式初始化器的内置函数。你所要做的就是在类型名称上选择<code class="fe ko kp kq kr b">CMD(⌘) + left-click</code>，并选择动作。</p></blockquote><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ni"><img src="../Images/00255f0d6d0363269d71422f4579e8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NptvXt3t8gt4Ay_MDhHIgg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">Xcode可以自动生成成员式初始化器</figcaption></figure><p id="eb35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用自定义初始化器允许我们直接添加默认值，而无需将参数的<code class="fe ko kp kq kr b">let</code>更改为<code class="fe ko kp kq kr b">var</code>:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="808d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，Swift只合成内部初始化器，所以如果你的视图是包的一部分，需要成为<code class="fe ko kp kq kr b">public</code>，你需要使用这种方法。否则，使用该包的应用程序将无法找到或实例化视图。</p><p id="4e06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，如果该视图仅在您的应用程序内部使用，您也可以让Swift编译器为您完成这项工作🚀所需要做的就是从<code class="fe ko kp kq kr b">let</code>更改为<code class="fe ko kp kq kr b">var</code>，并直接在实例属性上设置默认值:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="1097" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">2.使用返回自身的方法链接</h1><p id="8c8d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">您的视图不断增长，需要设置更多参数。随着初始化器的不断增长，它最终会变成一大段代码。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="966b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，从我的个人经验来看，Swift编译器在某个时候有太多的工作要同时做，就干脆放弃了(它崩溃了)。</p><p id="1601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分解大型初始化器(带有默认值)的一种方法是使用返回自链接模式:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2434" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于视图本身是不可变的，但是由纯数据组成(结构不是对象)，我们可以用<code class="fe ko kp kq kr b">var view = self</code>创建一个本地副本。由于现在这是一个局部变量，我们可以在返回它之前对它进行变异并设置动作。</p><h1 id="aa46" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">3.环境中的样式</h1><p id="26c4" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">除了手动配置每个视图，我们还可以定义一个全局样式指南。一个示例可能如下所示:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="91f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，这个解决方案有一个大问题:<br/>全局静态变量意味着，它们不能为不同的用例定制(例如在Xcode预览中)😕</p><p id="2f54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的解决方案是再次选择实例配置:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="865f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这看起来很有希望，因为我们现在可以随时随地将样式配置传递到视图中:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d30a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相当干净的解决方案。但是你可能已经在想“但是等等！这怎么会是一个<strong class="js iu">全球</strong>解决方案？”你的怀疑是有道理的！这个解决方案要求我们将样式传递给每一个视图，如下面的代码片段所示:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0db3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅将“全局”样式对象放入嵌套的<code class="fe ko kp kq kr b">FooBar</code>视图就花了三次。这是不可接受的。我们不想要这么多不必要的代码(特别是因为你也努力争取干净的代码，不是吗？).</p><p id="81b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，那我们还能想到什么？那么，如何混合静态和实例解决方案呢？<br/>我们所需要的是一个静态对象，在那里我们可以从<code class="fe ko kp kq kr b">Foo</code>设置样式并从<code class="fe ko kp kq kr b">FooBar</code>读取它……听起来像一些共享的<em class="ne">环境</em>💡</p><p id="a64c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SwiftUI引入了属性包装器<code class="fe ko kp kq kr b"><a class="ae nj" href="https://developer.apple.com/documentation/swiftui/environment" rel="noopener ugc nofollow" target="_blank">@Environment</a></code>，它允许我们从view🥳的共享环境中读取一个值</p><p id="e4bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，通过创建一个实现<code class="fe ko kp kq kr b">defaultValue</code>的结构来创建一个新的<code class="fe ko kp kq kr b">EnvironmentKey</code>:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="164a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，您需要添加新的环境键作为对<code class="fe ko kp kq kr b">EnvironmentValues</code>的扩展，以便可以从属性包装器中访问它:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a44d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，使用根视图中的<code class="fe ko kp kq kr b">.environment(\.style, ...)</code>设置值，并使用子视图中<code class="fe ko kp kq kr b">@Environment(\.style)</code>中<code class="fe ko kp kq kr b">style</code>的关键路径读取值:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0039" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">厉害！不再传递不必要的实例，仍然可以从根视图进行配置🚀</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="024e" class="nr lx it bd ly ns nt dn mc nu nv dp mg kb nw nx mk kf ny nz mo kj oa ob ms oc bi translated"><strong class="ak">奖励:自定义属性包装</strong></h2><p id="3f07" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">我们的环境解决方案已经很不错了，但是下面的不是更干净吗？</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="af63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个漂亮的语法，您只需要创建一个定制的属性包装器<code class="fe ko kp kq kr b">@Theme</code>,它包装我们的环境配置并通过一个keypath访问样式值。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c1fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更好的是，使用<code class="fe ko kp kq kr b">View</code>扩展可以让我们完全隐藏<code class="fe ko kp kq kr b">Environment</code>的用法！</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="nb nc nd"><p id="abe3" class="jq jr ne js b jt ju jv jw jx jy jz ka nf kc kd ke ng kg kh ki nh kk kl km kn im bi translated">注意:<br/>风格现在被称为<code class="fe ko kp kq kr b">theme</code>的原因老实说只是一个属性包装<code class="fe ko kp kq kr b">@Style</code>和<code class="fe ko kp kq kr b">struct Style</code>的命名冲突。如果重命名样式结构，也可以将此名称用于属性包装。</p></blockquote><h1 id="d80e" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结论</h1><p id="e244" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">SwiftUI提供了多种不同的方法来构建我们的视图层次结构，我们只探索了其中的几种。额外的选择，例如<code class="fe ko kp kq kr b">ViewModifier</code>已经存在，将来会有更多。</p><p id="e5fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在写这篇文章的时候，最佳实践还不存在，因为这项技术还很新。相反，我们有不同的<strong class="js iu">好的</strong>实践可供选择，可以专注于代码的可重用性、可定制性和干净性。</p><p id="b75d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想了解更多信息，请查看我的其他文章，在<a class="ae nj" href="https://twitter.com/philprimes" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，并随时给我发一份DM。<br/>你有什么特别的话题想让我介绍吗？让我知道！😃</p></div></div>    
</body>
</html>