<html>
<head>
<title>How to clear floats in CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何清除CSS中的浮动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-clear-floats-in-css-269f05f411da?source=collection_archive---------5-----------------------#2019-12-01">https://levelup.gitconnected.com/how-to-clear-floats-in-css-269f05f411da?source=collection_archive---------5-----------------------#2019-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2fdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个<a class="ae kl" href="https://medium.com/@kabir4691/use-css-float-property-to-create-columns-6fc2c8d2aa0" rel="noopener">故事</a>中，我们将看到如何使用浮动在页面上创建列。然而，使用浮动有一个警告:您需要在使用浮动后清除它们。让我们用一个例子来看看为什么需要这样做。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="a54f" class="kv kw iq kr b gy kx ky l kz la">&lt;body&gt;<br/>    &lt;div class="div-1"&gt;This is 33.33%&lt;/div&gt;<br/>    &lt;div class="div-2"&gt;This is 66.66%&lt;/div&gt;<br/>&lt;/body&gt;</span><span id="e1b7" class="kv kw iq kr b gy lb ky l kz la">div {<br/>    display: inline-block;<br/>    padding: 20px;<br/>    text-align: center;<br/>}<br/>.div-1 {<br/>    width: 33.33%;<br/>    background: #FF6347;<br/>}<br/>.div-2 {<br/>    width: 66.66%;<br/>    background: #0EB36D;<br/>}</span></pre><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/a4f165bc85f0823cde0404f2961ddceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leLMa_SbV1_BeOvhRQe5LA.png"/></div></div></figure><p id="2728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的例子显示了两个div，分别占据了屏幕宽度的三分之一和三分之二。让我们看看当我们试图在它们下面添加第三个大小为200x200像素的div时会发生什么，但是没有float属性。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="040f" class="kv kw iq kr b gy kx ky l kz la">&lt;body&gt;<br/>    &lt;div class="div-1"&gt;This is 33.33%&lt;/div&gt;<br/>    &lt;div class="div-2"&gt;This is 66.66%&lt;/div&gt;<br/>    &lt;div class="div-3"&gt;This is the third div&lt;/div&gt;<br/>&lt;/body&gt;</span><span id="1709" class="kv kw iq kr b gy lb ky l kz la">div {<br/>    display: inline-block;<br/>    padding: 20px;<br/>    text-align: center;<br/>}<br/>.div-1 {<br/>    width: 33.33%;<br/>    background: #FF6347;<br/>    float:left;<br/>}<br/>.div-2 {<br/>    width: 66.66%;<br/>    background: #0EB36D;<br/>    float:left;<br/>}<br/>.div-3 {<br/>    width: 200px;<br/>    height: 200px;<br/>    background: #2958B3;<br/>}</span></pre><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/2c571b9e3b65d1fa534d5162f1b513bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KsjsCZEDwQaUTcormy5Sg.png"/></div></div></figure><p id="bbf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到第三个div似乎出现在前两个div的下面。让我们检查页面以进一步理解。</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lk"><img src="../Images/71bed416eec131ed6cb9434f8d0d787c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKIqxj8wVIPwG-sZL1s0eg.png"/></div></div></figure><p id="5514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到第三个div确实没有出现在两个div的下面，这是HTML的正常流程。相反，它将自己对齐到页面的起始位置，就好像前两个div不存在一样。发生这种情况的原因是，当您对HTML中的元素应用float时，该元素将从页面的正常流程中移除。这导致在它之后出现的其余元素渗入其空间。为了克服这个问题，我们需要<code class="fe ll lm ln kr b">clear</code>浮动，以便浏览器正确地呈现剩余的元素。让我们来看看同样的一些方法:</p><h1 id="c9a2" class="lo kw iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">清除下一个元素的浮点</strong></h1><p id="2cc5" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我们可以将clear: both属性添加到紧随浮动元素之后的元素中，如下所示</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="a57a" class="kv kw iq kr b gy kx ky l kz la">.div-3 {<br/>    width: 200px;<br/>    height: 200px;<br/>    background: #2958B3;<br/>    clear: both;<br/>}</span></pre><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lk"><img src="../Images/c40a3b9e5f0ae3186f1a8c078dfc3d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xhh1SfjuOzqTnLk6g9w8ug.png"/></div></div></figure><p id="6631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，第三个div元素的行为符合预期，它将自己放置在前两个div的下面。这是因为通过应用<code class="fe ll lm ln kr b">clear: both</code>属性，您告诉浏览器浮动属性从该点开始不再有效，页面的正常流动可以恢复。</p><p id="cf26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，将clear属性单独应用于proceeding元素并不能每次都解决浮动的问题。考虑以下情况，浮动元素包含在父主元素中。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="985e" class="kv kw iq kr b gy kx ky l kz la">&lt;body&gt;<br/>    &lt;main&gt;<br/>        &lt;div class="div-1"&gt;This is 33.33%&lt;/div&gt;<br/>        &lt;div class="div-2"&gt;This is 66.66%&lt;/div&gt;<br/>    &lt;/main&gt;<br/>    &lt;div class="div-3"&gt;This is the third div&lt;/div&gt;<br/>&lt;/body&gt;</span><span id="148b" class="kv kw iq kr b gy lb ky l kz la">div {<br/>    display: inline-block;<br/>    padding: 20px;<br/>    text-align: center;<br/>}<br/>.div-1 {<br/>    width: 33.33%;<br/>    background: #FF6347;<br/>    float:left;<br/>}<br/>.div-2 {<br/>    width: 66.66%;<br/>    background: #0EB36D;<br/>    float:left;<br/>}<br/>.div-3 {<br/>    width: 200px;<br/>    height: 200px;<br/>    background: #2958B3;<br/>}</span></pre><p id="cd61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您尝试运行上面的代码并检查页面，您可以看到父元素' main '的高度是0px，即使它内部有一些占用空间的元素。这是因为，在proceeding元素中缺少clear: both属性的情况下，父main元素没有检索回它的样式。因此，为了让父元素重新获得它的样式，我们必须设法包含浮动，而不是清除它们。包含浮动有不同的方法。然而，我们要看三个最流行的:用clear: both放置一个空的div，溢出技术和clearfix技术。</p><h1 id="847f" class="lo kw iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">放置一个空div</h1><p id="79e3" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">在这个方法中，我们在父元素的结束标记之前放置一个空的div，并将其样式设置为clear: both。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="f87f" class="kv kw iq kr b gy kx ky l kz la">&lt;body&gt;<br/>    &lt;main&gt;<br/>        &lt;div class="div-1"&gt;This is 33.33%&lt;/div&gt;<br/>        &lt;div class="div-2"&gt;This is 66.66%&lt;/div&gt;<br/>        &lt;div class-"clear&gt;&lt;/div&gt;<br/>    &lt;/main&gt;<br/>    &lt;div class="div-3"&gt;This is the third div&lt;/div&gt;<br/>&lt;/body&gt;</span><span id="76bf" class="kv kw iq kr b gy lb ky l kz la">div {<br/>    display: inline-block;<br/>    padding: 20px;<br/>    text-align: center;<br/>}<br/>.div-1 {<br/>    width: 33.33%;<br/>    background: #FF6347;<br/>    float:left;<br/>}<br/>.div-2 {<br/>    width: 66.66%;<br/>    background: #0EB36D;<br/>    float:left;<br/>}<br/>.div-3 {<br/>    width: 200px;<br/>    height: 200px;<br/>    background: #2958B3;<br/>}<br/>.clear {<br/>    clear: both;<br/>}</span></pre><p id="a3ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以这种方式包含float效率不高，因为每次使用float时都需要添加一个空的div元素。此外，使用额外的空div在语义上也是不正确的。</p><h1 id="7caf" class="lo kw iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">溢出技术</h1><p id="7307" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">在这个方法中，我们将<code class="fe ll lm ln kr b">overflow: auto</code>属性应用于父元素，并将其样式设置为clear: both。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="babb" class="kv kw iq kr b gy kx ky l kz la">&lt;body&gt;<br/>    &lt;main&gt;<br/>        &lt;div class="div-1"&gt;This is 33.33%&lt;/div&gt;<br/>        &lt;div class="div-2"&gt;This is 66.66%&lt;/div&gt;<br/>    &lt;/main&gt;<br/>    &lt;div class="div-3"&gt;This is the third div&lt;/div&gt;<br/>&lt;/body&gt;</span><span id="3474" class="kv kw iq kr b gy lb ky l kz la">main {<br/>    overflow: auto;<br/>}</span><span id="7328" class="kv kw iq kr b gy lb ky l kz la">div {<br/>    display: inline-block;<br/>    padding: 20px;<br/>    text-align: center;<br/>}<br/>.div-1 {<br/>    width: 33.33%;<br/>    background: #FF6347;<br/>    float:left;<br/>}<br/>.div-2 {<br/>    width: 66.66%;<br/>    background: #0EB36D;<br/>    float:left;<br/>}<br/>.div-3 {<br/>    width: 200px;<br/>    height: 200px;<br/>    background: #2958B3;<br/>}</span></pre><p id="8022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法也有一些缺点。添加overflow属性可能会在Internet Explorer中添加滚动条。我们可以通过设置<code class="fe ll lm ln kr b">overflow: hidden</code>来解决这个问题。然而，这反过来又会导致某些样式(如阴影部分)不可见。</p><h1 id="ac96" class="lo kw iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">清晰定位技术</h1><p id="017d" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">这是迄今为止最有效也是最流行的包含浮动的方法。在这个方法中，我们创建一个包含特定规则的CSS类，然后将该类应用于包含浮动元素的父元素。让我们把这个类命名为“clearfix”。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="1705" class="kv kw iq kr b gy kx ky l kz la">&lt;body&gt;<br/>    &lt;main class="clearfix"&gt;<br/>        &lt;div class="div-1"&gt;This is 33.33%&lt;/div&gt;<br/>        &lt;div class="div-2"&gt;This is 66.66%&lt;/div&gt;<br/>    &lt;/main&gt;<br/>    &lt;div class="div-3"&gt;This is the third div&lt;/div&gt;<br/>&lt;/body&gt;</span><span id="5f30" class="kv kw iq kr b gy lb ky l kz la">div {<br/>    display: inline-block;<br/>    padding: 20px;<br/>    text-align: center;<br/>}<br/>.div-1 {<br/>    width: 33.33%;<br/>    background: #FF6347;<br/>    float:left;<br/>}<br/>.div-2 {<br/>    width: 66.66%;<br/>    background: #0EB36D;<br/>    float:left;<br/>}<br/>.div-3 {<br/>    width: 200px;<br/>    height: 200px;<br/>    background: #2958B3;<br/>}</span><span id="b5be" class="kv kw iq kr b gy lb ky l kz la">.clearfix: before, .clearfix: after {<br/>    content: "";<br/>    display: table;<br/>}<br/>.clearfix: after {<br/>    clear: both;<br/>}</span></pre><p id="6dca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们在clearfix类上使用before和after的伪元素，在它所应用的元素之上和之下创建动态内容。为了隐藏元素，我们还将内容设置为空字符串。</p><p id="c558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将display属性设置为table，以使它们成为跨越整个页面宽度的块级元素，包括类的上面和下面。将display属性设置为block也可以，但是我们将它作为table来应用，以确保在旧浏览器上的向后兼容性。</p><p id="077e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些动态创建的伪元素以隐藏的方式放置在内容的上方和下方，并确保浮动正确地包含在元素本身的范围内。我们还将clear: both属性应用于after元素，以确保下一个元素不会缠绕在浮动的元素周围。</p></div></div>    
</body>
</html>