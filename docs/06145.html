<html>
<head>
<title>React hooks gotchas: setState in async useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React钩子捕获:异步使用效果中的setState</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-gotchas-setstate-in-async-effects-d2fd84b02305?source=collection_archive---------1-----------------------#2020-10-30">https://levelup.gitconnected.com/react-hooks-gotchas-setstate-in-async-effects-d2fd84b02305?source=collection_archive---------1-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6ee9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk">🧶</h2></div><blockquote class="kf kg kh"><p id="c948" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">更新:这篇文章中提到的问题将在React v18中解决:<a class="ae lf" href="https://github.com/reactwg/react-18/discussions/21" rel="noopener ugc nofollow" target="_blank">https://github.com/reactwg/react-18/discussions/21</a></p></blockquote><p id="6e10" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">面对现实吧，胡克已经游荡了一段时间了。然而我感觉每天都在发现新的东西<strong class="kl ir"><em class="kk"/></strong>。今天，我想分享一个新的发现，因为它远非显而易见——至少可以这么说！</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/28e4e83289c4645a517446e28404debb.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*IOkIId5wbQqPW9V4"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">所以你认为你精通钩子…？</figcaption></figure><h1 id="24f2" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">小回顾:异步效果</h1><p id="9927" class="pw-post-body-paragraph ki kj iq kl b km mn jr ko kp mo ju kr lg mp ku kv lh mq ky kz li mr lc ld le ij bi translated">异步效果是一种调用承诺并基于该承诺设置某种状态的效果。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="14c2" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">以获取用户为例</h1><h2 id="1669" class="mu lw iq bd lx mv mw dn mb mx my dp mf lg mz na mh lh nb nc mj li nd ne ml nf bi translated">第一种方法</h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="d0f3" class="mu lw iq bd lx mv mw dn mb mx my dp mf lg mz na mh lh nb nc mj li nd ne ml nf bi translated">问题是</h2><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c93da1e6cd56286bfb657d8e427f1a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*n3ArbQkGEas4rhkW.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">问题，什么问题？</figcaption></figure><p id="260f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">使用这种方法，<code class="fe nh ni nj nk b">&lt;App /&gt;</code>组件将渲染4次:</p><ul class=""><li id="a63e" class="nl nm iq kl b km kn kp kq lg nn lh no li np le nq nr ns nt bi translated">渲染1:初始挂载</li><li id="a777" class="nl nm iq kl b km nu kp nv lg nw lh nx li ny le nq nr ns nt bi translated">渲染2:<code class="fe nh ni nj nk b">useEffect()</code>中的<code class="fe nh ni nj nk b">setPending(true)</code>导致第二次渲染</li><li id="d6b6" class="nl nm iq kl b km nu kp nv lg nw lh nx li ny le nq nr ns nt bi translated">渲染3:<code class="fe nh ni nj nk b">fetchUser().then()</code>中的<code class="fe nh ni nj nk b">setPending(false)</code></li><li id="49a6" class="nl nm iq kl b km nu kp nv lg nw lh nx li ny le nq nr ns nt bi translated">渲染4:<code class="fe nh ni nj nk b">fetchUser().then()</code>中的<code class="fe nh ni nj nk b">setUser(fetchedUser)</code></li></ul><p id="eb78" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">问题是:在<code class="fe nh ni nj nk b">fetchedUser().then()</code>中，我们触发了两个<code class="fe nh ni nj nk b">setState</code>，而不是像预期的那样有一个渲染，而是每个 <code class="fe nh ni nj nk b"><strong class="kl ir">setState</strong></code> <strong class="kl ir">调用</strong>都有一个渲染。</p><blockquote class="kf kg kh"><p id="cb77" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">重要提示</strong>:这种情况只发生在<em class="iq">异步动作的</em>(又名<code class="fe nh ni nj nk b">useEffect</code>中的承诺)。当<code class="fe nh ni nj nk b">useEffect()</code>没有触发任何异步动作时，<code class="fe nh ni nj nk b">setState</code>被正确批处理。</p></blockquote><h2 id="c7a8" class="mu lw iq bd lx mv mw dn mb mx my dp mf lg mz na mh lh nb nc mj li nd ne ml nf bi translated">解决方案是:将状态组合在一起</h2><p id="0b7f" class="pw-post-body-paragraph ki kj iq kl b km mn jr ko kp mo ju kr lg mp ku kv lh mq ky kz li mr lc ld le ij bi translated">为了减少渲染的数量，我们必须减少异步效果中的<code class="fe nh ni nj nk b">setState</code>调用。一种解决方案是将逻辑上相互关联的状态分组。这里，<code class="fe nh ni nj nk b">pending</code>和<code class="fe nh ni nj nk b">user</code>状态。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="095f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">现在好了，我们将有我们的3个预期的渲染。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="a00b" class="lv lw iq bd lx ly og ma mb mc oh me mf jw oi jx mh jz oj ka mj kc ok kd ml mm bi translated">更进一步</h1><h2 id="5669" class="mu lw iq bd lx mv mw dn mb mx my dp mf lg mz na mh lh nb nc mj li nd ne ml nf bi translated">抽象定制钩子中的逻辑</h2><p id="34f0" class="pw-post-body-paragraph ki kj iq kl b km mn jr ko kp mo ju kr lg mp ku kv lh mq ky kz li mr lc ld le ij bi translated">让我们创建一个<code class="fe nh ni nj nk b">usePromiseEffect</code>钩子</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7e77" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">让我们在我们的<code class="fe nh ni nj nk b">&lt;App /&gt;</code>组件中使用它:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d591" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">但是，等等，这是一个很大的变化…</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/7fb39cb442f548537836516c390b9b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*nLPTMzN5CO9gY6V5.gif"/></div></figure><h2 id="07a0" class="mu lw iq bd lx mv mw dn mb mx my dp mf lg mz na mh lh nb nc mj li nd ne ml nf bi translated">好吧，但所有这些都是为了保存… 1渲染？！</h2><p id="bb86" class="pw-post-body-paragraph ki kj iq kl b km mn jr ko kp mo ju kr lg mp ku kv lh mq ky kz li mr lc ld le ij bi translated">在这个例子中，是的。但是在现实生活中，你经常会遇到更复杂的例子。通常，在初始化表单之前，你需要获取一大堆数据，在这里你可以保存大量的渲染。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="cb00" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">综上所述，请记住，你的效果应该尽可能少地承担<a class="ae lf" href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="noopener ugc nofollow" target="_blank">责任</a>。</p><p id="dce5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">并且在编写自己的效果风格钩子时要记住这个问题。<br/>现在代码安全🧑‍💻，四处看看😇</p><p id="fa26" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">这里是<a class="ae lf" href="https://codesandbox.io/s/async-use-state-disparities-demo-mk26n" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>的完整演示，你可以用它玩un⋅commenting出来的特效等等……干杯！</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="om mt l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">玩得开心🤓</figcaption></figure></div></div>    
</body>
</html>