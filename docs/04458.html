<html>
<head>
<title>Tutorial: Learn the internals of Git by hacking a website</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:通过入侵一个网站来了解Git的内部</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-the-internals-of-git-by-hacking-websites-c70c59303b12?source=collection_archive---------2-----------------------#2020-06-28">https://levelup.gitconnected.com/learning-the-internals-of-git-by-hacking-websites-c70c59303b12?source=collection_archive---------2-----------------------#2020-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7c2b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">编程教程</h2><div class=""/><div class=""><h2 id="4423" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">理解我们最喜欢的工具之一实际上是做什么的</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/22a41ca7ba4e1077eae6931b0af14569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwwphXwzczd6Lq8RCYsJ_w.jpeg"/></div></div></figure><blockquote class="ld le lf"><p id="3b74" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">免责声明:本文仅用于教育目的。作者不纵容也不鼓励黑客攻击，除了</strong> <a class="ae md" href="https://medium.com/@yakko.majuri/the-internet-is-too-unsafe-we-need-more-hackers-c9742fc1a03b" rel="noopener"> <strong class="lj jd">允许的白帽黑客</strong> </a> <strong class="lj jd">。</strong></p></blockquote><p id="9942" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">在这个世界上漫游的大多数开发人员都曾在某个时候遇到过Git。</p><p id="2108" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">你可能每天都在使用它。</p><p id="661b" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">现在，虽然很容易将Git简化为几个记住的命令，如<code class="fe mh mi mj mk b">git add</code>、<code class="fe mh mi mj mk b">git commit</code>和<code class="fe mh mi mj mk b">git push</code>，但实际上在后台发生了很多我们不经常想去理解的事情。</p><p id="80da" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">然而，了解一点幕后发生的事情可能是非常有用的，我将尝试以一种有趣的方式让您深入了解这一点:通过教您如何利用与Git相关的安全漏洞，以便您可以更好地保护自己的网站。</p><p id="a385" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">记住，<strong class="lj jd">没有明确的许可，你永远不要在任何人的网站上尝试这样做</strong>。这样做可以构成严重犯罪。我不为你从这篇文章中获得的知识所做的任何事情负责。</p><h2 id="b3b3" class="ml mm it bd mn mo mp dn mq mr ms dp mt me mu mv mw mf mx my mz mg na nb nc iz bi translated">一个非常小的网络服务器</h2><p id="e147" class="pw-post-body-paragraph lg lh it lj b lk nd kd lm ln ne kg lp me nf ls lt mf ng lw lx mg nh ma mb mc im bi translated"><em class="li">如果你想跳过文件创建和东西，可以随意地从</em> <a class="ae md" href="https://github.com/yakkomajuri/exposed-git" rel="noopener ugc nofollow" target="_blank"> <em class="li">克隆代码到这里</em> </a> <em class="li">(使用Git :D)，并跳过</em> <a class="ae md" href="#5e99" rel="noopener ugc nofollow"> <em class="li">这一节</em> </a> <em class="li">。</em></p><p id="a4ff" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">我将在这里讨论的漏洞包括将您的Git存储库或其内容暴露给web。直到今天，它仍然影响着许多网站，而且大多与PHP服务器有关(惊讶吧！)，所以我们给自己弄一个吧。</p><p id="f25e" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">不，先别走！我们实际上不会写很多PHP，但是你需要确保你的机器上安装了PHP。您可以通过运行<code class="fe mh mi mj mk b">php -v</code>来检查它是否已经安装。</p><p id="b4fe" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">在写这篇教程之前，我自己从来没有真正使用过PHP，所以我向你保证这非常简单。</p><p id="9240" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">现在，打开一个终端窗口，让我们创建一个Git目录并向其中添加一个文件:</p><p id="3d15" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ mkdir exposed-git</code></p><p id="a89b" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ cd exposed-git</code></p><p id="21cd" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ git init</code></p><p id="b142" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ echo "&lt;h1&gt;I will be hacked soon!&lt;/h1&gt;" &gt; index.php</code></p><p id="739c" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">要运行简单的web服务器，只需键入:</p><p id="4371" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ php -S localhost:8000</code></p><p id="15d4" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">现在试着在你的浏览器中点击<code class="fe mh mi mj mk b">localhost:8000</code>,确保它能正常工作。</p><p id="57cd" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">厉害！我们有自己的网络服务器。</p><h2 id="eca1" class="ml mm it bd mn mo mp dn mq mr ms dp mt me mu mv mw mf mx my mz mg na nb nc iz bi translated">没有提交的Git是什么</h2><p id="281e" class="pw-post-body-paragraph lg lh it lj b lk nd kd lm ln ne kg lp me nf ls lt mf ng lw lx mg nh ma mb mc im bi translated">我们的web服务器准备好了，让我们给它添加一些有趣的东西。</p><p id="8470" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">在目录的根目录中，执行以下操作:</p><p id="9e83" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ touch config.php</code></p><p id="ee29" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">然后，使用您选择的编辑器，将以下内容添加到<code class="fe mh mi mj mk b">config.php:</code></p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="0152" class="ml mm it mk b gy nm nn l no np">&lt;?php</span><span id="520d" class="ml mm it mk b gy nq nn l no np">    if(!isset($_SERVER['HTTP_REFERER'])){<br/>        header('location: ../error.php');<br/>        exit;<br/>    }</span><span id="80c8" class="ml mm it mk b gy nq nn l no np">    define('DB_USER', 'admin');<br/>    define('DB_PASSWORD', 'password123');</span><span id="96ef" class="ml mm it mk b gy nq nn l no np">?&gt;</span></pre><p id="fffd" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">我们上面所做的是创建一个保存数据库凭证的配置文件模型，并添加一个“安全机制”来防止用户访问它。尝试访问<code class="fe mh mi mj mk b">localhost:8000/config.php</code>会将我们带到一个错误页面，我们将在下面创建这个页面:</p><p id="008a" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ echo "&lt;h1&gt;You really thought you could hack me?&lt;/h1&gt;" &gt; error.php</code></p><p id="c130" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">此时，你可能会想:</p><p id="d34e" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">“啊，但是没有人会以明文形式存储他们的数据库凭证！”</p><p id="e2c2" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">对此我的回答是:<a class="ae md" href="https://wordpress.org/support/article/editing-wp-config-php/" rel="noopener ugc nofollow" target="_blank">这里有一个关于<code class="fe mh mi mj mk b">wp-config.php</code>文件的官方WordPress教程</a>。哦，是的，很糟糕。</p><p id="2c24" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">顺便说一下，如果<strong class="lj jd">你</strong>以明文形式存储任何凭证，至少请<strong class="lj jd">查看</strong>环境变量。</p><h2 id="306a" class="ml mm it bd mn mo mp dn mq mr ms dp mt me mu mv mw mf mx my mz mg na nb nc iz bi translated">没有提交的Git是什么</h2><p id="2923" class="pw-post-body-paragraph lg lh it lj b lk nd kd lm ln ne kg lp me nf ls lt mf ng lw lx mg nh ma mb mc im bi translated">现在我们的服务器文件已经准备好了，让我们提交它们。运行:</p><p id="ac90" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ git add .</code></p><p id="f0bb" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ git commit -m "first commit"</code></p><p id="344c" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">我们已经完成了设置。现在让我们来看看黑客。</p><h2 id="5e99" class="ml mm it bd mn mo mp dn mq mr ms dp mt me mu mv mw mf mx my mz mg na nb nc iz bi translated">你会黑吗？</h2><p id="aaaf" class="pw-post-body-paragraph lg lh it lj b lk nd kd lm ln ne kg lp me nf ls lt mf ng lw lx mg nh ma mb mc im bi translated">让我们运行我们的服务器并尝试一些事情。同样，命令是:</p><p id="d6e3" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ php -S localhost:8000</code></p><p id="cb1c" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">确保您的服务器在本教程的剩余部分保持运行，并在其他终端窗口上执行所有其他操作。</p><p id="5a5d" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">首先，尝试在<code class="fe mh mi mj mk b">localhost:8000/config.php</code>访问我们的<code class="fe mh mi mj mk b">config.php</code>文件。您应该会看到我们之前设置的错误页面。</p><p id="53b1" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">现在，让我们看看是否可以访问隐藏的<code class="fe mh mi mj mk b">.git/</code>目录，因为这正是我们在本文中讨论的内容:</p><p id="4008" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">localhost:8000/.git/</code></p><p id="4d84" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">我运行的是PHP 7.3.9，这给了我以下页面:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/3e098280f73d8acb3f8207563df3e937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKboD2icNlbN65FVs-hJYg.png"/></div></div></figure><p id="fb72" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">真好。默认情况下，PHP会阻止对目录的访问。实际上，并不总是这样。一些网站公开了他们的整个<code class="fe mh mi mj mk b">.git</code>目录，看起来像这样:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e7370526535f4c68b8d47a18c49d07bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*_zxGhIvhKDwLZhNSAJhEMw.png"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">演职员表:<a class="ae md" href="https://pentester.land/tutorials/2018/10/25/source-code-disclosure-via-exposed-git-folder.html" rel="noopener ugc nofollow" target="_blank">https://pentester . land/tutorials/2018/10/25/source-code-disclosure-via-exposed-git-folder . html</a></figcaption></figure><p id="5d43" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">但是，嘿，如果我们不能访问完整的目录，我们也不能访问它的内容，对不对？</p><p id="84f1" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">好吧，我们试试。参考上图，我们看到了每个Git目录包含的一些东西。<code class="fe mh mi mj mk b">HEAD</code>看起来特别有趣(<code class="fe mh mi mj mk b">config</code>看起来也很有趣，但是我们今天把那个放在一边)。我们能进入吗？</p><p id="f300" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">访问<code class="fe mh mi mj mk b">localhost:8000/.git/HEAD</code>和宾果！我们有发现了。</p><p id="7858" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">虽然看起来不太有趣。但这是一条路——我们也可以试试？</p><p id="51a2" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">localhost:8000/.git/refs/heads/master</code></p><p id="ffa0" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">哦，我们得到一份杂烩！那会是什么呢？</p><p id="bb16" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">好吧，让我们想想GitHub。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/2ee2080c5c65ed12e60b72c26ac2c972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KW47Mqut1zT0Vd_d_rtvhg.png"/></div></div></figure><p id="1fab" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">上面是PHP解释器的GitHub库的截图。有一个横幅宣布最近的提交，后面还有一段hash。我们能找到提交的散列吗？</p><p id="e8f2" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">既然Git为我们存储了提交，我们能通过散列找到那个提交吗？</p><p id="4b0c" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">再次查看目录结构，可以猜测提交可能存储在<code class="fe mh mi mj mk b">.git/objects/</code>中。听起来是个不错的猜测。我们能拿到吗？</p><p id="b165" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">localhost:8000/.git/objects/f452d4085347400afa8751aae3a5184d73113628</code></p><blockquote class="ld le lf"><p id="b1c8" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">作者注</strong></p><p id="f779" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">记得用上面的散列替换从<code class="fe mh mi mj mk b">localhost:8000/.git/refs/heads/master</code>得到的中的<strong class="lj jd">。</strong></p></blockquote><p id="4d8c" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">没有找到。所以我们可以放弃，或者尝试学习更多关于Git的知识，然后再试一次。</p><p id="cca2" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">打开任何使用Git的目录，查看里面的内容。</p><p id="5838" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">如果您选择了一个有很多活动的目录，<code class="fe mh mi mj mk b">objects/</code>可能看起来像这样:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/bbf4f67742d21c9cbe1a86ebed1c078f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEIUA3hm8Ju44-7CbIIkPQ.png"/></div></div></figure><p id="8a10" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">许多子目录以双字符十六进制命名。</p><p id="a94f" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">啊！所以我们要寻找的提交不仅仅是自由浮动在<code class="fe mh mi mj mk b">objects/</code>中，它很可能在一个子目录中，这个子目录以它的hash的前两个字符命名。这值得一试。让我们继续请求它(用你的散列代替我的):</p><p id="e7cd" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">localhost:8000/.git/objects/f4/52d4085347400afa8751aae3a5184d73113628</code></p><p id="2493" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">对我来说，这实际上提示了一个下载窗口。所以我们一定在做正确的事情。但是如果我在下载后打开或<code class="fe mh mi mj mk b">cat</code>文件，我得到的只是一些胡言乱语:</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="08fe" class="ml mm it mk b gy nm nn l no np">xùéÀmB1�9ªäm »ˆ˙+!Dê„⁄ﬁM`2ÊêÓCBg£©kÔÀã~33ÿúıQíq¡’…≈*&amp;4ùè≠ËZmQ7|ù Y,¢Ò&gt;&amp;#⁄’,Ï–ŸB1JnË5'r,M — c~Ø&gt;È|^·Hß«X`˜ÛG€˛OáØNÀe[◊æ„3b<br/>⁄x¯–®µz⁄ÁÊ‰∑JñqüÍ®_∏⁄K,</span></pre><p id="7dc0" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">但是，Git必须知道如何处理这个。让我们创建一个<strong class="lj jd">新的</strong>空目录来运行一些测试。</p><p id="7433" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ mkdir git-tests</code></p><p id="1ca1" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ cd git-tests</code></p><p id="f00f" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated"><code class="fe mh mi mj mk b">$ git init</code></p><p id="f8e0" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">然后让我们把文件放在它应该在的地方，在<code class="fe mh mi mj mk b">.git/objects/</code>。从我们的<code class="fe mh mi mj mk b">git-tests</code>目录的根目录开始，执行(使用您自己的散列):</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="9c1e" class="ml mm it mk b gy nm nn l no np">$ mkdir .git/objects/f4</span><span id="3f4e" class="ml mm it mk b gy nq nn l no np">$ curl localhost:8000/.git/objects/f4/52d4085347400afa8751aae3a5184d73113628 --output ./.git/objects/f4/52d4085347400afa8751aae3a5184d73113628</span></pre><p id="3df6" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">然后我们可以使用一个内置的Git命令来实际读取文件的内容。看起来是这样的:</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="98c4" class="ml mm it mk b gy nm nn l no np">$ git cat-file -p f452d4085347400afa8751aae3a5184d73113628</span></pre><p id="7407" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">这给了我们第一点敏感信息:</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="62df" class="ml mm it mk b gy nm nn l no np">tree 2764257f81462ae8f9b26ab16d08de153db0cc2b</span><span id="e68f" class="ml mm it mk b gy nq nn l no np">author Yakko Majuri &lt;email_removed&gt; 1593386015 -0300</span><span id="dfd2" class="ml mm it mk b gy nq nn l no np">committer Yakko Majuri &lt;email_removed&gt; 1593386015 -0300</span><span id="cde1" class="ml mm it mk b gy nq nn l no np">first commit</span></pre><p id="a0d0" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">(注意:如果您有先前的提交，您还会看到对“父”的引用。)</p><p id="d162" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">我们得到了一个“树”的标识符和一些关于提交作者和提交者的信息(例如，这些在拉请求的情况下是不同的)，包括他们的电子邮件！最后，我们还收到了提交消息。</p><p id="d64f" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">事情开始变得严重了…</p><p id="e0b6" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">作为参考，你实际上不需要整个散列来运行<code class="fe mh mi mj mk b">git cat-file</code>，只需要其中的一部分就可以了。例如，这给了我相同的结果:</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="326b" class="ml mm it mk b gy nm nn l no np">$ git cat-file -p f452d40</span></pre><p id="8b65" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">您还应该知道的是，您也可以使用标志<code class="fe mh mi mj mk b">-t</code>运行该命令。这将给出对象类型，可以是树、blob、提交和带注释的标记。我们主要关心前3个，尤其是blobs(文件)。因此，如果我们得到一个散列并想知道它代表什么类型的对象，我们可以简单地运行:</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="9262" class="ml mm it mk b gy nm nn l no np">$ git cat-file -t f452d40<br/>commit</span></pre><p id="0d73" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">我们已经涉及了相当多的领域，所以让我们停下来记下一些事情:</p><ul class=""><li id="c8f9" class="nz oa it lj b lk ll ln lo me ob mf oc mg od mc oe of og oh bi translated">所有与Git相关的东西都存储在<code class="fe mh mi mj mk b">.git/</code>目录中</li><li id="0bd3" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated"><code class="fe mh mi mj mk b">HEAD</code>存储对分支负责人的引用。在我们的例子中，我们只有<code class="fe mh mi mj mk b">master</code></li><li id="560f" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated">Git以对象的形式存储所有东西，对象是基于它们的散列来存储的。这是一个伟大的设计决策，因为这意味着<strong class="lj jd">相同的对象只存储一次</strong>，没有不必要的冗余。</li><li id="3b7a" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated">对象存储在以其散列的前两个字符命名的子目录内的<code class="fe mh mi mj mk b">.git/objects/</code>中(例如<code class="fe mh mi mj mk b">.git/objects/f4</code></li><li id="227a" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated">我们可以使用<code class="fe mh mi mj mk b">git cat-file</code>通过带有标志<code class="fe mh mi mj mk b">-t</code>的散列来获取对象的类型，以及带有标志<code class="fe mh mi mj mk b">-p</code>的可读格式的实际内容</li></ul><p id="c80b" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">厉害！但是我们还没完。让我们再深入一点。</p><h2 id="b540" class="ml mm it bd mn mo mp dn mq mr ms dp mt me mu mv mw mf mx my mz mg na nb nc iz bi translated"><strong class="ak">树和二进制大对象(斑点)</strong></h2><p id="9eb1" class="pw-post-body-paragraph lg lh it lj b lk nd kd lm ln ne kg lp me nf ls lt mf ng lw lx mg nh ma mb mc im bi translated">我们上面检查的提交对象包含对树的引用。让我们通过执行与上面相同的操作来检查这是什么——在<code class="fe mh mi mj mk b">git-tests</code>中将对象下载到我们的本地<code class="fe mh mi mj mk b">.git/</code>。</p><p id="d804" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">实际上，<strong class="lj jd">我们正在构建服务器Git目录的镜像，这样我们就可以看到他们的源代码</strong>，并有可能攻击它。</p><blockquote class="ld le lf"><p id="f9e2" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">作者注</strong></p><p id="1a9a" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在真正的攻击中，这当然会通过自动化脚本来完成。编写一个非常简单，但这里不讨论。我们感兴趣的是Git如何工作，而不是Python脚本，所以我们将手动操作。</p></blockquote><p id="a3a3" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">继续，我的树对象在提交中被引用，如下所示:</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="8b1a" class="ml mm it mk b gy nm nn l no np">tree 2764257f81462ae8f9b26ab16d08de153db0cc2b</span></pre><p id="9186" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">所以我想做的是用这个新散列运行相同的<code class="fe mh mi mj mk b">curl</code>命令:</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="99da" class="ml mm it mk b gy nm nn l no np">$ mkdir .git/objects/27</span><span id="e6dc" class="ml mm it mk b gy nq nn l no np">$ curl localhost:8000/.git/objects/27/64257f81462ae8f9b26ab16d08de153db0cc2b --output ./.git/objects/27/64257f81462ae8f9b26ab16d08de153db0cc2b</span></pre><p id="6c95" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">然后，<code class="fe mh mi mj mk b">git cat-file</code>(有些重复是好的，但是在这之后我就不再重复这些命令了):</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="7ac5" class="ml mm it mk b gy nm nn l no np">$ git cat-file -p 2764257</span></pre><p id="d6fd" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">你看看那个！</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="0cdc" class="ml mm it mk b gy nm nn l no np">100644 blob b7ea4906d2ac64060e01b35530a922c65f063831 config.php</span><span id="3e58" class="ml mm it mk b gy nq nn l no np">100644 blob 5d4522cc30964b73ccd6855b42de805bf4ef59cc error.php</span><span id="691e" class="ml mm it mk b gy nq nn l no np">100644 blob 9f192b766a623127d8adbc6af01c120a58d8e1f0 index.php</span></pre><p id="33ad" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">我们得到了服务器根目录的目录结构！</p><p id="5854" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">由此，我们可以得出一个重要的结论:树，在Git中，只是引用其他Git对象的数据结构。因此，Git中的目录被表示为引用blobs(文件)和其他树(目录)的树。</p><p id="2bca" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">例如，如果我们的服务器中有一个<code class="fe mh mi mj mk b">vendor/</code>子目录，它将显示为我们刚才检查的树中引用的树。</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="3f17" class="ml mm it mk b gy nm nn l no np">100644 blob b7ea4906d2ac64060e01b35530a922c65f063831 config.php</span><span id="dd0e" class="ml mm it mk b gy nq nn l no np">100644 blob 5d4522cc30964b73ccd6855b42de805bf4ef59cc error.php</span><span id="7a02" class="ml mm it mk b gy nq nn l no np">100644 blob 9f192b766a623127d8adbc6af01c120a58d8e1f0 index.php</span><span id="65fd" class="ml mm it mk b gy nq nn l no np">040000 tree              SOME_HASH                   vendor</span></pre><p id="b137" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">还有，左边的数字只是Git模式。目录是040000，因为权限被忽略。100644是不可执行的，100755是可执行的。还有其他的，但这是主要的。</p><p id="6b45" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">同样，在我们进入最后一步之前，让我们回顾一些重要的学习点。这里有一个开始的图表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/6cec9fcb48db3001d43e9787867613dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vAwSz_mHe_M6ZEtUPamnfQ.png"/></div></div></figure><p id="b419" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">等等，但是那张图的箭头指向了错误的方向！</p><p id="c2ef" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">实际上，虽然大多数在线Git图表会向您显示从第一次提交到<code class="fe mh mi mj mk b">HEAD</code>的箭头，但我们在这里了解到提交实际上引用了它们的父级，而不是它们的子级。</p><p id="4881" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">同样，这也是一个好的设计决策。如果提交引用了它们的子对象，那么上图中的第二个提交将不得不保留两个引用，而不是一个。实际上，它必须能够处理越来越多的孩子。</p><p id="a565" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">另一方面，这样做可以确保每个提交只有一个对另一个提交的引用，除非它们是第一个提交(没有父提交)或合并提交(有两个父提交)。并且任意数量的提交可以依次引用同一个父节点，从而创建分支。</p><p id="fca2" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">最后，正如我们所做的，为了找到一个分支的<code class="fe mh mi mj mk b">HEAD</code>，我们在<code class="fe mh mi mj mk b">.git/refs/heads/&lt;branch_name&gt;</code>下检查它。在Git中，我们总是有一个对每个叶节点(代表每个分支)的引用，并从它们向根节点遍历，而不是反过来。</p><p id="f221" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">现在，我们来谈谈另外几点:</p><ul class=""><li id="e268" class="nz oa it lj b lk ll ln lo me ob mf oc mg od mc oe of og oh bi translated">当您<code class="fe mh mi mj mk b">git add</code>文件时，它们的对象在<code class="fe mh mi mj mk b">objects/</code>中被创建，但是提交对象没有被创建</li><li id="de06" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated">当您<code class="fe mh mi mj mk b">git commit</code>时，所有的引用都被更新，以反映分支中的变化。最重要的是，先前的<code class="fe mh mi mj mk b">HEAD</code>(提交)获得了对新的<code class="fe mh mi mj mk b">HEAD</code>的引用，因此<code class="fe mh mi mj mk b">.git/HEAD</code>将通过<code class="fe mh mi mj mk b">.git/refs/heads/&lt;branch_name&gt;</code>指向新的<code class="fe mh mi mj mk b">HEAD</code></li><li id="aaa8" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated">分支也是引用之上的引用。它们与另一个分支共享一个commit(比如<code class="fe mh mi mj mk b">master</code>)，这就是为什么在合并时很容易检查分支之间的变化。Git需要做的就是从<code class="fe mh mi mj mk b">HEAD</code>开始跟踪对每个提交的父提交的引用，直到到达发生拆分的提交。然后，它在另一个分支上跟踪该提交的子提交，直到到达<code class="fe mh mi mj mk b">HEAD</code>并比较树。这可以从<strong class="lj jd">任何分支到任何其他分支进行，</strong>因为它们最终都是<code class="fe mh mi mj mk b">master</code>的一部分。</li><li id="d660" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated">上面的这一点也意味着，如果您从任何下游分支的<code class="fe mh mi mj mk b">HEAD</code>开始跟踪引用，您将最终到达您的存储库中的第一个提交(<a class="ae md" href="https://stackoverflow.com/questions/5689960/how-do-i-create-a-commit-without-a-parent-in-git" rel="noopener ugc nofollow" target="_blank">除了孤儿分支的特殊情况</a>)</li><li id="16f6" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated">提交包含对其父级的引用，但最重要的是，对树的引用是提交后项目的快照。这就是为什么我们实际上可以用Git回顾过去，在任何给定的提交上看到我们项目的整个状态。</li><li id="2273" class="nz oa it lj b lk oi ln oj me ok mf ol mg om mc oe of og oh bi translated">上面这一点也暴露了Git的危险，尤其是在与GitHub或GitLab这样的平台配对时。如果您没有明确删除过去的对象和提交，项目的整个过去将对那些有权访问该存储库的人可见。如果回购以前是私有的，后来变成了公共的，那么它的整个过去都将是可用的。因此，如果你在一个项目中添加了一些你不应该添加的东西(比如一个API密匙，或者更糟，一个密码)，一个新的提交删除它是不够的。您必须实际删除相应的对象并提交。幸运的是，Git确实有一些命令可以帮助你做到这一点，所以你不需要继续在一堆奇怪的散列命名的文件上运行<code class="fe mh mi mj mk b">rm</code>。</li></ul><h2 id="2426" class="ml mm it bd mn mo mp dn mq mr ms dp mt me mu mv mw mf mx my mz mg na nb nc iz bi translated">要去杀人了</h2><p id="1afe" class="pw-post-body-paragraph lg lh it lj b lk nd kd lm ln ne kg lp me nf ls lt mf ng lw lx mg nh ma mb mc im bi translated">如果你已经仔细阅读了整个教程，你现在应该知道接下来会发生什么，以及如何去做。</p><p id="7697" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">执行与上面相同的步骤，我们可以下载<code class="fe mh mi mj mk b">config.php</code>文件，我们现在知道它的散列，并检查它的内容。</p><pre class="ks kt ku kv gt ni mk nj nk aw nl bi"><span id="f002" class="ml mm it mk b gy nm nn l no np">$ git cat-file -p b7ea4906d2</span><span id="135d" class="ml mm it mk b gy nq nn l no np">&lt;?php</span><span id="c780" class="ml mm it mk b gy nq nn l no np">    if(!isset($_SERVER['HTTP_REFERER'])){<br/>        header('location: ../error.php');<br/>        exit;<br/>    }</span><span id="bced" class="ml mm it mk b gy nq nn l no np">    define('DB_USER', 'admin');<br/>    define('DB_PASSWORD', 'password123');<br/>?&gt;</span></pre><p id="b397" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">在我们的例子中，我们“发现”了一个数据库的用户名和密码。这可能对你来说很荒谬，但是很多网站都像这样被黑过。</p><p id="26d2" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">即使您没有明文获得敏感信息，您仍然可以访问整个源代码，这意味着人们可以进行各种其他攻击。</p><h2 id="8417" class="ml mm it bd mn mo mp dn mq mr ms dp mt me mu mv mw mf mx my mz mg na nb nc iz bi translated">结论</h2><p id="45a4" class="pw-post-body-paragraph lg lh it lj b lk nd kd lm ln ne kg lp me nf ls lt mf ng lw lx mg nh ma mb mc im bi translated">我希望这篇教程给你上了一些有用的课，既有关于Git如何工作的，也有一些与其误用相关的危险。虽然Git比我们在这里经历的要多得多，但我相信这应该是一个好的开始。</p><p id="d8fb" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">我自己远不是一个Git专家，但是这个简单的知识让我的版本控制游戏有了显著的升级。</p><p id="3784" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">再一次，你可以在这里找到我浏览过的所有源代码。如果有任何错误或者我没有解释清楚的地方，请告诉我——我会很乐意尝试改正。</p><p id="d873" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">最后，要了解更多，我强烈建议你在你的<code class="fe mh mi mj mk b">.git/</code>目录中四处看看，如果你真的感兴趣，你可以看看Git的<a class="ae md" href="https://github.com/git/git" rel="noopener ugc nofollow" target="_blank">源代码</a>。我也推荐下面的视频:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3dc1" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp me lr ls lt mf lv lw lx mg lz ma mb mc im bi translated">这就是我要说的。谢谢大家！</p></div></div>    
</body>
</html>