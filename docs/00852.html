<html>
<head>
<title>Reusability by using container components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过使用容器组件实现可重用性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/container-and-presentational-components-in-react-c56aca7713ba?source=collection_archive---------0-----------------------#2019-08-24">https://levelup.gitconnected.com/container-and-presentational-components-in-react-c56aca7713ba?source=collection_archive---------0-----------------------#2019-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/78b432b3407dea2fa63ee2c830d1fdc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ys09xKpQ26fD_X1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">弗兰克·麦肯纳在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d2b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React旨在通过改进我们构建UI组件的方式来解决现代前端开发中的一些复杂性。其中的一个核心原则是构建可重用的组件。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="ed41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提高组件可重用性的一个方法是让它们具有单一的职责。获取将要用来构建UI的数据的组件有两个职责，获取数据和呈现数据。为了避免这种情况，解决方案是制造容器组件。</p><p id="d75f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">容器组件是呈现另一个组件的组件，它是一种高阶组件。容器组件负责获取数据，然后将其传递给其他组件。当然，容器组件并不严格地用于获取数据，它们可以做其他计算或逻辑相关的杂务。</p><p id="bbd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我自己更清楚一点，这里有一个例子:一个<code class="fe li lj lk ll b">PostList</code>组件可能循环遍历一个post数组，并为数组中的每个post对象呈现一个<code class="fe li lj lk ll b">Post</code>组件。如果<code class="fe li lj lk ll b">PostList</code>正在获取帖子的数组，那么每当我们想要重用组件时，我们就不得不请求数据。</p><p id="a3cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想在应用程序的另一部分呈现一个帖子列表，而这次我们不想要来自我们在<code class="fe li lj lk ll b">PostList</code>组件中调用的端点的帖子，该怎么办？我们可以让<code class="fe li lj lk ll b">PostList</code>把端点作为一个参数。然后，我们可能希望使用来自两个端点的帖子，并连接数组并呈现它们。关键是我们很快就会遇到问题。</p><p id="984e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免在<code class="fe li lj lk ll b">PostList</code>组件中获取数据，我们可以创建一个<code class="fe li lj lk ll b">PostListContainer</code>组件来请求数据，并在其render方法中呈现一个<code class="fe li lj lk ll b">&lt;PostList posts={posts} /&gt;</code>。这样,<code class="fe li lj lk ll b">PostList</code>只关心表示，数据作为参数传递。现在可以重用<code class="fe li lj lk ll b">PostList</code>了，如果我们有一个来自上述端点的帖子数组，我们就有了规范化的数据(一个帖子数组)，我们可以将它传递给<code class="fe li lj lk ll b">PostList</code>。</p><p id="a8c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在代码中，容器组件可能如下所示:</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="c0b4" class="lu lv iq ll b gy lw lx l ly lz"><strong class="ll ir">// PostListContainer.js</strong></span><span id="8690" class="lu lv iq ll b gy ma lx l ly lz">const endpoint = `https://jsonplaceholder.typicode.com/posts`</span><span id="6414" class="lu lv iq ll b gy ma lx l ly lz">const <strong class="ll ir">PostListContainer</strong> = () =&gt; {<br/>  const [posts, setPosts] = useState([])</span><span id="ba9f" class="lu lv iq ll b gy ma lx l ly lz">  useEffect(() =&gt; {<br/>    const fetchData = async (id) =&gt; {<br/>      const response = await fetch(endpoint);<br/>      const posts = await response.json()<br/>      setPosts(posts)<br/>    }<br/>    fetchData();<br/>  },[posts]);<br/>  <br/>  return(<br/>    &lt;<strong class="ll ir">PostList</strong> posts={posts} /&gt;<br/>  )<br/>}</span></pre><p id="c4e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">容器获取数据并将其传递给<code class="fe li lj lk ll b">PostList</code>，只要得到一个posts数组，<code class="fe li lj lk ll b">PostList</code>就会一直正常工作。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="3c51" class="lu lv iq ll b gy lw lx l ly lz"><strong class="ll ir">// PostList.js</strong></span><span id="f569" class="lu lv iq ll b gy ma lx l ly lz">const <strong class="ll ir">PostList</strong> = ({ posts }) =&gt; (<br/>  &lt;div&gt;<br/>    {posts.map(post =&gt;<br/>      &lt;<strong class="ll ir">Post</strong><br/>        key={post.id}<br/>        title={post.title}<br/>        body={post.body}<br/>      /&gt;)}<br/>  &lt;/div&gt;<br/>)</span></pre><p id="3a29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在其他组件中重用<code class="fe li lj lk ll b">PostList</code>。如果我们在<code class="fe li lj lk ll b">PostList</code>中获取数据，组件就不容易重用。</p><p id="7f7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">制作容器组件的另一个好处是，当<code class="fe li lj lk ll b">PostList</code>只关心表示时，为它编写测试更容易，因为现在它只有一个职责。</p><h2 id="e0d9" class="lu lv iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">概括起来</h2><p id="9231" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">具有单一职责的组件更容易重用和测试。容器组件是分离关注点的一种方式。容器组件可能负责获取数据，并在其render方法中，将数据传递给表示组件，表示组件反过来只负责UI显示数据。</p></div></div>    
</body>
</html>