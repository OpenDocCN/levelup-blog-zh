<html>
<head>
<title>The Saga pattern in Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务中的传奇模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-saga-pattern-in-microservices-fbed0b90bf92?source=collection_archive---------5-----------------------#2021-02-11">https://levelup.gitconnected.com/the-saga-pattern-in-microservices-fbed0b90bf92?source=collection_archive---------5-----------------------#2021-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="19a3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理分布式事务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b657220ffb0075c5e93393266bc0e7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6c51Eng452hyANIS7Cy9CA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">paweczerwi ski在<a class="ae kv" href="https://unsplash.com/s/photos/saga-pattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7f4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一切正常时，API组合和CQRS模式可以为分布式查询提供合适的解决方案。</p><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/running-distributed-queries-in-micro-services-157b12b93154"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">在微服务中运行分布式查询</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">CQRS和API组合方法</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="2339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，维护分布式数据的完整性是复杂的。如果将所有数据存储在单个关系数据库中，并在模式中指定适当的约束，则可以依靠数据库引擎来维护数据完整性。</p><p id="6231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当多个微服务将数据保存在隔离的数据存储中(关系或非关系)时，情况就大不相同了。数据完整性很关键，但必须通过代码来维护。传奇模式解决了这个问题。</p><h2 id="5f9e" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">酸</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/81324806852cb11837a0ee857f6f9795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZBEDCA3Gvzsf8TNNQ6E1g.jpeg"/></div></figure><p id="401c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据完整性的一个常见衡量标准是所有修改数据的事务都具有ACID属性:</p><ul class=""><li id="8a84" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><strong class="ky ir">原子:</strong>事务中的所有操作要么成功，要么全部失败。</li><li id="69d9" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">一致:</strong>数据状态满足事务前后的所有约束</li><li id="719f" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">隔离:</strong>并发事务的行为就像它们被序列化了一样。</li><li id="f8de" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">持久:</strong>当事务成功完成时，结果被持久化。</li></ul><p id="fa85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ACID属性并不特定于关系数据库，但经常在这种上下文中使用，主要是因为关系模式及其形式约束提供了一种方便的一致性度量。隔离属性通常会严重影响性能，一些偏好高性能和最终一致性的系统可能会放宽隔离属性。</p><h2 id="81ed" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">CAP定理</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7a07218e6bdfb8900bf75100f5be37e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*7w5OpqT1M7YJ9KNbCC2smQ.jpeg"/></div></figure><p id="f460" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CAP定理指出，分布式系统不能同时具有以下三个属性:</p><ul class=""><li id="fcb9" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><strong class="ky ir">一致性:</strong>是指无论客户端请求来自什么路径，所有客户端都会同时看到相同的数据。这对于频繁更新的应用程序来说至关重要。</li><li id="04cf" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">可用性:</strong>意味着所有运行的应用程序组件都将返回有效的响应，即使它们关闭了。如果应用程序的用户群体对停机的容忍度较低(例如零售门户)，这一点尤其重要。</li><li id="e1ce" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">分区弹性</strong>:意味着即使在网络故障导致服务间消息丢失或延迟的情况下，应用程序也能运行。这在集成了大量分布式独立组件的应用程序中发挥了作用。</li></ul><p id="81f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实践中，您需要选择是实施CP系统还是AP系统。CP系统(一致的和分区弹性的)总是一致的，并且如果组件之间存在网络分区，CP系统将不会提供查询或做出改变。它只能在系统完全连接后运行。显然，这意味着你没有可用性。</p><p id="d8b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，AP系统(可用且具有分区弹性)总是可用的，并且可以以裂脑方式运行。当系统被拆分时，每个部分可能会继续正常运行，但系统会变得不一致，因为每个部分都不知道其他部分正在发生什么。</p><p id="9592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AP系统通常被称为最终一致系统，因为当连接恢复时，某些协调过程可以确保整个系统再次同步。一个有趣的变体是冻结系统，当网络分区发生时，它们正常降级，两部分继续处理查询，但拒绝对系统的所有修改。请注意，由于分区中的一些事务可能仍然无法复制到另一个部分，因此不能保证这两个部分在分区期间是一致的。一般来说，这已经足够好了，因为分割部分之间的差异很小，并且不会因为拒绝新的更改而随着时间的推移而增加。</p><h2 id="5045" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">传奇模式</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/c3cd1e04e28f6d7b0c348478b4d16627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5TmAgQqwZK62HlDt.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自microservices.io</figcaption></figure><p id="a8f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">saga模式的基本思想是集中管理所有微服务的操作，对于每一个操作，如果因为某种原因无法完成整个事务，就会进行一次补偿操作。这实现了酸的原子性。然而，每个微服务上的变化是立即可见的，而不仅仅是在整个分布式事务结束时。这违反了一致性和隔离属性。如果你把你的系统设计成AP(最终一致)，这不是问题。但是，它要求您的代码意识到这一点，并能够使用可能部分不一致或过期的数据。在许多情况下，这是一个可以接受的妥协。</p><p id="2c44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传奇模式是如何运作的？Saga是对微服务的一套操作和相应的补偿操作。当一个操作失败时，它的补偿操作和所有以前的补偿操作将以相反的顺序被调用，以回滚系统的整个状态。</p><p id="658d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Sagas的实现并不容易，因为补偿操作也可能失败。通常，转换状态必须是持久的，并且必须被如此标记，并且必须存储大量元数据以实现可靠的回滚。一个好的做法是经常运行带外进程，并清除无法实时完成所有补偿操作的错误Sagas。思考传奇的一个好方法是将其视为一个工作流程。工作流很酷，因为它们可以实现长流程，甚至涉及到人，而不仅仅是软件。</p><p id="1af1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种类型的传奇:</p><ul class=""><li id="97c7" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><strong class="ky ir">基于编排的Saga: </strong>在这种方法中，有一个Saga编排器管理所有事务，并指导参与者服务基于事件执行本地事务。这位指挥者也可以被认为是一位传奇经理人。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/97a84300ff53c379f0530fcbe8191ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l6Rs8BIorqEV-b1L.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自microservices.io</figcaption></figure><ul class=""><li id="f828" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><strong class="ky ir">基于编舞的传奇:</strong>在这种方法中，没有中央指挥。参与Saga的每个服务执行它们的事务和发布事件。其他服务根据这些事件进行操作，并执行它们的事务。此外，他们可能会或不会根据情况发布其他事件。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/b05b38bc4b1fa64a1f5a43bb2d7b4750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NLPXcFzSYDlgerpy.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自microservices.io</figcaption></figure><h2 id="da31" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">结论</h2><p id="bdc0" class="pw-post-body-paragraph kw kx iq ky b kz nw jr lb lc nx ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">Saga模式的主要优点是，它可以帮助维护多个服务之间的数据一致性，而无需紧密耦合。这是微服务架构的一个极其重要的方面。</p><p id="6ea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，从编程的角度来看，Saga模式的主要缺点是明显的复杂性。另一个挑战是，补偿交易还必须设计成让传奇故事正常运行。</p><p id="01fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">明智地选择您的数据库。然后，设计您的微服务工作流和框架，以确保您不会破坏您的目标</p></div></div>    
</body>
</html>