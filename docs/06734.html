<html>
<head>
<title>Modifying The Linux Kernel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修改Linux内核</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-your-own-system-calls-part-2-process-weights-97d5e66f56f3?source=collection_archive---------1-----------------------#2020-12-24">https://levelup.gitconnected.com/create-your-own-system-calls-part-2-process-weights-97d5e66f56f3?source=collection_archive---------1-----------------------#2020-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何添加新的系统调用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5e818d3a2effe91362bd817f70376c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rs7H2Diz6G7pP-4-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何修改linux内核，添加我们自己独特的系统调用，并最终用我们添加的功能构建内核。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始修改Linux内核之前，我们必须以某种方式下载它。我将详细说明我所采取的步骤，因此请确保您准确地遵循这些步骤，以保证获得相同的结果。</p><ul class=""><li id="3fe0" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">下载虚拟机软件，如Vmware \ VirtualBox</li><li id="33b6" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">下载一张Ubuntu 18.04的图片<a class="ae ky" href="http://releases.ubuntu.com/18.04/" rel="noopener ugc nofollow" target="_blank">http://releases.ubuntu.com/18.04/</a></li><li id="37dd" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">使用下载的映像从虚拟机软件设置虚拟操作系统</li></ul><p id="b510" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦Ubuntu加载完毕，打开终端并跟随操作</p><ul class=""><li id="7050" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">安装先决条件</li></ul><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="a141" class="mv mw it mr b gy mx my l mz na">&gt;&gt; sudo sed -i "s/# deb-src/deb-src/g" /etc/apt/sources.list<br/>&gt;&gt; sudo apt update -y<br/>&gt;&gt; sudo apt install -y build-essential libncurses-dev bison flex<br/>&gt;&gt; sudo apt install -y libssl-dev libelf-dev</span></pre><ul class=""><li id="cc2f" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">下载Linux源代码</li></ul><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="35c4" class="mv mw it mr b gy mx my l mz na">&gt;&gt; cd ~<br/>&gt;&gt; apt source linux</span></pre><ul class=""><li id="9969" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">更改权限和重命名文件夹</li></ul><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="fddc" class="mv mw it mr b gy mx my l mz na">&gt;&gt; sudo chown -R student:student ~/linux-4.15.0/<br/>&gt;&gt; mv ~/linux-4.15.0 ~/linux-4.15.18-custom</span></pre><ul class=""><li id="a4c5" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">配置内核构建过程</li></ul><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="865f" class="mv mw it mr b gy mx my l mz na">&gt;&gt; cd ~/linux-4.15.18-custom<br/>&gt;&gt; cp -f /boot/config-$(uname -r) .config<br/>&gt;&gt; geany .config<br/># search the CONFIG_LOCALVERSION parameter and set it to "-custom"<br/>&gt;&gt; yes '' | make localmodconfig<br/>&gt;&gt; yes '' | make oldconfig</span></pre><ul class=""><li id="da25" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">编译内核</li></ul><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="ae49" class="mv mw it mr b gy mx my l mz na">&gt;&gt; make -j $(nproc)</span></pre><ul class=""><li id="3286" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">安装内核模块和映像</li></ul><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="116a" class="mv mw it mr b gy mx my l mz na">&gt;&gt; sudo make modules_install<br/>&gt;&gt; sudo make install</span></pre><ul class=""><li id="b448" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">配置GRUB</li></ul><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="e801" class="mv mw it mr b gy mx my l mz na">&gt;&gt; sudo geany /etc/default/grub</span></pre><p id="001a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件打开后，请执行以下操作</p><ul class=""><li id="4dae" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">将“GRUB_DEFAULT”设置为“Ubuntu，带Linux 4 . 15 . 18-自定义”</li><li id="3d0d" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">将“GRUB_TIMEOUT_STYLE”设置为菜单</li><li id="012c" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">将“GRUB_TIMEOUT”设置为5</li><li id="9fd5" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">在的末尾添加一行:“GRUB_DISABLE_SUBMENUE=y”</li></ul><p id="3916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们必须生成GRUB配置文件，并使用</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="0bfb" class="mv mw it mr b gy mx my l mz na">&gt;&gt; sudo update-grub<br/>&gt;&gt; sudo reboot</span></pre><p id="7060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦操作系统启动，确保您加载了自定义内核</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="be45" class="mv mw it mr b gy mx my l mz na">&gt;&gt; uname -r</span></pre><p id="e65b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果应该是“4 . 15 . 18-自定义”</p><p id="3266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我们完成了先决条件，是时候编码了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="043c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将要添加的功能称为进程权重。<br/>顾名思义，我们将为每个流程分配一个权重，以表示它有多“重”。</p><p id="5f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望保持的两种行为是:</p><ul class=""><li id="8318" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">当一个进程被分叉时，子进程将拥有与其父进程相同的权重</li><li id="45af" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">初始化进程权重将为0</li></ul><p id="c4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将要实现的系统调用将能够</p><ul class=""><li id="9439" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">设置当前流程的权重</li><li id="65de" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">递归获取当前进程的总权重</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f31c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要以某种方式告诉每个过程“仅供参考，您现在有一个重量了”。为了做到这一点，打开<code class="fe nb nc nd mr b">~/linux-4.15.18-custom/include/linux/sched.h<br/></code>并在结构<code class="fe nb nc nd mr b">task_struct</code>中添加一个属性<code class="fe nb nc nd mr b">int weight</code></p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="d824" class="mv mw it mr b gy mx my l mz na">struct task_struct {<br/>#ifdef CONFIG_THREAD_INFO_IN_TASK<br/> /*<br/>  * For reasons of header soup (see current_thread_info()), this  <br/>  * must be the first element of task_struct.<br/>  */ <br/>struct thread_info  thread_info;<br/>#endif<br/> /* -1 unrunnable, 0 runnable, &gt;0 stopped: */ <br/><strong class="mr iu"><em class="ne">int                  weight;</em> #line 569</strong><br/>volatile long   state; <br/>/*  <br/> * This begins the randomizable portion of task_struct. Only<br/> * scheduling-critical items should be added above here.  <br/> */ <br/>randomized_struct_fields_start</span></pre><p id="4342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们想告诉每一个进程他的初始权重是多少，为了做到这一点，在与之前相同的目录下，打开<code class="fe nb nc nd mr b">init_task.h</code>——转到<code class="fe nb nc nd mr b">INIT_TASK</code>的宏定义，并为您刚刚添加的权重属性添加一个初始化。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="f80c" class="mv mw it mr b gy mx my l mz na">#define INIT_TASK(tsk) \<br/>{         \<br/> INIT_TASK_TI(tsk)      \<br/><strong class="mr iu"><em class="ne"> .weight  = 0,      \ #line 228</em></strong><br/> .state  = 0,      \<br/> .stack  = init_stack,     \<br/>...</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一节中，我们能够告诉每个进程，它有一个名为weight的新属性，并且每当创建一个新进程时，该属性应该初始化为0。</p><p id="73d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我们将着重于为我们的新系统调用建立基础。</p><p id="5aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到<code class="fe nb nc nd mr b">~/linux-4.15.18-custom/arch/x86/entry/syscalls/</code>并打开<code class="fe nb nc nd mr b">syscall_64.tbl</code> <br/>滚动到文件底部并保留您的系统调用号</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="f7d0" class="mv mw it mr b gy mx my l mz na">...<br/>332 common statx   sys_statx<br/>333 common hello   sys_hello<br/><strong class="mr iu"><em class="ne">334 common set_weight  sys_set_weight<br/>335 common get_total_weight sys_get_total_weight<br/>...</em></strong></span></pre><p id="a672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将创建我们的系统调用签名。转到同一目录下的<code class="fe nb nc nd mr b">syscalls.h</code>,滚动到文件底部</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="29eb" class="mv mw it mr b gy mx my l mz na">...<br/>asmlinkage long sys_pkey_free(int pkey);<br/>asmlinkage long sys_statx(int dfd, const char __user *path, unsigned  flags,     unsigned mask, struct statx __user *buffer);<br/>asmlinkage long sys_hello(void);<br/><strong class="mr iu"><em class="ne">asmlinkage long sys_set_weight(int weight); #line 944<br/>asmlinkage long sys_get_total_weight(void);</em></strong><br/>#endif</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="9b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经设置好了一切，唯一缺少的是这些新系统调用的实现。</p><p id="6009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到<code class="fe nb nc nd mr b">~/linux-4.15.18-custom/kernel</code>并创建一个名为<code class="fe nb nc nd mr b">syscalls_weight.c</code>的新文件。<br/>不要忘记进入同一个目录下的<code class="fe nb nc nd mr b">Makefile</code>,并将您的新文件添加到构建过程中</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="7d7b" class="mv mw it mr b gy mx my l mz na"># SPDX-License-Identifier: GPL-2.0<br/>#<br/># Makefile for the linux kernel.<br/># <br/>obj-y = fork.o exec_domain.o panic.o \<br/>cpu.o exit.o softirq.o resource.o \ <br/>sysctl.o sysctl_binary.o capability.o ptrace.o user.o \ <br/>signal.o sys.o umh.o workqueue.o pid.o task_work.o \ <br/>extable.o params.o \ <br/>kthread.o sys_ni.o nsproxy.o \ <br/>notifier.o ksysfs.o cred.o reboot.o \ <br/>async.o range.o smpboot.o ucount.o hello_syscall.o<strong class="mr iu"><em class="ne"> syscalls_weight.o<br/></em></strong>...</span></pre><p id="a3f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开您刚刚创建的文件<code class="fe nb nc nd mr b">syscalls_weight.c</code>，让我们实现新的系统调用。</p><p id="77a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，包括以下库</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="b1e8" class="mv mw it mr b gy mx my l mz na">#include &lt;linux/kernel.h&gt;<br/>#include &lt;linux/list.h&gt;<br/>#include &lt;linux/module.h&gt;<br/>#include &lt;linux/sched.h&gt;</span></pre><p id="8275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从<code class="fe nb nc nd mr b">sys_set_weight</code>的实现开始</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="ea72" class="mv mw it mr b gy mx my l mz na">asmlinkage long sys_get_weight(int weight){<br/>  if(weight &lt; 0){<br/>    return -EINVAL;<br/>  }<br/>  current-&gt;weight = weight;<br/>  return 0;<br/>}</span></pre><p id="2491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的几件事</p><ul class=""><li id="882d" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><code class="fe nb nc nd mr b">current</code>是当前运行任务的指针</li><li id="09cd" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">syscalls的约定是如果成功就返回0，如果出现错误就返回负值，这正是我们所做的(考虑到我们不想允许负权重)。</li></ul><p id="dd0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到下一个syscall实现，我们将首先定义另一个对我们有帮助的函数</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="b85d" class="mv mw it mr b gy mx my l mz na">int traverse_children_sum_weight(struct task_struct *root_task){<br/>  struct task_struct *task;<br/>  struct list_head *list;<br/>  int sum = root_task-&gt;weight;<br/> <br/>  list_for_each(list, &amp;root_task-&gt;children){<br/>    task = list_entry(list, struct task_struct, sibling);<br/>    sum += traverse_children_sum_weight(task, true);<br/>  }<br/>  return sum;</span></pre><p id="f89e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们的系统调用实现将是</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="9a0f" class="mv mw it mr b gy mx my l mz na">asmlinkage long sys_get_total_weight(void){<br/>  return traverse_children_sum_weight(current);<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做到了。你现在所要做的就是构建你的内核，重启你的机器，然后你就可以自由地使用你刚刚创建的这些全新的内核特性了。</p><p id="ae77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要构建并重启，只需执行以下命令</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="50a1" class="mv mw it mr b gy mx my l mz na">make -j $(nproc)<br/>sudo cp -f arch/x86/boot/bzImage /boot/vmlinuz-4.15.18-custom <br/>sudo reboot</span></pre><p id="ea8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能想到一些有趣的新功能吗？也许这将是你的下一个编码项目。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9689" class="nf mw it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">最后一句话</h1><p id="553c" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">如果你想看更多关于这个话题和其他话题的内容，可以看看我的博客。</p></div></div>    
</body>
</html>