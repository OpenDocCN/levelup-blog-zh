<html>
<head>
<title>Sorting Algorithms: Quick Sort — Practical Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法:快速排序——实用的深度分析</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sorting-algorithms-quick-sort-ed0fbbdd0d40?source=collection_archive---------5-----------------------#2022-05-14">https://levelup.gitconnected.com/sorting-algorithms-quick-sort-ed0fbbdd0d40?source=collection_archive---------5-----------------------#2022-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6e09" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速排序是有史以来最有趣和最流行的排序算法之一。它基于分而治之的方法，快速，实用，有趣。我们将讨论使用快速排序时的实现细节以及需要考虑和记住的最重要的事情。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40138129aaa58d3f6d7d8d66e44c0cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8Dqev00qVtQfmd64y6G7w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">快速排序介绍</figcaption></figure><h1 id="5c36" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">内容</h1><ul class=""><li id="c3aa" class="lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ls iu">什么是快速排序算法？</strong></li><li id="edf0" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><strong class="ls iu">它是如何与详细的例子一起工作的？</strong></li><li id="6445" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><strong class="ls iu">让我们写一个快速排序的代码(递归&amp;迭代)</strong></li><li id="225f" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><strong class="ls iu">时间复杂度与多示例</strong></li><li id="3800" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><strong class="ls iu">空间复杂度</strong></li><li id="4ec6" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><strong class="ls iu">常见问题解答</strong></li><li id="59fc" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><strong class="ls iu">结论</strong></li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9399" class="ky kz it bd la lb mu ld le lf mv lh li jz mw ka lk kc mx kd lm kf my kg lo lp bi translated">什么是快速排序算法？</h1><p id="ca9c" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">快速排序类似于合并排序，基于分治法。它首先选择一个元素作为<strong class="ls iu">枢轴</strong>并使用它来划分数组。</p><p id="191e" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated"><strong class="ls iu">引自维基百科:</strong></p><blockquote class="nr ns nt"><p id="e046" class="mz na nu ls b lt nm ju nb lv nn jx nc nv no ne nf nw np nh ni nx nq nk nl md im bi translated"><strong class="ls iu">快速排序</strong>是一种就地排序算法。该算法由英国计算机科学家东尼·霍尔于1959年开发，并于1961年发表，至今仍是一种常用的排序算法。如果实现得好，它会比<strong class="ls iu">合并排序</strong>快一些，比<strong class="ls iu">堆排序</strong>快两到三倍。</p><p id="d4a8" class="mz na nu ls b lt nm ju nb lv nn jx nc nv no ne nf nw np nh ni nx nq nk nl md im bi translated"><strong class="ls iu">快速排序</strong>是一种<strong class="ls iu">分治算法</strong>。它的工作方式是从数组中选择一个'<strong class="ls iu"> pivot </strong>'元素，并根据其他元素是小于还是大于pivot将它们划分为两个子数组。由于这个原因，它有时被称为<strong class="ls iu">分区交换排序</strong>。然后对子数组进行递归排序。这可以就地完成，需要少量额外的内存来执行排序。</p><p id="4c18" class="mz na nu ls b lt nm ju nb lv nn jx nc nv no ne nf nw np nh ni nx nq nk nl md im bi translated"><strong class="ls iu"> Quicksort </strong>是一个<strong class="ls iu">比较排序</strong>，这意味着它可以对定义了“小于”关系(形式上是总订单)的任何类型的项目进行排序。快速排序的有效实现不是一种稳定的排序，这意味着相等排序项的相对顺序不会被保留。</p></blockquote><h1 id="46ec" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">它是如何工作的</h1><p id="43b1" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">理解任何算法的最好方法是把它分解成它的基础，并开始把它的所有步骤组合成一幅大图。我们将研究快速排序是如何工作的，然后进行一些变化和考虑，以确保我们完全理解它。</p><p id="192c" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">关于快速排序的工作原理，需要理解的重要一点是，在每次迭代中，我们需要选择Pivot，然后把它放到正确的位置。</p><ol class=""><li id="ee47" class="lq lr it ls b lt nm lv nn lx ny lz nz mb oa md ob mf mg mh bi translated">选择任何元素作为pivot(让我们首先假设pivot总是数组的第一个元素，但我们稍后将回到这个假设，看看选择pivot的最佳方式是什么，以及它如何影响算法性能。)</li><li id="cca5" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md ob mf mg mh bi translated">通过将所有最小的元素向左移动，将所有最大的元素向右移动，根据pivot对数组进行分区。</li><li id="0b84" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md ob mf mg mh bi translated">对左分区递归应用快速排序。</li><li id="6083" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md ob mf mg mh bi translated">对右分区递归应用快速排序。</li></ol><h2 id="33d8" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">例子</h2><p id="dadf" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">假设我们有这个数组:<em class="nu"> [8，5，2，9，5，6，3]。</em></p><p id="5c84" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">在第一次迭代中，只需看一下下图就能理解每一步。第一次迭代的目标是将枢纽放在正确的位置，这样左边的所有项目都变小，右边的所有项目都变大。</p><p id="fd8b" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">我们选择了8个作为<strong class="ls iu">支点</strong>，5个作为<strong class="ls iu">左侧</strong>，3个作为<strong class="ls iu">右侧</strong>。因为5小于8，所以它在左手边的正确位置，我们将把左边的指针移动到小于8的2，所以我们将移动到大于枢轴8的9，所以它需要与右边的指针交换。现在让我们看看是否需要交换正确的元素。右边的元素是3，它比主元素小，所以它可以被交换，为此我们将9换成3，并将两个指针移到下一个。依此类推，如下图所示，直到枢轴左边的元素最小，右边的元素最大。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/94e5f80f55cb3dfcfe8d5057ad634de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKcWdl1NLAuQOi_M4RBlgw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第一次迭代</figcaption></figure><p id="2cde" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">现在我们有了一个排序后的条目和两个子数组:<em class="nu">【6，5，2，3，5】</em>和<em class="nu">【9】，所以让我们再次对这两个子数组应用该算法。</em></p><p id="ac43" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">第二次迭代将应用于仅包含一个项目的最小数组，因此它被排序为没有其他项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/47c94ca2f65ec58b0df43bae670c7f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*EIyeWjY91dwK9gRduS3AYA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第二次迭代</figcaption></figure><p id="73a4" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">然后对数组的另一部分进行第三次迭代<em class="nu"> [6，5，2，3，5]: </em></p><p id="42fa" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">选择6作为轴心，5作为左边，另外5作为右边。左侧小于P，因此增加它以将其移动到项目2，2小于主元，因此继续移动到3，它仍然小于主元，因此继续移动。现在，L &amp; R指向5，5小于枢轴，所以从左指针的角度来看，它是排序的，所以将L指针移动到下一项。现在L &amp; R互相交叉，所以让我们用右指针交换支点。现在我们得到了它的排序位置的支点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/6455ce03628608509838cf3d56cf3187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usEk2FHDdqffX30lDs6eCQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第三次迭代</figcaption></figure><p id="5e67" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">第四次迭代:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/2bc7bf196f6d131568ddbe9f8a100309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGMm423zaNOYUp5DG4fbaQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第四次迭代</figcaption></figure><p id="e9e5" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">第五次迭代:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/c98984b9f0e426537c7b892742e3d144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyzosEmixJ8JS74QuhI0Kg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第五次迭代</figcaption></figure><p id="3f8e" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">然后是第6次和第7次迭代:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e6f9a5f9e7133c9c4f755056302f5bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*qCJh56tgWn5DiZk1hxniGg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第6次迭代</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ca895e4488344e0613a48eb0c4df7d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*t-E1eQmqFBezErNzNK0Rkw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第7次迭代</figcaption></figure><h1 id="5b3d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">让我们为此编写一个代码</h1><p id="3f3d" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">现在我们了解了这个算法是如何工作的，让我们把我们的想法放到工作代码中:</p><p id="d12f" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">在下面的代码中，我们完全按照我上面的说明做了。我刚刚创建了另一个助手函数来方便调用主函数。main函数接受array，然后将它发送给带有开始和结束索引的helper方法。</p><p id="8e37" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">然后，如您在第15行中所见，我们选择pivot、left和right索引，然后循环遍历数组，并完全按照我们之前指定的步骤进行分区(如果需要，选择pivot、move和swap)，然后一旦循环结束，就将pivot放在正确的位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="7300" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">正如你在上面的第39行看到的，我们计算左子数组是否更小，所以我们首先调用它的分区，因为这将使算法更快，我们将在后面看到。</p><h2 id="907f" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">更标准…</h2><p id="39e5" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">上面的代码很容易理解，但是如果我们想编写更标准化的快速排序方法，我们需要对代码进行一些组织。</p><p id="60c5" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">正如我们前面讨论的，快速排序的整个思想就是所谓的分区，它只是从选择枢轴开始，将所有最小的元素移到它的左边，将所有最大的项目移到它的右边。</p><p id="cd72" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">因此，为了编写更标准的快速排序，我们可以封装选择枢纽的这一部分，并将元素移动到名为Partition的方法中。</p><p id="761d" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">我们先写分区方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="ca99" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">正如您在上面看到的，这一次，我们没有选择枢轴作为数组的第一项，而是选择了中间元素(我们稍后将讨论选择枢轴的最佳实践以及它如何影响算法的性能，但现在，请记住，您可以选择任何随机枢轴，一些工程师为了便于说明，选择第一项作为枢轴，但这不是最佳实践)</p><p id="8d11" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">在上面的代码中，我们做了和第一个例子完全一样的事情，但是用了一个稍微不同的方法(给你更多的想法)，我们选择了旋转，循环和交换，如果需要的话，直到两个指针(左和右)重叠。</p><p id="8c54" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">在循环过程中，只要左元素小于pivot，就保持它的位置，并将左指针移动到下一个元素(第6行)，然后只要右元素大于pivot，就保持它的位置，并将右指针移动到下一个元素(第7行)。如果left ≤ right，则交换位置并移动指针。下面从3到17的行与上面第一个例子中从15到37的行非常相似。</p><p id="bec5" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">所以现在我们像你上面一样写了分区方法，让我们写调用者方法。</p><p id="9859" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">我们可以把它写成递归的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="1089" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">或者我们可以把它写成迭代:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="1c89" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">递归版本是标准版本，如果你要写一个快速排序方法，递归版本就足够了，但有时人们会要求将递归转换为迭代，为此我在这里展示了两者。我想说的是，递归版本和迭代版本在理论上没有真正的不同，因为迭代版本使用堆栈来模拟递归版本，所以理论上它在空间复杂度上应该非常相似，但实际上递归版本更有效，因为你将创建堆栈的任务委托给编译器，这比你在迭代部分创建的堆栈更好，此外迭代版本有一些额外的变量和操作，增加了时间和空间复杂度。所以并不是在所有情况下迭代版本都更有效。</p><p id="9c0c" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">最后，我写了上面的许多版本来与您分享关于如何实现该算法的许多想法，但如果有一种标准的方法，那将是使用分区方法的递归方法，下面是它的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="c5f6" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">所以希望在这个阶段，你明白什么是快速排序，它是如何工作的，以及如何以多种方式实现它。</p><h1 id="17dc" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">时间复杂度</h1><p id="6a52" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">我喜欢在每个部分重复这个想法，但从不同的角度来看，这样你就清楚了。现在让我们引用著名的破解编码访谈书中关于快速排序的这句话:</p><blockquote class="nr ns nt"><p id="142e" class="mz na nu ls b lt nm ju nb lv nn jx nc nv no ne nf nw np nh ni nx nq nk nl md im bi translated">在快速排序中，我们选择一个随机元素并对数组进行分区，这样所有小于分区元素的数字都排在所有大于分区元素的数字之前。通过一系列交换，可以有效地执行分区。</p><p id="87bf" class="mz na nu ls b lt nm ju nb lv nn jx nc nv no ne nf nw np nh ni nx nq nk nl md im bi translated">如果我们围绕元素重复划分数组(及其子数组),数组最终会被排序。然而，由于分区的元素不能保证是中间值(或任何接近中间值的位置)，我们的排序可能会非常慢。这就是<code class="fe ox oy oz pa b">O(n^2)</code>最坏情况的原因。</p></blockquote><p id="07fc" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">简而言之，最好的情况是当分区<em class="nu">发生在中间时的<code class="fe ox oy oz pa b"><em class="nu">O(n log n)</em></code> <em class="nu">，最坏的情况是当</em>分区发生在任何边缘时的</em> <code class="fe ox oy oz pa b"><em class="nu">O(n^2)</em></code> <em class="nu">，如果数组已经按升序或降序排序，并且您选择pivot作为第一个元素，则可能会发生这种情况。T <em class="nu">他一般情况下是</em> <code class="fe ox oy oz pa b"><em class="nu">O(n log n)</em></code> <em class="nu">。</em></em></p><h2 id="c975" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">此算法何时会给出最差结果的示例:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/5929bdf8380d45ce8c63a2770a4f33f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*jov0S1XLIangkwng0TDYPA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">要从快速排序中调用的升序排序数组</figcaption></figure><p id="3be0" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">如上所述，如果元素已经按升序或降序排序，例如[10，20，30，40，50]并且pivot是第一个元素，那么这是最糟糕的情况，因为如果你考虑一下，在第一次迭代中，让我们选择10作为pivot，20作为left，50作为right，10将与其自身交换，我们将有一个子数组称为[20，30，40，50]，它的长度为n-1，那么下一次迭代将产生一个sub那就得出1+2+3+…+n(n+1)/2 ≈ <code class="fe ox oy oz pa b"><em class="nu">O(n^2)</em></code> <em class="nu">。降序排序也会给出相同的结果。因此结论是，如果数组已经按升序或降序排序，并且枢轴是第一个元素，那么快速排序将给出最坏的情况，即</em> <code class="fe ox oy oz pa b"><em class="nu">O(n^2)</em></code> <em class="nu">。如果我们知道数组已经排序，我们可以通过选择中心元素作为中间元素来解决这个问题，这样会得到最好的结果，因为它会在每次迭代中将数组划分为两个子数组，如下所示。</em></p><h2 id="2c7b" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">此算法何时能给出最佳结果的示例:</h2><p id="9e78" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">最好的结果将是<code class="fe ox oy oz pa b"><em class="nu">O(n log n)</em></code> <em class="nu">，如果列表在每次迭代中被分割</em><em class="nu">，这将会发生，我们有两个子数组，这将减少对log n的递归调用，因此总时间复杂度将是</em> <code class="fe ox oy oz pa b"><em class="nu">O(n log n)</em></code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/15e580dc4446deaa8ce5ad4f0737c628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOV-9-SZHeuIJKKTyYigyA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">如果每次迭代从中间分裂阵列，将获得最佳的时间复杂度</figcaption></figure><p id="2f54" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">如上图所示，这种情况下的分区将发生log n-1次，因为log(15) ≈ 4，但我们看到分区发生了3次，所以log n-1，但我们假设它是log n，所以总的来说<code class="fe ox oy oz pa b"><em class="nu">O(n log n)</em></code></p><p id="dddc" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">对于这一点，现实生活中的版本，如果该算法使用一种<strong class="ls iu">随机化</strong>方式来选择枢轴，这种方式可以为每个分区提供两个子数组，因此我们平均达到最好的情况<code class="fe ox oy oz pa b"><em class="nu">O(n log n)</em></code></p><h1 id="840d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">空间复杂性</h1><p id="07d0" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">正如上一节所提到的，空间复杂度是根据递归堆栈中使用的空间来确定的。</p><p id="5ea4" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">如果列表已经排序，并且pivot是每次迭代的第一个元素，那么最坏情况下使用的空间将是<code class="fe ox oy oz pa b">O(n)</code>。使用的平均案例空间将是<code class="fe ox oy oz pa b">O(log n)</code>，因为这是每个分区有2个子数组时需要的递归调用的数量。</p><h1 id="c9fd" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">FQA</h1><h2 id="7722" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">这个算法稳定吗？</h2><p id="33cf" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">如果具有相同键的两个对象在排序输出中出现的顺序与它们在要排序的输入数组中出现的顺序相同，则称排序算法是<strong class="ls iu">稳定的</strong>。快速排序<strong class="ls iu">不稳定</strong>，因为元素的交换是根据pivot的位置发生的，而不考虑它们的原始位置。</p><h2 id="3cae" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">这个算法适应性强吗？</h2><p id="8947" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">快速排序不是自适应的。简单地说，如果算法利用其元素的位置来最小化执行排序所需的操作数量，我们称之为自适应算法。事实上，如果数组已经排序，快速排序在某些情况下会比以前表现得更差，正如我们之前提到的。所以不具有适应性。</p><h2 id="2888" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">这个算法到位了吗？</h2><p id="ff52" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">如果我们假设，就地意味着我们没有使用额外的数组来促进排序，所以它是就地的，但是如果我们假设我们使用递归，使用堆栈来增加额外的空间，所以我们可以判断它不是就地的，所以这取决于你对就地的理解。</p><h2 id="f2c1" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">如何改进快速排序算法？</h2><p id="9cc0" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">可以对该算法进行许多改进，但最标准的一个是获得主元的随机化，因此我们可以实现O(n log n)时间复杂度。</p><h2 id="1f88" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">这个算法适用于链表吗？</h2><p id="7824" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">该算法不适用于链表，因为它将给出O(n)的时间复杂度，因为如果我们需要获得一个随机的枢轴来获得我们之前指定的最佳划分，我们需要迭代链表来获得枢轴。我们当然可以在链表上执行它，但是我们对主元的选择非常有限，或者我们将得到O(n)来迭代链表以得到随机主元，这并不好。</p><h2 id="e1e9" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">这个算法比归并排序好吗？</h2><p id="8ed7" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">视情况而定，合并排序的时间复杂度为O(nlogn ),但它不是就地的，你必须至少有一个大小为O(n)的腋窝数组才能执行它。</p><p id="374e" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">所以我会说，如果空间是关注，所以肯定快速排序是最好的。</p><p id="55ee" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">它非常适合对数组进行排序，因为快速排序是一种就地排序算法。就地排序意味着不需要额外的存储空间来执行排序。<strong class="ls iu">合并排序需要一个临时数组来合并排序后的数组，因此它不能就地给快速排序带来空间优势</strong>。</p><p id="e3c1" class="pw-post-body-paragraph mz na it ls b lt nm ju nb lv nn jx nc lx no ne nf lz np nh ni mb nq nk nl md im bi translated">没有我们上面指定的链表。</p><h2 id="2028" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">最坏的情况是O(n)和人们如何建议使用它？</h2><p id="acc5" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">因为如果应用枢轴的随机化将使得平均情况时间复杂度为O(n log n ),这对于排序技术来说是好的。</p><h2 id="e1ec" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">快速排序与选择排序？</h2><p id="3376" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">在选择排序中，我们选择一个位置，并找出该位置的元素。在快速排序中，我们选择一个元素，并找出该元素的位置。</p><h2 id="a19c" class="oc kz it bd la od oe dn le of og dp li lx oh oi lk lz oj ok lm mb ol om lo on bi translated">什么时候用或者不用？</h2><p id="99c5" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">这是一种快速算法，所以只要你想快速排序就用它，如果排序的稳定性很重要就不要用它，因为它不是一种稳定的算法。</p><h1 id="cfde" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">最后</h1><p id="d729" class="pw-post-body-paragraph mz na it ls b lt lu ju nb lv lw jx nc lx nd ne nf lz ng nh ni mb nj nk nl md im bi translated">我希望你觉得这个例子有用。我试图包含尽可能多的清晰的例子和想法，同时保持简单，关注重要的东西。请随时留下您的意见、建议或任何反馈。</p></div></div>    
</body>
</html>