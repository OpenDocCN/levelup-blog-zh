# 打字稿和摩卡挂钩

> 原文：<https://levelup.gitconnected.com/typescript-and-mocha-hooks-c5d9ccffd58f>

作为一名软件开发人员，我一直确保测试架构的维护。作为一个原则，我相信测试应该表现出与产品代码同等的质量。现在，我们如何用 TypeScript 实现这一点呢？

在我看来，我们首先需要选择一个合适的测试框架。我发现 Mocha 有很好的效果——它足够灵活，可以帮助我们利用其他库。尽管它很简单，但它支持构建一个非常适合 TypeScript 项目的可靠的测试架构——全部通过使用钩子。

![](img/c7f9e55a538153d20286b78a8313dd1d.png)

杰米·马托西诺斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 摩卡挂钩

Mocha 提供了 4 种类型的挂钩:
* `beforeEach`(特定块中的每个特定测试执行之前)、
* `beforeAll`(特定块中的所有测试执行之前)、
* `afterEach`(特定块中的每个特定测试执行之后)、
* `afterAll`(特定块中的所有测试执行之后)。

我故意用了“特别”这个词，因为摩卡允许我们在任何有意义的层面上建立挂钩。正如您可能已经发现的，测试架构是相当全局的构造——我们打算在全局级别上设置钩子。为了实现这一点，我们需要更深入地挖掘测试配置。

## 根摩卡钩

根 Mocha 挂钩适用于整个测试设置中的所有测试。你如何使用它们必然是你的决定——然而，我想给你我的想法清单。在我的测试中，我倾向于严重依赖这些钩子的正确配置，这为编写测试的人减轻了许多工作。

## 摩卡语境

Mocha 上下文是可用于访问每个测试的可变对象。我对 Mocha 测试架构的想法是让每个测试都有相同的上下文，并且只使用根 Mocha 钩子来改变它。它保证了每个测试的简单性、有序性和可预测的行为。

由于`Mocha.Context`是一个类(不是一个可扩展的接口)，我们应该定义两种类型——为我们管理的属性定义`InjectableContext`，为作为上下文一部分的所有属性定义`TestContext`。`TestContext`将是测试使用的类型。下面的一个简单片段应该可以澄清这个概念:

InjectableContext 和 TestContext 的定义

如果您想知道为什么我在上面的代码片段中使用了`Readonly`类型，您可以阅读我发表在 the Level Up Coding 出版物上的关于 TypeScript 中的不变性的文章:

[](/the-complete-guide-to-immutability-in-typescript-99154f859fdb) [## TypeScript 中不变性的完全指南

### 如何使用函数式编程理论、只读修饰符和经过良好测试的实践来将不变性应用于

levelup.gitconnected.com](/the-complete-guide-to-immutability-in-typescript-99154f859fdb) 

## 在所有挂钩之前

我们可以使用这个钩子来设置所有被测试直接或间接使用的系统组件。我总是推荐使用依赖注入来最小化模仿、间谍和存根的数量。我们可以通过将系统组件放在 Mocha 环境中，将它们暴露给所有的测试。

对于系统组件，我理解如下(列表不完整):
*模拟数据库、
*模拟服务器、
*模拟消息系统、
*共享服务、
*控制器、
*有用的助手功能。

如果您有大量的测试并使用并行化，请注意 Mocha 将为每个测试文件执行 Before All 钩子。

## 每次挂钩前

我想我们可以使用这个钩子来设置 Mocha 上下文中的属性，这些属性不是作为 Before All 钩子的一部分来设置的。也可以设置一些结构的初始状态，比如计数器或者间谍。“每个挂钩之前”与“每个挂钩之后”协同工作。

## 毕竟钩

我们作为 Before All 钩子的一部分初始化的所有东西，我们必须作为 After Each 钩子的一部分拆除。为了让 Mocha 完成并产生任何结果，需要释放所有悬空资源。在并行测试执行的情况下，Mocha 将为每个测试文件执行这个钩子。

## 每次上钩后

如前所述，After Each 钩子与 Before Each 钩子协同工作。这意味着，如果某个复位指令被放在其中一个钩子中，我们很可能不需要把它放在另一个钩子中。例如，如果我们在每个钩子之前把一个计数器重置为零，我们就不必在每个钩子之后做同样的事情。

# 设置

既然我已经解释了这个理论，我们应该尝试在 TypeScript 项目中设置根 Mocha 挂钩。假设 Mocha 配置存储在主应用程序目录中的`.mocharc.yml`文件中，我们需要键入以下内容:

这通知 Mocha 我们想要注册一个类型脚本加载器(使用`ts-node`库),并且我们需要测试框架来执行`test/rootMochaHooks.ts`文件。顾名思义，这个文件将包含 Rook Mocha 钩子。

该文件的最基本结构如下:

根摩卡钩的示例性定义

该文件需要导出一个名为`mochaHooks`的函数，该函数返回该类型的`Mocha.RootHookObject`或`Promise`。定义为返回值一部分的所有函数也可以是异步的。明眼人可以看出，`beforeAll`函数接受`Mocha.Context`类型的`this`，但是所有其他函数已经以先前定义的`TestContext`的形式从`InjectableContext`获取数据。

理论上，我们已经可以在`mochaHooks`函数的主体中初始化一些系统组件。重要的是我们正确地填充了`InjectableContext`——这正是我在代码中明确定义它的原因。如果您想知道`Object.assign(this, context);`是否是一个正确的赋值——是的，这是一个不寻常的用法，但是它执行得很好。

## 我们如何在测试中使用它？

根据定义，每个测试都可以直接访问`TestContext`，它可以通过以下方式访问:

请注意，匿名函数不能成为箭头函数，否则它将失去对`this`对象的访问。

# 摘要

由于 Mocha 使用行为驱动开发设计模式，我们需要相应地构建我们的代码以适应它。多亏了(Root) Mocha 钩子，我们可以毫不费力地进行装配，获得可维护的测试架构和类型安全性。如果你有问题，请在评论区留言！