<html>
<head>
<title>Merging arrays with concat vs. spread operator in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中使用concat与spread运算符合并数组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/merging-arrays-with-concat-vs-spread-operator-in-javascript-67a2ff89cc31?source=collection_archive---------6-----------------------#2022-12-29">https://levelup.gitconnected.com/merging-arrays-with-concat-vs-spread-operator-in-javascript-67a2ff89cc31?source=collection_archive---------6-----------------------#2022-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1841" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp ky bm di kz"> <img alt="W" class="la lb lc ld le lf fc n ih dh bf" src="../Images/d891666cc9ebd9231a574f9c9cb6a45e.png" width="70" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:140/1*59b1ZckwqsMM87YXqWOz-g.png"/> <span class="l kp kq kr bm ks kt ku kv kw di kx"> W </span> </span>谈到在JavaScript中合并数组，有几种方法可用，每种方法都有自己的优缺点。在我们之前的一篇文章中，我们讨论了合并两个数组的不同方法。在本文中，我们将比较两种最流行的方法:使用concat方法和使用spread运算符。concat方法和spread运算符都允许您将两个或多个数组合并成一个数组，但是它们有一些关键的区别，使它们更适合某些任务。我们将探究这些差异，并查看一些实际例子，说明如何在JavaScript中使用concat方法和spread操作符来合并数组。</p><p id="4cf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是众多关于web开发的文章中的一篇。请随时关注或订阅我们，获取更多关于web开发的精彩内容。我们尝试一周发布多次。请确保不要错过我们的任何精彩内容。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/b46c79d47a55bdf2fdf7020d319a6b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-miSobEMu0NJy-md"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">照片由<a class="ae lg" href="https://unsplash.com/@karolinesfotografia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Karoline Soares </a>在<a class="ae lg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有不同的方法来合并多个数组。在上一篇关于合并数组的文章中，我们介绍了不同的方法。但是在这篇文章中，我们想集中讨论其中的两种，并逐一进行比较</p><p id="d412" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您合并多个数组时，concat和spread的行为非常相似。然而，如果参数不是一个<br/>可迭代的，它们的行为就会完全不同。</p><p id="7dfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JavaScript中，iterable是一个实现Symbol.iterator <br/>方法的对象，该方法允许在<br/>循环的for…中或使用spread运算符(…)迭代(循环)对象。</p><p id="dc07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个可迭代对象的例子:</p><pre class="li lj lk ll gt lw lx ly bn lz ma bi"><span id="9cf1" class="mb mc it lx b be md me l mf mg">const iterable = {<br/> [Symbol.iterator]: function* () {<br/> yield 1;<br/> yield 2;<br/> yield 3;<br/> }<br/>};<br/>for (const value of iterable) {<br/> console.log(value);<br/>}<br/>// Output: 1, 2, 3</span></pre><p id="fb9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可迭代对象是JavaScript <br/>语言设计中的一个核心概念，它们被用在各种上下文中，比如数组、<br/>字符串和生成器函数。</p><p id="3e43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数组和字符串是JavaScript中内置的可迭代对象，它们<br/>可以使用for…of循环或spread操作符(…)循环。对于<br/>示例:</p><pre class="li lj lk ll gt lw lx ly bn lz ma bi"><span id="2d5c" class="mb mc it lx b be md me l mf mg">const arr = [1, 2, 3];<br/>for (const value of arr) {<br/> console.log(value);<br/>}<br/>// Output: 1, 2, 3<br/>const str = 'abc';<br/>for (const value of str) {<br/> console.log(value);<br/>}<br/>// Output: 'a', 'b', 'c'</span></pre><p id="fb9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">生成器函数是在<br/>执行期间可以暂停和恢复的函数，当被调用时，它们返回一个可迭代的对象。下面是一个返回iterable对象的生成器函数的<br/>示例:</p><pre class="li lj lk ll gt lw lx ly bn lz ma bi"><span id="bbfc" class="mb mc it lx b be md me l mf mg">function* generator() {<br/> yield 1;<br/> yield 2;<br/> yield 3;<br/>}<br/>const iterable = generator();<br/>for (const value of iterable) {<br/> console.log(value);<br/>}<br/>// Output: 1, 2, 3</span></pre><p id="621b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回到concat()方法和spread操作符。当合并数组时，concat()将数组项作为一个整体添加，而spread操作符尝试迭代它，如果失败，将引发异常。例如:</p><pre class="li lj lk ll gt lw lx ly bn lz ma bi"><span id="0fed" class="mb mc it lx b be md me l mf mg">const a = [1,2,3]<br/>const y = 99;<br/>console.log(a.concat(y)); <br/>// Output: [1,2,3,99]<br/>console.log([…a, …y]); <br/>// Output: throws TypeError</span></pre><p id="a7cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，concat()方法将数字视为一个整体，而spread操作符试图迭代，但失败了，因此抛出了异常。</p><p id="e355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个例子:</p><pre class="li lj lk ll gt lw lx ly bn lz ma bi"><span id="c650" class="mb mc it lx b be md me l mf mg">const x = "hi";<br/>console.log(a.concat(x)); <br/>// Output: [1,2,3, "hi"];<br/>console.log([…a, …x]); <br/>// Output: [1,2,3, "h", "i"]</span></pre><p id="c999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">concat()方法将字符串视为一个整体，而spread则尝试遍历字符串中的每个字符。</p><p id="ecf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是另一个说明concat()方法和spread运算符之间差异的示例:</p><pre class="li lj lk ll gt lw lx ly bn lz ma bi"><span id="0346" class="mb mc it lx b be md me l mf mg">function* gen() {<br/> yield 'a';<br/> yield 'b';<br/> yield 'c';<br/>}<br/>console.log(a.concat(gen())); <br/>// Output: [1,2,3, [gen]]<br/>console.log([...a, ...gen()]); <br/>// Output: [1,2,3, 'a', 'b', 'c']</span></pre><p id="b1a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">concat()方法将生成器函数作为一个整体放入数组中。而spread操作符接受生成器函数并执行它，从而将生成的值添加到数组中。</p><p id="8b26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总而言之，当参数可能不可迭代时，concat()和spread之间的<br/>选择取决于您是否希望它们被迭代。除此之外，它们的行为基本相同。如果您希望它们被迭代，请使用spread。如果你想把它当作一个整体，使用concat。</p><p id="64a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">话虽如此，ES6还是提供了一种用Symbol.isConcatSpreadable覆盖<br/> concat()默认行为的方法。</p><p id="014b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，这对于数组是真的。对于其他一切，它是<br/>假的。手动将其设置为true，告知concat()迭代<br/>参数，就像spread一样，如下所示:</p><pre class="li lj lk ll gt lw lx ly bn lz ma bi"><span id="76aa" class="mb mc it lx b be md me l mf mg">const x = new String("hi");<br/>console.log(a.concat(x)); <br/>// Output: [1,2,3, "hi"];<br/>x[Symbol.isConcatSpreadable] = true<br/>console.log(a.concat(x)); <br/>// Output: [1,2,3, "h", "i"];</span></pre><p id="58a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">性能方面的concat()对于小型和大型数组都更快<br/>，这可能是因为它可以受益于特定于数组的优化，而<br/> spread必须符合通用迭代协议。然而，这只适用于较新的浏览器。在旧的浏览器上，spread操作符对于小数组更快，而concat()对于大数组更快。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/5c7fdb823e2c7f4190f716ff6bed224c.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*M96Lw3t2ZV4F3S-tD-N27Q.png"/></div></figure><p id="3515" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就在几个月前，我们认为spread对于小数组更快，而concat()对于大数组更快。如你所见，事情发生了巨大而快速的变化。因此，保持最新状态是很重要的。您可以通过关注或订阅我们来做到这一点。我们尝试一周发布多次。请确保不要错过我们的任何精彩内容。再见。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="086a" class="mp mc it bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">分级编码</h1><p id="1920" class="pw-post-body-paragraph jq jr it js b jt nm jv jw jx nn jz ka kb no kd ke kf np kh ki kj nq kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="a5f8" class="nr ns it js b jt ju jx jy kb nt kf nu kj nv kn nw nx ny nz bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="322b" class="nr ns it js b jt oa jx ob kb oc kf od kj oe kn nw nx ny nz bi translated">📰查看<a class="ae lg" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="3901" class="nr ns it js b jt oa jx ob kb oc kf od kj oe kn nw nx ny nz bi translated">🔔关注我们:<a class="ae lg" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae lg" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lg" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="74b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae lg" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>