<html>
<head>
<title>Why We Don’t Need the ‘function’ Keyword in JavaScript Anymore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们不再需要JavaScript中的“函数”关键字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-we-dont-need-the-function-keyword-in-javascript-anymore-7e43a8709491?source=collection_archive---------5-----------------------#2020-04-09">https://levelup.gitconnected.com/why-we-dont-need-the-function-keyword-in-javascript-anymore-7e43a8709491?source=collection_archive---------5-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/15453d09973589757e7108a011b3a0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QFgg_bkUizPioe0A"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@creativegangsters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾莉·史密斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="afa7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从版本1开始，<code class="fe le lf lg lh b">function</code>关键字就出现在JavaScript中，让我们可以用各种方式定义函数。</p><p id="fb89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看为什么我们再也不需要使用<code class="fe le lf lg lh b">function</code>关键字来定义函数了。</p><h1 id="3979" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">箭头功能</h1><p id="6ce4" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以将箭头函数用于所有非构造函数方法或不引用对象或构造函数中的<code class="fe le lf lg lh b">this</code>的对象方法。</p><p id="ae12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="41e3" class="mt lj it lh b gy mu mv l mw mx">const arr = [1, 2, 3].map(function(x) {<br/>  return x ** 2;<br/>})</span></pre><p id="4d32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="25c9" class="mt lj it lh b gy mu mv l mw mx">const arr = [1, 2, 3].map(x =&gt; x ** 2);</span></pre><p id="6ec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它要短得多，也更好，我们不必担心函数中<code class="fe le lf lg lh b">this</code>的值。</p><p id="a7e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在回调中引用<code class="fe le lf lg lh b">this</code>，但是我们不应该这样做，因为嵌套的作用域会使引用它更加混乱。</p><p id="87b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，如果我们有一个不引用<code class="fe le lf lg lh b">this</code>的独立函数，我们也可以使用箭头函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fe0a" class="mt lj it lh b gy mu mv l mw mx">const greet = (name) =&gt; console.log(`hi ${name}`);</span></pre><p id="9c16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，箭头函数也适用于独立函数。</p><p id="b670" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于对象中的方法，不要这样写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c51a" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  foo: function() {<br/>    console.log('foo')<br/>  }<br/>}</span></pre><p id="56ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="be02" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  foo: () =&gt; {<br/>    console.log('foo')<br/>  }<br/>}</span></pre><p id="4923" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于上面的<code class="fe le lf lg lh b">foo</code>方法没有引用<code class="fe le lf lg lh b">this</code>，我们可以使用一个箭头函数。</p><h1 id="ce36" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">引用此的对象方法</h1><p id="81de" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们的对象有引用<code class="fe le lf lg lh b">this</code>的方法，那么我们可以使用方法简写。</p><p id="7bca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要这样写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c82e" class="mt lj it lh b gy mu mv l mw mx">const person = {<br/>  name: 'jane',<br/>  greet: function() {<br/>    console.log(`hi ${this.name}`)<br/>  }<br/>}</span></pre><p id="4c18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6ccc" class="mt lj it lh b gy mu mv l mw mx">const person = {<br/>  name: 'jane',<br/>  greet() {<br/>    console.log(`hi ${this.name}`)<br/>  }<br/>}</span></pre><p id="1a5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们再次看到的，它要短得多，它们做同样的事情。简写与使用<code class="fe le lf lg lh b">function</code>关键字相同。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/d23b5662c7dce5227f215ba5d711a973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*geebKIbh1WHoUOD8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@thenewmalcolm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥比·奥尼耶德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="3abe" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">构造函数和类</h1><p id="a23a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们想创建构造函数，那么我们应该使用类语法。</p><p id="ea83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下带方法的构造函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8c80" class="mt lj it lh b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="5fa0" class="mt lj it lh b gy mz mv l mw mx">Person.prototype.greet = function() {<br/>  console.log(`hi ${this.name}`)<br/>}</span></pre><p id="34b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="53a8" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="8747" class="mt lj it lh b gy mz mv l mw mx">  greet() {<br/>    console.log(`hi ${this.name}`)<br/>  }<br/>}</span></pre><p id="35f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们做错了什么，旧的构造函数语法会抛出错误。</p><p id="7081" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，新的类语法可以。此外，我们可以像对待<code class="fe le lf lg lh b">greet</code>方法一样使用class方法简写，我们不必将它作为属性附加到类的<code class="fe le lf lg lh b">prototype</code>属性上。</p><p id="7101" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们再次不需要<code class="fe le lf lg lh b">function</code>关键字，因为它再次变得多余。</p><h1 id="c617" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="405b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在今天的JavaScript代码中，我们可以不使用<code class="fe le lf lg lh b">function</code>关键字。我们可以对不需要引用<code class="fe le lf lg lh b">this</code>的函数使用箭头函数，对任何需要引用<code class="fe le lf lg lh b">this</code>的函数使用方法简写。</p></div></div>    
</body>
</html>