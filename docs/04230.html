<html>
<head>
<title>JavaScript Basics — Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础—对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-basics-objects-3e94605131e0?source=collection_archive---------24-----------------------#2020-06-15">https://levelup.gitconnected.com/javascript-basics-objects-3e94605131e0?source=collection_archive---------24-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6583b09cf41445bed7030366250eb11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2OUM2E7ypTI5wwCJ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@chn008?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">周延前</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cd42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究JavaScript对象。</p><h1 id="8fce" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">地图</h1><p id="9c84" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">映射是一组键值对。</p><p id="3de4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7171" class="mq lf it mm b gy mr ms l mt mu">const ages = {<br/>  james: 10,<br/>  alex: 20<br/>}</span></pre><p id="30d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用名字作为关键字，用年龄作为相应的属性。</p><p id="20ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对象属性可以是字符串，也可以是符号，但大多数时候，我们用的是字符串。</p><p id="0a26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能在一个对象中使用对象作为键。因此，JavaScript有一个<code class="fe mv mw mx mm b">Map</code>构造函数，比使用对象进行映射更加灵活。</p><p id="732a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="71fe" class="mq lf it mm b gy mr ms l mt mu">const ages = new Map();<br/>ages.set("james", 10);<br/>ages.set("alex", 20);</span></pre><p id="a158" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">set</code>方法是<code class="fe mv mw mx mm b">Map</code>对象的一部分。我们用它向地图添加条目。</p><p id="c941" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想把一个对象当作一个地图，我们可以使用<code class="fe mv mw mx mm b">Object.keys</code>来返回一个对象自己的字符串键。</p><p id="3578" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种方法是使用<code class="fe mv mw mx mm b">in</code>操作符或<code class="fe mv mw mx mm b">hasOwnProperty</code>。</p><p id="fe0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下代码来使用<code class="fe mv mw mx mm b">in</code>操作符:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d5bd" class="mq lf it mm b gy mr ms l mt mu">'james' in ages</span></pre><p id="bac9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5bbf" class="mq lf it mm b gy mr ms l mt mu">ages.hasOwnProperty('james')</span></pre><h1 id="59b4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">多态性</h1><p id="e598" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以覆盖继承的方法，让它们做我们想做的事情。</p><p id="7fe7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以覆盖<code class="fe mv mw mx mm b">Object.prototype.toString</code>方法，让它做一些更有用的事情。</p><p id="f7c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="33ab" class="mq lf it mm b gy mr ms l mt mu">function Dog(name) {<br/>  this.name = name;<br/>}</span><span id="19ee" class="mq lf it mm b gy my ms l mt mu">Dog.prototype.toString = function() {<br/>  return this.name;<br/>}</span></pre><p id="492c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们在一个<code class="fe mv mw mx mm b">Dog</code>实例上调用<code class="fe mv mw mx mm b">toString</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e684" class="mq lf it mm b gy mr ms l mt mu">const dog = new Dog('joe');<br/>console.log(dog.toString());</span></pre><p id="83d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mv mw mx mm b">'joe'</code>日志。</p><p id="ca9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们没有覆盖，那么我们得到<code class="fe mv mw mx mm b">[object Object]</code>记录。</p><h1 id="1e66" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">标志</h1><p id="0f9d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">多个接口可能对不同的事情使用相同的属性名。</p><p id="db51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们不能用字符串键这样做，因为它们会互相覆盖。</p><p id="59a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript通过添加symbol原语类型增加了具有相同名称的对象键的能力。</p><p id="553b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有两个符号实例是相同的。</p><p id="5493" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7473" class="mq lf it mm b gy mr ms l mt mu">const sym = Symbol("name");<br/>const sym2 = Symbol("name");</span></pre><p id="3e33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们比较它们:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c961" class="mq lf it mm b gy mr ms l mt mu">console.log(sym === sym2);</span></pre><p id="4b06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mv mw mx mm b">false</code>，即使它们的内容是相同的。</p><p id="b2cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将它们用作对象标识符。</p><p id="79c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3573" class="mq lf it mm b gy mr ms l mt mu">const speak = Symbol("speak");<br/>const dog = {<br/>  [speak]() {<br/>    console.log('hi');<br/>  }<br/>}</span></pre><p id="976b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们只能通过引用同一个<code class="fe mv mw mx mm b">speak</code>符号来调用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a770" class="mq lf it mm b gy mr ms l mt mu">dog[speak]();</span></pre><h1 id="3ec1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">迭代程序</h1><p id="063d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用for-of循环遍历任何可迭代对象。</p><p id="aca4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个iterable对象必须有<code class="fe mv mw mx mm b">Symbol.iterator</code>方法。</p><p id="5769" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该方法应该是迭代器。</p><p id="3cd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代器有一个<code class="fe mv mw mx mm b">next</code>方法，该方法返回一个具有<code class="fe mv mw mx mm b">value</code>属性和<code class="fe mv mw mx mm b">done</code>布尔属性的对象。</p><p id="cb6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bbcb" class="mq lf it mm b gy mr ms l mt mu">class Id {<br/>  constructor(max) {<br/>    this.id = 0;<br/>    this.max = max;<br/>  }</span><span id="13ce" class="mq lf it mm b gy my ms l mt mu">next() {<br/>    this.id++;<br/>    if (this.max === this.id) {<br/>      return {<br/>        done: true<br/>      }<br/>    }<br/>    return {<br/>      done: false,<br/>      value: this.id<br/>    }<br/>  }<br/>}</span><span id="4401" class="mq lf it mm b gy my ms l mt mu">class IdIterator {<br/>  [Symbol.iterator]() {<br/>    return new Id(10);<br/>  }<br/>}</span><span id="11ed" class="mq lf it mm b gy my ms l mt mu">for (const id of new IdIterator(10)) {<br/>  console.log(id);<br/>}</span></pre><p id="b6c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有<code class="fe mv mw mx mm b">Id</code>类，它有<code class="fe mv mw mx mm b">next</code>方法。当<code class="fe mv mw mx mm b">this.id</code>等于<code class="fe mv mw mx mm b">this.max</code>时，它返回一个<code class="fe mv mw mx mm b">done</code>设置为<code class="fe mv mw mx mm b">true</code>的对象。</p><p id="aec5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，它返回下一个<code class="fe mv mw mx mm b">this.id</code>值。</p><p id="52ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有<code class="fe mv mw mx mm b">IdIterator</code>类，它有<code class="fe mv mw mx mm b">Symbol.iterator</code>方法，我们在那里返回迭代器。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/a483eea080b0c2694ff9f58fd8937071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wd8WnL-aYnCPq5oW"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@pgreen1983?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">保罗·格伦</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="5ca1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Getters和Setters</h1><p id="0a6a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript类可以有getters来返回一些值作为属性。</p><p id="1e31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ec31" class="mq lf it mm b gy mr ms l mt mu">const random = {<br/>  get num() {<br/>    return Math.floor(Math.random() * 100);<br/>  }<br/>};</span></pre><p id="476a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个由关键字<code class="fe mv mw mx mm b">get</code>指示的<code class="fe mv mw mx mm b">num</code> getter。</p><p id="0a72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回一个介于0和100之间的随机数。</p><p id="7fa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要访问返回值，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="baec" class="mq lf it mm b gy mr ms l mt mu">console.log(random.num);</span></pre><p id="3fd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mv mw mx mm b">random.num</code>将是一个随机数。</p><p id="5021" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用<code class="fe mv mw mx mm b">set</code>关键字创建一个setter:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5e38" class="mq lf it mm b gy mr ms l mt mu">class Cat {<br/>  get name() {<br/>    return this._name<br/>  }</span><span id="2aac" class="mq lf it mm b gy my ms l mt mu">  set name(name) {<br/>    this._name = `cat ${name}`;<br/>  }<br/>}</span></pre><p id="49f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个带有setter的<code class="fe mv mw mx mm b">Cat</code>类。</p><p id="db2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键字<code class="fe mv mw mx mm b">set</code>表明我们有了<code class="fe mv mw mx mm b">name</code> setter方法。</p><p id="f288" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将名称与<code class="fe mv mw mx mm b">name</code>一起设置为<code class="fe mv mw mx mm b">'cat'</code>。</p><p id="db58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e78e" class="mq lf it mm b gy mr ms l mt mu">const cat = new Cat();<br/>cat.name = 'mary';<br/>console.log(cat.name);</span></pre><p id="9ab7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4b4e" class="mq lf it mm b gy mr ms l mt mu">'cat mary'</span></pre><p id="fe4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">已登录控制台。</p><h1 id="2f42" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5ff2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">映射让我们在JavaScript代码中存储键值对。</p><p id="c3c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代器对于创建我们可以用for-of循环来循环的对象很有用。</p><p id="7675" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Getters和setters让我们设置值。</p></div></div>    
</body>
</html>