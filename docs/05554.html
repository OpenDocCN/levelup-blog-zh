<html>
<head>
<title>Python Context Managers in Depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python上下文管理器的深度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-context-managers-in-depth-52dd2dd2624b?source=collection_archive---------8-----------------------#2020-09-08">https://levelup.gitconnected.com/python-context-managers-in-depth-52dd2dd2624b?source=collection_archive---------8-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="be40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像专业人士一样管理您的资源</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/935b1d5a193381e86435510fd4573f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KUofNN8YgGF9LffV.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=960248" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae le" href="https://pixabay.com/users/ErikaWittlieb-427626/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=960248" rel="noopener ugc nofollow" target="_blank">erikawittleb</a>的图片</figcaption></figure><p id="1b19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python是一种特别干净和甜蜜的语言，这要归功于它的许多便利特性。在这篇文章中，我将深入探讨Python中的上下文管理器，如何使用它们，在哪里可以找到它们，以及如何编写自己的上下文管理器。</p><h1 id="a63b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么我们需要上下文管理器？</h1><p id="8239" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当我们谈论<em class="mi">资源</em>时，最常使用上下文管理器。例如，从文件中读取/写入。检查这个简单的片段:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="d271" class="mo lg it mk b gy mp mq l mr ms">f = open('log.txt', 'w') <br/>f.write('hello world') <br/>f.close()</span></pre><p id="cfb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码所做的就是打开<code class="fe mt mu mv mk b">log.txt</code>进行写入，并在其中写入<code class="fe mt mu mv mk b">hello world</code>。很简单。但是假设第2行的代码无缘无故地抛出了一个异常。在这种情况下，文件仍然打开，但不会关闭，因为解释器不会到达第3行。对于一次性脚本来说，这不是问题，但是如果您要在Python上开发任何严肃的东西，这可能会成为一个令人头痛的问题。</p><p id="7150" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何解决这个问题？脑海中浮现出<code class="fe mt mu mv mk b">try</code> / <code class="fe mt mu mv mk b">finally</code>的建筑:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="fdce" class="mo lg it mk b gy mp mq l mr ms">f = open('log.txt', 'w') <br/>try: <br/>    f.write('hello world') <br/>finally: <br/>    f.close()</span></pre><p id="dd49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是可行的，因为即使抛出异常，也会执行<code class="fe mt mu mv mk b">finally</code>，并且文件描述符将被丢弃。然而，这看起来并不十分Pythonish化...</p><p id="9a3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是<code class="fe mt mu mv mk b">with</code>关键字发挥作用的地方。它是为这个特定的目的而开发的:使资源管理可读。这个代码片段在功能上与上面的示例相同:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="e645" class="mo lg it mk b gy mp mq l mr ms">with open('log.txt', 'w') as f: <br/>    f.write('hello world')</span></pre><p id="4b4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来干净多了，你同意吗？</p><h1 id="f0fa" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">上下文管理器是如何工作的？</h1><p id="e40d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">上下文管理器背后的逻辑实际上非常简单。让我们通过编写自己的上下文管理器来探索它。对于要被识别为上下文管理器的对象，它必须实现两个方法:<code class="fe mt mu mv mk b">__enter__</code>和<code class="fe mt mu mv mk b">__exit__</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3762" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您尝试运行此示例，您将获得以下输出:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="5ee5" class="mo lg it mk b gy mp mq l mr ms">Entered into context manager! <br/>Inside context manager! <br/>Exiting context manager!</span></pre><p id="0179" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们尝试在<code class="fe mt mu mv mk b">with</code>中抛出一个异常:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="d730" class="mo lg it mk b gy mp mq l mr ms">with TestContextManager(): <br/>    raise Exception()</span></pre><p id="e08c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您尝试运行这个版本，请注意仍然调用了<code class="fe mt mu mv mk b">__exit__</code>方法，很像<code class="fe mt mu mv mk b">try</code>块中的<code class="fe mt mu mv mk b">finally</code>子句。这可用于清理和释放该上下文管理器使用的任何资源。</p><h1 id="748a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe mt mu mv mk b">contextlib</code>模块</h1><p id="5799" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果没有<code class="fe mt mu mv mk b">contextlib</code>模块，所有这些都不会特别有用。这个模块是标准库的一部分，它提供了一些通用的构造来简化您的工作。</p><p id="ed84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最值得注意的添加是<code class="fe mt mu mv mk b">@contextmanager</code> <a class="ae le" href="https://everyday.codes/python/why-do-you-need-decorators-in-your-python-code/" rel="noopener ugc nofollow" target="_blank">装饰器</a>。它可以让你将任何生成器函数转换成一个上下文管理器，根本不需要额外的代码！这里有一个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ce24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这仍然需要使用<code class="fe mt mu mv mk b">try</code> / <code class="fe mt mu mv mk b">finally</code>，但这可以让您将它抽象一次并忘记它，同时还可以让您的代码与代码库的其余部分兼容，这些代码库可能不像您现在这样理解上下文管理器。</p><p id="8215" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mt mu mv mk b">contextlib</code>的另一个有用的特性是<code class="fe mt mu mv mk b">AbstractContextManager</code>类(Python 3.6中的新特性)。这是一个<a class="ae le" href="https://everyday.codes/python/abstract-classes-and-meta-classes-in-python/" rel="noopener ugc nofollow" target="_blank">抽象基类</a>，它实现了<code class="fe mt mu mv mk b">__enter__</code>和<code class="fe mt mu mv mk b">__exit__</code>功能。在您的自定义上下文管理器中使用它，以确保类型兼容。</p><h1 id="e839" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结束语</h1><p id="22e2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">感谢您的阅读，希望您喜欢这篇文章。在我的下一篇文章中，我将讨论<strong class="js iu">异步</strong>上下文管理器。敬请期待！</p><h1 id="6a73" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">资源</h1><ul class=""><li id="8040" class="my mz it js b jt md jx me kb na kf nb kj nc kn nd ne nf ng bi translated"><a class="ae le" href="https://medium.com/better-programming/abstract-classes-and-metaclasses-in-python-9236ccfbf88b" rel="noopener">Python中的抽象类</a></li><li id="81c1" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated"><a class="ae le" href="https://medium.com/better-programming/why-you-need-decorators-in-your-python-code-df12d43eac9c" rel="noopener">Python中的自定义装饰器</a></li><li id="61b0" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated"><a class="ae le" href="https://docs.python.org/2.5/whatsnew/pep-343.html" rel="noopener ugc nofollow" target="_blank">pep 343—</a><code class="fe mt mu mv mk b"><a class="ae le" href="https://docs.python.org/2.5/whatsnew/pep-343.html" rel="noopener ugc nofollow" target="_blank">with</a></code><a class="ae le" href="https://docs.python.org/2.5/whatsnew/pep-343.html" rel="noopener ugc nofollow" target="_blank">语句</a></li><li id="6f5c" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated"><code class="fe mt mu mv mk b"><a class="ae le" href="https://docs.python.org/3/library/contextlib.html" rel="noopener ugc nofollow" target="_blank">contextlib</a></code> <a class="ae le" href="https://docs.python.org/3/library/contextlib.html" rel="noopener ugc nofollow" target="_blank">单据</a></li></ul></div></div>    
</body>
</html>