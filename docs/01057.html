<html>
<head>
<title>Micro-frontend Architecture: Replacing a Monolith from the Inside Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端架构:从内到外取代整体架构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/micro-frontend-architecture-replacing-a-monolith-from-the-inside-out-61f60d2e14c1?source=collection_archive---------0-----------------------#2019-11-01">https://levelup.gitconnected.com/micro-frontend-architecture-replacing-a-monolith-from-the-inside-out-61f60d2e14c1?source=collection_archive---------0-----------------------#2019-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8428" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用微前端技术使遗留应用程序现代化？</h2></div><p id="b2dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文是关于微前端应用和管理它们的技术的系列文章的一部分。</p><p id="1e49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看下一个<a class="ae lf" href="https://medium.com/@ScriptedAlchemy/micro-frontend-architecture-dynamic-import-chunks-from-another-webpack-bundle-at-runtime-1132d8cb6051" rel="noopener">这里</a></p><p id="3795" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们正在对前端架构做一些大的改变。查看我们在Webpack模块联盟方面的进展:</p><div class="lg lh gp gr li lj"><a href="https://medium.com/@ScriptedAlchemy/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">Webpack 5:模块联合。Javascript架构的游戏改变者。解锁微前端</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">模块联合——相当于Apollo对GraphQL所做的Javascript工作。多个Webpack版本一起工作，就像…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">medium.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx ly lj"/></div></div></a></div><div class="lg lh gp gr li lj"><a href="https://github.com/webpack/webpack/issues/10352" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">合并提议:捆绑包之间的模块联合和代码共享。许多构建作为一个问题…</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">这是一个将我现有的工作合并到Webpack核心的提议。基本概念是联合应用程序…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">github.com</p></div></div><div class="ls l"><div class="lz l lu lv lw ls lx ly lj"/></div></div></a></div><p id="e57a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本教程将讨论如何将你的前端从monolith解耦，并立即开始迁移到微前端架构。这是我过去的项目之一</p><h1 id="a506" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">问题是</h1><p id="5bb7" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">让我们假设有一个完整的代码库。这个整体使用一个后端模板引擎或系统(例如<a class="ae lf" href="https://www.npmjs.com/package/ejs" rel="noopener ugc nofollow" target="_blank"> EJS </a>或<a class="ae lf" href="https://ruby-doc.org/stdlib-2.6.5/libdoc/erb/rdoc/ERB.html" rel="noopener ugc nofollow" target="_blank"> ERB </a>)，jQuery，并且它没有真正考虑前端——或者更糟，它来自于spa存在之前的时代。也许它像Ruby on Rails一样有一些资产管道。在这种情况下，javascript文件中可能有后端变量——比如<em class="le"> .js.erb </em>文件或AEM片段。<strong class="kk iu">一个耦合的、意大利面条式的代码库，感觉几乎不可能现代化。</strong></p><blockquote class="mx"><p id="daa6" class="my mz it bd na nb nc nd ne nf ng ld dk translated">你想停止在这个庞然大物中编写前端代码，并转移到一个更加面向JavaScript的生态系统，但是怎么做呢？</p></blockquote><p id="5766" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">大多数公司无法承受(或不会接受)一次“工具停机”重写的工程停工期。功能需要在积极的开发下进步。毫无疑问，这些功能越来越难以同样的速度发布。</p><blockquote class="mx"><p id="f332" class="my mz it bd na nb nc nd ne nf ng ld dk translated">整体需求应该以渐进、过渡的方式分解成更小的部分。它不能中断业务。</p></blockquote><p id="e9d5" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">然而，解耦一个monolith可能是棘手的，主要是当支持JavaScript应用程序的新API需要经历规划或开发以支持前端迁移时。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="3aec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代前端开发、微前端(MFE)实现和团队自治在等待必要的API经历开发或完成并进入发布周期时被阻塞。<strong class="kk iu">假，可以并行解耦前端到后端。</strong></p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi nt"><img src="../Images/fee0447e7b36b068acbc96ebcc4bab4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7xZ-hErIvKArY3DDY18mQ.jpeg"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">扎克·杰克逊——编剧</figcaption></figure><p id="d482" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个解决方案，可以将前端解耦，并将其移植到一个独立的MFE，并配有SSR。这种方法允许团队这样做，而无需等待后端API被抽象和分离为微服务，甚至是monolith中的可消费API。从里到外更换整块。</p><h1 id="086b" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">阻挡者</h1><p id="6640" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">微前端通常具有这两个必要的依赖性。<br/> 1)认证<br/> 2)在浏览器和服务器端渲染(SSR)期间向应用程序提供数据</p><p id="8a32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据我的经验，无论遗留系统是Rails、Java、.网等。</p><p id="944b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">微前端架构还有其他具有挑战性的方面，这些将在以后的系列文章中详细阐述。敬请关注！</p><h1 id="19e6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">使用整块作为布局引擎</h1><p id="ed89" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">MFE平台设计有几种不同的架构规范。本文将关注一个在后端微服务中流行的改编规范—<strong class="kk iu">【LOSA(大量小应用)</strong>。<strong class="kk iu"> </strong>这种架构<strong class="kk iu"> </strong>是“由内向外”迁移的好选择。</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi oi"><img src="../Images/296a3e59bdaba8749ae3375e3e7c3dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4AIizwcAeaVyC_eTrIU0A.jpeg"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">通过monolith的LOSA请求/响应流程。图像归功于罗伯特·阿克莱特</figcaption></figure><p id="405a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> LOSA </strong>应用程序(一般为微前端)是独立的Node.js服务，能够在服务器端呈现网页的一部分或片段。一个页面可以由多个<strong class="kk iu"> LOSA </strong>服务组成。这些应用/微前端被构建并部署到独立的容器中，并以独立的方式运行</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi oi"><img src="../Images/3fd58112b74a44acf22c15a5971769d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzE-p6IHtG5oqMybdIz_iQ.jpeg"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">相同的网页，由三种不同的方式组成，展示了一个增量迁移路径。开始作为一个整体呈现页面，过渡到LOSA微前端，最后作为一个微前端垂直结束，完全取代了整体。图片来源:罗伯特·阿克莱特</figcaption></figure><p id="5e3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">monolith仍然负责处理HTTP请求对象，向客户端发送最终响应。微前端可以留在集群中的防火墙后面，只有在API网关和用户身份验证可以分离(或者至少变成API端点)之前，才可以直接用于遗留系统。你不需要做太多的改变来为它们的后monolith生活做准备。</p><h1 id="828e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">渲染流</h1><p id="be97" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">下面是一个请求/响应可能结束的模型示例。</p><p id="4eba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，提出一个请求:</p><pre class="nu nv nw nx gt oj ok ol om aw on bi"><span id="c6db" class="oo mb it ok b gy op oq l or os">GET/POST 'https://MFEwebsite.com/parts/header?format=json</span></pre><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ot"><img src="../Images/2fe912fcca0146bc6908454c028efbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBPgZnLihWpoYYVNyiSKAA.png"/></div></div></figure><p id="ad8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">呈现一个页面可能需要各种数据，任何还不能从解耦端点查询的“缺失”信息都可以在请求期间作为道具被<strong class="kk iu">发送</strong>到<em class="le"/><em class="le"/>MFE<em class="le">(</em>微前端)<strong class="kk iu">。以下是MFE在发出请求时所做的事情，请求通过一个负责呈现React应用程序的中间件传递，对任何必要的解耦API发出查询，其响应作为props发送回它。这些道具会组成<code class="fe ou ov ow ok b">window.INITIAL_STATE</code>。</strong></p><h1 id="5f93" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">代码</h1><p id="e87a" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">如果你需要一些如何实现这些模板函数或过滤器的灵感，那么Hypernova值得一看。我没有用过Hypernova，总是选择自己构建。我已经在Rails、Node和PHP后端实现了类似的机制。由于各种后端平台的专有性质，我将使用Hypernova的例子来传达一个基本概念。</p><p id="da9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是express中MFE渲染端点的外观:</p><p id="150d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">来自另一个系统的请求，在本例中为单块:</strong></p><pre class="nu nv nw nx gt oj ok ol om aw on bi"><span id="5a05" class="oo mb it ok b gy op oq l or os">GET/POST 'https://MFEwebsite.com/parts/header?format=json<br/>{<br/>   html: '&lt;div&gt; ... &lt;/div&gt;',<br/>   css: '/static/header.3042u3298423.css',<br/>   js: '/static/header.idhf93hf23iu.js',<br/>   initial_state: {items:[...]}<br/>}</span></pre><p id="0d55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">处理响应的中间件:</strong></p><pre class="nu nv nw nx gt oj ok ol om aw on bi"><span id="7160" class="oo mb it ok b gy op oq l or os">export function exampleRenderAPIware(req, res) {<br/>  const renderedMarkup = renderHTMLpage(<br/>    req,<br/>    this.index,<br/>    intial_state,<br/>  );<br/>  asyncRender.then(() =&gt; {<br/>    const responseObject = {<br/>      html: renderedMarkup,<br/>      initial_state,<br/>      js: jsResource,<br/>      css: cssResource,<br/>    };<br/>    res.status(200).end(JSON.stringify(responseObject));<br/>  });<br/>}</span></pre><p id="8481" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发出这些初始POST请求的控制器应该处理响应，将JS和CSS放入正确的位置，并最终将React应用程序呈现到遗留模板中的适当位置。这是一个遗留模板的例子。通常由monolith中的其他控制器处理的资产将负责将这些脚本和样式注入到遗留的body标签的头部和底部。请记住，整块仍然作为布局引擎。我们正在更换零件，并以React SSR的方式添加新功能。最终，这些LOSA应用程序可以在一个MFE下或与我正在开发的Webpack black magic一起缝合，称为<a class="ae lf" href="https://github.com/ScriptedAlchemy/webpack-external-import" rel="noopener ugc nofollow" target="_blank">web pack-external-import</a>。</p><div class="lg lh gp gr li lj"><a href="https://medium.com/@ScriptedAlchemy/micro-frontend-architecture-dynamic-import-chunks-from-another-webpack-bundle-at-runtime-1132d8cb6051" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">微前端架构:在运行时从另一个Webpack包动态导入块。</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">在运行时从其他Webpack包导入块的挑战和解决方案，使用它们就像有…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">medium.com</p></div></div><div class="ls l"><div class="ox l lu lv lw ls lx ly lj"/></div></div></a></div><h2 id="bad3" class="oo mb it bd mc oy oz dn mg pa pb dp mk kr pc pd mm kv pe pf mo kz pg ph mq pi bi translated">从模板数据迁移到新的API怎么样？</h2><p id="bb44" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">当一个新的API被解耦并上线时，在迁移中可以期待什么？</p><p id="2e81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当monolith向MFE提供数据时，Express.js从HTTP请求体访问这些信息。现在，express需要从API异步获取数据。数据格式可能已经改变，但是React仍然接收props。令人印象深刻的直白。</p><h1 id="9b21" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">表演</h1><p id="5332" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">与旧的monoliths相比，新的LOSA(许多小应用程序)架构性能不够，页面的一部分渲染需要400-600毫秒。我们使用异步工人结构，这意味着我们可以要求多个服务对应用程序的不同部分进行SSR，而不是一个SSR应用程序。这使得离线生产变得非常困难，因为“生产失败”意味着可能会丢失10分钟的侧边栏或页脚，直到它被修复。最好的关注点分离。</p><p id="c9aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我所说的LOSA异步工人。有许多节点服务，每个负责呈现一个/多个组件。</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi pj"><img src="../Images/ad567d1d6e7f221bb8732eb5793fb509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8QFoZCYUclxH-iDYEc49A@2x.jpeg"/></div></div></figure><p id="6c2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">支持遗留后端视图的控制器(灰色齿轮)可以将视图数据转移到post请求，而不是后端模板引擎。回收数据意味着后端不需要太多的工作来支持这些机制。避免大的修改将释放大部分后端工程，以专注于解耦数据提供者，而前端可以独立地进展。</p><p id="ab8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于视图数据被发送到外部react服务，对该发送的响应(包含标记)随后被传递到后端模板引擎，同时传递的还有样式表、初始状态和CSS URLs。模板引擎现在只呈现来自POST请求的响应，从而将您的视图或部分视图从遗留的monolith中分离出来。</p><h2 id="3b93" class="oo mb it bd mc oy oz dn mg pa pb dp mk kr pc pd mm kv pe pf mo kz pg ph mq pi bi translated">反应渲染时间</h2><p id="2a00" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">反应很慢！SSR就是不够快，所以我们新的react解决方案LOSA架构的性能不够好，不可行。我们的解决方案:【react内部的片段缓存。</p><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi pk"><img src="../Images/185898dea4902c91b81ff8229af00f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jILQjF2AroeXDVR_neY_fQ@2x.jpeg"/></div></div></figure><ul class=""><li id="9f18" class="pl pm it kk b kl km ko kp kr pn kv po kz pp ld pq pr ps pt bi translated">黄色:无反应片段缓存—端到端(+-400毫秒)</li><li id="f805" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">深紫色:带React片段缓存—端到端(+-150毫秒)</li><li id="707b" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">橙色:完全优化的架构(+-20毫秒)</li><li id="942b" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">绿色(在数据点的底部):来自后端的本机片段缓存</li></ul><p id="834d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将需要写另一篇文章来详细介绍创建一个完全优化的react服务器的整个过程(抱歉<a class="pz qa ep" href="https://medium.com/u/742f2d568062?source=post_page-----61f60d2e14c1--------------------------------" rel="noopener" target="_blank">安东·科尔祖诺夫</a>)。Graphana的数据显示，我们至少将渲染性能提高了一倍，循环时间仍然非常慢。而在内部，React能够非常快速地渲染——端到端时间不如我们希望的那样高。至少150毫秒。如您所见，我将在下一篇文章中详细阐述——我可以与片段后端片段缓存竞争。</p><h2 id="f1ba" class="oo mb it bd mc oy oz dn mg pa pb dp mk kr pc pd mm kv pe pf mo kz pg ph mq pi bi translated">渲染时间与循环时间</h2><p id="1c73" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">渲染时间是挑战的一部分，但即使在React内部实现了片段缓存之后。我失望地看到，虽然我们在Node.js中的内部渲染时间非常快(大约20毫秒)。整个首尾相连的行程<strong class="kk iu">仍然</strong>耗时140-200毫秒。</p><h2 id="bec0" class="oo mb it bd mc oy oz dn mg pa pb dp mk kr pc pd mm kv pe pf mo kz pg ph mq pi bi translated">瓶颈是什么</h2><ol class=""><li id="e00a" class="pl pm it kk b kl ms ko mt kr qb kv qc kz qd ld qe pr ps pt bi translated">JSON大小，特别是初始应用程序状态。发送呈现页面所需的最低状态。不要把太多的字符串化状态转储到初始渲染中。发送足够的状态，以便React能够重新水合，并且可能发送一些额外的状态，以便使折叠组件立即交互。</li><li id="5719" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld qe pr ps pt bi translated">要呈现的DOM节点的数量——不要再把代码包装在无用的div中，只是为了在上面放一个类。利用HTML的语义特性和CSS的层叠效果。您最终会编写更少的标记，从而导致生成更少的<code class="fe ou ov ow ok b">React.createComponent</code>函数。</li><li id="43f7" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld qe pr ps pt bi translated">垃圾收集——更多细节将在后续文章系列中介绍。</li><li id="2488" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld qe pr ps pt bi translated">只有和数据提供者一样快。—利用中间层的Redis缓存。如果你向我抛出“缓存失效很难”的论点，那么看看事件源。更好的是，用CQRS和异步工人来解决读写问题。</li><li id="769c" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld qe pr ps pt bi translated">monolith和MFE之间的HTTP开销— gRPC、CQRS、UDP和Protobuf。独石和你的MFE之间的通信应该通过Kubernetes网络在内部进行。开机自检很慢，但很有效。当你碰到问题时，就相应地处理它。</li></ol><h2 id="2410" class="oo mb it bd mc oy oz dn mg pa pb dp mk kr pc pd mm kv pe pf mo kz pg ph mq pi bi translated">我如何胜过后端渲染</h2><p id="a2ca" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">模板化、片段缓存和gRPC/CQRS，消除了初始状态JSON的膨胀。在服务器上反应很慢。很容易忘记，没有抽象更快，只有更慢。</p><h1 id="b43a" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">规模呢？</h1><p id="5abf" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">任何好的解决方案都需要在规模上具有成本效益。运营成本增长到天文数字。有钱能使鬼推磨，糟糕的业绩成本。我大规模构建廉价的解决方案。以下是perf让你付出代价的方式:</p><p id="d224" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1)支付昂贵的第三方服务来承担负载</p><p id="c5ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2)为更多/更大的容器付费</p><p id="47b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3)由于业绩不佳而错过收入</p><p id="a0a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">monolith通常会导致发布周期或部署交通堵塞，因为两个分支不能同时进入master。</p><p id="a4d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5)开发人员可以在风险较低的环境中更快地行动，企业能够向市场提供新的想法，并回滚有问题的领域——能够快速高效地行动的团队是经济高效的企业推动者。</p><h1 id="32da" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结果呢</h1><p id="89b6" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated"><strong class="kk iu">流量</strong>:1000万(渲染)/天</p><p id="f415" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">资源分配:</strong></p><ul class=""><li id="1605" class="pl pm it kk b kl km ko kp kr pn kv po kz pp ld pq pr ps pt bi translated">实例:5</li><li id="82e8" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">内存:100英里(100兆内存)</li><li id="a34c" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">CPU: 100(单核)</li><li id="c3a3" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">最大CPU使用率阈值:65%</li><li id="d8a5" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">响应时间:20–25毫秒</li><li id="f678" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">DOM复杂性:高</li><li id="29e5" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">响应时间缩短95%。</li></ul><figure class="nu nv nw nx gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi qf"><img src="../Images/b16ee38dbcb665e68f625f0a888b906b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fS9hsG5Ehv6wngJXE2sdRw.jpeg"/></div></div></figure><ul class=""><li id="e334" class="pl pm it kk b kl km ko kp kr pn kv po kz pp ld pq pr ps pt bi translated">绿色:后端渲染时间</li><li id="4ac0" class="pl pm it kk b kl pu ko pv kr pw kv px kz py ld pq pr ps pt bi translated">蓝色:对片段缓存和状态优化做出反应。</li></ul><blockquote class="mx"><p id="b5ea" class="my mz it bd na nb qg qh qi qj qk ld dk translated">我的单线程Javascript应用程序比具有成熟片段缓存的多线程后端系统更快。</p></blockquote><p id="7153" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">在推特上关注我</p><p id="8890" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你需要更多信息或咨询，请联系我。</p><p id="21b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一个系列中——我将详细阐述在本文末尾简要提到的性能方面。</p></div></div>    
</body>
</html>