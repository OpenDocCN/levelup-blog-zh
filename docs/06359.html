<html>
<head>
<title>Dynamic Programming: Subset Sum Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划:子集和问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamic-programming-subset-sum-c386126621cd?source=collection_archive---------0-----------------------#2020-11-18">https://levelup.gitconnected.com/dynamic-programming-subset-sum-c386126621cd?source=collection_archive---------0-----------------------#2020-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb39" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">动态规划问题#2:子集和</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8907215a879818c33ce5bded578ba8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*45xYjQ6j3i-qitLh"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">萨法尔·萨法罗夫在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开始子集和问题之前，我强烈推荐你阅读一下<a class="ae kv" href="https://medium.com/swlh/dynamic-programming-9a5e60fb7245" rel="noopener"> <strong class="ky ir">动态编程</strong> </a>的介绍。在这里，我已经介绍了如何处理基于DP的问题的基本方法。我们将使用相同的概念来解决<strong class="ky ir">子集和</strong>问题。我还建议仔细研究一下<a class="ae kv" href="https://medium.com/@tanishqvyas069/dynamic-programming-0-1-knapsack-5af91763b6d5" rel="noopener"> <strong class="ky ir">背包问题</strong> </a>，因为它是<strong class="ky ir">子集和问题</strong>的父问题。</p><p id="011c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">话虽如此，我们开始吧！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="30e3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">1.什么是子集和问题？</h1><p id="a7f2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">给定一组<strong class="ky ir"> N </strong>非负整数和一个目标和<strong class="ky ir"> S </strong>，确定是否存在给定集合的子集，使得子集的元素和等于<strong class="ky ir"> S </strong>。如果存在这样的子集，则返回1，否则返回0。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a50c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">2.递归、记忆和制表</h1><p id="ad1b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个问题与<a class="ae kv" href="https://medium.com/@tanishqvyas069/dynamic-programming-0-1-knapsack-5af91763b6d5" rel="noopener">0–1背包问题</a>非常相似，在这种情况下是它的父问题。因此我推荐你去看一看。</p><p id="2ac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你读过上面提到的两篇文章，那么你就会知道，为了编写一个合适的基于DP的解决方案，你必须能够想到一个递归的解决方案。我们将使用Python3来编码这个问题的解决方案。让我们看看递归解是什么样的。</p><h2 id="da48" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">a)递归方法</h2><p id="0ce8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了写出一个递归解，一个人必须能够弄清楚两件事:<em class="ni">基础条件&amp;递归逻辑</em>/递归关系<em class="ni">。</em></p><ol class=""><li id="05f7" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">基本条件:基本条件总是指我们试图解决的问题的最小可能情况。在这种情况下，有两种可能性:</li></ol><ul class=""><li id="3c84" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr ns np nq nr bi translated">如果目标总和<strong class="ky ir"> S </strong>等于0。在这种情况下，不管给定的集合是什么，人们总是能够找到一个子集(它是空集),使得该子集的一些元素是0。</li><li id="64c6" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr ns np nq nr bi translated">如果集合(<strong class="ky ir"> N) </strong>中的元素个数为零。在这种情况下，无论我们如何努力，我们都无法得到一个元素之和等于目标和<strong class="ky ir"> S </strong>的子集。因此，在所有这些情况下，我们返回<strong class="ky ir">假</strong>。然而，如果<strong class="ky ir"> N = 0 </strong>以及<strong class="ky ir"> S = 0 </strong>，我们返回<strong class="ky ir"> True </strong>，因为空集满足要求。但是由于我们在上一点中已经讨论了这个案例，所以我们不需要在这里担心它。</li></ul><p id="9f43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir">递归逻辑:</strong>就像我们在<a class="ae kv" href="https://medium.com/@tanishqvyas069/dynamic-programming-0-1-knapsack-5af91763b6d5" rel="noopener">0–1背包问题</a>中做的一样，即使在这里我们也要看这个数是否有可能包含在子集里。</p><ul class=""><li id="301a" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr ns np nq nr bi translated">该数字的值必须小于或等于目标总和<strong class="ky ir"> B </strong>才能被考虑纳入。</li><li id="27ce" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr ns np nq nr bi translated">如果这个数字可以包括在内，我们考虑两种情况:</li></ul><ol class=""><li id="99c7" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">数的包含:如果数被包含，那么我们将目标和减去该数，并继续下一个递归调用。</li></ol><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="4e56" class="mw ma iq nz b gy od oe l of og">target_sum = target_sum - number</span></pre><p id="cae9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.排除数:如果数不包括在内，那么目标和保持不变，我们简单地进行下一个递归调用。</p><p id="b84f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住所有这些，这就是递归解决方案的样子</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/59acc2933f7f404a30e8ae4e70b277d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDRXxPZ5Nd4Gs76yLNRnwQ.png"/></div></div></figure><p id="5ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了基本的逻辑和我们前面讨论的案例，上面是相同的递归实现。现在我们有了递归的解决方案，让我们把它转换成一个<strong class="ky ir">记忆的</strong>解决方案。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="6247" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">记忆化</h2><p id="847e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">从我们在<a class="ae kv" href="https://medium.com/swlh/dynamic-programming-9a5e60fb7245" rel="noopener">这个</a>和<a class="ae kv" href="https://medium.com/@tanishqvyas069/dynamic-programming-0-1-knapsack-5af91763b6d5" rel="noopener">这个</a>的讨论中，我们都知道在编写记忆解决方案时，我们必须牢记以下几点:</p><ul class=""><li id="7bc9" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr ns np nq nr bi translated">为了减少递归调用，我们保存计算的值供以后使用。我更喜欢把这个变量叫做<strong class="ky ir"> store </strong>。</li><li id="9c7d" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr ns np nq nr bi translated">商店的规模取决于在我们的递归解决方案的变化参数的数量。在这种情况下是2:目标总和&amp; N。因为目标总和可以总共取<strong class="ky ir"> S+1 </strong>个值，并且元素数目可以总共取<strong class="ky ir"> N+1 </strong>个可能值。这样我们就有了<strong class="ky ir">商店【N+1】【S+1】</strong>。</li><li id="8f77" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr ns np nq nr bi translated">在计算任何呼叫的答案之前，我们检查存储中是否存在答案。如果它存在，我们同样返回。否则我们计算它并存储它以备后用。</li><li id="2f64" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr ns np nq nr bi translated">可视化<strong class="ky ir"> store </strong>最简单的方法是理解这样一个事实，即(在本例中)一般来说<strong class="ky ir"> store[n][s] </strong>保存着函数调用<strong class="ky ir"> isSubsetSum(number_set，n，s) </strong>的答案。</li></ul><p id="7b98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住这几点，让我们看看修改后的解决方案是什么样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/af66a7e7e7dc0147039355ad23407965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTR0ef8o1vbDGAvFpwcZ8g.png"/></div></div></figure><p id="75e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们如何通过增加几个简单的步骤来记忆我们的递归解。这极大地改进了解决方案，因为它将时间复杂度从指数级降低到多项式级。</p><p id="a9a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看如何编写一个<strong class="ky ir">列表</strong>解决方案。</p><h2 id="b3de" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">c)制表</h2><p id="8de2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">表格化的关键概念是能够借助<strong class="ky ir">基本条件</strong>和<strong class="ky ir">递归逻辑</strong>自下而上地构建<strong class="ky ir">存储</strong>。</p><p id="50f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从我们在<a class="ae kv" href="https://medium.com/swlh/dynamic-programming-9a5e60fb7245" rel="noopener">这</a>和<a class="ae kv" href="https://medium.com/@tanishqvyas069/dynamic-programming-0-1-knapsack-5af91763b6d5" rel="noopener">这</a>中的讨论中，我们都知道在编写列表解决方案时必须牢记以下几点:</p><ul class=""><li id="eca3" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr ns np nq nr bi translated">商店的规模取决于在我们的递归解决方案的变化参数的数量。在这种情况下是2:目标总和&amp; N。因为目标总和可以总共取<strong class="ky ir"> S+1 </strong>个值，并且元素数目可以总共取<strong class="ky ir"> N+1 </strong>个可能值。这样我们就有了<strong class="ky ir">商店【N+1】【S+1】</strong>。</li><li id="ad5a" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr ns np nq nr bi translated">可视化<strong class="ky ir"> store </strong>最简单的方法是理解这样一个事实，即(在这种情况下)通常<strong class="ky ir"> store[n][s] </strong>保存函数调用<strong class="ky ir"> isSubsetSum(number_set，n，s) </strong>的答案。</li><li id="414a" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr ns np nq nr bi translated">为了开始，我们必须有所建树。因此我们需要初始化<strong class="ky ir">存储</strong>的某些值。这就是<strong class="ky ir">基地条件</strong>来救援的地方。我们在递归解的基础条件的帮助下初始化存储。</li><li id="f205" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr ns np nq nr bi translated">使用初始化的值和递归逻辑完成对<strong class="ky ir">存储器</strong>的填充。从而最终获得<strong class="ky ir"> store[n][targetSum] </strong>的值，我们知道，该值保存了对原始函数调用<strong class="ky ir"> isSubsetSum(number_set，n，targetSum) </strong>的回答。然后我们返回相同的。</li></ul><p id="bae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住这几点，让我们看看列表解决方案(自下而上的方法)会是什么样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/7746f7393b03017031b7196fceaf3e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jBI1xDyqmTIsk0t29YCJTA.png"/></div></div></figure><p id="c387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是如何通过遵循前面讨论的步骤和我们从递归解得到的知识来编写列表解。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="73d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，<strong class="ky ir">子集求和问题</strong>结束。我希望这篇文章能提供信息，帮助你正确理解DP的概念，以及如何为<strong class="ky ir">子集和问题</strong>编写<strong class="ky ir">记忆</strong>和<strong class="ky ir">列表</strong>解决方案。</p><h1 id="270b" class="lz ma iq bd mb mc ok me mf mg ol mi mj jw om jx ml jz on ka mn kc oo kd mp mq bi translated"><strong class="ak">参考文献&amp;其他文章</strong></h1><ol class=""><li id="61b7" class="nj nk iq ky b kz mr lc ms lf op lj oq ln or lr no np nq nr bi translated"><a class="ae kv" href="https://medium.com/swlh/dynamic-programming-9a5e60fb7245" rel="noopener">动态编程入门</a></li><li id="dc23" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr no np nq nr bi translated"><a class="ae kv" href="https://medium.com/@tanishqvyas069/dynamic-programming-0-1-knapsack-5af91763b6d5" rel="noopener">0–1背包问题|动态规划</a></li><li id="323d" class="nj nk iq ky b kz nt lc nu lf nv lj nw ln nx lr no np nq nr bi translated"><a class="ae kv" href="https://tanishqvyas069.medium.com/dynamic-programming-equal-sum-partition-problem-b5059caf46bb" rel="noopener">等分问题|动态规划</a></li></ol></div></div>    
</body>
</html>