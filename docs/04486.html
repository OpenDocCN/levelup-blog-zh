<html>
<head>
<title>Solving the “Welsh Sort” Problem!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决“威尔士排序”问题！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solving-the-welsh-sort-problem-30458a4dd6bc?source=collection_archive---------12-----------------------#2020-06-29">https://levelup.gitconnected.com/solving-the-welsh-sort-problem-30458a4dd6bc?source=collection_archive---------12-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5eae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">鲸鱼！—我是说威尔士！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/381654b5f36ae2279dcda1a2dcc0038e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t_CKOsZ8EL-aGDQP"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">不是这种腰！</figcaption></figure><p id="086f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近，我一直在为顶级科技公司的硬编码面试做准备。大约两个月前，我发表了一篇文章，取笑了这些类型的编码问题,但随后我在一次采访中几乎立即被问到这些问题，所以我仍然认为它们既无用又必要，因为程序员需要向彼此证明他们是“S-M-E-R-T”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/65e4f1b5578c28d6fb266d35996902d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOManVZQt9skf8_bh1tanQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Yaaas英俊的23岁！教我编码！</figcaption></figure><p id="3afe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近我一直在像<a class="ae lu" href="http://leetcode.com" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>和<a class="ae lu" href="http://hackerrank.com" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>这样的网站上解决这些问题，尽管这两个网站最近都把它们的一些内容变得更加“高级”,以从我们这些失业的无业游民身上榨取金钱。但是如果(说实话:当)我在一个问题上卡住了，我会去看看这个家伙的视频，他指导我解决这个问题。</p><p id="c77d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我把他用Java写的代码翻译成JavaScript，如果不完全相同的话，这通常非常容易(帮助我认识到它们的相似之处！)并为问题的所有行写下注释，这样我就知道我理解了。</p><p id="924f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，如果可以的话，我会在LeetCode上测试它，看看它是否能运行，或者编写我自己的测试，然后如果我做错了，就像我有时害怕的骗子综合症n00b一样绝望地向朋友求助。</p><p id="eeed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，最近我遇到了一个问题，没有任何视频或容易找到的公共信息。问题是这样的:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="22f6" class="mb mc it lx b gy md me l mf mg">Given the Welsh Alphabet, which is slightly different than the English one, design a function that sorts a list of words by that alphabet:</span><span id="0248" class="mb mc it lx b gy mh me l mf mg">"<em class="mi">a b c ch d dd e f ff g ng h i j l ll m n o p ph r rh s t th u w y"</em></span><span id="ec10" class="mb mc it lx b gy mh me l mf mg">Note: "double" letters supersede single letters so "ng" would be considered in its current order and not as an "n g".</span></pre><p id="cbbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那些是英国音！人们甚至可以说，试图解决这个问题将是一个“艰难的夜晚”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/34568ebf2e9145129cb73bbe127a3c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/0*ZnblSk4rzLbrppeu.jpg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">看我在那里做了什么。</figcaption></figure><p id="40ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不管怎样，既然没有LeetCode也没有视频，那就开始吧！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="d9ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们复制并粘贴威尔士字母表，使其成为一个好变量。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c177" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu">const</strong> welshAlphabet = 'a b c ch d dd e f ff g ng h i j l ll m n o p ph r rh s t th u w y'</span></pre><p id="2150" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们知道我们需要一个函数来接受由我们的函数判断的单词的列表或数组。同时，让我们把那个大的旧字符串也变成一个数组！比较好对付！</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="fcfd" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu">const</strong> welshSort = (welshWordsArray) <strong class="lx iu">=&gt;</strong> {</span><span id="e90c" class="mb mc it lx b gy mh me l mf mg"><em class="mi"> //turn the string into an array of welsh letters.</em></span><span id="3443" class="mb mc it lx b gy mh me l mf mg"><strong class="lx iu"> let</strong> welshArray = welshAlphabet.split(' ')</span></pre><p id="e00b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢尽可能描述性地给事物命名，以免自己被弄糊涂！</p><p id="3ac1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来让我们创建一个<em class="mi">字典</em>！在JavaScript中，我们称之为<em class="mi">映射、</em>哈希映射或<em class="mi">对象</em>。这将是一种尽可能快地跟踪字母表顺序的方法，因为在一个<em class="mi">对象</em>中查找值需要O(1)时间！因此，要制作这个字典，我们只需将其初始化为一个变量，并使用JavaScript <em class="mi"> forEach </em>循环来获取字母的<em class="mi">索引</em>或顺序，并将它们设置为威尔士字母的<em class="mi">键</em>的<em class="mi">值</em>。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="397e" class="mb mc it lx b gy md me l mf mg"><em class="mi">//create a map/dicitonary for the welsh letters with O(1) lookup.</em></span><span id="4d1e" class="mb mc it lx b gy mh me l mf mg"><strong class="lx iu">const</strong> welshDict = {}</span><span id="ce4a" class="mb mc it lx b gy mh me l mf mg"><em class="mi">//add each letter as a key in the dictionary with its value based on order.</em></span><span id="a3a7" class="mb mc it lx b gy mh me l mf mg">welshArray.forEach((letter,i) <strong class="lx iu">=&gt;</strong> welshDict[letter] = i)</span></pre><p id="d1a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在重要的是，我想把一些逻辑抽象成一个帮助函数。我已经有了一个想法，我们将遍历每个单词，寻找那些威尔士双字母，我想创建一个函数，告诉我一个字母是否是其中之一。</p><p id="e011" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我将使用<em class="mi"> String.slice() </em>方法一次查看字符串中的两个元素，看看它们是否可能是威尔士语，如果是，我们希望它们按照双字母值进行估值。否则，我们将只取字符串中任何位置<em class="mi">的单个字母</em>。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="7634" class="mb mc it lx b gy md me l mf mg"><em class="mi">//helper function to see if the letter we're checking is a two letter Welsh character or not.</em></span><span id="8be7" class="mb mc it lx b gy mh me l mf mg"><strong class="lx iu">const</strong> isItWelsh = (word, position) <strong class="lx iu">=&gt;</strong> {</span><span id="1be9" class="mb mc it lx b gy mh me l mf mg"><em class="mi">  //if it is a welsh letter, this slice of the word will be the letter.</em></span><span id="6181" class="mb mc it lx b gy mh me l mf mg"><strong class="lx iu"> let</strong> potentiallyWelsh = word.slice(position, position +2)</span><span id="9024" class="mb mc it lx b gy mh me l mf mg"><em class="mi">  //if we're not at the end of the word and the two-letter character is in the welsh alphabet, return it</em></span><span id="1601" class="mb mc it lx b gy mh me l mf mg">  if(position &lt; word.length-1 &amp;&amp; potentiallyWelsh in welshDict) return potentiallyWelsh;</span><span id="ae31" class="mb mc it lx b gy mh me l mf mg"><em class="mi">  //otherwise return the single character letter</em></span><span id="1857" class="mb mc it lx b gy mh me l mf mg">  return word[position]</span><span id="87e6" class="mb mc it lx b gy mh me l mf mg">}</span></pre><p id="5a21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了，我们已经完成了最难的部分。现在我们只需要进行实际的排序。现在在JavaScript中，我们可以调用<em class="mi"> Array.sort() </em>或者我们可以添加一个选项<em class="mi">函数</em>来排序，给定数组中的两个值，这就是我们要做的。</p><p id="d5e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将是我们函数的<em class="mi">返回</em>值，因为它将被排序，我们还可以将我们的位置初始化为单词的第一个元素，在JavaScript中该元素的索引为0。</p><p id="d2a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们可以处理一个<em class="mi">边缘情况</em>，意思是不太可能发生但有可能发生的事情。在这种情况下，我们要处理的是这两个词是否完全相同，这意味着我们不需要做任何花哨的逻辑！</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1b4b" class="mb mc it lx b gy md me l mf mg"><em class="mi">//we need to sort these words by a custom method</em></span><span id="4217" class="mb mc it lx b gy mh me l mf mg">return welshWordsArray.sort((a,b) <strong class="lx iu">=&gt;</strong> {</span><span id="4015" class="mb mc it lx b gy mh me l mf mg"><em class="mi">//edge-case, if they're the same word, no need to manipulate the array!</em></span><span id="3a4c" class="mb mc it lx b gy mh me l mf mg">if(a === b) return 0;</span><span id="f838" class="mb mc it lx b gy mh me l mf mg"><em class="mi">//initializing the position at the start of the word.</em></span><span id="5050" class="mb mc it lx b gy mh me l mf mg"><strong class="lx iu">let</strong> position = 0</span></pre><p id="9d4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧！现在让乐趣开始吧。</p><p id="c0c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将想要迭代地查看这个数组<em class="mi">的每个字母</em>，这意味着我们将使用一个<em class="mi">循环</em>。为了简单起见，我只使用了一个<em class="mi"> while(true) </em>循环，如果不告诉它停止，它将无限运行，所以我必须用<em class="mi"> return </em>或<em class="mi"> break </em>语句手动停止它。</p><p id="2ab6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，如果单词在某一点上完全相同，但是其中一个更长(例如:able，ableist)，我们将会把最短的那个放在比T42更长的那个后面。所以我们也会处理的。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f41a" class="mb mc it lx b gy md me l mf mg"><em class="mi">//using a loop to loop through the whole word with no condition so we can use custom returns.</em></span><span id="f1c6" class="mb mc it lx b gy mh me l mf mg">while(true){</span><span id="f667" class="mb mc it lx b gy mh me l mf mg"><em class="mi">  //if we've reached the end of the first word and it's been equal thus far but shorter, it goes before.</em></span><span id="f98a" class="mb mc it lx b gy mh me l mf mg">  if(position &gt;= a.length) return -1;</span><span id="fbd2" class="mb mc it lx b gy mh me l mf mg"><em class="mi">  //if we've reached the second word and it's been equal but shorter it goes before.</em></span><span id="a408" class="mb mc it lx b gy mh me l mf mg">  if(position &gt;= b.length) return 1;</span></pre><p id="efcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是简单的部分！我们需要检查每个字母和两个字母块，看看它是否是威尔士语！通常这涉及到很多逻辑，但是因为我们做了一个助手函数，所以很简单:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c005" class="mb mc it lx b gy md me l mf mg"><em class="mi">//initializing what the letters are at the current position using our helper function</em></span><span id="1a1e" class="mb mc it lx b gy mh me l mf mg"><strong class="lx iu">let</strong> letterA = isItWelsh(a, position)</span><span id="9587" class="mb mc it lx b gy mh me l mf mg"><strong class="lx iu">let</strong> letterB = isItWelsh(b, position)</span></pre><p id="3736" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们还有最后一个条件。如果我们在相同的位置有相同的字母，一个或两个字符的字母，我们想移动到下一个位置，继续我们的循环。否则，我们可以用排序语法<em class="mi"> a-b </em>按字母排序，这给出了一个<em class="mi">升序</em>和<em class="mi">返回值</em>的排序。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="efd6" class="mb mc it lx b gy md me l mf mg"><em class="mi">//if they're letters are equal, go to the next letter, either 1 or 2 away!</em></span><span id="d3d8" class="mb mc it lx b gy mh me l mf mg">if(letterA === letterB){</span><span id="161b" class="mb mc it lx b gy mh me l mf mg">  position += letterA.length</span><span id="89fe" class="mb mc it lx b gy mh me l mf mg">} else {</span><span id="ce41" class="mb mc it lx b gy mh me l mf mg"><em class="mi">  //otherwise sort them by their welsh values comparing the first and second word.</em></span><span id="4d60" class="mb mc it lx b gy mh me l mf mg">  return welshDict[letterA] - welshDict[letterB]</span><span id="936c" class="mb mc it lx b gy mh me l mf mg">}</span></pre><p id="1119" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们完事了。最终的代码看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="11e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，最后，让我们来谈谈<strong class="la iu">时间和空间的复杂性</strong>，因为这是一个面试问题，你很可能会被问到这个问题。</p><p id="4707" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">空间复杂度</strong>相当简单，因为无论函数有多长，我们都只创建一个数组和一个对象，这意味着如果<strong class="la iu">永不改变</strong>，那么它就是<strong class="la iu">常量空间或O(1) </strong>。</p><p id="0a7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong>稍微难一点。据我所知，对于我们的<strong class="la iu">排序</strong>算法，我们平均得到<strong class="la iu"> O(n log n) </strong>时间，<a class="ae lu" href="https://blog.shovonhasan.com/time-space-complexity-of-array-sort-in-v8/#:~:text=Time%20and%20Space%20Complexity.,-There's%20nothing%20magical&amp;text=Quicksort's%20space%20complexity%20is%20O,sorts%20the%20array%20in%20place." rel="noopener ugc nofollow" target="_blank">更多信息在这里，这实际上是非常酷的</a>。</p><p id="2dd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，按照我的理解，<strong class="la iu">因为我们不仅要对每个单词进行排序，还要遍历它来确定一个字母是否是威尔士语</strong>，<strong class="la iu">时间复杂度(最坏情况)是O(最长单词的长度。* n log n) </strong>。</p><p id="5285" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哇哦。汪汪。东盟地区论坛。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="325f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原来如此！虽然我认为威尔士是个好地方，但我没有关于它的事实。我只是不希望任何人在困境中被遗忘，这可能也不是威尔士人的事情。</p><p id="6170" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是艰难的，虽然我没有一个机智的segue，所以，这里有一个可爱的狗！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/679d3ba6f8853a884d27f8f1335e2b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ln4jHwzBeS63DXaVmaKFvg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">影子！</figcaption></figure><p id="1e45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是最棒的男孩影子。他是个午夜小可爱。他超级聪明，知道什么时候拉你停止像变魔术一样拉你。他也很有情商，会舔和倾斜。一旦他在肖恩·卡西，我肯定他会被收养。</p><p id="8bd1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他很聪明，我打赌他能学会威尔士语。</p><p id="18fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管他是只狗。</p><p id="496c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尤其是因为他是只狗。</p><p id="2fd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">白现在来说，</p><p id="bffa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">网络信息中心(Network Information Center)ˌ网路界面卡(Network Interface Card)ˌ全国工业理事会(National Industrial Council)ˌ航行情报中心(Navigation Information Center)</p></div></div>    
</body>
</html>