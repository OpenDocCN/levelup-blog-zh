<html>
<head>
<title>Stop Right There with Coroutines in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Unity中停止使用协程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stop-right-there-with-coroutines-in-unity-dacef8b69bc2?source=collection_archive---------6-----------------------#2021-05-11">https://levelup.gitconnected.com/stop-right-there-with-coroutines-in-unity-dacef8b69bc2?source=collection_archive---------6-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f0e9afa0a39117f8eec198c90447d185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wb2oavPYtbgC6hln_0X4AA.png"/></div></div></figure><div class=""/><p id="6293" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">当你需要在执行一个<strong class="ke jf">动作</strong>之前<strong class="ke jf">等待</strong>一定量的<strong class="ke jf">时间</strong>时，Unity中的协程会前来救援。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi la"><img src="../Images/b33337a9b083c7a550ee6de402907aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*BeN84gHIVofs0MBjNSEPlw.png"/></div></figure><p id="c68a" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">下面的信息性描述直接来自Unity的文档，表明协程可以<strong class="ke jf">暂停它的执行</strong>，直到给定的<strong class="ke jf">产出指令</strong>完成。基本上，脚本从上到下运行，没有停顿，但是协程能够让<strong class="ke jf">暂停</strong>和<strong class="ke jf">等待</strong>的指令，然后继续运行。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lf"><img src="../Images/a4ed954681933b8c4315652c76a0f7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3_GWW4ATBJs-r8pGwdX6g.png"/></div></div></figure><p id="9b63" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这个例子中，我将制作一个基本的敌人产卵器，每隔<strong class="ke jf">秒</strong>就会产生新的敌人。我希望敌人在一个while循环中产卵，这意味着只要某个条件为真，敌人就会一直产卵，直到那个条件为假。首先是一个变量来容纳我们的条件，以一个<strong class="ke jf"> bool </strong>(真或假)的形式出现。为了清楚这里的意图，这个名字可以是一个明显的<strong class="ke jf">stoppening</strong>并且应该被设置为<strong class="ke jf"> false </strong>。现在敌人会产卵，直到停止产卵成为现实。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lg"><img src="../Images/b7490a5a27b121c22c1d967385e1c56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9FE5Gs8zODAgaMwN53mlg.png"/></div></div></figure><p id="f27c" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">为了<strong class="ke jf">创建</strong>协程，需要创建<strong class="ke jf"> IEnumerator </strong>类型的<strong class="ke jf">函数</strong>，然后为该方法指定一个合适的<strong class="ke jf">名称</strong>。在这里我将其命名为<strong class="ke jf"> SpawnRoutine() </strong>。至于另一个文本，<strong class="ke jf"> while循环</strong>将继续运行，直到那个<strong class="ke jf">stop spacing</strong>变量变为<strong class="ke jf"> true </strong>，我可以稍后将它赋值，例如当玩家<strong class="ke jf">死亡</strong>时。需要注意的重要部分是代码的最后一行。需要这个<strong class="ke jf"> yield return new </strong>语句来防止协程抛出<strong class="ke jf">错误</strong>。它还告诉代码让<strong class="ke jf">产生</strong>，然后<strong class="ke jf">返回</strong>新的。新的返回是代码的最后一位，表示<strong class="ke jf">等待秒(2f) </strong>，它告诉我的代码在<strong class="ke jf">继续</strong>之前<strong class="ke jf">等待</strong>2秒<strong class="ke jf">。由于这是一个while循环，在2秒钟过去后，代码将返回到顶部并创建另一个敌人<strong class="ke jf">以此类推，直到玩家死亡。</strong></strong></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lh"><img src="../Images/0351026c362d20fdd3f60546f0c21be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h65wsuRQastmunuSKZPukw.png"/></div></div></figure><p id="990b" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">最后要介绍的是如何<strong class="ke jf">启动</strong>一个协程。这是非常简单的，关键字<strong class="ke jf"> StartCoroutine </strong>，后面是括号中<strong class="ke jf">方法</strong>的<strong class="ke jf">名称</strong>。在方法名的末尾需要另一组方法本身的括号，以便像调用任何其他void方法一样调用它。在这里，我把它放在void start中，所以它会在游戏开始时激活。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi li"><img src="../Images/862ffad4fa799af2c4361c61f358a4b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEGYSw-HeargkweNwsQ54Q.png"/></div></div></figure><p id="9d86" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">就编码技术而言，协程<strong class="ke jf">是强大的<strong class="ke jf">函数</strong>。在项目中有很多需要<strong class="ke jf">暂停</strong>和使用<strong class="ke jf">定时器</strong>的情况，将会是<strong class="ke jf">关键</strong>。对于那些我们需要<strong class="ke jf">让出</strong>…协程来拯救的情况！</strong></p></div></div>    
</body>
</html>