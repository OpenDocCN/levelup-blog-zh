<html>
<head>
<title>Simulating Rubik Cube Actions with Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java模拟魔方动作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simulating-rubik-cube-actions-with-java-10cf44bc6014?source=collection_archive---------4-----------------------#2022-06-23">https://levelup.gitconnected.com/simulating-rubik-cube-actions-with-java-10cf44bc6014?source=collection_archive---------4-----------------------#2022-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/434d892879f5f19435b260705c0030be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/0*5P_Yma_xvGkSnVfM.jpg"/></div></figure><p id="42fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">今天让我们做一些有趣的事情，模拟一个魔方。这是我下一个主题的前奏，提供解决魔方的方法。</p><h1 id="35f1" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">系统模型化</h1><p id="4f4a" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们可以有很多方法来模拟魔方模型作为一个类，但我在这里的目标是使它尽可能简单和易于理解。一个看起来更科学的方法是拥有三维数据，但这将涉及一些3D数学，可能会令人困惑，所以我不打算这样做。相反，我会把魔方分成6个面，然后平放。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/dca3d2127960fc2c60b7db35e7b4b0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/0*rWfse7WV7ZNqHg_F.png"/></div></figure><p id="fd93" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们声明了一个名为<code class="fe ma mb mc md b">RubikSide</code>的类来建模，用立方体的大小和每个位置的值来表示颜色。我们只是在做一个3x3的魔方，但是代码应该可以处理不同的大小。我们没有保存6种颜色，而是用数字1 - 6来表示颜色——红色、蓝色、橙色、绿色、白色和黄色。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/b2e5047947acb21a332fe9ed6a0f12c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GSbzjMgGotXbE5vV.png"/></div></div></figure><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="53cc" class="mn kt iq md b gy mo mp l mq mr">public class RubikSide implements Cloneable{<br/>    private final int size;<br/>    private int[][] values;</span><span id="8a15" class="mn kt iq md b gy ms mp l mq mr">    public RubikSide(int size, int value){<br/>        this.size = size;<br/>        int[] dimension = IntStream.generate(() -&gt; value).limit(size).toArray();<br/>        values = IntStream.range(0, size)<br/>                .boxed()<br/>                .map(i -&gt; dimension.clone())<br/>                .toArray(int[][]::new);<br/>    }<br/>}</span></pre><p id="9431" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每一边的值都存储在名为<code class="fe ma mb mc md b">values</code>的2D数组中。第一维是行，第二维是列。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/7937545a889830fc36410d6992e3f4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/0*Il19OLKXVJLlYmSM.png"/></div></figure><p id="776c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们将所有6个面组合在一起形成魔方时，我们定义了平放时的位置。这对我们后期的作品非常重要，尤其是上下翻柱的时候。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi gj"><img src="../Images/d44914dfa7de7afee9b1dc58591c3f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zkvtQ__x4gvSVp2w.png"/></div></div></figure><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="e8eb" class="mn kt iq md b gy mo mp l mq mr">public class RubikCube{<br/>    private RubikSide main;<br/>    private RubikSide right;<br/>    private RubikSide left;<br/>    private RubikSide back;<br/>    private RubikSide top;<br/>    private RubikSide bottom;<br/>    private int size;</span><span id="b65d" class="mn kt iq md b gy ms mp l mq mr">    public RubikCube(int size){<br/>        this.size = size;<br/>        main = new RubikSide(size, 1);<br/>        right = new RubikSide(size, 2);<br/>        back = new RubikSide(size, 3);<br/>        left = new RubikSide(size, 4);<br/>        top = new RubikSide(size, 5);<br/>        bottom = new RubikSide(size, 6);<br/>    }</span><span id="640d" class="mn kt iq md b gy ms mp l mq mr">}</span></pre><h1 id="97d3" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">基本功能</h1><p id="26ad" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">为了准备我们可以在魔方上执行的操作，我们应该创建一些方法来获取和设置每个<code class="fe ma mb mc md b">RubikSide</code>的行和列。获取行非常简单，获取列只需要一点点操作。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="a7a6" class="mn kt iq md b gy mo mp l mq mr">public int[] getRow(int row){<br/>    return values[row];<br/>}</span><span id="74de" class="mn kt iq md b gy ms mp l mq mr">public int[] getCol(int col){<br/>    return IntStream.range(0, size)<br/>            .map(i -&gt; values[i][col])<br/>            .toArray();<br/>}</span></pre><p id="8a66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">设置这些值几乎是一样的。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="6ed2" class="mn kt iq md b gy mo mp l mq mr">public void setRow(int row, int[] newValues){<br/>    values[row] = newValues;<br/>}</span><span id="a1b6" class="mn kt iq md b gy ms mp l mq mr">public void setCol(int col, int[] newValues){<br/>    IntStream.range(0, size).forEach(i -&gt; values[i][col] = newValues[i]);<br/>}</span></pre><h1 id="8e7d" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">行动</h1><p id="fb02" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">现在，我们已经准备好创建可以在魔方上执行的操作。我的简化策略是只针对可以在<code class="fe ma mb mc md b">main</code>端执行的动作。在不指定行和列的情况下，行和列应该是动态的，因为我们想要迎合不同的魔方大小(3x3、4x4、5x5)，我可以将一侧可用的所有操作总结如下:</p><ol class=""><li id="2554" class="mu mv iq jw b jx jy kb kc kf mw kj mx kn my kr mz na nb nc bi translated">向左拐行<code class="fe ma mb mc md b">X</code></li><li id="bbce" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">向右转动第<code class="fe ma mb mc md b">X</code>排</li><li id="d18d" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">将列“Y”向上转</li><li id="b675" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">向下转动“Y”列</li><li id="0b89" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">顺时针旋转<code class="fe ma mb mc md b">main</code>侧</li><li id="1035" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">逆时针旋转<code class="fe ma mb mc md b">main</code>侧。</li></ol><h1 id="1658" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">转弯行</h1><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ni"><img src="../Images/ba6107bfb2ca782ce5416444fb9f6c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p8haAT6sbQAMGpj1.png"/></div></div></figure><p id="e822" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">向左和向右旋转行是最简单的，我只需要重新分配每一边的值。例如，向左旋转一行只是用同一行在<code class="fe ma mb mc md b">right</code>侧的值重新分配在<code class="fe ma mb mc md b">main</code>侧的值。然后我们用同一行在<code class="fe ma mb mc md b">back</code>端的值替换<code class="fe ma mb mc md b">right</code>端的值。我们用<code class="fe ma mb mc md b">left</code>侧的行值替换<code class="fe ma mb mc md b">back</code>侧的行值。最后，在我们开始所有这些之前，我们应该有一个<code class="fe ma mb mc md b">main</code>侧的行值的副本，这样我们就可以用<code class="fe ma mb mc md b">main</code>侧的行值替换<code class="fe ma mb mc md b">left</code>侧的行值。但是，我们需要确保如果涉及到顶行或底行，我们需要旋转相应的顶边和底边。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="ff5d" class="mn kt iq md b gy mo mp l mq mr">public void turnRowToRight(int row) throws Exception{<br/>        int[] mainTopRow = getMain().getRow(row);<br/>        getMain().setRow(row, getLeft().getRow(row));<br/>        getLeft().setRow(row, getBack().getRow(row));<br/>        getBack().setRow(row, getRight().getRow(row));<br/>        getRight().setRow(row, mainTopRow);<br/>        if(row == 0){<br/>            getTop().rotateAntiClockwise();<br/>        }else if(row == (getSize() - 1)){<br/>            getBottom().rotateClockwise();<br/>        }<br/>    }</span><span id="ee09" class="mn kt iq md b gy ms mp l mq mr">    public void turnRowToLeft(int row) throws Exception{<br/>        int[] mainTopRow = getMain().getRow(row);<br/>        getMain().setRow(row, getRight().getRow(row));<br/>        getRight().setRow(row, getBack().getRow(row));<br/>        getBack().setRow(row, getLeft().getRow(row));<br/>        getLeft().setRow(row, mainTopRow);<br/>        if(row == 0){<br/>            getTop().rotateClockwise();<br/>        }else if(row == (getSize() - 1)){<br/>            getBottom().rotateAntiClockwise();<br/>        }<br/>    }</span></pre><p id="de3f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以现在，我们需要在<code class="fe ma mb mc md b">RubikSide</code>中创建旋转函数。顺时针旋转也可以这样想象。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nj"><img src="../Images/73181288a8b84c7e53bf418fe1320af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mCD82fKWfUUzkKH8.png"/></div></div></figure><p id="adff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从上图中可以看出，新行只是每列的反转，因此我们可以轻松地创建<code class="fe ma mb mc md b">rotateClockwise</code>函数。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="932e" class="mn kt iq md b gy mo mp l mq mr">public void rotateClockwise(){<br/>    values = IntStream.range(0, size)<br/>                      .boxed()<br/>                      .map(i -&gt; Utils.reverseArray(getCol(i)))<br/>                      .toArray(int[][]::new);<br/>}</span></pre><p id="977d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，我们将<code class="fe ma mb mc md b">reverseArray</code>函数重构为一个实用程序类，以确保符合<a class="ae nk" href="https://thecodinganalyst.github.io/software%20engineering/solid-principle/" rel="noopener ugc nofollow" target="_blank">坚实原则</a>。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="487c" class="mn kt iq md b gy mo mp l mq mr">public class Utils {<br/>    public static int[] reverseArray(int[] arr){<br/>        return IntStream.rangeClosed(1, arr.length)<br/>                        .map(i -&gt; arr[arr.length - i])<br/>                        .toArray();<br/>    }<br/>}</span></pre><p id="1365" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">逆时针旋转，我们的新<code class="fe ma mb mc md b">row 0</code>就是我们的<code class="fe ma mb mc md b">column n</code>，我们的<code class="fe ma mb mc md b">row n</code>就是我们的<code class="fe ma mb mc md b">column 0</code>，就像这样可以看到的。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nj"><img src="../Images/ab68c15d8c62864c248ba29f35ed4155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NnbbxzUG7FXW2_yB.png"/></div></div></figure><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="8d0f" class="mn kt iq md b gy mo mp l mq mr">public void rotateAntiClockwise(){<br/>        values = IntStream.rangeClosed(1, size)<br/>                            .boxed()<br/>                            .map(i -&gt; getCol(size - i))<br/>                            .toArray(int[][]::new);<br/>}</span></pre><h1 id="7f05" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">转向柱</h1><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nl"><img src="../Images/b892c8e9e1296468d5c7f9ead154fce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HhXJ1YR5mGMgDTJ1.png"/></div></div></figure><p id="79ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们希望将旋转行的相同逻辑应用于旋转列。同样，要向下翻转一列，我们首先在<code class="fe ma mb mc md b">main</code>端保存该列值的副本。然后我们用<code class="fe ma mb mc md b">top</code>侧的列值替换<code class="fe ma mb mc md b">main</code>侧的列值，用<code class="fe ma mb mc md b">back</code>侧的列值替换<code class="fe ma mb mc md b">top</code>侧的列值。继续，我们用<code class="fe ma mb mc md b">bottom</code>侧的<code class="fe ma mb mc md b">column</code>值替换<code class="fe ma mb mc md b">back</code>侧的列值，用之前保存的<code class="fe ma mb mc md b">main</code>侧的列值替换<code class="fe ma mb mc md b">bottom</code>侧的列值。如果是第一列或最后一列，我们需要旋转<code class="fe ma mb mc md b">left</code>和<code class="fe ma mb mc md b">right</code>侧的值。</p><p id="04bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，如果我们想使用这种方法，有一点棘手，因为<code class="fe ma mb mc md b">back</code>面的顶部现在是底部，而<code class="fe ma mb mc md b">back</code>面的左侧现在是右侧。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/66eac4042ac53702ff8739f791ab9f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/0*_tQS1SPXegizzgWr.png"/></div></figure><p id="5c4a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们需要翻转<code class="fe ma mb mc md b">back</code>面，然后才能对值进行简单的重新分配，所以我们提供了一个<code class="fe ma mb mc md b">reverse2dArray</code>函数。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="f300" class="mn kt iq md b gy mo mp l mq mr">public static int[][] reverse2dArray(int[][] arr){<br/>    int[][] interim =  IntStream.range(0, arr.length)<br/>                                .boxed()<br/>                                .map(i -&gt; reverseArray(arr[i]))<br/>                                .toArray(int[][]::new);</span><span id="5b66" class="mn kt iq md b gy ms mp l mq mr">    return IntStream.rangeClosed(1, interim.length)<br/>                    .boxed()<br/>                    .map(i -&gt; interim[interim.length - i])<br/>                    .toArray(int[][]::new);<br/>}</span></pre><p id="86bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们可以使用这个新函数将<code class="fe ma mb mc md b">back</code> face的值临时更改为我们需要的透视图，这样我们就可以进行简单的列重新分配。但是，我们需要在完成列赋值后立即将视角切换回来。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="6acd" class="mn kt iq md b gy mo mp l mq mr">public void turnColUp(int col) throws Exception{<br/>        int[] mainCol = getMain().getCol(col);<br/>        RubikSide reversedBack = getBack().cloneReversed();<br/>        getMain().setCol(col, getBottom().getCol(col));<br/>        getBottom().setCol(col, reversedBack.getCol(col));<br/>        reversedBack.setCol(col, getTop().getCol(col));<br/>        getTop().setCol(col, mainCol);<br/>        back = reversedBack.cloneReversed();<br/>        if(col == 0){<br/>            getLeft().rotateAntiClockwise();<br/>        }else if(col == (getSize() - 1)){<br/>            getRight().rotateClockwise();<br/>        }<br/>    }</span><span id="27ba" class="mn kt iq md b gy ms mp l mq mr">    public void turnColDown(int col) throws Exception{<br/>        int[] mainCol = getMain().getCol(col);<br/>        RubikSide reversedBack = getBack().cloneReversed();<br/>        getMain().setCol(col, getTop().getCol(col));<br/>        getTop().setCol(col, reversedBack.getCol(col));<br/>        reversedBack.setCol(col, getBottom().getCol(col));<br/>        getBottom().setCol(col, mainCol);<br/>        back = reversedBack.cloneReversed();<br/>        if(col == 0){<br/>            getLeft().rotateClockwise();<br/>        }else if(col == (getSize() - 1)){<br/>            getRight().rotateAntiClockwise();<br/>        }<br/>    }</span></pre><h1 id="6ed4" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">旋转<code class="fe ma mb mc md b">main</code>侧</h1><p id="8750" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">因为我们的目标是让事情简单明了，所以我们希望将所有操作都集中在<code class="fe ma mb mc md b">main</code>侧。旋转<code class="fe ma mb mc md b">main</code>侧与旋转<code class="fe ma mb mc md b">right</code>侧的第一柱相同。但是我们不想在另一边做手术，然而我们仍然需要提供所有可能的手术。因此，我的解决方案是不要有旋转动作，而是用<code class="fe ma mb mc md b">face</code>动作将其他边变成<code class="fe ma mb mc md b">main</code>边。</p><h1 id="1858" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">面部动作</h1><p id="60fb" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这应该是最简单的行动，只需更换两侧。而我们只需要提供5个这样的<code class="fe ma mb mc md b">face</code>动作——<code class="fe ma mb mc md b">face right</code>、<code class="fe ma mb mc md b">face back</code>、<code class="fe ma mb mc md b">face left</code>、<code class="fe ma mb mc md b">face top</code>、<code class="fe ma mb mc md b">face bottom</code>。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="0e92" class="mn kt iq md b gy mo mp l mq mr">public void face(FACE newFace){<br/>    Map&lt;FACE, RubikSide&gt; old = Map.of(<br/>            FACE.MAIN, getMain().clone(),<br/>            FACE.RIGHT, getRight().clone(),<br/>            FACE.BACK, getBack().clone(),<br/>            FACE.LEFT, getLeft().clone(),<br/>            FACE.TOP, getTop().clone(),<br/>            FACE.BOTTOM, getBottom().clone()<br/>    );<br/>    main = getFace(newFace);<br/>    right = old.get(getRightFaceOf(newFace));<br/>    back = old.get(getBackFaceOf(newFace));<br/>    left = old.get(getLeftFaceOf(newFace));<br/>    top = old.get(getTopFaceOf(newFace));<br/>    bottom = old.get(getBottomFaceOf(newFace));<br/>}</span><span id="4d7f" class="mn kt iq md b gy ms mp l mq mr">public static FACE getBackFaceOf(FACE face){<br/>    if(face == FACE.MAIN) return FACE.BACK;<br/>    if(face == FACE.RIGHT) return FACE.LEFT;<br/>    if(face == FACE.BACK) return FACE.MAIN;<br/>    if(face == FACE.LEFT) return FACE.RIGHT;<br/>    if(face == FACE.TOP) return FACE.BOTTOM;<br/>    return FACE.TOP;<br/>}</span><span id="9613" class="mn kt iq md b gy ms mp l mq mr">public static FACE getRightFaceOf(FACE face){<br/>    if(face == FACE.MAIN) return FACE.RIGHT;<br/>    if(face == FACE.RIGHT) return FACE.BACK;<br/>    if(face == FACE.BACK) return FACE.LEFT;<br/>    if(face == FACE.LEFT) return FACE.MAIN;<br/>    return FACE.RIGHT;<br/>}</span><span id="9006" class="mn kt iq md b gy ms mp l mq mr">public static FACE getLeftFaceOf(FACE face){<br/>    if(face == FACE.MAIN) return FACE.LEFT;<br/>    if(face == FACE.RIGHT) return FACE.MAIN;<br/>    if(face == FACE.BACK) return FACE.RIGHT;<br/>    if(face == FACE.LEFT) return FACE.BACK;<br/>    return FACE.LEFT;<br/>}</span><span id="d952" class="mn kt iq md b gy ms mp l mq mr">public static FACE getTopFaceOf(FACE face){<br/>    if(face == FACE.TOP) return FACE.BACK;<br/>    if(face == FACE.BOTTOM) return FACE.MAIN;<br/>    return FACE.TOP;<br/>}</span><span id="ea3d" class="mn kt iq md b gy ms mp l mq mr">public static FACE getBottomFaceOf(FACE face){<br/>    if(face == FACE.TOP) return FACE.MAIN;<br/>    if(face == FACE.BOTTOM) return FACE.BACK;<br/>    return FACE.BOTTOM;<br/>}</span></pre><h1 id="51ac" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">定义和执行操作</h1><p id="35ea" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">既然建模魔方的动机是为了解决它，我们需要一种方法来轻松地调用任何动作。一个简单的方法是将所有可能的动作放在一个列表中，这样每个动作都被分配了一个编号。但是由于我们的魔方大小是动态的，所以可能的动作数量也是动态的，这取决于行数和列数。</p><p id="8c4d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们有两种不同类型的动作— <code class="fe ma mb mc md b">Turn</code>和<code class="fe ma mb mc md b">Face</code>。但它们都是动作，所以我们把它们概括为一个接口——<code class="fe ma mb mc md b">RubikCubeAction</code>。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="8f83" class="mn kt iq md b gy mo mp l mq mr">public interface RubikCubeAction {<br/>    String getName();<br/>    void performAction(RubikCube rubikCube);<br/>    RubikCubeAction oppositeAction();<br/>}</span></pre><p id="8f8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们提供了三个功能:<code class="fe ma mb mc md b">getName</code>、<code class="fe ma mb mc md b">performAction</code>和<code class="fe ma mb mc md b">oppositeAction</code>。<code class="fe ma mb mc md b">getName</code>应该打印动作的名称，这样我们可以直观地看到发生了什么。<code class="fe ma mb mc md b">performAction</code>利用一个<a class="ae nk" href="https://refactoring.guru/design-patterns/strategy" rel="noopener ugc nofollow" target="_blank">策略模式</a>用相同的方法调用不同的动作，而没有一长串if-else或switch语句。最后，为了确保我们的动作正确地更新了值，我们想要运行一个完整的动作列表，然后运行每个动作的相反动作的反向列表，它应该会返回给我们完美的魔方。所以我们需要每个动作都有一个相反的动作。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nn"><img src="../Images/fa6677c71fafc57d6d6e0cba68762828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J1fF2K5keCU2uA6h.png"/></div></div></figure><p id="32e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们有一个<code class="fe ma mb mc md b">FaceAction</code>和一个<code class="fe ma mb mc md b">TurnAction</code>，它们实现了<code class="fe ma mb mc md b">RubikCubeAction</code>。这两个动作中的每一个都有助于为多维数据集提供所有可能的动作。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="d040" class="mn kt iq md b gy mo mp l mq mr">public class FaceAction implements RubikCubeAction{</span><span id="66f8" class="mn kt iq md b gy ms mp l mq mr">    private final RubikCube.FACE face;</span><span id="9f2a" class="mn kt iq md b gy ms mp l mq mr">    private FaceAction(RubikCube.FACE face){<br/>        this.face = face;<br/>    }</span><span id="b612" class="mn kt iq md b gy ms mp l mq mr">    public static FaceAction[] allActions(){<br/>        return Arrays.stream(RubikCube.FACE.values())<br/>                .filter(face -&gt; face != RubikCube.FACE.MAIN)<br/>                .map(FaceAction::new)<br/>                .toArray(FaceAction[]::new);<br/>    }</span><span id="1159" class="mn kt iq md b gy ms mp l mq mr">    @Override<br/>    public void performAction(RubikCube rubikCube){<br/>        rubikCube.face(face);<br/>    }</span><span id="d931" class="mn kt iq md b gy ms mp l mq mr">    ...<br/>}</span><span id="96b6" class="mn kt iq md b gy ms mp l mq mr">public class TurnAction implements RubikCubeAction{</span><span id="0c1e" class="mn kt iq md b gy ms mp l mq mr">    public enum DIRECTION { LEFT, RIGHT, UP, DOWN}<br/>    public enum TURN_TYPE { ROW, COL }<br/>    public int turnPosition;<br/>    public DIRECTION direction;<br/>    public TURN_TYPE turnType;</span><span id="d009" class="mn kt iq md b gy ms mp l mq mr">    private TurnAction(TURN_TYPE turnType, DIRECTION direction, int turnPosition){<br/>        this.turnType = turnType;<br/>        this.direction = direction;<br/>        this.turnPosition = turnPosition;<br/>    }</span><span id="4653" class="mn kt iq md b gy ms mp l mq mr">    public static TurnAction[] allActions(int size){<br/>        return IntStream.range(0, size)<br/>                        .boxed()<br/>                        .flatMap(i -&gt; Stream.of(<br/>                            new TurnAction(TURN_TYPE.ROW, DIRECTION.LEFT, i),<br/>                            new TurnAction(TURN_TYPE.ROW, DIRECTION.RIGHT, i),<br/>                            new TurnAction(TURN_TYPE.COL, DIRECTION.UP, i),<br/>                            new TurnAction(TURN_TYPE.COL, DIRECTION.DOWN, i)<br/>                        ))<br/>                        .toArray(TurnAction[]::new);<br/>    }</span><span id="e5c6" class="mn kt iq md b gy ms mp l mq mr">    @Override<br/>    public void performAction(RubikCube rubikCube){<br/>        try {<br/>            if(turnType == TURN_TYPE.COL){<br/>                if(direction == DIRECTION.UP) rubikCube.turnColUp(turnPosition);<br/>                if(direction == DIRECTION.DOWN) rubikCube.turnColDown(turnPosition);<br/>            }else if(turnType == TURN_TYPE.ROW){<br/>                if(direction == DIRECTION.LEFT) rubikCube.turnRowToLeft(turnPosition);<br/>                if(direction == DIRECTION.RIGHT) rubikCube.turnRowToRight(turnPosition);<br/>            }<br/>        }catch (Exception e){<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>    ...<br/>}</span></pre><p id="9c72" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于策略模式，我们只需要从<code class="fe ma mb mc md b">RubikCubeAction</code>接口进行简单的调用来执行<code class="fe ma mb mc md b">RubikCube</code>中的动作。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="6548" class="mn kt iq md b gy mo mp l mq mr">public void performAction(RubikCubeAction action) {<br/>    action.performAction(this);<br/>}</span></pre><p id="71a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们可以在<code class="fe ma mb mc md b">RubikCube</code>的构造函数中定义所有可能的动作。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="7c8f" class="mn kt iq md b gy mo mp l mq mr">private RubikCubeAction[] allActions;</span><span id="b7c8" class="mn kt iq md b gy ms mp l mq mr">public RubikCube(int size){<br/>        this.size = size;<br/>        main = new RubikSide(size, 1);<br/>        right = new RubikSide(size, 2);<br/>        back = new RubikSide(size, 3);<br/>        left = new RubikSide(size, 4);<br/>        top = new RubikSide(size, 5);<br/>        bottom = new RubikSide(size, 6);<br/>        allActions = Stream.concat(<br/>                        Stream.of(FaceAction.allActions()),<br/>                        Stream.of(TurnAction.allActions(size)))<br/>                    .toArray(RubikCubeAction[]::new);<br/>    }<br/>}</span></pre><h1 id="0e57" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">核查</h1><h1 id="e396" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">检验反向行动列表假设</h1><p id="5edb" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">为了确保我们到目前为止所做的是正确的，我们创建了一个<code class="fe ma mb mc md b">RubikSolution</code>来初始化一个3x3的魔方，并执行一系列随机动作，以及打印出魔方每边的值。然后，我们运行所执行的动作的反向列表，并再次打印立方体。我们应该得到一个完美的立方体。</p><h1 id="846a" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">打印</h1><p id="2c14" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">为了更容易地可视化操作的结果，让我们提供一个打印方法。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="1410" class="mn kt iq md b gy mo mp l mq mr">public void print(){<br/>    String[] box = join(RubikSide.getEmptyString(getSize()), getTop().getString());<br/>    Arrays.stream(box).forEach(System.out::println);</span><span id="fd25" class="mn kt iq md b gy ms mp l mq mr">    box = join(getLeft().getString(), getMain().getString(), getRight().getString(), getBack().getString());<br/>    Arrays.stream(box).forEach(System.out::println);</span><span id="35d8" class="mn kt iq md b gy ms mp l mq mr">    box = join(RubikSide.getEmptyString(getSize()), getBottom().getString());<br/>    Arrays.stream(box).forEach(System.out::println);</span><span id="5b2b" class="mn kt iq md b gy ms mp l mq mr">    System.out.println(" ");<br/>}</span></pre><h1 id="bb22" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">随机动作</h1><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="8f44" class="mn kt iq md b gy mo mp l mq mr">public List&lt;RubikCubeAction&gt; randomActions(RubikCube rubikCube, int count){<br/>    Random random = new Random();<br/>    int actionCount = rubikCube.getAllActions().length;<br/>    return IntStream.range(0, count).boxed().map(i -&gt; {<br/>      RubikCubeAction action = rubikCube.getAllActions()[random.nextInt(actionCount)];<br/>      rubikCube.performAction(action);<br/>      return action;<br/>    }).toList();<br/>}</span></pre><h1 id="99de" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">反向操作</h1><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="4a87" class="mn kt iq md b gy mo mp l mq mr">public List&lt;RubikCubeAction&gt; reverseActions(List&lt;RubikCubeAction&gt; originalActions){<br/>    return IntStream.rangeClosed(1, originalActions.size())<br/>                .boxed()<br/>                .map(i -&gt; originalActions.get(originalActions.size() - i))<br/>                .map(RubikCubeAction::oppositeAction)<br/>                .toList();<br/>}</span></pre><h1 id="01c7" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">运行假设</h1><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="2e24" class="mn kt iq md b gy mo mp l mq mr">public static void main(String[] args) {<br/>    RubikCube cube = new RubikCube(3);<br/>    RubikSolution solution = new RubikSolution();<br/>    List&lt;RubikCubeAction&gt; randomActions = solution.randomActions(cube, 20);<br/>    randomActions.forEach(action -&gt; System.out.println(action.getName()));<br/>    cube.print();<br/>    System.out.println(cube.check());</span><span id="f0a2" class="mn kt iq md b gy ms mp l mq mr">    List&lt;RubikCubeAction&gt; reverseActions = solution.reverseActions(randomActions);<br/>    reverseActions.forEach(action -&gt; System.out.println(action.getName()));<br/>    reverseActions.forEach(cube::performAction);<br/>    cube.print();<br/>    System.out.println(cube.check());<br/>}</span></pre><p id="67a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们有一个行动列表</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="de5e" class="mn kt iq md b gy mo mp l mq mr">TURN_ROW_0_RIGHT<br/>TURN_ROW_1_LEFT<br/>FACE_RIGHT<br/>TURN_COL_2_DOWN<br/>FACE_TOP<br/>FACE_LEFT<br/>TURN_COL_1_UP<br/>TURN_ROW_0_LEFT<br/>TURN_COL_2_UP<br/>FACE_LEFT<br/>FACE_TOP<br/>TURN_ROW_1_LEFT<br/>TURN_COL_1_DOWN<br/>TURN_COL_2_DOWN<br/>TURN_ROW_0_LEFT<br/>FACE_BACK<br/>TURN_COL_2_DOWN<br/>TURN_ROW_0_RIGHT<br/>TURN_COL_2_DOWN<br/>FACE_RIGHT</span></pre><p id="ceee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并打印出魔方。</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="7ae2" class="mn kt iq md b gy mo mp l mq mr">          [4, 2, 4]<br/>          [5, 1, 5]<br/>          [3, 4, 2]<br/>[2, 6, 5] [5, 3, 6] [6, 2, 3] [1, 2, 5]<br/>[3, 6, 4] [6, 2, 1] [3, 5, 4] [5, 4, 2]<br/>[4, 1, 1] [3, 5, 6] [1, 1, 3] [5, 3, 1]<br/>          [4, 6, 2]<br/>          [6, 3, 4]<br/>          [6, 1, 2]</span></pre><p id="f310" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们得到了相反的行动列表</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="f486" class="mn kt iq md b gy mo mp l mq mr">FACE_LEFT<br/>TURN_COL_2_UP<br/>TURN_ROW_0_LEFT<br/>TURN_COL_2_UP<br/>FACE_BACK<br/>TURN_ROW_0_RIGHT<br/>TURN_COL_2_UP<br/>TURN_COL_1_UP<br/>TURN_ROW_1_RIGHT<br/>FACE_BOTTOM<br/>FACE_RIGHT<br/>TURN_COL_2_DOWN<br/>TURN_ROW_0_RIGHT<br/>TURN_COL_1_DOWN<br/>FACE_RIGHT<br/>FACE_BOTTOM<br/>TURN_COL_2_UP<br/>FACE_LEFT<br/>TURN_ROW_1_RIGHT<br/>TURN_ROW_0_LEFT</span></pre><p id="0131" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们拿回了完美的魔方！</p><pre class="lw lx ly lz gt mj md mk ml aw mm bi"><span id="395a" class="mn kt iq md b gy mo mp l mq mr">          [5, 5, 5]<br/>          [5, 5, 5]<br/>          [5, 5, 5]<br/>[4, 4, 4] [1, 1, 1] [2, 2, 2] [3, 3, 3]<br/>[4, 4, 4] [1, 1, 1] [2, 2, 2] [3, 3, 3]<br/>[4, 4, 4] [1, 1, 1] [2, 2, 2] [3, 3, 3]<br/>          [6, 6, 6]<br/>          [6, 6, 6]<br/>          [6, 6, 6]</span></pre><p id="b42e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该主题的代码可在<a class="ae nk" href="https://github.com/thecodinganalyst/RubiksCube" rel="noopener ugc nofollow" target="_blank">https://github.com/thecodinganalyst/RubiksCube</a>获得。</p><p id="142c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="no">本文原载于</em><a class="ae nk" href="https://thecodinganalyst.github.io/fun/Simulating-Rubik-Cube-Actions-with-Java/" rel="noopener ugc nofollow" target="_blank"><em class="no">https://the coding analyst . github . io/fun/Simulating-Rubik-Cube-Actions-with-Java/</em></a></p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="d633" class="ks kt iq bd ku kv nw kx ky kz nx lb lc ld ny lf lg lh nz lj lk ll oa ln lo lp bi translated">分级编码</h1><p id="a425" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae nk" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae nk" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae nk" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae nk" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="jw ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae nk" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>