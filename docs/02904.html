<html>
<head>
<title>Asynchronous Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的异步编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-programming-in-javascript-9fff87cb7df1?source=collection_archive---------17-----------------------#2020-04-09">https://levelup.gitconnected.com/asynchronous-programming-in-javascript-9fff87cb7df1?source=collection_archive---------17-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c6f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">异步/等待的最佳用途</h2></div><blockquote class="ki"><p id="e00a" class="kj kk it bd kl km kn ko kp kq kr ks dk translated">学习一门新的编程语言的唯一方法是用它写程序——丹尼斯·里奇</p></blockquote><p id="d214" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln ks im bi translated">计算机编程中的异步是指独立于主程序流的事件的发生以及处理这些事件的方式。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/a10d1daa93dbe2572a4f54919d00cf83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOKTlxsKqHVkEZizgD8n7A.jpeg"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">图片由<a class="ae me" href="https://unsplash.com/@nathananderson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">内森·安德森</a>在<a class="ae me" href="https://unsplash.com/s/photos/parallel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ada8" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">与编程语言Java/C#不同，JavaScript是单线程的，所有代码都是按顺序逐行执行的，而不是并行执行的。通常，我们希望事件的发生独立于主程序流。这可以在JavaScript中使用回调、承诺、异步/等待来实现。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="9e19" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">Async/await是一种编写异步代码的新方法，异步代码的其他替代方法是回调或承诺。</p><blockquote class="mr ms mt"><p id="8e01" class="kt ku mu kv b kw mf ju ky kz mg jx lb mv mh le lf mw mi li lj mx mj lm ln ks im bi translated"><em class="it"> Async/await使异步代码看起来和行为都不像同步代码。</em></p></blockquote><p id="eba8" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">在这篇文章中，我将尝试解决</p><ol class=""><li id="11e9" class="my mz it kv b kw mf kz mg lc na lg nb lk nc ks nd ne nf ng bi translated">什么是异步/等待</li><li id="74b9" class="my mz it kv b kw nh kz ni lc nj lg nk lk nl ks nd ne nf ng bi translated">异步/等待工作</li><li id="7b78" class="my mz it kv b kw nh kz ni lc nj lg nk lk nl ks nd ne nf ng bi translated">承诺并发</li><li id="4e2c" class="my mz it kv b kw nh kz ni lc nj lg nk lk nl ks nd ne nf ng bi translated">异步并行执行</li></ol><h1 id="3486" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">异步ˌ非同步(asynchronous)</h1><p id="c741" class="pw-post-body-paragraph kt ku it kv b kw oe ju ky kz of jx lb lc og le lf lg oh li lj lk oi lm ln ks im bi translated">异步函数声明定义了一个异步函数，一个返回对象的函数。这些函数使我们能够编写基于承诺的代码，而不会阻塞执行线程。它们通过事件循环以不同于其余代码的顺序运行，返回一个承诺作为结果。</p><pre class="lp lq lr ls gt oj ok ol om aw on bi"><span id="1d35" class="oo nn it ok b gy op oq l or os">async function GetText() {<br/> return ”Hello”;<br/> }<br/> <br/> GetText().then(alert); // Hello</span></pre><p id="60a9" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">如果你观察到上面运行的GetText()返回一个promise并使用then调用。</p><h1 id="0714" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">等待</h1><p id="9a2c" class="pw-post-body-paragraph kt ku it kv b kw oe ju ky kz of jx lb lc og le lf lg oh li lj lk oi lm ln ks im bi translated">异步函数可以包含await表达式，await会暂停异步执行，直到相关的承诺被解析。Await使异步块等待，但不是整个执行块。Await只能在异步函数中使用。</p><pre class="lp lq lr ls gt oj ok ol om aw on bi"><span id="8cd0" class="oo nn it ok b gy op oq l or os">function getData() {<br/>   return new Promise(resolve =&gt; {setTimeout(() =&gt;     {resolve(‘resolved’);}, 2000);});}</span><span id="58ac" class="oo nn it ok b gy ot oq l or os">async function asyncGet() {console.log(‘calling’);<br/>const result = await getData();<br/>console.log(result);// expected output: ‘resolved’}</span><span id="5dd3" class="oo nn it ok b gy ot oq l or os">asyncGet();</span></pre><p id="eb11" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">通过运行上面的代码，我们可以观察到异步函数代码因为await关键字而暂停了2秒钟。一旦getData()承诺得到解决，我们就可以在异步函数中看到期望的输出。</p><p id="c3d5" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">我们太担心语法和它的酷了。让我们更深入地研究示例，并开始使用async/wait。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7414" class="nm nn it bd no np ou nr ns nt ov nv nw jz ow ka ny kc ox kd oa kf oy kg oc od bi translated">异步/等待工作</h1><p id="01e5" class="pw-post-body-paragraph kt ku it kv b kw oe ju ky kz of jx lb lc og le lf lg oh li lj lk oi lm ln ks im bi translated">在整篇文章中，我们将使用一个制作午餐的指令示例来了解async/await如何简化一系列异步操作。这是做午餐的说明清单。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oz"><img src="../Images/3a041066f1a04dc8ac9320bc4af37abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wi2OnJ1bQNs7Xx3HnwtZVA.jpeg"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">图片由<a class="ae me" href="https://unsplash.com/s/photos/lunch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae me" href="https://unsplash.com/@foodiesfeed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雅各布·卡普斯纳克</a>拍摄</figcaption></figure><p id="4a41" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">1.倒辣花生汤。</p><p id="2d69" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">2.准备蔬菜沙拉。</p><p id="a1ff" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">3.准备炒鸡蛋。</p><p id="9468" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">4.炸汉堡小面包。</p><p id="ac8b" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">5.在汉堡中加入蔬菜。</p><p id="9758" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">6.倒一杯柠檬汁。</p><p id="6d82" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">如果您有做午餐的经验，您可以异步执行这些指令。烹饪午餐是一个很好的非并行异步工作的例子。一个人(或线程)可以处理所有这些任务。在午餐类比中，一个人可以通过在第一个任务完成之前开始下一个任务来异步制作午餐。不管有没有人看，烹饪都会进行下去。一旦你开始切蔬菜做沙拉，你就可以做炒鸡蛋了。一旦开始争抢，你就可以在锅上煎馒头了。</p><p id="f475" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">让我们用JavaScript写所有的指令。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">顺序</figcaption></figure><p id="9ee7" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">JavaScript解释这些指令的方式与人们不同。JavaScript将在每条语句上阻塞，直到工作完成，然后继续下一条语句。这就造成了一顿不令人满意的午餐。在前面的任务完成之前，后面的任务不会开始。做午餐要花更长的时间，而且一些食物在端上来之前就已经凉了。</p><p id="3368" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">如果您想异步执行这些指令，应该编写异步代码。</p><p id="3e46" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">前面的代码演示了一个不好的做法:构造同步代码来执行异步操作。如前所述，这段代码阻止执行它的线程做任何其他工作。让我们从更新这段代码开始，这样线程就不会在任务运行时阻塞。await关键字提供了一种非阻塞方式来启动任务，然后在任务完成时继续执行。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">异步的</figcaption></figure><p id="3415" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">当沙拉或炒鸡蛋正在烹饪时，上面的代码不会阻塞。但是这段代码不会启动任何其他任务。你还是会在锅里煎小面包，然后盯着它直到它被煎熟。但至少，你会回应任何想引起你注意的人。现在，处理午餐的线程在等待任何尚未完成的已启动任务时不会被阻塞。</p><h1 id="8160" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">承诺并发</h1><p id="0cdd" class="pw-post-body-paragraph kt ku it kv b kw oe ju ky kz of jx lb lc og le lf lg oh li lj lk oi lm ln ks im bi translated">在许多情况下，您希望立即开始几个独立的任务。然后，随着每项任务的完成，你可以继续其他准备好的工作。承诺使您能够编写更类似于创建午餐的代码。你会开始做沙拉，炒鸡蛋，同时煎小面包。因为每一个都需要行动，你会把注意力转移到那个任务上，关注下一个行动，然后等待其他需要你注意的事情。</p><p id="245a" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">你可以为每项任务创建一个承诺，然后等待每项任务的结果。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">并发</figcaption></figure><p id="03e9" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">如果您观察上面的代码，您可以立即启动所有异步任务，并且仅在需要结果时才等待每个任务。这就像构建一个web应用程序的代码发出几个web APIs的请求，然后将结果组合成一个结果。</p><p id="d169" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">这段代码是异步的，就像一个人做午餐一样。</p><h1 id="46c8" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">异步并行执行</h1><p id="67d8" class="pw-post-body-paragraph kt ku it kv b kw oe ju ky kz of jx lb lc og le lf lg oh li lj lk oi lm ln ks im bi translated">Async await使执行顺序化，但是使用Promise.all并行执行可以使执行速度更快。</p><p id="8aed" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">在上面的例子中，我们可以看到，准备沙拉、炒鸡蛋和面包是相互独立的，可以并行执行。</p><h2 id="46eb" class="oo nn it bd no pc pd dn ns pe pf dp nw lc pg ph ny lg pi pj oa lk pk pl oc pm bi translated">通常的方法</h2><pre class="lp lq lr ls gt oj ok ol om aw on bi"><span id="1c7a" class="oo nn it ok b gy op oq l or os">async function do() {<br/> await saladPromise; // Wait 50ms<br/> await sEggPromise; // then wait another 50ms.</span><span id="b12d" class="oo nn it ok b gy ot oq l or os">await burgerPromise; // wait for 50ms<br/> return “done!”;<br/> }</span></pre><p id="1cdf" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">上面的代码需要150毫秒的时间，对于一个构建良好的web应用程序来说，这是一段很长的时间。这是因为所有的承诺都是按顺序一个接一个执行的，只有先承诺后兑现。这不是一个好的做法，而且费时。</p><p id="881b" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">我们可以使用Promise.all()来克服上述挑战。</p><h2 id="ee48" class="oo nn it bd no pc pd dn ns pe pf dp nw lc pg ph ny lg pi pj oa lk pk pl oc pm bi translated">使用Promise.all</h2><p id="d660" class="pw-post-body-paragraph kt ku it kv b kw oe ju ky kz of jx lb lc og le lf lg oh li lj lk oi lm ln ks im bi translated"><strong class="kv iu"> Promise.all() </strong>方法返回单个承诺，当作为可迭代对象传递的所有承诺都已解析时，或者当可迭代对象不包含承诺时，该承诺将被解析。它以拒绝的第一个承诺的理由拒绝。</p><h1 id="1c91" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">包扎</h1><p id="2c9b" class="pw-post-body-paragraph kt ku it kv b kw oe ju ky kz of jx lb lc og le lf lg oh li lj lk oi lm ln ks im bi translated">Async/Await是JavaScript引入的新特性，可以像编写同步代码一样简单地编写异步代码。它还提供了以并行和并发方式执行功能的可行性。当您从web API检索数据或加载任何图像或任何异步用例时，您可以开始实现这个特性。</p><p id="4392" class="pw-post-body-paragraph kt ku it kv b kw mf ju ky kz mg jx lb lc mh le lf lg mi li lj lk mj lm ln ks im bi translated">到目前为止，我们看到了更多关于Async/Await的内容，并且对其进行了总结。请仔细阅读下面的文章，对承诺有一个清晰的了解。</p><div class="pn po gp gr pp pq"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-promises-are-an-ideal-solution-for-asynchronous-programming-e9e530ce4f8c"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">JavaScript承诺:异步编程的理想解决方案</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">保证！！！这都是关于承诺</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe ly pq"/></div></div></a></div><blockquote class="ki"><p id="05a3" class="kj kk it bd kl km kn ko kp kq kr ks dk translated">希望你喜欢它！！！请对任何疑问或建议发表评论！！！！</p></blockquote></div></div>    
</body>
</html>