<html>
<head>
<title>2 Simple Tips for Developers to Write Reusable Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发人员编写可重用代码的两个简单技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-design-reusable-software-components-213e05119796?source=collection_archive---------1-----------------------#2021-02-04">https://levelup.gitconnected.com/how-to-design-reusable-software-components-213e05119796?source=collection_archive---------1-----------------------#2021-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f87d8a23df7a2e35d1cfac3c29227e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h93c8q60oSgR5YVz"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">奥斯卡·伊尔迪兹在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4a16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码重用是一件很棒的事情，因为开发人员不必从头开始实现项目中的每个新特性。新的功能可以建立在系统中已经存在的组件之上，例如方法、类、库或整个微服务。</p><p id="f170" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码重用加快了开发时间。此外，当新功能建立在现有组件之上时，开发人员会感到有信心，因为组件很可能被单元测试所覆盖，甚至可能是产品代码的一部分。这意味着现有代码已经过很好的测试。</p><p id="de9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，即使在大型软件系统中，也很难找到可重用的组件，因为这些组件没有被设计为在新的上下文中重用。</p><p id="90b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可复用的软件组件和不可复用的软件组件有什么不同？一个可复用的软件组件遵循<strong class="ki iu">单一责任原则</strong>，并且<strong class="ki iu">松散耦合</strong>到它的依赖项，而一个不可复用的组件违反其中一个或者两个。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a5d9" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">单一责任原则</h1><p id="9abc" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">无法重用软件组件的第一个原因是违反了单一责任原则。每个组件，不管其级别(方法、类等。)，必须有单一的改变理由。组件的行为应该用一个不包含连词“和”或“或”的句子来描述。</p><p id="8fa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看为什么违反单一责任原则会扼杀代码重用，在这个简单的例子中:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="480f" class="mx lm it mt b gy my mz l na nb">public class FileParser<br/>{<br/>   public bool Parse(FileInfo file)<br/>   {<br/>      if(file.Extension != ".txt")<br/>      {<br/>         return false;<br/>      }</span><span id="42d3" class="mx lm it mt b gy nc mz l na nb">      var parseResult = Parse(file);    <br/>      <br/>      return true;<br/>   }<br/>   <br/>   //TODO: parsing logic here<br/>}</span></pre><p id="a220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个类违反了单一责任原则，因为它有两个改变的原因。第一个原因是需要更改验证逻辑，第二个原因是需要更改解析文件的逻辑。</p><p id="ed00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发人员将不能在新的上下文中只重用验证逻辑，因为SRP violator类的所有职责必须一起重用。</p><p id="3d65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当需要重用属于同一类的几个职责中的一个时，开发人员有什么选择？实际上有三个:</p><ol class=""><li id="6b84" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld ni nj nk nl bi translated">开发人员可以将验证逻辑复制并粘贴到新位置。</li><li id="bf13" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">开发人员可以实现一个布尔标志，并在外部设置它来启用或禁用验证逻辑。</li><li id="439c" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">验证逻辑的责任应该提取到一个单独的类中。</li></ol><p id="8df6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个和第二个选项只会降低应用程序的可维护性。第三个是每个开发者都应该努力避免在项目中出现技术债务。</p><p id="1534" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些情况下，违反单一责任原则的类仍然可以在新的上下文中重用，而无需对其进行任何更改。当新的上下文需要类中包含的所有职责时，这是可能的。然而，这可能是偶然发生的，而不是故意的。</p><p id="87cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让组件有一个改变的理由是迈向代码重用的第一大步。然而，为了拥有可重用的组件，还有第二个重要的原则要遵循。这被称为松耦合。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="1a4b" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">松耦合</h1><p id="c1d1" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">该类通常具有注入类构造函数或通过静态属性访问的依赖项。这个类应该有依赖关系，因为它不需要自己完成所有的工作。否则，将违反单一责任原则。</p><p id="4cd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当要使一个类依赖于另一个类时，有紧耦合和松耦合两种选择。紧密耦合意味着类之间的关系是在编译时定义的，在运行时无法打破这种关系。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8fb6" class="mx lm it mt b gy my mz l na nb">public class ReportGenerator<br/>{<br/>   public Report Generate()<br/>   {<br/>      var data = HttpClient.GetData("http://projectapi.com/data/");<br/>      <br/>      return GenerateReport(data);<br/>   }</span><span id="6a2c" class="mx lm it mt b gy nc mz l na nb">   //TODO: report generation logic here<br/>}</span></pre><p id="4c1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nr">report generator类与其依赖项HttpClient类密切相关。</em></p><p id="360f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与其依赖关系密切的类通常不能被重用，因为新的上下文可能不知道如何处理它。</p><p id="6ab4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，新的上下文可能想要提供自己的数据来从数据库生成报告，而不是通过API接收它。但是紧密耦合迫使客户端重用他们不需要的HttpClient。因此，他们不会重用报告生成逻辑。</p><p id="4ed6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ReportGenerator必须从数据源中抽象出来。一种方法是将ReportGenerator类重构为类似如下的形式:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="194a" class="mx lm it mt b gy my mz l na nb">public class ReportGenerator<br/>{<br/>    private readonly IReportDataProvider _reportDataProvider;</span><span id="e5a9" class="mx lm it mt b gy nc mz l na nb">    public ReportGenerator(IReportDataProvider reportDataProvider)<br/>    {<br/>        _reportDataProvider = reportDataProvider;<br/>    }</span><span id="9cc3" class="mx lm it mt b gy nc mz l na nb">    public Report Generate()<br/>    {<br/>        var data = _reportDataProvider.GetData();</span><span id="8193" class="mx lm it mt b gy nc mz l na nb">        return GenerateReport(data);<br/>    }<br/>    <br/>    //TODO: report generation logic here<br/>}</span></pre><p id="1780" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HttpClient类必须封装在IReportDataProvider接口的实现中。需要重用ReportGenerator类的客户端只需提供自己的IReportDataProvider接口实现，该接口可以封装从数据库或任何其他来源获取的数据。</p><p id="ce0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">松散耦合通常通过使用依赖注入技术和接口来实现，但是还有其他设计模式需要考虑，比如中介、环境上下文等。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="1d75" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="e84a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当开发可重用代码或重构不可重用代码时，开发人员不应该重新发明轮子。面向对象设计中有相当多的<strong class="ki iu">设计模式</strong>(装饰者、代理、责任链、门面……)和<strong class="ki iu">设计原则</strong>(控制反转、依赖反转……)教导开发人员即使在最复杂的场景中也要将这些基本原则应用于软件组件。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="d306" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">关于可维护性的更多信息</h1><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jz nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://medium.com/codex/when-code-quality-metrics-can-be-of-real-value-to-software-engineers-7fc2de96afc4" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">充分利用代码质量度量</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在软件工程中充分利用圈复杂度、可维护性指数、单元测试覆盖率和其他度量</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj jz nv"/></div></div></a></div></div></div>    
</body>
</html>