<html>
<head>
<title>How to write a circuit breaker in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Golang写一个断路器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-a-circuit-breaker-in-golang-9ebd5644738c?source=collection_archive---------3-----------------------#2022-09-12">https://levelup.gitconnected.com/how-to-write-a-circuit-breaker-in-golang-9ebd5644738c?source=collection_archive---------3-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c342" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我想谈谈基于一个流行的开源项目<code class="fe kl km kn ko b">hystrix</code>的<code class="fe kl km kn ko b">circuit breaker</code>模式(实际上，我会看一下golang版本<a class="ae kp" href="https://github.com/afex/hystrix-go" rel="noopener ugc nofollow" target="_blank"> hystrix-go </a>，而不是用Java编写的<a class="ae kp" href="https://github.com/Netflix/Hystrix" rel="noopener ugc nofollow" target="_blank">原始版本</a>)。</p><p id="e6ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文的第一部分，我将对<code class="fe kl km kn ko b">circuit breaker</code>做一个大概的介绍，让你知道它是什么，为什么它很重要。此外，让我们回顾一下关于项目<code class="fe kl km kn ko b">hystrix-go</code>和<code class="fe kl km kn ko b">hystrix</code>的背景，并通过一个小演示示例了解基本用法。</p><h1 id="788f" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">断路器</h1><p id="c1ea" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">分布式体系结构中的软件通常有许多依赖关系，每个依赖关系(即使是最可靠的服务)在某个点上的失败是不可避免的。</p><p id="4778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们失败的服务变得没有响应，会发生什么？所有依赖它的服务也有变得无响应的风险。这叫做<code class="fe kl km kn ko b">catastrophic cascading failure.</code></p><p id="7077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">断路器背后的基本思想非常简单。断路器的工作原理是将调用包装到目标服务，并持续监控故障率。一旦故障达到某个阈值，断路器就会跳闸，所有对电路的进一步调用都会返回故障或错误。</p><p id="c4b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">断路器模式背后的设计理念是<code class="fe kl km kn ko b">fail fast</code>:当一个服务变得无响应时，依赖它的其他服务应该停止等待，并开始处理失败的服务可能不可用的事实。通过防止单个服务的故障通过整个系统级联，断路器模式有助于整个系统的<code class="fe kl km kn ko b">stability</code>和<code class="fe kl km kn ko b">resilience</code>。</p><p id="e9d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">断路器模式可以实现为如下所示的有限状态机:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/d724e6f1505fa1c47cbbca23ce5d19e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FNaudg-1fhsfSv5O.png"/></div></div></figure><p id="49ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">断路器</p><p id="20e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有三种状态:<code class="fe kl km kn ko b">open</code>、<code class="fe kl km kn ko b">closed</code>和<code class="fe kl km kn ko b">half-open</code></p><ul class=""><li id="60a9" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir">关闭</strong>:请求被传递给目标服务。持续监控错误率、请求数量和超时等指标。当这些指标超过特定阈值(由开发人员设定)时，断路器跳闸并转换到<code class="fe kl km kn ko b">open</code>状态。</li><li id="b3d5" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir"> open </strong>:请求不会传递给目标服务，而是会调用<code class="fe kl km kn ko b">fallback</code>逻辑(也是由开发人员定义的)来处理失败。断路器将保持<code class="fe kl km kn ko b">open</code>状态一段时间，称为<code class="fe kl km kn ko b">sleeping window</code>，之后断路器可以从<code class="fe kl km kn ko b">open</code>转换到<code class="fe kl km kn ko b">half-open</code>。</li><li id="f0e9" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">半开</strong>:在这种状态下，有限数量的请求被传递给目标服务，目的是重置状态。如果目标服务能够成功响应，则中断<code class="fe kl km kn ko b">reset</code>回到<code class="fe kl km kn ko b">closed</code>状态。否则断路器转换回<code class="fe kl km kn ko b">open</code>状态。</li></ul><p id="3d95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是关于断路器的基本背景，你可以在网上找到更多关于它的信息。</p><p id="4737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们来调查项目<code class="fe kl km kn ko b">hystrix</code>。</p><h1 id="a909" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">高起鳞癣</h1><p id="128f" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated"><code class="fe kl km kn ko b">hystrix</code>是一个非常流行的开源项目。你可以在这个<a class="ae kp" href="https://github.com/Netflix/Hystrix/wiki" rel="noopener ugc nofollow" target="_blank">链接</a>中找到关于它的一切。</p><p id="daae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想引用上面链接的几个要点。Hystrix设计用于实现以下功能:</p><ul class=""><li id="0eaa" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">针对通过第三方客户端库访问(通常通过网络)的依赖性，提供保护并控制延迟和故障。</li><li id="1ec0" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">停止复杂分布式系统中的级联故障。</li><li id="7311" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">快速失败并迅速恢复。</li><li id="32c5" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">尽可能后退并适度降级。</li><li id="a29c" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">实现近乎实时的监控、警报和运营控制。</li></ul><p id="bc4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到<code class="fe kl km kn ko b">hystrix</code>完美地实现了我们在上一节谈到的断路器模式的想法，对吗？</p><p id="d2a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">hystrix</code>项目是用<code class="fe kl km kn ko b">Java</code>开发的。在本文中，我更喜欢使用golang版本<code class="fe kl km kn ko b">hystrix-go</code>，这是一个简化的版本，但实现了所有关于断路器的主要设计和想法。</p><p id="0372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe kl km kn ko b">hystrix-go</code>的用法，可以在这个<a class="ae kp" href="https://github.com/afex/hystrix-go" rel="noopener ugc nofollow" target="_blank">链接</a>中找到，非常直观易懂。你可以很容易地在网上找到许多其他的文章和演示例子来展示更多的使用水平的东西。请去头部阅读。</p><p id="e6b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的文章中，我想深入到<code class="fe kl km kn ko b">hystrix-go</code>的源代码中，深入研究一下<code class="fe kl km kn ko b">circuit breaker</code>是如何实现的。请跟进阅读以下部分。</p><h1 id="71ac" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">三种服务降级策略</h1><p id="5b69" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated"><code class="fe kl km kn ko b">Hystrix</code>提供了三种不同的服务降级策略来避免<code class="fe kl km kn ko b">cascading failure</code>在整个系统中发生:<code class="fe kl km kn ko b">timeout</code>、<code class="fe kl km kn ko b">maximum concurrent request numbers</code>和<code class="fe kl km kn ko b">request error rate</code>。</p><ul class=""><li id="4d28" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir">超时</strong>:如果服务调用在预定义的时间内没有成功返回响应，那么回退逻辑将运行。这个策略是最简单的。</li><li id="1055" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">最大并发请求数</strong>:当并发请求数超过阈值时，回退逻辑将处理下一个请求。</li><li id="fb27" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">请求错误率</strong> : <code class="fe kl km kn ko b">hystrix</code>将记录每个服务呼叫的响应状态，在错误率达到阈值后，断路器将打开，在断路器状态变回闭合之前，回退逻辑将执行。<code class="fe kl km kn ko b">error rate</code>策略是最复杂的一种。</li></ul><p id="148d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以从<code class="fe kl km kn ko b">hystrix</code>的基本用法看出，如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f45f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的使用案例中，可以看到<code class="fe kl km kn ko b">timeout</code>设置为10秒，最大请求数为100，错误率阈值为25个百分比。</p><p id="fe28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在消费者应用程序级别，这几乎是您需要设置的所有配置。<code class="fe kl km kn ko b">hystrix</code>会使魔音内部发生。</p><p id="555f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我计划通过查看源代码向您展示<code class="fe kl km kn ko b">hystrix</code>的内部。</p><p id="63db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先说容易的:<code class="fe kl km kn ko b">max concurrent requests</code>和<code class="fe kl km kn ko b">timeout</code>。然后继续探索复杂的策略<code class="fe kl km kn ko b">request error rate</code>。</p><h1 id="50f9" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">总指挥官</h1><p id="0e54" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">基于上面的例子，你可以看到<code class="fe kl km kn ko b">Go</code>函数是通向<code class="fe kl km kn ko b">hystrix</code>源代码的大门，所以让我们从它开始如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1d7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Go</code>函数接受三个参数:</p><ul class=""><li id="edfb" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir">名称</strong>:命令名，绑定到hystrix内部创建的<code class="fe kl km kn ko b">circuit</code>。</li><li id="0d13" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">运行</strong>:一个函数，包含向依赖服务发送请求的正常逻辑。</li><li id="3b6d" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">回退</strong>:包含回退逻辑的函数。</li></ul><p id="db24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Go</code>函数只是将<code class="fe kl km kn ko b">run</code>和<code class="fe kl km kn ko b">fallback</code>用<code class="fe kl km kn ko b">Context</code>包裹起来，用于控制和取消goroutine，如果不熟悉可以参考之前的<a class="ae kp" href="https://baoqger.github.io/2021/04/26/golang-context-source-code/" rel="noopener ugc nofollow" target="_blank">文章</a>。最后它会调用<code class="fe kl km kn ko b">GoC</code>函数。</p><p id="65e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">GoC</code>功能如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e802" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我承认这很复杂，但也是整个<code class="fe kl km kn ko b">hystrix</code>项目的核心。耐心点，我们一点一点仔细复习。</p><p id="9ce0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，<code class="fe kl km kn ko b">GoC</code>函数的代码结构如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mv"><img src="../Images/23cd508896e05c6bca71ca494d19c2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dvEs9jhtMzSdbE8X.png"/></div></div></figure><p id="9b3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总指挥官</p><ol class=""><li id="9a2e" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mw ml mm mn bi translated">构造一个新的<code class="fe kl km kn ko b">Command</code>对象，它包含每次调用<code class="fe kl km kn ko b">GoC</code>函数的所有信息。</li><li id="3dab" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mw ml mm mn bi translated">通过调用<code class="fe kl km kn ko b">GetCircuit(name)</code>函数按名称获取<code class="fe kl km kn ko b">circuit breaker</code>(如果不存在就创建它)。</li><li id="7f02" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mw ml mm mn bi translated">声明条件变量<strong class="jp ir"> ticketCond </strong>和<strong class="jp ir"> ticketChecked </strong> with <code class="fe kl km kn ko b">sync.Cond</code>，用于goroutines之间的通信。</li><li id="b3cc" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mw ml mm mn bi translated">声明函数<strong class="jp ir">返回票</strong>。什么是<strong class="jp ir">票</strong>？<strong class="jp ir"> returnTicket </strong>是什么意思？以后再详细讨论吧。</li><li id="58f8" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mw ml mm mn bi translated">声明另一个函数<strong class="jp ir"> reportAllEvent </strong>。该功能对<code class="fe kl km kn ko b">error rate</code>策略至关重要。</li><li id="b1a0" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mw ml mm mn bi translated">声明一个<code class="fe kl km kn ko b">sync.Once</code>的实例，这是golang提供的另一个有趣的<code class="fe kl km kn ko b">synchronization primitives</code>。</li><li id="8583" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mw ml mm mn bi translated">启动两个goroutines，每个goroutines也包含许多逻辑。简单来说，第一个包含向目标服务发送请求的逻辑和<code class="fe kl km kn ko b">max concurrent request number</code>的策略，第二个包含<code class="fe kl km kn ko b">timeout</code>的策略。</li><li id="21f0" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mw ml mm mn bi translated">返回一个<code class="fe kl km kn ko b">channel</code>类型值</li></ol><p id="30c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们逐一回顾一下。</p><h1 id="5690" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">命令</h1><p id="d5c9" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated"><code class="fe kl km kn ko b">command</code>结构如下，嵌入<strong class="jp ir">同步。互斥</strong>定义了几个字段:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c30e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，<code class="fe kl km kn ko b">command</code>对象iteself不包含命令名信息，它的生命周期就在一个<code class="fe kl km kn ko b">GoC</code>调用的范围内。这意味着关于服务请求的统计指标，如<code class="fe kl km kn ko b">error rate</code>和<code class="fe kl km kn ko b">concurrent request number</code>没有存储在命令对象中。相反，这些度量存储在<strong class="jp ir">电路</strong>字段中，该字段是<code class="fe kl km kn ko b">CircuitBreaker</code>类型。</p><h1 id="c879" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">断路器</h1><p id="8e0a" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">正如我们在<code class="fe kl km kn ko b">GoC</code>函数的工作流程中提到的，调用<code class="fe kl km kn ko b">GetCircuit(name)</code>来获取或创建<code class="fe kl km kn ko b">circuit breaker</code>。它在<code class="fe kl km kn ko b">circuit.go</code>文件中实现如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="131d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逻辑非常简单。所有断路器都存储在一个地图对象<strong class="jp ir">断路器</strong>中，关键字为<strong class="jp ir">命令名</strong>。</p><p id="a082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">newCircuitBreaker</code>构造函数和<code class="fe kl km kn ko b">CircuitBreaker</code>结构如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bffa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">CircuitBreaker</code>的所有字段对于理解断路器如何工作都很重要。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/cc9ad41b2555c185da5704585f1f4617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*r8LreDG0xO5H0UZa.png"/></div></figure><p id="44dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两个不是简单类型的字段需要更多的分析，包括<code class="fe kl km kn ko b">executorPool</code>和<code class="fe kl km kn ko b">metrics</code>。</p><ul class=""><li id="aeb6" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir">执行池</strong>:用于<code class="fe kl km kn ko b">max concurrent request number</code>策略。</li><li id="96ab" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">指标</strong>:用于<code class="fe kl km kn ko b">request error rate</code>策略，好吗？</li></ul><h1 id="7874" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">遗嘱执行人</h1><p id="0040" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">我们可以在<code class="fe kl km kn ko b">pool.go</code>文件中找到<code class="fe kl km kn ko b">executorPool</code>逻辑:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0d47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它利用golang <code class="fe kl km kn ko b">channel</code>来实现<code class="fe kl km kn ko b">max concurrent request number</code>策略。请注意，创建了<code class="fe kl km kn ko b">Tickets</code>字段，这是一个容量为<strong class="jp ir"> MaxConcurrentRequests </strong>的缓冲通道。并且在随后的<strong class="jp ir"> for </strong>循环中，通过向通道发送值直到达到容量，使缓冲通道充满。</p><p id="f88b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所示，在<code class="fe kl km kn ko b">GoC</code>功能的第一个goroutine中，<code class="fe kl km kn ko b">Tickets</code>通道的用法如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="13a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次调用<code class="fe kl km kn ko b">GoC</code>函数都会从<strong class="jp ir">circuit . executor pool . tickets</strong>通道获得一张<strong class="jp ir">票</strong>，直到没有<strong class="jp ir">票</strong>剩余，这意味着并发请求的数量达到了阈值。在这种情况下，将执行<code class="fe kl km kn ko b">default</code>案例，并且服务将通过回退逻辑优雅地降级。</p><p id="8f83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，每次对<code class="fe kl km kn ko b">GoC</code>的调用完成后，需要将<strong class="jp ir">票</strong>送回<strong class="jp ir">circuit . executor pool . tickets</strong>，对吗？你还记得上一节提到的<code class="fe kl km kn ko b">returnTicket</code>功能吗？是的，它只是用于这个目的。<code class="fe kl km kn ko b">GoC</code>功能中定义的<code class="fe kl km kn ko b">returnTicket</code>功能如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8a21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它调用<code class="fe kl km kn ko b">executorPool.Return</code>函数:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">票</strong>的设计和实现是<code class="fe kl km kn ko b">golang channel</code>在现实应用中的一个很好的例子。</p><p id="1915" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，<code class="fe kl km kn ko b">max concurrent request number</code>战略可以说明如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi my"><img src="../Images/dcd7995a28f8715a68078a1f60505449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J6tDLksK7dQBAuPO.png"/></div></div></figure><p id="26d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上节认真复习了<code class="fe kl km kn ko b">hystrix</code>中的<code class="fe kl km kn ko b">max concurrent requests</code>策略，希望你能从中学习到一些有趣的东西。</p><p id="f803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们在下一节一起研究<code class="fe kl km kn ko b">timeout</code>策略。</p><h1 id="5e75" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">超时</h1><p id="7559" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">与<code class="fe kl km kn ko b">max concurrent request number</code>策略相比，<code class="fe kl km kn ko b">timeout</code>非常直白易懂。</p><p id="6fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在上一节提到的，<code class="fe kl km kn ko b">hystrix</code>的核心逻辑在<code class="fe kl km kn ko b">GoC</code>函数内部。<code class="fe kl km kn ko b">GoC</code>函数内部运行两个goroutines。您已经看到第一个goroutine包含向目标服务发送请求的逻辑和<code class="fe kl km kn ko b">max concurrent request number</code>的策略。第二个goroutine怎么样？下面我们来回顾一下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9d58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，定时器<strong class="jp ir">是用设置中的超时持续时间值创建的。并且一个<code class="fe kl km kn ko b">select</code>语句让这个goroutine等待，直到一个<code class="fe kl km kn ko b">case</code>条件从通道接收值。<strong class="jp ir">超时</strong>情况只是第三种情况(前两种情况未触发时)，它将运行回退逻辑，并显示<strong class="jp ir"> ErrTimeout </strong>错误消息。</strong></p><p id="672a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，您应该清楚这两个goroutines的主要结构和功能。但在细节上，有两个Golang技巧需要你注意:<code class="fe kl km kn ko b">sync.Once</code>和<code class="fe kl km kn ko b">sync.Cond</code>。</p><h1 id="fafc" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">同步。一次</h1><p id="a9a9" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">您可能已经注意到下面的代码块，它在<code class="fe kl km kn ko b">GoC</code>函数中重复了几次:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6396" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> returnOnce </strong>是<code class="fe kl km kn ko b">sync.Once</code>的类型，保证<code class="fe kl km kn ko b">Do</code>方法的回调函数在不同的goroutines之间只运行一次。</p><p id="4f0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种特定情况下，可以保证<strong class="jp ir"> returnTicket() </strong>和<strong class="jp ir"> reportAllEvent() </strong>都只执行一次。这确实很有意义，因为如果<strong class="jp ir"> returnTicket() </strong>为一个<code class="fe kl km kn ko b">GoC</code>调用运行多次，那么当前的并发请求数就不会正确，对吗？</p><p id="2a39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我另外写了一篇关于<code class="fe kl km kn ko b">sync.Once</code>的详细文章，你可以参考<a class="ae kp" href="https://baoqger.github.io/2021/05/11/golang-sync-once/" rel="noopener ugc nofollow" target="_blank">那篇文章</a>进行更深入的解释。</p><h1 id="8ad9" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">同步。Cond</h1><p id="71ab" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated"><strong class="jp ir"> returnTicket </strong>函数的实现如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="227a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> ticketCond </strong>是条件变量，在Golang中是<code class="fe kl km kn ko b">sync.Cond</code>的类型。</p><p id="caf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">条件变量在不同例程之间的通信中很有用。具体来说，<code class="fe kl km kn ko b">sync.Cond</code>的<code class="fe kl km kn ko b">Wait</code>方法会挂起当前的goroutine，<code class="fe kl km kn ko b">Signal</code>方法会唤醒阻塞的goroutine继续执行。</p><p id="4bd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kl km kn ko b">hystrix</code>情况下，当<strong class="jp ir"> ticketChecked </strong>为<strong class="jp ir"> false </strong>时，意味着当前的<code class="fe kl km kn ko b">GoC</code>调用还没有结束，并且<strong class="jp ir"> ticket </strong>应该还没有返回。所以<strong class="jp ir"> ticketCond。Wait() </strong>被调用来阻塞这个goroutine，并等待直到<code class="fe kl km kn ko b">Signal</code>方法通知的<code class="fe kl km kn ko b">GoC</code>调用完成。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="dc49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，上面两行代码总是被一起调用。<strong class="jp ir"> ticketChecked </strong>设置为<strong class="jp ir"> true </strong>表示当前<code class="fe kl km kn ko b">GoC</code>调用结束，<strong class="jp ir">票</strong>准备返回。此外，悬挂goroutine的<code class="fe kl km kn ko b">Wait</code>方法放在循环的<strong class="jp ir">内，这也是一种最佳实践技术。</strong></p><p id="1b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于<code class="fe kl km kn ko b">sync.Cond</code>的更多解释，我将在以后写另一篇文章来解释，请稍等。</p><h1 id="f09d" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">撤退</h1><p id="fe25" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">最后，让我们看看当目标服务没有响应时，如何调用<strong class="jp ir"> fallback </strong>函数。</p><p id="540b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回忆一下，每个<code class="fe kl km kn ko b">GoC</code>调用都会创建一个新的<strong class="jp ir">命令</strong>实例。并且<strong class="jp ir"> fallback </strong>函数将被分配给同名的字段，以后会用到。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c7e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在上面章节中看到的，当达到<code class="fe kl km kn ko b">timeout</code>或<code class="fe kl km kn ko b">max concurrent request number</code>阈值时，触发<strong class="jp ir"> errorWithFallback </strong>方法。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="acb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> errorWithFallback </strong>方法将通过调用<strong class="jp ir"> tryFallback </strong>运行回退，并报告度量事件，如<strong class="jp ir">回退失败</strong>和<strong class="jp ir">回退成功</strong>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们谈到了<code class="fe kl km kn ko b">hystrix</code>提供的所有策略中最简单的一个<code class="fe kl km kn ko b">timeout</code>策略。为了更好地理解复杂的代码逻辑，还回顾了一些详细的Golang技术。</p><h1 id="a8ee" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">摘要</h1><p id="5e32" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在本文中，我们讨论了由<code class="fe kl km kn ko b">hystrix</code>提供的<code class="fe kl km kn ko b">max concurrent requests</code>策略和<code class="fe kl km kn ko b">timeout</code>策略的详细实现。为了更好地理解复杂的代码逻辑，还回顾了一些详细的Golang技术。</p><p id="157e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我把<code class="fe kl km kn ko b">error rate</code>策略留给你，请深入代码库，探索更多关于断路的知识。玩得开心！</p></div></div>    
</body>
</html>