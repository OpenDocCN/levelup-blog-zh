<html>
<head>
<title>Build a Moving Box with Purescript — An Introduction to Purescript Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Purescript构建一个移动的盒子——pure script教程介绍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-moving-box-with-purescript-ae1a490429ab?source=collection_archive---------0-----------------------#2019-11-21">https://levelup.gitconnected.com/building-a-moving-box-with-purescript-ae1a490429ab?source=collection_archive---------0-----------------------#2019-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="90f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用用于DOM操作的普通Purescript技术构建一个简单的移动框，学习用于web开发的Purescript的基础知识。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/84b20a6b2577c822bb2c58fd235fe30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*bt9wn8yEiwUwSbf4.gif"/></div></figure><h1 id="56d6" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">介绍</h1><p id="06a8" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于那些想要深入函数式编程世界的人来说，Purescript是一个非常有趣的选择。它让你把纯粹的功能乐趣带入网络世界，因为它可以编译成Javascript。这很好，因为web编程已经为许多开发人员所熟悉，这使它成为函数式编程范例的一个很好的展示。</p><p id="f77d" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">我开始研究Purescript，因为我学习了一点Haskell。我从中获得了乐趣，所以我想构建一些更实用的东西，而不是常见的书籍示例。问题是，如果我使用Haskell，我必须学习一些GUI库来使项目图形化和有趣。</p><p id="a205" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">然后我想起了Purescript，这种语言看起来很像Haskell ( <a class="ae mj" href="https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md" rel="noopener ugc nofollow" target="_blank"> not equal，虽然</a>)并且允许我为我已经习惯的web环境构建应用程序。我决定我的玩具项目将只是一个围绕页面窗口移动的彩色盒子。</p><p id="74bb" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">当我开始研究这门语言时，我注意到有一些著名的库可以处理DOM。像<a class="ae mj" href="https://github.com/slamdata/purescript-halogen" rel="noopener ugc nofollow" target="_blank"> Halogen </a>和<a class="ae mj" href="https://github.com/purescript-contrib/purescript-react" rel="noopener ugc nofollow" target="_blank"> purescript-react </a>这样的库有望让处理DOM变得更简单，并提供更实用的体验。然而，我也想用这个项目来比较普通Javascript和普通Purescript的DOM操作，以了解“仅仅”改变语言会有什么不同。</p><p id="d72c" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这时我注意到没有太多的Purescript教程，尤其是如果你想在不使用这些库的情况下构建一些东西。如果你想通过只使用该语言的官方标准库(如purescript-web-dom或purescript-web-html)来做一些事情，那么你可能只有<a class="ae mj" href="https://pursuit.purescript.org/" rel="noopener ugc nofollow" target="_blank"> Pursuit </a>的API文档(这些文档并不总是真正描述性的)和GitHub上其他人的源代码作为参考(如果你找到的话)。这是做这个教程的主要动机。</p><p id="b8c5" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">本教程的代码基于<a class="ae mj" href="https://github.com/GCrispino/purescript-moving-box" rel="noopener ugc nofollow" target="_blank">这个库</a>。我对它做了一点修改，如果你愿意的话，我会分步骤(你可以通过它的分支)把它发布到这个<a class="ae mj" href="https://github.com/GCrispino/purescript-moving-box-tutorial" rel="noopener ugc nofollow" target="_blank">其他库</a>中。</p><h1 id="8cdf" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">开始项目</h1><p id="616f" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们开始弄脏我们的手。首先，我们将设置项目。为此，我们需要<code class="fe mk ml mm mn b">purs</code>(pure script编译器)、<code class="fe mk ml mm mn b">pulp</code> (Purescript的构建工具)和<code class="fe mk ml mm mn b">bower</code>(是的，不是npm的包管理器)。要安装这些工具，请查看Purescript官方“入门”指南的<a class="ae mj" href="https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md#installing-the-compiler" rel="noopener ugc nofollow" target="_blank">部分。</a></p><p id="5cf7" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">首先，让我们创建一个目录，并使用<code class="fe mk ml mm mn b">pulp</code>初始化它。我将把它命名为<code class="fe mk ml mm mn b">box</code> <strong class="lk iu"> </strong>但是你可以随意命名:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="921f" class="ms kr it mn b gy mt mu l mv mw">$ mkdir box<br/>$ cd box<br/>$ pulp init</span></pre><p id="da42" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这将安装一些依赖项并设置<code class="fe mk ml mm mn b">bower.json</code>文件。它还将通过在<code class="fe mk ml mm mn b">src/Main.purs</code>上创建一个简单的Hello World文件和在<code class="fe mk ml mm mn b">test/Main.purs</code>上创建一个测试文件来创建一个样板文件结构。我们不会在这里讨论自动化测试，所以你可以删除最后一个。</p><p id="8e34" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">尽管这不是必需的，我们也将使用npm来定义一个构建脚本。所以跑吧:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="0727" class="ms kr it mn b gy mt mu l mv mw">$ npm init -y</span></pre><p id="bb65" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">然后在新创建的<code class="fe mk ml mm mn b">package.json</code>文件中，创建一个<code class="fe mk ml mm mn b">build</code>条目。<code class="fe mk ml mm mn b">scripts</code>属性如下所示:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="b4ee" class="ms kr it mn b gy mt mu l mv mw">"scripts": {<br/>  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>  "build": "pulp build -O --to dist/index.js"<br/>},</span></pre><p id="aa01" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">完成这些之后，让我们安装将与bower一起使用的代码依赖项:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="4e03" class="ms kr it mn b gy mt mu l mv mw">bower install --save purescript-web-dom purescript-web-html</span></pre><p id="d4ae" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">当我们运行<code class="fe mk ml mm mn b">pulp init</code>时，项目基本上只用Purescript的Prelude初始化，Prelude是它的标准库(它定义了基本的操作符、函数和类型)。所以我们需要<code class="fe mk ml mm mn b">purescript-web-dom</code>和<code class="fe mk ml mm mn b">purescript-web-html</code>来处理DOM和操作HTML元素。</p><p id="44b9" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">Purescript编译器生成一个<code class="fe mk ml mm mn b">.js</code>文件，所以在我们的例子中，我们需要一个HTML文件来在浏览器中加载我们的代码。在我们项目的根目录下创建一个<code class="fe mk ml mm mn b">index.html</code>,内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0166" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><strong class="lk iu">注意(可选):</strong>如果您想将其转换成Git存储库，您可以将以下条目添加到由<code class="fe mk ml mm mn b">pulp init</code>创建的<code class="fe mk ml mm mn b">.gitignore</code>文件中:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="a538" class="ms kr it mn b gy mt mu l mv mw">/dist/</span></pre><p id="8ddd" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">我们将使用这个文件夹来保存我们构建的文件，所以我们不希望它们被提交到存储库中。</p><h2 id="d297" class="ms kr it bd ks mz na dn kw nb nc dp la lr nd ne lc lv nf ng le lz nh ni lg nj bi translated">构建和运行代码</h2><p id="137d" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要构建代码，我们只需在终端中运行我们之前定义的<code class="fe mk ml mm mn b">build</code>命令:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="ce0b" class="ms kr it mn b gy mt mu l mv mw">$ npm run build</span></pre><p id="209b" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">要运行它，只需在某个web浏览器中打开<code class="fe mk ml mm mn b">index.html</code>文件，并查看它的控制台。如果一切顺利，它应该显示<code class="fe mk ml mm mn b">Hello sailor!</code></p><h1 id="fa28" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">代码</h1><h2 id="bfec" class="ms kr it bd ks mz na dn kw nb nc dp la lr nd ne lc lv nf ng le lz nh ni lg nj bi translated">创建盒子</h2><p id="d479" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们已经设置好了一切，我们可以开始创建盒子了！让我们从创建一个静止的盒子开始(<em class="nk">耶</em>):</p><p id="1ca2" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">我们也将使用Purescript完成所有的样式，这样我们就不必处理CSS文件之类的东西了。</p><p id="10a3" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">我们需要在<code class="fe mk ml mm mn b">Main.purs</code>文件的顶部导入一些我们需要的依赖项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="465d" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">然后，我们将定义<code class="fe mk ml mm mn b">createBoxElement</code>，一个创建代表盒子的HTML元素的函数。它使用一个<code class="fe mk ml mm mn b">String</code>作为元素的id，一个<code class="fe mk ml mm mn b">DOM.Document</code>作为文档对象，并返回一个<code class="fe mk ml mm mn b">Effect DOM.Element.Element</code>，即新创建的HTML对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="948d" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">创建元素，然后定义它的id和类名。最后设置它的初始CSS属性，最后返回(<code class="fe mk ml mm mn b">pure</code>把<code class="fe mk ml mm mn b">boxEl</code>里面的纯值包装成一个<code class="fe mk ml mm mn b">Effect</code>)。</p><p id="8655" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">但是等等——我们新函数上面的这个<code class="fe mk ml mm mn b">foreign</code>语句是什么？这是Purescript的<strong class="lk iu">外来函数接口</strong> (FFI)的一个例子。这是一个在Javascript文件中定义的函数，我们只需要告诉Purescript编译器我们正在导入它，我们还需要给它一个类型签名，这样它就可以正确地进行类型检查。</p><p id="7b03" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这是该功能实现的代码，写在<code class="fe mk ml mm mn b">Main.js</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bdac" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">除了<a class="ae mj" href="https://stackoverflow.com/questions/36314/what-is-currying" rel="noopener ugc nofollow" target="_blank"> currying </a>(这是Purescript中外函数的规则)，它没有做任何异常的事情。</p><p id="51d0" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">我创建它不是为了学习/展示FFI是如何工作的。我这么做是因为我找不到一个本地函数来修改元素的样式属性(如果你知道的话，我很乐意添加)。</p><p id="40d9" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">看一下<code class="fe mk ml mm mn b">main</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dd3f" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这个函数是我们应用程序的入口点。每个Purescript程序都需要它。为此，我们使用前面定义的<code class="fe mk ml mm mn b">createBoxElement</code>函数来创建我们的box元素，并将其附加到文档的主体。我们通过<code class="fe mk ml mm mn b">HTML.window</code>和<code class="fe mk ml mm mn b">HTML.Window.document</code>函数访问窗口和文档对象。然后我们必须得到物体。函数<code class="fe mk ml mm mn b">HTML.body</code>给了我们一个<code class="fe mk ml mm mn b">Effect (Maybe HTMLElement)</code>，所以我们必须对它进行模式匹配，以确定它是属于类型<code class="fe mk ml mm mn b">Nothing</code>还是类型<code class="fe mk ml mm mn b">Just a</code>。这就是创建默认span element对象的原因，因为它用于第一种情况。获取body对象的结果被放入变量<code class="fe mk ml mm mn b">b</code>。</p><p id="522e" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">最后，我们创建盒子，并在最后两行将其附加到主体。</p><p id="013a" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">运行<code class="fe mk ml mm mn b">npm run build</code>，您应该会得到类似这样的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3ee4cb9ba74cc0bfebd20e9a44d1b02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*N-98tbA8mCfF1WVk2S52gA.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">一个很棒的盒子</figcaption></figure><p id="dfd1" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">酷！我们刚刚造好了我们的盒子！但是还没动…</p><h2 id="d53f" class="ms kr it bd ks mz na dn kw nb nc dp la lr nd ne lc lv nf ng le lz nh ni lg nj bi translated">移动箱子</h2><p id="a5a2" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们有了箱子，我们应该开始考虑如何让它移动。为了让盒子反复移动，我们必须有某种循环。为此，我们将使用<code class="fe mk ml mm mn b">requestAnimationFrame</code>,这是一个在浏览器进行下一次重画之前安排一个动作(由回调表示)发生的函数(更多信息，请查看<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"> this </a>)。在Purescript中，该函数具有以下签名:</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="885a" class="ms kr it mn b gy mt mu l mv mw">requestAnimationFrame :: Effect Unit -&gt; Window -&gt; Effect RequestAnimationFrameId</span></pre><p id="1f78" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">换句话说，它接受一个<code class="fe mk ml mm mn b">Effect Unit</code>(回调)——换句话说，这是一个副作用，它返回一个<code class="fe mk ml mm mn b">Unit</code>(在本例中是我们的回调)，一个<code class="fe mk ml mm mn b">Window</code>对象，并返回一个<code class="fe mk ml mm mn b">Effect RequestAnimationFrameId</code>，一个包含我们刚刚调度回调的帧的id的效果。</p><p id="aec1" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">首先，让我们创建一个虚拟动作，将一些内容打印到屏幕上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7e15" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">然后，在主函数的最后，让我们用<code class="fe mk ml mm mn b">requestAnimationFrame</code>来调度它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2799" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">完成这些更改并编译和运行代码后，您应该会在浏览器控制台中看到一个<code class="fe mk ml mm mn b">"Request animation frame!!"</code>。</p><p id="cd51" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这个效果只执行一次。我们以后需要的是不停执行的东西，所以我们必须稍微改变一下<code class="fe mk ml mm mn b">execFrame</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="34fd" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在，在我们将字符串打印到控制台后，我们将通过调度另一个<code class="fe mk ml mm mn b">requestAnimationFrame</code>调用来递归调用同一个函数。现在，您的代码应该无限地打印同一个字符串。</p><p id="79a2" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这并不令人兴奋，对吗？但我们会马上搬箱子。</p><h2 id="1ad3" class="ms kr it bd ks mz na dn kw nb nc dp la lr nd ne lc lv nf ng le lz nh ni lg nj bi translated">搬箱子(真的，我保证)</h2><p id="6bd9" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着我们的应用程序变得有点复杂，我们将定义一个<code class="fe mk ml mm mn b">State</code>类型来保持我们的状态数据在单个对象中定义良好。这在我们的小应用程序中并不真正必要，但在较大的程序中这是一个很好的实践:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="edba" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在，我们将只保留将在像素中使用的<code class="fe mk ml mm mn b">position</code>来跟踪盒子在<code class="fe mk ml mm mn b">Number</code>变量中的位置，只是为了展示如何保留这段数据。</p><p id="5e8f" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们对<code class="fe mk ml mm mn b">main</code>函数做一些修改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9845" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">注意，通过调用<code class="fe mk ml mm mn b">new</code>函数并传递一个默认记录，创建了一个<code class="fe mk ml mm mn b">Ref State</code>对象，现在它被传递给了<code class="fe mk ml mm mn b">execFrame</code>函数，现在使用<code class="fe mk ml mm mn b">requestAnimationFrame</code>调用该函数。使用<code class="fe mk ml mm mn b">Ref</code>(在<code class="fe mk ml mm mn b">Effect.Ref</code>模块中可用)类型是在Purescript中操作可变数据的一种方式。它保存了对某种数据的引用，就像我们在Javascript中做的那样。然而，我们必须使用一个接口来实现:要创建一个新的<code class="fe mk ml mm mn b">Ref</code>对象，您必须调用<code class="fe mk ml mm mn b">new</code>函数；为了读取和写入内容，我们使用了(不足为奇的)函数<code class="fe mk ml mm mn b">read</code>和<code class="fe mk ml mm mn b">write</code>。所有这些函数都返回一个带有最新数据的对象，所以尽管它是可变的，但它仍然是纯的(可能会令人困惑，请原谅我)。</p><p id="512a" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这个完全相同的函数发生了一点变化，让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ba07" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在，它基本上只是调用新的<code class="fe mk ml mm mn b">moveBox</code>函数，并向它传递box元素和新的ref。以下是<code class="fe mk ml mm mn b">moveBox</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5c93" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">它首先读取当前状态，并基于它向右导出新的盒子位置。然后，它通过使用<code class="fe mk ml mm mn b">requestAnimationFrame</code>调度它在下一帧执行来递归调用相同的函数。最后，它将新的距离写入状态参考。</p><p id="3058" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如果您构建并运行它，您应该会看到盒子向右移动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/66ff3721e87ef51149c4336d62501310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*h0NSHSCP1V93XYWO.gif"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">厉害！</figcaption></figure><h2 id="0af8" class="ms kr it bd ks mz na dn kw nb nc dp la lr nd ne lc lv nf ng le lz nh ni lg nj bi translated">把盒子放在窗户里</h2><p id="c005" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">盒子会移动，但是当它到达屏幕的右端时就会消失。我们想让它保持在屏幕范围内。</p><p id="6965" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们首先创建一个名为<code class="fe mk ml mm mn b">Direction</code>的新类型，它将指示盒子的移动。下面的代码将保存在<code class="fe mk ml mm mn b">src/Direction.purs</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6631" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><code class="fe mk ml mm mn b">Direction</code>模块和类型本身被定义。正如我们所看到的，这是一个简单的类型，可以是以下4种类型中的任何一种:<code class="fe mk ml mm mn b">LeftDir</code>、<code class="fe mk ml mm mn b">RightDir</code>、<code class="fe mk ml mm mn b">UpDir</code>和<code class="fe mk ml mm mn b">DownDir</code>。</p><p id="879b" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><code class="fe mk ml mm mn b">moveBox</code>函数现在将接收当前方向，它还必须确定移动盒子后的新方向:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e11a" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">请注意，它调用了一个名为<code class="fe mk ml mm mn b">getNewDirectionAndDist</code>的新函数来确定新的方向和距盒子原点的距离。查看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1ae0" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">目前，我们只是担心水平方向(稍后我们将扩展到垂直方向)。上面的代码匹配方向，并检查到根的距离是否超过了窗口的宽度(或原点，如果它已经返回)。如果是的话，现在方向变了。此外，根据方向增加或减少距离。</p><p id="4cea" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><code class="fe mk ml mm mn b">execFrame</code>函数的签名需要稍微修改一下。它现在将水平方向作为其第一个参数<code class="fe mk ml mm mn b">hDir</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ed6e" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在只需在对<code class="fe mk ml mm mn b">main</code>内部<code class="fe mk ml mm mn b">requestAnimationFrame</code>的调用中更改以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ef7a" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在，在构建并运行它之后，您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/84b20a6b2577c822bb2c58fd235fe30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*bt9wn8yEiwUwSbf4.gif"/></div></figure><h2 id="17d9" class="ms kr it bd ks mz na dn kw nb nc dp la lr nd ne lc lv nf ng le lz nh ni lg nj bi translated">垂直移动盒子</h2><p id="26f9" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的下一步也是最后一步是让盒子水平和垂直移动。在我们完成了上一节的内容之后，这应该不会太难。我们只需要在代码中添加一些语句。</p><p id="82d7" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">因为我们跟踪当前盒子的位置，而且盒子也会垂直移动，所以我们必须保持它在两个轴上的位置。状态应该是这样的知道吗:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b41d" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">我们将把它编码成两个<code class="fe mk ml mm mn b">Number</code>变量的<code class="fe mk ml mm mn b">Tuple</code>，而不是只有一个<code class="fe mk ml mm mn b">Number</code>。然后，必须对以下功能进行更改:</p><p id="4536" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><code class="fe mk ml mm mn b">getNewDirectionAndDist</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7953" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><code class="fe mk ml mm mn b">moveBox</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5d38" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><code class="fe mk ml mm mn b">execFrame</code>和<code class="fe mk ml mm mn b">main</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f767" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">基本上，我们所做的是改变应用程序状态的读写，并在垂直方向(而不仅仅是水平方向)添加移动逻辑，主要是在<code class="fe mk ml mm mn b">getNewDirectionAndDist</code>和<code class="fe mk ml mm mn b">moveBox</code>功能上。</p><p id="7e22" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在，你的盒子应该水平和垂直移动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/0c69f85a87a03eca15119024c193e7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*9z-yZyyYrt7_3pmM.gif"/></div></figure><h1 id="f5ca" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">结论</h1><p id="af84" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们只用Purescript就构建了一个<strong class="lk iu">超赞的</strong>移动盒子！我可以说，与用普通Javascript编写这样的应用程序相比，不使用库来编写这样的应用程序有一些优势:使用函数类型(<code class="fe mk ml mm mn b">Maybe</code>、<code class="fe mk ml mm mn b">Effect</code>等)、纯度和类型安全的能力就是很好的例子。当然这并不意味着这样更好，但是有一个替代方案是很好的。</p><p id="d1f1" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">正如我所说的，我刚刚开始学习更多关于纯函数式语言的知识，但是到目前为止还是很有趣的，如果这对你有所帮助，我已经很高兴了。请随意留下你的想法。再见！</p></div></div>    
</body>
</html>