<html>
<head>
<title>Why an Interface Can Not Implement Another Interface</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么一个接口不能实现另一个接口</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-an-interface-can-not-implement-another-interface-updated-f3f7ec936e95?source=collection_archive---------20-----------------------#2022-12-14">https://levelup.gitconnected.com/why-an-interface-can-not-implement-another-interface-updated-f3f7ec936e95?source=collection_archive---------20-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="a338" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">面向对象编程</h2><div class=""/><div class=""><h2 id="22c4" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">类和接口示例和概念</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2db89d2af0ac2ad7180ae151a42b5e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFdprY5ynPPJexZs1SQniQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">马库斯·斯皮斯克在<a class="ae le" href="https://unsplash.com/s/photos/java?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6f43" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因为你已经读过文章的标题，这是你下次面试时可能会被问到的有趣的面试问题之一。我发现这个问题非常有趣，我们将在本文中讨论它。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="50df" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">问题是:</h1><h2 id="a71d" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">让我通过写一些示例代码来问这个问题，这样你就能清楚地知道问这个问题的意义。</h2><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="6d37" class="nq mj iq nm b be nr ns l nt nu">interface A {<br/>    void display();<br/>}</span></pre><h2 id="f48c" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">抽象类B实现接口a。</h2><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="fa4a" class="nq mj iq nm b be nr ns l nt nu">abstract class B implements A {<br/>} <br/>// we may or may not implement display() method but this is allowed</span></pre><h2 id="e969" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">C类将这个抽象扩展到了b类。</h2><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="7f92" class="nq mj iq nm b be nr ns l nt nu">class C extends B {<br/>   void display(){<br/>   }<br/>}</span></pre><h2 id="9ffe" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">接口D实现了接口a。为什么这是不允许的，尽管它是100%抽象的，并且类似于抽象类B？</h2><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="1511" class="nq mj iq nm b be nr ns l nt nu">interface D implements A {<br/>} // this is not allowed.</span></pre><p id="2381" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在跳到答案之前，我们先来了解一下抽象类和接口。这将是一个快速掌握答案的复习。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="86cd" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">Java中的抽象</h1><p id="e14a" class="pw-post-body-paragraph lf lg iq lh b li nv ka lk ll nw kd ln lo nx lq lr ls ny lu lv lw nz ly lz ma ij bi translated"><strong class="lh ja"> <em class="oa">抽象</em> </strong> <em class="oa">是隐藏实现细节，只向用户显示功能的过程。</em></p><p id="bffc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一种方式，它只向用户显示基本的东西，隐藏内部细节，例如，在你输入文本和发送消息的地方发送短信。你不知道消息传递的内部处理。</p><p id="6e25" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">抽象让你专注于对象做什么，而不是它如何做。</p><h2 id="ea34" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">实现抽象的方法:</h2><p id="9c6f" class="pw-post-body-paragraph lf lg iq lh b li nv ka lk ll nw kd ln lo nx lq lr ls ny lu lv lw nz ly lz ma ij bi translated">在java中有两种实现抽象的方法</p><ol class=""><li id="c3bc" class="ob oc iq lh b li lj ll lm lo od ls oe lw of ma og oh oi oj bi translated"><em class="oa">抽象类(0到100%) </em></li><li id="fa5e" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated"><em class="oa">界面(100%) </em></li></ol></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="7ea6" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">1.抽象类:</h1><p id="028f" class="pw-post-body-paragraph lf lg iq lh b li nv ka lk ll nw kd ln lo nx lq lr ls ny lu lv lw nz ly lz ma ij bi translated">以下是关于抽象类的一些重要观察。</p><ol class=""><li id="f9cc" class="ob oc iq lh b li lj ll lm lo od ls oe lw of ma og oh oi oj bi translated"><strong class="lh ja"> <em class="oa">无法创建抽象类的实例，因为它可能包含在抽象类中没有方法定义的抽象方法。</em> </strong></li><li id="3e52" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated"><strong class="lh ja"> <em class="oa">允许构造函数，这样就可以初始化抽象类的数据字段。</em> </strong></li><li id="374b" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated"><strong class="lh ja"> <em class="oa">我们可以有一个抽象类，不需要任何抽象方法。</em>T25】</strong></li><li id="5a9d" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated">我们可以在抽象类中定义静态方法。T29】</li></ol><h2 id="7fbf" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">示例:</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">抽象示例。</figcaption></figure><h2 id="03a4" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">输出:</h2><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="2dd5" class="nq mj iq nm b be nr ns l nt nu">in display of CentralBank class.<br/>in writeMessage of CentralBank class.<br/>in sayHello of Bank class.<br/>in display of Bank class.</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="7eb3" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">2.界面:</h1><p id="42e1" class="pw-post-body-paragraph lf lg iq lh b li nv ka lk ll nw kd ln lo nx lq lr ls ny lu lv lw nz ly lz ma ij bi translated"><em class="oa">一个</em> <strong class="lh ja"> <em class="oa">接口</em> </strong> <em class="oa">是一个类的蓝图。它有静态常数和抽象方法。</em></p><p id="f9e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="oa">它是一种实现抽象的机制。Java接口中只能有抽象方法，不能有方法体。它用于实现Java中的抽象和多重继承。</em></p><ul class=""><li id="4e24" class="ob oc iq lh b li lj ll lm lo od ls oe lw of ma or oh oi oj bi translated">通过接口，我们可以<strong class="lh ja"> <em class="oa">支持多继承的功能。</em>T11】</strong></li><li id="4082" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma or oh oi oj bi translated">它<strong class="lh ja"> <em class="oa">可以用来实现松耦合。</em>T15】</strong></li><li id="3351" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma or oh oi oj bi translated">它<strong class="lh ja"> <em class="oa">不能像抽象类一样被实例化。</em>T19】</strong></li></ul><h2 id="aa81" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">注意:</h2><ol class=""><li id="a178" class="ob oc iq lh b li nv ll nw lo os ls ot lw ou ma og oh oi oj bi translated"><em class="oa">从Java 8开始，我们可以在一个接口中拥有</em> <strong class="lh ja"> <em class="oa">默认和</em> </strong> <em class="oa">静态方法。</em></li><li id="6d8d" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated"><em class="oa">从Java 9开始，我们可以在一个接口中拥有</em> <strong class="lh ja"> <em class="oa">私有方法</em> </strong> <em class="oa">。</em></li></ol><h2 id="de22" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">示例:</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">界面示例</figcaption></figure><h2 id="1ced" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">输出:</h2><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="cf49" class="nq mj iq nm b be nr ns l nt nu">overridden default method<br/>default method<br/>drawing rectangle</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="8fa3" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">要回答上述问题，下面是几个要点:</h1><ol class=""><li id="b819" class="ob oc iq lh b li nv ll nw lo os ls ot lw ou ma og oh oi oj bi translated">一个类可以扩展另一个类来继承父类的特性和/或实现一个接口来为接口的抽象方法提供方法定义。</li><li id="1ffa" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated">一个接口扩展了另一个接口，因为扩展另一个接口的接口只是添加了自己的抽象方法，并没有为另一个接口的抽象方法提供方法定义。</li><li id="fcf2" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated">接口永远不会扩展类，因为接口不提供方法定义。</li></ol></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="9347" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">TLDR:</h1><p id="ab2b" class="pw-post-body-paragraph lf lg iq lh b li nv ka lk ll nw kd ln lo nx lq lr ls ny lu lv lw nz ly lz ma ij bi translated"><em class="oa">一个接口只能有</em> <code class="fe ov ow ox nm b"><strong class="lh ja"><em class="oa">extend</em></strong></code> <em class="oa">其他接口不能有</em> <code class="fe ov ow ox nm b"><strong class="lh ja"><em class="oa">implement</em></strong></code> <em class="oa">其他接口作为接口只能有方法声明而不能有方法体本身。</em></p><p id="283e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="oa">当我们说实现时，那基本上意味着为抽象方法提供方法定义。</em></p><p id="164d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="oa">于是一个接口扩展了另一个接口。</em>T47】</strong></p><p id="184d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另外，注意一个<em class="oa"> 100% </em> <code class="fe ov ow ox nm b">abstract class</code>在功能上等同于一个<code class="fe ov ow ox nm b">interface</code>，但是如果你愿意，它也可以有实现(在这种情况下，它不会保持100% <code class="fe ov ow ox nm b">abstract</code>)，所以从JVM的角度来看，它们是不同的东西。</p><p id="90c3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">同样，100%<strong class="lh ja"><em class="oa"/></strong><code class="fe ov ow ox nm b"><strong class="lh ja">abstract class</strong></code>中的成员变量可以有任何访问说明符，而在<code class="fe ov ow ox nm b"><strong class="lh ja">interface</strong></code>中，它们是隐式的<code class="fe ov ow ox nm b"><strong class="lh ja">public static final</strong></code>。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="20e3" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">一个接口可以覆盖另一个接口的默认方法吗？</h1><p id="f2ce" class="pw-post-body-paragraph lf lg iq lh b li nv ka lk ll nw kd ln lo nx lq lr ls ny lu lv lw nz ly lz ma ij bi translated">可以在一个接口中编写<em class="oa">默认</em>和<em class="oa">静态</em> <em class="oa">方法</em>来支持向后兼容。当一个接口扩展另一个接口时，该接口可以覆盖默认方法，然而，将实现的类也可以覆盖默认方法。</p><p id="4669" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">查看以下示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">重写接口内的默认方法。</figcaption></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="f966" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="oa">本文到此为止。希望你喜欢这篇文章。</em></p><h1 id="6846" class="mi mj iq bd mk ml oy mn mo mp oz mr ms kf pa kg mu ki pb kj mw kl pc km my mz bi translated">您可以关注<a class="pd pe ep" href="https://medium.com/u/2c3b611409dc?source=post_page-----f3f7ec936e95--------------------------------" rel="noopener" target="_blank">维克拉姆·古普塔</a>了解类似内容。</h1></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="9cfc" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">分级编码</h1><p id="a9c5" class="pw-post-body-paragraph lf lg iq lh b li nv ka lk ll nw kd ln lo nx lq lr ls ny lu lv lw nz ly lz ma ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="95b7" class="ob oc iq lh b li lj ll lm lo od ls oe lw of ma or oh oi oj bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="07a1" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma or oh oi oj bi translated">📰查看更多内容请参见<a class="ae le" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="004b" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma or oh oi oj bi translated">🔔关注我们:<a class="ae le" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae le" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae le" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="2151" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">🚀👉<a class="ae le" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>