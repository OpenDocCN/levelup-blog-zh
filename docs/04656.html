<html>
<head>
<title>Face Recognition, Socket Programming, and Multithreading in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的人脸识别、套接字编程和多线程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/face-recognition-socket-programming-and-multithreading-in-python-6f9717fa2864?source=collection_archive---------5-----------------------#2020-07-08">https://levelup.gitconnected.com/face-recognition-socket-programming-and-multithreading-in-python-6f9717fa2864?source=collection_archive---------5-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="439b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">⏳在下面的材料中，我们将说明网络套接字(特别是TCP)的机制，并在此基础上构建一个具有多线程服务器的人脸识别应用程序。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e8c28cfe513a5aad6a3620e2829331b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ivV4l5RcxTUAMyQ1"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@nevenkrcmarek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Neven Krcmarek </a>拍摄的照片</figcaption></figure><h1 id="c3e3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">👉套接字通信</h1><p id="e56d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Network_socket" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">套接字</strong> </a>是进程间的一种通信方式。它与其他进程的主要区别在于，它可以实现两个或多个不同主机、机器、节点……(不同IP地址)之间的<a class="ae ky" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">进程间通信</strong> </a>。为了完成通信，套接字总是存在于我们的网络中，例如，我们每天上网、流式传输、发送和接收电子邮件等。</p><p id="d7d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于进程通信最重要的事情是每个进程必须被唯一地标识。例如，在TCP/IP网络协议中，进程由(IP地址、协议(TCP或UDP)、端口号)三元组来标识。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="94cb" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">👉TCP协议</h1><p id="eb0b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">TCP是面向连接的<a class="ae ky" href="https://en.wikipedia.org/wiki/Transport_layer" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">传输层</strong> </a>协议。TCP Socket基于一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu"/></a><strong class="lt iu"/>的客户-服务器模型(或者更一般地说是<strong class="lt iu">生产者-消费者模型</strong>)。服务器处理客户端的连接请求，并在连接建立后传输数据(<strong class="lt iu">三次握手):</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/04affec28229aaa9e6dabdb15d2e6492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OX2IJqq-bhWr1jA2slrDw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Wireshark捕获的图像:id = 443和id =47976的两个进程之间的3次握手</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/7e54db74a8272d832fdf50c231a4f3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cLlW7myXsAuwQhGuhHQbQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">服务器和客户端之间的3次握手</figcaption></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ba88" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">👉python中的套接字</h1><p id="0652" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了使用套接字，我们需要导入相应的内置模块。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3af6" class="nl la it nh b gy nm nn l no np">import socket</span></pre><p id="611d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在您需要创建socket对象的一个实例:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7ab8" class="nl la it nh b gy nm nn l no np">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></pre><p id="d882" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">可调用函数套接字接受两个参数作为输入:</p><blockquote class="nq nr ns"><p id="eba0" class="lr ls nt lt b lu mn ju lw lx mo jx lz nu mp mc md nv mq mg mh nw mr mk ml mm im bi translated"><strong class="lt iu">地址族</strong>:三个主要值之一:</p></blockquote><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c3fe" class="nl la it nh b gy nm nn l no np">+-------------------+--------------------+<br/>|<strong class="nh iu">  Address family </strong>  |   <strong class="nh iu"> Explanation </strong>    |<br/>+-------------------+--------------------+<br/>|  socket.AF_INET   |    IPv4 socket     | <br/>|  socket.AF_INET6  |    IPv6 socket     |<br/>|  socket.AF_UNIX   |  IPC(local socket) | <br/>+-------------------+--------------------+<br/>IPC : Inter-Process Communication</span></pre><blockquote class="nq nr ns"><p id="46e5" class="lr ls nt lt b lu mn ju lw lx mo jx lz nu mp mc md nv mq mg mh nw mr mk ml mm im bi translated"><strong class="lt iu">插座类型:</strong>四个值之一:</p></blockquote><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5e48" class="nl la it nh b gy nm nn l no np">+---------------------+--------------------+<br/>|<strong class="nh iu">   Socket type   </strong>    |   <strong class="nh iu"> Explanation </strong>    |<br/>+---------------------+--------------------+<br/>|  socket.SOCK_STREAM |    TCP  socket     | <br/>|  socket.SOCK_DGRAM  |    UDP  socket     |<br/>|socket.SOCK_SEQPACKET|  sequenced packet  | <br/>|  socket.SOCK_RAW    |   raw protocols    |<br/>+---------------------+--------------------+</span></pre><p id="54e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该函数返回一个表示套接字id的整数，否则返回-1，表示发生了错误。</p><p id="5857" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通信是通过这种套接字类型和地址族的组合来建立的。</p><p id="e58b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，<strong class="lt iu">插座。AF_INET </strong>和<strong class="lt iu">插座。SOCK_STREAM </strong>启用<strong class="lt iu"> IPv4 </strong>地址和<strong class="lt iu"> TCP </strong>通信。</p><p id="9bad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们在<strong class="lt iu">套接字</strong> <strong class="lt iu">变量</strong>中有了一个<strong class="lt iu">套接字</strong>，我们可以用它来做进一步的工作。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="2a37" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">👉TCP套接字服务器</h1><p id="5665" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">TCP协议背后的主要思想是一个程序与另一个程序建立连接，它们交换数据，没有丢失。完成后，应该关闭连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/19a18782e6f0419b197f5a4737a2de14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZudISloovh909PElfpURA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">会议闭幕</figcaption></figure><p id="64d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在TCP中，数据以字节为单位进行交换。程序应该把它分成单独的消息。</p><p id="a638" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了创建服务器，您需要将一个套接字与计算机上的一个或所有主机(IP地址)和一些空闲端口号(<a class="ae ky" href="https://www.webopedia.com/quick_ref/portnumbers.asp#:~:text=Port%20numbers%20range%20from%200,process%20as%20its%20contact%20port." rel="noopener ugc nofollow" target="_blank">已分配端口列表</a>)相关联。Ip地址“0.0.0.0”表示<em class="nt">本地机器上的所有IPv4地址</em>。如果指定“127.0.0.1”或“localhost”(环回地址)，则只能从同一台计算机连接。</p><p id="8b23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在你需要将IP地址绑定到套接字上。这个方法采用2元组作为参数:IP地址或主机名，以及端口号。这就是传统上所说的<a class="ae ky" href="https://linux.die.net/man/2/bind" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu"/></a></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="76cf" class="nl la it nh b gy nm nn l no np">HOST = "localhost"<br/>PORT = 5555 <br/>server_socket.bind((HOST, PORT))</span></pre><p id="d315" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此时，我们需要在调用<strong class="lt iu"> accept </strong>方法之前指出连接队列中可用的最大连接数。这可以通过使用<strong class="lt iu">监听</strong>功能来完成:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="746a" class="nl la it nh b gy nm nn l no np">server_socket.listen(5) # 5 connections can only be available in the queue</span></pre><p id="a218" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在<strong class="lt iu">成功</strong>时，它将返回<strong class="lt iu">零</strong>。否则，返回<strong class="lt iu"> -1 </strong>。</p><p id="09fc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在使用accept函数接受连接。这个函数阻塞服务器，直到出现一个传入的连接，并返回与之相关联的套接字对象和所连接主机的地址。<strong class="lt iu">地址</strong>是由<strong class="lt iu"> IP地址</strong>和<strong class="lt iu">端口号</strong>组成的数组。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ec15" class="nl la it nh b gy nm nn l no np">client_socket, addr = server_socket.accept()# addr is an array<br/>print('\n[*] Connected from ip: {} and port : {} '.format(addr[0],addr[1]))</span></pre><p id="0ae4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用client_socket对象，我们的服务器可以与客户机交换数据。</p><blockquote class="nq nr ns"><p id="04c7" class="lr ls nt lt b lu mn ju lw lx mo jx lz nu mp mc md nv mq mg mh nw mr mk ml mm im bi translated"><strong class="lt iu"> addr [0] </strong>:连接客户端的IP地址。</p><p id="bac5" class="lr ls nt lt b lu mn ju lw lx mo jx lz nu mp mc md nv mq mg mh nw mr mk ml mm im bi translated"><strong class="lt iu"> addr[1] </strong>:套接字的端口号，可以在其中与连接的客户端交换数据。(服务器端端口)</p></blockquote><p id="987f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要建立与新客户机的新连接，您需要调用accept函数。所以我们需要一个循环来接受无限数量的连接。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1019" class="nl la it nh b gy nm nn l no np">while True:<br/>  print('\n[*] Waiting for client...')<br/>  # Wait to accept a connection - blocking call<br/>  client_socket, addr = server_socket.accept()</span></pre><p id="607a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这一点上，我们的服务器看起来很棒。</p><p id="83df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在要从客户端读取传入的数据，您需要使用<strong class="lt iu"> recv() </strong>方法。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="aef0" class="nl la it nh b gy nm nn l no np">Bytes_Number = 8 * 1024 # Number of bytes to receive, 8 kilo-bytes<br/># 1 byte is equivalent to 8 bits<br/>data = client_socket.recv(Bytes_Number)<br/></span></pre><p id="b83a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">换句话说，“字节数”是网络缓冲区的大小。</p><p id="e3c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从套接字接收的数据类型是字节，如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8ed9" class="nl la it nh b gy nm nn l no np">data = b’\xed0\x00\x00\x00\x00\x00\x00'# byte array of hex values<br/>data = data.hex()# convert to <strong class="nh iu">hexadecimal</strong> values.</span></pre><p id="16aa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在数据的值变成了十六进制表示的“d02900000000000”。注意，这个表示是以<strong class="lt iu">大端</strong>格式。所以为了找到这个数的十进制值，你需要以这样的方式交换字节，最高有效位变成最低有效位。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="9e00" class="nl la it nh b gy nm nn l no np">data = 00000000000029d0 # equivalent to 10704 in decimal</span></pre><p id="865c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个项目中，这个数字表示客户端发送的图像的大小。请继续阅读，了解更多关于这个数字的信息。</p><p id="573e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<strong class="lt iu"> send() </strong>函数，可以向socket发送数据。它也接受字节，所以要发送一个字符串，你必须对它进行编码。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5f24" class="nl la it nh b gy nm nn l no np">str = "Hi"<br/>client_socket.send (b "Hello From Server" ) <br/>client_socket.send (b "Your data:"  + str.encode ( "utf-8" ))</span></pre><p id="7a35" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所见，在这两个函数<strong class="lt iu"> send </strong>和<strong class="lt iu"> recv的帮助下，数据可以在整个TCP连接中进行交换。</strong></p><p id="0d53" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您还可以使用<strong class="lt iu"> sendall() </strong>方法来发送您作为参数传递的整个缓冲区。事实上，您可以使用<strong class="lt iu"> send() </strong>方法重新实现这个方法，如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f39b" class="nl la it nh b gy nm nn l no np">def sendall(socket, data):<br/>    ret = socket.send(data) # return the nb of bytes sent<br/>    while ret &gt; 0:<br/>        <!-- -->ret = socket.send(data[ret:])<br/>    return None</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="66a4" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">👉TCP套接字客户端</h1><p id="87bd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在客户端，创建套接字的方式与在服务器端完全相同:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c1de" class="nl la it nh b gy nm nn l no np">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></pre><p id="e95d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，区别存在于客户端，我们需要连接到服务器已经打开的套接字，而不是监听套接字。为此，我们使用<strong class="lt iu">连接</strong>方法:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2762" class="nl la it nh b gy nm nn l no np">HOST = 'localhost' <br/>TCP_PORT = 5555 # the port number that is opened by the server<br/>Client_Socket.connect((HOST, TCP_PORT))</span></pre><p id="88d3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在服务器端，<strong class="lt iu"> accept </strong>方法将打开与之前连接的客户端的连接。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="97af" class="nl la it nh b gy nm nn l no np">client_socket, addr = server_socket.accept() #server side connection</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/4ebd58e2eb9198cda58d5740f145dcc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*1ogkGMyzxEbiCDa103xocw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">客户端-服务器工作流</figcaption></figure><p id="7790" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后一切如常。</p><p id="3c7d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在回到我们的主要目标，我们需要创建一个能够发送图像和接收可识别图像的客户端。根据我的经验，要做到这一点，有两种发送图像的方法。</p><p id="8b2a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 1-将图像作为二进制文件加载，并以字节块的形式发送，如下所示:</strong></p><p id="8739" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">程序的工作流程:</strong></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="38db" class="nl la it nh b gy nm nn l no np">CLIENT                                             SERVER<br/>                   Send chunks of Image<br/>load image   ----------------------------------&gt;  Read Bytes<br/>                        Send b'0' <br/>as binary    ----------------------------------&gt;  End of Image<br/>                  Send the received image<br/>Read Bytes   &lt;----------------------------------  Read and Save<br/>                        Send b'0'<br/>End of Image &lt;----------------------------------<br/>                         <br/>Read + Save  ----------------------------------&gt;  Closing the socket<br/>                   Client Closes Socket</span></pre><p id="a37b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> server.py </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="08a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> client.py </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ff0a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">运行服务器将生成以下输出:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f1e1" class="nl la it nh b gy nm nn l no np"><br/>(base) harmouch@kali:~/Desktop$ python3 server.py</span><span id="ab93" class="nl la it nh b gy ob nn l no np">[*] Socket successfully created</span><span id="bd18" class="nl la it nh b gy ob nn l no np">[*] Socket is now listening</span><span id="63c0" class="nl la it nh b gy ob nn l no np">[*] Connected from ip: 127.0.0.1 and port : 51126 <br/>Image received and recreated<br/>Sending image data...<br/>Length Data sent:4096<br/>Length Data sent:4096<br/>Length Data sent:2270<br/>Length Data sent:0</span><span id="3a9c" class="nl la it nh b gy ob nn l no np">----------------Connection Closed-------------------</span></pre><p id="f034" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，运行客户端将提示以下内容:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5d3a" class="nl la it nh b gy nm nn l no np">(base) harmouch@kali:~/Desktop$ python3 client.py</span><span id="f691" class="nl la it nh b gy ob nn l no np">[*] Socket successfully created</span><span id="7953" class="nl la it nh b gy ob nn l no np">[*] Connecting to server @ ip = localhost and port = 3333</span><span id="5848" class="nl la it nh b gy ob nn l no np">[*] Sending image as bytes...<br/>1<br/>4096<br/>4096<br/>2269</span><span id="6bf5" class="nl la it nh b gy ob nn l no np">[*] Finish sending the image...</span><span id="b737" class="nl la it nh b gy ob nn l no np">------------------------------------------------</span><span id="e444" class="nl la it nh b gy ob nn l no np">----------------Receving data-------------------</span><span id="d972" class="nl la it nh b gy ob nn l no np">------------------------------------------------</span><span id="2733" class="nl la it nh b gy ob nn l no np">[*] Length of Data received: 4096</span><span id="b50d" class="nl la it nh b gy ob nn l no np">[*] Length of Data received: 4096</span><span id="2ac5" class="nl la it nh b gy ob nn l no np">[*] Length of Data received: 2270</span><span id="d0b9" class="nl la it nh b gy ob nn l no np">[*] Length of Data received: 1</span></pre><p id="5f2c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 2-第二种方法:</strong></p><p id="00d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将图像作为三维数组(RGB)读取，并使用cv2.imencode将其编码为某种格式(jpeg、jpg、png…)。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0df4" class="nl la it nh b gy nm nn l no np">image = cv2.imread("img.jpg")<br/>encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 90]<br/>result, frame = cv2.imencode('.jpeg', image, encode_param)</span></pre><p id="936b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本例中，<strong class="lt iu"> cv2.imencode() </strong>函数将用jpeg压缩将图像格式转换成字节，并将其分配给某个内存缓存。</p><p id="27ef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们需要发送压缩图像的大小及其字节表示，以让网络的另一端(服务器)知道他需要接收多少字节。这可以通过使用<strong class="lt iu"> struct.pack </strong>函数来完成:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="aa64" class="nl la it nh b gy nm nn l no np">Client_Socket.sendall(struct.pack("l",size) + data)</span></pre><p id="cb1b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> struct.pack r </strong>返回一个包含值<strong class="lt iu"> size </strong>的bytes对象，用<strong class="lt iu"> long </strong>格式打包，发送图像的所有字节及其大小。</p><p id="937f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此时，服务器可以检索套接字缓冲区中存在的字节，如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8f00" class="nl la it nh b gy nm nn l no np">CHUNK_SIZE = 4 * 1024 # 4 kB<br/>encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 90]<br/># struct_size is 8 bytes<br/>struct_size = struct.calcsize("l")<br/>img_size= client_socket.recv(struct_size) # reads 8 bytes to store #the size of the image <br/># struct.unpack retrun a tuple <br/>img_size = struct.unpack("l", img_size)[0] # 8 bytes<br/># read 4 kB from the buffer each time untill img_size<br/>while len(data) &lt; img_size:<br/>  data += client_socket.recv(CHUNK_SIZE)<br/>  print("\n[*] Receiving ",len(data))<br/>frame_data = data[:img_size]<br/>data = data[img_size:]<br/>frame=pickle.loads(frame_data)<br/>frame = cv2.imdecode(frame, cv2.IMREAD_COLOR)</span></pre><p id="bc71" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">代码</strong></p><p id="882e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> Server.py </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a2a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> Client.py </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7a9f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">程序的工作流程:</strong></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="07f0" class="nl la it nh b gy nm nn l no np">CLIENT                                             SERVER<br/>               <br/>Read frame     Encode,Send The Image with size<br/>of the video ----------------------------------&gt;  Read Bytes,decode         <br/> <br/>Read Bytes                                        predict the label<br/>              Encode,Send The Recognized Image <br/>End of Image &lt;----------------------------------  <br/></span></pre><p id="c5d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">程序的输出看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/1720b0113a0ddb7ce3be78e4865454fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGPPJ9ApTM3b1MLlIOo1EQ.png"/></div></div></figure><p id="edf8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的服务器只能处理一个客户端，所以要处理下一个客户端，它应该等到上一个客户端服务完成之后。我们能改进它吗？？</p><p id="566a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">答案是肯定的，通过利用物理资源(CPU线程)。</p><blockquote class="nq nr ns"><p id="3a66" class="lr ls nt lt b lu mn ju lw lx mo jx lz nu mp mc md nv mq mg mh nw mr mk ml mm im bi translated">该识别算法先前在本文  <strong class="lt iu">的<a class="ae ky" href="https://medium.com/dev-genius/face-recognition-based-on-lbph-algorithm-17acd65ca5f7" rel="noopener"> <strong class="lt iu">中讨论过。</strong></a></strong></p></blockquote></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="c799" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">👉<strong class="ak">多线程</strong></h1><p id="5c8f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">多线程是一个低级编程概念，所有高级编程语言都支持它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/c570f44d240813b26a814d129ec85ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hm6QcIEZ-m4tKMlELGHiyA.png"/></div></div></figure><h2 id="019a" class="nl la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated">什么是线程？</h2><p id="f04d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">处理器有一个或多个内核，每个内核有一个或多个线程。线程是具有独立指令集的最小执行单元。它是进程的一部分，运行在与内存相同的上下文共享程序的可执行资源上。</p><h2 id="45b9" class="nl la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated"><strong class="ak">多线程</strong>的优点:</h2><p id="b3da" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">1-它提高了多核系统的计算速度</p><p id="3283" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">2-所有进程线程可以共享全局变量。因此，如果一个全局变量在一个线程中发生变化，它会影响其他线程。</p><p id="f01b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">3-它允许程序在单独处理一个或多个线程时保持响应。</p><h2 id="1c7a" class="nl la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated"><strong class="ak">多线程</strong>的缺点:</h2><p id="a4c5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">1-在单处理器中，系统性能可能会下降。</p><p id="5bbb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">2-增加内存和处理器的使用。</p><p id="76b4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">3-增加了程序的复杂性。</p><p id="6e83" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在python中，有两个允许多线程的模块:</p><ul class=""><li id="f826" class="op oq it lt b lu mn lx mo ma or me os mi ot mm ou ov ow ox bi translated"><strong class="lt iu"> <em class="nt">螺纹</em> </strong></li><li id="1598" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><strong class="lt iu"> <em class="nt">穿线</em> </strong></li></ul><p id="9bb5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要创建一个线程，可以使用下面这段代码:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5e29" class="nl la it nh b gy nm nn l no np">t = threading.Thread(target=function, args=(arg1,arg2 ...))<br/>t.start()</span></pre><p id="0c9a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此将创建一个线程来处理目标<strong class="lt iu">函数</strong>以及该函数的<strong class="lt iu">参数</strong> arg1，arg2…参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="46f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，您可以运行多个客户端进行人脸识别:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/8a872262ed8a83246bd204501fe13bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fudL8YitwYunkHv_B5L2MA.png"/></div></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="d9f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在你可能会问:我们可以运行多少个线程？</p><p id="6bf9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">答案取决于您的CPU能力:处理器有多少个内核或线程，就有多少个线程可以同时运行。</p><h1 id="7907" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">👉结论</h1><p id="26e9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我希望这个基本的Python网络/多线程帖子非常有趣和直观。此外，我在本文中添加了几个插图，这些插图无疑会帮助您提高Python技能。</p><p id="2ec7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你可以随时在GitHub上查看我的项目代码。请随意叉我的回购，并为这个项目作出贡献，以便改善它，如果你想。</p><div class="pe pf gp gr pg ph"><a href="https://github.com/Harmouch101/Face-Recogntion-Detection" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">harmouch 101/人脸识别检测</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">这个项目实现了一个人脸检测算法，使用皮肤分割RGB-YCrCb-HSV，viola jones和人脸…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">github.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks ph"/></div></div></a></div><blockquote class="pw"><p id="1808" class="px py it bd pz qa qb qc qd qe qf mm dk translated">寓意:“一个代码可以建立一个完整的世界，另一个可以摧毁一个，而你就是那个决定的人……”</p></blockquote></div></div>    
</body>
</html>