<html>
<head>
<title>Useful JavaScript Tips — Loops and Sorting Dates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的JavaScript技巧——循环和日期排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/useful-javascript-tips-loops-and-sorting-dates-21456c5634a6?source=collection_archive---------16-----------------------#2020-06-27">https://levelup.gitconnected.com/useful-javascript-tips-loops-and-sorting-dates-21456c5634a6?source=collection_archive---------16-----------------------#2020-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/37cbdbd2305e99f5ca75e86e66f67441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E4qVLyZWqzv0WjQt"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sreckoskrobic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯雷科·斯克罗比奇</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="64f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解一些应该遵循的技巧，以便更快更好地编写JavaScript代码。</p><h1 id="2241" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">中断for循环</h1><p id="ea04" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们想早点结束一个<code class="fe mh mi mj mk b">for</code>循环，我们可以使用<code class="fe mh mi mj mk b">break</code>关键字。</p><p id="864b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ce13" class="mt lf it mk b gy mu mv l mw mx">for (const val of list) {<br/>  console.log(val);<br/>  if (val === 'b') {<br/>    break;<br/>  }<br/>}</span></pre><p id="df82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mh mi mj mk b">val</code>是<code class="fe mh mi mj mk b">'b'</code>，那么我们用<code class="fe mh mi mj mk b">break</code>结束循环。</p><p id="9503" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以用旧的<code class="fe mh mi mj mk b">for</code>循环做同样的事情:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c897" class="mt lf it mk b gy mu mv l mw mx">for (let i = 0; i &lt; list.length; i++) {<br/>  console.log(list[i]);<br/>  if (list[i] === 'b') {<br/>    break;<br/>  }<br/>}</span></pre><p id="661d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们做同样的事情，除了因为索引而变得更长。</p><h1 id="a2e2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查对象是否为空</h1><p id="0fab" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">Object.entries</code>方法检查一个对象是否为空。它返回对象中非继承的键值对。</p><p id="f98f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0014" class="mt lf it mk b gy mu mv l mw mx">Object.entries(obj).length === 0</span></pre><p id="529c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过检查由<code class="fe mh mi mj mk b">Object.entries</code>的长度返回的数组来检查<code class="fe mh mi mj mk b">obj</code>是否为空。</p><p id="cd08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最好通过添加以下内容来检查<code class="fe mh mi mj mk b">obj</code>实际上是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d813" class="mt lf it mk b gy mu mv l mw mx">obj.constructor === Object</span></pre><p id="342e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lodash也有<code class="fe mh mi mj mk b">isEmpty</code>函数来做同样的事情。</p><p id="7983" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2dcd" class="mt lf it mk b gy mu mv l mw mx">_.isEmpty(obj)</span></pre><p id="f7a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">去做检查。</p><h1 id="f5eb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">返回异步函数的结果</h1><p id="1da1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">异步函数返回一个承诺，其中包含该承诺的解析值。</p><p id="cc2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7e6b" class="mt lf it mk b gy mu mv l mw mx">const getJSON = async () =&gt; {<br/>  const response = await fetch('./file.json')<br/>  return response<br/>}</span></pre><p id="538f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们返回一个解析到<code class="fe mh mi mj mk b">response</code>对象的承诺。然后，我们可以将它与其他异步函数一起使用，或者对它调用<code class="fe mh mi mj mk b">then</code>。</p><h1 id="e2d9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查JavaScript数组是否有给定值</h1><p id="bf50" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">includes</code>方法来检查一个数组是否有给定值。</p><p id="a2aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c272" class="mt lf it mk b gy mu mv l mw mx">['red', 'green'].includes('red');</span></pre><p id="b3a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以检查<code class="fe mh mi mj mk b">'red'</code>是否在它被调用的数组中。它应该返回<code class="fe mh mi mj mk b">true</code>，因为它包含在数组中。如果参数中的值不包含在内，那么它返回<code class="fe mh mi mj mk b">false</code>。</p><h1 id="9357" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象析构时重命名字段</h1><p id="ef97" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在析构对象时重命名字段。为此，我们可以使用<code class="fe mh mi mj mk b">:</code>符号。</p><p id="1ad8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="243e" class="mt lf it mk b gy mu mv l mw mx">const person = {<br/>  firstName: 'james',<br/>  lastName: 'smith'<br/>}</span><span id="4e4e" class="mt lf it mk b gy my mv l mw mx">const { firstName: name, lastName } = person;</span></pre><p id="5782" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们把<code class="fe mh mi mj mk b">firstName</code>改名为<code class="fe mh mi mj mk b">name</code>。所以<code class="fe mh mi mj mk b">name</code>就是<code class="fe mh mi mj mk b">'james'</code>。</p><h1 id="bcbd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用符号</h1><p id="09e3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用符号来创建一个唯一的标识符。即使内容相同，创建的每个符号也不会相同。</p><p id="8a4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f669" class="mt lf it mk b gy mu mv l mw mx">Symbol() === Symbol()</span></pre><p id="fe8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回<code class="fe mh mi mj mk b">false</code>。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6ba7" class="mt lf it mk b gy mu mv l mw mx">Symbol('foo') === Symbol('foo')</span></pre><p id="c1b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也是<code class="fe mh mi mj mk b">false</code>。</p><p id="7017" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将它们用作属性标识符。</p><p id="8a34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7339" class="mt lf it mk b gy mu mv l mw mx">const foo = Symbol('foo');<br/>const obj = {<br/>  [foo](){<br/>    //...<br/>  }<br/>}</span></pre><p id="8f9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8471" class="mt lf it mk b gy mu mv l mw mx">const foo = Symbol('foo');<br/>class Bar {<br/>  [foo](){<br/>    //...<br/>  }<br/>}</span></pre><p id="7978" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在对象和类中使用符号作为标识符。</p><h1 id="9fe2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">公共类字段</h1><p id="e94f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过将公共类字段放在构造函数或方法中来添加它们。</p><p id="2ac2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0655" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  constructor() {<br/>    this.count = 0<br/>  }<br/>}</span></pre><h1 id="2894" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">按日期对数组排序</h1><p id="5df6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要按日期对数组进行排序，我们可以使用<code class="fe mh mi mj mk b">sort</code>方法，计算两个日期条目之间的差值并返回它。</p><p id="e22d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定以下数组:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="02c3" class="mt lf it mk b gy mu mv l mw mx">const tasks = [{<br/>    title: 'eat',<br/>    date: new Date('2020-06-23')<br/>  },<br/>  {<br/>    title: 'drink',<br/>    date: new Date('2020-06-10')<br/>  },<br/>  {<br/>    title: 'sleep',<br/>    date: new Date('2020-06-22')<br/>  }<br/>]</span></pre><p id="94e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以按日期降序对其进行排序，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2343" class="mt lf it mk b gy mu mv l mw mx">tasks.sort((a, b) =&gt; +b.date - +a.date);</span></pre><p id="8d04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">sort</code>对数组进行排序。</p><p id="379f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">+</code>操作符将日期转换成UNIX时间戳，这样我们就可以计算它们之间的差异。</p><p id="bebf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果差值大于1，则<code class="fe mh mi mj mk b">sort</code>颠倒2个条目的顺序。</p><p id="7094" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="64e4" class="mt lf it mk b gy mu mv l mw mx">[<br/>  {<br/>    "title": "eat",<br/>    "date": "2020-06-23T00:00:00.000Z"<br/>  },<br/>  {<br/>    "title": "sleep",<br/>    "date": "2020-06-22T00:00:00.000Z"<br/>  },<br/>  {<br/>    "title": "drink",<br/>    "date": "2020-06-10T00:00:00.000Z"<br/>  }<br/>]</span></pre><p id="1a41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为<code class="fe mh mi mj mk b">tasks</code>的值。</p><p id="4f39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以翻转<code class="fe mh mi mj mk b">a</code>和<code class="fe mh mi mj mk b">b</code>来按照日期升序对<code class="fe mh mi mj mk b">tasks</code>进行排序。</p><p id="8758" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在排序前复制<code class="fe mh mi mj mk b">tasks</code>，我们可以使用扩展运算符或<code class="fe mh mi mj mk b">slice</code>，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a8b7" class="mt lf it mk b gy mu mv l mw mx">const sortedTasks = [...tasks];<br/>sortedTasks.sort((a, b) =&gt; +b.date - +a.date);</span></pre><p id="1934" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a7a8" class="mt lf it mk b gy mu mv l mw mx">const sortedTasks = tasks.slice();<br/>sortedTasks.sort((a, b) =&gt; +b.date - +a.date);</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/ae196e3a74b2a9878d57fdbc79ada0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u9XJ27uFNtFX-Vej"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@lvnatikk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">百合班克斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b968" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="7549" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">break</code>提前结束一个循环。</p><p id="defa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了用日期对对象进行排序，我们可以返回时间戳之间的差异。</p><p id="0bdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用<code class="fe mh mi mj mk b">Object.entries</code>返回一个键值对数组并使用<code class="fe mh mi mj mk b">length</code>属性来检查对象是否为空。</p></div></div>    
</body>
</html>