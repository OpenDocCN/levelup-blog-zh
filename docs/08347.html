<html>
<head>
<title>How to Professionally Do a Code Review of a Bug Fix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何专业地对Bug修复进行代码审查</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0?source=collection_archive---------5-----------------------#2021-04-23">https://levelup.gitconnected.com/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0?source=collection_archive---------5-----------------------#2021-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="952b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">审查bug修复时要问的几个重要问题。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6ac027b333935c22fd4d81dc462ad3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DTNzrM8-AfmiofU-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lewagon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Le Wagon </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="ec21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个开发人员都会定期对bug修复进行代码审查，这是他们日常工作的一部分。这个过程简单明了，但是为了开发出具有良好代码质量的项目，开发人员应该记住并遵循一些最佳实践。</p><p id="2cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名专业开发人员，在回顾队友的bug修复时，你会问自己这些问题吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d3c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单元测试有变化吗？</h1><p id="96bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">修复代码中的bug应该伴随着单元测试的添加或修改。</p><blockquote class="mz"><p id="00b8" class="na nb it bd nc nd ne nf ng nh ni lu dk translated">包含修复bug的代码更改但不包含单元测试更改的pull请求是一种气味。</p></blockquote><p id="223e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果代码更改是为了修复bug，但是没有添加或更改任何单元测试，那么单元测试覆盖率是不够的。</p><p id="5db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设开发人员实现了一个将一些字符串选项转换成数字的方法，并用单元测试覆盖了它。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f39c" class="nt md it np b gy nu nv l nw nx">public int Convert(string option)<br/>{<br/>   if (option == "No") return 0;<br/>   else if (option == "Yes") return 1;<br/>   else return -1;<br/>}</span><span id="c240" class="nt md it np b gy ny nv l nw nx">[InlineData("No", 0)]<br/>[InlineData("Yes", 1)]<br/>[InlineData("Invalid", -1)]<br/>public void VerifyConvert(string option, int expectedValue)<br/>{<br/>   var actualResult = Convert(option);<br/>   Assert.Equal(expectedValue, actualResult);<br/>}</span></pre><p id="ae4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当前的单元测试完全覆盖了<code class="fe nz oa ob np b">Convert</code>方法——行和分支覆盖率都是100%。</p><p id="e98a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，一个开发人员忘记添加第三个“也许”选项，质量控制工程师报告了这个错误。如果开发人员通过简单地将缺少的选项添加到<code class="fe nz oa ob np b">Convert</code>方法中来解决问题，而没有将新的测试用例添加到单元测试中，那么该方法将不再具有完整的单元测试覆盖范围。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4716" class="nt md it np b gy nu nv l nw nx">public int Convert(string option)<br/>{<br/>   if (option == "No") return 0;<br/>   else if (option == "Yes") return 1;<br/>   <strong class="np iu">else if (option == "Maybe") return 2; </strong><br/>   else return "-1";<br/>}</span><span id="cb25" class="nt md it np b gy ny nv l nw nx">[InlineData("No", 0)]<br/>[InlineData("Yes", 1)]<br/>[InlineData("Invalid", -1)]<br/><strong class="np iu">//The test case for "Maybe" option is missing</strong><br/>public void VerifyConvert(string option, int expectedValue)<br/>{<br/>   var actualResult = Convert(option);<br/>   Assert.Equal(expectedValue, actualResult);<br/>}</span></pre><p id="5446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试用例的缺失意味着，如果某个开发人员后来在重构过程中不小心将“2”改为“20”或者删除了“也许”选项，那么单元测试仍然会是绿色的，因为测试用例<code class="fe nz oa ob np b">[InlineDate("Maybe", 2)]</code>并没有使用添加到方法中的新选项来实现。问题会在一段时间后被发现，甚至可能在生产代码中被发现。因此，对于业务逻辑中的任何修正，相应的单元测试中必须有变化。代码审查是发现单元测试缺失的最佳时机。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们是在解决根本原因还是仅仅是症状？</h1><p id="78dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">了解开发人员是在试图修复错误的根本原因，还是只是一个症状，这一点很重要。找到根本原因往往比仅仅修复症状需要更多的时间。但这是唯一正确的做事方式，让我们来看看为什么:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d016" class="nt md it np b gy nu nv l nw nx">public decimal CalculateOrderPrice(int orderId)<br/>{<br/>   Order order = _orderRepository.GetOrder(orderId);</span><span id="7114" class="nt md it np b gy ny nv l nw nx">   decimal price = order.Price; //Potential null reference here<br/>}</span></pre><p id="58c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob np b">Order</code>类是一个引用类型，它可以包含一个空值，当应用程序试图访问<code class="fe nz oa ob np b">Price</code>属性时会崩溃。</p><p id="8388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“修复”这个问题最简单的方法是添加一个空检查，然后忘掉它。然而，空引用异常只是一个更严重问题的征兆，比如订单创建的逻辑。这个原始的根本原因会在应用程序的不同地方引起问题，简单地添加一个空检查并不能解决根本问题。</p><p id="6d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员应该始终找到并修复问题的根本原因，以便完全消除所有症状。如果由于业务压力或其他原因，开发人员只有时间解决症状，他们仍然需要确定根本原因，并在产品待办事项中创建一个<strong class="lb iu">技术债务单</strong>。</p><div class="oc od gp gr oe of"><a href="https://medium.com/codex/technical-debt-management-best-practices-for-software-engineers-871a315ac812" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">软件工程师的技术债务管理最佳实践</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">技术债务率=应该返工的代码行数/现有源代码行数* 100%</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a386" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="8b03" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据您的项目，在代码审查期间可能会出现许多其他问题。如果你的项目没有端到端的自动化测试，你可以问，<em class="ou">“开发人员向质量控制工程师描述了变更的影响范围了吗？”。</em>如果你的项目有全面的技术文档，你可以问:<em class="ou">“文档是否已经更新以反映源代码的变化？”。</em></p><p id="9a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总是问问题。您可以从我在文章中描述的那些开始，然后用您自己的扩展列表，以便更好地进行代码审查。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c3f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更多文章</h1><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/50-software-engineering-best-practices-for-technical-leaders-and-seniors-cfcdf6a17e44"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">面向技术领导者和资深人士的50个软件工程最佳实践</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">最佳工程师的最佳实践。</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oo l"><div class="ow l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/the-simplest-explanation-of-adapter-design-pattern-cd37f02bfecd"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">适配器设计模式的最简单解释</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">C#中的真实世界示例</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oo l"><div class="ox l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>