<html>
<head>
<title>Dockerize your Nodejs Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的Nodejs应用程序归档</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dockerize-your-nodejs-application-93eea25b909a?source=collection_archive---------8-----------------------#2021-10-20">https://levelup.gitconnected.com/dockerize-your-nodejs-application-93eea25b909a?source=collection_archive---------8-----------------------#2021-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f7faf2fb17eeb9b81afac5f3f67b55be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dt1TnBfucZh9jUUvQDkYmg.png"/></div></div></figure><h1 id="af8d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">目标</h1><p id="4bd8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">本文的目标是展示一个例子，它将一个nodejs应用程序归档并使用docker卷存储应用程序数据。我将使用一个非常简单的例子，但是您可以应用相同的步骤来dockerize任何nodejs应用程序。</p><p id="1520" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为此，我将使用一个用nodejs构建的简单的单页博客网站。如果您有您想要的应用程序，那么就使用它，否则就克隆我正在使用的同一个库，让我们开始吧。</p><p id="e7c3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">知识库链接:【https://github.com/hayk-simonyan/dockerized-blog-website T21】</p><h1 id="73ae" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">让我们整理一下</h1><h2 id="af8f" class="ma jz iq bd ka mb mc dn ke md me dp ki lh mf mg km ll mh mi kq lp mj mk ku ml bi translated">1.创建Dockerfile文件</h2><p id="7e7e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先，你需要<code class="fe mm mn mo mp b">cd {into_your_project}</code>，在我这里是<code class="fe mm mn mo mp b">cd dockerized-blog-website</code></p><p id="ab78" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，您需要创建一个<strong class="ky ir"> Dockerfile </strong>，这是一个<strong class="ky ir">文件，您可以在其中定义docker映像应该如何配置和构建。稍后，您将基于该文件构建您的映像，docker将自上而下执行这里列出的所有命令。</strong></p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="bae7" class="ma jz iq mp b gy my mz l na nb">FROM node </span><span id="fcbd" class="ma jz iq mp b gy nc mz l na nb">WORKDIR /blogapp </span><span id="afb7" class="ma jz iq mp b gy nc mz l na nb">COPY package.json . </span><span id="7a70" class="ma jz iq mp b gy nc mz l na nb">RUN npm install </span><span id="7032" class="ma jz iq mp b gy nc mz l na nb">COPY . . </span><span id="a47b" class="ma jz iq mp b gy nc mz l na nb">EXPOSE 8080 </span><span id="c572" class="ma jz iq mp b gy nc mz l na nb">CMD [“node”, “server.js”]</span></pre><p id="a698" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们看看这个文件包含了什么。我们在来自<a class="ae lz" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>的节点图像上构建我们的图像。然后我们将主工作目录设置为<code class="fe mm mn mo mp b">/blogapp</code>文件夹(可选)。我们将<code class="fe mm mn mo mp b">package.json</code>复制到<code class="fe mm mn mo mp b">/blogapp</code>库中，并运行<code class="fe mm mn mo mp b">npm install</code>来安装<code class="fe mm mn mo mp b">node_modules</code>。</p><p id="d244" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">之后，我们将剩余的内容复制到<code class="fe mm mn mo mp b">/blogapp</code>中。然后我们公开端口<code class="fe mm mn mo mp b">8080</code>，因为我们的<code class="fe mm mn mo mp b">server.js</code>监听端口<code class="fe mm mn mo mp b">8080</code> - <code class="fe mm mn mo mp b">app.listen(8080)</code>，如果你的应用运行在不同的端口上，你应该公开那个端口而不是<code class="fe mm mn mo mp b">8080</code>。最后，我们通过运行<code class="fe mm mn mo mp b">node server.js</code>启动我们的服务器</p><p id="23db" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">确保您在项目的根级别创建了docker文件。</p><h2 id="01e5" class="ma jz iq bd ka mb mc dn ke md me dp ki lh mf mg km ll mh mi kq lp mj mk ku ml bi translated">2.使用Dockerfile文件构建映像</h2><p id="b571" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在我们有了docker文件，我们可以创建一个图像。在您的项目存储库中运行</p><p id="a728" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe mm mn mo mp b">docker build . -t blogapp:1.0</code></p><p id="f417" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe mm mn mo mp b">docker build .</code> <strong class="ky ir">使用您的docker文件</strong>构建新图像。使用<code class="fe mm mn mo mp b">-t option</code>给你的图像命名(<code class="fe mm mn mo mp b">blogapp</code>)和版本(<code class="fe mm mn mo mp b">1.0</code>)</p><p id="db2a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">检查它是否创建成功，运行docker images并在列表中找到您的图像</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="350b" class="ma jz iq mp b gy my mz l na nb">REPOSITORY | TAG   | IMAGE ID     | CREATED        | SIZE<br/>blogapp    | 1.0   | a6778e6bb622 | 5 seconds ago  | 914MB</span></pre><h2 id="0b51" class="ma jz iq bd ka mb mc dn ke md me dp ki lh mf mg km ll mh mi kq lp mj mk ku ml bi translated">3.创建一个容器</h2><p id="da81" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我的应用程序中，我将帖子作为文本文件存储在<code class="fe mm mn mo mp b">/post</code>文件夹中。因此docker也会这样做，并将帖子保存在容器内的<code class="fe mm mn mo mp b">/post</code>文件夹中。但是之后，如果容器被移除，这些在<code class="fe mm mn mo mp b">/post</code>文件夹中的帖子将会随着容器一起被移除。</p><p id="86ab" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以我们需要某种方法来备份这个<code class="fe mm mn mo mp b">/post</code>文件夹，以确保我们不会丢失用户数据。为此，我们可以使用<strong class="ky ir"> docker volumes </strong>来安全地备份重要数据。</p><p id="eb5f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><a class="ae lz" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">卷</strong> </a>是您主机上的文件夹，它们被“挂载”(可用)在容器中。即使容器被移除，卷仍然存在。容器可以在卷中读写数据。</p><p id="1b4a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，我将基于刚刚构建的图像创建我的容器。我还将在同一个命令中创建一个卷来存储来自<code class="fe mm mn mo mp b">/post</code>文件夹的所有文件，以确保容器被移除时的安全。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="dd58" class="ma jz iq mp b gy my mz l na nb">docker run -p 3000:8080 —-name blogapp -v post:/blogapp/post a6778e6bb622</span></pre><p id="cb0d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe mm mn mo mp b">-p 3000:8080</code>指定您将在哪个端口上运行容器中的这个应用程序。<code class="fe mm mn mo mp b">8080</code>是您在<strong class="ky ir">docker文件</strong>中指定的相同端口，这是我们公开的端口，而<code class="fe mm mn mo mp b">3000</code>是应用程序将在其上运行的容器中的端口。使用<code class="fe mm mn mo mp b">--name</code>选项，您可以命名您的容器(blogapp)。</p><p id="40d3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe mm mn mo mp b">-v post:/blogapp/post</code>创建一个名为<code class="fe mm mn mo mp b">post</code>的<strong class="ky ir">卷</strong>，它被挂载到我们容器内的<code class="fe mm mn mo mp b">/blogapp/post</code>文件夹中。这意味着在我们的应用程序中创建的任何post都将存储在我们主机上名为<code class="fe mm mn mo mp b">post</code>的卷中。而<code class="fe mm mn mo mp b">a6778e6bb622</code>是我们用Dockerfile构建的图像的id。</p><p id="cf4f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">运行<code class="fe mm mn mo mp b">docker ps</code>再次检查容器是否正在运行</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="978b" class="ma jz iq mp b gy my mz l na nb">CONTAINER ID | IMAGE        | ... | NAMES<br/>ab31a3adb143 | a6778e6bb622 | ... | blogapp</span></pre><h2 id="0a38" class="ma jz iq bd ka mb mc dn ke md me dp ki lh mf mg km ll mh mi kq lp mj mk ku ml bi translated">4.打开应用程序并将数据储存在宗卷中</h2><p id="cadc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在你的容器在端口<code class="fe mm mn mo mp b">3000</code>上运行，如果你访问<a class="ae lz" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>你应该会看到你的应用在运行。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/003f29992188380d823addd459efee47.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*cBvvS5Xv7QLihjyzwqNOag.png"/></div></figure><p id="ab0b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如，试着创建一个标题为<code class="fe mm mn mo mp b">firstpost</code>和任何内容的新帖子。然后访问<a class="ae lz" href="http://localhost:3000/post/post2.txt" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/post/first post . txt</a>。你应该在这里看到你的帖子</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/6274518d5a1ca283667eed712834aa44.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*wAj7B_WmfPTp7fnmtf9WvQ.png"/></div></figure><p id="6a51" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要查看卷是否已创建，请运行<code class="fe mm mn mo mp b">docker volume ls</code></p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="1f2f" class="ma jz iq mp b gy my mz l na nb">DRIVER | VOLUME NAME<br/>local  | post</span></pre><h2 id="f68d" class="ma jz iq bd ka mb mc dn ke md me dp ki lh mf mg km ll mh mi kq lp mj mk ku ml bi translated">5.停止、移除、重新启动容器，并确保数据存储在卷中</h2><p id="938c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用容器名称<code class="fe mm mn mo mp b">docker stop blogapp</code>停止容器</p><p id="d470" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">取出容器<code class="fe mm mn mo mp b">docker rm blogapp</code></p><p id="e2ca" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，用我们上面使用的命令重新启动您的容器</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="3475" class="ma jz iq mp b gy my mz l na nb">docker run -p 3000:8080 — name blogapp -v post:/blogapp/post a6778e6bb622</span></pre><p id="59b0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">并访问<a class="ae lz" href="http://localhost:3000/post/post2.txt" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/post/first post . txt</a>。您应该仍然可以看到您创建的文章，这意味着它存储在docker卷中，并且在容器移除后仍然存在。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/6274518d5a1ca283667eed712834aa44.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*wAj7B_WmfPTp7fnmtf9WvQ.png"/></div></figure><h1 id="19cc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概括起来</h1><p id="06e6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是一个使用卷将nodejs应用程序归档的例子。正如我们所见，容器可以读/写数据，但是如果容器被移除，写入的数据将会丢失。因此，我们使用docker卷，它是主机上的文件夹，由docker管理，并装入容器中。</p><p id="4687" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在本例中，我们使用了一个命名卷。有3种类型的卷可供使用—命名卷、匿名卷和绑定装载。如果你想了解更多，我会在下面的参考资料中留下一个链接。</p><h1 id="cf44" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">资源</h1><p id="084f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae lz" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-started/overview/</a><br/><a class="ae lz" href="https://docs.docker.com/get-started/02_our_app/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-started/02_our_app/</a><br/><a class="ae lz" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/storage/volumes/</a><br/><a class="ae lz" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a><br/><a class="ae lz" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/docker file _ best-practices/</a></p></div></div>    
</body>
</html>