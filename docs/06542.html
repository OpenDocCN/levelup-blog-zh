<html>
<head>
<title>Learning Python: Inheritance and Polymorphism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Python:继承和多态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-python-inheritance-and-polymorphism-1ec7b3e53fb7?source=collection_archive---------7-----------------------#2020-12-04">https://levelup.gitconnected.com/learning-python-inheritance-and-polymorphism-1ec7b3e53fb7?source=collection_archive---------7-----------------------#2020-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ac1602f01591fb6e3492b810476d4be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CKPFPttuBmX0AhKC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本工程图</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f1a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python编程中采用面向对象编程(OOP)的一个重要原因是利用了两个关键的OOP概念——继承和多态。在本文中，我将讨论如何在Python编程中使用这两个概念。</p><h1 id="463f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">继承术语</h1><p id="5943" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">继承是一个类定义使用已经在另一个类中定义的属性和方法的能力。首先定义一组属性和方法的类被称为<em class="mh">超类</em>。继承这些属性和方法的类被称为<em class="mh">子类</em>。</p><p id="ace1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">超类及其子类的集合被称为<em class="mh">继承层次</em>。子类可以从其他子类派生。这被称为多重继承，但我不打算在本文中探讨它。</p><h1 id="58f3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">继承基础</h1><p id="5cb1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">子类是通过在子类的定义中提供对超类的引用来创建的。为了演示这一点，我将创建一个<code class="fe mi mj mk ml b">Shape</code>类，它将作为一组子类的超类，这些子类定义特定类型的形状，如圆形和正方形。</p><p id="f892" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个<code class="fe mi mj mk ml b">Shape</code>类定义和一个测试该类的简短程序:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4a6e" class="mu lf it ml b gy mv mw l mx my">class Shape:<br/>  def __init__(self,name,x,y):<br/>    self.name = name<br/>  <br/>  self.x = x<br/>  self.y = y</span><span id="e4eb" class="mu lf it ml b gy mz mw l mx my">def draw(self):<br/>  print("Drawing",self.name,"at origin x:",self.x,"y:",self.y)</span><span id="dcf2" class="mu lf it ml b gy mz mw l mx my">s = Shape("Shape",1,2)<br/>s.draw()</span></pre><p id="6c57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="5404" class="mu lf it ml b gy mv mw l mx my">Drawing Shape at x: 1 y: 2</span></pre><p id="1e3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们定义一个继承自<code class="fe mi mj mk ml b">Shape</code>类的<code class="fe mi mj mk ml b">Rectangle</code>类。我们从识别<code class="fe mi mj mk ml b">Rectangle</code>是一个子类开始，在派生类定义的第一行括号中放置子类的名称:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="54db" class="mu lf it ml b gy mv mw l mx my">class Rectangle(Shape):</span></pre><p id="a969" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来要做的是定义<code class="fe mi mj mk ml b">__init__</code>方法。我们想利用继承，不需要重新定义我们可以在子类定义中重用的方法。记住这一点，下面是对<code class="fe mi mj mk ml b">Rectangle</code>类<code class="fe mi mj mk ml b">__init__</code>方法的定义:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="3ee1" class="mu lf it ml b gy mv mw l mx my">def __init__(self,x,y,height,width):<br/>  Shape.__init__(self,x,y)<br/>  self.name = "Rectangle"<br/>  self.height = height<br/>  self.width = width</span></pre><p id="ae58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里要注意的主要事情是我如何从超类<code class="fe mi mj mk ml b">Shape</code>中调用<code class="fe mi mj mk ml b">__init__</code>方法，这样我就不必再次写出那个定义。这是通过继承实现良好代码重用的本质。</p><p id="b9f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我们需要一个“画”矩形的方法。在这里，我决定演示一个被称为<em class="mh">覆盖</em>的概念，这意味着我将重新定义当从<code class="fe mi mj mk ml b">Rectangle</code>对象调用draw方法时它做什么。定义如下:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="0b23" class="mu lf it ml b gy mv mw l mx my">#overriding super class definition of the draw method<br/>def draw(self):<br/>  print("Drawing",self.name,"at origin x:",self.x,"y:",self.y)<br/>  print("Height:",self.height,"Width:",self.width)</span></pre><p id="2298" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们将所有这些合并到一个程序中，该程序创建一个<code class="fe mi mj mk ml b">Shape</code>对象和一个<code class="fe mi mj mk ml b">Rectangle</code>对象，以及这些类的定义:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="adac" class="mu lf it ml b gy mv mw l mx my">class Shape:<br/>  def __init__(self,x,y):<br/>    self.name = "Shape"<br/>    self.x = x<br/>    self.y = y</span><span id="945e" class="mu lf it ml b gy mz mw l mx my">  def draw(self):<br/>    print("Drawing",self.name,"at origin x:",self.x,"y:",self.y)</span><span id="f866" class="mu lf it ml b gy mz mw l mx my">class Rectangle(Shape):<br/>  def __init__(self,x,y,height,width):<br/>    Shape.__init__(self,x,y)<br/>    self.name = "Rectangle"<br/>    self.height = height<br/>    self.width = width</span><span id="5a82" class="mu lf it ml b gy mz mw l mx my">  #overriding base class definition<br/>  def draw(self):<br/>    print("Drawing",self.name,"at origin x:",self.x,"y:",self.y)<br/>    print("Height:",self.height,"Width:",self.width)</span><span id="8e8d" class="mu lf it ml b gy mz mw l mx my">sh = Shape(3,4)<br/>sh.draw()<br/>rec = Rectangle(1,2,5,10)<br/>rec.draw()</span></pre><p id="5084" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="dd6e" class="mu lf it ml b gy mv mw l mx my">Drawing Shape at origin x: 3 y: 4<br/>Drawing Rectangle at origin x: 1 y: 2<br/>Height: 5 Width: 10</span></pre><p id="5eb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总结一下我们在继承方面的进展，我们已经看到子类可以继承超类的属性和方法，因此这些属性和方法不必在子类中重新定义。这是一个强大的编程特性，允许代码重用，允许程序员遵循“不要重复自己”或DRY的原则。</p><p id="abd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也是Python中类多态的一个例子。系统将计算出它遇到了什么类型的对象，并调用适当的方法。</p><h1 id="3ddd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python中的其他多态性类型</h1><p id="5951" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为Python是一种动态类型的编程语言，所以很容易处理类对象的集合。这在像C++这样的语言中是不正确的，c++是强类型的，需要程序员通过一些限制来正确地处理类对象集合。</p><p id="d6ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，我可以简单地声明一个新的列表，然后随心所欲地向列表中添加对象。当我想访问对象时，我可以简单地遍历列表并执行任何我想要的操作。Python将知道如何处理每个方法调用</p><p id="1416" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，我创建了一个基于<code class="fe mi mj mk ml b">Shape</code>的对象列表，并从列表中“画”出它们。下面是代码和输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="cd04" class="mu lf it ml b gy mv mw l mx my">class Shape:<br/>  def __init__(self,x,y):<br/>    self.name = "Shape"<br/>    self.x = x<br/>    self.y = y</span><span id="48fe" class="mu lf it ml b gy mz mw l mx my">  def draw(self):<br/>    print("Drawing",self.name,"at origin x:",self.x,"y:",self.y)</span><span id="338a" class="mu lf it ml b gy mz mw l mx my">class Rectangle(Shape):<br/>  def __init__(self,x,y,height,width):<br/>    Shape.__init__(self,x,y)<br/>    self.name = "Rectangle"<br/>    self.height = height<br/>    self.width = width</span><span id="8f2a" class="mu lf it ml b gy mz mw l mx my">  #overriding base class definition<br/>  def draw(self):<br/>    print("Drawing",self.name,"at origin x:",self.x,"y:",self.y)<br/>    print("Height:",self.height,"Width:",self.width)</span><span id="55a1" class="mu lf it ml b gy mz mw l mx my">class Circle(Shape):<br/>  def __init__(self, x,y,radius):<br/>    Shape.__init__(self,x,y)<br/>    self.name = "Circle"<br/>    self.radius = radius</span><span id="0161" class="mu lf it ml b gy mz mw l mx my">  def draw(self):<br/>    print("Drawing",self.name,"at origin x:",self.x,"y:",self.y)<br/>    print("Radius:",self.radius)</span><span id="d9f1" class="mu lf it ml b gy mz mw l mx my">sh = Shape(3,4)<br/>rec = Rectangle(1,2,5,10)<br/>circ = Circle(5,6,5)<br/>shapes = []<br/>shapes.append(sh)<br/>shapes.append(rec)<br/>shapes.append(circ)<br/>print()<br/>print()<br/>print("Drawing set of shapes:")<br/>for sh in shapes:<br/>  sh.draw()</span></pre><p id="27a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="6dc9" class="mu lf it ml b gy mv mw l mx my">Drawing set of shapes:<br/>Drawing Shape at origin x: 3 y: 4<br/>Drawing Rectangle at origin x: 1 y: 2<br/>Height: 5 Width: 10<br/>Drawing Circle at origin x: 5 y: 6<br/>Radius: 5</span></pre><p id="dde3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于多态性，Python知道调用哪个draw方法，即使所有对象都存储在同一个列表中。</p><h1 id="ec91" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">功能多态性</h1><p id="e75f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们谈到多态性时，我还需要介绍一下<em class="mh">函数多态性</em>。Python中有很多内置函数多态性的例子。<code class="fe mi mj mk ml b">print</code>函数就是一个很好的例子。</p><p id="a382" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以将一个数字、一个字符串、一个列表和许多其他对象传递给<code class="fe mi mj mk ml b">print</code>函数，它会知道如何恰当地处理这些对象。<code class="fe mi mj mk ml b">len</code>功能是另一个例子。如果您将一个字符串传递给<code class="fe mi mj mk ml b">len</code>函数，它将打印字符串中的字符数。如果你传递一个列表，它会计算列表中的元素。如果你传递给<code class="fe mi mj mk ml b">len</code>一个字典，它会计算键/值对。这是函数多态性的另一个很好的例子。</p><p id="c094" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以对类对象做同样的事情。以下函数打印传递给它的<code class="fe mi mj mk ml b">Shape</code>对象的名称:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8355" class="mu lf it ml b gy mv mw l mx my">def printName(shape):<br/>  print(shape.name)</span></pre><p id="63dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用函数的程序:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="61b4" class="mu lf it ml b gy mv mw l mx my">sh = Shape(3,4)<br/>rec = Rectangle(1,2,5,10)<br/>circ = Circle(5,6,5)<br/>printName(sh)<br/>printName(rec)<br/>printName(circ)</span></pre><p id="98e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="928f" class="mu lf it ml b gy mv mw l mx my">Shape<br/>Rectangle<br/>Circle</span></pre><p id="7eba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就完成了我想说的关于类继承和多态的内容。现在，您已经对Python的主要特性有了一个相当完整但简短的介绍。在我的下一篇文章中，当我结束学习Python的这个系列时，我将介绍我在以前的文章中没有涉及的一些特性。</p><p id="de31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请发电子邮件至<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">mmmcmillan1@att.net</a>告诉我您的意见和建议，或者在下面添加回复。</p></div></div>    
</body>
</html>