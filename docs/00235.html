<html>
<head>
<title>React Native: Adding Push Notifications to your App with Expo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native:通过Expo向您的应用程序添加推送通知</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-native-adding-push-notifications-to-your-app-with-expo-8e4b659ddbfb?source=collection_archive---------0-----------------------#2018-10-16">https://levelup.gitconnected.com/react-native-adding-push-notifications-to-your-app-with-expo-8e4b659ddbfb?source=collection_archive---------0-----------------------#2018-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/26b3bc18631aac4f7390052ecbd50fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4MP5L_Mq-KFyIB6tFffRw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@joannakosinska" rel="noopener ugc nofollow" target="_blank">乔安娜·科辛斯卡</a>拍摄。来源:https://unsplash.com/photos/LbMy35NyCNg<a class="ae kc" href="https://unsplash.com/photos/LbMy35NyCNg" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="9821" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我的书《反应本地烹饪书》的摘录，第二版，由Packt出版社出版，将于今年冬天出版。</p><p id="7834" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推送通知是一种很好的方式，通过不断提供与用户相关的应用特定数据，在应用和用户之间提供持续的反馈循环。当新消息到达时，消息应用程序会发送通知。提醒应用程序会显示一个通知，提醒用户在特定时间或位置的任务。播客应用程序可以使用通知来通知用户新的剧集已经发布。购物应用程序可以使用通知来提醒用户结算限时交易。</p><p id="b40a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推送通知是一种行之有效的增加用户互动和保留的方式。如果你的应用程序使用时间敏感或基于事件的数据，推送通知可能是一个有价值的资产。在本教程中，我们将使用Expo的推送通知实现，它简化了普通React本地项目所需的一些设置。如果需求或者你的app要求非世博项目，我会推荐考虑<a class="ae kc" href="https://github.com/zo0r/react-native-push-notification" rel="noopener ugc nofollow" target="_blank">https://github.com/zo0r/react-native-push-notification</a>的<code class="fe lc ld le lf b">react-native-push-notification</code>套餐。</p><p id="8a0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将制作一个非常简单的带有推送通知的消息应用程序。我们将请求适当的权限，然后向我们将要构建的Express服务器注册推送通知令牌。我们还将呈现一个<code class="fe lc ld le lf b">TextInput</code>,供用户输入消息。当按下<strong class="kf ir">发送</strong>按钮时，消息将被发送到我们的服务器，服务器将通过Expo的推送通知服务器向所有在我们的Express服务器上注册了令牌的设备发送推送通知，以及来自应用程序的消息。</p><p id="19c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于Expo内置的推送通知服务，为每个本地设备创建通知的复杂工作被卸载到Expo托管的后端。我们在本教程中构建的Express服务器将把每个推送通知的JSON对象传递给Expo后端，剩下的就交给它了。下图来自Expo文档，展示了推送通知的生命周期。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/b1b633dcfcf7fc39c0e17a7d8b4ca766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mT0p0Sxlry6C4RA7.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:<a class="ae kc" href="https://docs.expo.io/versions/latest/guides/push-notifications" rel="noopener ugc nofollow" target="_blank">https://docs . Expo . io/versions/latest/guides/push-notifications</a></figcaption></figure><p id="c6fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然使用Expo实现推送通知的设置工作比其他方式要少，但是技术的需求仍然意味着我们需要运行一个服务器来处理注册和发送通知，这意味着本教程将比大多数教程稍长一些。我们开始吧！</p><h1 id="7edc" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">做好准备</h1><p id="97c9" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在这个应用程序中，我们需要做的第一件事就是请求设备允许我们使用推送通知。不幸的是，推送通知权限在模拟器中无法正常工作，所以需要一个真实的设备来测试这个应用程序。</p><p id="56d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要能够从本地主机之外的地址访问推送通知服务器。在现实世界的设置中，推送通知服务器已经有了一个公共url，但是在开发环境中，最简单的解决方案是创建一个隧道，将开发推送通知服务器暴露给互联网。为此，我们将使用ngrok工具，因为它是一个成熟的、健壮的、非常易于使用的解决方案。你可以在https://ngrok.com了解更多关于这个软件的信息。</p><p id="c604" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先使用以下命令通过npm全局安装ngrok:</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="ec3d" class="ms lm iq lf b gy mt mu l mv mw">npm i -g ngrok</span></pre><p id="bf3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装完成后，您可以通过使用https参数执行ngrok来创建一个从internet到本地计算机端口的隧道:</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="ffdd" class="ms lm iq lf b gy mt mu l mv mw">ngrok https [port-to-expose]</span></pre><p id="c4b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在教程的后面使用这个命令来公开开发服务器。</p><p id="bf0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用Expo为这个教程创建一个新的应用程序。我们就叫它<code class="fe lc ld le lf b">push-notifications</code>。对于本教程，我们需要三个额外的npm包:<code class="fe lc ld le lf b">express</code>用于推送通知服务器，<code class="fe lc ld le lf b">esm</code>用于在服务器上使用ES6语法支持，<code class="fe lc ld le lf b">expo-server-sdk</code>用于处理推送通知。用纱线安装它们:</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="b832" class="ms lm iq lf b gy mt mu l mv mw">yarn add express esm expo-server-sdk</span></pre><p id="722f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或npm:</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="3f7d" class="ms lm iq lf b gy mt mu l mv mw">npm install express esm expo-server-sdk --save</span></pre><h1 id="4300" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">如何</h1><p id="6fb8" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">1.让我们从构建应用程序开始。我们将开始向<code class="fe lc ld le lf b">App.js</code>添加我们需要的依赖项。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="3b02" class="ms lm iq lf b gy mt mu l mv mw">import React from 'react';<br/>import {<br/>  StyleSheet,<br/>  Text,<br/>  View,<br/>  TextInput,<br/>  Modal,<br/>  TouchableOpacity<br/>} from 'react-native';<br/>import { Permissions, Notifications } from 'expo';</span></pre><p id="111d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.我们将为服务器上的API端点声明两个常量，但是url将在我们稍后运行服务器时由ngrok生成，所以我们将在那时更新这些常量的值。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="aa3f" class="ms lm iq lf b gy mt mu l mv mw">const PUSH_REGISTRATION_ENDPOINT = 'http://<strong class="lf ir">generated-ngrok-url</strong>/token';<br/>const MESSAGE_ENPOINT = 'http://<strong class="lf ir">generated-ngrok-url</strong>/message';</span></pre><p id="caf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.让我们创建<code class="fe lc ld le lf b">App</code>组件并初始化<code class="fe lc ld le lf b">state</code>对象。我们需要一个通知属性来保存由<code class="fe lc ld le lf b">Notifications</code>监听器接收的<code class="fe lc ld le lf b">notifications</code>，我们将在后面的步骤中定义它。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="ff6d" class="ms lm iq lf b gy mt mu l mv mw">export default class App extends React.Component {<br/>  state = {<br/>    notification: null,<br/>    messageText: ''<br/>  }</span><span id="fa0d" class="ms lm iq lf b gy mx mu l mv mw"> // Defined in following steps<br/>}</span></pre><p id="351a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.让我们定义将处理向服务器注册推送通知令牌的方法。我们将通过<code class="fe lc ld le lf b">Permissions</code>组件上的<code class="fe lc ld le lf b">askAsync</code>方法向用户请求通知权限。如果许可被授予，从设备的<code class="fe lc ld le lf b">Notifications</code>组件的<code class="fe lc ld le lf b">getExpoPushTokenAsync</code>方法获取令牌。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="a319" class="ms lm iq lf b gy mt mu l mv mw">registerForPushNotificationsAsync = async () =&gt; {<br/>    const { status } = await Permissions.askAsync(Permissions.NOTIFICATIONS);<br/>    if (status !== 'granted') {<br/>      return;<br/>    }<br/>    let token = await Notifications.getExpoPushTokenAsync();</span><span id="b71b" class="ms lm iq lf b gy mx mu l mv mw">    // Defined in following steps<br/>  }</span></pre><p id="fe54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.一旦我们有了合适的令牌，我们将把它发送到推送通知服务器进行注册。然后，我们将向<code class="fe lc ld le lf b">PUSH_REGISTRATION_ENDPOINT</code>发出POST请求，在请求体中发送一个<code class="fe lc ld le lf b">token</code>对象和<code class="fe lc ld le lf b">user</code>对象。我已经对用户对象中的值进行了硬编码，但是在真正的应用程序中，这将是您为当前用户存储的元数据。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="360b" class="ms lm iq lf b gy mt mu l mv mw">registerForPushNotificationsAsync = async () =&gt; {<br/>    // Defined in above step</span><span id="6091" class="ms lm iq lf b gy mx mu l mv mw"><strong class="lf ir">    return fetch(PUSH_REGISTRATION_ENDPOINT, {</strong><br/><strong class="lf ir">      method: 'POST',</strong><br/><strong class="lf ir">      headers: {</strong><br/><strong class="lf ir">        'Accept': 'application/json',</strong><br/><strong class="lf ir">        'Content-Type': 'application/json',</strong><br/><strong class="lf ir">      },</strong><br/><strong class="lf ir">      body: JSON.stringify({</strong><br/><strong class="lf ir">        token: {</strong><br/><strong class="lf ir">          value: token,</strong><br/><strong class="lf ir">        },</strong><br/><strong class="lf ir">        user: {</strong><br/><strong class="lf ir">          username: 'warly',</strong><br/><strong class="lf ir">          name: 'Dan Ward'</strong><br/><strong class="lf ir">        },</strong><br/><strong class="lf ir">      }),</strong><br/><strong class="lf ir">    });</strong></span><span id="f752" class="ms lm iq lf b gy mx mu l mv mw">    // Defined in next step<br/>  }</span></pre><p id="02cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.注册令牌后，我们将设置一个事件监听器来监听应用程序打开和前景化时发生的任何通知。在某些情况下，我们将需要手动处理显示来自传入推送通知的信息。查看本教程末尾的<em class="lb">工作原理</em>部分，了解为什么这是必要的以及如何利用它。我们将在下一步定义处理程序。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="6fe7" class="ms lm iq lf b gy mt mu l mv mw"><strong class="lf ir">registerForPushNotificationsAsync = async () =&gt; {</strong><br/>    // Defined in above steps</span><span id="a004" class="ms lm iq lf b gy mx mu l mv mw">    this.notificationSubscription = Notifications.addListener(this.handleNotification);<br/><strong class="lf ir">  }</strong></span></pre><p id="1f98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">7.每当接收到新的通知，就会运行<code class="fe lc ld le lf b">handleNotification</code>方法。我们将把传递给这个回调函数的新通知存储在<code class="fe lc ld le lf b">state</code>对象上，供以后在<code class="fe lc ld le lf b">render</code>函数中使用。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="d23e" class="ms lm iq lf b gy mt mu l mv mw">handleNotification = (notification) =&gt; {<br/>    this.setState({ notification });<br/>  }</span></pre><p id="420d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">8.我们希望我们的应用程序请求使用推送通知的权限，并在应用程序启动时注册推送通知令牌。我们将利用<code class="fe lc ld le lf b">componentDidMount</code>生命周期挂钩来运行我们的<code class="fe lc ld le lf b">registerForPushNotificationsAsync</code>方法。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="013d" class="ms lm iq lf b gy mt mu l mv mw">componentDidMount() {<br/>    this.registerForPushNotificationsAsync();<br/>  }</span></pre><p id="d6f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">9.为了保持教程的简单，用户界面将会非常简洁。它由一个用于消息文本的<code class="fe lc ld le lf b">TextInput</code>、一个用于发送消息的<strong class="kf ir"> Send </strong>按钮和一个用于显示通知监听器所听到的任何通知的<code class="fe lc ld le lf b">View</code>组成。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="f818" class="ms lm iq lf b gy mt mu l mv mw">render() {<br/>    return (<br/>      &lt;View style={styles.container}&gt;<br/>        &lt;TextInput<br/>          value={this.state.messageText}<br/>          onChangeText={this.handleChangeText}<br/>          style={styles.textInput}<br/>        /&gt;<br/>        &lt;TouchableOpacity<br/>          style={styles.button}<br/>          onPress={this.sendMessage}<br/>        &gt;<br/>          &lt;Text style={styles.buttonText}&gt;Send&lt;/Text&gt;<br/>        &lt;/TouchableOpacity&gt;<br/>        {this.state.notification ?<br/>          this.renderNotification()<br/>        : null}<br/>      &lt;/View&gt;<br/>    );<br/>  }</span></pre><p id="335e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">10.上一步中定义的<code class="fe lc ld le lf b">TextInput</code>组件缺少其<code class="fe lc ld le lf b">onChangeText</code>属性所需的方法。接下来让我们创建这个方法。它只是将用户输入的文本保存到<code class="fe lc ld le lf b">this.state.messageText</code>中，这样它就可以被<code class="fe lc ld le lf b">value</code>道具和其他地方使用。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="cfe8" class="ms lm iq lf b gy mt mu l mv mw">handleChangeText = (text) =&gt; {<br/>    this.setState({ messageText: text });<br/>  }</span></pre><p id="03f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">11.当用户按下按钮时，<code class="fe lc ld le lf b">TouchableOpacity</code>组件的<code class="fe lc ld le lf b">onPress</code>属性正在调用<code class="fe lc ld le lf b">sendMessage</code>方法来发送消息文本。在这个函数中，我们将获取消息文本并将其发布到我们的推送通知服务器上的<code class="fe lc ld le lf b">MESSAGE_ENDPOINT</code>。服务器将从那里处理事情。一旦消息发出，我们将清除<code class="fe lc ld le lf b">state</code>上的<code class="fe lc ld le lf b">messageText</code>属性。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="bdb2" class="ms lm iq lf b gy mt mu l mv mw">sendMessage = async () =&gt; {<br/>    fetch(MESSAGE_ENPOINT, {<br/>      method: 'POST',<br/>      headers: {<br/>        Accept: 'application/json',<br/>        'Content-Type': 'application/json',<br/>      },<br/>      body: JSON.stringify({<br/>        message: this.state.messageText,<br/>      }),<br/>    });<br/>    this.setState({ messageText: '' });<br/>  }</span></pre><p id="f735" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">12.我们为<code class="fe lc ld le lf b">App</code>需要的最后一件东西是款式。由于本教程是关于通知，而不是对React本机应用程序进行样式化，所以我们不会深入研究样式和布局，尽管这里没有发生非常复杂的事情。你可以在<a class="ae kc" href="https://facebook.github.io/react-native/docs/stylesheet" rel="noopener ugc nofollow" target="_blank">文档中阅读更多关于React Native的<code class="fe lc ld le lf b">StyleSheet</code>组件，以及在</a><a class="ae kc" href="https://facebook.github.io/react-native/docs/flexbox" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读flexbox如何在React Native中工作。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="915e" class="ms lm iq lf b gy mt mu l mv mw">const styles = StyleSheet.create({<br/>  container: {<br/>    flex: 1,<br/>    backgroundColor: '#474747',<br/>    alignItems: 'center',<br/>    justifyContent: 'center',<br/>  },<br/>  textInput: {<br/>    height: 50,<br/>    width: 300,<br/>    borderColor: '#f6f6f6',<br/>    borderWidth: 1,<br/>    backgroundColor: '#fff',<br/>    padding: 10<br/>  },<br/>  button: {<br/>    padding: 10<br/>  },<br/>  buttonText: {<br/>    fontSize: 18,<br/>    color: '#fff'<br/>  },<br/>  label: {<br/>    fontSize: 18<br/>  }<br/>});</span></pre><p id="f419" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">13.React本机应用程序部分已经完成，让我们来看看服务器部分。首先，我们将在项目的根目录下创建一个新的<code class="fe lc ld le lf b">server</code>文件夹，其中包含一个<code class="fe lc ld le lf b">index.js</code>文件。让我们首先导入<code class="fe lc ld le lf b">express</code>来运行服务器，导入<code class="fe lc ld le lf b">expo-server-sdk</code>来处理注册和发送推送通知。我们将创建一个express server应用程序并存储在const <code class="fe lc ld le lf b">app</code>中，并将expo server SDK的新实例存储在const <code class="fe lc ld le lf b">expo</code>中。我们还将添加一个<code class="fe lc ld le lf b">savedPushTokens</code>数组，用于存储向React本机应用程序注册的任何令牌，以及一个<code class="fe lc ld le lf b">PORT_NUMBER</code>常量，用于我们希望运行服务器的端口。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="3812" class="ms lm iq lf b gy mt mu l mv mw">import express from 'express';<br/>import Expo from 'expo-server-sdk';</span><span id="4142" class="ms lm iq lf b gy mx mu l mv mw">const app = express();<br/>const expo = new Expo();</span><span id="b56c" class="ms lm iq lf b gy mx mu l mv mw">let savedPushTokens = [];<br/>const PORT_NUMBER = 3000;</span></pre><p id="4c0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">14.我们的服务器将需要公开两个端点(一个用于注册令牌，一个用于接受来自React本机应用程序的消息)，因此我们将创建两个函数，当这些路由被命中时将执行这两个函数。我们将首先定义<code class="fe lc ld le lf b">saveToken</code>函数。它只是获取一个令牌，检查它是否存储在<code class="fe lc ld le lf b">savedPushTokens</code>数组中，如果它不存在，就把它推到数组中。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="bb06" class="ms lm iq lf b gy mt mu l mv mw">const saveToken = (token) =&gt; {<br/>  if (savedPushTokens.indexOf(token === -1)) {<br/>    savedPushTokens.push(token);<br/>  }<br/>}</span></pre><p id="0939" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">15.我们的服务器需要的另一个功能是一个处理程序，用于在从React本地应用程序收到消息时发送推送通知。我们将遍历所有保存到<code class="fe lc ld le lf b">savedPushTokens</code>数组的令牌，并为每个令牌创建一个消息对象。每个消息对象都有一个标题“消息已收到！”这将在推送通知中以粗体显示，消息文本作为通知的正文。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="1b68" class="ms lm iq lf b gy mt mu l mv mw">const handlePushTokens = (message) =&gt; {<br/>  let notifications = [];<br/>  for (let pushToken of savedPushTokens) {<br/>    if (!Expo.isExpoPushToken(pushToken)) {<br/>      console.error(`Push token ${pushToken} is not a valid Expo push token`);<br/>      continue;<br/>    }<br/>    notifications.push({<br/>      to: pushToken,<br/>      sound: 'default',<br/>      title: 'Message received!',<br/>      body: message,<br/>      data: { message }<br/>    })<br/>  }</span><span id="5cf5" class="ms lm iq lf b gy mx mu l mv mw">  // Defined in following step<br/>}</span></pre><p id="d874" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">16.一旦我们有了一组消息，我们就可以把它们发送到Expo的服务器上，然后服务器会把推送通知发送到所有注册的设备上。我们将通过expo服务器的<code class="fe lc ld le lf b">chunkPushNotifications</code>和<code class="fe lc ld le lf b">sendPushNotificationsAsync</code>方法发送消息数组，并通过<code class="fe lc ld le lf b">console.log</code>向服务器控制台发送适当的成功回执或错误。在本教程末尾的<em class="lb">工作原理</em>部分有更多关于这种工作原理的内容。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="e97d" class="ms lm iq lf b gy mt mu l mv mw">const handlePushTokens = (message) =&gt; {<br/>  // Defined in previous step</span><span id="dd84" class="ms lm iq lf b gy mx mu l mv mw"><strong class="lf ir">  let chunks = expo.chunkPushNotifications(notifications);</strong></span><span id="77ce" class="ms lm iq lf b gy mx mu l mv mw"><strong class="lf ir">  (async () =&gt; {</strong><br/><strong class="lf ir">    for (let chunk of chunks) {</strong><br/><strong class="lf ir">      try {</strong><br/><strong class="lf ir">        let receipts = await expo.sendPushNotificationsAsync(chunk);</strong><br/><strong class="lf ir">        console.log(receipts);</strong><br/><strong class="lf ir">      } catch (error) {</strong><br/><strong class="lf ir">        console.error(error);</strong><br/><strong class="lf ir">      }</strong><br/><strong class="lf ir">    }</strong><br/><strong class="lf ir">  })();</strong><br/>}</span></pre><p id="a445" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">17.现在我们已经定义了处理推送通知和消息的函数，让我们通过创建API端点来公开这些函数。如果您不熟悉Express，它是一个强大且易于使用的框架，用于在Node中运行web服务器。在<a class="ae kc" href="https://expressjs.com/en/starter/basic-routing.html" rel="noopener ugc nofollow" target="_blank">https://expressjs.com/en/starter/basic-routing.html</a>你可以通过基本路线文件快速掌握路线的基本知识。<br/>我们将使用JSON数据，所以第一步将通过调用<code class="fe lc ld le lf b">express.json()</code>来应用JSON解析器中间件。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="e0be" class="ms lm iq lf b gy mt mu l mv mw">app.use(express.json());</span></pre><p id="2e2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">18.即使我们不会真正使用服务器的根路径(<code class="fe lc ld le lf b">/</code>)，定义一个也是很好的做法。我们将只回复一条服务器正在运行的消息。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="bdb7" class="ms lm iq lf b gy mt mu l mv mw">app.get('/', (req, res) =&gt; {<br/>  res.send('Push Notification Server Running');<br/>});</span></pre><p id="5ab8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">19.首先，让我们实现保存推送通知令牌的端点。当POST请求被发送到<code class="fe lc ld le lf b">/token</code>端点时，我们将把令牌值传递给saveToken函数，并返回一个响应，声明令牌已被接收。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="0d53" class="ms lm iq lf b gy mt mu l mv mw">app.post('/token', (req, res) =&gt; {<br/>  saveToken(req.body.token.value);<br/>  console.log(`Received push token, ${req.body.token.value}`);<br/>  res.send(`Received push token, ${req.body.token.value}`);<br/>});</span></pre><p id="3252" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">20.同样,<code class="fe lc ld le lf b">/message</code>端点将从请求体中获取<code class="fe lc ld le lf b">message</code>,并将其传递给<code class="fe lc ld le lf b">handlePushTokens</code>函数进行处理。然后，我们将发回一个消息已收到的响应。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="e4c1" class="ms lm iq lf b gy mt mu l mv mw">app.post('/message', (req, res) =&gt; {<br/>  handlePushTokens(req.body.message);<br/>  console.log(`Received message, ${req.body.message}`);<br/>  res.send(`Received message, ${req.body.message}`);<br/>});</span></pre><p id="4677" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">21.服务器的最后一部分是在服务器实例上调用Express的<code class="fe lc ld le lf b">listen</code>方法，这将启动服务器。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="e8c0" class="ms lm iq lf b gy mt mu l mv mw">app.listen(PORT_NUMBER, () =&gt; {<br/>  console.log('Server Online on Port ${PORT_NUMBER}');<br/>});</span></pre><p id="81f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">22.我们需要一种启动服务器的方法，所以我们将向名为serve的<code class="fe lc ld le lf b">package.json</code>文件添加一个自定义脚本。打开<code class="fe lc ld le lf b">package.json</code>文件，用一个新的<code class="fe lc ld le lf b">serve</code>脚本更新它。有了这个，我们可以通过<code class="fe lc ld le lf b">yarn run serve</code>命令用yarn运行服务器，或者通过<code class="fe lc ld le lf b">npm run serve</code>命令用npm运行服务器。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="0653" class="ms lm iq lf b gy mt mu l mv mw">{<br/>  "main": "node_modules/expo/AppEntry.js",<br/>  "private": true,<br/>  "dependencies": {<br/>    "esm": "^3.0.28",<br/>    "expo": "^27.0.1",<br/>    "expo-server-sdk": "^2.3.3",<br/>    "express": "^4.16.3",<br/>    "react": "16.3.1",<br/>    "react-native": "https://github.com/expo/react-native/archive/sdk-27.0.0.tar.gz"<br/>  },<br/><strong class="lf ir">  "scripts": {</strong><br/><strong class="lf ir">    "serve": "node -r esm server/index.js"</strong><br/><strong class="lf ir">  }</strong><br/>}</span></pre><p id="2f5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">23.我们已经准备好了所有的代码，让我们开始使用吧！如前所述，推送通知权限在模拟器上无法正常工作，因此需要一个真实的设备来测试推送通知功能。首先，我们将通过运行<code class="fe lc ld le lf b">yarn run serve</code>或<code class="fe lc ld le lf b">npm run serve</code>来启动我们新创建的服务器。您应该会看到我们在第21步的<code class="fe lc ld le lf b">listen</code>方法调用中定义的“服务器在线”消息。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/5c4d6d8f41a1b0812609b039aa4d5213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hj-CBI2hoOlb2zWM.png"/></div></div></figure><p id="f92a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">24.接下来，我们需要运行ngrok将我们的服务器暴露给互联网。打开一个新的终端窗口，用命令<code class="fe lc ld le lf b">ngrok http 3000</code>创建一个ngrok隧道。您应该在终端中看到ngrok界面。这将显示ngrok生成的URL。在这种情况下，ngrok将我位于<code class="fe lc ld le lf b">http://localhost:3000</code>的服务器转发到url <code class="fe lc ld le lf b">http://ddf558bd.ngrok.io</code>。让我们复制那个url。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/1d32cef7fed3bffd000c2e584e062d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eMWF0-Xvtg3jU1oi.png"/></div></div></figure><p id="36fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">25.您可以通过在浏览器中访问生成的URL来测试服务器是否正在运行以及是否可以从internet访问。直接导航到这个url的行为与导航到<code class="fe lc ld le lf b">http://localhost:300</code>完全相同，这意味着我们在步骤中定义的GET端点应该运行。该函数返回字符串“推送通知服务器正在运行”，并且应该显示在您的浏览器中。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e5faa87f9752fb6c52f824d29e284231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*GmtGMK_VdsOMUiQ8.png"/></div></figure><p id="6034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">26.现在我们已经确认了服务器正在运行，让我们更新React本机应用程序以使用正确的服务器URL。在步骤2中，我们添加了用于保存API端点的常量，但是我们还没有正确的URL。让我们更新这些url，以反映ngrok生成的隧道URL。</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="839e" class="ms lm iq lf b gy mt mu l mv mw">const PUSH_REGISTRATION_ENDPOINT = 'http://ddf558bd.ngrok.io/token';<br/>const MESSAGE_ENPOINT = 'http://ddf558bd.ngrok.io/message';</span></pre><p id="ad71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">27.如前所述，您需要在真实设备上运行此应用程序，权限请求才能正常工作。一旦打开应用程序，设备就会提示您，询问您是否允许应用程序发送通知。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/e8c63962ad9be93816a9073a70665fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XABt6kIQ-0shSg8e.jpg"/></div></div></figure><p id="cbe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">28.一旦选择了<strong class="kf ir">允许</strong>，推送通知令牌将被发送到服务器的<code class="fe lc ld le lf b">/token</code>端点进行保存。这还应该在服务器终端中打印相关的console.log语句和保存的令牌。在这种情况下，我的iPhone的推送令牌是字符串<code class="fe lc ld le lf b">ExponentPushToken[g5sIEbOm2yFdzn5VdSSy9n]</code>。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/9f2171bd2f0e52e9afbb8c6a27b0bdf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mFb1_kPWZqC2H_rs.png"/></div></div></figure><p id="dd33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">29.此时，如果您有第二台Android或iOS设备，也可以在这台设备上打开React Native应用程序。如果没有，也不用担心。还有另一种简单的方法来测试我们的推送通知功能是否正常工作，而不需要使用第二个设备。</p><p id="1024" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">30.使用React本机应用程序发送消息。如果你有第二台设备已经向服务器注册了一个令牌，它应该会收到与新发送的消息相对应的推送通知！您还应该在服务器中看到两个新的<code class="fe lc ld le lf b">console.log</code>:一个显示收到的消息，另一个显示从Expo服务器收到的“receipts”数组。如果操作成功，数组中的每个收据对象都有一个值为<code class="fe lc ld le lf b">‘ok’</code>的<code class="fe lc ld le lf b">status</code>属性。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/7065944d977e5c25bafce6a25e44d444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LnsGwnobRgLDJzWH.png"/></div></div></figure><p id="bc8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">31.如果你没有第二个设备来测试，你可以使用博览会的推送通知工具，托管在<a class="ae kc" href="https://expo.io/dashboard/notifications" rel="noopener ugc nofollow" target="_blank">https://expo.io/dashboard/notifications</a>。只需从服务器终端复制推送令牌，并将其粘贴到标记为“EXPO PUSH TOKEN(来自您的应用程序)”的输入中要模拟从React本地应用程序发送的消息，请将消息标题设置为“消息已收到！”，消息正文，并勾选<strong class="kf ir">播放声音</strong>复选框。如果您愿意，您还可以通过添加一个JSON对象来模拟<code class="fe lc ld le lf b">data</code>对象，该对象带有一个消息键和一个消息文本值，即<code class="fe lc ld le lf b">{ “message”: “This is a test message.” }</code>。</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/83b3f45e1cdd596e4aab7521ccc17be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UyVpD10eDJvbIWSg.jpg"/></div></div></figure><h1 id="e717" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">它是如何工作的</h1><p id="ef56" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们在这里构建的应用程序有点做作，但请求权限、注册令牌、接受应用程序数据和发送推送通知以响应应用程序数据所需的核心概念都在那里。</p><p id="997c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第4步中，我们定义了<code class="fe lc ld le lf b">registerForPushNotificationsAsync</code>函数的第一部分。我们首先请求用户允许通过<code class="fe lc ld le lf b">Permissions.askAsync</code>方法从我们的应用程序向他们发送通知，并传入推送通知权限的enum，<code class="fe lc ld le lf b">Permissions.NOTIFICATIONS</code>。然后，我们保存了已解析的返回对象的status属性，如果用户授予了权限，该属性将具有值<code class="fe lc ld le lf b">‘granted’</code>。如果我们没有获得许可，我们马上<code class="fe lc ld le lf b">return</code>，否则我们通过调用<code class="fe lc ld le lf b">getExpoPushTokenAsync</code>从Expo的<code class="fe lc ld le lf b">Notifications</code>组件获得令牌。此函数返回一个令牌字符串，其格式如下:</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="f5e9" class="ms lm iq lf b gy mt mu l mv mw">ExponentPushToken[xxxxxxxxxxxxxxxxxxxxxx]</span></pre><p id="0916" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第5步中，我们定义了对服务器注册端点的POST调用(<code class="fe lc ld le lf b">/token</code>)。这个函数在请求体中发送令牌，然后使用步骤14中定义的<code class="fe lc ld le lf b">saveToken</code>函数将令牌保存在服务器上。</p><p id="3e81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤6中，我们创建一个事件监听器，它将监听任何新的传入推送通知。这是通过调用<code class="fe lc ld le lf b">Notifications.addListener</code>并传递一个回调函数来完成的，该函数将在每次收到新通知时执行。在iOS设备上，系统被设计为仅在发送推送通知的应用程序未打开且未被前景化的情况下产生推送通知。这意味着，如果你试图在用户正在使用你的应用时向他们发送推送通知，他们将永远不会收到。</p><p id="e127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，Expo建议在你的应用中手动显示推送通知数据。这个<code class="fe lc ld le lf b">Notifications.addListener</code>方法就是为了满足这种需求而创建。当接收到推送通知时，传递给<code class="fe lc ld le lf b">addListener</code>的回调将被执行，并将接收新的通知对象作为参数。在第7步中，我们将这个通知保存到<code class="fe lc ld le lf b">state</code>，以便相应地重新呈现UI。在本教程中，我们只在一个<code class="fe lc ld le lf b">Text</code>组件中显示消息文本，但是您也可以创建一个更像通知的模型。</p><p id="ed55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤11中，我们创建了sendMessage函数，它将存储在<code class="fe lc ld le lf b">state</code>上的消息文本发送到服务器的<code class="fe lc ld le lf b">/message</code>端点。这将执行步骤15中定义的服务器功能<code class="fe lc ld le lf b">handlePushToken</code>。</p><p id="0c1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第13步中，我们开始在服务器上工作，它利用了Express和Expo server SDK。通过直接调用<code class="fe lc ld le lf b">express()</code>创建一个新的服务器，作为一个本地常量，通常按照惯例命名为<code class="fe lc ld le lf b">app</code>。我们能够用<code class="fe lc ld le lf b">new Expo()</code>创建一个新的Expo server SDK实例，并将其存储在const <code class="fe lc ld le lf b">expo</code>中。我们稍后使用Expo server SDK通过<code class="fe lc ld le lf b">expo</code>发送推送通知，在步骤17–20中使用<code class="fe lc ld le lf b">app</code>定义路线，并在步骤22中通过调用<code class="fe lc ld le lf b">app.listen()</code>启动服务器。</p><p id="2cf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤14中，我们定义了<code class="fe lc ld le lf b">saveToken</code>函数，当React本地应用程序使用<code class="fe lc ld le lf b">/token</code>端点注册令牌时，将执行该函数。这个函数将传入的令牌保存到<code class="fe lc ld le lf b">savedPushTokens</code>数组中，供以后用户发送消息时使用。在真实的应用程序中，这是您可能希望将令牌保存到某种持久数据库的地方，比如SQL、MongoDB或Firebase数据库。</p><p id="74f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第15步中，我们开始定义当React本地应用程序使用<code class="fe lc ld le lf b">/message</code>端点时运行的<code class="fe lc ld le lf b">handlePushTokens</code>函数。该函数循环遍历<code class="fe lc ld le lf b">savedPushTokens</code>数组进行处理。使用Expo server SDK方法<code class="fe lc ld le lf b">isExpoPushToken</code>检查每个令牌的有效性，该方法接收一个令牌，如果令牌有效，则返回<code class="fe lc ld le lf b">true</code>。如果无效，我们会在服务器控制台记录一个错误。如果它是有效的，我们将一个新的<code class="fe lc ld le lf b">notification</code>对象推送到本地通知数组，用于下一步的批处理。每个通知对象都需要一个<code class="fe lc ld le lf b">to</code>属性，该属性的值被设置为有效的Expo push令牌。所有其他属性都是可选的。我们设置的可选属性是:</p><ul class=""><li id="4b4e" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated">声音—可以是“默认”播放默认通知声音，也可以是<code class="fe lc ld le lf b">null</code>不播放声音。</li><li id="b8c3" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">标题—推送通知的标题，通常以粗体显示。</li><li id="2687" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">正文—推送通知的正文。</li><li id="9466" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">数据—自定义数据JSON对象。</li></ul><p id="f8b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤16中，我们使用Expo server SDK实例方法<code class="fe lc ld le lf b">chunkPushNotifications</code>来创建一个数据块数组，这些数据块经过优化后发送到Expo的推送通知服务器。然后我们循环这些块，并通过<code class="fe lc ld le lf b">expo.sendPushNotificationsAsync</code>方法将每个块发送到Expo的推送通知服务器。它返回一个承诺，该承诺解析为每个推送通知的收据数组。如果流程成功，数组中的每个通知都将有一个对象<code class="fe lc ld le lf b">{ status: ‘ok’ }</code>。</p><p id="7aef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个端点的行为可能比真实的服务器更简单，因为大多数消息应用程序处理消息的方式更复杂。至少可能会有接收者列表，该列表将指示哪些注册的设备将依次接收特定的推送通知。为了描述基本流程，逻辑有意保持简单。</p><p id="3189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤18中，我们定义了服务器上第一个可访问的路由，即根(/)路径。Express提供了<code class="fe lc ld le lf b">get</code>和<code class="fe lc ld le lf b">post</code>助手方法，分别为GET和POST请求创建API端点。回调函数接收请求对象和响应对象作为参数。所有服务器URL都需要响应请求，否则请求会超时。响应通过响应对象上的<code class="fe lc ld le lf b">send</code>方法发送。这个路由不处理任何数据，所以我们只是返回表明我们的服务器正在运行的字符串。</p><p id="9f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤19和20中，我们为<code class="fe lc ld le lf b">/token</code>和<code class="fe lc ld le lf b">/message</code>定义了POST端点，它们将分别执行<code class="fe lc ld le lf b">saveToken</code>和<code class="fe lc ld le lf b">handlePushTokens</code>。为了便于开发，我们还为每个语句添加了<code class="fe lc ld le lf b">console.log</code>语句，以便将令牌和消息记录到服务器终端。</p><p id="e46c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤21中，我们在Express服务器上定义了<code class="fe lc ld le lf b">listen</code>方法，它启动服务器。第一个参数是监听请求的端口号，第二个参数是一个回调函数，通常用于<code class="fe lc ld le lf b">console.log</code>向服务器终端发送一条消息，表明服务器已经启动。</p><p id="0561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤22中，我们向项目的<code class="fe lc ld le lf b">package.json</code>文件添加了一个定制脚本。可以在终端中运行的任何命令都可以成为自定义npm脚本，方法是向设置为对象的<code class="fe lc ld le lf b">package.json</code>文件添加一个<code class="fe lc ld le lf b">scripts</code>键，该对象的键是自定义脚本的名称，其值是在运行自定义脚本时应该执行的命令。在本教程中，我们定义了一个名为<code class="fe lc ld le lf b">serve</code>的自定义脚本来运行命令<code class="fe lc ld le lf b">node -r esm server/index.js</code>。这个命令使用我们在本教程开始时安装的<code class="fe lc ld le lf b">esm</code> npm包运行我们的服务器文件(<code class="fe lc ld le lf b">server/index.js</code>)和Node。可以使用npm执行自定义脚本:</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="89e3" class="ms lm iq lf b gy mt mu l mv mw">npm run [custom-script-name]</span></pre><p id="99c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或纱线:</p><pre class="lh li lj lk gt mo lf mp mq aw mr bi"><span id="4f9d" class="ms lm iq lf b gy mt mu l mv mw">yarn run [custom-script-name]</span></pre><p id="46f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推送通知可能很复杂，但值得庆幸的是，Expo在很多方面简化了这个过程。有很多关于世博会推送通知服务的文档，涵盖了通知定时的细节、其他语言的世博会服务器SDK，以及如何通过HTTP/2实现通知。我鼓励你在<a class="ae kc" href="https://docs.expo.io/versions/latest/guides/push-notifications" rel="noopener ugc nofollow" target="_blank">https://docs . Expo . io/versions/latest/guides/push-notifications</a>上阅读更多内容。</p><p id="0378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你也可以在GitHub上的<a class="ae kc" href="https://github.com/warlyware/react-native-cookbook/tree/master/chapter-5/push-notifications" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/warly ware/react-native-cookbook/tree/master/chapter-5/push-notifications</a>看一下这个教程的源代码。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="b749" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">如果您觉得本文有帮助，请点击👏！您还可以</em> <a class="ae kc" href="https://medium.com/@warlyware" rel="noopener"> <em class="lb">关注我</em> </a> <em class="lb">获取更多关于React Native、Vue和JavaScript开发的文章。</em></p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><figure class="lh li lj lk gt jr gh gi paragraph-image"><a href="http://levelup.gitconnected.com"><div class="ab gu cl nz"><img src="../Images/a5f9dfbe503d8543c6f72bdbef622101.png" data-original-src="https://miro.medium.com/v2/format:webp/1*E8lHUzxrIT5VDhu7fUS6gg.png"/></div></a></figure><div class="oa ob gp gr oc od"><a href="https://gitconnected.com/learn/react-native" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">学习React Native -最佳React Native教程(2019) | gitconnected</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">10大React原生教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">gitconnected.com</p></div></div><div class="om l"><div class="on l oo op oq om or jw od"/></div></div></a></div></div></div>    
</body>
</html>