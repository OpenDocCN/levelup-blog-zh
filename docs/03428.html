<html>
<head>
<title>Ways to Refactor JavaScript Code You May Have Missed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构您可能错过的JavaScript代码的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ways-to-refactor-javascript-code-you-may-have-missed-3fabd0c0f8f1?source=collection_archive---------2-----------------------#2020-05-08">https://levelup.gitconnected.com/ways-to-refactor-javascript-code-you-may-have-missed-3fabd0c0f8f1?source=collection_archive---------2-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/730b89f7fe13b2af11ec83711f879e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qygO2tZPZVD-w8e9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯·克里斯滕森在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="52ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难写出一段干净的JavaScript代码。</p><p id="175f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看一些你可能错过的重构代码的方法。</p><h1 id="ce7d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用对象参数</h1><p id="fb27" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对象参数是作为对象的参数。对于对象参数，我们不关心在属性中传递的顺序。</p><p id="19b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不必担心传入太多参数，因为这只是一个具有多个属性的参数。</p><p id="1c33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不必担心添加和删除参数会破坏我们的代码，因为它仍然是一个对象。</p><p id="7f71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">析构赋值语法可以将对象分解成变量，所以我们可以像使用变量一样使用属性。</p><p id="5485" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了用这种模式重构我们的JavaScript代码，我们通过将参数组合成一个对象参数来转换它们。</p><p id="b981" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用对象参数的示例如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b5eb" class="mq lf it mm b gy mr ms l mt mu">const greet = ({<br/>  greeting,<br/>  firstName,<br/>  lastName<br/>}) =&gt; `${greeting}, ${firstName} ${lastName}`;</span></pre><p id="b75e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个对象参数，它有3个属性，<code class="fe mv mw mx mm b">greeting</code>、<code class="fe mv mw mx mm b">firstName</code>和<code class="fe mv mw mx mm b">lastName</code>，然后我们提取它们，并用析构语法将它们作为变量使用。</p><p id="5489" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以这样称呼它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b08b" class="mq lf it mm b gy mr ms l mt mu">const greeting = greet({<br/>  greeting: 'Hello',<br/>  firstName: 'jane',<br/>  lastName: 'smith'<br/>})</span></pre><p id="2792" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们看到<code class="fe mv mw mx mm b">greeting</code>就是<code class="fe mv mw mx mm b">'Hello, jane smith’</code>。</p><h1 id="fcd8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用命名回调替换匿名回调</h1><p id="f7f2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">匿名函数没有名字，所以不太清楚，因为它们没有名字来区分它们在做什么。</p><p id="7816" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使它们更容易阅读和理解，我们可以在它们的方法之外提取它们，然后将它们赋给一个常数，并将该常数传入。</p><p id="b006" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来提取对常量的回调:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="acd9" class="mq lf it mm b gy mr ms l mt mu">const double = a =&gt; a * 2;<br/>const arr = [1, 2, 3].map(double);</span></pre><p id="1f6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mv mw mx mm b">double</code>常量，它被赋予了函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d237" class="mq lf it mm b gy mr ms l mt mu">a =&gt; a * 2;</span></pre><p id="e3f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它被它下面的<code class="fe mv mw mx mm b">map</code>方法用来将数组中每一项的值加倍。</p><p id="3ef0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道回调用于将每个条目的值加倍，而不必读取回调的代码。</p><h1 id="35c0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用对象替换图元</h1><p id="95bc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有很多原语，我们想分配给一个变量，就像我们改变状态一样，我们可以把它们都放到一个对象中，然后使用它们。</p><p id="f762" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，它们都在一个地方，如果我们必须更改它们，我们不必到处更改它们。</p><p id="f883" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于JavaScript没有枚举，我们可以使用<code class="fe mv mw mx mm b">Set</code> s将我们的值放入其中。</p><p id="667c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以将所有值添加到一个集合中，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="245f" class="mq lf it mm b gy mr ms l mt mu">const statuses = new Set(['loading', 'success', 'error', 'pending'])</span><span id="4c64" class="mq lf it mm b gy my ms l mt mu">const setStatus = (status) =&gt; {<br/>   if (statuses.has(status)) {<br/>     return status;<br/>   }<br/> }</span></pre><p id="e064" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有具有多种状态的<code class="fe mv mw mx mm b">statuses</code>集合。然后在<code class="fe mv mw mx mm b">setStatus</code>函数中，我们在返回状态之前检查状态是否存在于<code class="fe mv mw mx mm b">statuses</code>集合中。</p><p id="e9f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以确保在代码中设置了有效的状态。这类似于没有定义枚举的枚举，因为我们只能设置集合中列出的值。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1aaff2a69872075fc61b2ea9ca4ad5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QNDRo3jiaSqM6j6P"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳森派</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="5640" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将条件分解成变量或函数</h1><p id="9dd3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">条件表达式，尤其是长表达式，很难读懂。这是因为它们只是列出了一堆用括号连接在一起的条件，括号中有and、or或括号。</p><p id="39fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使它们更容易阅读，我们可以将布尔表达式赋给一个变量，或者在函数中返回表达式，这样我们就可以理解条件在检查什么，而不用查看条件表达式本身。</p><p id="cde8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码，将条件表达式赋给变量:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7ef5" class="mq lf it mm b gy mr ms l mt mu">const hasWinner = score === 100 || remainingPlayer === 0;</span></pre><p id="4745" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们知道代码正在检查游戏中的赢家，因为我们看到我们将布尔表达式赋给了<code class="fe mv mw mx mm b">hasWinner</code>常量。</p><p id="e3ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有布尔值，很难知道我们在检查一个游戏是否有赢家。我们只知道我们正在检查<code class="fe mv mw mx mm b">score</code>是100，而<code class="fe mv mw mx mm b">remainingPlayer</code>是0。当它们连在一起时，很难知道它们是什么意思。</p><p id="5c75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以在函数中返回布尔表达式，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dedd" class="mq lf it mm b gy mr ms l mt mu">const hasWinner = () =&gt; score === 100 || remainingPlayer === 0;</span></pre><p id="2683" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后只在调用<code class="fe mv mw mx mm b">hasWinner</code>的时候求值，而不是一直求值。</p><h1 id="87fe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4539" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对象参数让我们通过添加更多的参数来传递更多的参数，因为我们可以将它们作为属性来传递，并在函数中析构它们。</p><p id="3b1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有许多重复的原始值，我们可以把它们都放在一个对象中。然后我们可以在设置值之前使用对象来检查这些项，以确保它们是有效的。</p><p id="22c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以将布尔表达式设置到函数或变量中，我们可以对回调做同样的事情，使它们变得清晰。</p></div></div>    
</body>
</html>