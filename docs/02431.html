<html>
<head>
<title>How to Construct an Immutable Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构造一个不可变的队列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-construct-an-immutable-queue-9a8aec86caef?source=collection_archive---------8-----------------------#2020-03-12">https://levelup.gitconnected.com/how-to-construct-an-immutable-queue-9a8aec86caef?source=collection_archive---------8-----------------------#2020-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b47c29de1c898d5136400f0ac3793542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JehFkNnzUQrVui_N.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">最初发表于</em><a class="ae kg" href="https://edward-huang.com/scala/functional-programming/algorithm/2020/03/11/how-to-construct-an-immutable-queue/" rel="noopener ugc nofollow" target="_blank"><em class="kf"/></a><em class="kf">。</em></figcaption></figure><p id="bf1c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当创建一个不可变的数据结构时，我们经常需要一个包含一些状态的程序，以便在执行过程中发生变化。</p><p id="d9d6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">一个例子是创建一个不可变的队列。在scala库中，您初始化了一个不可变队列，如下所示:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="f468" class="lo lp it lk b gy lq lr l ls lt">val empty = Queue[Int]()</span></pre><p id="055d" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，您可以将队列入队，这将返回一个包含更新元素的新队列。您还可以使队列出队，这将返回您删除的元素的元组和新队列。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="deaa" class="lo lp it lk b gy lq lr l ls lt">val one = empty.enqueue(1)<br/>val (one, emptyQ) = one.dequeue()</span></pre><p id="8c8c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">但是，如果您想对不可变队列进行一系列操作，您需要将新元素传递给下一个操作。像这样:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="567d" class="lo lp it lk b gy lq lr l ls lt">val one = empty.enqueue(1)<br/>val two = one.enqueue(2) <em class="lu">// enqueue from one<br/></em>val three = two.enqueue(3) <em class="lu">// enqueue from two</em></span></pre><p id="e6bc" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果您需要通过显式地将一种状态传递给另一种状态来执行许多操作，那么这很容易出错。</p><p id="c451" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在本文中，我想分享如何使用cats状态单子来构造队列。通过使用状态monad，构造不可变的数据结构不需要显式地将一个状态传递给另一个状态。因此，它减少了容易出错的样板文件的数量。</p><h1 id="7720" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">执行顺序</h1><p id="3c8f" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">我们从实现常规不可变队列开始，它展示了常规scala不可变队列的相同操作。然后，我们实现相同的不可变队列，但是使用了Cats状态单子。</p><p id="d165" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">声明:队列实现高度</p><h1 id="a484" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">创建常规不可变队列</h1><p id="aa72" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">让我们创建队列的构造函数:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="a460" class="lo lp it lk b gy lq lr l ls lt">class FunctionalQueue[+A](vector:Vector[A])</span></pre><p id="9542" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">FunctionalQueue的主类包含一个向量，该向量包含所有排队或出列的元素。</p><p id="ab53" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们实现入队和出队函数:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8c35" class="lo lp it lk b gy lq lr l ls lt">def enqueue[B &gt;: A](elmt:B): FunctionalQueue[B] = new FunctionalQueue(vector :+ elmt)<br/>def dequeue: (A, FunctionalQueue[A]) = (vector.head, new FunctionalQueue[A](vector.tail))</span></pre><p id="35dc" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">enqueue和dequeue函数只是将值附加到vector上，并从vector中检索值。</p><p id="251d" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，通过定义companion对象为FunctionalQueue构造函数添加一个工厂方法。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e205" class="lo lp it lk b gy lq lr l ls lt">object FunctionalQueue {<br/>  def apply[A]():FunctionalQueue[A] = new FunctionalQueue[A](Vector.empty[A])<br/>}</span></pre><p id="6935" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您可以调用main中的函数，就像这样:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="d3bd" class="lo lp it lk b gy lq lr l ls lt">println(s"creating immutable queue without State monad")<br/>val functionalQueue = FunctionalQueue[Int]<br/>println(s"enqueue 1 immutable queue")<br/>val enqueue1 = functionalQueue.enqueue(1)<br/>println(s"enqueue 2 immutable queue")<br/>val enqueue2 = enqueue1.enqueue(2)<br/>println(s"front ${enqueue2.front}")<br/>val (head, rest) = enqueue2.dequeue<br/>println(s"dequeue head: ${head}  rest : ${rest}")</span></pre><h1 id="61a5" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">什么是状态单子</h1><p id="855c" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">根据<a class="ae kg" href="https://underscore.io/books/scala-with-cats/" rel="noopener ugc nofollow" target="_blank"> Scala with Cats </a>，状态单子允许我们传递额外的状态作为计算的一部分。</p><p id="60d1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">状态实例的表示是<code class="fe mx my mz lk b">State[S,A]</code>，这里表示函数<code class="fe mx my mz lk b">S =&gt; (S,A)</code>。</p><p id="e888" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这意味着它接受某个状态，并返回一个结果以及新计算的状态。</p><p id="1985" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们试着创建一个简单的状态:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="46cb" class="lo lp it lk b gy lq lr l ls lt">import cats.data.State<br/>val a = State[Int,String] {integerState =&gt;<br/>  (integerState, s"The state is ${state}")<br/>}</span></pre><p id="f873" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在第一个输入变量准备好传入之前，状态连接所有的计算。程序全部连线后，可以传入初始状态，执行<code class="fe mx my mz lk b">run</code>得到预期的结束状态及其结果。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="11df" class="lo lp it lk b gy lq lr l ls lt">val (endState, result) = a.run(2).value <em class="lu">// 2 is the initial input that is passed in<br/>// endState: 2 result : The state is 2</em></span></pre><p id="c435" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">国家的力量在于地图和平面图功能。它可以将状态从一个实例传递到另一个实例。</p><p id="ba33" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">每个状态代表一个单独的转换，您可以通过使用flatMap将它们组合起来，以转换完整的变更序列:</p><p id="7eae" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在下面的例子中，<code class="fe mx my mz lk b">plus1</code>和<code class="fe mx my mz lk b">plus2</code>返回计算出的新状态的值和该计算的描述历史。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="1bde" class="lo lp it lk b gy lq lr l ls lt">import cats.data.State<br/><br/>val plus1 = State[Int, String]{state =&gt;<br/>  (state+1, s"The result of this state is ${state+1}")<br/>}<br/><br/>val plus2 = State[Int,String] {state =&gt;<br/>  (state +2, s"The result of this state is ${state+2}")<br/>}<br/><br/>val program = for {<br/>  historyOne &lt;- plus1 <em class="lu">// historyOne is the String<br/></em>  historyTwo &lt;- plus2<br/>} yield List(historyOne, historyTwo)<br/><br/>val (result, history) = program.run(0).value<br/><em class="lu">// result = 3<br/>// history = List("The result of this state is 1","The result of this state is 3" )</em></span></pre><p id="2189" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如你所见，<code class="fe mx my mz lk b">plus1</code>和<code class="fe mx my mz lk b">plus2</code>是线程化的，即使我们没有为了理解而与之交互。</p><h1 id="49ee" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">用状态单子重构函数队列</h1><p id="4896" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">现在你知道了状态单子是如何工作的，让我们通过使用状态单子来重构函数队列。</p><p id="04eb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">用状态单子实现<code class="fe mx my mz lk b">enqueue</code>和<code class="fe mx my mz lk b">dequeue</code>。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="9d68" class="lo lp it lk b gy lq lr l ls lt">type QueueFunc[A] = State[Vector[A], Option[A]]<br/><br/>def enqueue[A](elmt:A): QueueFunc[A] = State[Vector[A], Option[A]]{ oldVector =&gt;<br/>    (oldVector :+ elmt, oldVector.headOption)<br/>  }<br/><br/>def dequeue[A]: QueueFunc[A] = State[Vector[A],Option[A]] { oldVector =&gt;<br/>  (oldVector.tail, oldVector.headOption)<br/>}</span></pre><p id="9657" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我创建了<code class="fe mx my mz lk b">QueueFunc</code>作为代表<code class="fe mx my mz lk b">State[Vector[A], Option[A]]</code>的类型别名。状态包含一个向量，该向量包含一个类型<code class="fe mx my mz lk b">A</code>和可选的队列头。函数enqueue和dequeue接受一个旧的向量，并添加或删除向量的头部。</p><p id="8015" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，我们已经用State完成了不可变队列的所有实现！</p><p id="13f7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你如何运行这个功能？</p><p id="f6cf" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们用我们的新实现执行与<code class="fe mx my mz lk b">FunctionalQueue</code>相同的操作。</p><p id="7ce3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">请记住，我们使用flatMap来组合每个操作，而没有真正与它的更新状态进行交互。</p><p id="f1ad" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们提供所有预期的执行步骤。然后，我们给它连接一个程序，提供它的初始状态并执行<code class="fe mx my mz lk b">run</code>函数。在这种情况下，初始值是一个空向量。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="9fa4" class="lo lp it lk b gy lq lr l ls lt"><em class="lu">// supply our operation<br/></em>val program = for {<br/>  _ &lt;- enqueue[Int](1)<br/>  _ &lt;- enqueue[Int](2)<br/>  end &lt;- dequeue[Int]<br/>} yield end<br/><br/><br/>val (newState, head) = program.run(Vector.empty[Int]).value<br/><em class="lu">// newState = Vector(2)<br/>// head = 1</em></span></pre><h1 id="244c" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">外卖食品</h1><ul class=""><li id="a3e2" class="na nb it kj b kk ms ko mt ks nc kw nd la ne le nf ng nh ni bi translated">状态单子帮助您消除所有容易出错的样板代码，这些代码将更新后的状态传递给下一个操作。</li><li id="c912" class="na nb it kj b kk nj ko nk ks nl kw nm la nn le nf ng nh ni bi translated">状态monad实例传入一个状态，并返回结果及其更新后的状态。</li><li id="d894" class="na nb it kj b kk nj ko nk ks nl kw nm la nn le nf ng nh ni bi translated">状态单子的能力依赖于<code class="fe mx my mz lk b">map</code>和<code class="fe mx my mz lk b">flatMap</code>操作，它们将一个实例线程化到另一个实例。每个状态实例代表一个原子转换。它们的组合代表了一系列的变化。你不需要为了理解而与中间状态进行交互。</li></ul><p id="bcd8" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">所有信息和示例都在<a class="ae kg" href="https://github.com/edwardGunawan/Blog-Tutorial/blob/master/ScalaTutorial/catsStateMonad/README.md" rel="noopener ugc nofollow" target="_blank"> Github中。</a></p><p id="4b95" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">GitHub信息有3种不同的方法来实现不可变队列。第一个是没有状态monad的常规不可变队列(第一个例子)。第二个用状态单子模仿常规的不可变队列接口——最后一个用状态单子实现稳定状态(本文的第二个例子)。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="6bd9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae kg" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="kj iu"/></a><strong class="kj iu">来接收关于科技职业的每周文章、有趣的链接和内容！</strong></p><p id="fea2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可以关注我，也可以在<a class="ae kg" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p></div></div>    
</body>
</html>