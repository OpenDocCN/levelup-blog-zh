<html>
<head>
<title>Switch Statement in Golang Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的Switch语句解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/switch-statement-in-golang-explained-9cd3a85aa19d?source=collection_archive---------5-----------------------#2022-05-31">https://levelup.gitconnected.com/switch-statement-in-golang-explained-9cd3a85aa19d?source=collection_archive---------5-----------------------#2022-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee2c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有了实际例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9bc28d1661e3b69c2cfd56f403e0cfb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Bjg5V7zLT42HsodmuNEkw.png"/></div></div></figure><p id="6e14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Golang像大多数编程语言一样有一个switch语句。开关允许你在多种情况下评估一个变量或表达式，它通常在编写大量的<code class="fe lq lr ls lt b">if-else</code>语句使代码看起来丑陋和重复时使用。</p><p id="3990" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过一个例子来开始了解<code class="fe lq lr ls lt b">switch</code>语句在Go中的不同用法。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1168" class="ly lz it lt b gy ma mb l mc md">func variableEvaluation() {<br/> name := "John"<br/> switch name {<br/> case "John":<br/>  fmt.Println("Hi it is John")<br/> case "Carl":<br/>  fmt.Println("Hi it is Carl")<br/> case "Paul":<br/>  fmt.Println("Hi it is Paul")<br/> default:<br/>  fmt.Println("Unkown name")<br/> }<br/>}</span></pre><p id="4aca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于第一个例子，交换机评估<code class="fe lq lr ls lt b">name</code>变量，根据这个值它将打印一个不同的消息。注意开关中的每个case并没有一个<code class="fe lq lr ls lt b">break</code>关键字，这是因为Golang默认情况下会在case匹配时中断开关。此外，还有一个<code class="fe lq lr ls lt b">default</code>选项，以防变量与开关中的任何情况都不匹配。</p><p id="99f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开关还允许您将多个值放入一个案例中。当您想要在不同的情况下执行相同的操作时，这很有用。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="042a" class="ly lz it lt b gy ma mb l mc md">func statusEvaluation() {<br/> status := "active"<br/> switch status {<br/> case "active", "inactive":<br/>  fmt.Println("Update user")<br/> case "deleted":<br/>  fmt.Println("Hard Delete user")<br/> }<br/>}</span></pre><p id="5792" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以在switch语句中使用表达式。让我们看一个例子:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="977f" class="ly lz it lt b gy ma mb l mc md">func expressionEvaluation() {<br/> num := 10<br/> switch {<br/> case num &gt; 10 &amp;&amp; num &lt; 20:<br/>  num /= 2<br/> case num &gt;= 20:<br/>  num *= 2<br/> case num &lt;= 10 &amp;&amp; num &gt; 0:<br/>  num += 100<br/> default:<br/>  fmt.Println("Invalid number")<br/> }<br/> fmt.Println("Num: ", num)<br/>}</span></pre><p id="75a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，switch语句没有计算任何变量，而是每个case都有一个表达式，如果表达式与变量值匹配，那么case将被执行。</p><p id="8771" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以在switch语句中使用另一个函数的结果。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="ad28" class="ly lz it lt b gy ma mb l mc md">func functionEvaluation() {<br/> num := 12<br/> switch b := isEven(num); {<br/> case false:<br/>  fmt.Printf("Num is odd %v %t\n", num, b)<br/> case true &amp;&amp; num &lt; 5:<br/>  fmt.Printf("Num is even %v %t\n", num, b)<br/> case true &amp;&amp; num &gt; 10:<br/>  fmt.Printf("Num is even %v, and greater than 10\n", num)<br/> }<br/>}</span><span id="19dd" class="ly lz it lt b gy me mb l mc md">func isEven(n int) bool {<br/> if n%2 == 0 {<br/>  return true<br/> }</span><span id="89de" class="ly lz it lt b gy me mb l mc md"> return false<br/>}</span></pre><p id="9bb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，switch正在评估<code class="fe lq lr ls lt b">isEven</code>函数的结果，注意我们是如何在switch语句中定义变量<code class="fe lq lr ls lt b">b</code>的，这在我们需要case中函数的结果时很有用。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="d87e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以使用开关来知道变量的类型。当我们有类型为<code class="fe lq lr ls lt b">interface{}</code>的变量时，这很有用。让我们看看这是什么样子。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="ff18" class="ly lz it lt b gy ma mb l mc md">func typeSwitch(elements interface{}) {<br/> switch t := elements.(type) {<br/> case int:<br/>  fmt.Printf("Type integer %T\n", t)<br/> case bool:<br/>  fmt.Printf("Type boolean %T\n", t)<br/> case []int:<br/>  fmt.Printf("Type slice of integers %T\n", t)<br/> case []string:<br/>  fmt.Printf("Type slice of strings %T\n", t)<br/> default:<br/>  fmt.Println("Unkown type")<br/> }<br/>}</span></pre><p id="c4ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从前面的代码中可以看出，使用开关检查变量类型的语法与使用关键字<code class="fe lq lr ls lt b">type</code>进行类型断言的语法相同。如果我们想要执行相同的操作，我们也可以将多个类型放在一个案例中。</p><p id="a531" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们运行这个例子，看看输出:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="ce95" class="ly lz it lt b gy ma mb l mc md">typeSwitch([]int{1, 2, 3, 4, 5})<br/>typeSwitch([]string{"name", "lastName"})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/359072f90a6ccd7da466a0484dd67806.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*9mX8VLSg_SOJMs2GX2WliQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">类型开关输出</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="65c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有一个函数，它将一部分字节作为参数，我们想要调用这个函数，但是我们拥有的数据是类型<code class="fe lq lr ls lt b">interface{}</code>，所以在将这些数据传递给函数之前，我们需要将其转换为正确的类型。我们可以使用类型开关来解决这个问题。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="cc54" class="ly lz it lt b gy ma mb l mc md">func transformVariableToConcreateType(data interface{}) {<br/> bytes := []byte{}</span><span id="9b3d" class="ly lz it lt b gy me mb l mc md"> switch d := data.(type) {<br/> case []byte:<br/>  bytes = d<br/> case string:<br/>  bytes = []byte(d)<br/> }</span><span id="8e4c" class="ly lz it lt b gy me mb l mc md"> processData(bytes)<br/>}</span><span id="9a77" class="ly lz it lt b gy me mb l mc md">func processData(data []byte) {<br/> fmt.Println("Processing data: ", data)<br/>}</span></pre><p id="cf53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本例中，类型开关有两种情况，一种是字节片，另一种是字符串。如果数据是一个字节片，它只将<code class="fe lq lr ls lt b">d</code>赋给变量<code class="fe lq lr ls lt b">bytes</code>，如果数据是字符串类型，它在将数据赋给<code class="fe lq lr ls lt b">bytes</code>变量之前将其转换为一个字节片。在switch语句将数据转换成正确的类型后，现在可以将它传递给<code class="fe lq lr ls lt b">processData</code>函数。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="5f33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有一个接受模型的函数，这个函数负责调用正确的函数来更新基于模型的模型。但是由于更新函数只接受指针，所以交换机需要处理这个问题，如果模型不是指针，就把它作为指针传递。我们还可以使用类型开关来获取模型的类型，并调用正确的函数。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="7670" class="ly lz it lt b gy ma mb l mc md">func updateModel(model interface{}) {<br/> switch t := model.(type) {<br/> case *User:<br/>  updateUser(t)<br/> case User:<br/>  updateUser(&amp;t)<br/> case *Post:<br/>  updatePost(t)<br/> case Post:<br/>  updatePost(&amp;t)<br/> case *Chat:<br/>  updateChat(t)<br/> case Chat:<br/>  updateChat(&amp;t)<br/> }<br/>}</span><span id="ec89" class="ly lz it lt b gy me mb l mc md">func updateUser(user *User) {<br/> fmt.Printf("Updating user %v\n", user.Name)<br/>}</span><span id="5596" class="ly lz it lt b gy me mb l mc md">func updatePost(post *Post) {<br/> fmt.Printf("Updating post %v\n", post.Title)<br/>}</span><span id="a4cd" class="ly lz it lt b gy me mb l mc md">func updateChat(chat *Chat) {<br/> fmt.Printf("Updating chat %v\n", chat.Participants)<br/>}</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="6620" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个包含了我们所涉及的所有例子的文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="2a6f" class="ly lz it bd mt mu mv dn mw mx my dp mz ld na nb nc lh nd ne nf ll ng nh ni nj bi translated">结论</h2><p id="8412" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">Golang中的<code class="fe lq lr ls lt b">switch</code>语句非常灵活，允许我们做几件事情，并将其用于不同的用例。在本文中，我们介绍了以下内容:</p><ul class=""><li id="5f97" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">开关变量评估</li><li id="9ce7" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">开关表达式求值</li><li id="2d60" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">开关功能评估</li><li id="416b" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">类型开关</li></ul><p id="88b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你觉得这篇文章有用，并学到了新的东西！感谢您的阅读！</p><p id="b761" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">附加阅读</strong></p><div class="od oe gp gr of og"><a rel="noopener  ugc nofollow" target="_blank" href="/concurrency-in-golang-goroutines-and-channels-explained-55ddb5e1881"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Golang、Goroutines和Channels中的并发性解释</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Go中的主并发</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://betterprogramming.pub/go-api-design-with-protocol-buffers-and-grpc-991838e4852b" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">使用协议缓冲区和gRPC的Go API设计</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">基于社交媒体应用的分步指南</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">better编程. pub</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://betterprogramming.pub/implementing-interfaces-with-golang-51a3b7f527b4" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">用Golang实现接口</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">了解如何利用接口的力量</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">better编程. pub</p></div></div><div class="op l"><div class="ow l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>