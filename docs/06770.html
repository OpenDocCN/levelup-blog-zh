<html>
<head>
<title>Writing a Single Page Application with Vanilla JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用普通JS编写单页应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-a-single-page-application-with-vanilla-js-a5c7f7e23f6d?source=collection_archive---------0-----------------------#2020-12-30">https://levelup.gitconnected.com/writing-a-single-page-application-with-vanilla-js-a5c7f7e23f6d?source=collection_archive---------0-----------------------#2020-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/012023a97d8b73385b810929496d14dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d91k15f-crxUYIWeC5aGzg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马尔科姆·曼纳斯拍摄的开花香草植物的照片</figcaption></figure><p id="1101" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我遇到了以下关于单页面应用程序(SPA)中刷新状态处理的堆栈溢出问题。我发现OP开发SPA的方法很有趣:他们想避免第三方库和框架，因为他们“更喜欢简单的方法”。</p><p id="36f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章中的问题是:</p><div class="lb lc gp gr ld le"><a href="https://stackoverflow.com/a/64440218/3482831" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">如何处理浏览器刷新按钮的这种中断行为</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">我做了一个简单的概念证明来说明如何实现你所寻找的，你可以在这里看到…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">stackoverflow.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="5d9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我做了一个简单的概念证明来说明如何实现他们所寻找的东西，可以在这里看到<a class="ae kc" href="https://lucasreta.com/stack-overflow/spa-vanilla-js/section-2" rel="noopener ugc nofollow" target="_blank"/>(或者从<a class="ae kc" href="https://github.com/lucasreta/vanilla-spa" rel="noopener ugc nofollow" target="_blank"> github </a>克隆而来)。</p><p id="1b7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上传的版本中，我使用最后一个URL参数来确定应该加载什么。这是标准做法，但是需要服务器端配置，以便将所有传入的请求路由到单个文件。</p><p id="0e6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种选择(github上代码的默认选项)是使用锚片段。我的脚本支持这两种选择，你可以在这里看到<a class="ae kc" href="https://lucasreta.com/stack-overflow/spa-vanilla-js-no-rewrite/#section-2" rel="noopener ugc nofollow" target="_blank">上传的版本使用锚代替URL重写。</a></p><p id="45f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码非常简单(尽管可以通过使用fetch或不太冗长的XHR实现来进一步简化)。</p><h1 id="3d10" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">超文本标记语言</h1><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="145e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们只关心两件事:</p><ul class=""><li id="6d51" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated"><code class="fe nn no np nq b">#content-box</code>部分(第21行)，在这里我们将放置从我们的API加载的任何内容。</li><li id="00a4" class="ne nf iq kf b kg nr kk ns ko nt ks nu kw nv la nj nk nl nm bi translated">用于内部路由的<code class="fe nn no np nq b">a</code>元素，必须有与之关联的类<code class="fe nn no np nq b">link</code>(第14–17行)。</li></ul><h1 id="5050" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">Java Script语言</h1><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d674" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先我们初始化几个全局变量:</p><pre class="my mz na nb gt nw nq nx ny aw nz bi"><span id="ae16" class="oa mb iq nq b gy ob oc l od oe">const useHash = true;<br/>const apiUrl = 'https://lucasreta.com/stack-overflow/spa-vanilla-js/api';<br/>const routes = ['section-1', 'section-2'];<br/>const content_box = document.getElementById("content_box");</span></pre><p id="cd88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np nq b">useHash</code>将决定我们是否应该使用URL的锚(散列),或者我们内部路由的最后一个参数。</p><p id="a28e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np nq b">apiUrl</code>设置我们简单API的基本URL。</p><p id="178f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np nq b">routes</code>定义了我们的应用程序的有效路径。</p><p id="e5a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np nq b">content_box</code>是我们将使用外部数据更新的DOM元素。</p><p id="3201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们定义我们的异步getter，它仍然是一个非常标准的XHR调用，类似于查询者在示例代码<strong class="kf ir">(错误处理缺失)</strong>中的调用:</p><pre class="my mz na nb gt nw nq nx ny aw nz bi"><span id="e2c5" class="oa mb iq nq b gy ob oc l od oe">function get(page) {<br/>  const xhr = new XMLHttpRequest();<br/>  xhr.onreadystatechange = function() {<br/>    if (this.readyState == 4 &amp;&amp; this.status == 200) {<br/>      data = JSON.parse(xhr.responseText);<br/>      content_box.innerHTML = data.content;<br/>      const title = `${data.title} | App Manual`;<br/>      document.title = title;<br/>      window.history.pushState(<br/>        { 'content': data.content, 'title': title},<br/>        title,<br/>        useHash ?<br/>          `#${page}` :<br/>          page<br/>      );<br/>    }<br/>  };<br/>  xhr.open('GET', `${apiUrl}/${page}`, true);<br/>  xhr.send();<br/>}</span></pre><p id="3c3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们向我们的<code class="fe nn no np nq b">get</code>函数发送一个名为<code class="fe nn no np nq b">page</code>的参数，该参数匹配我们将使用的API的端点以及我们将在状态和URL中使用的名称，以确定我们必须显示的内容。</p><p id="a784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们必须处理单页应用程序状态被修改的三个事件:</p><pre class="my mz na nb gt nw nq nx ny aw nz bi"><span id="e932" class="oa mb iq nq b gy ob oc l od oe">// add event listener to links<br/>const links = document.getElementsByClassName('link');<br/>for(let i = 0; i &lt; links.length; i++) {<br/>  links[i].addEventListener('click', function(event) {<br/>    event.preventDefault();<br/>    get(links[i].href.split('/').pop());<br/>  }, false);<br/>}</span><span id="7300" class="oa mb iq nq b gy of oc l od oe">// add event listener to history changes<br/>window.addEventListener("popstate", function(e) {<br/>  const state = e.state;<br/>  document.title = state.title;<br/>  content_box.innerHTML = state.content;<br/>});</span><span id="34af" class="oa mb iq nq b gy of oc l od oe">// add ready event for initial load of our site<br/>(function(fn = function() {<br/>  const page = useHash ?<br/>    window.location.hash.split('#').pop() :<br/>    window.location.href.split('/').pop();<br/>  get(routes.indexOf(page) &gt;= 0 ? page : routes[0]);<br/>}) {<br/>  if (document.readyState != 'loading'){<br/>    fn();<br/>  } else {<br/>    document.addEventListener('DOMContentLoaded', fn);<br/>  }<br/>})();</span></pre><p id="ff87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们用类<code class="fe nn no np nq b">.link</code>获取所有元素，并为它们附加一个事件监听器，这样当它们被点击时，默认事件被停止，取而代之的是用href的最后一个参数调用我们的<code class="fe nn no np nq b">get</code>函数。</p><p id="4ca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们单击上面列出的第一个链接时，我们将对<code class="fe nn no np nq b">api.com/section-1</code>执行一个GET请求，并将应用程序的URL更新为<code class="fe nn no np nq b">app.com/section-1</code>或<code class="fe nn no np nq b">app.com/#section-1</code>。</p><p id="7380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是我的实现的两个限制:</p><ul class=""><li id="feaf" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated">API和应用程序路由必须匹配。</li><li id="6827" class="ne nf iq kf b kg nr kk ns ko nt ks nu kw nv la nj nk nl nm bi translated">路线不能有多个参数。</li></ul><p id="94eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两者都是可修复的，我不会详细说明，因为它避开了简单概念验证的要点，但我必须指出这一点。第一个问题可以通过使用某种字典来解决，该字典将我们的路由匹配到它们应该获取的端点。第二个问题可以通过使链接的事件监听器中的逻辑更复杂一点来解决，扩展简单的<code class="fe nn no np nq b">links[i].href.split('/').pop()</code>以包含所有期望的参数。</p><p id="ca47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们有了历史变化的事件监听器。由于我们将API返回的内容存储在历史状态本身中，所以当历史发生变化时，我们所要做的就是用我们的<code class="fe nn no np nq b">state.content</code>重新填充<code class="fe nn no np nq b">content_box</code>。</p><p id="ee90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们有ready函数，在DOM最初结束加载时调用，我们检查我们的URL以获得最后一个参数或hash/anchor的值，然后验证我们从URL获得的内容是否存在于我们定义的内部路由数组中。如果是的话，我们调用我们的<code class="fe nn no np nq b">get</code>函数，把它作为一个参数。如果没有，我们从数组中取出第一条路径，用它来调用它。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d680" class="ma mb iq bd mc md og mf mg mh oh mj mk ml oi mn mo mp oj mr ms mt ok mv mw mx bi translated">这是更简单的方法吗？</h1><p id="fdd3" class="pw-post-body-paragraph kd ke iq kf b kg ol ki kj kk om km kn ko on kq kr ks oo ku kv kw op ky kz la ij bi translated">虽然我认为任何人都可以从了解这一点和如何做到这一点中受益，但我不知道我是否同意OP的观点，即避免第三方库是做事的“更简单的方式”。即使这个简单的POC也有缺陷，如果试图将其扩展到更复杂的场景中，就会暴露出更多的缺陷。</p><p id="f56d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这种方法的简单性仅仅是对当前前端框架的复杂性的一种更没有根据的认识的结果。我鼓励任何人在抛弃他们并选择普通的JS路线之前，给<a class="ae kc" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>或<a class="ae kc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>一个机会。</p><p id="6947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="oq">关于我:</em> </strong> <em class="oq">我是一名拥有超过7年经验的全栈式web开发人员，目前正在接受新的机会。你可以查看</em> <a class="ae kc" href="https://lucasreta.com/en/" rel="noopener ugc nofollow" target="_blank"> <em class="oq">我的网站</em> </a> <em class="oq">做进一步参考或者直接写信给我</em><a class="ae kc" href="mailto:1.lucasreta@gmail.com" rel="noopener ugc nofollow" target="_blank"><em class="oq">1.lucasreta@gmail.com</em></a></p></div></div>    
</body>
</html>