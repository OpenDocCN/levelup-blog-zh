<html>
<head>
<title>Calling Multiple APIs Concurrently in Go (Goroutine and WaitGroup)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中同时调用多个API(Go routine和WaitGroup)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/calling-multiple-apis-concurrently-in-go-goroutine-and-waitgroup-5535155902c3?source=collection_archive---------0-----------------------#2021-01-02">https://levelup.gitconnected.com/calling-multiple-apis-concurrently-in-go-goroutine-and-waitgroup-5535155902c3?source=collection_archive---------0-----------------------#2021-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2e916bf8c90653c1372f1ea9df09a118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VtSDyoHInkNscximqpXAA.png"/></div></div></figure><p id="9404" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如今有这么多的REST APIs，您会发现自己处于这样一种情况，需要调用多个端点来构建业务对象的适当表示。这不是一个困难的任务，只需创建一个新对象，调用各种API获取数据，填充适当的字段，就可以了。如果您的所有调用都很快，这很好，但是如果您的一个或所有API调用花费大量时间，这就开始变得很麻烦了。</p><p id="670e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本帖中，我们将看看如何使用Goroutines和WaitGroups在Go中同时进行这些调用。我们将编写一些模拟API调用的代码，并在每个代码中引入一些延迟。我们将同步调用每个端点并计时。然后，我们将重构代码以同时调用它们并比较结果。我们走吧！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b76e" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">设置</h1><p id="1b3a" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在这段代码中，我们将模拟调用多个(三个)不同的API来构建自定义结构的所有数据。在每个“API”调用中，我们将引入一个“睡眠”来模拟调用中的延迟。让我们看看代码。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7730" class="ms lh it mo b gy mt mu l mv mw">package main</span><span id="0e48" class="ms lh it mo b gy mx mu l mv mw">import (<br/> "encoding/json"<br/> "fmt"<br/> "log"<br/> "time"<br/>)</span><span id="0d9e" class="ms lh it mo b gy mx mu l mv mw">type City struct {<br/> Name       string<br/> Population int<br/> Households int<br/> Temp       int<br/> Forecast   string<br/> Elevation  int<br/> Lat        float64<br/> Long       float64<br/>}</span><span id="248a" class="ms lh it mo b gy mx mu l mv mw">// Main function<br/>func main() {<br/> defer timeTrack(time.Now(), "Fetching city info")</span><span id="f781" class="ms lh it mo b gy mx mu l mv mw"> fmt.Println("Starting synchronous calls...")</span><span id="b710" class="ms lh it mo b gy mx mu l mv mw"> city := City{Name: "Richmond"}</span><span id="cb04" class="ms lh it mo b gy mx mu l mv mw"> getDemoInfo(&amp;city)<br/> getCurrentWeather(&amp;city)<br/> getMapInfo(&amp;city)</span><span id="0b52" class="ms lh it mo b gy mx mu l mv mw"> data, _ := json.Marshal(city)<br/> fmt.Printf("%s\n", data)<br/>}</span><span id="a392" class="ms lh it mo b gy mx mu l mv mw">func getDemoInfo(c *City) {<br/> // Calling Sleep method (lag)<br/> time.Sleep(2100 * time.Millisecond)</span><span id="f2fa" class="ms lh it mo b gy mx mu l mv mw"> c.Population = 230436<br/> c.Households = 90301<br/>}</span><span id="c36c" class="ms lh it mo b gy mx mu l mv mw">func getCurrentWeather(c *City) {<br/> // Calling Sleep method (lag)<br/> time.Sleep(1200 * time.Millisecond)<br/> <br/> c.Temp = 32<br/> c.Forecast = "Snow, turning to rain"<br/>}</span><span id="2739" class="ms lh it mo b gy mx mu l mv mw">func getMapInfo(c *City) {<br/> // Calling Sleep method (lag)<br/> time.Sleep(3300 * time.Millisecond)</span><span id="fdb0" class="ms lh it mo b gy mx mu l mv mw"> c.Elevation = 457<br/> c.Lat = 37.533333333<br/> c.Long = -77.466666666<br/>}</span><span id="4175" class="ms lh it mo b gy mx mu l mv mw">func timeTrack(start time.Time, name string) {<br/> elapsed := time.Since(start)<br/> log.Printf("%s took %s", name, elapsed)<br/>}</span></pre><p id="26c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们分解这段代码的每一部分:</p><ul class=""><li id="fb8b" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">首先，我们有一个包含三个数据部分的<code class="fe nh ni nj mo b">City</code>结构:人口统计、天气和地图。</li><li id="e6b7" class="my mz it kd b ke nk ki nl km nm kq nn ku no ky nd ne nf ng bi translated">在我们的<code class="fe nh ni nj mo b">main</code>函数中，我们立即推迟对自定义<code class="fe nh ni nj mo b">timeTrack</code>函数的调用。这只是一个助手，将时间和打印功能需要多长时间运行。</li><li id="19e4" class="my mz it kd b ke nk ki nl km nm kq nn ku no ky nd ne nf ng bi translated">接下来，我们新建一个<code class="fe nh ni nj mo b">City</code>对象，并将其命名为Richmond (RVA宝贝！)，然后进行三次调用来获取我们需要的所有数据，通过引用传递<code class="fe nh ni nj mo b">city</code>对象。</li><li id="d9d7" class="my mz it kd b ke nk ki nl km nm kq nn ku no ky nd ne nf ng bi translated">在<code class="fe nh ni nj mo b">main</code>函数的最后，我们简单地打印了一个我们城市的JSON表示。</li><li id="9878" class="my mz it kd b ke nk ki nl km nm kq nn ku no ky nd ne nf ng bi translated">在我们的每个“API”调用中，我们简单地调用一个带有随机值的<code class="fe nh ni nj mo b">time.Sleep</code>。同样，这模拟了您可能在真实API调用中发现的延迟。</li></ul><p id="044d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为这些是同步调用，所以您实际上可以遍历每个“API”调用，并将我们引入的“休眠”相加，以确定这段代码应该运行多长时间。把这些加起来，我们得到6.6秒。运行这段代码，我们得到以下输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d44f" class="ms lh it mo b gy mt mu l mv mw">Starting synchronous calls...<br/>{"Name":"Richmond","Population":230436,"Households":90301,"Temp":32,"Forecast":"Snow, turning to rain","Elevation":457,"Lat":37.533333333,"Long":-77.466666666}<br/>2021/01/02 14:03:37 Fetching city info took 6.606641483s</span></pre><p id="c72b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好的，这看起来很棒！我们创建了一个<code class="fe nh ni nj mo b">City</code>对象，称为一组“API ”,填充我们的对象，并打印结果。这看起来不错，但是6.6秒对你的用户来说可能太长了(对我的用户来说是这样)。让我们看看如何轻松地修改这段代码，以便同时进行所有这些调用。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="18da" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">所有人，立刻</h1><p id="bfa9" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">为了实现这一点，我们将介绍两件事情:</p><ul class=""><li id="44a5" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">Go routine:Go routine是由Go运行时管理的轻量级线程。这些是OS线程之上的包装器，由Go运行时而不是操作系统管理。基本上把<code class="fe nh ni nj mo b">go</code>放在你的函数调用前面，它处理剩下的。这里有一篇很有深度的文章<a class="ae np" href="https://medium.com/technofunnel/understanding-golang-and-goroutines-72ac3c9a014d" rel="noopener">。</a></li><li id="abe3" class="my mz it kd b ke nk ki nl km nm kq nn ku no ky nd ne nf ng bi translated">WaitGroups:一个<a class="ae np" href="https://golang.org/pkg/sync/#WaitGroup" rel="noopener ugc nofollow" target="_blank"> WaitGroup </a>等待goroutines的收集完成。这里有一篇<a class="ae np" href="https://medium.com/swlh/using-goroutines-and-wait-groups-for-concurrency-in-golang-78ca7a069d28" rel="noopener">很棒的写起来要深挖一点</a>。</li></ul><p id="3e8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，对于我们的代码来说，没有什么需要修改的地方。让我们来看看修改后的代码:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d3c8" class="ms lh it mo b gy mt mu l mv mw">func main() {<br/> defer timeTrack(time.Now(), "Fetching city info")</span><span id="431a" class="ms lh it mo b gy mx mu l mv mw"> fmt.Println("Starting concurrent calls...")</span><span id="09ea" class="ms lh it mo b gy mx mu l mv mw"> var waitgroup sync.WaitGroup<br/> waitgroup.Add(3)</span><span id="cdf3" class="ms lh it mo b gy mx mu l mv mw"> city := City{Name: "Richmond"}</span><span id="3f04" class="ms lh it mo b gy mx mu l mv mw"> go func() {<br/>  getDemoInfo(&amp;city)<br/>  waitgroup.Done()<br/> }()</span><span id="46e6" class="ms lh it mo b gy mx mu l mv mw"> go func() {<br/>  getCurrentWeather(&amp;city)<br/>  waitgroup.Done()<br/> }()</span><span id="d19a" class="ms lh it mo b gy mx mu l mv mw"> go func() {<br/>  getMapInfo(&amp;city)<br/>  waitgroup.Done()<br/> }()</span><span id="23d1" class="ms lh it mo b gy mx mu l mv mw"> waitgroup.Wait()</span><span id="638d" class="ms lh it mo b gy mx mu l mv mw"> data, _ := json.Marshal(city)<br/> fmt.Printf("%s\n", data)<br/>}</span></pre><p id="21e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们打开包装:</p><ul class=""><li id="5579" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">这个片段中没有显示，我们必须导入<code class="fe nh ni nj mo b">WaitGroup</code>所在的<code class="fe nh ni nj mo b">sync</code>包。</li><li id="43e5" class="my mz it kd b ke nk ki nl km nm kq nn ku no ky nd ne nf ng bi translated">一旦我们有了导入，我们就可以为我们的WaitGroup <code class="fe nh ni nj mo b">var waitgroup sync.WaitGroup</code>创建一个新变量</li><li id="539b" class="my mz it kd b ke nk ki nl km nm kq nn ku no ky nd ne nf ng bi translated">接下来，我们必须告诉我们的WaitGroup我们将使用<code class="fe nh ni nj mo b">waitgroup.Add(3)</code>开始多少goroutines。</li><li id="a694" class="my mz it kd b ke nk ki nl km nm kq nn ku no ky nd ne nf ng bi translated">然后，我们创建三个匿名函数来包装我们的“API”调用。在这里使用匿名函数可以让我们不去动原来的“API”调用，这很好。当使用WaitGroup时，您必须调用<code class="fe nh ni nj mo b">waitgroup.Done()</code>，这将减少我们之前给WaitGroup的计数。这就是它如何知道所有的goroutines什么时候完成。如果我们在这里没有使用匿名函数，我们需要更新我们的“API”调用函数，通过引用传递我们的WaitGroup对象，然后调用其中的<code class="fe nh ni nj mo b">Done()</code>方法。在我看来，这更干净，因为它不会混淆实现。</li></ul><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="31ea" class="ms lh it mo b gy mt mu l mv mw">go func() {<br/>  getDemoInfo(&amp;city)<br/>  waitgroup.Done()<br/> }()</span></pre><ul class=""><li id="e3fd" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">最后，我们需要等待所有调用结束，因此我们有一个<code class="fe nh ni nj mo b">waitgroup.Wait()</code>调用。这告诉我们的WaitGroup阻塞，直到所有的goroutines都完成。它知道这一点是因为我们告诉它我们有3个要运行，并且每个调用都用一个<code class="fe nh ni nj mo b">waitgroup.Done()</code>来减少这个计数。一旦计数达到0，该块就被释放，函数可以继续运行。</li></ul><p id="3a10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然所有的调用都在同时运行，我们应该看到运行时间等于运行时间最长的“API”调用，即3.3秒。运行这段代码，我们得到以下输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="dd9e" class="ms lh it mo b gy mt mu l mv mw">Starting concurrent calls...<br/>{"Name":"Richmond","Population":230436,"Households":90301,"Temp":32,"Forecast":"Snow, turning to rain","Elevation":457,"Lat":37.533333333,"Long":-77.466666666}<br/>2021/01/02 14:34:00 Fetching city info took 3.305725811s</span></pre><p id="46dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好多了！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ebcc" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">包扎</h1><p id="e5aa" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在这篇文章中，我们快速看了一下如何在Go中使用WaitGroups进行并发API调用。我们花了很长时间，把运行时间缩短了一半！在Go中还有其他的并发编程方式。有<a class="ae np" href="https://tour.golang.org/concurrency/2" rel="noopener ugc nofollow" target="_blank">通道</a>，允许你接收从goroutines返回的数据，还有一起使用<a class="ae np" href="https://dev.to/sophiedebenedetto/synchronizing-go-routines-with-channels-and-waitgroups-3ke2" rel="noopener ugc nofollow" target="_blank">通道和等待组</a>。这篇文章希望是对这些概念的快速介绍，现在你可以更深入地了解了！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="5094" class="ms lh it bd li nq nr dn lm ns nt dp lq km nu nv lu kq nw nx ly ku ny nz mc oa bi translated">资源</h2><p id="aa7e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">GitHub Repo:<a class="ae np" href="https://github.com/atkinsonbg/calling-apis-concurrently-go-waitgroups" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/atkinsonbg/calling-APIs-concurrent-go-wait groups</a></p><p id="cf35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">https://tour.golang.org/concurrency/1</p><p id="c382" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">等待组:<a class="ae np" href="https://golang.org/pkg/sync/#WaitGroup" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/sync/#WaitGroup</a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><figure class="mj mk ml mm gt ju gh gi paragraph-image"><a href="https://ko-fi.com/O5O63ENS7"><div class="gh gi ob"><img src="../Images/3515ab52cb6fb5e74c27c7a2e06d3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5imNjCtY48Wh3owQyPv6Cw.png"/></div></a></figure></div></div>    
</body>
</html>