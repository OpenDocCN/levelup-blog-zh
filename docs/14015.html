<html>
<head>
<title>JavaScript Design Patterns: Strategy Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式:策略模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-design-patterns-strategy-pattern-c013d3dbc059?source=collection_archive---------3-----------------------#2022-10-25">https://levelup.gitconnected.com/javascript-design-patterns-strategy-pattern-c013d3dbc059?source=collection_archive---------3-----------------------#2022-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e45189971eadc294c6fe5e81316951fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3ZhaNN3WoqXdxKrCVbpsA.png"/></div></div></figure><p id="5993" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">学习设计模式的目的是代码的可重用性，使代码更容易被他人理解，并确保代码的可靠性。设计模式使编码真正工程化；设计模式是软件工程的基石，就像建筑物的结构一样。</p><p id="e9d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有23个经典的设计模式，但并不是每个设计模式都被频繁使用。在这里，我们介绍最常见和实用的设计模式。在上一期中，我们介绍了<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/javascript-design-patterns-singleton-pattern-7ada98be9a10">单例模式</a>。今天，我们将介绍策略模式。</p><blockquote class="la lb lc"><p id="b157" class="kb kc ld kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated">在计算机编程中，策略模式(也称为策略模式)是一种行为软件设计模式，允许在运行时选择算法。代码不是直接实现单个算法，而是接收运行时指令，以决定使用哪一组算法。</p></blockquote><p id="b045" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你在开发一个网店项目，每个产品都有一个原价，叫做<code class="fe lh li lj lk b">originalPrice</code>。但实际上并非所有产品都是全价销售，可能会推出允许商品打折销售的促销活动。</p><p id="f733" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">商家可以在后台为产品设置不同的状态，然后会根据产品状态和原价动态调整实际售价。</p><p id="2026" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">具体规则如下:</p><ul class=""><li id="ed8a" class="ll lm it kd b ke kf ki kj km ln kq lo ku lp ky lq lr ls lt bi translated"><strong class="kd iu">部分产品预售:</strong>为鼓励顾客预购，会有原价八折优惠。</li><li id="d624" class="ll lm it kd b ke lu ki lv km lw kq lx ku ly ky lq lr ls lt bi translated"><strong class="kd iu">部分产品处于正常促销阶段:</strong>原价小于等于100，打九折销售；如果原价高于100，他们就优惠10元。</li><li id="0e15" class="ll lm it kd b ke lu ki lv km lw kq lx ku ly ky lq lr ls lt bi translated"><strong class="kd iu">部分商品没有任何促销:</strong>默认状态，全价销售。</li></ul><p id="7e02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这时候你需要写一个函数getPrice来获取产品的价格。应该怎么写？</p><pre class="lz ma mb mc gt md lk me mf aw mg bi"><span id="20c1" class="mh mi it lk b gy mj mk l ml mm">function getPrice(originalPrice,status){<br/>   //...<br/>   //return price<br/>}</span></pre><p id="ae05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其实面对这样的问题，在不考虑任何设计模式的情况下，最直观的写法可能就是if-else多个条件判断语句来计算价格。</p><p id="3ef1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有三种状态，您可以像这样快速编写代码:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="76c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有三个条件，上面的代码写了三条<code class="fe lh li lj lk b">if</code>语句，很直观的代码，但是这段代码组织的不好。</p><p id="bf51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，它违反了单一责任原则(即每个类或函数都应该有一个单一的函数，并且该函数应该被该类或函数完全封装)。函数<code class="fe lh li lj lk b">getPrice </code>做的事情太多，这个函数不容易读懂，容易出bug。如果一个条件出错，整个功能就会崩溃。同时，这样的代码也不容易调试。</p><p id="d5fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而且这种代码很难应对不断变化的需求。这时候就要考虑设计模式了，设计模式往往在业务逻辑发生变化的时候才显示出它的魅力。</p><p id="a9c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设生意扩大，现在又有一个打折促销:黑色星期五。折扣规则如下:</p><ul class=""><li id="66ce" class="ll lm it kd b ke kf ki kj km ln kq lo ku lp ky lq lr ls lt bi translated">价格低于或等于100美元的产品以20%的折扣出售。</li><li id="a4a5" class="ll lm it kd b ke lu ki lv km lw kq lx ku ly ky lq lr ls lt bi translated">定价高于100美元但低于200美元的产品将打折20美元。</li><li id="e8c7" class="ll lm it kd b ke lu ki lv km lw kq lx ku ly ky lq lr ls lt bi translated">价格高于或等于200美元的产品将减少20美元。</li></ul><p id="1a73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时如何扩展<code class="fe lh li lj lk b">getPrice </code>功能？</p><p id="fb9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看起来你必须给<code class="fe lh li lj lk b">getPrice </code>函数添加一个条件语句:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6bf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当折扣增加或减少时，功能都需要改变。这种做法违反了开闭原则(开放用于扩展，关闭用于修改)。修改现有功能容易产生新的bug，让<code class="fe lh li lj lk b">getPrice </code>越来越臃肿。</p><p id="83b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么如何优化这段代码呢？</p><p id="f4b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，可以拆分<code class="fe lh li lj lk b">getPrice </code>功能以减少臃肿。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5a38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经过这次修改，虽然代码行数有所增加，但是可读性有了明显的提高。<code class="fe lh li lj lk b">getPrice </code>函数显然没有那么臃肿，写单元测试更方便。<br/>但是上面的改动并没有解决根本问题:代码中仍然充满了if-else，在加减折扣规则时<code class="fe lh li lj lk b">getPrice </code>仍然需要修改。<br/>其实用这些<code class="fe lh li lj lk b">if-else</code>的目的就是为了对应状态和折扣策略。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/9d412c4722c9826858dc8455b1b84944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Shp-wVFCS-u6jnb7Tp9irA.png"/></div></div></figure><p id="9608" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从图中可以看出，这个逻辑本质上是一个映射关系:产品状态和折扣策略的映射关系。</p><p id="3b9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以用map代替冗长的if-else来存储地图。按照这种思路，可以构建一个价格策略映射关系(策略名称与其处理功能之间的映射)，如下:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="94b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结合状态和折扣策略，价格函数可以优化如下:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9537" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，如果需要增减折扣策略，则不需要修改该功能，只需要修改价格策略映射关系priceStrategies即可</p><p id="1acf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前面的代码逻辑如下:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/0ba52cb8588f85733f2f482197280dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3aNBEgK8yNoLehX4bMCiQ.png"/></div></div></figure><p id="6b19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">优化的代码逻辑如下:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/068f80e0db9c7e1b9d662c2652f18f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*j5lgsqMqvXov0soFWNym_w.png"/></div></figure><p id="d7cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上优化策略使用的是设计模式的策略模式，在实际项目开发过程中更加实用。</p><p id="d75c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在什么情况下可以考虑使用策略模式？如果函数具有以下特征:</p><ul class=""><li id="653a" class="ll lm it kd b ke kf ki kj km ln kq lo ku lp ky lq lr ls lt bi translated">判断条件有很多</li><li id="ae60" class="ll lm it kd b ke lu ki lv km lw kq lx ku ly ky lq lr ls lt bi translated">每种判断条件下的代码是相互独立的。</li></ul><p id="c284" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后可以将每个判断条件下的代码封装成一个独立的函数，然后建立判断条件和具体策略之间的映射关系。</p><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-design-patterns-singleton-pattern-7ada98be9a10"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">JavaScript设计模式:单例模式</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Singleton模式:将类实例化的次数限制为一次，一个类只有一个实例，并且…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jz mv"/></div></div></a></div></div></div>    
</body>
</html>