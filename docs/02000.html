<html>
<head>
<title>Building A CD Pipeline With Drone CI And Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无人机CI和Kubernetes构建CD管道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-cd-pipeline-with-drone-ci-and-kubernetes-4b8c44e89fe2?source=collection_archive---------5-----------------------#2020-02-11">https://levelup.gitconnected.com/building-a-cd-pipeline-with-drone-ci-and-kubernetes-4b8c44e89fe2?source=collection_archive---------5-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b31e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文原载于</em><a class="ae kp" href="https://www.magalix.com/blog/building-a-cd-pipeline-with-drone-ci-and-kubernetes" rel="noopener ugc nofollow" target="_blank">https://www . magalix . com/blog/building-a-CD-pipeline-with-drone-ci-and-kubernetes</a></p><p id="64f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上一篇文章中，我们讨论了什么是<a class="ae kp" href="https://www.magalix.com/blog/create-a-ci/cd-pipeline-with-kubernetes-and-jenkins" rel="noopener ugc nofollow" target="_blank"> CI/CD </a>，它试图解决的问题类型，以及它在DevOps范例中的位置。我们还建立了一个小型实验室，在那里我们使用Jenkins、Ansible和Kubernetes建立了一个连续交付(CD)管道。在本文中，我们将构建一个类似的CD管道，但是这次我们使用的是<a class="ae kp" href="https://drone.io/" rel="noopener ugc nofollow" target="_blank"> Drone CI </a>。</p><h1 id="bc9b" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是无人机CI？</h1><p id="d9c7" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">Drone CI用Go编写，于2014年首次发布，是一个使用容器优先方法的构建工具。Drone最突出的特点就是用容器装<em class="ko">一切</em>。Drone中最复杂的管道中的每个阶段都是通过Docker容器执行的。这为使用多种工具和/或环境来满足您的构建和<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank">部署</a>需求提供了极大的灵活性。与Jenkins不同，Drone CI必须与Git存储库集成才能正常工作。它有许多插件，可以作为Docker容器部署。它们可以像UNIX工具(ls、cat、tee等)一样使用。)都用上了。</p><p id="6f58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无人侦察机利用YAML的文件获取指令。指令文件与应用程序代码的其余部分一起在存储库中进行检查。当Jenkins中的声明性管道被配置为使用作为存储库一部分的Jenkinsfile时，这种行为与它们非常相似。然而，Jenkins使用Groovy作为DSL语言。</p><h1 id="54fa" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">我们的示例应用程序:用Go编写的Hello-World API</h1><p id="b783" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在这个实验中，我们简化了构建、测试和交付一个用Go编写的简单API的过程。当根URL收到GET请求时，API应该显示“hello world”。让我们从应用程序代码(main.go)开始:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0252" class="mc kr it ly b gy md me l mf mg">package main</span><span id="d9b9" class="mc kr it ly b gy mh me l mf mg">import (<br/>   "log"<br/>   "net/http"<br/>)</span><span id="c081" class="mc kr it ly b gy mh me l mf mg">type Server struct{}</span><span id="1019" class="mc kr it ly b gy mh me l mf mg">func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {<br/>   w.WriteHeader(http.StatusOK)<br/>   w.Header().Set("Content-Type", "application/json")<br/>   w.Write([]byte(`{"message": "hello world"}`))<br/>}</span><span id="8a8c" class="mc kr it ly b gy mh me l mf mg">func main() {<br/>   s := &amp;Server{}<br/>   http.Handle("/", s)<br/>   log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="bd01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要对代码进行一些测试。Go使这变得非常容易，我们只需要添加一个包含我们的测试函数的文件，并将其命名为main_test.go:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="062c" class="mc kr it ly b gy md me l mf mg">package main</span><span id="3c3a" class="mc kr it ly b gy mh me l mf mg">import (<br/>   "io/ioutil"<br/>   "net/http"<br/>   "net/http/httptest"<br/>   "testing"<br/>)</span><span id="88b5" class="mc kr it ly b gy mh me l mf mg">func TestServeHTTP(t *testing.T) {<br/>   handler := &amp;Server{}<br/>   server := httptest.NewServer(handler)<br/>   defer server.Close()</span><span id="e2a7" class="mc kr it ly b gy mh me l mf mg">resp, err := http.Get(server.URL)<br/>   if err != nil {<br/>       t.Fatal(err)<br/>   }<br/>   if resp.StatusCode != 200 {<br/>       t.Fatalf("Received non-200 response: %d\n", resp.StatusCode)<br/>   }<br/>   expected := `{"message": "hello world"}`<br/>   actual, err := ioutil.ReadAll(resp.Body)<br/>   if err != nil {<br/>       t.Fatal(err)<br/>   }<br/>   if expected != string(actual) {<br/>       t.Errorf("Expected the message '%s' but got '%s'\n", expected,actual)<br/>   }<br/>}</span></pre><p id="720b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了建立一个图像，我们需要一个docker文件。它可能看起来像这样:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a2a5" class="mc kr it ly b gy md me l mf mg">FROM golang:alpine AS build-env<br/>RUN mkdir /go/src/app &amp;&amp; apk update &amp;&amp; apk add git<br/>ADD main.go /go/src/app/<br/>WORKDIR /go/src/app<br/>RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-extldflags "-static"' -o app .</span><span id="871d" class="mc kr it ly b gy mh me l mf mg">FROM scratch<br/>WORKDIR /app<br/>COPY --from=build-env /go/src/app/app .<br/>ENTRYPOINT [ "./app" ]</span></pre><h1 id="93b0" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">在Kubernetes上安装和配置Drone CI</h1><h1 id="2b3d" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">安装舵</h1><p id="3e95" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">安装无人机CI最简单快捷的方法就是使用<a class="ae kp" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">舵图</a>。如果你不知道Helm是什么，它只是Kubernetes的一个包管理器。每当你有一个应用程序需要不同的Kubernetes资源，比如<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank">部署</a>、<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-services-101-the-pods-interfaces" rel="noopener ugc nofollow" target="_blank">服务</a>、<a class="ae kp" href="https://www.magalix.com/blog/the-configmap-pattern" rel="noopener ugc nofollow" target="_blank">配置映射</a>、<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-secrets-101" rel="noopener ugc nofollow" target="_blank">秘密</a>等。您可以将它打包到一个舵图中，通过一个命令部署(或删除)所有内容。Helm本身由两个组件组成:客户端工具(helm ),它是一个运行在笔记本电脑上的二进制文件；服务器端工具(tiller ),它运行在服务器上。</p><p id="337f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您已经拥有对正在运行的<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-101-concepts-and-why-it-matters" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群的管理权限，您可以通过以下简单步骤安装Helm:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="89b4" class="mc kr it ly b gy md me l mf mg"># cd /tmp<br/># curl <a class="ae kp" href="https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get</a> &gt; install-helm.sh<br/># chmod u+x install-helm.sh<br/># ./install-helm.sh</span><span id="bcde" class="mc kr it ly b gy mh me l mf mg"># kubectl -n kube-system create serviceaccount tiller<br/># kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller<br/># helm init --service-account tiller</span></pre><p id="ff5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端只是保存在您自己的笔记本电脑上的二进制文件。为了部署Tiller，我们需要为它创建一个服务帐户。我们称之为蒂勒。然后，我们创建一个ClusterRoleBinding来将服务帐户添加到cluster-admin，这是Kubernetes附带的一个内置角色。顾名思义，该角色授予其用户对集群的管理权限。</p><h1 id="91ec" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">部署无人机CI</h1><p id="1458" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在部署Drone之前，我们必须在存储库上创建一个OAuth应用程序。在本实验中，我们使用GitHub，但同样的概念也适用于其他主要的存储库服务，如BitBucket、GitLab等。</p><p id="8b7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于GitHub，转到<a class="ae kp" href="https://github.com/settings/developers" rel="noopener ugc nofollow" target="_blank">https://github.com/settings/developers</a>并创建一个新的应用程序:</p><figure class="lt lu lv lw gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mi"><img src="../Images/8ded75089e0e4f453cfaa0c851b5b89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zRpNbZbVp2fUn1n1.png"/></div></div></figure><p id="07ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可能会注意到，我们没有为主页或回调URL指定有效的URL。我们这样做是因为我们还没有正确的URL。一旦我们在Kubernetes上创建了服务，我们就可以返回并相应地更改URL。现在，我们只需要令牌:</p><figure class="lt lu lv lw gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mq"><img src="../Images/2b173cdbd9f730e08e6766365b70c59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5oHTHnbBIAIUGNja.png"/></div></div></figure><p id="ebf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要Kubernetes访问这个客户秘密，以便无人机CI可以在必要时使用它。让我们创建一个秘密来保存我们的令牌:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="647f" class="mc kr it ly b gy md me l mf mg">kubectl create secret generic drone-server-secrets --namespace=default --from-literal=clientSecret="80b2fd9ae648384df5fb87955a5ed34962bf3c49"</span></pre><p id="36d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Helm使用一个名为values.yaml的文件，您可以在其中进行不同的定义和覆盖。一旦我们有了舵和舵杆，使用它的舵图部署无人机就相对容易了:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3174" class="mc kr it ly b gy md me l mf mg">helm install --name drone-release stable/drone</span></pre><p id="bcfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能会注意到输出中的一条错误消息，该消息发送了一条警告，指出安装未完成，因为我们没有指定版本控制系统。类似于以下内容:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e077" class="mc kr it ly b gy md me l mf mg">NOTES:<br/>##############################################################################<br/>####        ERROR: You did not set a valid version control provider       ####<br/>##############################################################################</span></pre><p id="bbe6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着我们仍然需要提供重要的信息，以便我们的部署能够正常工作。让我们接下来这样做:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="20e6" class="mc kr it ly b gy md me l mf mg">helm upgrade drone --reuse-values --set 'service.type=NodePort' --set 'service.nodePort=32000' --set 'sourceControl.provider=github' --set 'sourceControl.github.clientID=0cb6e52e26befec35a3e' --set 'sourceControl.secret=drone-server-secrets' stable/drone</span></pre><p id="54e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Helm通过以下两种方式之一接受部署中使用的自定义变量:</p><ul class=""><li id="0e6d" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">使用values.yaml文件。</li><li id="e69c" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">通过使用set选项直接在命令行中设置这些值。</li></ul><p id="84e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两种方法通常结合使用，values.yaml文件包含默认值，而set选项会覆盖它。</p><p id="fd2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的示例中，我们正在为我们的Helm部署设置一些重要的值:</p><ul class=""><li id="41bd" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">service.type设置为NodePort。我们可以根据自己的喜好将其设置为LoadBalancer或ClusterIP。</li><li id="2a81" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">service.nodePort:因为我们使用的是nodePort服务类型，所以我们设置了NodePort，这样我们就可以在防火墙上启用它。</li><li id="20ea" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">提供商是github。</li><li id="cee8" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">最后两个选项设置了客户端ID和客户端密码，以便Drone能够与GitHub通信。</li></ul><p id="f8c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您需要设置不同的值或探索其他选项，您可以参考舵图文档页面:<a class="ae kp" href="https://github.com/helm/charts/tree/master/stable/drone" rel="noopener ugc nofollow" target="_blank">https://github.com/helm/charts/tree/master/stable/drone</a></p><p id="4209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们需要获取我们的无人机服务器的IP地址来更新部署，并且还要更新我们的GitHub应用程序设置:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ebb9" class="mc kr it ly b gy md me l mf mg">$ kubectl get nodes -o wide<br/>NAME                                                STATUS   ROLES    AGE     VERSION          INTERNAL-IP   EXTERNAL-IP      OS-IMAGE                             KERNEL-VERSION   CONTAINER-RUNTIME<br/>gke-standard-cluster-1-default-pool-e317cef6-79bh   Ready       4h32m   v1.15.4-gke.18   10.128.0.60   35.239.209.198   Container-Optimized OS from Google   4.19.76+         docker://19.3.1</span></pre><p id="1e50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获得URL后，我们可以按如下方式更新部署:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6dff" class="mc kr it ly b gy md me l mf mg">helm upgrade drone-release --reuse-values --set 'server.host=<a class="ae kp" href="http://35.239.209.198:32000'" rel="noopener ugc nofollow" target="_blank">http://35.239.209.198:32000'</a> stable/drone</span></pre><p id="0653" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，更新GitHub应用程序:</p><figure class="lt lu lv lw gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nf"><img src="../Images/ef4b09d1be46d88e932435954b750b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dt2hIg24VConO05B.png"/></div></div></figure><p id="bcc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在导航到http://35.239.209.198:32000<a class="ae kp" href="http://35.239.209.198:32000" rel="noopener ugc nofollow" target="_blank"/>。您可能需要在GitHub中授权该应用程序。接下来，您应该会看到一个包含您帐户中所有存储库的页面:</p><figure class="lt lu lv lw gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ng"><img src="../Images/7dfec7d0771ead38384731f9ac457fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h3Q7N0njlMsp26s6.png"/></div></div></figure><p id="bd2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要通过单击名称旁边的激活链接来激活存储库。</p><h1 id="c332" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">建设管道</h1><p id="f52c" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">Drone使用一个名为. drone.yml的YAML文件，该文件与其余的代码文件一起签入存储库。您可以通过Drone UI中的存储库设置随意更改该文件的名称和路径。的。无人机文件包含一个管道，该管道可能有一个或多个部署步骤。要到达某个步骤，必须成功执行前一个步骤。让我们看看我们的。无人机文件可能看起来:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8159" class="mc kr it ly b gy md me l mf mg">kind: pipeline<br/>name: default<br/>steps:<br/>- name: test<br/> image: golang:1.10-alpine<br/> commands:<br/>   - "go test"</span></pre><p id="d21e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该文件以管道的定义和名称(缺省值)开始。然后我们编写第一步:测试。我们使用包含go二进制的golang图像。一旦调用了映像，工作区目录就会自动装载到容器中。接下来，我们运行go test，它将运行main_test.go文件中的任何测试函数。如果任何一个测试失败，管道就会失败，输出会解释哪个测试用例失败了。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b8da" class="mc kr it ly b gy md me l mf mg">- name: build<br/> image: golang:1.10-alpine<br/> commands:<br/>   - "go build -o ./myapp"</span></pre><p id="c510" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是建立形象。虽然我们不打算使用所创建的二进制文件，但是这一步非常重要，因为它验证了代码是否可以顺利构建。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6d46" class="mc kr it ly b gy md me l mf mg">- name: publish<br/> image: plugins/docker<br/> settings:<br/>   repo: magalixcorp/k8scicd<br/>   tags: [ "${DRONE_COMMIT_SHA:0:7}","latest" ]<br/>   username:<br/>     from_secret: docker_username<br/>   password:<br/>     from_secret: docker_password</span></pre><p id="21d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在发布步骤中，代码实际上被保存在Docker映像中，并被推送到注册表中，以便以后可以在任何环境中使用。让我们来看看这个步骤中有趣的部分:</p><ul class=""><li id="d3b0" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">我们用的是无人机的Docker插件。这个插件允许我们使用提供的Docker文件从代码中构建Docker映像。</li><li id="ccba" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">该插件需要图像名称(repo)、标记以及注册中心的凭证。在我们的例子中，我们使用Docker Hub。</li><li id="686a" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">注意，出于安全原因，我们不应该在文件中直接添加用户名和密码。相反，我们使用from_secret指令，使我们能够从Drone的秘密中检索值。</li><li id="acac" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">我们需要将Docker用户名和密码添加到Drone中。这可以通过存储库的设置页面来完成，如屏幕截图所示:</li></ul><figure class="lt lu lv lw gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mq"><img src="../Images/c6d571c31c34320479f322e021b1a9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rpJDdyK1J7pLrDPT.png"/></div></div></figure><p id="bbc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是管道的最后一部分，负责将图像实际部署到Kubernetes:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7c41" class="mc kr it ly b gy md me l mf mg">- name: deliver<br/> image: sinlead/drone-kubectl<br/> settings:<br/>   kubernetes_server:<br/>     from_secret: k8s_server<br/>   kubernetes_cert:<br/>     from_secret: k8s_cert<br/>   kubernetes_token:<br/>     from_secret: k8s_token<br/> commands:<br/>   - kubectl apply -f deployment.yml</span></pre><p id="b402" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一步中，我们使用包含kubectl的图像。请注意，这张图片是为无人机设计的。您可以通过查看项目的资源库来检查作者所做的调整:<a class="ae kp" href="https://github.com/sinlead/drone-kubectl" rel="noopener ugc nofollow" target="_blank">https://github.com/sinlead/drone-kubectl</a></p><p id="2ea2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，该步骤包括调用一个名为deployment.yml的文件。它看起来如下:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="9c20" class="mc kr it ly b gy md me l mf mg">apiVersion: v1<br/>kind: Service<br/>metadata:<br/> name: hello-svc<br/>spec:<br/> selector:<br/>   role: app<br/> ports:<br/>   - protocol: TCP<br/>     port: 80<br/>     targetPort: 8080<br/>     nodePort: 32001<br/> type: NodePort<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/> name: hello-deployment<br/> labels:<br/>   role: app<br/>spec:<br/> replicas: 2<br/> selector:<br/>   matchLabels:<br/>     role: app<br/> template:<br/>   metadata:<br/>     labels:<br/>       role: app<br/>   spec:<br/>     containers:<br/>     - name: app<br/>       image: "magalixcorp/k8scicd"<br/>       resources:<br/>         requests:<br/>           cpu: 10m</span></pre><p id="9e3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能还注意到，我们正在将Drone的秘密变量注入到这个管道步骤中，以便我们可以向Kubernetes认证和授权Drone:</p><p id="a999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">kubernetes_cert是kubernetes使用的CA证书。它可以通过以下命令获得:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="cabf" class="mc kr it ly b gy md me l mf mg">$ kubectl get secret drone-token-sn77f -o jsonpath='{.data.ca\.crt}' &amp;&amp; echo</span></pre><p id="6ff4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个秘密是kubernetes_token，这是我们正在使用的服务帐户的令牌。可以通过以下方式获得:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="cc24" class="mc kr it ly b gy md me l mf mg">$ kubectl get secret drone-token-sn77f -o jsonpath='{.data.token}' | base64 --decode &amp;&amp; echo</span></pre><p id="c85c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">drone-token-sn77f是为服务帐户创建的密码的名称。它也可以通过以下命令获得:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="1278" class="mc kr it ly b gy md me l mf mg">$ kubectl get secrets</span></pre><p id="832f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，drone是具有创建和管理相关资源所需访问权限的服务帐户的名称。创建和授权服务帐户超出了本文的范围，但是您可以在我们的文章<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-authorization" rel="noopener ugc nofollow" target="_blank"> Kubernetes Authorization </a>中找到详细的演练。</p><h1 id="fc85" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">调用管道</h1><p id="7cac" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在测试管道调用之前，我们需要确保在GitHub上正确配置了webhooks，以便它能够将事件发送到正确的端点。转到存储库的设置页面，然后转到webhooks，页面应该如下所示:</p><figure class="lt lu lv lw gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mq"><img src="../Images/fdccba0e0a30ebc9408d8fc421125ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_Y_L6Wygs7FhTnnJ.png"/></div></div></figure><p id="1d12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们对回购进行更改，提交代码并将其推送到GitHub。几秒钟后，将触发管道构建。以下屏幕截图显示管道正在运行:</p><figure class="lt lu lv lw gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mq"><img src="../Images/28b0d4abe692d7fd1897152e48e95304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TmzeKXwaPPHNhyHv.png"/></div></div></figure><p id="3010" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和完整的。为了完整起见，此处列出了无人机文件:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3d31" class="mc kr it ly b gy md me l mf mg">kind: pipeline<br/>name: default<br/>steps:<br/>- name: test<br/> image: golang:1.10-alpine<br/> commands:<br/>   - "go test"<br/>- name: build<br/> image: golang:1.10-alpine<br/> commands:<br/>   - "go build -o ./myapp"<br/>- name: publish<br/> image: plugins/docker<br/> settings:<br/>   repo: magalixcorp/k8scicd<br/>   tags: [ "${DRONE_COMMIT_SHA:0:7}","latest" ]<br/>   username:<br/>     from_secret: docker_username<br/>   password:<br/>     from_secret: docker_password<br/>- name: deliver<br/> image: sinlead/drone-kubectl<br/> settings:<br/>   kubernetes_server:<br/>     from_secret: k8s_server<br/>   kubernetes_cert:<br/>     from_secret: k8s_cert<br/>   kubernetes_token:<br/>     from_secret: k8s_token<br/> commands:<br/>   - kubectl apply -f deployment.yml</span></pre><p id="e69b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要看的最后一件事是无人机的一个有趣的特性。在Kubernetes上运行时，无人机通过<a class="ae kp" href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" rel="noopener ugc nofollow" target="_blank"> Kubernetes作业</a>运行管道。让我们来看看:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7b66" class="mc kr it ly b gy md me l mf mg">$ kubectl get jobs<br/>NAME                             COMPLETIONS   DURATION   AGE<br/>drone-job-1-eksquogvevfu79trt    1/1           27s        35h<br/>drone-job-10-xhuvskgleefv9zljj   1/1           59s        31h<br/>drone-job-11-qp3mutcw3mkl7gfsn   1/1           57s        31h<br/>drone-job-12-bmyuq8acki1uf7ldz   1/1           71s        31h<br/>drone-job-13-jdkyeuxaemksq8jjw   1/1           73s        31h</span></pre><h1 id="fee0" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="e117" class="mr ms it js b jt lo jx lp kb nh kf ni kj nj kn mw mx my mz bi translated">Drone CI是最新的CI/CD工具之一——它是开源的，用Go编写，于2014年发布。</li><li id="8836" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">无人机将码头集装箱视为一等公民。与Jenkins等其他构建工具不同，Drone在所有构建步骤中都使用了容器。</li><li id="537b" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">无人机也有一些插件，可以直接在管道中<em class="ko">投放</em>。</li><li id="da2c" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">为了接收指令，无人机使用了一个特殊的YAML文件。drone(如果需要，可以在设置中将名称更改为其他名称)。该文件是存储库的一部分，这使得对代码进行“原子”更改变得更加容易。</li><li id="43fc" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">Drone通过集成开箱即用的代码库来工作。支持所有主要的在线Git服务，如GitHub、Bitbucket和GitLab等。</li><li id="813f" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">在这个实验中，我们演示了一个简单的CD管道，其中我们使用了一个用Go编写的简单API。使用Drone，我们能够自动构建、测试、对接和交付我们的应用到目标环境。</li><li id="0500" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">当Drone在Kubernetes上作为Pod运行时，它会利用系统提供的功能。例如，管道是通过<a class="ae kp" href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" rel="noopener ugc nofollow" target="_blank"> Kubernetes jobs </a>运行的。</li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="89d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2020年2月11日https://www.magalix.com</em><em class="ko"/><a class="ae kp" href="https://www.magalix.com/blog/building-a-cd-pipeline-with-drone-ci-and-kubernetes" rel="noopener ugc nofollow" target="_blank"><em class="ko">。</em></a></p></div></div>    
</body>
</html>