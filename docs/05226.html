<html>
<head>
<title>Introduction to Data Recovery with free Unix Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">免费Unix工具数据恢复简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-data-recovery-with-free-unix-tools-8dd2bb9ace34?source=collection_archive---------6-----------------------#2020-08-13">https://levelup.gitconnected.com/introduction-to-data-recovery-with-free-unix-tools-8dd2bb9ace34?source=collection_archive---------6-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1c75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不得不从一个损坏的外部硬盘上恢复数据，我的典型恢复软件失败了(<a class="ae ko" href="https://www.cgsecurity.org/wiki/TestDisk" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> TestDisk </em> </a>)，因为磁盘的硬件严重损坏。</p><p id="4fa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">保证:我不是数据恢复方面的专业人士。这是我从朋友损坏的硬盘上恢复数据的经验。我对任何数据的丢失不承担任何责任。仅当您的数据对您不重要时，才遵循以下步骤。</em></p><h2 id="a52b" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated">症状</h2><p id="5c1e" class="pw-post-body-paragraph jq jr it js b jt lj jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj ln kl km kn im bi translated">OMG！一位朋友在将一个2 TB WD elements外置硬盘连接到正在进行写操作的PC时，它掉了下来。</p><p id="a081" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，Windows nor Ubuntu无法再挂载磁盘，磁盘管理器将第一个主分区显示为<em class="kp"> RAW </em>，Windows提示:</p><blockquote class="lo lp lq"><p id="690f" class="jq jr kp js b jt ju jv jw jx jy jz ka lr kc kd ke ls kg kh ki lt kk kl km kn im bi translated">驱动器没有格式化，您想现在格式化吗</p></blockquote><p id="9f32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可能丢失的数据量约为40 GB的图片/视频和1 GB的文档，如。docx，。ppt，和. pdf。</p><h2 id="7091" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated">必要工具的安装</h2><p id="c70c" class="pw-post-body-paragraph jq jr it js b jt lj jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj ln kl km kn im bi translated">您要么使用一个可引导的实时系统，如<a class="ae ko" href="http://www.knopper.net/knoppix/index-en.html" rel="noopener ugc nofollow" target="_blank"> KNOPPIX </a>，它附带了所有需要的工具，要么在您的机器上手动安装它们:</p><ul class=""><li id="f45d" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated"><a class="ae ko" href="https://www.cgsecurity.org/wiki/TestDisk_Download" rel="noopener ugc nofollow" target="_blank"> TestDisk </a>:如果问题是由非机械问题引起的，比如当您得到一个损坏的分区表时，那么<em class="kp"> TestDisk </em>应该能够恢复损坏的磁盘。这个过程实际上很简单，并且有很好的文档记录。</li><li id="ab85" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><a class="ae ko" href="https://www.gnu.org/software/ddrescue/" rel="noopener ugc nofollow" target="_blank"> ddrescue </a>:将硬盘、光盘等故障块设备复制到文件或其他块设备。</li></ul><h1 id="7edb" class="mi kr it bd ks mj mk ml kv mm mn mo ky mp mq mr lb ms mt mu le mv mw mx lh my bi translated">丑陋的一面——机械硬件故障</h1><p id="c03c" class="pw-post-body-paragraph jq jr it js b jt lj jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj ln kl km kn im bi translated">对我来说，TestDisk的分区结构分析算法失败了，因为有太多损坏的扇区。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi mz"><img src="../Images/1b88b179234acac6e26f28de7d5346e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-cfrQ1jQXTPt8PnJo7_ZQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">TestDisk试图分析和恢复丢失的分区</figcaption></figure><p id="1f84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">开始时，对故障设备的分析看起来没问题，但是每次尝试都失败了。找不到分区。</p><p id="05db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在怎么办？</p><h2 id="fea1" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated">尽可能多地恢复数据！</h2><h1 id="333b" class="mi kr it bd ks mj mk ml kv mm mn mo ky mp mq mr lb ms mt mu le mv mw mx lh my bi translated">使用ddrescue创建原始光盘映像副本</h1><ul class=""><li id="e7d6" class="lu lv it js b jt lj jx lk kb np kf nq kj nr kn lz ma mb mc bi translated"><em class="kp"> ddrescue </em>可用于对硬盘进行低级访问，并对整个设备进行复制。</li><li id="763a" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">与众所周知的dd命令相反，它执行智能复制算法，跳过坏扇区并尝试首先复制所有好扇区。<br/>关于检测到的坏扇区的信息存储在一个日志文件中，该文件可用于在下次运行时进行重新读取</li></ul><h2 id="61d6" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><strong class="ak">小心</strong></h2><ul class=""><li id="5441" class="lu lv it js b jt lj jx lk kb np kf nq kj nr kn lz ma mb mc bi translated">如果您对Unix和终端不熟悉，请不要继续。你可以通过误用<em class="kp"> ddrescue </em>轻易地破坏你的整个系统，例如当你把错误的设备名传给<em class="kp"> ddrescue </em>时。</li><li id="1062" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">一般来说，在一个机械损坏的硬盘上执行太多的IO操作不是一个好主意。一个坏扇区可能首先像一个微小的整体，但你越是试图访问那里的数据，这个整体就会变得越大，更多的数据会永远丢失。</li></ul><p id="486c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://www.gnu.org/software/ddrescue/manual/ddrescue_manual.html" rel="noopener ugc nofollow" target="_blank">来自官方手册:</a></p><blockquote class="lo lp lq"><p id="bc0a" class="jq jr kp js b jt ju jv jw jx jy jz ka lr kc kd ke ls kg kh ki lt kk kl km kn im bi translated">永远不要试图拯救一个读/写挂载分区。由此产生的副本可能是无用的。最好要拯救的设备或分区根本没有挂载，甚至不是只读的。</p><p id="b34e" class="jq jr kp js b jt ju jv jw jx jy jz ka lr kc kd ke ls kg kh ki lt kk kl km kn im bi translated">不要试图修复有I/O错误的驱动器上的文件系统；您可能会丢失更多的数据。</p><p id="ef72" class="jq jr kp js b jt ju jv jw jx jy jz ka lr kc kd ke ls kg kh ki lt kk kl km kn im bi translated">如果您使用设备或分区作为目标，存储在那里的任何数据都将被覆盖。</p></blockquote><p id="744c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多方法可以找回数据，比如使用<a class="ae ko" href="https://linuxconfig.org/how-to-recover-deleted-files-with-foremost-on-linux" rel="noopener ugc nofollow" target="_blank">取证数据恢复工具，最重要的是</a>，但是直接在光盘上应用一堆不同的恢复工具并不是一个好主意，因为这可能会恶化光盘的状态。</p><p id="3a86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个包含尽可能多的数据的原始磁盘映像，并从那里开始。</p><p id="8566" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1。了解您安装的设备</strong></p><p id="8f86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你必须识别你损坏的设备。使用<em class="kp"> lsblk </em>列出所有连接到系统的块设备。</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="2d93" class="kq kr it nt b gy nx ny l nz oa">$ lsblk -o name,label,size,fstype,model<br/>sda             119,2G          SAMSUNG SSD CM87<br/>├─sda1            512M vfat     <br/>└─sda2          118,8G ext4     <br/>sdb               1,8T          Elements 10B8   <br/>└─sdb1 Elements   1,8T ntfs</span></pre><p id="aba3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那个例子中，<em class="kp"> sda </em>是我的操作系统，<em class="kp"> sdb </em>是一个外部硬盘。</p><p id="dfbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议在应用ddrescue之前卸载光盘。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d317eef1b61af99f5ce937bb8efa76a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*ULLxRqspPt_6iFmHP_qH4Q.png"/></div></figure><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="6bb9" class="kq kr it nt b gy nx ny l nz oa">$ sudo unmount /dev/sdb1<br/>$ lsblk | grep sdb1<br/>  sdb1   8:17   0   1,8T  0 part</span></pre><p id="8596" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。作为一个新手，我更喜欢将原始磁盘映像存储到文件中，而不是重写一个实际的附加硬盘。</strong></p><p id="ea4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先尝试最基本的选项:</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="eaec" class="kq kr it nt b gy nx ny l nz oa">$ ddrescue -d -n /dev/sdc1 /path/to/backup/drive3.raw ddrescue.log</span><span id="2877" class="kq kr it nt b gy oc ny l nz oa">with options:<br/>-d direct disc access, bypasses the kernel's IO cache<br/>-n get most good areas by skipping the scraping phase; Avoid trying to rescue difficult parts;</span></pre><p id="9503" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是操作卡住了，我不得不用“Control + C”停止。我得到了一个大约20 GB的磁盘映像(drive 3 . raw)——对于开始来说还不错。幸运的是，ddrescue可以随时停止，并在以后使用不同的设置继续运行。</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="ae53" class="kq kr it nt b gy nx ny l nz oa">$ ddrescue -e +2 -d -r1 -T 1s /dev/sdc1 /path/to/backup/drive3.raw ddrescue.log</span><span id="6339" class="kq kr it nt b gy oc ny l nz oa">with options:<strong class="nt iu"><br/></strong>-e maximum number of bad areas allowed before giving up<br/>-T interval, maximum time since last successful read allowed before giving<br/>-r3 retry bad sectors (3 times) detected on a previous run</span></pre><p id="3346" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于复制过程需要几个小时，而且仍然会任意冻结，所以我编写了一个小脚本来多次重新运行ddrescue，以扩展创建的备份。</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="a6ed" class="kq kr it nt b gy nx ny l nz oa">$ ddresc-copy.sh /dev/sdc1 /path/to/backup/drive3.raw ddrescue.log</span><span id="bc7f" class="kq kr it nt b gy oc ny l nz oa">// ddresc-copy.sh<br/>#!/bin/sh</span><span id="e823" class="kq kr it nt b gy oc ny l nz oa">counter=0</span><span id="f1d4" class="kq kr it nt b gy oc ny l nz oa">while [ $counter -lt 5 ]<br/>do <br/> OUTPUT=$(ddrescue -e +0 -d -r1 -T 1s $1 $2 $3)<br/> counter=$(( $counter + 1 ))</span><span id="b405" class="kq kr it nt b gy oc ny l nz oa">echo "done: $OUTPUT"</span><span id="2d94" class="kq kr it nt b gy oc ny l nz oa">if [[ $OUTPUT == *"Finished"* ]]; then<br/>  exit 0<br/> fi</span><span id="7881" class="kq kr it nt b gy oc ny l nz oa">echo "new run $counter"<br/> sleep 3<br/>done</span></pre><p id="b734" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后我有了一个1 TB大小的副本！不是整个光盘，但足以找到一些文件肯定。</p><p id="bbcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3。调查原始磁盘副本</strong></p><p id="1748" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经怀疑过了，但是<em class="kp"> parted </em>找不到任何东西<em class="kp"> TestDisk </em>也无法恢复分区表。</p><p id="3b9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有适当的文件系统结构，就无法重建文件夹结构或读取文件名。但是，仍然可以找到文件扩展名正确的原始数据！</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="99db" class="kq kr it nt b gy nx ny l nz oa">$ parted drive3.raw<br/>Disk /media/christian/Elements/Backups/drive3.raw: 1000GB<br/>Sector size (logical/physical): 512B/512B<br/>Partition Table: msdos<br/>Disk Flags:</span><span id="2840" class="kq kr it nt b gy oc ny l nz oa">Number  Start  End  Size  Type  File system  Flags</span></pre><p id="718a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看日志文件会发现一些坏扇区。</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="0f3c" class="kq kr it nt b gy nx ny l nz oa"># Mapfile. Created by GNU ddrescue version 1.22<br/># Command line: ddrescue -i8200MiB -s5GiB -e +0 -d -r1 -T 3s -n /dev/sdc1 /media/christian/Elements/Backups/backup.raw ddrescue.log<br/># Start time:   2020-05-14 08:52:58<br/># Current time: 2020-05-14 08:52:58<br/># current_pos  current_status  current_pass<br/>0x00000000     ?               1<br/>#      pos        size  status<br/>0x00000000  0x200800000  ?<br/>0x200800000  0x140000000  ?<br/>0x340800000  0xE5A0238200  ?</span></pre><h1 id="f909" class="mi kr it bd ks mj mk ml kv mm mn mo ky mp mq mr lb ms mt mu le mv mw mx lh my bi translated">从原始分区副本恢复数据</h1><h2 id="96b4" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><strong class="ak"> Photorec </strong></h2><p id="4a54" class="pw-post-body-paragraph jq jr it js b jt lj jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj ln kl km kn im bi translated"><em class="kp"> Photorec </em>与<em class="kp"> TestDisk </em>出自同一家开发商，可用于从原始图像中提取数据。如果原始文件系统格式是已知的，那就更好了。我用的是最新的测试版7.2。</p><p id="3749" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不出所料，分区未被识别。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi od"><img src="../Images/255114c58237bda0f77fcb6952eb7761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*wM2TPSzhx65NHDOq4Jw6JQ.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">选择要恢复的文件扩展名</figcaption></figure><p id="d8e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览列表并选择文件类型。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e76e61c68d3a328664c53509d90ae2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*3GOxUPfXnReVt7412Zvy2Q.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><a class="ae ko" href="https://www.cgsecurity.org/wiki/File_Formats_Recovered_By_PhotoRec" rel="noopener ugc nofollow" target="_blank">以下是支持文件的列表</a></figcaption></figure><p id="d290" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管确切的硬盘格式无法辨认，但我知道它是FAT32。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi of"><img src="../Images/aaa3a32be93f92004ad9449e61a3345c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*pnVAHno8krkPal9Mzse6oA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">选择文件系统格式</figcaption></figure><p id="5989" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Photorec将输出每种类型的恢复文件的数量。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d317eef1b61af99f5ce937bb8efa76a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*ULLxRqspPt_6iFmHP_qH4Q.png"/></div></figure><p id="56f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">恢复的数据</strong></p><p id="7445" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是啊！Photorec检索到47 GB的实际未损坏的文件！</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="c154" class="kq kr it nt b gy nx ny l nz oa">$ du -sh recovered_data<br/>47G</span></pre><p id="e387" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这些文件是随机命名的，没有结构，并被附加到名为recup_dir.X的文件夹中。</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="67b2" class="kq kr it nt b gy nx ny l nz oa">$ ll recovered_data<br/>drwxrwxrwx 1 christian christian 232K Mai 14 16:22 recup_dir.1<br/>drwxrwxrwx 1 christian christian 232K Mai 14 17:23 recup_dir.10<br/>drwxrwxrwx 1 christian christian 228K Mai 14 17:28 recup_dir.11<br/>drwxrwxrwx 1 christian christian 216K Mai 14 17:32 recup_dir.12<br/>drwxrwxrwx 1 christian christian 160K Mai 14 17:33 recup_dir.13<br/>drwxrwxrwx 1 christian christian 160K Mai 14 17:34 recup_dir.14<br/>drwxrwxrwx 1 christian christian 164K Mai 14 17:34 recup_dir.15<br/>drwxrwxrwx 1 christian christian 112K Mai 14 17:35 recup_dir.16</span></pre><p id="5a10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使数据可用，一些分析和分类是必要的。</p><p id="abc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">盒子里有什么？</p><p id="1ca9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于如此大量的非结构化文件，我想知道仅使用<em class="kp">查找管道</em>找到了什么类型的数据。</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="612d" class="kq kr it nt b gy nx ny l nz oa">$ find recovered_data -type f | rev | cut -d. -f1 | rev  | tr '[:upper:]' '[:lower:]' | sort | uniq --count | sort -rn<br/>  25276 jpg<br/>   1204 docx<br/>    612 png<br/>    126 mp4<br/>    124 doc<br/>     73 pptx<br/>     38 pdf<br/>     20 mov<br/>     19 ppt<br/>     16 3gp<br/>     11 xlsx<br/>      6 zip<br/>      6 avi<br/>      3 wmv<br/>      3 plist<br/>      2 odt<br/>      2 msg<br/>      1 xml<br/>      1 txt<br/>      1 notebook<br/>      1 lnk</span></pre><p id="79ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来棒极了！</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="b919" class="kq kr it nt b gy nx ny l nz oa"><em class="kp">|-type f </em>:<em class="kp"> </em>find all files within that directory<br/>recovered_data/f0477104.JPG</span><span id="1fd0" class="kq kr it nt b gy oc ny l nz oa"><em class="kp">| rev</em> : reverse file-path to capture file extension in front (“JPG.4017740f/1.rid_pucer/atad_derevocer”)</span><span id="0174" class="kq kr it nt b gy oc ny l nz oa"><em class="kp">| cut -d. </em>:<em class="kp"> </em>split string on the dot and keep first column (the extension)<br/>“GPJ”</span><span id="1f5a" class="kq kr it nt b gy oc ny l nz oa">| rev : reverse again<br/>“JPG”</span><span id="68f9" class="kq kr it nt b gy oc ny l nz oa">| tr ‘[:upper:]’ ‘[:lower:]’: convert all upper cased characters to lower case<br/>“jpg”</span><span id="3aa7" class="kq kr it nt b gy oc ny l nz oa">| uniq --count : get all unique strings with their respective amount of files</span><span id="5125" class="kq kr it nt b gy oc ny l nz oa">| sort -rn : sort file types in descending numeric order</span></pre><h2 id="f141" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated">排序恢复的数据</h2><p id="ee4d" class="pw-post-body-paragraph jq jr it js b jt lj jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj ln kl km kn im bi translated">下一步是根据文件类型和内容等标准对非结构化数据进行排序和组织。</p><p id="05f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用并改进了一个<a class="ae ko" href="https://github.com/ChrizH/sort-PhotorecRecoveredFiles" rel="noopener ugc nofollow" target="_blank"> Python脚本</a>，它在根据文件扩展名对文件进行分组方面做得很好。</p><p id="197b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，它还根据拍摄的年月来区分jpg。此外，它还可以检测在周末旅行等多天拍摄的照片。</p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="ac9a" class="kq kr it nt b gy nx ny l nz oa">$ python recovery.py &lt;path to files recovered_data by Photorec&gt; &lt;destination&gt; -m</span></pre><p id="8f4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">新文件夹结构</strong></p><pre class="na nb nc nd gt ns nt nu nv aw nw bi"><span id="32d0" class="kq kr it nt b gy nx ny l nz oa">&lt;destination&gt;<br/>|- DOC<br/>|- PDF<br/>|- PNG<br/>|- JPG<br/>  |- 2020   # Year<br/>    |- 1    # Month January<br/>        |- 2020-01-10__to__01_13 # event, trip 1<br/>        |- 2020-01-23__to__01_24 # event, trip 2</span></pre><h1 id="3d76" class="mi kr it bd ks mj mk ml kv mm mn mo ky mp mq mr lb ms mt mu le mv mw mx lh my bi translated">结论</h1><p id="c6ab" class="pw-post-body-paragraph jq jr it js b jt lj jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj ln kl km kn im bi translated">我只能用免费的Unix工具从损坏的外部硬盘上恢复丢失的数据。</p><p id="932f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp"> ddrescue </em>用于创建原始分区副本。首先，所有未损坏的扇区都已复制到文件中。在额外的迭代中<em class="kp">从坏扇区中刮出数据，直到我对1 TB大小的结果感到满意。</em></p><p id="c7c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp"> Photorec </em>在恢复众所周知的数据类型方面做得很好。<br/>但是，结构和文件名都没有了。</p><p id="2a39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非结构化文件按扩展名分组，JPG图像按创建时间排序和分组。</p><p id="f327" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的下一个故事中，我将讨论为恢复的文本文档找到合适的文件名的问题。doc，。ppt或. pdf。</p><h1 id="87b4" class="mi kr it bd ks mj mk ml kv mm mn mo ky mp mq mr lb ms mt mu le mv mw mx lh my bi translated">资源</h1><p id="d52b" class="pw-post-body-paragraph jq jr it js b jt lj jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj ln kl km kn im bi translated">来自Level1Linux的优秀视频</p><figure class="na nb nc nd gt ne"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0832" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CGSecurity</p><div class="oi oj gp gr ok ol"><a href="https://www.cgsecurity.org/wiki/TestDisk_Step_By_Step" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">逐步测试磁盘- CGSecurity</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">这个恢复示例引导您一步一步地通过TestDisk来恢复丢失的分区和修复损坏的…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.cgsecurity.org</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz nj ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://www.cgsecurity.org/wiki/After_Using_PhotoRec#Using_a_more_complex_Python_script" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">使用photo RC-CG security后</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">usr/bin/env python import OS import OS . path import shutil import sys source = sys . argv[1]destination = sys . argv[2]…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.cgsecurity.org</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz nj ol"/></div></div></a></div></div></div>    
</body>
</html>