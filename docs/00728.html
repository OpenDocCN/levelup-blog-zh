<html>
<head>
<title>Golang &amp; SOAP Based Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Golang和SOAP的服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-soap-based-services-ccc4b3e3ee2e?source=collection_archive---------0-----------------------#2019-07-11">https://levelup.gitconnected.com/golang-soap-based-services-ccc4b3e3ee2e?source=collection_archive---------0-----------------------#2019-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="78e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Golang的各种优势，它在企业应用程序中得到了广泛的应用，但是在尝试将一种新语言应用到您的项目中时，仍然会遇到一些前所未有的情况。我们在项目中遇到的挑战之一是将基于SOAP的服务与RESTful API集成。尽管在Golang上实现和集成基于SOAP的服务有多种方法，但我们通过使用Go上可用的少数供应商dep选择了其中一种方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c249201c886e8c1f40021dc8b91d8cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSc-c8m86JC4daxEHnP7fw.png"/></div></div></figure><p id="b613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">需要考虑的部门:</em></p><ul class=""><li id="b189" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated"><code class="fe lh li lj lk b">encoding/xml</code>:理解XML名称空间的简单XML 1.0解析器</li><li id="7c3a" class="ky kz iq jp b jq ll ju lm jy ln kc lo kg lp kk ld le lf lg bi translated"><code class="fe lh li lj lk b">text/template</code> : template实现数据驱动的模板，用于生成文本输出。</li></ul><p id="25ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码片段显示了我们如何集成基于SOAP的服务的概述，接下来的部分将显示详细描述实现集成的步骤的逐步方法。</p><pre class="km kn ko kp gt lq lk lr ls aw lt bi"><span id="f6e6" class="lu lv iq lk b gy lw lx l ly lz"><strong class="lk ir">func </strong>callSOAPClientSteps(){<br/><br/>   req := populateRequest()<br/><br/>   httpReq, err := generateSOAPRequest(req)<br/>   <strong class="lk ir">if </strong>err != nil {<br/>      fmt.Println("Some problem occurred in request generation")<br/>   }<br/><br/>   response, err := soapCall(httpReq)<br/>   <strong class="lk ir">if </strong>err != nil {<br/>      fmt.Println("Problem occurred in making a SOAP call")<br/>   }<br/>}</span></pre><h1 id="302a" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak"> SOAP请求模板</strong></h1><p id="1399" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">为我们正在与可以动态分配的<em class="kx">变量</em>交互的服务创建一个SOAP模板。假设您正在使用一项服务，该服务需要如下所示的有效负载。用一个变量初始化它，如<code class="fe lh li lj lk b">getTemplate</code></p><pre class="km kn ko kp gt lq lk lr ls aw lt bi"><span id="f7c7" class="lu lv iq lk b gy lw lx l ly lz"><strong class="lk ir"><br/>var </strong>getTemplate =<br/>&lt;soapenv:Envelope<br/> xmlns:soapenv="<a class="ae nc" href="http://schemas.xmlsoap.org/soap/envelope/" rel="noopener ugc nofollow" target="_blank">http://schemas.xmlsoap.org/soap/envelope/</a>"<br/> xmlns:api="<a class="ae nc" href="http://soapdummies.com/api" rel="noopener ugc nofollow" target="_blank">http://soapdummies.com/api</a>"&gt;<br/> &lt;soapenv:Header/&gt;<br/> &lt;soapenv:Body&gt;<br/>  &lt;api:Command<br/>   ae nc" href="http://soapdummies.com/api" rel="noopener ugc nofollow" target="_blank"&gt;http://soapdummies.com/api"&gt;<br/>   &lt;api:Credentials&gt;<br/>    &lt;api:Username&gt;{{.Username}}&lt;/api:Username&gt;<br/>    &lt;api:Password&gt;{{.Password}}&lt;/api:Password&gt;<br/>   &lt;/api:Credentials&gt;<br/>   &lt;api:Body&gt;<br/>    &lt;SOAPDummy schemaVersion="3.0"<br/>     ae nc" href="http://soapdummies.com/products/request" rel="noopener ugc nofollow" target="_blank"&gt;http://soapdummies.com/products/request"&gt;<br/>     &lt;Identity&gt;      <br/>      &lt;Title/&gt;<br/>      &lt;FirstName&gt;{{.FirstName}}&lt;/FirstName&gt;<br/>      &lt;MiddleName&gt;{{.MiddleName}}&lt;/MiddleName&gt;<br/>      &lt;LastName&gt;{{.LastName}}&lt;/LastName&gt;<br/>      &lt;Suffix/&gt;<br/>      &lt;DOB&gt;{{.Dob}}&lt;/DOB&gt;<br/>      &lt;Address&gt;<br/>       &lt;Line1&gt;{{.AddressLine1}}&lt;/Line1&gt;<br/>       &lt;Line2&gt;{{.AddressLine2}}&lt;/Line2&gt;<br/>      &lt;/Address&gt;<br/>      &lt;City&gt;{{.City}}&lt;/City&gt;<br/>      &lt;State&gt;{{.State}}&lt;/State&gt;<br/>      &lt;Zip&gt;{{.ZipCode}}&lt;/Zip&gt;<br/>      &lt;MobilePhone&gt;{{.MobilePhone}}&lt;/MobilePhone&gt;<br/>     &lt;/Identity&gt;<br/>    &lt;/SOAPDummy&gt;<br/>   &lt;/api:Body&gt;<br/>  &lt;/api:Command&gt;<br/> &lt;/soapenv:Body&gt;<br/>&lt;/soapenv:Envelope&gt;</span></pre><p id="342c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">变量是以<code class="fe lh li lj lk b">{{.<em class="kx">variables</em>}}</code> ( <em class="kx"> Ex </em> <code class="fe lh li lj lk b"><em class="kx">{{.Username}}</em></code> <em class="kx">，</em> <code class="fe lh li lj lk b"><em class="kx">{{.FirstName}}</em></code> <em class="kx">，</em> <code class="fe lh li lj lk b"><em class="kx">{{.AddressLine1}}</em></code> <em class="kx">等</em>的形式表示的</em>，在向SOAP端点发出请求时被动态赋值为实际值。</p><h1 id="848a" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">SOAP请求的结构</h1><p id="9d46" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">创建一个结构，将变量<em class="kx">从<code class="fe lh li lj lk b">getTemplate</code>替换为实际值，方法是将值赋给结构。</em></p><pre class="km kn ko kp gt lq lk lr ls aw lt bi"><span id="d27f" class="lu lv iq lk b gy lw lx l ly lz"><strong class="lk ir">type </strong>Request <strong class="lk ir">struct </strong>{<br/>   //Values are set in below fields as per the request<br/>   FirstName    string<br/>   LastName     string<br/>   MiddleName   string<br/>   AddressLine1 string<br/>   AddressLine2 string<br/>   City         string<br/>   State        string<br/>   ZipCode      string<br/>   MobilePhone  string<br/>   SSN          string<br/>   Dob          string<br/>   Username string<br/>   Password string   <br/>}</span></pre><h1 id="49cf" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">填充SOAP请求</h1><p id="aad6" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">一旦创建了一个<code class="fe lh li lj lk b">Request</code>结构，就使用<code class="fe lh li lj lk b">populateRequest()</code>填充这些值。</p><pre class="km kn ko kp gt lq lk lr ls aw lt bi"><span id="f051" class="lu lv iq lk b gy lw lx l ly lz"><strong class="lk ir">func </strong>populateRequest() *Request {<br/>   req := Request{}<br/>   req.FirstName = "Tony"<br/>   req.MiddleName = ""<br/>   req.LastName = "Blaire"<br/>   req.Dob = "1946-08-08"<br/>   req.AddressLine1 = "866 Atlas Dr"<br/>   req.AddressLine2 = "Apt 999"<br/>   req.City = "London"<br/>   req.State = "England"<br/>   req.ZipCode = "SW15 5PU"<br/>   req.MobilePhone = "9876543210"<br/>   req.Username = "tony1"<br/>   req.Password = "password1"<br/>   <strong class="lk ir">return </strong>&amp;req<br/>}</span></pre><h1 id="9723" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">SOAP响应示例</h1><pre class="km kn ko kp gt lq lk lr ls aw lt bi"><span id="419f" class="lu lv iq lk b gy lw lx l ly lz">&lt;soap:Envelope xmlns:soap=”<a class="ae nc" href="http://schemas.xmlsoap.org/soap/envelope/" rel="noopener ugc nofollow" target="_blank">http://schemas.xmlsoap.org/soap/envelope/</a>" xmlns:xsd=”<a class="ae nc" href="http://www.w3.org/2001/XMLSchema" rel="noopener ugc nofollow" target="_blank">http://www.w3.org/2001/XMLSchema</a>" xmlns:xsi=”<a class="ae nc" href="http://www.w3.org/2001/XMLSchema-instance" rel="noopener ugc nofollow" target="_blank">http://www.w3.org/2001/XMLSchema-instance</a>"&gt;<br/> &lt;soap:Body&gt;<br/> &lt;api:Response xmlns:api=”<a class="ae nc" href="http://soapdummies.com/products/request" rel="noopener ugc nofollow" target="_blank">http://soapdummies.com/products</a>/response"&gt;<br/> &lt;api:Solution&gt;Standard/MultiProduct&lt;/api:Solution&gt;<br/> &lt;api:RequestID&gt;baff2531-1959-42b0-947a-807b77a87814&lt;/api:RequestID&gt;<br/> &lt;api:Body&gt; <br/> &lt;Status&gt;100&lt;/Status&gt;<br/> &lt;Salary&gt;1&lt;/Salary&gt;<br/> &lt;Designation&gt;A1&lt;/Designation&gt;<br/> &lt;Manager&gt;122960618779897&lt;/Manager&gt;<br/> &lt;Company&gt;2019–07–09T07:31:03&lt;/Company&gt;<br/> &lt;EmployedSince&gt;500&lt;/EmployedSince&gt;<br/> &lt;/api:Body&gt;<br/> &lt;/api:Response&gt;<br/> &lt;/soap:Body&gt;<br/>&lt;/soap:Envelope&gt;</span></pre><p id="5936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于上面的SOAP响应示例，我们可以创建一个结构来在RESTful API中使用它。</p><h1 id="c479" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">SOAP响应的结构</h1><p id="8769" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">创建一个结构来解组从SOAP API收到的响应。这是在SOAP响应的反序列化过程中可能会遇到问题的部分，因此我们应该相应地仔细构造响应结构以避免问题。</p><pre class="km kn ko kp gt lq lk lr ls aw lt bi"><span id="92e8" class="lu lv iq lk b gy lw lx l ly lz"><strong class="lk ir">type </strong>Response <strong class="lk ir">struct </strong>{<br/>   XMLName  xml.Name `xml:"http://schemas.xmlsoap.org/soap/envelope/ Envelope"`<br/>   SoapBody *SOAPBodyResponse<br/>}<br/><br/><strong class="lk ir">type </strong>SOAPBodyResponse <strong class="lk ir">struct </strong>{<br/>   XMLName      xml.Name `xml:"Body"`<br/>   Resp         *ResponseBody<br/>   FaultDetails *Fault<br/>}<br/><br/><strong class="lk ir">type </strong>Fault <strong class="lk ir">struct </strong>{<br/>   XMLName     xml.Name `xml:"Fault"`<br/>   Faultcode   string   `xml:"faultcode"`<br/>   Faultstring string   `xml:"faultstring"`<br/>}<br/><br/><strong class="lk ir">type </strong>ResponseBody <strong class="lk ir">struct </strong>{<br/>   XMLName       xml.Name `xml:"Response"`<br/>   RequestID     string   `xml:"RequestID"`<br/>   Response      *Body<br/>   Status        string   `xml:"Status"`<br/>}<br/><br/><strong class="lk ir">type </strong>Body <strong class="lk ir">struct </strong>{<br/>   XMLName            xml.Name `xml:"Body"`<br/>   Status             string   `xml:"Status"`<br/>   Salary             string   `xml:"Salary"`<br/>   Designation        string   `xml:"Designation"`<br/>   Manager            string   `xml:"Manager"`<br/>   Company            string   `xml:"Company"`<br/>   EmployedSince      string   `xml:"EmployedSince"`<br/>}</span></pre><p id="bda1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，添加了<em class="kx"> Fault </em>结构来处理SOAP API返回的任何错误，以便让客户端捕获它。</p><h1 id="5ccc" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">SOAP请求</h1><p id="d429" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">对SOAP服务的调用与REST API调用没有什么不同，使用<code class="fe lh li lj lk b">http</code>包对预期的SOAP服务进行调用。下面的示例代码应该显示它是如何完成的。</p><pre class="km kn ko kp gt lq lk lr ls aw lt bi"><span id="66cf" class="lu lv iq lk b gy lw lx l ly lz"><strong class="lk ir">func </strong>generateSOAPRequest(req *Request) (*http.Request, error) {<br/>   // Using the var getTemplate to construct request<br/>   template, err := template.New("InputRequest").Parse(getTemplate)<br/>   <strong class="lk ir">if </strong>err != nil {<br/>      fmt.Println("Error while marshling object. %s ",err.Error())<br/>      <strong class="lk ir">return </strong>nil,err<br/>   }<br/><br/>   doc := &amp;bytes.Buffer{}<br/>   // Replacing the doc from template with actual req values<br/>   err = template.Execute(doc, req)<br/>   <strong class="lk ir">if </strong>err != nil {<br/>      fmt.Println("template.Execute error. %s ",err.Error())<br/>      <strong class="lk ir">return </strong>nil,err<br/>   }<br/><br/>   buffer := &amp;bytes.Buffer{}<br/>   encoder := xml.NewEncoder(buffer)<br/>   err = encoder.Encode(doc.String())<br/>   <strong class="lk ir">if </strong>err != nil {<br/>      fmt.Println("encoder.Encode error. %s ",err.Error())<br/>      <strong class="lk ir">return </strong>nil,err<br/>   }<br/><br/>   r, err := http.NewRequest(http.<em class="kx">MethodPost</em>, "https://www.soapurl.com/retreiveIdentity", bytes.NewBuffer([]byte(doc.String())))<br/>   <strong class="lk ir">if </strong>err != nil {<br/>      fmt.Println("Error making a request. %s ", err.Error())<br/>      <strong class="lk ir">return </strong>nil,err<br/>   }<br/><br/>   <strong class="lk ir">return </strong>r, nil<br/>}</span></pre><h1 id="1d05" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">SOAP调用</h1><p id="5e36" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">创建请求后，进行如下所示的SOAP调用</p><pre class="km kn ko kp gt lq lk lr ls aw lt bi"><span id="ca8e" class="lu lv iq lk b gy lw lx l ly lz"><strong class="lk ir">func </strong>soapCall(req *http.Request) (*Response, error) {<br/>   client := &amp;http.Client{}<br/>   resp, err := client.Do(req)<br/><br/>   <strong class="lk ir">if </strong>err != nil{<br/>      <strong class="lk ir">return </strong>nil,err<br/>   }<br/><br/>   body, err := ioutil.ReadAll(resp.Body)<br/>   <strong class="lk ir">if </strong>err != nil {<br/>      <strong class="lk ir">return </strong>nil,err<br/>   }<br/>   <strong class="lk ir">defer </strong>resp.Body.Close()<br/><br/>   r := &amp;Response{}<br/>   err = xml.Unmarshal(body, &amp;r)<br/><br/>   <strong class="lk ir">if </strong>err != nil {<br/>      <strong class="lk ir">return </strong>nil,err<br/>   }<br/><br/>   <strong class="lk ir">if </strong>r.SoapBody.Resp.Status != "200" {<br/>      <strong class="lk ir">return </strong>nil,err<br/>   }<br/><br/>   <strong class="lk ir">return </strong>r, nil<br/>}</span></pre><p id="857a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在解组响应时，使用本机编码/xml dep来反序列化从SOAP服务接收的响应。xml。解组方法有助于用从服务接收的相关值填充结构。</p><p id="3153" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然有多种方法可以将基于golang的API与遗留服务集成在一起，但这个例子可以说是集成基于SOAP的服务的有效方法之一，只需最少地使用供应商的dep来完成SOAP集成。</p></div></div>    
</body>
</html>