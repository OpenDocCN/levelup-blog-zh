<html>
<head>
<title>The identity of a Microservice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务的身份</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-identity-of-a-microservice-fb845816126a?source=collection_archive---------4-----------------------#2020-02-22">https://levelup.gitconnected.com/the-identity-of-a-microservice-fb845816126a?source=collection_archive---------4-----------------------#2020-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f1a557fb214741ff1bb65dba84e73edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ieu4lGgg2it-UeRRGKKTmQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">山坡上的小盒子…</figcaption></figure><p id="3691" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我现在的公司正在向微服务转型。这对公司来说是一个新的挑战，因为在这之前，我们所有的流程和工具都围绕着一个整体，由我们过去做出的所有决定(好的和坏的)形成。</p><p id="c1b1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们决定开始的方式是将一个组件迁移到一个微服务中，并为其他服务铺设一条“黄金路径”。这有助于我们简化流程，并引发一些关于该主题的真正有趣的讨论。</p><p id="a1ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">今天是最后一场大辩论。一个房间里有15个人，所有人都有不同的背景，他们在争论我们是将一个服务部署到2个机器集群(一个服务于HTTP API，另一个监听不同的事件流并将信息具体化到数据库)，还是将一个服务部署到具有这两种职责的单个机器集群。</p><p id="23ee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">辩论的结果是务实的，也是符合我们当前需求的，但我惊讶地发现，我们无法就一个最基本的方面达成一致:<strong class="kh iu">微服务何时不再是微服务？</strong></p><p id="ffce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我正要回家，我无法摆脱这个想法，所以我决定写这篇(非常固执己见的)文章。希望能引起一些人的共鸣，一些评论会挑战我现在的假设。</p><h1 id="2038" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">设定一些界限</h1><p id="b0b7" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">在做微服务时，我们学到的第一个概念是有界上下文的概念，或者我们业务的两个不同部分之间的边界。设定正确的界限真的很难，因为企业的所有部分都以某种方式相互关联。但是假设我们已经找到了一个合理的有界环境的近似，并且我们有一个处理支付的服务P。</p><p id="a747" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">服务P(可以想象)在公司相当受欢迎。而且它还有很多其他组件想要与之对话，所以它需要定义一种方式让它们说话。那就是接口，或者说服务的API。</p><h1 id="eb95" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">关于接口和共享数据库的前言</h1><p id="30a2" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">现在，我们这些从事Web服务工作的人倾向于将术语接口与传统的Java接口联系起来，将术语API与REST HTTP API联系起来，但是为了本文的缘故，我想强调接口可以是任何东西！</p><ol class=""><li id="b496" class="mg mh it kh b ki kj km kn kq mi ku mj ky mk lc ml mm mn mo bi translated">它可以是一系列HTTP端点。</li><li id="5dfe" class="mg mh it kh b ki mp km mq kq mr ku ms ky mt lc ml mm mn mo bi translated">发送用JSON编码的作业参数的队列。</li><li id="5621" class="mg mh it kh b ki mp km mq kq mr ku ms ky mt lc ml mm mn mo bi translated">S3桶中的一系列CSV文件。</li><li id="9a2f" class="mg mh it kh b ki mp km mq kq mr ku ms ky mt lc ml mm mn mo bi translated">SQL数据库。</li><li id="27be" class="mg mh it kh b ki mp km mq kq mr ku ms ky mt lc ml mm mn mo bi translated">你的同事迈克，<em class="mu">的拥有者，当一个客户打电话给你说<em class="mu">那个</em>问题时你需要运行的脚本</em>。</li></ol><p id="c072" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你从事后端/前端工作，你可能习惯于选项1-2，而选项3-4听起来有些混乱。如果你处理数据，你可能经常会做3-4次。如果你已经在这个行业呆了一段时间，你可能已经经历了选项5的痛苦。</p><p id="98a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但关键是，它们都是接口，在适当的上下文中它们都是有意义的。<strong class="kh iu">重要的部分是找到一个客户端可以使用的契约，服务器可以保证</strong>。</p><p id="dab5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以我认为，当我们听到关于微服务的强烈言论时，我们应该把它放在上下文中。</p><blockquote class="mv mw mx"><p id="b494" class="kf kg mu kh b ki kj kk kl km kn ko kp my kr ks kt mz kv kw kx na kz la lb lc im bi translated">误解:“2个微服务不能共享同一个数据库”</p><p id="48e5" class="kf kg mu kh b ki kj kk kl km kn ko kp my kr ks kt mz kv kw kx na kz la lb lc im bi translated">现实:“2个微服务不得共享同一个数据库<strong class="kh iu">来存储内部状态</strong>”</p></blockquote><h1 id="5cd3" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">微服务的逻辑和物理接口</h1><p id="0415" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">我通常从两个角度来看待服务的接口。</p><p id="21d6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一方面，我们有“逻辑”界面。这包括输入和输出的构造方式，或者我们命名和组织不同端点、命令或表格的方式。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a11841e162b36789b899f2d1b6c42738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*vEjxKI8SKXRknxboV0npVg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">服务的接口可以由不同的部分组成。在本例中，服务公开了一个HTTP API，并发出具有特定模式的事件。</figcaption></figure><p id="e52b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一方面，我们有“物理”界面。这与接口的公开方式有关。我们如何处理HTTP API或数据库？是公开暴露还是通过专网/vpn暴露？</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/7776605885bd0313a7266084359af305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*MBLAqJ1qVyiVoecpSXmzFA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">上例中的物理接口可能会在公共域上公开HTTP API，向特定的Kafka主题发出事件，并将事件存储在S3桶中，以便于以后访问。</figcaption></figure><p id="9509" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我今天开始意识到，逻辑和物理之间，以及接口和实现细节之间的交集是一个灰色区域，会导致很多混乱。所以我要问你一些哲学问题，作为思考练习，你可以记下你的第一直觉是什么。</p><h1 id="8651" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">微服务是不是因为我们重构了内部代码就不再是微服务了？</h1><p id="8ff1" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">如果我们对代码进行内部重构，保留当前接口，我们会称之为不同的微服务吗？</p><p id="62f2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们将服务的某些部分模块化，它会变成别的东西吗？</p><h1 id="61af" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">微服务是否会因为我们改变了部署方式而不再是微服务？</h1><p id="22b1" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">如果我们将一个服务部署到多个地区，或者<a class="ae ng" href="https://en.wikipedia.org/wiki/Multicloud" rel="noopener ugc nofollow" target="_blank">多个云</a>，它们会变成不同的服务吗？</p><p id="27ad" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们将一个服务部署到两个独立的集群(一个处理iOS客户端，另一个处理Android客户端，用于隔离目的)，这会使它们不同吗？如果这需要为负载均衡器实现定制逻辑会怎样？</p><p id="c549" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们以两种不同的风格部署相同的代码库(一种处理HTTP请求，另一种处理消费事件)，这是否意味着我们没有做微服务？</p><p id="997b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们的部署由6个无服务器功能、2个HTTP服务器和1个数据库组成，它们都独立部署和更新，但共享相同的代码库，您会将它们视为两个独立的微服务吗？</p><h1 id="3130" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">得到答案了吗？</h1><p id="c3b5" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">如果你的直觉是对第一部分的问题回答“否”，对第二部分的一些问题回答“是”，我必须告诉你我不同意你的观点。但是让我请求你帮两个忙:</p><ol class=""><li id="2912" class="mg mh it kh b ki kj km kn kq mi ku mj ky mk lc ml mm mn mo bi translated">听我说完。</li><li id="482d" class="mg mh it kh b ki mp km mq kq mr ku ms ky mt lc ml mm mn mo bi translated">在评论区分享你的想法和反驳。我真的很想知道！</li></ol><h1 id="bdb5" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">我(目前)的观点</h1><p id="1422" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">对我来说，微服务只能通过它所公开的接口来识别。</p><p id="660c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不同的代码文件、模块和变量在内部的布局不会改变它的身份，我觉得这很容易达成一致。</p><p id="525b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是我认为同样的推理应该适用于物理实现细节。在任何时候，我们都可能:</p><ul class=""><li id="2b31" class="mg mh it kh b ki kj km kn kq mi ku mj ky mk lc nh mm mn mo bi translated">将服务部署到多个区域或云中。</li><li id="1398" class="mg mh it kh b ki mp km mq kq mr ku ms ky mt lc nh mm mn mo bi translated">将每个区域的部署划分到3个集群中，以<a class="ae ng" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead" rel="noopener ugc nofollow" target="_blank">隔离</a>不同的工作负载。</li><li id="9e5c" class="mg mh it kh b ki mp km mq kq mr ku ms ky mt lc nh mm mn mo bi translated">将版本2作为金丝雀版本部署到我们10%的用户中。</li><li id="86f9" class="mg mh it kh b ki mp km mq kq mr ku ms ky mt lc nh mm mn mo bi translated">将2个事件侦听器重写为无服务器函数。</li></ul><p id="2a1f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些决定将使解决方案更加可靠。它们还会使维护变得更加复杂。但它们不会以任何方式改变我们微服务的身份，也不会代表微服务架构的反模式。</p><p id="20ef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">…对吗？</p></div></div>    
</body>
</html>