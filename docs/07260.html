<html>
<head>
<title>Singly Linked Lists with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带类型脚本的单链表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/singly-linked-lists-with-typescript-ca0b93845769?source=collection_archive---------0-----------------------#2021-02-04">https://levelup.gitconnected.com/singly-linked-lists-with-typescript-ca0b93845769?source=collection_archive---------0-----------------------#2021-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="faa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据结构是编程的核心，经常在你最不经意的时候派上用场。即使他们没有，你也确实需要他们来完成很多面试。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/58d263e326fc2b3721b89fe52cdc7f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CtE1qRpvIg-1LfyAzIoSwQ.png"/></div></div></figure><p id="7262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链表是一种常见的数据结构，本博客将帮助您理解如何使用typescript实现链表。</p><p id="efd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将会看到单链表。</p><p id="d891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持有趣，我们将使用一个非常酷的用例。游戏是我最喜欢的爱好之一，所以我们将使用链表来计算一个角色在攻击序列结束时造成的伤害。</p><h1 id="8716" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">链表如何适应我们的用例</h1><p id="9b00" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果我们想象一个角色攻击另一个角色，那么在最好的情况下，这个特定的角色应该能够无限命中，直到受害者的HP耗尽。</p><p id="4706" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们有一个不确定长度的攻击输入，可以收到了。</p><p id="0804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们将需要计算整个攻击链来反映总伤害，并在必要时应用特殊的buffs，如移动乘数。</p><p id="7df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链表在这里可以派上用场，因为我们可以使用它们来容纳插入的不确定数量的节点。</p><p id="fe8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与数组不同，这些节点不必是连续的，因此我们可以将它们分布在内存空间中，并使用指针来链接它们。</p><p id="9955" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也有助于消除使用相同的连续内存块上下移动节点的问题，或者由于数组通常为存储元素分配上限而浪费内存的问题。可能永远也到不了。</p><p id="874c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，缺点是访问特定的节点来检查它们的状态。这在阵列中可能会更快，但在我们的情况下，我们只关心所造成的总损害。</p><p id="cce9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以重新计算每次添加或删除节点所造成的总伤害。</p><p id="aa6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们开始吧。</p><h1 id="b8d5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">单链表</h1><p id="fa54" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们首先为链表创建节点，并为主链表类创建基本的shell。</p><p id="f4ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以这样做:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="34b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经创建了一个<strong class="jp ir"> ListNode </strong>，它将用于表示我们的链表中的每个单独的节点。这将保存一个<strong class="jp ir">值</strong>，以及一个<strong class="jp ir">下一个</strong>属性，该属性带有一个指向列表中下一个节点的指针。</p><p id="8d04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<strong class="jp ir"> LinkedList </strong>类保存当前的“<strong class="jp ir"> head </strong>”，列表的开始。<strong class="jp ir"> size </strong>属性只是用来跟踪列表中当前节点的总数<strong class="jp ir">。</strong></p><p id="bf5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们继续向LinkedList类添加方法来管理节点。</p><h2 id="ebea" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">推</h2><p id="36e7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">此方法将用于将节点推送到列表中，即将节点添加到列表的末尾。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="be21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> push </strong>方法接受一个与LinkedList对象实例化类型相同的值，因此我们使用了一个通用类型“T”。然后我们用这个传递的值创建一个新的<strong class="jp ir"> ListNode </strong>。</p><p id="8006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果链表为空，我们的<strong class="jp ir"> head </strong>属性将被设置为null(默认)。在这种情况下，我们可以直接将我们的新节点指定为头节点。</p><p id="4705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果列表中已经存在节点，那么我们必须遍历列表来找到最后一个节点。最后一个节点将位于列表的末尾，因此它的<strong class="jp ir"> next </strong>属性将指向<strong class="jp ir"> null </strong>。</p><p id="cc97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个条件，我们创建一个while循环来遍历列表的末尾，并在那里插入我们的新节点。</p><p id="78f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我们添加一个新的节点，我们还会将列表的大小增加1，以跟踪当前节点的总数。</p><h2 id="09ce" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">流行音乐</h2><p id="dbf1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这个方法将用于从列表末尾移除一个节点。由于我们目前处理的是一个单向链表，<strong class="jp ir">我们不会有一个“tail”属性来指示链表的确切结束位置(双向链表的情况就是如此)。</strong></p><p id="0c0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，要找到最后一个节点，我们需要遍历到末尾，然后从列表中删除它。</p><p id="2428" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以这样做:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5fa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在pop方法中，我们首先检查列表是否已经为空。因为那样的话从列表中弹出任何一项都没有意义。</p><p id="16a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们通过查看它的大小来检查列表是否只有一个节点。这意味着列表只有一个head。因此在这种情况下，我们可以直接将head赋值为null并清空列表。</p><p id="deca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每次删除操作后，我们都会小心减小列表的大小。</p><h2 id="3485" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">推动和弹出动作</h2><p id="8d1c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">要查看push和pop的运行情况，让我们获取一个<strong class="jp ir"> LinkedList </strong>的实例，然后记录这些方法的输出:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9166" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我建议使用<strong class="jp ir"> jsbin </strong>在线处理这段代码。这将是您的控制台中的输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mo"><img src="../Images/b2e337cbf4ff9c703199935f46f1c6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsTytu6dHcEEoryJ284TqA.png"/></div></div></figure><p id="2b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们第一次尝试弹出一个空列表时得到“false ”,就像我们编程时那样。</p><p id="c06a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和预期的一样，它后面的所有操作都成功了。我们已经有了足够好的基础，可以开始实际实施我们的攻击系统。</p><h1 id="d322" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">让链表发挥作用</h1><p id="f168" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们现在将继续使用我们的链表来追踪游戏中角色的攻击伤害。</p><p id="577e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，让我们修改现有的<strong class="jp ir"> ListNode </strong>和<strong class="jp ir"> LinkedList </strong>。首先让我们看看新的<strong class="jp ir">列表节点</strong>，我们现在称之为<strong class="jp ir">攻击节点</strong>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4f6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在我们的<strong class="jp ir"> AttackNode </strong>中添加了一个名为<strong class="jp ir"> attackBuff </strong>的新属性，以防任何新的Buff与攻击一起应用(这在游戏中很常见)。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="c311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将使用我们的链接列表来跟踪造成的总损失。为了更好的语义，我们的<strong class="jp ir"> LinkedList </strong>类现在将被称为<strong class="jp ir"> AttackList </strong>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">修改LinkedList类，以及push和pop方法</figcaption></figure><p id="8e5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们添加了一个<strong class="jp ir"> totalDamage </strong>属性，并且每当一个新的节点被推入或者一个现有的节点从列表中弹出时重新计算总损害。</p><p id="acfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，在推送一个新节点时，我们现在需要同时传递attackBuff值。</p><p id="8f5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看它是如何工作的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6ea0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将记录以下输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/15773d509d4bcde03ca5a0353afce784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBIoZ9bzYAh53LljJ3SnEg.png"/></div></div></figure><p id="0b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如预期的那样工作，我们有一个在我们弹出一个节点后重新计算的总伤害。</p><p id="d9cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们为什么要弹出一个节点？好吧，想象另一个角色能够偏转攻击，因此我们从总伤害中减去偏转的攻击。</p><h1 id="3e23" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更多链表方法</h1><p id="ceb7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">向我们的链表中添加更多的方法会很有用，这样我们可以更灵活地使用它。添加在两端添加和移除节点的能力可以帮助我们将链表用作堆栈和队列</p><h2 id="d986" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">变化</h2><p id="7c2b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">shift方法可用于从链表的开头移除一个列表节点。与数组相比，这里的优势在于我们不必重新调整剩余的元素，因为它们不存储在连续的内存块中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="dd7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和预期的一样，shift方法首先检查一个空列表。在这之后，我们将分配列表的第二个节点作为新的头。</p><p id="a7f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们通过将它的next属性设置为null，从列表中删除前一个head，因此它现在不指向任何地方。</p><p id="b1c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后，我们重新计算总伤害和列表大小。</p><p id="ba95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果列表开始时只有一个节点，那么它的<strong class="jp ir"> next </strong>属性将会为空。因此，新报头也将被设置为空。</p><h2 id="3bb7" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">松开打字机或键盘的字型变换键</h2><p id="78a9" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">unshift方法可用于在链表的开头添加一个新节点。同样，因为我们没有将节点存储在连续的内存块中，所以我们不必重新计算间距或重新调整内存中的节点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="8132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于push方法，只是我们在列表的开头添加了一个节点。我们创建一个新节点并将其链接到现有的head，然后将现有的head重新分配为这个新节点。</p><p id="d753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于新节点在此操作之前已链接到前一个头，因此旧头现在是列表中的第二个元素。</p><p id="0eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看换档和取消换档的效果:</p><pre class="km kn ko kp gt nb nc nd ne aw nf bi"><span id="3e85" class="mc ky iq nc b gy ng nh l ni nj">// create a new list instance<br/>const ll = new AttackList&lt;number&gt;();</span><span id="fb02" class="mc ky iq nc b gy nk nh l ni nj">// try to shift an empty list<br/>console.log(ll.shift());</span><span id="5a0a" class="mc ky iq nc b gy nk nh l ni nj">// unshift with passed value and attackBuff<br/>ll.unshift(10, 20);<br/>ll.unshift(5, 5);</span><span id="93d5" class="mc ky iq nc b gy nk nh l ni nj">// log total damage<br/>console.log(ll.totalDamage);</span><span id="55b3" class="mc ky iq nc b gy nk nh l ni nj">// shift to remove first node<br/>console.log(ll.shift());</span><span id="17ac" class="mc ky iq nc b gy nk nh l ni nj">console.log(ll.totalDamage);</span></pre><p id="3d05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述操作的输出符合预期:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/42cfcee234c015dc94a8a9ea69b98a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfEi95EDhVpMbdQsE1DCnQ.png"/></div></div></figure><p id="1e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们把两个节点相加后，如果移动一个空数组，就会得到一个false。</p><p id="9fd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们移动一个节点，记录重新计算的总伤害。</p><h2 id="e8db" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">GetAtIndex</h2><p id="7e9b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">getAtIndex方法可用于从用户处获取给定的索引或位置，然后返回该特定节点。</p><p id="5285" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是链表与数组相比效率低下的地方，因为我们必须遍历每个节点才能到达一个特定的索引。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a62b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们首先验证传递的索引。然后，我们使用一个计数器遍历列表，直到到达特定的索引。</p><p id="f9cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们返回这个索引处的节点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/6517ecb8924289faa81ad08e56b448da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28_teDqCoqZ1X6__IeGSyg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">列表中索引2处的节点</figcaption></figure><h2 id="e16d" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">移除索引</h2><p id="befa" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们也可以类似地从特定索引中删除一个节点。这将再次要求我们遍历到特定的索引值，然后将索引之前的节点和索引之后的节点链接在一起。</p><p id="838d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要删除的节点也应该被分离，这样它就不包含对列表或其任何节点的引用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="e4d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行上面的代码，我们得到以下输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/a534faa24b3df794f0c26359cbb0fdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGxHvuunm3Qc98KMF1m7Eg.png"/></div></div></figure><p id="4eec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这正是我们想要的。</p><p id="994c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下当然也行得通:</p><pre class="km kn ko kp gt nb nc nd ne aw nf bi"><span id="55a3" class="mc ky iq nc b gy ng nh l ni nj">const ll = new AttackList&lt;number&gt;();</span><span id="6e84" class="mc ky iq nc b gy nk nh l ni nj">ll.push(10, 5);<br/>ll.push(20, 5);<br/>ll.push(30, 5);</span><span id="6bea" class="mc ky iq nc b gy nk nh l ni nj">console.log(ll.totalDamage);<br/>console.log(ll.removeAtIndex(2));<br/>console.log(ll.totalDamage);</span><span id="37f7" class="mc ky iq nc b gy nk nh l ni nj">Output:</span><span id="5eb1" class="mc ky iq nc b gy nk nh l ni nj">75<br/>true<br/>50</span></pre><h2 id="a876" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">插入索引</h2><p id="c8c7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果到目前为止你已经掌握了链表是如何工作的要点，你可以自己实现这个方法作为练习。</p><p id="fe60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请自行尝试，如果无法找到解决方案，请参考下面的代码:</p><p id="dd52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个方法将接受一个索引，在它后面插入一个节点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="74e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们获得一个新节点，并验证传递的索引。我们遍历列表，直到到达索引，并将我们的新节点<strong class="jp ir">插入到这个索引的</strong>之后。</p><p id="0082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当从列表中获取这个新节点时，我们必须传递n+1作为索引。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/448c445fa4e4b8993c5bc0611a9cfda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qfffs1GmyDrPKJHGSDHtQ.png"/></div></div></figure><h2 id="d058" class="mc ky iq bd kz md me dn ld mf mg dp lh jy mh mi ll kc mj mk lp kg ml mm lt mn bi translated">发现</h2><p id="7cf3" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">find方法可以用来检查一个特定的值是否存在于我们的链表中。</p><p id="c428" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现起来非常简单，我们将遍历列表，如果发现一个值等于当前值，我们将返回节点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c76a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出显示了特定节点的数据:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/f52c5ea08c01ded5b5b23067da507d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdKoadYL8XNpns-l8fNctA.png"/></div></div></figure><h1 id="a065" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">把所有的放在一起</h1><p id="74e5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们现在有一些有用的方法可以使用，同时登记一个角色所做的一连串攻击。</p><p id="044c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用这些方法在任何给定的位置创建新的攻击节点，如果接收者偏离任何攻击节点，则删除攻击节点，并在我们想要显示攻击统计数据时找到特定的节点。</p><p id="fbdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些都是在链表的帮助下实现的，尽管它们对于某些特定的操作来说效率很低，但是对于插入和删除来说，它们真的很好。</p><p id="f456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，当我们将攻击推送到一个列表中时，单链表会更好地使用，但不适合访问特定的节点来查看其统计数据。数组更适合这种情况。</p><p id="5e5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要我们的需求是推送攻击节点和计算造成的总损害，链表将是更好的选择，因为它们不需要存储在连续的内存块中。</p><p id="6091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于利弊的完整列表，请看<a class="ae no" href="https://www.geeksforgeeks.org/linked-list-vs-array/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="9232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将很快在另一个博客中讨论双向链表。</p></div></div>    
</body>
</html>