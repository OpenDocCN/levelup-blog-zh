<html>
<head>
<title>Dependency Injection in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-in-typescript-5fd1f6207f2?source=collection_archive---------0-----------------------#2021-11-08">https://levelup.gitconnected.com/dependency-injection-in-typescript-5fd1f6207f2?source=collection_archive---------0-----------------------#2021-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8fca73d9401a271912b7461ddf00422b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RbmfNyhuBb8G3LWh.png"/></div></div></figure><h1 id="3b0e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">动机</h1><p id="d382" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在过去几年中，Node成为最受欢迎的后端解决方案之一。在Node上启动一个应用程序并开始动态处理HTTP请求是非常容易的。但有一个问题，在大多数情况下，节点应用程序在增长时会变得非常复杂和耦合，因此保持域和持久层分离变得非常困难。</p><p id="dc50" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了解决这个问题，我们应该深入到<a class="ae lz" href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design" rel="noopener ugc nofollow" target="_blank">固体</a>架构的世界中去(这是今天的一部分)。为了根据<a class="ae lz" href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design" rel="noopener ugc nofollow" target="_blank">坚实的</a>准则编写代码，我们需要<a class="ae lz" href="https://www.martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。它允许我们将类的创建从它们的实现中抽象出来，这将域/业务逻辑从所有其他层中分离出来，并使代码更容易维护。</p><p id="6411" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于节点中的依赖注入，没有现成的解决方案，但是我们可以在TypeScript decorators的帮助下实现我们自己的DI服务。</p><p id="e3cb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们开始吧。</p><h1 id="3b7e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">履行</h1><p id="c6d3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于decorators仍处于实验模式，我们需要在<strong class="ky ir"> <em class="ma"> tsconfig.json </em> </strong>中启用它们</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4c50" class="mk jz iq mg b gy ml mm l mn mo">{</span><span id="2373" class="mk jz iq mg b gy mp mm l mn mo">  "compilerOptions": {</span><span id="fd62" class="mk jz iq mg b gy mp mm l mn mo">    "target": "ES5",</span><span id="806d" class="mk jz iq mg b gy mp mm l mn mo">    "experimentalDecorators": true,</span><span id="d2c7" class="mk jz iq mg b gy mp mm l mn mo">    "emitDecoratorMetadata": true,</span><span id="eb07" class="mk jz iq mg b gy mp mm l mn mo">    "outDir": "dist"</span><span id="f09d" class="mk jz iq mg b gy mp mm l mn mo">  }</span><span id="0862" class="mk jz iq mg b gy mp mm l mn mo">}</span></pre><p id="bdcf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">假设我们有一个后端应用程序，非常需要Logger。Logger可以有多种实现，有些可以直接在控制台中记录消息，有些可以将消息存储在数据库中，还有一些可以同时实现这两种功能。</p><p id="f779" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们定义通用记录器抽象类，它将由实际的记录器实现</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c91c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里没有什么特别的，只是一个具有单一<code class="fe ms mt mu mg b">log</code>方法的抽象类。现在让我们看看可能的日志记录器实现。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f04e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于每个依赖项，我们需要一个惟一的字符串标识符，它将被映射到实际的类实例</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1a32" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们需要某种管理器类，它将存储所有初始化的类，并在依赖类需要时注入它们。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0fbf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们有希望注入的日志类和存储所有需要的映射的DependencyManager。唯一剩下的是<code class="fe ms mt mu mg b"><strong class="ky ir"><em class="ma">@Inject </em></strong></code> decorator(这里阅读更多<a class="ae lz" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank">关于TypeScript decorators的</a>，它将在我们的依赖管理器的帮助下负责注入类的实际实例</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4946" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此时，我们已经准备好使用我们的注入装饰器，并看到我们的代码在运行</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3488" class="mk jz iq mg b gy ml mm l mn mo">Output:<br/>LogServiceA -&gt; test<br/>LogServiceB -&gt; test</span></pre><p id="5c13" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还可以用<code class="fe ms mt mu mg b">@Injectable</code> decorator轻松地定义可注入类，因为我们已经实现了<code class="fe ms mt mu mg b">@Injectable</code>,我们只需要在类声明的顶部添加一个具有唯一id的调用</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9965" class="mk jz iq mg b gy ml mm l mn mo">Output:<br/>LogServiceC -&gt; test</span></pre><p id="4583" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如你所见，注射剂也可以作为注射剂使用。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="d82e" class="jy jz iq bd ka kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv bi translated">摘要</h1><p id="ccf4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是对Node中依赖注入的一个小介绍。依赖注入确实比这更深入，比如直接注入到构造函数中，用符号代替令牌(类似于Angular是怎么做的)。然而，我希望这已经让您对依赖注入在幕后是如何工作的有了一点了解。当我第一次开始编写代码时，依赖注入是一个黑盒，我知道它非常有用，但不知道它是如何工作的，我希望在这篇文章之后，还有一个关于软件工程的神奇部分，你不再被蒙在鼓里。</p><p id="f830" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此处代码可用<a class="ae lz" href="https://github.com/dudupopkhadze/ts-dependency-injection" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="6df1" class="mk jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">黑客快乐！</h2></div></div>    
</body>
</html>