<html>
<head>
<title>How to Create a Python API Using Flask and Connexion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Flask和Connexion创建Python API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-python-api-using-flask-connexion-4f3fc77e7f6e?source=collection_archive---------2-----------------------#2020-11-30">https://levelup.gitconnected.com/how-to-create-a-python-api-using-flask-connexion-4f3fc77e7f6e?source=collection_archive---------2-----------------------#2020-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让经过认证的后端在云中运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff665fe8957eaaa7d0bb810cdfd28a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhGSvk28TrHwlZcLmhqXYQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/terimakasih0-624267/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1020837" rel="noopener ugc nofollow" target="_blank">迪安·莫里亚蒂</a>从<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1020837" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</figcaption></figure><p id="2c28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/modern-php-df3d3bf343f8">现代PHP </a>中，我创建了一个全栈应用程序。后来我用PHP和Lumen编写了<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/microservices-with-php-and-lumen-d9af0b915a71?source=your_stories_page-------------------------------------">微服务</a>，它使用PHP和Lumen提供了一个partial REST API，可以简单地读取原始全栈应用程序产生的数据，并将其作为JSON提供。今天，我将创建、更新和删除API的一部分，以补充读取微服务。我打算用Python来做，因为微服务架构的一个自由就是你可以为每个服务使用不同的表达语言。</p><p id="b2d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来很疯狂，但是想想如果你经营一家开发店，你有一个PHP的编码专家和另一个Python的编码专家。你可以在他们的专业领域充分利用这两者。</p><p id="0ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通用代码呢？如果你的微服务做得对，就不应该有通用代码。你可能有共同的有效载荷，而那些必须被复制。但是这些类型的数据结构很容易编码，重复自己是一个小罪过。每个人都说要保持干燥(不要重复)，但我是说稍微潮湿一点没关系。尤其是重复的代码没有逻辑的情况下。</p><p id="40a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的开源社区非常成熟，所以大多数常见代码都可以来自外部依赖。一个好的微服务应该能够在一个文件中完成(根据语言的不同，可能有一些样板文件)。</p><p id="1d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是我不喜欢单元测试的原因。如果您的微服务需要单元测试，它可能不再是微的，您可能会考虑如何分解它。测试微服务的最佳方式是部署它们并检查输入和输出。Postman 可以是一个非常方便的工具，它提供了可以用作简单测试套件的集合。</p><h2 id="71a9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">证明</h2><p id="860c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">既然我已经讲述了微服务，让我们直接进入代码。我们要完成的第一件事是身份验证。因为我们将编写一个修改数据库的API，所以我们需要限制访问。我之前创建的read API可以被任何人读取，没有特定于用户的数据，所以没有必要限制它。我现在首选的身份验证是<a class="ae ky" href="https://www.okta.com/" rel="noopener ugc nofollow" target="_blank"> Okta </a>。</p><p id="b45f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从技术上讲，如果您不想进行身份验证，可以跳到“填写API”一节。如果你只是在本地运行，这没什么。但是这里的目标是拥有一个云就绪的API永远不要把任何可以修改数据库或文件系统的东西放在互联网上，也不要把任何可以存储数据并在以后不受限制地检索数据的东西放在互联网上。让一台服务器在互联网上暴露几天，看看访问日志，它们会充满漏洞探测。</p><p id="0a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将重用我们在现代PHP系列中使用的认证系统，特别是<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/modern-php-part-3-1f5b78b3371d">第3部分</a>，它承诺为您的所有应用程序提供单点登录。为了获得最佳效果，您应该阅读并尝试实现所有三个部分中显示的应用程序。</p><p id="33ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何使你的后端API得到认证？您的前端使用第三方服务(Okta)进行身份验证，接收一个令牌(在本例中是一个JWT)，然后在任何请求的授权头中发送JWT。然后，API可以验证具有相同第三方服务的JWT，并将其分解为各个方面，如用户名和角色，以便它可以进行授权(参见本文中关于<a class="ae ky" href="https://www.okta.com/identity-101/authentication-vs-authorization/" rel="noopener ugc nofollow" target="_blank">身份验证与授权</a>)。</p><p id="a8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从Okta Python示例应用程序开始，该应用程序可以在他们的<a class="ae ky" href="https://github.com/okta/samples-python-flask" rel="noopener ugc nofollow" target="_blank">示例GitHub存储库</a>中找到。让我们克隆它，并复制我们需要的部分作为初始代码库。从您希望保存不同存储库的目录开始:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cbec" class="lv lw it mu b gy my mz l na nb">git clone <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:okta/samples-python-flask.git</span></pre><p id="9d70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在设置您的新项目目录:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="16ac" class="lv lw it mu b gy my mz l na nb">mkdir flaskapi<br/>cp samples-python-flask/resource-server/* flaskapi<br/>cp samples-python/requirements.txt .<br/>cd flaskapi<br/># I use pip3 from brew on my Mac.<br/># You may also want to set up a virtual environment here<br/>pip3 install -r requirements.txt</span></pre><p id="f492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续编辑您的<code class="fe nc nd ne mu b">README.md</code>，并添加一个<code class="fe nc nd ne mu b">LICENSE</code>和您通常在项目中保留的任何内容。有一个文件<code class="fe nc nd ne mu b">client_secrets.json.dist</code>，它会让你的秘密不被Okta知道。一旦它被填充，我们不想把它签入GitHub。我常用的技术是将包含敏感信息的文件复制到存储库的父目录，它永远不会提交给git，然后在那里引用它:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fdda" class="lv lw it mu b gy my mz l na nb">mv client_secrets.json.dist ../client_secrets.json</span></pre><p id="740a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以编辑它并替换<code class="fe nc nd ne mu b">OKTA_DOMAIN</code>、<code class="fe nc nd ne mu b">CLIENT_ID</code>和<code class="fe nc nd ne mu b">CLIENT_SECRET</code>。如果您遵循了现代PHP系列，您应该已经有了一个<code class="fe nc nd ne mu b">config.yml</code>，我们用它作为凭证单点登录代理，并且在与<code class="fe nc nd ne mu b">client_secrets.json</code>相同的目录中有这些值。否则，您将不得不在设置应用程序时使用Okta中的值。</p><p id="9085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，编辑<code class="fe nc nd ne mu b">main.py</code>，将<code class="fe nc nd ne mu b">./client_secrets.json</code>改为<code class="fe nc nd ne mu b">../client_secrets.json</code>。使用以下命令启动服务器:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="dcb2" class="lv lw it mu b gy my mz l na nb">python3 main.py</span></pre><p id="3a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并浏览至<a class="ae ky" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ac0ec5ac24e96557e63f0f2b6fa68d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j58_xsd1Lvts8_rHXk_4Rg.png"/></div></div></figure><p id="b901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止相当无聊！这给我们带来了一个先有鸡还是先有蛋的问题，您需要前端登录并获取JWT，以便我们可以查看访问控制路径<code class="fe nc nd ne mu b">api/messages</code>，现在我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f2af808563d9af3bf21a79fbc4dc13ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gltmXhROva2KAmVnfZgzeg.png"/></div></div></figure><p id="f7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是单点登录的一部分，我可以使用我的一个使用JWT的应用程序，通过使用Chrome开发者工具来复制它。但是还有另一种方法。如果您有Postman(您应该)添加一个带有<a class="ae ky" href="http://localhost:8000/api/messages" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/API/messages</a>的GET请求，单击Authorization选项卡，选择OAuth 2.0的类型，然后单击“Get New Access Token”按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/89dd5841992f7e90b0f110fcf5f82844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GThotNu7dR5QiXNZBon2MA.png"/></div></div></figure><p id="b433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，填写字段</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d7b16447927993ca1842210cab48775c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Gn-5elM-79GYuACkhn-rw.png"/></div></div></figure><p id="aee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的回调URL来自我之前设置的凭证代理，所以我可以在我的Okta客户端设置中有一个回调URL。你应该使用你在设置Okta时输入的任何内容。</p><p id="ad1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个屏幕上，单击“使用令牌”按钮，它将自动填写授权标题。现在，您可以按“发送”按钮，您应该可以访问安全的终端</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/6fddc80b3b20e78baee65e9b0b2e8c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ocj5aRx_fovMuTss5KfH9w.png"/></div></div></figure><p id="8ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JWT代币过一会儿就过期了，所以到期时你需要换一张新的。</p><h2 id="2d42" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">填写API</h2><p id="f441" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们只有示例端点，让我们制作一些真正的端点。我将使用Connexion库将Swagger标记转换为所有端点。这种方法的好处是Swagger不仅可以定义您的API，它还可以用来生成样板代码，以及一个可以帮助您为其他人测试和记录API参数的UI。下面是我们将要使用的<code class="fe nc nd ne mu b">swagger.yml</code>:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="659d" class="lv lw it mu b gy my mz l na nb">swagger: "2.0"<br/>info:<br/>  description: Wine Cheese Pairing API Swagger<br/>  version: "1.0.0"<br/>  title: Wine Cheese Pairing API<br/>consumes:<br/>  - application/json<br/>produces:<br/>  - application/json</span><span id="782a" class="lv lw it mu b gy nk mz l na nb">basePath: /api</span><span id="7e37" class="lv lw it mu b gy nk mz l na nb"># Paths supported by the server application<br/>paths:<br/>  /pairing:<br/>    get:<br/>      operationId: winePairing.read_all<br/>      tags:<br/>        - WinePairing<br/>      summary: Read the entire list of Wine Cheese Pairings<br/>      description: Read the list of Wine Cheese Pairings<br/>      parameters:<br/>        - name: length<br/>          in: query<br/>          type: integer<br/>          description: Number of Wine Cheese Pairings to get<br/>          required: false<br/>        - name: offset<br/>          in: query<br/>          type: integer<br/>          description: Offset from beginning<br/>          required: false<br/>      responses:<br/>        200:<br/>          description: Successfully read list operation<br/>          schema:<br/>            type: array<br/>            items:<br/>              properties:<br/>                id:<br/>                  type: integer<br/>                wine:<br/>                  type: string<br/>                wine_descrption:<br/>                  type: string<br/>                cheese:<br/>                  type: string<br/>                cheese_descrption:<br/>                  type: string<br/>                pairing_notes:<br/>                  type: string</span><span id="fb06" class="lv lw it mu b gy nk mz l na nb">    post:<br/>      operationId: winePairing.create<br/>      tags:<br/>        - WinePairing<br/>      summary: Create a wine pairing and add it<br/>      description: Create a new wine pairing<br/>      parameters:<br/>        - name: pairing<br/>          in: body<br/>          description: Pairing to create<br/>          required: True<br/>          schema:<br/>            type: object<br/>            properties:<br/>                wine:<br/>                  type: string<br/>                wine_descrption:<br/>                  type: string<br/>                cheese:<br/>                  type: string<br/>                cheese_descrption:<br/>                  type: string<br/>                pairing_notes:<br/>                  type: string<br/>      responses:<br/>        201:<br/>          description: Successfully created wine pairing</span><span id="a656" class="lv lw it mu b gy nk mz l na nb">  /pairing/{id}:<br/>    get:<br/>      operationId: winePairing.read_one<br/>      tags:<br/>        - WinePairing<br/>      summary: Read one wine pairing<br/>      description: Read one wine pairing<br/>      parameters:<br/>        - name: id<br/>          in: path<br/>          description: Id of the pairing<br/>          type: integer<br/>          required: True<br/>      responses:<br/>        200:<br/>          description: Successfully read wine pairing<br/>          schema:<br/>            properties:<br/>                id:<br/>                  type: integer<br/>                wine:<br/>                  type: string<br/>                wine_descrption:<br/>                  type: string<br/>                cheese:<br/>                  type: string<br/>                cheese_descrption:<br/>                  type: string<br/>                pairing_notes:<br/>                  type: string</span><span id="a92e" class="lv lw it mu b gy nk mz l na nb">    put:<br/>      operationId: winePairing.update<br/>      tags:<br/>        - WinePairing<br/>      summary: Update a wine pairing<br/>      description: Update a wine pairing<br/>      parameters:<br/>        - name: id<br/>          in: path<br/>          description: Id of the wine pairing to update<br/>          type: integer<br/>          required: True<br/>        - name: person<br/>          in: body<br/>          schema:<br/>            type: object<br/>            properties:<br/>                id:<br/>                  type: integer<br/>                wine:<br/>                  type: string<br/>                wine_descrption:<br/>                  type: string<br/>                cheese:<br/>                  type: string<br/>                cheese_descrption:<br/>                  type: string<br/>                pairing_notes:<br/>                  type: string<br/>      responses:<br/>        200:<br/>          description: Successfully updated wine pairing</span><span id="bdfc" class="lv lw it mu b gy nk mz l na nb">    delete:<br/>      operationId: winePairing.delete<br/>      tags:<br/>        - WinePairing<br/>      summary: Delete a wine pairing<br/>      description: Delete a wine pairing<br/>      parameters:<br/>        - name: id<br/>          in: path<br/>          type: integer<br/>          required: True<br/>      responses:<br/>        200:<br/>          description: Successfully deleted a wine pairing</span></pre><p id="d31e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用Connexion，首先安装它:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="19cb" class="lv lw it mu b gy my mz l na nb">pip3 install connexion<br/>pip3 install "connexion[swagger-ui]"</span></pre><p id="863e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nc nd ne mu b">connexion[swagger-ui]</code>被引用了。Mac上的新shell，<code class="fe nc nd ne mu b">zsh</code>将[]视为特殊字符，所以我们需要用引号将其括起来。此外，将新的需求添加到requirements.txt的末尾。</p><p id="f2e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mu b">operationId</code>是我们连接代码的地方。例如，<code class="fe nc nd ne mu b">winePairing.read_all</code>需要是文件<code class="fe nc nd ne mu b">winePairing.py</code>中的方法<code class="fe nc nd ne mu b">read_all</code>。这是在<code class="fe nc nd ne mu b">winePairing.py</code>的第一关:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="aa22" class="lv lw it mu b gy my mz l na nb">def read_one(id):<br/>    return "this is a pairing"</span><span id="dd25" class="lv lw it mu b gy nk mz l na nb">def read_all():<br/>    return "this is the pairing list"</span><span id="2b12" class="lv lw it mu b gy nk mz l na nb">def create():<br/>    return "this is where we create"</span><span id="0940" class="lv lw it mu b gy nk mz l na nb">def update(id):<br/>    return "this is where we update"</span><span id="f565" class="lv lw it mu b gy nk mz l na nb">def delete(id):<br/>    return "this is where we delete"</span></pre><p id="b2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以将连接库添加到我们的main.py中:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0491" class="lv lw it mu b gy my mz l na nb">import json<br/>import time</span><span id="6e37" class="lv lw it mu b gy nk mz l na nb">from flask import Flask, render_template, url_for, redirect<br/>from flask_cors import CORS<br/>from flask_oidc import OpenIDConnect</span><span id="7abf" class="lv lw it mu b gy nk mz l na nb">import connexion</span><span id="fdb4" class="lv lw it mu b gy nk mz l na nb"># Create the application instance<br/>app = connexion.App(__name__, specification_dir='./')</span><span id="de39" class="lv lw it mu b gy nk mz l na nb"># Read the swagger.yml file to configure the endpoints<br/>app.add_api('swagger.yml')</span><span id="9fe6" class="lv lw it mu b gy nk mz l na nb">CORS(app.app)<br/>app.app.config.update({<br/>    'SECRET_KEY': 'SomethingNotEntirelySecret',<br/>    'OIDC_CLIENT_SECRETS': '../client_secrets.json',<br/>    'OIDC_ID_TOKEN_COOKIE_SECURE': False,<br/>    'OIDC_SCOPES': ["openid", "profile", "email"],<br/>    'OIDC_CALLBACK_ROUTE': '/authorization-code/callback'<br/>})</span><span id="66f2" class="lv lw it mu b gy nk mz l na nb">oidc = OpenIDConnect(app.app)</span><span id="d715" class="lv lw it mu b gy nk mz l na nb"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/")<br/>def home():<br/>    return "Hello!  There's not much to see here." \<br/>           "Please grab one of our front-end samples for use with this sample resource server"</span><span id="16f3" class="lv lw it mu b gy nk mz l na nb"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/api/messages")<br/><a class="ae ky" href="http://twitter.com/oidc" rel="noopener ugc nofollow" target="_blank">@oidc</a>.accept_token(True)<br/>def messages():<br/>    response = {<br/>        'messages': [<br/>            {<br/>                'date': time.time(),<br/>                'text': 'I am a robot.'<br/>            },<br/>            {<br/>                'date': time.time()-3600,<br/>                'text': 'Hello, World!'<br/>            }<br/>        ]<br/>    }</span><span id="6cfe" class="lv lw it mu b gy nk mz l na nb">return json.dumps(response)</span><span id="0731" class="lv lw it mu b gy nk mz l na nb">if __name__ == '__main__':<br/>    app.run(host="localhost", port=8000, debug=True)</span></pre><p id="5963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在开始尝试吧。运行:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9640" class="lv lw it mu b gy my mz l na nb">python3 main.py</span></pre><p id="be30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并浏览至<a class="ae ky" href="http://localhost:8000/api/ui" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/API/ui</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/7250b5e75bc5e5160be380d8dd346e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdWSH59iit31rEWwsAZPKQ.png"/></div></div></figure><p id="fe9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很时髦，是吧？单击周围，尝试每个端点。除了我们放在<code class="fe nc nd ne mu b">winePairing.py</code>文件中的虚假信息之外，你什么也得不到。</p><h2 id="894a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">添加数据库</h2><p id="e665" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果没有数据库来存储数据，那么使用API来修改数据就没有多大意义。我可以从我的现代PHP转到存储库，使用<code class="fe nc nd ne mu b">docker-compose.yml</code>打开数据库并初始化它，但我只是把它复制到这里，这样就方便了。因为我们使用Docker Compose，所以您必须安装Docker。如果没有，请遵循这些<a class="ae ky" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank">说明</a>。此外，您应该在<a class="ae ky" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>有一个账户</p><p id="48c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用MariaDB。如果你对MariaDB和MySQL感到困惑，当MySQL被Oracle收购时，MySQL的创建者并不认为Oracle会保留MySQL，因为它是他们主要摇钱树的竞争对手。所以它被分流到开源的MariaDB。自从被分叉后，它们几乎保持不变，所以通常很容易把一个换成另一个。但是如果你是一个尽责的开源者，请使用并支持MariaDB。</p><p id="6419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要三样东西来启动MariaDB，一个docker-compose.yml(您也可以从命令行运行docker)，一个init脚本和一个带秘密的配置脚本。我将从现代PHP系列创建的项目中复制这些内容，但我将在这里展示它们。下面是docker-compose.yml:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fdfe" class="lv lw it mu b gy my mz l na nb">version: "3"<br/>services:<br/>  mariadb:<br/>    image: mariadb<br/>    restart: always<br/>    volumes:<br/>     - ./init:/docker-entrypoint-initdb.d<br/>    env_file:<br/>      - ../mariadb.env<br/>    ports:<br/>      - 3306:3306</span></pre><p id="b3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像“mariadb”来自DockerHub，是官方图像。在“研究”模式下，我通常不贴图片标签，只拍最新的。当你开始真正的开发时，你应该总是使用一个标签，这样事情就不会神秘地中断。<code class="fe nc nd ne mu b">init</code>目录应该包含一个在MariaDB第一次启动时执行的脚本。以下是我所知道的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="eaa9" class="lv lw it mu b gy my mz l na nb">CREATE DATABASE IF NOT EXISTS winelist;<br/>USE winelist;<br/>CREATE TABLE IF NOT EXISTS wine_pairing<br/>  (id INT AUTO_INCREMENT NOT NULL,<br/>   wine VARCHAR(255) NOT NULL,<br/>   wine_description VARCHAR(255) NOT NULL,<br/>   cheese VARCHAR(255) NOT NULL,<br/>   cheese_description VARCHAR(255) NOT NULL,<br/>   pairing_notes VARCHAR(255) NOT NULL,<br/>   PRIMARY KEY(id))<br/>   DEFAULT CHARACTER SET utf8mb4<br/>   COLLATE `utf8mb4_unicode_ci`<br/>   ENGINE = InnoDB;</span><span id="97d6" class="lv lw it mu b gy nk mz l na nb">INSERT INTO wine_pairing (wine, wine_description, cheese, cheese_description, pairing_notes)<br/>  VALUES('wine1', 'wine1description', 'cheese1', 'cheese1description', 'notes1'),<br/>  ('wine2', 'wine2description', 'cheese2', 'cheese2description', 'notes2'),<br/>  ('wine3', 'wine3description', 'cheese3', 'cheese3description', 'notes3');</span></pre><p id="e18d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这个API将与我的葡萄酒和奶酪配对应用程序一起工作，所以它有一个表‘wine _ pairing’。</p><p id="3f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我将拥有包含秘密的<code class="fe nc nd ne mu b">mariadb.env</code>，以便应用程序可以与数据库对话。我将把这个文件保存在父目录中，因为它有秘密，我们不想把它们提交给GitHub。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8b45" class="lv lw it mu b gy my mz l na nb">DATABASE_URL=mysql://root:&lt;secrethere&gt;@mariadb:3306/winelist<br/>MYSQL_ROOT_PASSWORD=&lt;secrethere&gt;</span></pre><p id="643a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MariaDB读取MYSQL_ROOT_PASSWORD，另一个将由API使用。</p><p id="c788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些，我们就可以启动MariaDB了。但首先，我想确保我没有留下上一部分的任何容器:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3f41" class="lv lw it mu b gy my mz l na nb">docker ps -a<br/>&lt;stray containers listed here&gt;<br/>docker rm &lt;containerId1&gt; &lt;containerId2&gt; &lt;etc...&gt;</span></pre><p id="cac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那就发动她！</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0f05" class="lv lw it mu b gy my mz l na nb">docker-compose up</span></pre><p id="37b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我没有使用<code class="fe nc nd ne mu b">-d</code>选项，我喜欢在我的终端中查看日志。要继续，您可以按Command-T，它将打开一个新的终端窗口。如果希望能够查看数据库，可以使用Docker Compose exec命令:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="92bf" class="lv lw it mu b gy my mz l na nb">randalkamradt@Fuji flaskapi % docker-compose exec mariadb /bin/sh<br/># mariadb -u root -p<br/>Enter password: <br/>Welcome to the MariaDB monitor.  Commands end with ; or \g.<br/>Your MariaDB connection id is 4<br/>Server version: 10.5.5-MariaDB-1:10.5.5+maria~focal mariadb.org binary distribution</span><span id="50a6" class="lv lw it mu b gy nk mz l na nb">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><span id="0638" class="lv lw it mu b gy nk mz l na nb">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><span id="c758" class="lv lw it mu b gy nk mz l na nb">MariaDB [(none)]&gt; use winelist;<br/>Reading table information for completion of table and column names<br/>You can turn off this feature to get a quicker startup with -A</span><span id="dc9b" class="lv lw it mu b gy nk mz l na nb">Database changed<br/>MariaDB [winelist]&gt; select * from wine_pairing; <br/>+----+-------+------------------+---------+--------------------+---------------+<br/>| id | wine  | wine_description | cheese  | cheese_description | pairing_notes |<br/>+----+-------+------------------+---------+--------------------+---------------+<br/>|  1 | wine1 | wine1description | cheese1 | cheese1description | notes1        |<br/>|  2 | wine2 | wine2description | cheese2 | cheese2description | notes2        |<br/>|  3 | wine3 | wine3description | cheese3 | cheese3description | notes3        |<br/>+----+-------+------------------+---------+--------------------+---------------+<br/>3 rows in set (0.002 sec)</span><span id="81fc" class="lv lw it mu b gy nk mz l na nb">MariaDB [winelist]&gt; exit<br/>Bye<br/># exit<br/>randalkamradt@Fuji flaskapi %</span></pre><h2 id="f6c5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">与数据库对话</h2><p id="9195" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这就是奇怪的地方。我花了很多时间来弄清楚我需要哪些驱动程序，以及如何实现这个解决方案。我最后想到的是把文件拆分成<code class="fe nc nd ne mu b">main.py</code>、<code class="fe nc nd ne mu b">config.py</code>、<code class="fe nc nd ne mu b">models.py</code>和<code class="fe nc nd ne mu b">winePairing.py</code>。</p><p id="4783" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是首先，依赖关系。安装这些依赖项，并将它们添加到requirements.txt:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="de1a" class="lv lw it mu b gy my mz l na nb">pip3 install marshmallow<br/>pip3 install marshmallow-sqlalchemy<br/>pip3 install sqlalchemy<br/>pip3 install flask_sqlalchemy<br/>pip3 install flask_marshmallow<br/>pip3 install mysql-connector-python</span></pre><p id="89c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mu b">marshmallow</code>库用于编组输入和输出有效载荷。<code class="fe nc nd ne mu b">sqlalchemy</code>库提供ORM类型功能，而<code class="fe nc nd ne mu b">mysql-connector-python</code>是实际的MySQL/MariaDB驱动程序。</p><p id="48f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要跨模块共享的所有配置都包含在config.py中，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f8eb" class="lv lw it mu b gy my mz l na nb">import os<br/>import connexion<br/>from flask_sqlalchemy import SQLAlchemy<br/>from flask_marshmallow import Marshmallow<br/>from flask_cors import CORS</span><span id="2497" class="lv lw it mu b gy nk mz l na nb">basedir = os.path.abspath(os.path.dirname(__file__))<br/>connex_app = connexion.App(__name__, specification_dir=basedir)</span><span id="aca0" class="lv lw it mu b gy nk mz l na nb">app = connex_app.app</span><span id="9273" class="lv lw it mu b gy nk mz l na nb">app.config.from_pyfile('../flask.cfg')</span><span id="5820" class="lv lw it mu b gy nk mz l na nb">db = SQLAlchemy(app)</span><span id="59eb" class="lv lw it mu b gy nk mz l na nb">ma = Marshmallow(app)</span><span id="fa4a" class="lv lw it mu b gy nk mz l na nb">CORS(app)</span><span id="d76b" class="lv lw it mu b gy nk mz l na nb">app.config.update({<br/>    'SECRET_KEY': 'SomethingNotEntirelySecret',<br/>    'OIDC_CLIENT_SECRETS': '../client_secrets.json',<br/>    'OIDC_ID_TOKEN_COOKIE_SECURE': False,<br/>    'OIDC_SCOPES': ["openid", "profile", "email"],<br/>    'OIDC_CALLBACK_ROUTE': '/authorization-code/callback'<br/>})</span></pre><p id="dde0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我创建了<code class="fe nc nd ne mu b">connexion</code>应用程序，它包含了<code class="fe nc nd ne mu b">flask</code>应用程序。我在MariaDB配置的父目录<code class="fe nc nd ne mu b">../flask.cfg</code>中创建了一个新的secrets文件。看起来是这样的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9641" class="lv lw it mu b gy my mz l na nb">SQLALCHEMY_ECHO = True<br/>SQLALCHEMY_DATABASE_URI = 'mysql+mysqlconnector://root:<br/>     &lt;pw&gt;@mariadb:3306/winelist'<br/>SQLALCHEMY_TRACK_MODIFICATIONS = False</span></pre><p id="0c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mu b">config.py</code>还初始化数据库，棉花糖编组器，并为CORS和<code class="fe nc nd ne mu b">openid</code> (Okta)添加配置。</p><p id="b7a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的<code class="fe nc nd ne mu b">main.py</code>变得简单多了:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="edec" class="lv lw it mu b gy my mz l na nb">import config</span><span id="2704" class="lv lw it mu b gy nk mz l na nb"># Get the application instance<br/>connex_app = config.connex_app<br/>connex_app.add_api("swagger.yml")</span><span id="3466" class="lv lw it mu b gy nk mz l na nb">if __name__ == "__main__":<br/>    connex_app.run(debug=True)</span></pre><p id="9dde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所做的就是加载API定义文件，并启动服务器。请注意，这是<em class="nm">而不是</em>生产服务器，所以您可能希望在真实环境中使用Python和Nginx之间的WSGI实现。</p><p id="7925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是我们定义WinePairing数据和模式的模型。因为我们将这个服务添加到一个现有的数据库中，所以我们不需要利用数据库创建工具。实际上，我们无论如何都不应该在代码中这样做，因为这些是微服务。因此，没有一个服务应该负责创建数据库，最好将它留给外部实体。总之，这里是<code class="fe nc nd ne mu b">model.py</code>:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ebb6" class="lv lw it mu b gy my mz l na nb">from config import db, ma<br/>from marshmallow_sqlalchemy import ModelSchema</span><span id="685e" class="lv lw it mu b gy nk mz l na nb">class WinePairing(db.Model):<br/>    __tablename__ = 'wine_pairing'<br/>    id = db.Column(db.Integer, primary_key=True)<br/>    wine = db.Column(db.String(32),)<br/>    wine_description = db.Column(db.String(32))<br/>    cheese = db.Column(db.String(32))<br/>    cheese_description = db.Column(db.String(32))<br/>    pairing_notes = db.Column(db.String(32))</span><span id="1240" class="lv lw it mu b gy nk mz l na nb">class WinePairingSchema(ModelSchema):<br/>    class Meta:<br/>        model = WinePairing<br/>        sqla_session = db.session</span></pre><p id="98f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们从<code class="fe nc nd ne mu b">config.py</code>导入数据库和棉花糖。然后我们定义了两个类，一个作为数据对象，另一个作为模式。</p><p id="4bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们到达<code class="fe nc nd ne mu b">winePairing.py</code>,它现在已经填充了所有的数据库调用。它看起来是这样的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="86bd" class="lv lw it mu b gy my mz l na nb">import connexion<br/>from flask_oidc import OpenIDConnect<br/>from flask import (<br/>    make_response,<br/>    abort,<br/>    request<br/>)<br/>from config import (<br/>    db,<br/>    app<br/>)</span><span id="2686" class="lv lw it mu b gy nk mz l na nb">from models import (<br/>    WinePairing,<br/>    WinePairingSchema,<br/>)</span><span id="cb3c" class="lv lw it mu b gy nk mz l na nb">oidc = OpenIDConnect(app)</span><span id="0d7f" class="lv lw it mu b gy nk mz l na nb">def read_one(id):<br/>    winePairing = WinePairing.query \<br/>        .filter(WinePairing.id == id) \<br/>        .one_or_none()<br/>    if winePairing is not None:<br/>        winePairing_schema = WinePairingSchema()<br/>        return winePairing_schema.dump(winePairing)<br/>    else:<br/>        abort(404, 'WinePairing not found for Id: {id}'.format(id=id))</span><span id="62ab" class="lv lw it mu b gy nk mz l na nb">def read_all():<br/>    winePairing = WinePairing.query \<br/>        .order_by(WinePairing.id) \<br/>        .all()<br/>    winePairing_schema = WinePairingSchema(many=True)<br/>    return winePairing_schema.dump(winePairing)</span><span id="bad2" class="lv lw it mu b gy nk mz l na nb"><a class="ae ky" href="http://twitter.com/oidc" rel="noopener ugc nofollow" target="_blank">@oidc</a>.accept_token(True)<br/>def create():<br/>        schema = WinePairingSchema()<br/>        newWinePairing = schema.load(request.json, session=db.session)<br/>        db.session.add(newWinePairing)<br/>        db.session.commit()<br/>        return schema.dump(newWinePairing), 201</span><span id="f699" class="lv lw it mu b gy nk mz l na nb"><a class="ae ky" href="http://twitter.com/oidc" rel="noopener ugc nofollow" target="_blank">@oidc</a>.accept_token(True)<br/>def update(id):<br/>    updateWinePairing = WinePairing.query.filter(<br/>        WinePairing.id == id<br/>    ).one_or_none()<br/>    if updateWinePairing is None:<br/>        abort(<br/>            404,<br/>            "WinePairing not found for Id: {id}".format(id=id),<br/>        )<br/>    schema = WinePairingSchema()<br/>    update = schema.load(request.json, session=db.session)<br/>    update.id = updateWinePairing.id<br/>    db.session.merge(update)<br/>    db.session.commit()<br/>    data = schema.dump(updateWinePairing)<br/>    return data, 200</span><span id="cf8c" class="lv lw it mu b gy nk mz l na nb"><a class="ae ky" href="http://twitter.com/oidc" rel="noopener ugc nofollow" target="_blank">@oidc</a>.accept_token(True)<br/>def delete(id):<br/>    winePairing = WinePairing.query.filter(WinePairing.id == id).one_or_none()<br/>    if winePairing is not None:<br/>        db.session.delete(winePairing)<br/>        db.session.commit()<br/>        return make_response(<br/>            "WinePairing {id} deleted".format(id=id), 200<br/>        )<br/>    else:<br/>        abort(<br/>            404,<br/>            "WinePairing not found for Id: {id}".format(id=id),<br/>        )</span></pre><p id="c21e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，事情变得复杂多了。让我非常吃惊的一件事是端点方法不能接受一个以上的参数。因此，我没有为PUT和POST传递封送的请求体，而是传入request.json，幸运的是，<code class="fe nc nd ne mu b">schema.load</code>方法能够使用json。这与使用<code class="fe nc nd ne mu b">@oidc.accept_token</code>包装函数有关。如果任何一个端点需要额外的路径参数，我不知道该怎么办。</p><h2 id="3bed" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">将一切都转移到云上</h2><p id="916c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们可以将其容器化，然后添加到我们的云部署脚本中。只需要多一个文件，一个docker文件来告诉我们如何把这些放在一起。这很简单:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3723" class="lv lw it mu b gy my mz l na nb">FROM python:3.9.0-alpine3.12<br/>WORKDIR /project/app<br/>ADD . /project/app<br/>RUN pip install -r requirements.txt<br/>CMD ["python","main.py"]</span></pre><p id="4eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将调整config.py以从<code class="fe nc nd ne mu b">../config</code>获取配置文件，这样我就可以将它们挂载到<code class="fe nc nd ne mu b">/project</code>中，它是<code class="fe nc nd ne mu b">/project/app</code>的父目录。我将在本地对<code class="fe nc nd ne mu b">docker-compose.yml</code>做一点小小的补充:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7ca9" class="lv lw it mu b gy my mz l na nb">version: "3"<br/>services:<br/>  mariadb:<br/>    image: mariadb<br/>    restart: always<br/>    volumes:<br/>     - ./init:/docker-entrypoint-initdb.d<br/>    env_file:<br/>      - ../mariadb.env<br/>    ports:<br/>      - 3306:3306<br/>  api:<br/>    image: rlkamradt/winepairingapi<br/>    volumes:<br/>    - ../config:/project/config<br/>    ports:<br/>      - 5000:5000</span></pre><p id="aaa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，用<code class="fe nc nd ne mu b">docker build -t rlkamradt/winepairingapi .</code>构建映像，然后你可以用<code class="fe nc nd ne mu b">docker-compose up</code>启动它。浏览到<a class="ae ky" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank">http://localhost:5000</a>/API/pairing，应该会得到葡萄酒的列表。我从日志中注意到，出于某种原因，Swagger UI没有被加载，但我不会为此担心。我们也许不应该在生产环境中暴露Swagger。</p><p id="3818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在推送至DockerHub: <code class="fe nc nd ne mu b">docker push rlkamradt/winepairingapi</code>(当然使用自己的DockerHub用户名)我们应该准备好部署到云端了。</p><p id="99b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将用这个服务替换旧的read服务，因为它既可以读取也可以修改。这违背了我的愿望，我希望将它们分开，以便read可以与modify进行不同的伸缩，modify还可以使用消息队列将其与服务器分离，使其在高峰时间响应更快。但是现在我将追求简单，以后必要时可能会把事情复杂化。</p><p id="9512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这个<a class="ae ky" href="https://github.com/rkamradt/phpappprod/tree/v0.4" rel="noopener ugc nofollow" target="_blank">存储库</a>中找到我使用的部署脚本。我将简单地用新的<code class="fe nc nd ne mu b">pyrest</code>应用程序替换<code class="fe nc nd ne mu b">phprest</code>应用程序。我还将保留<code class="fe nc nd ne mu b">phprest.kamradtfamily.net</code>的DNS名称，这样我就不必与CloudFlare发生冲突了。这里是<code class="fe nc nd ne mu b">nginx.conf</code>的新章节:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="96ab" class="lv lw it mu b gy my mz l na nb">server {<br/>    access_log /dev/stdout;<br/>    listen 443 ssl;<br/>    server_name phprest.kamradtfamily.net;<br/>    ssl_certificate /etc/certs/kamradtfamily.net.pem;<br/>    ssl_certificate_key /etc/certs/kamradtfamily.net.key;<br/>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br/>    ssl_ciphers HIGH:!aNULL:!MD5;<br/>    location / {<br/>        proxy_pass <a class="ae ky" href="http://pyrest:5000" rel="noopener ugc nofollow" target="_blank">http://pyrest:5000</a>;<br/>}</span></pre><p id="5730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及docker-compose.yml中的新部分:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4215" class="lv lw it mu b gy my mz l na nb">pyrest:<br/>    image: rlkamradt/winepairingapi<br/>    volumes:<br/>    - ../config:/project/config<br/>    ports:<br/>      - 5000:5000</span></pre><p id="c767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以提交并将其推送到GitHub，这样我们就可以在我们的云虚拟机中启动它。</p><p id="4da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在云虚拟机上安装新的配置文件。打开一个ssh终端到虚拟机，创建一个名为<code class="fe nc nd ne mu b">config</code>的目录并更改到该目录，然后您可以<code class="fe nc nd ne mu b">vi</code><code class="fe nc nd ne mu b">client_secrets.json</code>和<code class="fe nc nd ne mu b">flask.cfg</code>，将笔记本电脑中的内容复制并粘贴到虚拟机。我们必须特别处理这些文件，因为它们包含秘密，所以它们不能成为我们GitHub库的一部分，这是我们通常将更改上传到VM的方式。</p><p id="21a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以<code class="fe nc nd ne mu b">cd</code>到云虚拟机上的<code class="fe nc nd ne mu b">~/phpappprod</code>目录，并使用<code class="fe nc nd ne mu b">git pull</code>获取最新配置。取下<code class="fe nc nd ne mu b">docker-compose.yml</code>，清理干净，重新拉图像，重启:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="40ef" class="lv lw it mu b gy my mz l na nb">sudo docker-compose down<br/>sudo docker-compose system prune --all --volumes<br/>sudo docker-compose pull<br/>sudo docker-compose up</span></pre><p id="de1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有使用<code class="fe nc nd ne mu b">-d</code>选项，因为我将假设有问题，并且我想查看日志。当然，是有的。但是问题出在配置文件上。我忘了使用运行在云虚拟机上的MariaDB的密码。我对云中的版本使用了与笔记本电脑上运行的实例不同的密码。修复它，并把它带回来给我更多的错误！</p><p id="cc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题中的错误是由于依赖项中的版本不匹配。pip install不更新<code class="fe nc nd ne mu b">requirements.txt</code>的事实似乎是一个真正的缺点。我依靠<code class="fe nc nd ne mu b">requirements.txt</code>来使docker映像工作，任何想在其他主机上运行代码的人都将依靠它。我开始更新一些依赖关系，看看我是否能让事情一起工作。</p><p id="eec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一些修改后，我可以打开它并运行所有的端点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/a7fdcd0263de0ef98ac53ada24d5e795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Xx5EqFvVUIW723R1eUI8A.png"/></div></div></figure><p id="00dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在我们的API运行在云中，对所有人都可用，但受授权头保护(除了reads)。</p><p id="23cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这么说我可能会树敌，但是用Python制作这个API是我这么长时间以来最糟糕的经历。我花了很多时间让所有的部分正常工作。我使用过很多语言，我不会向任何人推荐Python作为通用编程语言。我可以看到它作为一种特殊用途的脚本语言的用途，但是试图把任何东西放在一起，即使是适度复杂的，似乎也是一个挑战。这种语言散发着黑客和无指导的“改进”的味道，以保持其流行性。这可能是你最后一次看到我用Python写作，除了在我的Jupyter笔记本的安全壳里。</p><p id="2c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你听我说完，我希望我诚实的观点不会得罪太多人。这是一篇相当长的文章，但是我们完成了很多事情，从认证到从数据库读取，再到在云中部署。我的下一步计划是制作一个React前端，它可以读取这些内容并给它一个漂亮的外观。在那之前，永远不要停止学习(不管有时看起来多么令人沮丧)。</p><p id="f62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引用的存储库:</p><div class="no np gp gr nq nr"><a href="https://github.com/rkamradt/flaskapi/tree/v0.1" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">rkamradt/flaskapi</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">葡萄酒和奶酪配对应用GitHub的一个示例Python/Flask API是超过5000万开发人员的家园，他们工作…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://github.com/rkamradt/phpappprod/tree/v0.4" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">rkamradt/PHP pprod</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">phpapp GitHub生产版的部署脚本是超过5000万开发者的家园，他们一起工作…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div><p id="a880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考文章:</p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/modern-php-df3d3bf343f8"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">现代PHP</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">使用Upstart上最需要的项目语言之一开始你的自由职业生涯。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/modern-php-part-2-4973f48a90c0"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">现代PHP(第2部分)</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">部署到web</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="oi l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/modern-php-part-3-1f5b78b3371d"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">现代PHP(第3部分)</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">所有web应用程序的单点登录。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="oj l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/microservices-with-php-and-lumen-d9af0b915a71"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">使用PHP和Lumen的微服务</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">与PHP的过去决裂，而不破坏现有的应用程序</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="ok l oc od oe oa of ks nr"/></div></div></a></div></div></div>    
</body>
</html>