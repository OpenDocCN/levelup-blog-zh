<html>
<head>
<title>5 Ways to Improve the Performance of C# Code for Free</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5种免费提高C#代码性能的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da?source=collection_archive---------0-----------------------#2021-05-07">https://levelup.gitconnected.com/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da?source=collection_archive---------0-----------------------#2021-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b48e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">慢速代码是可选的。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef6de3f6ef25f230ca636ff34ea1a0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fnt7VBCh-FDvBkej"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@laurentmedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">转到</a>上<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">去飞溅</a></figcaption></figure><p id="3616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件开发是关于寻找折衷的:</p><ul class=""><li id="f520" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">CAP定理——开发人员只需要从软件系统的3个保证中选择2个。</li><li id="f3b2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">关系数据库模式的规范化与非规范化——开发人员在数据更新的便利性和数据检索时间之间找到了平衡。</li><li id="64a0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">开发速度与高质量编码——开发人员努力追求高质量，这是一项耗时的工作，而业务需要尽快准备好特性。</li></ul><p id="1340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高性能的C#代码也不是免费的。开发人员可以牺牲代码的可维护性或安全性来使代码运行得更快。但是这只适用于应用了所有性能模式和最佳实践，但是性能需要进一步提高的场景。</p><p id="b421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多方法可以帮助开发人员在不牺牲任何东西的情况下显著提高应用程序的性能。</p><p id="e582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔔<a class="ae ky" href="https://esashamathews.medium.com/subscribe" rel="noopener"> <strong class="lb iu">现在就订阅</strong> </a> <strong class="lb iu">，所以大家不要错过我接下来的文章。</strong></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0967" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">具体化LINQ查询一次</h1><p id="19e2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当使用<code class="fe nn no np nq b">IEnumerable</code>或<code class="fe nn no np nq b">IQueryable</code>接口编写LINQ查询时，开发人员可以立即物化(调用<code class="fe nn no np nq b">ToList</code>、<code class="fe nn no np nq b">ToArray</code>或类似方法)或不物化查询。</p><p id="dfa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">物化的缺乏允许开发人员懒散地使用集合。但是有时有必要对同一个集合进行多次迭代。如果查询不是通过调用<code class="fe nn no np nq b">ToList</code>方法实现的，那么多次迭代集合将会影响应用程序的性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe nn no np nq b">Where</code>查询没有被具体化。调用<code class="fe nn no np nq b">Where</code>方法只是返回一个实现<code class="fe nn no np nq b">IEnumerable</code>接口的对象。只有在<code class="fe nn no np nq b">foreach</code>循环中迭代集合时，才会调用<code class="fe nn no np nq b">GetEnumerator</code>和<code class="fe nn no np nq b">MoveNext</code>方法。</p><p id="b55d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个定义了物化查询的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是性能结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/d452a487b0aff4c8fed3fbb40ef4fc2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vznX62DZP0pi5dANBu4uMQ.png"/></div></div></figure><p id="2085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，第二个测试只通过调用<code class="fe nn no np nq b">ToList</code>方法实现了一次查询，运行时间比第一个测试少三倍。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3890" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">避免隐式线性搜索</h1><p id="ebe0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">线性搜索是最简单的搜索算法之一，它逐个遍历集合中的所有元素，直到找到指定的元素。</p><p id="872d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然开发人员通常不会显式实现线性搜索，但它仍然经常导致性能下降。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="755f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，<code class="fe nn no np nq b">Any</code>方法使用线性搜索算法来检查指定的用户ID是否在集合中。</p><p id="122f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员不一定需要知道他们使用的每一个的实现。重要的是要知道基本的:在。NET，<code class="fe nn no np nq b">List&lt;T&gt;</code>集合基于数组。而在一个未排序的数组中求一个值的时候，它的复杂度是O(n)。不管用哪种LINQ方法来寻找数组<code class="fe nn no np nq b">Any, Contains or Where,</code>中的值，复杂度都是一样的。</p><p id="137c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决我们特殊问题的方法是使用一种适合特定任务的数据结构。</p><div class="nu nv gp gr nw nx"><a href="https://www.bigocheatsheet.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">了解你的复杂性！</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">你好。这个网页涵盖了计算机科学中常用算法的空间和时间复杂性。当…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">www.bigocheatsheet.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><p id="5f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们有总是唯一的用户标识符。它允许我们将集合转换为<code class="fe nn no np nq b">HashSet&lt;T&gt;.</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/3acd5a98189c8f5d728b6c22da213f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihJ4W44LlT0uNw0LbDtaKQ.png"/></div></div></figure><p id="f9f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？<code class="fe nn no np nq b">HashSetTest</code>比<code class="fe nn no np nq b">LinearSearchTest.</code>慢5倍，这是因为我们也在测量构建<code class="fe nn no np nq b">HashSet&lt;T&gt;</code>系列的时间，对于大型布景来说，这是一项耗时的操作。</p><p id="75dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当开发人员计划频繁调用<code class="fe nn no np nq b">Contains</code>方法时，他们才会从转换到<code class="fe nn no np nq b">HashSet</code>中受益。</p><p id="883b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将集合创建从性能测试中移出，并且只测量找到元素的时间，那么结果会有很大的不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/11c2cc57cdbc2b5f3987f34fe8f1947a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtnoUbnbkKWazhTxz0Raeg.png"/></div></div></figure><p id="e08d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与在<code class="fe nn no np nq b">List&lt;T&gt;</code>集合中查找值相比，在<code class="fe nn no np nq b">HashSet&lt;T&gt;</code>中查找值几乎不花时间。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8e49" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">循环的并行化</h1><p id="d5eb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">通常有必要使用一个<code class="fe nn no np nq b">foreach</code>循环遍历一个集合，并为每个条目做一些逻辑处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，迭代是在同一个线程中一个接一个地执行的，所以总的执行时间将随着集合大小线性增长。</p><p id="95f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过开始使用框架提供给开发人员的<code class="fe nn no np nq b">foreach</code>循环的并行版本，可以提高性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">Parallel.Foreach</code>可以像常规的<code class="fe nn no np nq b">foreach</code>循环一样用在任何实现了<code class="fe nn no np nq b">IEnumerable&lt;T&gt;</code>接口的集合上。一个<code class="fe nn no np nq b">Parallel.Foreach</code>的实现将代替开发者做很多工作:将集合分割成块，在单独的线程中调度和执行块。</p><p id="81b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是并行版本的<code class="fe nn no np nq b">foreach</code>循环与普通版本的性能比较:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2836359c7735e154e2235783e55eaa2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*kNRh9iMSvd6wDsma123zog.png"/></div></figure><p id="be23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果集合很小，并且单次迭代的执行时间很快，将<code class="fe nn no np nq b">foreach</code>切换到<code class="fe nn no np nq b">Parallel.Foreach</code>甚至可能会使性能更差，尤其是当开发人员由于访问共享资源而使用线程同步时。</p><p id="d03c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由<code class="fe nn no np nq b">Parallel</code>类提供的功能对于<strong class="lb iu">长期运行的迭代来说是一个极好的选择，这些迭代相互独立</strong>并且不需要使用同步原语，比如并发集合。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2ca4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结构，而不是类</h1><p id="43ce" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">开发人员可能经常需要分配一个数组或<code class="fe nn no np nq b">List&lt;T&gt;</code>来在内存中存储数万个对象。这项任务可以使用类或结构来解决。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe nn no np nq b">ListOfObjectTest</code>和<code class="fe nn no np nq b">ListOfStructsTest</code>之间的唯一区别是第一个测试创建类的实例，而第二个测试创建结构的实例。<code class="fe nn no np nq b">PointClass</code>的代码与<code class="fe nn no np nq b">PointStruct.</code>的代码相同</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/93f521157b027c420d0ab6b5b30b3d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xv_GyoqJ0y3cq0Tr8q102Q.png"/></div></div></figure><p id="90cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用结构的代码比使用类的代码运行速度快15倍。有这么大的时间差，因为在类的情况下，CLR必须分配一百万个对象给托管堆，并将它们的引用存储回<code class="fe nn no np nq b">List&lt;T&gt;</code>集合。在结构的情况下，将有<strong class="lb iu">分配到托管堆</strong>中的唯一对象，该托管堆是<code class="fe nn no np nq b">List&lt;T&gt;</code>集合的实例。一百万个结构将被嵌入到这个集合实例中。更多信息请点击此处:</p><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/why-is-list-struct-is-15-times-faster-to-allocate-than-list-class-17f5f79889ae"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">为什么C#中List <struct>的分配速度比List <class>快15倍</class></struct></h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">在上一篇文章《免费提高C#代码性能的5种方法》中，在其中一个例子中，我测量了…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="oq l oi oj ok og ol ks nx"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5280" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">指定集合的容量</h1><p id="4d46" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面我们来看看两种几乎相同的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法完成相同的任务——使用<code class="fe nn no np nq b">foreach</code>循环用整数填充集合。唯一的区别是在<code class="fe nn no np nq b">FixedCapacityTest</code>方法中，构造函数被初始化为某个数字。这个简单的技巧使得<code class="fe nn no np nq b">FixedCapacityTest</code>的运行速度是<code class="fe nn no np nq b">NonFixedCapacityTest</code>的两倍</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/feb5cd1bcb2a6704720eabbb3126e180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3DFW_3EgIpzsdjeJQfXXQ.png"/></div></div></figure><p id="b51d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能提高了一倍，因为<code class="fe nn no np nq b">List&lt;T&gt;</code>的实现方式是将元素存储在一个数组中，这是一种固定大小的数据结构。当开发人员实例化<code class="fe nn no np nq b">List&lt;T&gt;</code>而没有指定其容量时，会分配一个默认的容量数组。当数组已满时，会分配一个新的更大的数组，并将旧数组中的值复制到新数组中。</p><p id="c510" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提前指定容量消除了旧阵列的分配、复制和垃圾收集的开销。指定集合的容量应该是开发人员的默认选择，如果他们预先知道有多少项将被添加到集合中。</p><p id="a0b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容量设置不仅适用于列表集合，也适用于其他集合，如<code class="fe nn no np nq b">Dictionary&lt;TKey, TValue&gt;, HashSet&lt;T&gt;</code>等。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d9d5" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">最后的想法</h1><p id="e606" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在应用任何建议之前，比如从类切换到结构或者从<code class="fe nn no np nq b">foreach</code>切换到<code class="fe nn no np nq b">Parallel.ForEach,</code>之前，运行profiler以确保问题确实存在。</p><p id="48c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">始终仔细分析您的具体情况，并做出对您最有利的最合适的选择。</p><p id="db36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以考虑订阅我的电报频道<a class="ae ky" href="https://t.me/sd_daily" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">软件开发日报</strong> </a>从我这里获取更多内容。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="e298" class="os mr it bd ms ot ou dn mw ov ow dp na li ox oy nc lm oz pa ne lq pb pc ng pd bi translated">我的其他文章:</h2><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/netarchtest-enforce-architecture-and-design-rules-in-your-application-e6c6c9f5c97e"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">NetArchTest —在您的应用程序中实施架构和设计规则</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">通过编写单元测试。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="pe l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">如何专业地对Bug修复进行代码审查</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">审查bug修复时要问的几个重要问题。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="pf l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">在C#中实现单例设计反模式的5种方法</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">各有利弊</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="pg l oi oj ok og ol ks nx"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="237b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">分级编码</h1><p id="da8d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">感谢您成为我们社区的一员！<a class="ae ky" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅我们的YouTube频道</a>或者加入<a class="ae ky" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Skilled.dev编码面试课程</strong> </a>。</p></div></div>    
</body>
</html>