<html>
<head>
<title>Demystifying Clojure: Enough to Get Started on Most Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Clojure的神秘面纱:足以开始大多数项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/demystifying-clojure-enough-to-get-started-on-most-projects-a45f63890622?source=collection_archive---------4-----------------------#2022-08-21">https://levelup.gitconnected.com/demystifying-clojure-enough-to-get-started-on-most-projects-a45f63890622?source=collection_archive---------4-----------------------#2022-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9f8c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从零到有(当然不是英雄)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/472efe6d9ae91137e7b73f6b428fec5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r0SVr96RKI7OPFMO"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@chatelp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pierre chtel-Innocenti</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="ae44" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">简介</strong></h2><p id="239e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">Clojure可能令人望而生畏——特别是对于以前没有使用Lisp的经验，并且只使用过Java等常见语言的人来说——顺便说一下我自己。</p><p id="adcb" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">话虽如此，Clojure并不是火箭科学。被赋予在Clojure中维护几个服务的责任(我注意到公司中的大多数开发人员都试图避免这一点)的确是一个机会——那么，我们为什么不对此进行更深入的探讨呢？</p><p id="caef" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在本文中，我们将了解一些事情:</p><ul class=""><li id="6f61" class="mq mr iq lu b lv ml ly mm lf ms lj mt ln mu mk mv mw mx my bi translated">设置并运行项目</li><li id="e245" class="mq mr iq lu b lv mz ly na lf nb lj nc ln nd mk mv mw mx my bi translated">依赖注入</li><li id="abae" class="mq mr iq lu b lv mz ly na lf nb lj nc ln nd mk mv mw mx my bi translated">在项目中导航</li><li id="69f7" class="mq mr iq lu b lv mz ly na lf nb lj nc ln nd mk mv mw mx my bi translated">与Java的互操作性</li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="275f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">语境</strong></h2><p id="bd90" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">为了做好准备，让我们假设我们在Clojure中有一个服务，一个相当老的服务——需要一些更新；然而，为了简单起见，也许限制它的范围是好的。因此，假设我们有以下库:</p><ul class=""><li id="06c2" class="mq mr iq lu b lv ml ly mm lf ms lj mt ln mu mk mv mw mx my bi translated">Stuart Sierra的组件(依赖注入)</li><li id="1cb2" class="mq mr iq lu b lv mz ly na lf nb lj nc ln nd mk mv mw mx my bi translated">环形码头适配器(HTTP服务器)</li><li id="fa69" class="mq mr iq lu b lv mz ly na lf nb lj nc ln nd mk mv mw mx my bi translated">胭脂红(红色连接)</li></ul><p id="d27d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">虽然有HTTP Kit和Jedis这样的替代工具来分别替代Jetty Adapter和Carmine这样的依赖工具，但是让我们考虑一下使用遗留服务的前提，并坚持使用它。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="1e5b" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">带Leiningen的启动和运行</strong></h2><p id="23a3" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">与Maven非常相似，Leiningen是一个构建自动化和依赖性管理工具，已经成为事实上的标准。事不宜迟，让我们在这个项目上试用一下:<a class="ae kv" href="https://github.com/emyasa/medium-articles/tree/master/clojure-introduction" rel="noopener ugc nofollow" target="_blank"> clojure-introduction </a>。</p><p id="d6e9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">假设有一个Redis在端口6379上本地运行，让我们在项目的根目录下运行Leiningen run命令:<code class="fe nl nm nn no b">lein run</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/fa49396ee9e03b7140ff6e91b6dd446b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYoaSYIE0UBNcWDIXy3w9Q.png"/></div></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="9095" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">依赖注入w/ Stuart Sierra的组件</strong></h2><p id="b334" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">虽然Clojure中没有对象，但是有了Stuart Sierra的组件<a class="ae kv" href="https://github.com/stuartsierra/component" rel="noopener ugc nofollow" target="_blank"><em class="nq">——感觉就像我们在做通常的面向对象和组件的自动连接。这里有一个例子，让我们看看我们的<code class="fe nl nm nn no b">system.clj</code>:</em></a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3f88" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如上所示，我们需要一个web服务器和Redis组件——然后执行<em class="nq">关联依赖注入</em>(这将贯穿组件的生命周期，我们将在后面看到)。</p><p id="4c2f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">或者，基于偏好，我们也可以这样编码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="4484" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">在项目中导航</strong></h2><p id="47a1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">熟悉了<em class="nq">组件</em>库之后，我们可以开始导航，并选择查看特定的组件以进行更深入的挖掘——让我们检查一下我们的Redis组件(<code class="fe nl nm nn no b">redis.clj</code>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="132e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">从顶部开始(需要)，我们包括了以下库:</p><ul class=""><li id="1f61" class="mq mr iq lu b lv ml ly mm lf ms lj mt ln mu mk mv mw mx my bi translated">记录</li><li id="3825" class="mq mr iq lu b lv mz ly na lf nb lj nc ln nd mk mv mw mx my bi translated">组件(依赖注入)</li><li id="30af" class="mq mr iq lu b lv mz ly na lf nb lj nc ln nd mk mv mw mx my bi translated">胭脂红(红色连接)</li></ul><p id="5603" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">然后我们定义一个名为<code class="fe nl nm nn no b">Redis</code>的defrecord，用<code class="fe nl nm nn no b">host</code>、<code class="fe nl nm nn no b">port</code>和<code class="fe nl nm nn no b">enabled</code>作为参数。</p><p id="9486" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">接下来，我们定义了一个方法来初始化我们的Redis defrecord——基于config参数。</p><p id="f263" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">接下来，我们定义了一个rediscomponentdefrecord——其中我们利用了组件的开始和停止生命周期。</p><p id="27da" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">最后，我们定义了一个名为<em class="nq"> make </em>的方法来初始化redis composition。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="ca48" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">与Java的互操作性</strong></h2><p id="026e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">值得一提的是，Clojure支持互操作性w/ Java类。让我们来看看我们的<code class="fe nl nm nn no b">webserver.clj</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c69b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">让我们不要讨论这个组件的每一个部分——相反，让我们集中讨论一些具体的部分，展示我们如何利用Java库。</p><p id="9f09" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">看最上面，我们可以看到Java导入。此外，在我们名为jetty-conf的私有函数中，注意我们在服务器参数上使用了<a class="ae kv" href="https://clojure.org/reference/java_interop#typehints" rel="noopener ugc nofollow" target="_blank"> <em class="nq">类型提示</em> </a>。最后，<a class="ae kv" href="https://clojure.org/reference/java_interop#_the_dot_special_form" rel="noopener ugc nofollow" target="_blank"> <em class="nq">点特殊形式</em> </a>使我们能够访问Java的成员方法。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="99c5" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">结论</strong></h2><p id="3a23" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">事实上，我们在本文中所涉及的只是冰山一角；然而，有了这几样东西——浏览一个项目并开始为之做贡献就足够了。</p><p id="9e79" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">此外，虽然这个项目的代码显然是用于演示目的，但其结构和依赖关系与Clojure中的一些遗留项目非常相似。</p><p id="0b6d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">像往常一样，完整的源代码总是可以在<a class="ae kv" href="https://github.com/emyasa/medium-articles/tree/master/clojure-introduction" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>