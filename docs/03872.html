<html>
<head>
<title>Advanced C++ Templates Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级C++模板教程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-c-templates-tutorial-7b54259b2671?source=collection_archive---------5-----------------------#2020-05-31">https://levelup.gitconnected.com/advanced-c-templates-tutorial-7b54259b2671?source=collection_archive---------5-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9014" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">高级C++模板概念“SFINAE”的解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/54373cce917033b15702394b678fc41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*2HxYAX6y_yZymWoI-VdTow.jpeg"/></div></figure><p id="e369" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">众所周知，C++包含了一个强大的特性，叫做模板。使用模板，您可以编写可重复用于不同类型的函数和类。事情很简单，直到您需要为特定类型或特定约束使用模板函数的不同实现。</p><p id="d51e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">假设我们定义了一个叫做<em class="lm"> Print </em>的普通效用函数模板，如下所示，</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="0e10" class="ls lt it lo b gy lu lv l lw lx">#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;chrono&gt;<br/>#include &lt;ctime&gt;</span><span id="90ed" class="ls lt it lo b gy ly lv l lw lx">template&lt;class T&gt;<br/>void Print(const T&amp; arg) {<br/>auto time_point = std::chrono::system_clock::now();<br/>std::time_t ttp = std::chrono::system_clock::to_time_t(time_point);</span><span id="1743" class="ls lt it lo b gy ly lv l lw lx">std::cout &lt;&lt; "["&lt;&lt; std::ctime(&amp;ttp) &lt;&lt;"] " &lt;&lt; arg &lt;&lt; std::endl;<br/>}</span></pre><p id="56cd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lm"> Print </em>函数接受一个模板参数，并将带有时间戳的值打印到控制台。</p><p id="fa25" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">例如，如果使用字符串和整数类型调用，输出如下所示。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="3425" class="ls lt it lo b gy lu lv l lw lx">std::string str = "Hello World!";<br/>int i = 1;</span><span id="93f2" class="ls lt it lo b gy ly lv l lw lx">Print(str);<br/>Print(i);</span><span id="3d26" class="ls lt it lo b gy ly lv l lw lx">## console output ##<br/>[Sun May 31 13:03:35 2020 ] Hello World!<br/>[Sun May 31 13:03:35 2020 ] 1</span></pre><p id="f68f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，您可以将<em class="lm"> Print </em>函数用于您的自定义类类型，只要它们支持<code class="fe lz ma mb lo b">operator&lt;&lt;</code>。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="79e4" class="ls lt it lo b gy lu lv l lw lx">class MyClass {<br/> public:<br/>  MyClass() : m_i(0) {};<br/> <br/>  friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp;out, const MyClass &amp;m);<br/> private:<br/>    int m_i;<br/>};</span><span id="2abe" class="ls lt it lo b gy ly lv l lw lx">std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const <!-- -->MyClass<!-- --> &amp;m) { <br/>    return os &lt;&lt; m.m_i;<br/>}</span></pre><p id="0753" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">(这里，它为<em class="lm"> MyClass </em>类型重载<code class="fe lz ma mb lo b">operator&lt;&lt;</code>，并将其声明为MyClass的友元，以便可以从重载的<code class="fe lz ma mb lo b">operator&lt;&lt;</code>访问私有成员<em class="lm"> m_i </em>)。输出如下所示。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="1ac5" class="ls lt it lo b gy lu lv l lw lx">MyClass my_class;<br/>Print(my_class);</span><span id="aad9" class="ls lt it lo b gy ly lv l lw lx">## console output ##<br/>[Sun May 31 13:03:35 2020 ] 0</span></pre><p id="551a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">到目前为止一切顺利。假设现在您只想将MyClass的值输出到日志文件或其他输出通道。所以你在MyClass中实现了<em class="lm"> LogMessage </em>函数，如下所示。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="4280" class="ls lt it lo b gy lu lv l lw lx">class MyClass {<br/> public:<br/>  MyClass() : m_i(0) {};<br/> <br/>  void <strong class="lo iu">LogMessage</strong>() const {<br/>  // Output to file<br/>  }</span><span id="a3e4" class="ls lt it lo b gy ly lv l lw lx">friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp;out, const MyClass &amp;m);<br/>private:<br/>    int m_i;<br/>};</span></pre><p id="bac9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，您需要修改<em class="lm"> Print </em>模板函数，以便它对<em class="lm"> MyClass </em>类型使用<em class="lm"> LogMessage </em>函数，同时对其他类型保持使用原来的实现。下面描述了新的要求。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="8147" class="ls lt it lo b gy lu lv l lw lx">std::string str = "Hello World!";<br/>int i = 0;<br/>MyClass my_class;</span><span id="566e" class="ls lt it lo b gy ly lv l lw lx">Print(str) --&gt; Use the original Print implementation. <br/>Print(i) --&gt; Use the original Print implementation.<br/>Print(my_class) --&gt; Use MyClass::LogMessage() function.</span></pre><p id="3fe7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">模板功能<em class="lm"> Print </em>需要的两个实现是</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="a322" class="ls lt it lo b gy lu lv l lw lx">template&lt;class T&gt;<br/>void Print(const T&amp; arg) {<br/>auto time_point = std::chrono::system_clock::now();<br/>std::time_t ttp = std::chrono::system_clock::to_time_t(time_point);</span><span id="f997" class="ls lt it lo b gy ly lv l lw lx">std::cout &lt;&lt; "["&lt;&lt; std::ctime(&amp;ttp) &lt;&lt;"] " &lt;&lt; arg &lt;&lt; std::endl;<br/>}</span></pre><p id="db8f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">和</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="e618" class="ls lt it lo b gy lu lv l lw lx">template&lt;class T&gt;<br/>void Print(const T&amp; arg) {<br/>  arg.LogMessage();<br/>}</span></pre><p id="a58a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当然，如果只是简单的写两个，编译器会给出一个错误，说模板函数<em class="lm"> Print </em>定义了两次。此外，即使编译器没有给出错误，编译器也无法判断为哪种类型选择哪个<em class="lm"> Print </em>函数。</p><p id="7582" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里需要注意的一点是，即使没有调用<em class="lm"> Print </em>函数，编译器也会给出错误，所以即使是模板函数<em class="lm"> Print </em>也没有用具体类型实例化。这种行为与编译器完成的“两阶段查找”有关。</p><p id="ad3a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">编译模板时，编译器分两个阶段完成。在第一阶段，它解析模板代码，然后检查是否有语法错误，并尝试查找变量名和不依赖于模板参数的函数名。</p><p id="1719" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在第二阶段，它用给定的具体类型实例化模板，然后再次检查代码对于给定的类型是否有效。</p><p id="609d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">回到我们关于模板函数<em class="lm"> Print </em>的问题，我们需要一些机制来让编译器根据给定的具体类型选择<em class="lm"> Print </em>的具体实现，而不违反编译器检查的规则。</p><p id="b62f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">至于模板类，部分模板专门化可用于根据特定类型或约束在不同的类模板实现之间进行选择。然而，在函数模板的情况下，不允许部分模板专门化。因此，我们必须使用另一种方式来实现预期的行为。</p><p id="00b2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好消息是，通过一些利用编译器SFINAE⁴原理的技术，我们可以解决这个问题。SFINAE原理与上述两阶段查找编译的第二阶段相关。您可以参考本文底部给出的链接了解详细信息，但总的来说，当编译器实例化具有具体类型的模板时，如果结果代码无效，它会简单地忽略结果而不给出任何错误，如果有任何更好的匹配，则继续尝试其他候选模板。</p><p id="60bd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们看看使用SFINAE原理的解决方案。第一个简单的解决方案是将<em class="lm"> Print </em>函数修改如下，</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="cbce" class="ls lt it lo b gy lu lv l lw lx">template &lt;class T&gt;<br/>typename std::enable_if&lt;!std::is_same&lt;T, MyClass&gt;::value&gt;::type<br/>Print(const T&amp; arg) {<br/>  auto time_point = std::chrono::system_clock::now();<br/>  std::time_t ttp =  std::chrono::system_clock::to_time_t(time_point);</span><span id="f2fa" class="ls lt it lo b gy ly lv l lw lx">  std::cout &lt;&lt; "["&lt;&lt; std::ctime(&amp;ttp) &lt;&lt;"] " &lt;&lt; arg &lt;&lt; std::endl;<br/>}</span><span id="9c48" class="ls lt it lo b gy ly lv l lw lx">template &lt;class T&gt;<br/>typename std::enable_if&lt;std::is_same&lt;T, MyClass&gt;::value&gt;::type<br/>Print(const T&amp; arg) {<br/>  arg.LogMessage();<br/>}</span></pre><p id="92bb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们一个一个来看，</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="4fe7" class="ls lt it lo b gy lu lv l lw lx">typename std::enable_if&lt;!std::is_same&lt;T, MyClass&gt;::value&gt;::type</span></pre><p id="b171" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上面一整行是为<em class="lm"> Print </em>函数声明指定一个返回类型。<em class="lm"> std::is_same </em> ⁵检查两个类型是否相同，如果相同，<em class="lm"> std::is_same::value </em>设置为<em class="lm"> true </em>。如果不同，<em class="lm"> std::is_same::value </em>设置为<em class="lm"> false </em>。</p><p id="88c9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">至于<em class="lm"> std::enable_if </em>，如果<em class="lm"> true </em>传递给<em class="lm"> std::enable_if </em>，那么它将一个类型(如果第二个模板参数中没有指定，则默认为<em class="lm"> void </em>)生成<em class="lm"> std::enable_if::type </em>。如果<em class="lm">假</em>通过，<em class="lm"> std::enable_if::type </em>将<strong class="ks iu">而非</strong> <strong class="ks iu">定义为</strong>。在上面<em class="lm"> Print </em>函数的声明中，根据SFINAE原理，如果<em class="lm"> std::enable_if::type </em>没有定义，就意味着代码无效，因此模板实例化将被忽略。</p><p id="2804" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lm">开头的typename </em>关键字只是告诉编译器<em class="lm"> std::enable_if::type </em>是类型，而不是变量(从C++14开始，它增加了一个别名，这样更容易写成<em class="lm"> std::enable_if_t⁶ </em>)。</p><p id="5fbf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第二个打印函数声明除了！在<em class="lm"> std::is_same </em>之前。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="c1aa" class="ls lt it lo b gy lu lv l lw lx">typename std::enable_if&lt;std::is_same&lt;T, MyClass&gt;::value&gt;::type</span></pre><p id="9085" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">即使差别很小，由于它们声明中的语法不同，编译器也不会抱怨模板<em class="lm"> Print </em>函数被定义了两次。</p><p id="232b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用这种方法，如果首先将<em class="lm"> MyClass </em>作为模板参数传递，编译器会尝试用<em class="lm"> MyClass </em>实例化第一个<em class="lm"> Print </em>模板函数实现。由于<em class="lm"> std::is_same &lt; T，my class&gt;:value</em>将<em class="lm"> true </em>，<em class="lm">STD::enable _ if&lt;</em><strong class="ks iu"><em class="lm">！</em></strong><em class="lm">STD::is _ same&lt;T，my class&gt;:::value&gt;:</em>类型<strong class="ks iu">将不会被定义</strong>(注意“！”在表达式前面)，所以第一个<em class="lm">打印</em>功能实现将被忽略。</p><p id="54c9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，编译器尝试用<em class="lm"> MyClass实例化第二个<em class="lm"> Print </em>函数实现。</em>由于<em class="lm">STD::enable _ if&lt;STD::is _ same&lt;T，my class&gt;:::value&gt;:::type</em><strong class="ks iu">将被定义为<em class="lm"> void type </em> </strong>，因此实例化成功完成。因此，第二个<em class="lm"> Print </em>函数实现被选择用于模板参数MyClass类型。</p><p id="0343" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一方面，对于其他类型，适用相反的逻辑，选择第一个<em class="lm">打印</em>功能实现。实例化结果描述如下。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="6052" class="ls lt it lo b gy lu lv l lw lx">Print(my_class) instantiates to</span><span id="74e2" class="ls lt it lo b gy ly lv l lw lx">void Print(const MyClass&amp; arg) {<br/>  arg.LogMessage();<br/>}</span><span id="9e09" class="ls lt it lo b gy ly lv l lw lx">Print(i) instantiates to</span><span id="6268" class="ls lt it lo b gy ly lv l lw lx">void Print(const int&amp; arg) {<br/>  auto time_point = std::chrono::system_clock::now();<br/>  std::time_t ttp =  std::chrono::system_clock::to_time_t(time_point);</span><span id="38ff" class="ls lt it lo b gy ly lv l lw lx">std::cout &lt;&lt; "["&lt;&lt; std::ctime(&amp;ttp) &lt;&lt;"] " &lt;&lt; arg &lt;&lt; std::endl;<br/>}</span></pre><p id="3fd5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个天真的解决方案解决了确切的问题。然而，假设您想要将<em class="lm"> LogMessage </em>函数添加到其他自定义类中。突然，第一个解决方案变得没有吸引力，因为您必须用上面的技术为所有其他实现<em class="lm"> LogMessage </em>函数的定制类重复<em class="lm"> Print </em>函数。</p><p id="6986" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">更好的方法可能是根据给定的模板参数类型是否有<em class="lm"> LogMessage() </em>成员函数来选择不同的<em class="lm"> Print </em>函数实现。第二个解决方案如下</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="7edd" class="ls lt it lo b gy lu lv l lw lx">template &lt;class, class = void&gt;<br/>struct has_log_message : std::false_type { };<br/> <br/>template &lt;class T&gt;<br/>struct has_log_message&lt;T, decltype(std::declval&lt;T&amp;&gt;().LogMessage())&gt; : std::true_type { };</span><span id="af88" class="ls lt it lo b gy ly lv l lw lx">template &lt;class T&gt;<br/>typename std::enable_if&lt;has_log_message&lt;T&gt;::value&gt;::type<br/>Print(const T&amp; arg) {<br/>  arg.LogMessage();<br/>}</span><span id="7d50" class="ls lt it lo b gy ly lv l lw lx">template &lt;class T&gt;<br/>typename std::enable_if&lt;!has_log_message&lt;T&gt;::value&gt;::type<br/>Print(const T&amp; arg) {<br/>  auto time_point = std::chrono::system_clock::now();<br/>  std::time_t ttp = std::chrono::system_clock::to_time_t(time_point);std::cout &lt;&lt; "["&lt;&lt; std::ctime(&amp;ttp) &lt;&lt;"] " &lt;&lt; arg &lt;&lt; std::endl;<br/>}</span></pre><p id="6f42" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第二种解决方案在逻辑上可以分为两个部分。第一块在下面，</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="8204" class="ls lt it lo b gy lu lv l lw lx">template &lt;class, class = void&gt;<br/>struct has_log_message : std::false_type { };<br/> <br/>template &lt;class T&gt;<br/>struct has_log_message&lt;T, decltype(std::declval&lt;T&gt;().LogMessage())&gt; : std::true_type { };</span></pre><p id="a004" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里，我们定义了一个结构模板<em class="lm"> has_log_message </em>。它需要两个模板参数。第二个模板参数有一个默认类型<em class="lm"> void </em>。它还指定了部分模板专门化</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="eb41" class="ls lt it lo b gy lu lv l lw lx">decltype(std::declval&lt;T&gt;().LogMessage())</span></pre><p id="4ea5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为第二个模板参数。<em class="lm"> std::declval⁷ </em>允许我们访问类型<em class="lm"> T </em>的成员，就好像我们从<em class="lm"> T </em>创建了一个对象。<em class="lm"> decltype </em> ⁷返回给定表达式的类型，在本例中，它返回<em class="lm"> T::LogMessage() </em>函数的返回类型。如果<em class="lm"> T </em>没有<em class="lm"> LogMessage() </em>函数，则替换失败，模板将被忽略。</p><p id="3e99" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lm"> std::true_type </em>，<em class="lm"> std::false_type </em>各自定义其成员<em class="lm">值</em>为<em class="lm"> true </em>，<em class="lm"> false </em> ⁸.</p><p id="5793" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，如果一个模板参数<em class="lm"> T </em>被传递给<em class="lm"> has_log_message </em>模板结构，首先，编译器试图为部分专门化的<em class="lm"> has_log_message </em>实现实例化<em class="lm"> T </em>。如果<em class="lm"> T </em>有<em class="lm"> LogMessage() </em>成员函数，则实例化成功完成。所以实例化的<em class="lm"> has_log_message </em>结构是继承了<em class="lm"> std::true_type </em>的结构，该结构将<em class="lm"> value </em>成员设置为<em class="lm"> true </em>。</p><p id="6e28" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果<em class="lm"> T </em>没有<em class="lm"> LogMessage() </em>函数，则部分专门化的<em class="lm"> has_log_message </em>实现的实例化失败(被忽略)，然后编译器继续使用继承<em class="lm"> std::false_type </em>的主定义进行实例化，该主定义将<em class="lm">值</em>成员设置为<em class="lm"> false </em>。</p><p id="73f8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">剩下的解决方案就是<em class="lm">打印</em>模板功能的实现。就像第一个天真的解决方案。下面一行指定了<em class="lm"> Print </em>函数的返回类型，但是这次使用了<em class="lm"> has_log_member </em> struct模板。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="e8e6" class="ls lt it lo b gy lu lv l lw lx">typename std::enable_if&lt;has_log_message&lt;T&gt;::value&gt;::type</span></pre><p id="b9d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与第一种解决方案一样，如果<em class="lm">has _ log _ message&lt;T&gt;:value</em>为<em class="lm"> false </em>，则跳过实例化，如果<em class="lm">为true </em>，则产生一个类型，实例化成功完成。</p><p id="b7c6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">综上所述，如果我们将一个具有<em class="lm"> LogMessage() </em>函数的类型传递给<em class="lm"> Print </em>，它将使用<em class="lm"> LogMessage() </em>，但是如果我们将一个没有<em class="lm"> LogMessage() </em>函数的类型传递给<em class="lm"> Print </em>，它将使用原来的<em class="lm"> Print </em>实现！</p><p id="3e55" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">实例化结果描述如下。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="1cc1" class="ls lt it lo b gy lu lv l lw lx">std::string str = "Hello World!";<br/>int i = 0;<br/>MyClass my_class;<br/>OtherClass other_class; // OtherClass has LogMessage() member.</span><span id="add1" class="ls lt it lo b gy ly lv l lw lx">Print(str) --&gt; Use the original Print implementation. <br/>Print(i) --&gt; Use the original Print implementation.<br/>Print(my_class) --&gt; Use MyClass::LogMessage() function.<br/>Print(other_class) --&gt; Use OtherClass::LogMessage() function.</span></pre><h1 id="4764" class="mc lt it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">摘要</h1><p id="b3cd" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">在这篇文章中，我解释了高级C++模板概念“SFINAE ”,并举例说明了如何根据给定的模板参数来区分模板函数的实现。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="eac1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[1]:模板，<a class="ae nf" href="https://en.cppreference.com/w/cpp/language/templates" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/templates</a></p><p id="0645" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[2]:《c++模板完全指南第二版》</p><p id="a8d3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[3]:部分模板专门化，<a class="ae nf" href="https://en.cppreference.com/w/cpp/language/partial_specialization" rel="noopener ugc nofollow" target="_blank">https://en . CP preference . com/w/CPP/language/partial _ specialization</a></p><p id="a989" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[4]: SFINAE，<a class="ae nf" href="https://en.cppreference.com/w/cpp/language/sfinae" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/sfinae</a></p><p id="e61b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[5]: std::is_same，<a class="ae nf" href="https://en.cppreference.com/w/cpp/types/is_same" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/types/is_same</a></p><p id="3a2f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[6]: std::enable_if，<a class="ae nf" href="https://en.cppreference.com/w/cpp/types/enable_if" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/types/enable_if</a></p><p id="9fc3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[7]: std::declval，【https://en.cppreference.com/w/cpp/utility/declval T2】</p><p id="2969" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">[8]: std::integral_constant，【https://en.cppreference.com/w/cpp/types/integral_constant】T4</p></div></div>    
</body>
</html>