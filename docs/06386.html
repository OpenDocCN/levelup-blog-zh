<html>
<head>
<title>Combining Multiple GraphQL Services into One Federated Data Graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将多个GraphQL服务组合成一个联邦数据图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/combining-multiple-graphql-services-into-one-federated-data-graph-c3d93b4bab45?source=collection_archive---------6-----------------------#2020-11-20">https://levelup.gitconnected.com/combining-multiple-graphql-services-into-one-federated-data-graph-c3d93b4bab45?source=collection_archive---------6-----------------------#2020-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f90f6981395f9c85f068277215ec8633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aoCto-0hclnjK4jx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克林特·王茂林在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bbea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">微服务在过去的十年里越来越受欢迎。原因有很多…可伸缩性、可靠性、可维护性…还有很多。本文不会关注这些，尽管现在几乎任何一本好书或文章都会深入讨论这些。</p><p id="30b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种快速增长和采用的原因可能与任何web开发人员使用现代编程语言和发布的工具构建和部署微服务的速度有关。</p><p id="698d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我发现自己在做一个项目，这个项目为系统运行所涉及的数据提供了清晰的上下文边界。这使得设计处理这些数据的服务变得相对简单！每个服务都有一个核心需求:读取大量数据并提供给用户。以前从未有机会在生产环境中使用GraphQL，这是我的第一选择。我着手创建每个服务，为每个服务创建一个<a class="ae kc" href="https://www.apollographql.com/docs/apollo-server/" rel="noopener ugc nofollow" target="_blank"> Apollo服务器</a>，以及相关的模式和解析器。前端用的<a class="ae kc" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">阿波罗客户端</a>。</p><p id="cc7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的唯一缺点是每个服务公开自己的GraphQL服务器端点。有多种方法可以处理这个问题，但是其中一种方法是为每个端点创建一个新的环境变量，并将每个视图包装在一个Apollo提供程序中。远非理想。允许多个服务自由创建单个数据图的解决方案对于减少所需的额外复杂配置来说是完美的。</p><p id="a0b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">介绍<a class="ae kc" href="https://www.apollographql.com/docs/federation/" rel="noopener ugc nofollow" target="_blank">阿波罗联邦</a>！Apollo Federation组合了多个GraphQL服务，并公开了一个单一的联邦数据图！完美！</p><p id="5db5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将介绍什么是Apollo Federation，使用Apollo Federation的好处，以及如何开始使用Apollo Federation。写这篇文章的目的是分享我在过去几个月的学习，而不是一篇指导性的文章。如果我犯了任何错误或可以改进的地方，请给我一个呼喊，让我知道！编程片段将在NodeJS和TypeScript中。尽情享受吧！</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="a112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先说什么是阿波罗联邦。以下是官方文件中引用的一段YouTube视频:</p><blockquote class="li lj lk"><p id="a634" class="kd ke ll kf b kg kh ki kj kk kl km kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated">一组工具，用于以声明方式将多个GraphQL模式组合成一个数据图</p></blockquote><p id="88d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以定义单独的<strong class="kf ir">集成</strong>服务，使用它们自己的GraphQL模式，运行在多个服务器上。例如，我们可能有一个巫师服务和一个咒语服务。我们可以用一个服务来表示两者，并用一个大的模式来表示巫师和咒语。然而，这可能会很快失控，并在未来拖开发人员的后腿！我们想避免的事情，对吗？一旦我们的服务启动并运行，我们就可以使用<strong class="kf ir"> Apollo Federation </strong>通过<strong class="kf ir">网关将这些模式整合在一起。</strong></p><p id="4124" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这正好解决了之前讨论的问题——在前端将许多不同的地址放在一起。现在，我们可以使用一个网关URL来访问单个数据图，并让每个服务扩展它，从而从我们的所有服务中提供一个架构。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="fba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要三个包来开始:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="6a82" class="ly lz iq lu b gy ma mb l mc md">@apollo/federation - which makes the schemas in our services federation ready<br/>@apollo/gateway - helps us to pull together our services and distribute GraphQL requests to respective services<br/>apollo-server - we need an instance of Apollo Server for each service and the Gateway API</span></pre><p id="aa7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们首先为我们的法术创建一个集成的服务。这样做的代码在下面的要点，让我们指出一些关键线路，并检查他们在做什么。注意第5行，我们已经把我们的法术类型变成了一个实体。这是通过添加@key指令并将其分配给“id”来实现的。通过添加@key指令，我们允许<em class="ll">其他服务</em>能够引用或扩展这个类型，只要它们知道ID。</p><p id="ae6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个重要的行是第10行。我们在这里使用extend关键字，因为基本查询将存在于我们的网关上，并且所有实现服务都扩展了这个查询类型。</p><p id="58fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，注意第27行。这里，我们使用buildFederatedSchema函数来构建我们的联邦模式，使用我们定义的typeDefs(第4行)和解析器(第15行)。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="a27c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建向导服务。请注意我们的巫师服务和我们的法术服务之间的相似之处。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="f63c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要创建我们的网关服务。我们可以通过创建另一个阿波罗服务器来做到这一点。我们的网关服务需要引用我们的实现服务。这是在第6行完成的，这里有我们的serviceList，一个对象数组，其中每个对象引用我们的一个实现服务。</p><p id="63ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，在第13行，当我们创建ApolloServer时，我们不再传入模式，而是传入网关。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="888b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们运行这个，我们应该看到我们的两个服务在我们的GraphQL操场上合并成一个数据图。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/417c0375f8d6a3a72e2c5026a5dfaa5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7n1uiYW9qgNNdTD45Lyug@2x.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">GraphQL操场单一数据图</figcaption></figure><p id="3f81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总的来说，Apollo Federation为拥有多个GraphQL服务提供了一个干净、简单的解决方案。我发现Apollo Federation可以加快开发速度，缩小开发和部署之间的差距。我发现错误修复很简单，因为我现在只维护与每个服务相关的数据图，我发现维护很简单，几乎没有压力！</p><p id="0051" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望本文强调了使用Apollo Federation创建和部署基于GraphQL的微服务是多么简单。这里是本文中使用的<a class="ae kc" href="https://github.com/gitpancake/federation-medium-spells" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。我真的很喜欢使用这些工具，并对GraphQL生态系统有了更多的了解。希望你也是！感谢阅读:)。</p></div></div>    
</body>
</html>