<html>
<head>
<title>Using JWT in Your React+Redux App for Authorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React+Redux应用程序中使用JWT进行授权</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-jwt-in-your-react-redux-app-for-authorization-d31be51a50d2?source=collection_archive---------0-----------------------#2019-04-09">https://levelup.gitconnected.com/using-jwt-in-your-react-redux-app-for-authorization-d31be51a50d2?source=collection_archive---------0-----------------------#2019-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何在web应用前端处理JWT和认证的解释和指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cae12095351fef3b8005eb84b1fec3d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21uJ1YDk7qllnM1DaHkhxg.png"/></div></div></figure><blockquote class="ku"><p id="1b1a" class="kv kw it bd kx ky kz la lb lc ld le dk translated">" Auth如何与Redux和JWT一起工作？"</p></blockquote><p id="ac99" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz le im bi translated">总体思路是，将当前用户的信息保存到Redux store，以便在整个应用程序中轻松访问。您还将把与用户相关联的JWT (JSON Web Token)保存到localStorage，以便他们的登录可以在会话之间持续，除非他们显式注销。</p><p id="eca6" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">本教程假设您已经设置了以下三个Rails API路径:</p><blockquote class="ku"><p id="e583" class="kv kw it bd kx ky mf mg mh mi mj le dk translated">发帖者/用户<br/>发帖者/登录者<br/>获取/个人资料</p></blockquote><p id="d08b" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz le im bi translated">这三个途径处理身份验证的三个基本部分——当用户创建帐户时，当用户登录到该帐户时，以及当登录的用户重新访问您的web应用程序时。我将按照这个顺序进行，尽管最后一部分(当用户再次访问你的应用时的处理)是JWT的用处所在。</p><p id="8938" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">我们开始吧！</p><blockquote class="mk ml mm"><p id="c3db" class="lf lg mn lh b li ma ju lk ll mb jx ln mo mc lq lr mp md lu lv mq me ly lz le im bi translated">注意:本教程主要面向Flatiron School的软件工程训练营的Mod 5学生，他们已经对其Rails API后端实现了JWT认证，但不确定如何让他们的客户端React+Redux应用程序处理认证。</p><p id="8054" class="lf lg mn lh b li ma ju lk ll mb jx ln mo mc lq lr mp md lu lv mq me ly lz le im bi translated">希望我能帮助你理清Auth的工作流程，以及如何将它应用到你的项目中！</p></blockquote><div class="mr ms gp gr mt mu"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">编写面试问题</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">技术开发</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ks mu"/></div></div></a></div><h1 id="10b7" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">1.用户注册(发布到/用户)</h1><p id="5249" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">当新用户访问您的应用程序时，您可能希望他们注册一个帐户。您实际上将运行一个标准的POST请求；你不需要做什么特别的事情就可以让它运行起来。</p><p id="8a64" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">如果设置正确，您的后端将创建用户实例，使用BCrypt加密密码，然后返回一个带有用户密钥和令牌密钥的对象。该对象是授权的重要部分。您将在本教程的后面看到它，但是我们实际上将获取用户对象并将其保存到Redux存储，然后获取与用户相关联的令牌并将其保存到localStorage。</p><p id="7fcb" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">注册新用户并自动登录的步骤如下。</p><h2 id="c44b" class="og nk it bd nl oh oi dn np oj ok dp nt lo ol om nv ls on oo nx lw op oq nz or bi translated">拥有新的用户提交表单</h2><p id="219c" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">在您的React应用程序中，您将需要一个表单，该表单在提交后将在您的<code class="fe os ot ou ov b">actions.js</code>文件中运行您的获取。您将在这里使用Redux的thunk，所以请确保您已经安装了它。</p><p id="ff91" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">创建一个受控组件，该组件是用于创建新用户的表单。例如，它可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="oy oz gj gh gi pa pb bd b be z dk translated">您的组件不必看起来完全像这样——重要的部分是handleSubmit函数。</figcaption></figure><p id="bfc1" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">注意某个名为<code class="fe os ot ou ov b">userPostFetch</code>的未知函数是从<code class="fe os ot ou ov b">actions.js</code>导入的，然后使用<code class="fe os ot ou ov b">mapDispatchToProps</code>作为道具添加到组件中。您可以在上面看到，这个prop是在提交表单时调用的。这将是处理获取本身的函数，以及将用户对象保存到Redux存储并将令牌添加到localStorage。接下来，我们将编写这个函数。</p><h2 id="5cc6" class="og nk it bd nl oh oi dn np oj ok dp nt lo ol om nv ls on oo nx lw op oq nz or bi translated">具有获取请求的功能</h2><p id="0c81" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">在您的<code class="fe os ot ou ov b">actions.js</code>文件中，它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="176c" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">注意两个独立的功能:<code class="fe os ot ou ov b">userPostFetch</code>和<code class="fe os ot ou ov b">loginUser</code>。函数<code class="fe os ot ou ov b">userPostFetch</code>将用户信息发送到你的后台进行验证。成功后，它期待一个JSON对象的响应，如下所示:</p><pre class="kj kk kl km gt pc ov pd pe aw pf bi"><span id="7949" class="og nk it ov b gy pg ph l pi pj">{<br/>  user: {<br/>    username: "ImANewUser",<br/>    avatar: "https://robohash.org/imanewuser.png",<br/>    bio: "A new user to the app."<br/>  },<br/>  token: "aaaaaaa.bbbbbbbb.ccccccc"<br/>}</span></pre><p id="74d1" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">在<code class="fe os ot ou ov b">userPostFetch</code>中，这是我们在第二个‘then’语句中命名的‘data’。</p><h2 id="7113" class="og nk it bd nl oh oi dn np oj ok dp nt lo ol om nv ls on oo nx lw op oq nz or bi translated">将令牌保存到本地存储</h2><p id="1c70" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">使用我们在<code class="fe os ot ou ov b">userPostFetch</code>函数中编写的代码，<code class="fe os ot ou ov b">localStorage.setItem(“token”, data.token)</code>会将令牌(<code class="fe os ot ou ov b">“aaaaaaa.bbbbbbbb.ccccccc”</code>)保存到用户的本地存储中。稍后，当我们在会话之间持久化用户登录时，将会用到它。</p><p id="876d" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">要检查令牌是否已成功保存，请在控制台中运行<code class="fe os ot ou ov b">localStorage.token</code>或<code class="fe os ot ou ov b">localStorage.getItem(“token”)</code>。</p><h2 id="9ba9" class="og nk it bd nl oh oi dn np oj ok dp nt lo ol om nv ls on oo nx lw op oq nz or bi translated">将用户对象保存到Redux存储中</h2><p id="2e10" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">至于用户对象，我们在这里看到<code class="fe os ot ou ov b">dispatch(loginUser(data.user))</code>正在运行。假设您的reducer将获取用户对象(<code class="fe os ot ou ov b">{username: “ImANewUser”}</code>)并将其保存到您的Redux存储中。这将使React应用程序中的任何组件都很容易知道当前用户是谁。</p><p id="05e5" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">作为一个例子，这是我的减速器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="69c0" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">这里，用户对象(<code class="fe os ot ou ov b">action.payload</code>)被保存到currentUser键下的状态。如果您安装了Redux DevTools，您可以在成功创建您的用户后检查它。您应该会看到用户对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/07249034dd6fce231d023231b5d7fcdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtbwaiZsJ4lTV1-1zdxiow.png"/></div></div><figcaption class="oy oz gj gh gi pa pb bd b be z dk translated">你可能会注意到我有一个你可能没有的“reducer”键。这是因为我有多个减速器，并将其中一个命名为“减速器”。</figcaption></figure><blockquote class="mk ml mm"><p id="1377" class="lf lg mn lh b li ma ju lk ll mb jx ln mo mc lq lr mp md lu lv mq me ly lz le im bi translated">注意:你知道有时你在网站上创建一个账户后，它会要求你立即手动登录吗？您的网站也可以这样做，用户创建帐户后，您不必自动登录。</p><p id="0f05" class="lf lg mn lh b li ma ju lk ll mb jx ln mo mc lq lr mp md lu lv mq me ly lz le im bi translated">如果您决定这样做，只需对用户对象和JWT令牌不做任何事情。事实上，您可以从后端编辑逻辑，使它只返回状态消息。</p></blockquote><p id="0b21" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">注册新用户到此为止。接下来，我们将了解如何登录现有用户。</p><h1 id="1935" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">2.用户登录(发布/登录)</h1><p id="d417" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">用户登录与注册过程非常相似，只是您只需要将登录凭证发送到后端。后端将处理对用户的验证，然后从注册中发回相同的对象——一个带有用户密钥和令牌密钥的对象。同样，您将把用户对象保存到Redux存储，并将令牌保存到localStorage。</p><p id="459b" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">如果你有一个专用于登录的组件，它看起来将与你的注册组件相似，但有一个主要的区别——它将从你的<code class="fe os ot ou ov b">actions.js</code>文件导入一个不同的函数。它可能看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="oy oz gj gh gi pa pb bd b be z dk translated">请注意，表单本身唯一的变化是删除了头像和简历输入字段。</figcaption></figure><p id="e30e" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">我们还没有编写<code class="fe os ot ou ov b">userLoginFetch</code>函数，但是它的外观类似于处理注册的fetch。见下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="468e" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">请注意，我们重用了<code class="fe os ot ou ov b">loginUser</code>动作，以便将用户对象保存到状态中。</p><p id="9530" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">令人惊讶的是，这就是用户登录！当用户的对象被保存到状态，并且他们的令牌被保存到localStorage时，您可以认为您的用户已经登录。</p><p id="1deb" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">现在让我们做第三部分，也是最后一部分:在会话之间保持用户的登录。</p><h1 id="48ed" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">3.用户回访(转到/个人资料)</h1><p id="39b5" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">将令牌保存到localStorage的目的是保存登录。当你的用户再次访问你的网站时，你想让他们感觉好像是从以前开始继续他们的会话。</p><p id="4eb1" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">请记住，保存到localStorage中的令牌只是一个字符串。它本身并不等同于登录用户。作为开发人员，您必须接受令牌，并将其转换为持久登录。</p><p id="8c8c" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">为此，如果用户在本地存储中保存了令牌，则每次访问应用程序时，您都需要运行fetch (GET to /profile)。在您的应用程序组件的componentDidMount中运行此逻辑是一个不错的选择，因为它肯定会在您的应用程序被访问时运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="oy oz gj gh gi pa pb bd b be z dk translated">您的应用程序组件看起来不会完全像这样(您可以特别忽略开关和路由部分)，但这里的关键部分是getProfileFetch函数，它作为一个prop提供给应用程序，然后在componentDidMount中调用。</figcaption></figure><p id="deda" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">我们正在从<code class="fe os ot ou ov b">actions.js</code>导入一个名为<code class="fe os ot ou ov b">getProfileFetch</code>的函数，它在应用组件挂载时立即运行。</p><p id="1855" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated"><code class="fe os ot ou ov b">getProfileFetch</code>要做的是运行一个标准的GET请求，除了一个带有令牌的授权头，它在<code class="fe os ot ou ov b">actions.js</code>文件中处理。您的后端应该设置为接收令牌，对其进行解码，然后返回其相关的用户对象。然后像往常一样将它保存到Redux存储中。您已经将令牌保存到了localStorage，所以您不必担心它。</p><p id="eb9f" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">该函数将类似于以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="38e7" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">函数<code class="fe os ot ou ov b">getProfileFetch</code>在尝试持久化登录之前，首先检查是否有令牌保存在localStorage中。这样，您就不会运行不必要的获取。</p><p id="2b31" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">再次注意，我们重用了<code class="fe os ot ou ov b">loginUser</code>动作，并且没有重新保存令牌。用户已经在他们的localStorage中有了它，所以没有必要再次保存它。</p><p id="ed71" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">现在你有了——你有了有效的授权！</p></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="b1aa" class="nj nk it bd nl nm ps no np nq pt ns nt jz pu ka nv kc pv kd nx kf pw kg nz oa bi translated">***奖励:注销</h1><p id="c64a" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">当你测试你的应用程序时，你会注意到目前唯一的注销方式是通过在你的控制台中键入<code class="fe os ot ou ov b">localStorage.removeItem(“token”)</code>来清除本地存储中的JWT令牌，然后点击刷新来清除Redux存储。我们应该为您的客户创建一个注销按钮。</p><p id="d04e" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">在你的应用程序中的某个地方，你需要一个注销按钮来完成上述操作。虽然我不会把它随意放在<code class="fe os ot ou ov b">App.js</code>文件中，但这里有一个<code class="fe os ot ou ov b">App.js</code>中注销按钮的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="983e" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">您应该注意到一些新的东西:首先，有一个名为<code class="fe os ot ou ov b">logoutUser</code>的新动作被导入，我们将很快编写它。我们现在还使用了mapStateToProps，以便App组件接收一个名为currentUser的属性。</p><blockquote class="mk ml mm"><p id="2a0f" class="lf lg mn lh b li ma ju lk ll mb jx ln mo mc lq lr mp md lu lv mq me ly lz le im bi translated">注意:因为我有多个reducers，所以我必须通过在mapStateToProps中键入<code class="fe os ot ou ov b">state.reducer.currentUser</code>来访问我的Redux存储的当前用户。如果你只有一个缩减器，你可能只需要写<code class="fe os ot ou ov b">state.currentUser</code>。</p></blockquote><p id="f342" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">现在还有一个三元运算符，它检查从Redux store接收的currentUser属性是否有一个用户名键(例如，currentUser对象是否为空)。如果是这样，它会呈现一个“注销”按钮，单击该按钮将调用<code class="fe os ot ou ov b">logoutUser</code>。它还将从本地存储中删除令牌。</p><p id="a5df" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated"><code class="fe os ot ou ov b">logoutUser</code>将只是一个简单的动作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="c02d" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">该操作将在reducer中执行以下操作，用一个空对象替换当前用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="b217" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">现在你知道了！当您登录和注销时，您应该会看到该按钮出现和消失。</p></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="41a9" class="nj nk it bd nl nm ps no np nq pt ns nt jz pu ka nv kc pv kd nx kf pw kg nz oa bi translated">怎么查？</h1><p id="1cb1" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">您可能已经遵循了上述内容，并且正在质疑您的授权是否有效。您可以通过注册、登录、按刷新和注销来测试它。如果一切正常，您应该会看到使用您的Redux DevTools将用户对象保存到您的Redux存储中，并在控制台中查看保存到您的localStorage中的令牌。</p><h1 id="5113" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">现在怎么办？</h1><p id="1788" class="pw-post-body-paragraph lf lg it lh b li ob ju lk ll oc jx ln lo od lq lr ls oe lu lv lw of ly lz le im bi translated">至于下一步该怎么做，您可以在组件中运行检查，如果用户没有登录，就把他们踢出去。您可以使用<code class="fe os ot ou ov b">react-router-dom</code>中的<code class="fe os ot ou ov b">Redirect</code>或<code class="fe os ot ou ov b">connected-react-router</code>中的<code class="fe os ot ou ov b">push</code>功能来完成此操作。这些是我更喜欢使用的资源。</p><p id="2e0c" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">如前所述，您现在还可以将currentUser对象从Redux store传递到应用程序中的任何组件。例如，如果你想让你的导航条显示用户的头像，你可以使用<code class="fe os ot ou ov b">mapStateToProps</code>将当前用户对象传递给导航条，然后呈现头像。</p><p id="9ab7" class="pw-post-body-paragraph lf lg it lh b li ma ju lk ll mb jx ln lo mc lq lr ls md lu lv lw me ly lz le im bi translated">这就是现在的全部内容——感谢您的阅读和快乐编码！</p></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><div class="kj kk kl km gt mu"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">gitconnected.com</p></div></div><div class="nd l"><div class="px l nf ng nh nd ni ks mu"/></div></div></a></div></div></div>    
</body>
</html>