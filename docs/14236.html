<html>
<head>
<title>Golang type conversion summary</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang类型转换摘要</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-type-conversion-summary-dc9e36842d25?source=collection_archive---------8-----------------------#2022-11-10">https://levelup.gitconnected.com/golang-type-conversion-summary-dc9e36842d25?source=collection_archive---------8-----------------------#2022-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1978" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一篇讲清楚Golang类型转换的文章。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d1d385cc7fe541e06e0970ad78c036a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7W2z2gvoZKQZt-LU"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">帕特里克·帕金斯在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4557" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">围棋中有4种<code class="fe lf lg lh li b">type-conversions</code>:</p><ul class=""><li id="9000" class="lj lk it js b jt ju jx jy kb ll kf lm kj ln kn lo lp lq lr bi translated">断言。</li><li id="8a55" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated">强制类型转换。</li><li id="2681" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated">显式类型转换。</li><li id="ae19" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated">隐式类型转换。</li></ul><p id="083e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般说的类型转换是指<code class="fe lf lg lh li b">assertion</code>，日常生活中不使用强制类型转换，显式是基本类型转换，隐式使用但不注意。</p><p id="23ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">断言、强制、显式这三类在Go语法描述中都有说明，隐式在日常使用过程中有总结。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="d7cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">断言类型转换。</strong></p><p id="8556" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过判断变量是否可以转换为某种类型来断言。</p><p id="160c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:类型断言只能发生在<code class="fe lf lg lh li b">interfaces</code>上。</p><p id="cafc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们先来看一个简单的断言表达式。</p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="6761" class="mi mj it li b gy mk ml l mm mn">var s = x.(T)</span></pre><p id="8419" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe lf lg lh li b">x</code>不是<code class="fe lf lg lh li b">nil</code>，并且<code class="fe lf lg lh li b">x</code>可以转换为类型<code class="fe lf lg lh li b">T</code>，则断言成功，返回类型<code class="fe lf lg lh li b">T</code>的变量<code class="fe lf lg lh li b">s</code>。</p><p id="8fd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe lf lg lh li b">T</code>不是<code class="fe lf lg lh li b">interface</code>类型，则要求<code class="fe lf lg lh li b">x</code>的类型是<code class="fe lf lg lh li b">T</code>，如果<code class="fe lf lg lh li b">T</code>是<code class="fe lf lg lh li b">interface</code>，则要求<code class="fe lf lg lh li b">x</code>实现<code class="fe lf lg lh li b">T</code>接口。</p><p id="18f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果断言类型为<code class="fe lf lg lh li b">true</code>，表达式返回值为<code class="fe lf lg lh li b">T</code>类型的<code class="fe lf lg lh li b">x</code>，断言失败将触发<code class="fe lf lg lh li b">panic</code>。</p><p id="d4ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果断言失败，它将<code class="fe lf lg lh li b">panic</code>。Go提供了另一种断言语法，并返回:</p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="2732" class="mi mj it li b gy mk ml l mm mn">s, ok := x.(T)</span></pre><p id="bc1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法和第一种几乎一样，只是<code class="fe lf lg lh li b">ok</code>会返回断言是否成功而不需要<code class="fe lf lg lh li b">panic</code>，<code class="fe lf lg lh li b">ok</code>表示是否成功。</p><p id="82a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在进行类型声明时，我们应该知道变量的底层类型，但情况并非总是如此。</p><p id="b941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是为什么类型断言表达式实际上返回第二个可选值。</p><p id="a384" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用第二个值，我们可以很容易地确定断言结构是否成功。</p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="f557" class="mi mj it li b gy mk ml l mm mn">var foo interface{} = "123" <br/>fooStr, ok := foo.(string)</span><span id="a743" class="mi mj it li b gy mo ml l mm mn">if ok {<br/>    // ...</span><span id="6e94" class="mi mj it li b gy mo ml l mm mn">}</span></pre><blockquote class="mp mq mr"><p id="06e0" class="jq jr ms js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">更多详情见官方文档:<a class="ae le" href="https://go.dev/ref/spec#Type_assertions" rel="noopener ugc nofollow" target="_blank">https://golang.org/ref/spec#Type_assertions</a></p></blockquote></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="2d27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">类型开关。</strong></p><p id="f5e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go语法中提供了另一种类型切换的断言方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0099" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">x</code>被断言为<code class="fe lf lg lh li b">type</code>类型，<code class="fe lf lg lh li b">type</code>类型的具体值为开关箱的值。</p><p id="e830" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe lf lg lh li b">x</code>被成功断言为<code class="fe lf lg lh li b">case</code>类型，则该案例可以被执行。此时<code class="fe lf lg lh li b">i := x.(type)</code>返回的<code class="fe lf lg lh li b">i</code>就是该类型的变量，可以直接作为case类型使用。</p><p id="6423" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您不确定接口的类型时，可以使用类型开关语法。</p><p id="e928" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个具体的例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><blockquote class="mp mq mr"><p id="2230" class="jq jr ms js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">更多详情见官方文档:<a class="ae le" href="https://go.dev/ref/spec#Type_switches" rel="noopener ugc nofollow" target="_blank">https://go.dev/ref/spec#Type_switches</a></p></blockquote></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="0524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">强制类型转换。</strong></p><p id="863d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过修改变量类型强制进行类型转换</p><p id="fedc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法并不常见。主要用于不安全包和接口类型检测。它需要Go变量的知识。</p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="7c47" class="mi mj it li b gy mk ml l mm mn">var f float64<br/>bits = *(*uint64)(unsafe.Pointer(&amp;f))</span><span id="4aa5" class="mi mj it li b gy mo ml l mm mn">type ptr unsafe.Pointer<br/>bits = *(*uint64)(ptr(&amp;f))</span><span id="3669" class="mi mj it li b gy mo ml l mm mn">var p ptr = nil</span></pre><p id="492b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<code class="fe lf lg lh li b">float64</code>强制转换为<code class="fe lf lg lh li b">uint64</code>类型，float的地址是值但类型是float64，然后创建一个<code class="fe lf lg lh li b">uint64</code>类型变量，地址值也是float64的地址值，两个变量的值相同，类型不同，最后强制类型。</p><p id="cff6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">Unsafe</code>强制是指针的底层操作。使用<code class="fe lf lg lh li b">C</code>语言的开发人员非常熟悉这样的指针类型转换。只有使用内存对齐，转换才是可靠的。</p><p id="436d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如<code class="fe lf lg lh li b">int</code>和<code class="fe lf lg lh li b">uint</code>有符号位差，不安全转换后的值可能不一样，但是内存中存储的二进制是完全一样的。</p><blockquote class="mp mq mr"><p id="2d4a" class="jq jr ms js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">关于不安全的具体细节，请参考官方文档:<a class="ae le" href="https://go.dev/ref/spec#Package_unsafe" rel="noopener ugc nofollow" target="_blank">https://go.dev/ref/spec#Package_unsafe</a></p></blockquote></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="e824" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">接口类型检测。</strong></p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="1b28" class="mi mj it li b gy mk ml l mm mn">var _ Context = (*ContextBase)(nil)</span></pre><p id="c336" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">nil</code>的类型为<code class="fe lf lg lh li b">nil</code>，地址值为<code class="fe lf lg lh li b">0</code>，强制转换为<code class="fe lf lg lh li b">* ContextBase</code>。返回的变量类型为<code class="fe lf lg lh li b">*ContextBase</code>，地址值为<code class="fe lf lg lh li b">0</code>。</p><p id="bae1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后分配<code class="fe lf lg lh li b">Context=xx</code>。如果xx实现了<code class="fe lf lg lh li b">Context</code>接口就ok了。如果没有实现，编译时会报错，实现会在编译时检查接口是否实现。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="7762" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">显式类型转换。</strong></p><p id="691a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显式可转换表达式<code class="fe lf lg lh li b">T (x)</code>，其中<code class="fe lf lg lh li b">T</code>为类型，<code class="fe lf lg lh li b">x</code>为可转换为类型<code class="fe lf lg lh li b">T</code>的表达式，例如:<code class="fe lf lg lh li b">uint(123)</code>。</p><p id="f15e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下列任何一种情况下，变量<code class="fe lf lg lh li b">x</code>都可以转换为类型<code class="fe lf lg lh li b">T</code>:</p><ul class=""><li id="08b8" class="lj lk it js b jt ju jx jy kb ll kf lm kj ln kn lo lp lq lr bi translated"><code class="fe lf lg lh li b">x</code>可分配给类型<code class="fe lf lg lh li b">T</code>。</li><li id="7197" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated">忽略结构标签的类型<code class="fe lf lg lh li b">x</code>和<code class="fe lf lg lh li b">T</code>具有相同的底层类型。</li><li id="63e0" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated">忽略结构标志<code class="fe lf lg lh li b">x</code>类型和<code class="fe lf lg lh li b">T</code>是未定义类型的指针类型，它们的指针基类型具有相同的基类型。</li><li id="9289" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><code class="fe lf lg lh li b">x</code>和<code class="fe lf lg lh li b">T</code>的类型都是整型或浮点型。</li><li id="bd64" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><code class="fe lf lg lh li b">x</code>和<code class="fe lf lg lh li b">T</code>的类型都是复杂类型。</li><li id="840d" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><code class="fe lf lg lh li b">x</code>的类型为整数或<code class="fe lf lg lh li b">[]byte</code>或<code class="fe lf lg lh li b">[]rune</code>，而<code class="fe lf lg lh li b">T</code>的类型为字符串。</li><li id="acaa" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><code class="fe lf lg lh li b">x</code>的类型为字符串<code class="fe lf lg lh li b">T</code>的类型为<code class="fe lf lg lh li b">[]byte</code>或<code class="fe lf lg lh li b">[]rune</code>。</li></ul><p id="5cb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如下面的代码使用规则进行转换，规则实现可以参考<code class="fe lf lg lh li b">reflect.Value.Convert</code>方法逻辑。</p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="7235" class="mi mj it li b gy mk ml l mm mn">int64(123)<br/>[]byte("hello")</span><span id="48b2" class="mi mj it li b gy mo ml l mm mn">type A int<br/>A(0)</span></pre><blockquote class="mp mq mr"><p id="c411" class="jq jr ms js b jt ju jv jw jx jy jz ka mt kc kd ke mu kg kh ki mv kk kl km kn im bi translated">更多详情见官方文档:<a class="ae le" href="https://go.dev/ref/spec#Conversions" rel="noopener ugc nofollow" target="_blank">https://go.dev/ref/spec#Conversions</a></p></blockquote></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="e606" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">隐式类型转换。</strong></p><p id="44a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">隐式类型转换在日常使用中感觉不到，但在操作中确实会发生，下面列出了其中的两种。</p><p id="651f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ms"> # 1。在组合之间重新声明类型。</em></p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="779b" class="mi mj it li b gy mk ml l mm mn">type Reader interface {<br/>    Read(p []byte) (n int, err error)<br/>}</span><span id="35f7" class="mi mj it li b gy mo ml l mm mn">type ReadCloser interface {<br/>    Reader<br/>    Close() error<br/>}</span><span id="4da9" class="mi mj it li b gy mo ml l mm mn">var rc ReaderClose<br/>r := rc</span></pre><p id="c551" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ReaderClose接口结合了Reader接口，但是当r=rc赋值时发生类型转换，Go使用系统内置函数进行类型转换。</p><p id="7a2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以前遇到过像接口组合类型这样的变量赋值，然后使用<code class="fe lf lg lh li b">pprof</code>和基准测试来发现这个细节，在接口类型传输上浪费了一些性能。</p><p id="995a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ms"> # 2。相同类型之间的赋值。</em></p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="d2c8" class="mi mj it li b gy mk ml l mm mn">type Handler func()</span><span id="285f" class="mi mj it li b gy mo ml l mm mn">func NewHandler() Handler {<br/>    return func() {}<br/>}</span></pre><p id="dc00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然type定义了<code class="fe lf lg lh li b">Handler</code>类型，<code class="fe lf lg lh li b">Handler</code>和<code class="fe lf lg lh li b">func()</code>是两个实际的类型，但是这两个类型并不相等，并且这两个类型在使用反射和断言时是不同的。</p><p id="f1f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检验代码:</p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="1bb7" class="mi mj it li b gy mk ml l mm mn">package main</span><span id="dffd" class="mi mj it li b gy mo ml l mm mn">import (<br/>    "fmt"<br/>    "reflect"<br/>)</span><span id="ae3b" class="mi mj it li b gy mo ml l mm mn">type Handler func()</span><span id="0406" class="mi mj it li b gy mo ml l mm mn">func a() Handler {<br/>    return func() {}<br/>}</span><span id="61e2" class="mi mj it li b gy mo ml l mm mn">func main() {<br/>    var i interface{} = main<br/>    _, ok := i.(func())<br/>    fmt.Println(ok)</span><span id="572c" class="mi mj it li b gy mo ml l mm mn">    _, ok = i.(Handler)<br/>    fmt.Println(ok)<br/>    fmt.Println(reflect.TypeOf(main) == reflect.TypeOf((*Handler)(nil)).Elem())<br/>}</span></pre><p id="4f9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果是:</p><pre class="kp kq kr ks gt me li mf mg aw mh bi"><span id="b356" class="mi mj it li b gy mk ml l mm mn">true<br/>false<br/>false</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="bd00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这样的故事，想支持我，请给我鼓掌。</p><p id="1a8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的支持对我很重要，谢谢。</p></div></div>    
</body>
</html>