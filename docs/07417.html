<html>
<head>
<title>Introducing SSH zero trust, Identity aware TCP sockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍SSH零信任、身份识别TCP套接字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introducing-ssh-zero-trust-identity-aware-tcp-sockets-c73cf65e57c?source=collection_archive---------3-----------------------#2021-02-16">https://levelup.gitconnected.com/introducing-ssh-zero-trust-identity-aware-tcp-sockets-c73cf65e57c?source=collection_archive---------3-----------------------#2021-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="cbba" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">在本文中，我们将看看Mysocket的零信任<strong class="jt ir"> <em class="iq">云交付的认证防火墙。</em> </strong> <em class="iq">允许</em> <strong class="jt ir"> <em class="iq"> </em> </strong>你<strong class="jt ir"> <em class="iq">用可信身份替换你的可信IP范围。</em>T13】</strong></p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="051a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">上个月，我们引入了第一个零信任特性，引入了<em class="js">身份识别套接字</em>的概念。很高兴看到人们对此进行尝试，并开始将其用作传统VPN的远程访问替代方案。</p><p id="e69f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">如今，大多数服务都是基于HTTP的，通常通过HTTPS提供。然而，还有一些其他常用的服务不是基于HTTP的，因此，直到今天，它们还没有从我们的身份识别套接字中受益。在本文中，我们将介绍对非基于HTTP的服务的零信任支持，以及身份感知TCP套接字。具体来说，我们将把为SSH提供零信任服务作为一个例子。</p><h1 id="a135" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">确定用户的身份、认证和授权</h1><p id="3fa6" class="pw-post-body-paragraph jq jr iq jt b ju lx jw jx jy ly ka kb kw lz ke kf kx ma ki kj ky mb km kn ko ij bi translated">将您的mysocket服务转换为一个身份识别套接字非常简单，只需在创建服务时向mysocketctl添加— cloud_authentication标志即可。在此过程中，您可以添加电子邮件域列表和/或电子邮件地址列表。现在，每次用户试图访问您的服务时，都会弹出一个浏览器，要求用户进行身份验证。身份验证完成后，我们知道用户的身份，如果该身份与授权用户列表相匹配，那么用户才会被放行。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/a131f89cbb62b2423d420e89fc28e23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ft92EY1oDOvNgKIuWr1EiQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">创建识别身份的TCP套接字</figcaption></figure><p id="401c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">如果你想想这里发生了什么，你会意识到我们这里有一个每个会话的<strong class="jt ir"> <em class="js">，认证防火墙</em> </strong>。只有在用户通过身份验证和授权后，我们才允许网络流量通过。请注意，这比您的传统防火墙先进得多；现在，<strong class="jt ir">每个网络流都有一个身份</strong>。那就是厉害！</p><p id="5dcd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">这种重定向用户进行身份验证然后返回到服务的流程是可行的，因为它是在浏览器中完成的，并且主要由HTTP会话管理构建。现在我们想用非HTTP服务来扩展它，所以我们需要为HTTP会话部分找到一个替代方案。在Mutual TLS (MTLS)的帮助下，这个问题得到了解决。MTLS强制客户端在与服务器通信时进行自我验证。这是通过向服务器提供签名的客户端证书来实现的。</p><h1 id="e9d2" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">识别身份的TCP套接字</h1><p id="bd13" class="pw-post-body-paragraph jq jr iq jt b ju lx jw jx jy ly ka kb kw lz ke kf kx ma ki kj ky mb km kn ko ij bi translated">随着身份识别TCP套接字的引入，mysocket边缘代理充当身份验证防火墙。由于我们依赖客户端TLS证书，所有流量都通过TLS连接安全地通过隧道传输。</p><p id="ad10" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">正如您在下面的流程图中看到的，在用户可以通过之前，需要采取一些措施。为了让您的服务用户获得无缝体验，我们扩展了mysocketctl命令行工具，提供了启动身份验证流程所需的功能。它开始认证过程；之后，它会请求一个客户端证书(您的入场券),然后为您建立TLS隧道。之后，用户可以通过这个经过身份验证和加密的隧道发送流量。最简单的形式是这样的:</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="e4c5" class="ms la iq mo b gy mt mu l mv mw">echo "hello" | mysocketctl client tls \<br/>  --host muddy-pond-7106.edge.mysocket.io </span></pre><p id="e425" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">在上面的例子中，我们向muddy-pond-7106 . edge . my socket . io提供的服务发送字符串hello。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mx"><img src="../Images/c61ccefe635d4e2cfa0231a66493b418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1k3zEiQ7UJ3Q_8GFO2DNQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">运输流量</figcaption></figure><p id="3f70" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">在字符串“hello”到达由mysocket保护的服务之前，mysocketctl客户端将处理身份验证流，请求TLS客户端证书，并将通过stdin传入的任何内容发送到mysocket edge服务。</p><h1 id="a20a" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">SSH零信任</h1><p id="8f1b" class="pw-post-body-paragraph jq jr iq jt b ju lx jw jx jy ly ka kb kw lz ke kf kx ma ki kj ky mb km kn ko ij bi translated">现在我们已经理解了高级流程，让我们看一个更实际的例子。在这个例子中，我们有一个服务器，我想让SSH服务只对一部分用户可用。ssh是在一个私有网络上，比如你的公司网络、你的家庭网络，甚至是在一个私有的VPC中，或者只是与互联网隔开。</p><p id="b5a0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">首先，我们将在服务器端使用mysocketctl提供服务，并建立隧道。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="4c87" class="ms la iq mo b gy mt mu l mv mw">mysocketctl connect \<br/>  --name 'remote access for my ssh server' \<br/>  --cloudauth \<br/>  --allowed_email_addresses'<a class="ae my" href="mailto:contractor@gmail.com" rel="noopener ugc nofollow" target="_blank">contractor@gmail.com</a><a class="ae my" href="mailto:,andree@example.com" rel="noopener ugc nofollow" target="_blank">,john@example.com</a>' \<br/>  --allowed_email_domains 'mycorp.com' \<br/>  --port 22 --host localhost \<br/>  --type tls</span></pre><p id="a9f8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">在这个例子中，我创建了一个TLS类型的mysocket服务，并且我们启用了云认证。这将强制用户提供有效的客户端TLS证书。该证书只能发给使用mycorp.com电子邮件地址或使用contractor@gmail.com或john@example.com特定电子邮件地址认证的用户。相同的命令还将建立一个到最近的mysocket隧道服务器的安全隧道，并暴露在端口22上运行的ssh服务。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mz"><img src="../Images/4252aee944bdabcc7236a51e49e2511f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwNlj3B5ixml37NApIu-GA.png"/></div></div></figure><p id="77b4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">结果是，这个SSH服务现在只能由允许的用户访问，因为crimson-thunder-8434 . edge . my socket . io:38676<br/>只有具有有效客户端TLS票证的入站流量才能通过。有效的TLS客户证书只会颁发给拥有mycorp.com域名或我们指定的两个承包商电子邮件地址的用户。</p><h2 id="1695" class="ms la iq bd lb na nb dn lf nc nd dp lj kw ne nf ln kx ng nh lr ky ni nj lv nk bi translated">设置SSH会话</h2><p id="af08" class="pw-post-body-paragraph jq jr iq jt b ju lx jw jx jy ly ka kb kw lz ke kf kx ma ki kj ky mb km kn ko ij bi translated">好了，是时候测试并连接到这个ssh服务了。请记住，我们需要有效的TLS客户端证书。这些仅通过有效的令牌来发布，并且令牌仅分发给授权用户。为了使这一切更容易，我们扩展了mysocketctl工具来处理这个工作流。下面的例子显示了我们如何使用ssh proxy命令来简化这个过程，就像这样。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="7aa5" class="ms la iq mo b gy mt mu l mv mw">ssh ubuntu@crimson-thunder-8434.edge.mysocket.io \<br/>  -o 'ProxyCommand=mysocketctl client tls --host %h'</span></pre><p id="abf1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">这将告诉ssh通过这个<em class="js"> mysocketctl客户端</em>命令发送所有ssh流量。这将启动身份验证过程，为我们获取TLS客户端证书，建立到mysocket边缘服务器的TLS隧道，并通过这个经过身份验证的隧道传输ssh流量。用户现在可以使用您习惯的任何方法登录ssh服务器。</p><p id="dd05" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">这样，我们就可以从互联网访问我们的私有ssh服务器，而认证mysocket防火墙的<strong class="jt ir"><em class="js"/></strong>只允许来自我们事先批准的客户端身份的会话。不需要VPN。很酷，对吧？</p><h1 id="ef41" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Mysocket SSH证书颁发机构。</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/01a8c3e908013174fa6436035ce04806.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*O4oTzRsqd2WDUlDo.jpg"/></div></figure><p id="2fd4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">SSH在工作流程方面与TLS非常相似。它也支持使用签名证书认证用户。</p><p id="9e3c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">所以我们决定扩展这个功能。除了负责签署TLS证书的API端点之外，我们还创建了一个用于签署SSH密钥的API端点。</p><p id="8f75" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">如果我们以上面的例子为基础，用户现在除了请求TLS客户机证书之外，还可以请求一个签名的SSH证书。我们的SSH证书签名服务将只在用户经过身份验证和授权的情况下对签名请求进行签名，使用与以前相同的逻辑。</p><h2 id="1f9f" class="ms la iq bd lb na nb dn lf nc nd dp lj kw ne nf ln kx ng nh lr ky ni nj lv nk bi translated">设置服务器</h2><p id="cf52" class="pw-post-body-paragraph jq jr iq jt b ju lx jw jx jy ly ka kb kw lz ke kf kx ma ki kj ky mb km kn ko ij bi translated">为了使用它，我们需要对SSH服务器做一些小的改动。要使用CA密钥启用身份验证，需要更改以下配置。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="d40c" class="ms la iq mo b gy mt mu l mv mw">echo "TrustedUserCAKeys /etc/ssh/ca.pub" &gt;&gt;/etc/ssh/sshd_config<br/>echo "AuthorizedPrincipalsFile %h/.ssh/authorized_principals" &gt;&gt;/etc/ssh/sshd_config<br/>echo "<!-- -->mysocket_ssh_signed" &gt; /home/ubuntu/<!-- -->.ssh/authorized_principals</span></pre><p id="59df" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">最后，还要确保获得CA的公钥(<em class="js"> mysocketctl socket show) </em>，并将其复制到ca.pub文件(<code class="fe nm nn no mo b">/etc/ssh/ca.pub)</code></p><p id="36f5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">现在，服务器被配置为使用并允许基于来自mysocket证书颁发机构的签名SSH密钥进行身份验证。注意，所有签名的证书都有两个原则，被验证用户的电子邮件地址，以及'<em class="js"> mysocket_ssh_signed </em>'。在上面的配置示例中，我们告诉服务器将原则为'<em class="js"> mysocket_ssh_signed </em>'的用户映射到本地用户ubuntu。</p><p id="9725" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">现在我们准备好连接了，但是我没有让ssh命令变得更长，而是将以下内容添加到我的ssh配置文件中~/。ssh/config</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="f590" class="ms la iq mo b gy mt mu l mv mw">Host *.edge.mysocket.io<br/>    ProxyCommand bash -c 'mysocketctl client ssh-keysign --host %h; ssh -tt -o IdentitiesOnly=yes -i ~/.ssh/%h %r@%h.mysocket-dummy &gt;&amp;2 &lt;&amp;1'</span><span id="014e" class="ms la iq mo b gy np mu l mv mw">Host *.mysocket-dummy<br/>    ProxyCommand mysocketctl client tls --host %h</span></pre><p id="2e90" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">以上内容将确保对于所有到*.edge.mysocket.io的ssh会话，我们启动身份验证流程，获取TLS客户端证书，并设置TLS隧道。我们还将提交一个SSH密钥签名请求，这将产生一个短期的签名SSH证书，该证书将用于认证SSH用户。</p><p id="0130" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">现在，用户可以像这样使用SSH，整个工作流程就开始了。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="6b25" class="ms la iq mo b gy mt mu l mv mw">ssh ubuntu@crimson-thunder-8434.edge.mysocket.io</span></pre><p id="4080" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">对于那些感兴趣的人来说，ssh证书将最终放在您的~/中。ssh/ directory，看起来像这样。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="8c4d" class="ms la iq mo b gy mt mu l mv mw">$ ssh-keygen -Lf ~/.ssh/nameless-thunder-8896.edge.mysocket.io-cert.pub<br/>/Users/andreetoonk/.ssh/nameless-thunder-8896.edge.mysocket.io-cert.pub:<br/>        Type: <a class="ae my" href="mailto:ecdsa-sha2-nistp256-cert-v01@openssh.com" rel="noopener ugc nofollow" target="_blank">ecdsa-sha2-nistp256-cert-v01@openssh.com</a> user certificate<br/>        Public key: ECDSA-CERT SHA256:0u6TICEhrISMCk7fbwBi629In9VWHaDG1IfnXoxjwlg<br/>        Signing CA: ECDSA SHA256:MEdE6L0TUS0ZZPp1EAlI6RZGzO81A429lG7+gxWOonQ (using ecdsa-sha2-nistp256)<br/>        Key ID: "<a class="ae my" href="mailto:atoonk@gmail.com" rel="noopener ugc nofollow" target="_blank">atoonk@gmail.com</a>"<br/>        Serial: 5248869306421956178<br/>        Valid: from 2021-02-13T12:15:20 to 2021-02-13T12:25:20<br/>        Principals:<br/>                <a class="ae my" href="mailto:atoonk@gmail.com" rel="noopener ugc nofollow" target="_blank">atoonk@gmail.com</a><br/>                mysocket_ssh_signed<br/>        Critical Options: (none)<br/>        Extensions:<br/>                permit-X11-forwarding<br/>                permit-agent-forwarding<br/>                permit-port-forwarding<br/>                permit-pty<br/>                permit-user-rc</span></pre><p id="2929" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">这样，用户就可以像以前一样SSH到同一个服务器，但是酷的是服务器不需要知道它的用户的任何传统的已知凭证。像密码或authorized_keys文件中的公钥条目这样的事情已经成为过去。相反，在<em class="js"> mysocketctl </em>的帮助下，用户将提供一个短期的签名ssh证书，服务器将信任该证书。</p><p id="4470" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">这样，我们为您的SSH服务器实现了真正的单点登录(SSO)。由于证书是短期的，从过去的五分钟(考虑到时间漂移)到未来的五分钟，我们可以确定每次登录的身份验证和授权流都是成功的。</p><h1 id="989c" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用我的SSH服务器亲自尝试一下</h1><p id="36f7" class="pw-post-body-paragraph jq jr iq jt b ju lx jw jx jy ly ka kb kw lz ke kf kx ma ki kj ky mb km kn ko ij bi translated">如果你对用户来说是什么样子很好奇，想试一试？我有一个在165.232.143.236上运行的测试虚拟机，它有防火墙规则来阻止来自互联网的SSH流量，但使用<em class="js"> mysocket </em>，任何拥有gmail.com账户的人都可以访问它。我鼓励你试一试，这将花费你不到一分钟的时间来设置，只需复制粘贴一次性设置配置。</p><h2 id="9927" class="ms la iq bd lb na nb dn lf nc nd dp lj kw ne nf ln kx ng nh lr ky ni nj lv nk bi translated">一次性安装</h2><p id="49ff" class="pw-post-body-paragraph jq jr iq jt b ju lx jw jx jy ly ka kb kw lz ke kf kx ma ki kj ky mb km kn ko ij bi translated">如果您使用Mac笔记本电脑作为客户端，您将需要mysockectl工具，该工具将请求短期证书并建立TLS隧道。要安装客户端，只需复制粘贴以下内容(仅适用于Mac，其他平台请参见download.edge.mysocket.io)。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="f61f" class="ms la iq mo b gy mt mu l mv mw">curl -o mysocketctl https://download.edge.mysocket.io/darwin_amd64/mysocketctl <br/>chmod +x ./mysocketctl<br/>sudo mv ./mysocketctl /usr/local/bin/</span></pre><p id="ca8d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">为了便于使用，我们将把以下内容添加到我们的ssh客户端配置文件中。这是一次性设置，将确保通过mysocketctl客户端工具发送到*.edge.mysocket.io的ssh流量。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="f6bb" class="ms la iq mo b gy mt mu l mv mw">cat &lt;&lt;EOF &gt;&gt; ~/.ssh/config</span><span id="4fcc" class="ms la iq mo b gy np mu l mv mw">Host *.edge.mysocket.io<br/> ProxyCommand bash -c ‘mysocketctl client ssh-keysign --host %h; ssh -tt -o IdentitiesOnly=yes -i ~/.ssh/%h %r@%h.mysocket-dummy &gt;&amp;2 &lt;&amp;1’</span><span id="16e2" class="ms la iq mo b gy np mu l mv mw">Host *.mysocket-dummy<br/> ProxyCommand mysocketctl client tls --host %h</span><span id="cd26" class="ms la iq mo b gy np mu l mv mw">EOF</span></pre><p id="79c5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">现在您应该能够使用ssh连接到我的测试服务器了</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="a32e" class="ms la iq mo b gy mt mu l mv mw">ssh <a class="ae my" href="mailto:testuser@frosty-feather-1130.edge.mysocket.io" rel="noopener ugc nofollow" target="_blank">testuser@frosty-feather-1130.edge.mysocket.io</a></span></pre><p id="9e43" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">当浏览器弹出时，确保使用“使用谷歌登录”选项，因为这个套接字已被配置为只允许具有Gmail.com电子邮件地址的身份。</p><h1 id="4f18" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">包扎</h1><p id="0f6e" class="pw-post-body-paragraph jq jr iq jt b ju lx jw jx jy ly ka kb kw lz ke kf kx ma ki kj ky mb km kn ko ij bi translated">在这篇文章中，我们展示了如何继续利用“身份识别<em class="js">套接字</em>”来构建我们之前的工作。我们引入了对身份识别TCP套接字的支持，利用TLS隧道和双向TLS进行身份验证。</p><blockquote class="jn jo jp"><p id="ab29" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">我喜欢把它想象成一个<strong class="jt ir"> <em class="iq">云交付的认证防火墙。</em> </strong>有了这个，我们就可以在非常精细的基础上让你的服务对互联网可用，并确保<strong class="jt ir"> <em class="iq">每个流都有一个附属的身份</em> </strong>。也就是说，我们确切地知道，在每个TCP流的基础上，什么身份(用户)正在使用这个流。与传统的防火墙相比，这是一个非常强大的功能，在传统的防火墙中，我们必须允许来自特定网络范围的SSH流量被隐式信任。我们现在可以对这些身份识别套接字做的是重写这些防火墙规则，并用可信身份替换可信IP范围。对于那些需要严格遵守，需要回答谁(不是IP，而是身份)何时连接到什么的人来说，这是非常强大的。</p></blockquote><p id="c5dc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">我们研究了如何使用它来提供对SSH服务器的零信任远程访问。以及如何通过使用新的SSH密钥签名服务来进一步扩展它。</p><p id="aa26" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated">这就是现在，我希望你发现这是有趣和有用的。一如既往，如果您有任何问题或反馈，请随时联系我们。</p><p id="1c20" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kw kd ke kf kx kh ki kj ky kl km kn ko ij bi translated"><a class="ae my" href="https://www.youtube.com/playlist?list=PLSqlOpN6fPZ1myn5we6UcOx4ll9oteG_8" rel="noopener ugc nofollow" target="_blank">渴望更多？点击这里查看我们在Youtube上的所有演示</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nq"><img src="../Images/c50141faf9f87bb83856ef350025b69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znvT-jt5sHPuOkLZ7XoOvQ.png"/></div></div></figure></div></div>    
</body>
</html>