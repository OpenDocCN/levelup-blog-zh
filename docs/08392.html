<html>
<head>
<title>Massively Better Than Aliases — Shell Functions Speed Up Your Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比别名好得多——Shell函数加快了您的工作速度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-biggest-time-saver-for-operators-is-dead-simple-9118a1a054b8?source=collection_archive---------17-----------------------#2021-04-27">https://levelup.gitconnected.com/the-biggest-time-saver-for-operators-is-dead-simple-9118a1a054b8?source=collection_archive---------17-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f6ee" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Shell |效率|脚本|工具| K.I.S.S. |节省时间</h2><div class=""/><p id="ac11" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">你有化名，但你与它们的局限性抗争？你用不同的参数定期重复命令？你输入SQL查询来检查你的数据？那么这将大大加快你的速度！还有你的团队！</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/d966b2b97cbe33e969813996d540e7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gN3kzwPAj4b4ZiEc3SzmCg.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">卡尔·海尔达尔在<a class="ae ln" href="https://unsplash.com/collections/8953605/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="044a" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">知识共享系统</h1><p id="6974" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">生活中最美好的事情就是简单和自由。虽然下面的解决方案不是最漂亮、最现代或最具革命性的——但它非常有效，而且非常简单。我已经用了10多年了，它节省了大量的时间，同时让我可以轻松快速地处理请求或检查数据。</p><p id="4ff4" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">过去，我负责一个支付系统，有大量预定义的SQL查询来快速从数据库中获取数据，以验证错误、检查账户、支付……甚至触发操作。我不再每次都输入查询，而是在几秒钟内就能得到结果，并且查询集迅速增长，成为一个复杂的命令行管理界面。最大的好处是:我能够与团队分享这些功能，每个人都可以使用无需解释的功能，这些功能可以通过tab补全来实现。</p><h1 id="a8dd" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">利益</h1><p id="bbe2" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">在你想开始写你自己的函数之前，让我们看看它的好处。</p><ul class=""><li id="4aa1" class="mr ms it kb b kc kd kg kh kk mt ko mu ks mv kw mw mx my mz bi translated">在终端中，函数名是自动用制表符补全的，因此您不必全部记住。</li><li id="2ab4" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">函数可以调用公共函数、处理(可选)参数、运行多个命令、请求确认等等。基本上任何shell脚本能做的事情(别名不能)。</li><li id="0070" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">你可以轻松地与同事分享一组功能，例如通过git。</li><li id="832f" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">外壳函数支持开箱即用。</li><li id="f9ce" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">也可以，但对我来说，它有不同的使用情形。</li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="ab04" class="lo lp it bd lq lr nq lt lu lv nr lx ly lz ns mb mc md nt mf mg mh nu mj mk ml bi translated">用三个简单的步骤自己尝试一下</h1><h1 id="860d" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤1:为你的函数创建一个文件</h1><p id="547e" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">创建一个以<code class="fe nf ng nh ni b">.sh</code>结尾的文件，并添加您的第一个函数</p><pre class="ky kz la lb gt nv ni nw nx aw ny bi"><span id="338f" class="nz lp it ni b gy oa ob l oc od"># Hello world!<br/>function demo.helloWorld() {<br/>  if [ -z "$1" ]; then<br/>    echo "Hello World!"<br/>  else<br/>    echo "Hello $1!"<br/>  fi<br/>}</span></pre><p id="1416" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">保存它，然后在终端输入<code class="fe nf ng nh ni b">source my-functions.sh</code>——在你当前的shell中加载函数。用<code class="fe nf ng nh ni b">demo&lt;tab&gt;&lt;tab&gt;</code>试试看。</p><p id="8029" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">要在打开终端时自动包含您的功能，请将<code class="fe nf ng nh ni b">source $HOME/my-functions.sh</code>添加到您个人目录中的<code class="fe nf ng nh ni b">.bashrc</code>、<code class="fe nf ng nh ni b">.zsh</code>或<code class="fe nf ng nh ni b">.profile</code>。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="08fe" class="lo lp it bd lq lr nq lt lu lv nr lx ly lz ns mb mc md nt mf mg mh nu mj mk ml bi translated">步骤2:定义命名方案</h1><p id="9244" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">要利用制表符补全来浏览您的函数，请定义一个符合您需要的命名方案。这里有一些例子可以让你更好的理解。</p><h2 id="e551" class="nz lp it bd lq oe of dn lu og oh dp ly kk oi oj mc ko ok ol mg ks om on mk iz bi translated"><strong class="ak">案例1:数据库查询</strong></h2><p id="bec1" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">您的案例是查询用户数据库。作为输入，你通常会收到一封电子邮件，用户id，交易id，…</p><pre class="ky kz la lb gt nv ni nw nx aw ny bi"><span id="71c9" class="nz lp it ni b gy oa ob l oc od"># 1. &lt;namespace/project&gt; = mydb<br/># 2. &lt;input1&gt; = email<br/># 3. &lt;output&gt; = user<br/>mydb.email.user foo@bar.com<br/>mydb.email.user.events foo@bar.com<br/>mydb.email.user.transaction/payments/logs/actions/logins/...</span><span id="b197" class="nz lp it ni b gy oo ob l oc od"># 1. &lt;namespace/project&gt; = mydb<br/># 2. &lt;input1&gt; = user uuid<br/># 3. &lt;output&gt; = user<br/>mydb.userid.user 2fa71c31-a48a-47f3-8f65-1172eb0839ae<br/>mydb.userid.user.events/...</span></pre><p id="cb91" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这里的目的是从你所拥有的开始，例如，我有一个错误报告，并获得了用户或交易的UUID，或者…现在我想获得相关的数据和记录，如帐户、支付方式、事件…所以当我键入<code class="fe nf ng nh ni b">mydb.userid.&lt;tab&gt;&lt;tab&gt;</code>时，可用的功能应该会显示出来。</p><p id="fd1c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">查询数据库的实际“代码”可以像这样简单:</p><pre class="ky kz la lb gt nv ni nw nx aw ny bi"><span id="09d1" class="nz lp it ni b gy oa ob l oc od">devdb="psql --username=admin --expanded"</span><span id="7139" class="nz lp it ni b gy oo ob l oc od">function mydb._query() {<br/>  db=$1<br/>  query=$2<br/>  echo "$query" | $devdb $db<br/>}</span><span id="3a8a" class="nz lp it ni b gy oo ob l oc od"># Get user by UUID<br/>function mydb.userid.user() {<br/>  [...]<br/>  mydb._query user "SELECT * FROM user WHERE id='$1'"<br/>}</span></pre><p id="7da5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">一旦掌握了窍门，您可能会想到各种非常有用且更复杂的查询(连接、子查询),其输出特定于您的需求。</p><p id="ccee" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">要点是</strong>:当你需要它的时候写一次查询(并且知道它会再次被需要)，随着时间的推移重用和改进它，节省大量手工输入连接或多个查询的时间。让wiki页面充满有文档记录的查询也已经节省了时间，但是它远没有那么灵活，并且您仍然必须搜索查询并将其复制到SQL控制台中…</p><h2 id="96b2" class="nz lp it bd lq oe of dn lu og oh dp ly kk oi oj mc ko ok ol mg ks om on mk iz bi translated"><strong class="ak">案例2: GitHub问题和存储库</strong></h2><p id="37ed" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">从控制台管理git问题、分支、拉请求……因为您的开发周期可能是独立的。</p><pre class="ky kz la lb gt nv ni nw nx aw ny bi"><span id="707e" class="nz lp it ni b gy oa ob l oc od"># 1. &lt;tool&gt; = git<br/># 2. &lt;object&gt; = issue<br/># 3. &lt;action&gt; = create<br/>git.issue.create "Add feature B"<br/>git.issue.branchPush 42 # create a branch from issue and push<br/>git.issue.createPullRequest 23 # create PR from issue<br/>git.issue.close/comment/...</span></pre><p id="1b85" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">您的函数可以使用<code class="fe nf ng nh ni b">hub</code>与GitHub API通信:</p><pre class="ky kz la lb gt nv ni nw nx aw ny bi"><span id="0cef" class="nz lp it ni b gy oa ob l oc od"># Normalize a title so it can be used as branch name<br/>function git.branch.normalizeName() {<br/>  [ -z "$1" ] &amp;&amp; {<br/>    echo "Usage: $0 &lt;some issue title&gt;"<br/>    return<br/>  }<br/>  echo "$1" | tr -d "'\`" \<br/>    | sed -E 's#[\. \"\*\#\!\$\?~\^:\\]#-#g' \<br/>    | sed -E 's#-+#-#g' \<br/>    | sed -E 's#^[-/]##' \<br/>    | sed -E 's#[-/](.lock)?$##'<br/>}</span><span id="022b" class="nz lp it ni b gy oo ob l oc od"># Git function: create and push a branch<br/>function git.branch.createPush() {<br/>  if [ -z "$1" ]; then<br/>    echo "Usage: $0 &lt;branch name&gt;"<br/>    return<br/>  fi<br/>  git branch "$1" &amp;&amp; \<br/>  git checkout "$1" &amp;&amp; \<br/>  git push --set-upstream origin "$1"<br/>}</span><span id="8ebc" class="nz lp it ni b gy oo ob l oc od"># GitHub function: create and push a branch from an issue<br/># to be run in a github project directory<br/>function git.issue.branchPush() {<br/>  if [ -z "$1" ]; then<br/>    echo "Usage: $0 &lt;github issue no&gt;"<br/>    return<br/>  fi<br/>  issue=$(hub issue show $1 | head -n1)<br/>  if [ $? -ne 0 -o -z "$issue" ]; then<br/>    echo "Issue $1 not found"<br/>  elif [ -n "$(echo "$issue" | grep "CLOSED")" ]; then<br/>    echo "Issue $1 is closed"<br/>  else<br/>    name="$1-$(git.branch.normalizeName $issue)"<br/>    git.branch.createPush $name<br/>  fi<br/>}</span></pre><h2 id="b596" class="nz lp it bd lq oe of dn lu og oh dp ly kk oi oj mc ko ok ol mg ks om on mk iz bi translated"><strong class="ak">案例3:你的项目管理</strong></h2><p id="f61e" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">你能想到在你的项目中你经常触发的任务和行动吗？不属于你的发展管道？你的同事也经常执行的任务？你上一次想“要是有个小工具能帮我摆脱这种无脑的复制粘贴任务就好了……”是什么时候？或者听起来更像是“我已经有很多事情要做，现在我不得不浪费时间在数据库中搜索这个愚蠢的支持案例的交易…”</p><p id="c8de" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">为什么不在项目中添加一组功能来帮助完成这些事情，并在每次使用时节省时间。</p><p id="a04a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">命名方案:<code class="fe nf ng nh ni b">myproj.&lt;subsystem&gt;[.&lt;input1&gt;[.&lt;input2&gt;].&lt;output/action&gt;</code></p><pre class="ky kz la lb gt nv ni nw nx aw ny bi"><span id="866a" class="nz lp it ni b gy oa ob l oc od">PROJECTPATH=$HOME/git/myproject<br/>DB_CMD="docker exec -it myproj-db -- psql myproj"<br/>REDIS_CMD="docker exec -it myproj-redis -- redis-cli"</span><span id="c626" class="nz lp it ni b gy oo ob l oc od"># start up my local instance<br/>function myproj.start() {<br/>  cd $PROJECTPATH<br/>  docker-compose up<br/>}</span><span id="8dbd" class="nz lp it ni b gy oo ob l oc od"># in case of k8s, get pod by labels<br/>function myproj.userPod() {<br/>  kubectl -n myproj get pod -l mykey=value \<br/>    -o jsonpath="{ .items[0].metadata.name }"<br/>}<br/>function myproj.dbPod() {<br/>  kubectl -n myproj get pod -l component=database \<br/>    -o jsonpath="{ .items[0].metadata.name }"<br/>}</span><span id="4d35" class="nz lp it ni b gy oo ob l oc od"># and use the pod function in other functions<br/>function myproj.user.shell() {<br/>  kubectl -n myproj exec -it $(myproj.userPod) -- /bin/bash<br/>}<br/>function myproj.db.shell() {<br/>  kubectl -n myproj exec -it $(myproj.dbPod) -- psql<br/>}</span><span id="191a" class="nz lp it ni b gy oo ob l oc od"># dump user records<br/>function myproj.db.dumpUsers() {<br/>  echo "SELECT * FROM user;" | $DB_CMD<br/>}<br/>function myproj.db.trxId.userId() {<br/>  echo "SELECT user_id FROM transaction WHERE id='$1';" | $DB_CMD<br/>}</span><span id="df89" class="nz lp it ni b gy oo ob l oc od"># show redis keys for user ID<br/>function myproj.redis.get() {<br/>  $REDIS_CMD get "user:$1"<br/>}<br/># list redis keys by pattern<br/>function myproj.redis.pattern.list() {<br/>  $REDIS_CMD --scan --pattern "'$1'"<br/>}</span><span id="eea8" class="nz lp it ni b gy oo ob l oc od"># get everything we know about a transaction for debugging/review<br/>function myproj.db.trxId.dumpAll() {<br/>  userid=$(myproj.db.trxId.userId $1)<br/>  [ -n "$userid" ] &amp;&amp; myproj.db.userid.user $userid<br/>  myproj.db.trxId.orders $trxid<br/>  myproj.db.trxId.events $trxid<br/>  myproj.db.trxId.transaction $trxid<br/>}</span></pre><p id="01e3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">你可以想象，唯一的限制就是你自己的创造力。考虑到您将键入查询五个具有两个连接的表所需的所有查询…每次有人要求您研究一个问题时…想象一下您使用一个函数节省了多少时间。</p><h2 id="5e70" class="nz lp it bd lq oe of dn lu og oh dp ly kk oi oj mc ko ok ol mg ks om on mk iz bi translated">命名有什么帮助</h2><p id="3cdd" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">如前所述，使用制表符补全时，命名很方便。如果您没有完全定义您的命名方案，也不用担心，因为用户可以通过使用“tab”键简单地“探索”所有功能。</p><pre class="ky kz la lb gt nv ni nw nx aw ny bi"><span id="97e3" class="nz lp it ni b gy oa ob l oc od">$ myproj.&lt;tab&gt;&lt;tab&gt;<br/>myproj.db.dumpUsers        myproj.db.trxId.userId<br/>myproj.redis.pattern.list  myproj.db.trxId.dumpAll<br/>myproj.redis.get           myproj.start</span><span id="a7dc" class="nz lp it ni b gy oo ob l oc od">$ myproj.db.&lt;tab&gt;&lt;tab&gt;<br/>myproj.db.dumpUsers      myproj.db.trxId.dumpAll  myproj.db.trxId.userId</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="d40e" class="lo lp it bd lq lr nq lt lu lv nr lx ly lz ns mb mc md nt mf mg mh nu mj mk ml bi translated">疯狂一把</h1><p id="9c77" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">叶，已经这样了。剩下你要做的就是编写你自己的函数，无论何时你遇到一个经常重复的，或者耗时的任务。</p><h2 id="02d3" class="nz lp it bd lq oe of dn lu og oh dp ly kk oi oj mc ko ok ol mg ks om on mk iz bi translated">关于常用函数的一些想法</h2><p id="dbaf" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">一旦您的收藏增加，您会注意到重复的命令或相同问题的解决方案。以下是您可能希望考虑为其创建通用函数的一些内容:</p><ul class=""><li id="8f4b" class="mr ms it kb b kc kd kg kh kk mt ko mu ks mv kw mw mx my mz bi translated">参数检查:一个检查你是否得到了所有需要的参数和/或它们是否有效的功能。如果没有给出参数，应该打印参数的“用法”信息，以帮助探索函数。</li><li id="f78f" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">可重用函数:一个实际执行数据库查询的函数，所有其他函数都使用它。也就是说:在彼此的基础上构建函数，这样您就可以自己在函数中重用基本命令。</li><li id="ab7b" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">一种功能，用于检查环境中是否有缺失的命令，并在用户确认后有选择地安装这些命令。有点像<code class="fe nf ng nh ni b">brew doctor</code>。</li><li id="b299" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">解析ID的简单助手函数(即通过事务ID获取用户ID，反之亦然)，因为您可以使用它们在函数中获取查询某些数据所需的ID。</li><li id="f472" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">利用函数附带的变量，设置有用的默认值，但允许它们被覆盖:<code class="fe nf ng nh ni b">VAR=${VAR:-”default”}</code></li><li id="81ae" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">您正在进行大量的字符串操作，还是更喜欢用python来编写脚本？那么为什么不从shell函数中运行python脚本呢？</li><li id="9be7" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">向slack/discord/…您最喜欢的web hook端点发送通知。</li><li id="9546" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">用<code class="fe nf ng nh ni b">curl</code>做一个HTTP请求，可以选择打印标题</li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="e1bd" class="lo lp it bd lq lr nq lt lu lv nr lx ly lz ns mb mc md nt mf mg mh nu mj mk ml bi translated">摘要</h1><ul class=""><li id="bb04" class="mr ms it kb b kc mm kg mn kk op ko oq ks or kw mw mx my mz bi translated">每个人都可以即时访问shell函数——不需要任何先决条件(除非您需要一个macOS/Linux/WSL终端)。例如，通过git，团队可以很容易地共享功能。</li><li id="06c9" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">您可以像在SQL控制台中编写查询一样快地编写一个新函数，那么为什么不使它可重用并随着时间的推移改进/扩展它呢？</li><li id="35c1" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">当与允许您“探索”功能树的功能命名方案相结合时，Tab补全非常方便——对于新同事或长假后。</li><li id="34aa" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">漂亮吗？不。有关系吗？号码</li><li id="96c0" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">这很简单，可以节省你的时间去关注重要的事情。</li><li id="05a7" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">保持简单和具体。如果你需要更多，时间会证明的。</li><li id="35e1" class="mr ms it kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">将您的shell函数与其他文章中的技巧结合起来，例如这个关于有用的k8s命令的故事来自<a class="os ot ep" href="https://medium.com/u/ee642c602f6a?source=post_page-----9118a1a054b8--------------------------------" rel="noopener" target="_blank"> Maroun Maroun </a>:</li></ul><div class="ou ov gp gr ow ox"><a href="https://medium.com/better-programming/useful-kubectl-aliases-that-will-speed-up-your-coding-54960185d10" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd jd gy z fp pc fr fs pd fu fw jc bi translated">有用的Kubectl别名将加速你的编码</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">使用kubectl命令时，减少输入完整长度命令的时间，并防止令人讨厌的输入错误</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl lh ox"/></div></div></a></div></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="1318" class="lo lp it bd lq lr nq lt lu lv nr lx ly lz ns mb mc md nt mf mg mh nu mj mk ml bi translated">对你有什么帮助？</h1><p id="29bc" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">请在评论中告诉我你是如何使用自己的函数来帮助你关注重要的事情和代码的。或者哪些重复的任务可以让你再次变得愉快，因为现在做起来又快又容易。</p><p id="30ac" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我很乐意把你的情况列入疯狂例子的清单:</p><h2 id="8ee3" class="nz lp it bd lq oe of dn lu og oh dp ly kk oi oj mc ko ok ol mg ks om on mk iz bi translated">更多疯狂的例子</h2><pre class="ky kz la lb gt nv ni nw nx aw ny bi"><span id="d579" class="nz lp it ni b gy oa ob l oc od">## define subqueries and reuse them<br/>function myproj.user.multipleQueries() {<br/>  # build queries with simple strings to DRY<br/>  subquery="SELECT DISTINCT user_id FROM user WHERE type='special'"<br/>  query1="SELECT * FROM message WHERE user_id IN ($subquery)"<br/>  query2="SELECT * FROM transaction WHERE user_id IN ($subquery)"<br/>  myproj.db.query "$query1"<br/>  myproj.db.query "$query2"<br/>}</span><span id="2bd7" class="nz lp it ni b gy oo ob l oc od">## scale deployments<br/>function myproj.scale() {<br/>  [ -z "$1" ] &amp;&amp; {<br/>    echo "Usage: $0 &lt;replicas&gt;"<br/>    return<br/>  }<br/>  kubectl -n myproj scale deployment $(myproj.user.deployment) \<br/>    --replicas $1<br/>}</span><span id="45df" class="nz lp it ni b gy oo ob l oc od">## change log level<br/>function myproj.logLevel() {<br/>  loglevel=${1:-"DEBUG"}<br/>  index=$(kubectl -n myproj get deployment $(myproj.user.deployment) -o jsonpath="{ .spec.template.spec.containers[0].env|map(.name == "LOGLEVEL")|index(true)')</span><span id="49f1" class="nz lp it ni b gy oo ob l oc od">  kubectl -n myproj patch deployment $(myproj.user.deployment) --type=json -p='[{"op":"replace", "path":"/spec/template/spec/containers/0/env/'$index'/value", "value": "'$loglevel'"}]'<br/>}</span><span id="f6a7" class="nz lp it ni b gy oo ob l oc od">## tail logs of multiple pods<br/>function myproj.user.tailLogs() {<br/>  pods=$(kubectl -n user get pod -l component=service \<br/>    -o jsonpath="{ .items[*].metadata.name }")</span><span id="07f5" class="nz lp it ni b gy oo ob l oc od">  trap '<!-- -->kill $(jobs -p)' TERM INT<br/>  for p in $pods; do<br/>    kubectl -n kube-system logs --tail 10 -f $p &amp;<br/>  done<br/>  wait<br/>}</span><span id="3dc0" class="nz lp it ni b gy oo ob l oc od">## YOUR CONTRIBUTION<br/>function mycrazy.func() {<br/>  # what would you put here?<br/>}</span></pre><p id="f644" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">GitHub上的例子:</p><ul class=""><li id="0c3a" class="mr ms it kb b kc kd kg kh kk mt ko mu ks mv kw mw mx my mz bi translated">基于<code class="fe nf ng nh ni b">app.kubernetes.io/instance</code>标签的k8s功能</li></ul><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="pm pn l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">GitHub Gist上可用的函数示例</figcaption></figure></div></div>    
</body>
</html>