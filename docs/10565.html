<html>
<head>
<title>Music Recommender System — Part 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">音乐推荐系统——第六部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/music-recommender-system-part-6-4278bf89411c?source=collection_archive---------1-----------------------#2021-12-21">https://levelup.gitconnected.com/music-recommender-system-part-6-4278bf89411c?source=collection_archive---------1-----------------------#2021-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7f17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将基于ML的推荐系统部署到产品中</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/212fa4d8f60e91e63b77da3e184ad73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlGGZw1EdKoiMNqteFsQ8w.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Spotify推荐系统(SPR)</figcaption></figure><h1 id="62a4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">概述</h1><p id="436f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在<a class="ae me" href="https://medium.com/@david.de.hernandez/modeling-data-for-a-spotify-recommender-system-3056997a0fc5?sk=7ce613a3d5cbd4a69e73804983d49f91" rel="noopener">上一篇文章</a>中，我们创建了几个机器学习模型，根据用户Spotify喜爱的音乐或播放列表找出最佳推荐。</p><p id="4c3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章记录了我们如何把它们放在一起供公众使用。我们不希望我们的ML模型死在Jupyter笔记本里。我们希望将我们的模型集成到产品/应用程序中，并提供给任何用户。完整的部署过程包括三个主要步骤。</p><ol class=""><li id="6d51" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">可以轻松访问机器学习模型的API。</li><li id="d156" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">允许用户访问预测的前端应用程序。</li><li id="dd68" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">我们将部署应用程序的云/服务器。</li></ol><h1 id="bebb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建API以访问ML模型预测</h1><p id="6d4d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了通过web应用程序访问机器学习模型的结果，首先我们清理了代码，并为我们希望在应用程序中显示的每个任务/结果编写了清理函数。我们决定在web应用程序中有两个选项来接受用户的输入。第一个选项是获取任何Spotify播放列表，第二个选项是获取用户收藏夹，该选项要求用户使用其Spotify凭据自动授权我们的web应用程序。对于这两个选项，我们收集歌曲列表并提取每首歌曲的音频特征。然后，我们使用这些音频特征作为我们已经训练好的机器学习模型的测试数据，来预测用户所属的集群。找到聚类后，我们提取与用户播放列表/收藏夹相似或不相似的顶级播放列表。然后，我们显示这些热门播放列表中的热门歌曲作为我们的推荐。完整建模和预测的细节在我们的<a class="ae me" href="https://medium.com/@david.de.hernandez/modeling-data-for-a-spotify-recommender-system-3056997a0fc5?sk=7ce613a3d5cbd4a69e73804983d49f91" rel="noopener">上一篇文章</a>中有解释。</p><p id="296b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了一个SpotifyRecommender Python类，它将上述所有任务作为独立的函数。我们使用这个类作为前端应用程序的API。前端应用程序将经过训练的机器学习模型和播放列表url或用户名作为输入传递给API，并且它将接收最受推荐的歌曲作为输出。我们在这个Python类中添加了一些函数来创建必要的绘图。示例图如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/9bfae5efdb54832fbe636c0d4c48af8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkkkVZW-gsNRJHg1fBVAng.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">为我们的Web应用程序生成的图</figcaption></figure><h1 id="4044" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">前端应用程序</h1><p id="0c43" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在我们有了干净的模块化代码，我们需要一种简单的方式让任何用户与我们的机器学习模型进行交互。创建一个网站有很多框架，但是我们希望在这一部分花费尽可能少的时间，因为这不是我们项目的强制要求。所以，我们决定使用Streamlit Python库。它允许用Python创建web应用程序，而无需了解任何关于创建网站或复杂web框架的知识。他们也有很棒的文档，你可以在这里查看。现在，让我们看看如何为我们的推荐系统创建一个简单的web应用程序。</p><p id="3d29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建网站的第一步是决定布局和功能。在看了几个<a class="ae me" href="https://streamlit.io/gallery" rel="noopener ugc nofollow" target="_blank"> Streamlit应用程序的例子</a>后，我们决定有侧边栏，它将有一些按钮带用户到不同的页面。我们还决定建立页面，其中包括我们使用的数据集的信息、机器学习模型的用户输入、我们的建议、结论以及所有这些博客帖子的链接。</p><p id="7b54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在决定了每个页面的布局和内容后，下一步是安装前端所需的Streamlit库。我们已经使用requirements.txt文件安装了这个作为<a class="ae me" href="https://nsanka.medium.com/music-recommender-system-part-1-86936d673c31?sk=4278ddfebc850599db2fca4a5f2a2104" rel="noopener">创建开发环境</a>的一部分。如果不是，您可以使用pip安装，如下所示:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="3e81" class="mz lc iq mv b gy na nb l nc nd">pip install streamlit</span></pre><p id="7cf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们在streamlit文件夹中创建了一个文件app.py，并在这个文件中编写了所有的前端相关代码。在本文中，我展示了我们在应用中包含的最少代码和重要特性/改进。如果你想看完整的代码，可以在GitHub repo <a class="ae me" href="https://github.com/nsanka/RecSys" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们还使用style.css文件为按钮定义了一些样式，如下所示:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="dd57" class="mz lc iq mv b gy na nb l nc nd">body {<br/>color: rgb(45, 49, 45);<br/>background-color: #22222218;<br/>}<br/>.stButton&gt;button {<br/>width: 100%;<br/>display: inline-flex;<br/>align-items: center;<br/>justify-content: center;<br/>background-color: rgb(255, 255, 255);<br/>color: rgb(38, 39, 48);<br/>padding: .25rem .75rem;<br/>position: relative;<br/>text-decoration: none;<br/>border-radius: 4px;<br/>border-width: 1px;<br/>border-style: solid;<br/>border-color: aquamarine;<br/>border-image: initial;<br/>}<br/>.stButton&gt;button:hover {<br/>border-color: rgb(246, 51, 102);<br/>color: rgb(246, 51, 102);<br/>}<br/>.stButton&gt;button:active{<br/>box-shadow: none;<br/>background-color: rgb(246, 51, 102);<br/>color: white;<br/>}</span></pre><p id="fffc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从文档中，我们了解到，每次我们与应用程序交互时，Streamlit都会从头到尾重新运行脚本，并且每次重新运行都是在空白板上进行的。因此，代码中定义的变量不会在运行之间共享。我们发现它提供了一个名为会话状态的选项，这有助于为每个用户会话在重新运行之间共享变量。除了存储和持久化状态的能力之外，Streamlit还公开了使用来自按钮时钟或输入更改的回调来操作状态变量的能力。我们使用该选项来显示基于所选页面的正确页面信息。示例代码如下所示:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="f165" class="mz lc iq mv b gy na nb l nc nd">import streamlit as st</span><span id="0048" class="mz lc iq mv b gy ne nb l nc nd"># Sidebar<br/>def spr_sidebar():<br/>   with st.sidebar:<br/>      st.info('**Spotify Playlist Recommender**')<br/>      home_button = st.button("Home")<br/>      blog_button = st.button('Blog Posts')<br/>      if home_button:<br/>         st.session_state.app_mode = 'home'<br/>      if blog_button:<br/>         st.session_state.app_mode = 'blog'</span><span id="44c6" class="mz lc iq mv b gy ne nb l nc nd">def main():<br/>   spr_sidebar()<br/>   if st.session_state.app_mode == 'home':<br/>      home_page()<br/>   if st.session_state.app_mode == 'blog':<br/>      blog_page()<br/>   spr_footer()</span><span id="d82c" class="mz lc iq mv b gy ne nb l nc nd">def spr_footer():<br/>   st.markdown('---')<br/>   st.markdown('© Copyright 2021 - Spotify Playlist Recommender')</span></pre><p id="de30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为我们web应用程序的一部分，我们希望在页面中包含Spotify web播放器。为此，我们使用Streamlit组件API在iframe中加载Spotify播放列表URL，如下所示:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="974f" class="mz lc iq mv b gy na nb l nc nd">import streamlit as st<br/>import streamlit.components.v1 as components</span><span id="1d62" class="mz lc iq mv b gy ne nb l nc nd">playlist_uri = '37i9dQZF1DX0kbJZpiYdZl'<br/>uri_link = 'https://open.spotify.com/embed/playlist/' + playlist_uri<br/>components.iframe(uri_link, height=300)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/dc61f96f8de55c1b46a9710338681178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXgCx7YPPgZ-s4VwEZF3oQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">嵌入我们应用程序的Spotify播放列表</figcaption></figure><p id="d1e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了优化性能以预测不同用户输入的建议，我们使用Streamlit缓存机制加载了机器学习模型，该机制允许应用程序即使在从web加载数据、操作大型数据集或执行昂贵的计算时也能保持高性能。这是用<code class="fe ng nh ni mv b"><a class="ae me" href="https://docs.streamlit.io/library/api-reference/performance/st.cache" rel="noopener ugc nofollow" target="_blank">@st.cache</a></code>装饰器完成的，对所有用户都是全局的。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="566e" class="mz lc iq mv b gy na nb l nc nd">import streamlit as st</span><span id="8c62" class="mz lc iq mv b gy ne nb l nc nd">@st.cache(suppress_st_warning=True)<br/>def load_spr_ml_model():<br/>   st.session_state.ml_model = SPR_ML_Model()</span></pre><p id="81d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想提到的最后一个更新是关于我们在第2部分中定义的SPOTIPY_CLIENT_ID和SPOTIPY_CLIENT_SECRET。我们不想让公众直接看到这些，所以我们创建了”。streamlit”文件夹中，将这些变量添加到如下所示的“secrets.toml”文件中，并将该文件添加到”。gitignore”这样就不会被推送到GitHub了。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="0b24" class="mz lc iq mv b gy na nb l nc nd"># Spotify Credentials<br/>SPOTIPY_CLIENT_ID = 'Replace with your id'<br/>SPOTIPY_CLIENT_SECRET = 'Replace with your secret'<br/># Needed for user authorization<br/>SPOTIPY_REDIRECT_URI = '<a class="ae me" href="http://localhost:8080'" rel="noopener ugc nofollow" target="_blank">http://localhost:8080'</a></span></pre><p id="7f3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的web应用程序中，这些变量被视为环境变量，spotipy API调用工作正常。如果我们需要在Python代码中访问它们，我们可以使用SPOTIPY_CLIENT_ID作为ST . secrets[" spot ipy _ CLIENT _ ID "]。</p><p id="5854" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们完成了所有页面的代码编写，我们在我们的开发环境中进行了彻底的测试，并将所有代码推送到GitHub仓库。</p><h1 id="2fd1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">云/服务器</h1><p id="20f9" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">到目前为止，我们所有的工作都是在我们的开发工作区中进行的。我们有一个前端web应用程序在我们的工作区运行，允许我们访问我们的机器学习模型预测。我们希望扩展和每个人都可以访问这个网络应用程序！我们可以使用Docker封装我们的应用程序，并部署到任何云提供商，如AWS、Google Cloud和Microsoft Azure。但是，整天运行Docker映像需要一些配额/资金。对于这个项目，我们想尝试<a class="ae me" href="https://streamlit.io/cloud" rel="noopener ugc nofollow" target="_blank"> Streamlit Cloud </a>，它提供了一个部署和共享无限公共应用的平台。部署过程非常简单。</p><p id="293d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们登录Streamlit Cloud并允许它访问GitHub库。一旦我们给予回购访问权，点击新的应用程序与现有的回购，并填写如下图所示的详细信息与存储库的详细信息和主文件路径。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/92a97a06353b1584cd4fd8dcbb9a6c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6KlCaZ0r5G1iLkyh9lFyFA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用Streamlit云创建应用</figcaption></figure><p id="8fc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在“高级设置…”中，我们输入上述“secrets.toml”文件中的信息。要详细了解Streamlit Secrets的用法，可以查看这篇<a class="ae me" href="https://blog.streamlit.io/secrets-in-sharing-apps/" rel="noopener ugc nofollow" target="_blank">博客</a>。一旦我们按下Deploy按钮，Streamlit就会启动一个实例，从GitHub克隆所有代码，并运行“主文件路径”中提到的文件。最后，我们的web应用程序已经准备好了<a class="ae me" href="https://share.streamlit.io/nsanka/recsys/main/streamlit/app.py" rel="noopener ugc nofollow" target="_blank">公共URL </a>，任何人都可以访问。下面是我们最终web应用程序的演示视频。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Web应用程序演示</figcaption></figure></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="4509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢看我的文章，并想支持我，请考虑注册成为一个媒体成员。每月5美元，你可以无限制地阅读媒体上的故事。请用我的链接注册来支持我:【https://nsanka.medium.com/membership. T4】</p></div></div>    
</body>
</html>