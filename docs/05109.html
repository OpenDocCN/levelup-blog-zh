<html>
<head>
<title>Completely Type-Safe Error Handling in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中完全类型安全的错误处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/completely-type-safe-error-handling-in-python-3307c5d4c096?source=collection_archive---------7-----------------------#2020-08-04">https://levelup.gitconnected.com/completely-type-safe-error-handling-in-python-3307c5d4c096?source=collection_archive---------7-----------------------#2020-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/49e4aecb8dcb9e9881200ba3c20dd67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRFJCfKn5yubat4RbE5YmA.jpeg"/></div></div></figure><p id="8224" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我关于使用<a class="ae kz" href="https://pfun.dev/" rel="noopener ugc nofollow" target="_blank"> pfun </a>进行Python函数式编程的系列文章中，我们将看看Python的类型系统，以及如何使用它使使用<code class="fe la lb lc ld b">pfun</code>的错误处理完全类型安全。在本系列的<a class="ae kz" href="https://dev.to/suned/purely-functional-python-with-static-types-41mf" rel="noopener ugc nofollow" target="_blank">上一篇文章中，我们介绍了<code class="fe la lb lc ld b">pfun.effect.Effect</code>类型，并讨论了它如何模拟成功计算(通过称为<em class="le">的<code class="fe la lb lc ld b">A</code>类型参数模拟成功类型</em>)和错误(通过称为<em class="le">的<code class="fe la lb lc ld b">E</code>类型参数模拟错误类型</em>)。</a></p><p id="46eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回想一下<code class="fe la lb lc ld b">Effect</code>代表的功能是:</p><ul class=""><li id="8098" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">只取一个类型为<code class="fe la lb lc ld b">R</code>的参数</li><li id="badf" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">返回类型为<code class="fe la lb lc ld b">A</code>的结果或引发类型为<code class="fe la lb lc ld b">E</code>的错误</li><li id="4b5b" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">可能会也可能不会产生副作用</li></ul><p id="24c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们用一个小例子来研究这种抽象如何实现完全类型安全的错误处理。为了理解<code class="fe la lb lc ld b">Effect</code>如何启用这个特性，让我们重新检查一下将<code class="fe la lb lc ld b">Effect</code>与返回新的<code class="fe la lb lc ld b">Effect</code>的函数链接在一起的方法<code class="fe la lb lc ld b">and_then</code>:</p><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="a971" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们已经省略了实现，因为它不是特别重要(如果你愿意，你可以在<a class="ae kz" href="https://dev.to/suned/purely-functional-python-with-static-types-41mf" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中看到细节)。<em class="le">重要的是<code class="fe la lb lc ld b">and_then</code>的<em class="le">签名</em>。要了解<code class="fe la lb lc ld b">and_then</code>的类型如何启用类型安全错误处理，请考虑以下代码:</em></p><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="e99e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当在最后一行中调用<code class="fe la lb lc ld b">last</code>时，它调用<code class="fe la lb lc ld b">first</code>，这可能会以类型<code class="fe la lb lc ld b">E</code>的值失败。如果<code class="fe la lb lc ld b">first</code>成功，<code class="fe la lb lc ld b">last</code>调用<code class="fe la lb lc ld b">f</code>，结果为<code class="fe la lb lc ld b">first</code>。<code class="fe la lb lc ld b">f</code>返回<code class="fe la lb lc ld b">second</code>，也被<code class="fe la lb lc ld b">last</code>调用。但是<code class="fe la lb lc ld b">second</code>可能会因类型为<code class="fe la lb lc ld b">E2</code>的值而失败，这最终意味着<code class="fe la lb lc ld b">last</code>可能会以两种方式失败:</p><p id="c183" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，<code class="fe la lb lc ld b">last</code>的正确错误类型必须是<code class="fe la lb lc ld b">Union[E, E2]</code>，这就是你将在<code class="fe la lb lc ld b">and_then</code>的签名中发现的。</p><p id="1cf7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe la lb lc ld b">and_then</code>的返回类型中使用<code class="fe la lb lc ld b">Union</code>意味着通过将效果与简单错误类型<em class="le">自动组合</em>来构建复杂错误类型。这是非常有用的，因为它允许我们在类型检查器(如<a class="ae kz" href="https://mypy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> MyPy </a>)的帮助下推理组合效果的复杂错误，而不需要我们做任何特别的努力:我们可以简单地用简单的错误类型描述效果，将它们与<code class="fe la lb lc ld b">and_then</code>(或接受多种效果的<code class="fe la lb lc ld b">pfun.effect</code> api中的任何其他函数)组合，并让类型检查器做复杂的工作，跟踪当调用<code class="fe la lb lc ld b">Effect</code>时可能会引发哪些错误。</p><p id="9b25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们不能通过类型安全处理错误类型来消除它们，那么自动跟踪错误类型就不是特别有用。<code class="fe la lb lc ld b">pfun.effect.Effect</code>提供了<a class="ae kz" href="https://pfun.dev/effectful_but_side_effect_free/#error-handling" rel="noopener ugc nofollow" target="_blank">几种处理错误</a>的方式。我们将通过下面的例子来研究其中一个:</p><p id="f0c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您想使用<code class="fe la lb lc ld b">pfun</code>调用一个HTTP api，并将结果解析为函数式的JSON。要发出HTTP请求，您可以使用:</p><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="3db4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(当然，您不必键入<code class="fe la lb lc ld b">call_api</code>的类型，因为它可以由<code class="fe la lb lc ld b">MyPy</code>推断出来，我们在这里这样做只是因为查看类型是有益的)。</p><p id="9910" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为不是所有的字节串都是有效的JSON数据，所以让我们编写一个函数<code class="fe la lb lc ld b">parse_json</code>，将JSON数据解析为一个<code class="fe la lb lc ld b">Effect</code>。我们可以使用<code class="fe la lb lc ld b">effect.success</code>函数创建一个除了返回参数之外什么也不做的效果，使用<code class="fe la lb lc ld b">effect.error</code>函数创建一个除了参数失败之外什么也不做的效果:</p><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="a647" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者简单地使用<code class="fe la lb lc ld b">effect.catch</code>装饰器:</p><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4f4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了<code class="fe la lb lc ld b">parse_json</code>在手，我们的整个程序看起来像:</p><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="c987" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，假设我们想要确保在<code class="fe la lb lc ld b">program</code>被赋值时所有的错误都被处理。我们用来消除误差的函数叫做<code class="fe la lb lc ld b"><a class="ae kz" href="https://pfun.dev/effect_api/#pfun.effect.Effect.recover" rel="noopener ugc nofollow" target="_blank">Effect.recover</a></code>。这个函数允许我们传入一个函数来检查错误并返回一个新的效果(它可能会以新的方式失败)。</p><p id="9a27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过操作<code class="fe la lb lc ld b">HTTPException</code>来演示一下。这可以通过调用备份api来完成。在本例中，我们将简单地想象我们可以使用默认的备份响应</p><figure class="lt lu lv lw gt ju"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7d28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">typing.NoReturn</code>是一种特殊类型，表示<code class="fe la lb lc ld b">handle_http_error</code>不能为<code class="fe la lb lc ld b">Effect</code>的<code class="fe la lb lc ld b">E</code>类型变量返回值，这是让类型检查器验证<code class="fe la lb lc ld b">handle_http_error</code>不能失败。</p><p id="a1fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们当然可以以类似的方式继续操作<code class="fe la lb lc ld b">JSONDecodeError</code>，但我想你已经明白了。</p><p id="cd3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，<code class="fe la lb lc ld b">pfun.effect</code>通过纯粹的函数式编程实现了类型安全错误处理，而无需开发人员付出任何特别的努力。这很有用，因为它使我们能够使用类型检查器来验证我们的错误处理是正确的(至少在类型方面)。要了解更多关于<code class="fe la lb lc ld b">pfun</code>的信息，请查看<a class="ae kz" href="https://pfun.dev/" rel="noopener ugc nofollow" target="_blank">文档</a>或前往<a class="ae kz" href="http://github.com/suned/pfun" rel="noopener ugc nofollow" target="_blank"> github库</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="22d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="le">最初发布于dev。</em> <a class="ae kz" href="https://dev.to/suned/completely-type-safe-error-handling-in-python-3apg" rel="noopener ugc nofollow" target="_blank"> <em class="le">至</em> </a></p></div></div>    
</body>
</html>