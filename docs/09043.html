<html>
<head>
<title>When a Python Gotcha Leads to Wrong Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当Python陷阱导致错误结果时</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-a-python-gotcha-leads-to-wrong-results-2447f379fdfe?source=collection_archive---------28-----------------------#2021-06-29">https://levelup.gitconnected.com/when-a-python-gotcha-leads-to-wrong-results-2447f379fdfe?source=collection_archive---------28-----------------------#2021-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be08" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个奇怪的难以调试的带有舍入数字的Python故障</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/37bc24ec8d755f3a620f2f34f142cf75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYXoAXHHeIJ08OA3mk5F-g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</figcaption></figure><p id="8dc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我志愿担任<a class="ae lu" href="https://www.dataquest.io/" rel="noopener ugc nofollow" target="_blank"> Dataquest </a>的社区版主。有一次，我在回答一位学员提出的一个看似简单的问题。任务是写一个函数<code class="fe lv lw lx ly b">divide_apples</code>,给定两个数字(苹果和人),返回每个人的苹果数量和剩下的苹果数量。该学生编写了下面的函数(为了更好的可读性，我对它进行了轻微的重构，并更改了变量名):</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1788" class="md me it ly b gy mf mg l mh mi">def divide_apples(num_apples, num_people):    <br/>    apples_each = num_apples // num_people<br/>    apples_divided_strictly = num_apples / num_people<br/>    leftovers_per_person = apples_divided_strictly - apples_each<br/>    apples_left = int(leftovers_per_person * num_people)<br/>    return apples_each, apples_left</span></pre><p id="1fda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能不是最直接的解决方案(稍后，我们将看到一个更简洁的方案)，但无论如何，所有步骤似乎在技术上都是正确的。事实上，它在几个输入对苹果-人的情况下工作得很好，但是在37个苹果和7个人的情况下出现了问题:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d69c" class="md me it ly b gy mf mg l mh mi">num_apples = 37<br/>num_people = 7</span><span id="a8cb" class="md me it ly b gy mj mg l mh mi">print(divide_apples(num_apples, num_people))</span><span id="706e" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu">Output:<br/></strong>(5, 1)</span></pre><p id="0afc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但很明显，这种情况下剩下的苹果数应该是2，而不是1。为了调试代码，让我们再添加两个从我们的函数返回的值:<code class="fe lv lw lx ly b">apples_divided_strictly</code>(当剩余的苹果以外科医生的精度被切开，并且这些苹果块被平均分配给所有参与者)和<code class="fe lv lw lx ly b">leftovers_per_person</code>。然后，我们将再次对37个苹果和7个人运行修改后的函数:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c6f0" class="md me it ly b gy mf mg l mh mi">def divide_apples(num_apples, num_people):    <br/>    apples_each = num_apples // num_people<br/>    apples_divided_strictly = num_apples / num_people<br/>    leftovers_per_person = apples_divided_strictly - apples_each<br/>    apples_left = int(leftovers_per_person * num_people)<br/>    return apples_each, apples_left, apples_divided_strictly, leftovers_per_person <br/>    <br/>print(divide_apples(num_apples, num_people))</span><span id="4070" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu">Output:<br/></strong>(5, 1, 5.285714285714286, 0.2857142857142856)</span></pre><p id="06da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来看看<code class="fe lv lw lx ly b">apples_divided_strictly</code>的结果值。如果我们用高精度计算器<a class="ae lu" href="https://apfloat.appspot.com/" rel="noopener ugc nofollow" target="_blank">将37除以7，我们会得到一个循环十进制数:5。<strong class="la iu">285714</strong>285714285714285714285714(此处精度为31)。在我们的例子中，Python采用了这个值并将其四舍五入到16位小数:5.285714285714286。现在，让我们跳过为什么正好是16的问题，这里重要的是它正确地做了。</a></p><p id="7caa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是计算<code class="fe lv lw lx ly b">leftovers_per_person</code>，这里我们期望从<code class="fe lv lw lx ly b">apples_divided_strictly</code>(也是5)的整个部分中提取整数(5)。该操作的逻辑结果是<code class="fe lv lw lx ly b">leftovers_per_person</code>的小数部分，即0.285714285714286。然而，<code class="fe lv lw lx ly b">leftovers_per_person</code>的<strong class="la iu">实际</strong>值略有不同:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5739" class="md me it ly b gy mf mg l mh mi">Expected value: 0.285714285714286<br/>Actual value:   0.2857142857142856</span></pre><p id="5cd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到实际值多了一位小数。<strong class="la iu">更重要的是:</strong>考虑到计算该值的初始循环十进制数5.285714285714，该值在数学上舍入有误！记住这一点，让我们看看计算<code class="fe lv lw lx ly b">apples_left</code>的那条线:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f68f" class="md me it ly b gy mf mg l mh mi">apples_left = int(leftovers_per_person * num_people)</span></pre><p id="778d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">试着计算括号中的代码段，包括<code class="fe lv lw lx ly b">leftovers_per_person</code>的值(预期值和实际值)以及我们遇到技术故障的7个人:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2467" class="md me it ly b gy mf mg l mh mi">print(0.285714285714286 * 7)<br/>print(0.2857142857142856 * 7)</span><span id="cad2" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu">Output:</strong><br/>2.0000000000000018<br/>1.9999999999999991</span></pre><p id="871b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以清楚地看到问题是如何发生的！当然，<code class="fe lv lw lx ly b">int(1.9999999999999991)=1</code>，所以我们的函数会返回剩下的1个苹果，给定37个苹果和7个人。否则，使用正确舍入的值<code class="fe lv lw lx ly b">leftovers_per_person</code>(预期值)，我们将得到2个苹果，这是正确的答案。</p><p id="9659" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这仍然不是故事的结尾。Python如此糟糕地舍入了这个值，难道我们只是运气不好吗？</p><p id="b3c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们做一个小实验。数字0.285714285714285714也是一个循环十进制数，它实际上是<code class="fe lv lw lx ly b">leftovers_per_person</code>的值，我们可以(这次是正确的)舍入到任何小数点。的确，我们的实验会是在不同的小数点上四舍五入(比如从18个小数点开始递减)，再乘以7(同样的7个人)。对于每个舍入值，我们将执行两次该操作:数学上的和“python化的”。您可以在<a class="ae lu" href="https://apfloat.appspot.com/" rel="noopener ugc nofollow" target="_blank">计算器</a>中运行每个运算，检查下面报告的数学结果。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f451" class="md me it ly b gy mf mg l mh mi">print(  f'1. Python: {0.285714285714285714*7} \n   Maths:  1.999999999999999998\n'<br/>      f'\n2. Python: {0.28571428571428571*7} \n   Maths:  1.99999999999999997\n'    <br/>      f'\n3. Python: {0.2857142857142857*7} \n   Maths:  1.9999999999999999\n'<br/>      f'\n4. Python: {0.285714285714286*7} \n   Maths:  2.000000000000002\n'<br/>      f'\n5. Python: {0.28571428571429*7} \n   Maths:  2.00000000000003\n'<br/>      f'\n6. Python: {0.2857142857143*7} \n   Maths:  2.0000000000001\n'<br/>      f'\n7. Python: {0.285714285714*7} \n   Maths:  1.999999999998\n'<br/>      f'\n8. Python: {0.28571428571*7} \n   Maths:  1.99999999997\n'<br/>      f'\n9. Python: {0.2857142857*7} \n   Maths:  1.9999999999\n'<br/>      f'\n10.Python: {0.285714286*7} \n   Maths:  2.000000002\n')</span><span id="ea2f" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu">Output:<br/></strong>1. Python: 2.0 <br/>   Maths:  1.999999999999999998<br/><br/>2. Python: 2.0 <br/>   Maths:  1.99999999999999997<br/><br/>3. Python: 2.0 <br/>   Maths:  1.9999999999999999<br/><br/>4. Python: 2.0000000000000018 <br/>   Maths:  2.000000000000002<br/><br/>5. Python: 2.0000000000000298 <br/>   Maths:  2.00000000000003<br/><br/>6. Python: 2.0000000000001004 <br/>   Maths:  2.0000000000001<br/><br/>7. Python: 1.9999999999979998 <br/>   Maths:  1.999999999998<br/><br/>8. Python: 1.99999999997 <br/>   Maths:  1.99999999997<br/><br/>9. Python: 1.9999999999 <br/>   Maths:  1.9999999999<br/><br/>10.Python: 2.0000000019999997 <br/>   Maths:  2.000000002</span></pre><p id="508c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以做出如下观察:</p><ul class=""><li id="3785" class="mk ml it la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">Python将具有16个或更多小数点的值的结果四舍五入为2.0(例1–3)。严格地说，相同情况下的数学结果小于2(因此，它们中每一个的整个部分都是1)。</li><li id="936c" class="mk ml it la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">几乎在所有情况下，Python舍入都不同于数学舍入。这是由于Python在处理浮点数时的不完善。在<a class="ae lu" href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="noopener ugc nofollow" target="_blank">这篇教程</a>中，你可以读到更多关于它的内容，但简而言之，它试图将十进制数渲染成二进制数，这有时会导致怪异的结果，缺乏精度。</li><li id="1641" class="mk ml it la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">即使只考虑<strong class="la iu">的数学舍入，我们看到对于相同的运算，根据所选的精度，我们会得到一个小于2或大于2的数。这对于我们在7个人之间分配37个苹果的初始任务来说是不同的:我们需要获得2，而不是1作为最终的整数值。</strong></li></ul><p id="7eb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们返回到<code class="fe lv lw lx ly b">leftovers_per_person</code>的<strong class="la iu">预期</strong>值，即0.2828528526865在上面的列表中，它对应于情况4，对于这种情况，在数学上和than化上，我们将收到一个大于2的十进制数，因此是一个整数2，即正确的结果。这意味着在这里我们将是幸运的，只是Python再次出错，增加了一个额外的小数点，并且舍入不正确。</p><p id="767a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，我们可以使用<a class="ae lu" href="https://www.educative.io/edpresso/floor-division" rel="noopener ugc nofollow" target="_blank">地板划分</a>和<a class="ae lu" href="https://en.wikipedia.org/wiki/Modulo_operation" rel="noopener ugc nofollow" target="_blank">模数</a>以一种无陷阱(也更优雅)的方式修改我们的函数:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b649" class="md me it ly b gy mf mg l mh mi">def divide_apples(num_apples, num_people):<br/>    return num_apples // num_people, num_apples % num_people</span><span id="8877" class="md me it ly b gy mj mg l mh mi">print(divide_apples(num_apples, num_people))</span><span id="11c9" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu">Output:<br/></strong>(5, 2)</span></pre><h1 id="d63b" class="my me it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">结论</h1><p id="1bf4" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">像本文中讨论的小故障通常很难发现和调试。正如我们所见，有时它们会导致奇怪的结果，从而得出错误的结论。幸运的是，我们找到了解决这个问题的方法。此外，我们探讨了Python中舍入的一些潜在限制，以及一般数学中的限制。</p><p id="b099" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="7d00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能也会对这些文章感兴趣</p><div class="ob oc gp gr od oe"><a href="https://medium.com/geekculture/creating-toyplots-in-python-49de0bb27ec1" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">在Python 🧸中创建玩具图</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">高质量的极简交互式可视化，非常适合电子出版</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://betterprogramming.pub/read-your-horoscope-in-python-91ca561910e1" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">如何用Python阅读你的星座运势</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">用Python找乐子</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">better编程. pub</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://towardsdatascience.com/the-easiest-ways-to-perform-logical-operations-on-two-dictionaries-in-python-88c120fa0c8f" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">在Python中对两个字典执行逻辑运算的最简单方法</h2><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ou l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>