<html>
<head>
<title>Scala Journals — Algebraic Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala期刊—代数数据类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-algebraic-data-types-d4b8e84b08ef?source=collection_archive---------19-----------------------#2020-02-25">https://levelup.gitconnected.com/scala-journals-algebraic-data-types-d4b8e84b08ef?source=collection_archive---------19-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7875cb4989958b2e1ba832212d327460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kh3f-3Tv4ECchHaXNOdDwQ.jpeg"/></div></div></figure><p id="f23c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我提到过函数式编程是关于数据<strong class="kd iu"/>和操作<strong class="kd iu"/>之间非常清晰的划分。我们不把它们混在一起。一个像OO一样的设计，其中一个类有私有字段和作用于它们的方法，这是一个很好的例子。</p><p id="db7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还记得我之前提到过几次，当我想到Scala时，我会想到代数吗？如果不是对象(数据)和对它们的操作(函数)*，代数到底是什么？今天我将谈论数据块，确切地说是<code class="fe kz la lb lc b">1 + 2 = 3</code>中的“1”、“2”和“3”。</p><h1 id="3e21" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么是代数数据类型(ADTs)？</h1><p id="8a3b" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">首先，在函数式编程的上下文中<strong class="kd iu"> ADT并不意味着抽象数据类型</strong>。我听过这个错误很多次了，正如你在这篇文章后会意识到的，这是两个独立的(讽刺的是非常相反的)概念。</p><p id="9c7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好的。我们开始吧。直截了当地理解ADT非常重要，因为其背后的思想非常简单，但定义可能会非常混乱。此外，这听起来像一些疯狂的函数式编程的东西，几乎像M字…但相信我，它不是！</p><p id="3787" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">代数数据类型</strong>都是关于(并且仅仅是关于)描述数据的。这都是关于拥有和是一种关系。好消息是，如果您在使用某种ADT之前已经使用过case类。</p><p id="49ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ADT有两种基本类型:<strong class="kd iu">总和</strong>和<strong class="kd iu">乘积</strong>。让我们开始吧。</p><h1 id="9bb0" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">总和ADT</h1><p id="3887" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">可能实例数量有限的类型。把sum想象成一个<strong class="kd iu">是一个</strong>或<strong class="kd iu">或</strong>类型。</p><p id="f15c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如类型“风味”。只有一些可能的实例，并且它们是唯一被允许的(比如enum！).</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="9f04" class="mo le it lc b gy mp mq l mr ms">sealed trait Flavour<br/>case object Savoury extends Flavour<br/>case object Salty extends Flavour<br/>case object Sweet extends Flavour<br/>case object Sour extends Flavour</span></pre><p id="6608" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从以下方面考虑IS-A /或零件:</p><ul class=""><li id="f3b9" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">咸味是一种味道。</li><li id="efac" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">长<strong class="kd iu">不是</strong>的一种味道。</li><li id="a9fd" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">T21有四种口味可供选择:咸、甜、酸。</li><li id="5c74" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">味道可以是酸的<strong class="kd iu">或甜的</strong></li><li id="4776" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">味道不能同时是甜的和酸的(好吧，这是有争议的，可能不是现实生活中食物的最佳模型，但你明白了！)</li></ul><h2 id="b450" class="mo le it bd lf nh ni dn lj nj nk dp ln km nl nm lr kq nn no lv ku np nq lz nr bi translated">为什么密封trait和case对象而不仅仅是case类？</h2><p id="1b98" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">两个主要原因:我们只需要每种价值的一个实例(为什么我们需要可口的两个实例？)并且我们想在它们上面进行模式匹配。</p><p id="62b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">密封特征只能在定义它们的文件中扩展。我们不希望有人在某个随机文件中摇滚并扩展我们的基本特征(风味)。我们想看看我们的ADT，确切地知道我们正在使用什么数据模型，没有隐藏的惊喜。</p><p id="6742" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于case对象:Scala中的对象是单例的，case类是模式匹配的梦想。人们可以猜测，case对象从两个世界中各取一点，最终成为一个很容易进行模式匹配的单例对象。(然而，它们不仅仅如此——请务必查阅它们！)</p><h2 id="984a" class="mo le it bd lf nh ni dn lj nj nk dp ln km nl nm lr kq nn no lv ku np nq lz nr bi translated">我应该用Sum ADT建模什么？</h2><p id="8574" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">一般来说，当你知道所有可能的值时。有点像枚举。以下是一些想法:</p><ul class=""><li id="11c0" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">帐户状态:活动、非活动、已阻止</li><li id="4d5f" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">方向:北、南、东、西</li><li id="55be" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">季节:冬天，夏天，春天，秋天</li><li id="f322" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">性别:女性、男性、其他</li><li id="a0c6" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">大陆:欧洲，亚洲，非洲，北美，南美，南极洲，澳大利亚</li><li id="1369" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">取款人错误:没有足够的资金，帐户被冻结，资金不可用</li></ul><p id="d379" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于最后一种错误，请记住它是单例的，所以如果您不关心错误消息，请只使用Sum。顺便提一下:注意我们不会抛出异常，而是使用ADTs。ADTs在某种程度上迫使你去思考你所有的边缘案例。</p><h1 id="e3b7" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">产品ADT</h1><p id="177a" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">允许您创建具体实例的类型。把它想象成<strong class="kd iu">有</strong>或者<strong class="kd iu">和</strong>类型。</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="602b" class="mo le it lc b gy mp mq l mr ms">sealed trait Creature<br/>case class Human(name: String, dateOfBirth: Date) extends Creature<br/>case class Alien(name: String, spaceshipId: SpaceshipId) extends Creature<br/>case class Animal(name: String, dateOfBirth: Date) extends Creature</span></pre><p id="2a04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，人类、外星人和动物有某些<strong class="kd iu">特征</strong>将他们区分开来，使他们成为不同种类的生物，但为了简单起见，我们现在忽略这一点。</p><p id="98f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从以下方面考虑HAS-A / AND部分:</p><ul class=""><li id="bfa9" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">人类<strong class="kd iu">有一个</strong>名字<strong class="kd iu">和</strong>出生日期</li><li id="4e6e" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated">外星人<strong class="kd iu">有一个</strong>名字<strong class="kd iu">和</strong>一个太空飞船Id</li></ul><h2 id="489c" class="mo le it bd lf nh ni dn lj nj nk dp ln km nl nm lr kq nn no lv ku np nq lz nr bi translated">为什么要密封trait和case类？</h2><p id="d487" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">出于和sum一样的原因，我们希望所有的东西都在一个地方。Case类，因为我们希望用给定的构造函数参数实例化人类、外星人和动物，并且能够对它们进行模式匹配。</p><h2 id="036e" class="mo le it bd lf nh ni dn lj nj nk dp ln km nl nm lr kq nn no lv ku np nq lz nr bi translated">我应该使用产品ADT建立什么模型？</h2><ul class=""><li id="c82e" class="mt mu it kd b ke mb ki mc km ns kq nt ku nu ky my mz na nb bi translated">递归结构:</li></ul><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="d838" class="mo le it lc b gy mp mq l mr ms">sealed trait Person<br/>case class Child(name: String, parent: Person) extends Person<br/>case class Parent(name: String) extends Person</span></pre><ul class=""><li id="9b12" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">消息错误</li></ul><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="f6f7" class="mo le it lc b gy mp mq l mr ms">sealed trait Error<br/>case class RegistrationError(msg: String) extends Error<br/>case class LoginError(msg: String) extends Error</span></pre><ul class=""><li id="21c2" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">任何其他感觉自然的产品真的！</li></ul><h1 id="2122" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">混合ADT</h1><p id="f00d" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">尽管如此，在编程中，我们并不总是有灵丹妙药和现成的解决方案。在某些情况下，混合求和与乘积可能是有意义的。阿尔文·亚历山大的一个很好的例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="2ad8" class="mo le it lc b gy mp mq l mr ms">sealed trait Shape<br/>final case class Circle(radius: Double) extends Shape<br/>final case class Rectangle(width: Double, height: Double) extends Shape</span></pre><h1 id="ac1e" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为什么叫“和”和“积”？那是令人困惑的。</h1><p id="f946" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">有一段时间我对命名感到困惑，可能你也是。当你对命名感到困惑的时候，想想<strong class="kd iu">“我能得到的所有可能的实例列表是什么？”</strong>。</p><p id="4d4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于代数<strong class="kd iu">和</strong>，你已经指定了所有的选项(实例)。如果你把所有的都加起来，你就有了所有实例的列表。对于<code class="fe kz la lb lc b">Creature</code>，你唯一的选择是:<code class="fe kz la lb lc b">Human</code>、<code class="fe kz la lb lc b">Alien</code>和<code class="fe kz la lb lc b">Animal</code></p><p id="f65f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于代数<strong class="kd iu">乘积</strong>来说，可能有无限数量的实例。假设你的数据类型需要一个Long作为构造函数。那么你的数据可能是我的类型(1)，我的类型(23)，我的类型(235554)，我的类型(0)，我的类型(4848444)…现在想象你的数据类型接受一个Int和一个String！你必须将所有可能的字符串乘以所有可能的整型数来得到所有可能的实例。所以让我们看看…我的类型(-2147483648，"")，我的类型(-2147483647，" a ")，我的类型(-2147483646，" b)"…你明白了！</p><h1 id="28b8" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">但是如果ADT都是关于数据的，那么你怎么用它们做任何事情呢？</h1><p id="b895" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">代数又来帮忙了！</p><p id="9288" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果ADT在<code class="fe kz la lb lc b">1 + 2 = 3</code>中为“1”、“2”、“3 ”,这意味着它们只是数据的表示，并且需要对它们进行操作。听起来像是<strong class="kd iu">的功能</strong>，不是吗？</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="5e47" class="mo le it lc b gy mp mq l mr ms">sealed trait Shape<br/>final case class Circle(radius: Double) extends Shape<br/>final case class Rectangle(width: Double, height: Double) extends Shape<br/><br/>def calculateShapeArea(shape: Shape) = {<br/>    shape match {<br/>        case Circle(r)       =&gt; circleArea(r)<br/>        case Rectangle(w, h) =&gt; rectangleArea(w, h)<br/>    }<br/>}</span></pre><p id="23d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提醒一下我已经提到过几次的两条经验法则:</p><ol class=""><li id="f742" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nv mz na nb bi translated">边复制边更新，不要变异！</li><li id="5083" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nv mz na nb bi translated">写函数，不要写有字段和方法的类，记住——数据和函数是分开的，就像在代数中一样</li></ol><h1 id="a4dd" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="dcf5" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">ADT不外乎是一种表示数据的方式。有一个sum(带有case对象的密封特征)和一个product(带有case类的密封特征)。有时候想出一个混血儿也是可以的！</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="3f4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(*)如果你是一名数学家，你将不得不说很多，但让我们保持简单。</p></div></div>    
</body>
</html>