<html>
<head>
<title>Decorators and Mixins in Lightning Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lightning Web组件中的装饰者和混合者</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/decorators-and-mixins-in-lightning-web-components-18589f39b27e?source=collection_archive---------8-----------------------#2021-06-09">https://levelup.gitconnected.com/decorators-and-mixins-in-lightning-web-components-18589f39b27e?source=collection_archive---------8-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/69419263d30c14331ee9521812980751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4SEC6Jwxc_EVtNbr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@trommelkopf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">史蒂夫·哈维</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d141" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以肯定地说，如今每个现代web应用程序在某种程度上都依赖于三个基本的web标准:HTML、CSS和JavaScript。虽然HTML自HTML5标准以来已经基本稳定，但CSS和JavaScript都在继续发展，以满足开发人员和用户的需求。</p><p id="9a55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这三种技术不断发展的本质导致了<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> web组件</a>的引入，这是一种用于构建复杂web应用的跨浏览器解决方案。在这个开源标准的基础上，Salesforce开发了<a class="ae kf" href="https://lwc.dev/" rel="noopener ugc nofollow" target="_blank">Lightning Web Components</a>(LWC)作为一个快速的企业级包装器，包装普通的Web组件。结果是一个瘦的，高性能的，功能齐全的框架，完全建立在开放的网络上。</p><p id="2f8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">LWC不仅建立在ECMAScript标准之上，它还提供了一些漂亮的语法糖，可以转换成标准的JavaScript。正因为如此，LWC框架能够整合<a class="ae kf" href="https://github.com/tc39/proposals" rel="noopener ugc nofollow" target="_blank">提议的语言特性</a>，从而通过在不断发展的JavaScript生态系统中让您的代码经得起未来考验来简化应用程序开发。在本帖中，我们将仔细研究两个相对较新的特性——mixins和decorator——并看看它们如何应用在你的LWC应用中。</p><h1 id="83c3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是Mixin？</h1><p id="5fc8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在许多面向对象的编程语言中，类可以通过一个称为继承的特性“接收”额外的方法。例如，如果你有一个带有方法<code class="fe mh mi mj mk b">go</code>和<code class="fe mh mi mj mk b">stop</code>的<code class="fe mh mi mj mk b">Vehicle</code>类，子类<code class="fe mh mi mj mk b">Bicycle</code>和<code class="fe mh mi mj mk b">Car</code>可以直接实现它们:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d9f6" class="mt lf it mk b gy mu mv l mw mx">class Vehicle {<br/>  void go();<br/>  void stop();<br/>}</span><span id="e2fb" class="mt lf it mk b gy my mv l mw mx">class Bicycle &lt; Vehicle {<br/>  void go() {<br/>    usePedal();<br/>  }</span><span id="3d76" class="mt lf it mk b gy my mv l mw mx">  void stop() {<br/>    stopPedal();<br/>  }<br/>}</span><span id="7c45" class="mt lf it mk b gy my mv l mw mx">class Car &lt; Vehicle {<br/>  void go() {<br/>    useEngine();<br/>  }</span><span id="c012" class="mt lf it mk b gy my mv l mw mx">  void stop() {<br/>    stopEngine();<br/>  }<br/>}</span></pre><p id="3eca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">继承通过改变对象的层次来影响对象的组成。每一个<code class="fe mh mi mj mk b">Bicycle</code>和<code class="fe mh mi mj mk b">Car</code>现在也是一个<code class="fe mh mi mj mk b">Vehicle</code>。但是，如果您只想在对象中添加公共方法，而不处理任何父类，该怎么办呢？这就是一个<a class="ae kf" href="https://en.wikipedia.org/wiki/Mixin" rel="noopener ugc nofollow" target="_blank"> mixin </a>做的事情。</p><p id="1364" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript上下文中，mixin可以向JavaScript类添加行为，这很有用，因为类只能从一个其他类扩展，而多个mixin可以添加到一个类中。Mixins利用了<code class="fe mh mi mj mk b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank">Object.assign</a></code>方法，该方法将一个对象的所有属性复制到另一个对象上:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="403d" class="mt lf it mk b gy mu mv l mw mx">// mixin<br/>let greetingsMixin = {<br/>  sayHi() {<br/>    alert(`Hello ${this.name}`);<br/>  },<br/>  sayBye() {<br/>    alert(`Bye ${this.name}`);<br/>  }<br/>};</span><span id="fea5" class="mt lf it mk b gy my mv l mw mx">class User {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="ccd8" class="mt lf it mk b gy my mv l mw mx">// copy the methods<br/>Object.assign(User.prototype, greetingsMixin);</span></pre><p id="af79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">User</code>现在可以原生调用<code class="fe mh mi mj mk b">sayHi</code>和<code class="fe mh mi mj mk b">sayBye</code>。根据JavaScript规则，<code class="fe mh mi mj mk b">User</code>也可以只继承一个类，同时包含任意数量的mixins的属性和函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0a27" class="mt lf it mk b gy mu mv l mw mx">class User extends Person {<br/>  // ...<br/>}</span><span id="588f" class="mt lf it mk b gy my mv l mw mx">Object.assign(User.prototype, greetingsMixin);<br/>Object.assign(User.prototype, someOtherMixin);</span></pre><p id="6045" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，写出<code class="fe mh mi mj mk b">Object.assign</code>有点类似于乱丢代码。更糟糕的是，弄清楚这个方法在做什么并不是很直观。通过一些本地JavaScript语法，您实际上可以用mixin创建一个“子类工厂”,并在顶部声明您正在使用的mixin:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2c43" class="mt lf it mk b gy mu mv l mw mx">class User extends greetingsMixin(Person) {<br/>  // ...<br/>}</span></pre><p id="ed33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(关于这项技术的更多信息，请查看本文。)</p><p id="1528" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，<code class="fe mh mi mj mk b">User</code>包含了<code class="fe mh mi mj mk b">greetingsMixin</code>并继承了<code class="fe mh mi mj mk b">Person</code>类，所有这些都在一行中。</p><p id="1821" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种技巧不仅仅是语法上的糖:它实际上是LWC经常喜欢的一种。例如，<code class="fe mh mi mj mk b"><a class="ae kf" href="https://developer.salesforce.com/docs/component-library/bundle/lightning-navigation/documentation" rel="noopener ugc nofollow" target="_blank">Navigation Mixin</a></code>提供了对导航UI元素有用的方法，但是最终，包含它的每个类也应该从普通的<code class="fe mh mi mj mk b">LightningElement</code>派生:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="498d" class="mt lf it mk b gy mu mv l mw mx">import { LightningElement } from 'lwc';<br/>import { NavigationMixin } from 'lightning/navigation';</span><span id="fdac" class="mt lf it mk b gy my mv l mw mx">export default class TestComponent extends NavigationMixin(LightningElement) {<br/>  // ...<br/>}</span></pre><p id="0d80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">NavigationMixin</code>为处理页面导航的组件提供关键功能，而<code class="fe mh mi mj mk b">LightningElement</code>为每个组件提供所有基本功能。因此，<code class="fe mh mi mj mk b">TestComponent</code>将需要包含<code class="fe mh mi mj mk b">NavigationMixin</code>和<code class="fe mh mi mj mk b">LightningElement</code>的子类，并且可以以易于查看的单行格式来实现。</p><h1 id="99de" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是室内设计师？</h1><p id="5c22" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">装饰者目前是添加到JavaScript的提议，但是它们非常有用，许多框架已经支持它们。本质上，装饰器是一个可以修改类或者它的任何属性和方法的函数。这是一个相当高层次的定义，所以让我们看看它在实践中意味着什么。</p><p id="1547" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有这样一个类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="256e" class="mt lf it mk b gy mu mv l mw mx">class User {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }</span><span id="f272" class="mt lf it mk b gy my mv l mw mx">  getFullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</span></pre><p id="c7e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，任何使用这个类的代码都可以创建一个用户:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ded0" class="mt lf it mk b gy mu mv l mw mx">let user = new User("Jane", "Eyre");<br/>user.getFullName(); // returns "Jane Eyre"</span></pre><p id="9f1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是由于JavaScript的设计方式，开发人员可能会无意中更改<code class="fe mh mi mj mk b">getFullName</code>方法，如果他们愿意的话:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bedc" class="mt lf it mk b gy mu mv l mw mx">let user = new User("Jane", "Eyre");<br/>user.prototype.getFullName = function() {<br/>  return "not the name!;"<br/>}<br/>user.getFullName(); // returns "not the name!"</span></pre><p id="6781" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这显然是一个老生常谈的例子，但危险依然存在。您可以编写代码将类属性设置为只读，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d95d" class="mt lf it mk b gy mu mv l mw mx">Object.defineProperty(User.prototype, 'gettFullName', {<br/>  writable: false<br/>});</span></pre><p id="e829" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是可行的，但是为多个属性编写显然很麻烦。</p><p id="d629" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进入装饰者。您可以定义一个装饰函数，将您想要的任何行为应用于目标属性。例如，要将目标设置为<code class="fe mh mi mj mk b">writable: false</code>，您可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1fbe" class="mt lf it mk b gy mu mv l mw mx">function readonly(target) {<br/>  target.descriptor.writable = false;<br/>  return target;<br/>}</span></pre><p id="f289" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们刚刚定义了一个名为<code class="fe mh mi mj mk b">readonly</code>的装饰器，当传递一个目标时，它会将其<code class="fe mh mi mj mk b">descriptor.writable</code>属性设置为<code class="fe mh mi mj mk b">false</code>。这个可以这样应用到我们的<code class="fe mh mi mj mk b">User</code>类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0e66" class="mt lf it mk b gy mu mv l mw mx">class User {<br/>  // ...<br/>  @readonly<br/>  getFullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</span></pre><p id="f241" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">瞧啊。在一行代码中实现相同的功能。</p><p id="8e27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">LWC提供<a class="ae kf" href="https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_decorators" rel="noopener ugc nofollow" target="_blank">几个装饰器</a>给开发者使用。它们是:</p><ul class=""><li id="3b08" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated">默认情况下，每个属性都是隐藏的和私有的。<code class="fe mh mi mj mk b">@api</code>公开曝光。</li><li id="a744" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">@track</code>:这将一个属性标记为reactive，这意味着当它的值改变时，web组件将重新呈现并显示新的值。</li><li id="4898" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">@wire</code>:这是一个装饰器，表示我们想要读取Salesforce数据。</li></ul><p id="719e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这三个装饰器是LWC独有的，旨在帮助减少相同代码的重写，同时轻松提供通用功能。</p><h1 id="982a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="92de" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">由于LWC是建立在web标准之上的，它可以利用本地API和语言来让开发人员立即提高工作效率，因为他们使用的是现有的技能，而不是学习专有技术。</p><p id="1e70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想仔细看看<a class="ae kf" href="https://lwc.dev/" rel="noopener ugc nofollow" target="_blank"> Lightning Web Components </a>，<a class="ae kf" href="https://github.com/diervo/lwc-typescript-boilerplate" rel="noopener ugc nofollow" target="_blank"> Salesforce有一个内置在TypeScript </a>中的样板应用。还有一个<a class="ae kf" href="https://trailhead.salesforce.com/quests/web-components?&amp;utm_source=event&amp;utm_medium=paid&amp;utm_campaign=codemotion&amp;utm_content=webinar-promo_web_components" rel="noopener ugc nofollow" target="_blank">先导课程</a>可以帮助你在不到一个小时的时间里了解web组件。或者，随意查看<a class="ae kf" href="https://lwc.dev/" rel="noopener ugc nofollow" target="_blank">LWC开发文档</a>以获取更多具体参考信息。</p></div></div>    
</body>
</html>