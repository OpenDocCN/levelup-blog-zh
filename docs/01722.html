<html>
<head>
<title>A performance optimization of Flutter WebView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振WebView的性能优化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-performance-optimization-of-flutter-webview-6afa1a5b4300?source=collection_archive---------3-----------------------#2020-01-25">https://levelup.gitconnected.com/a-performance-optimization-of-flutter-webview-6afa1a5b4300?source=collection_archive---------3-----------------------#2020-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="08d2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">本文记录了一个基于WebView的颤振数据可视化库的性能优化:</em><a class="ae kg" href="https://github.com/entronad/flutter_echarts" rel="noopener ugc nofollow" target="_blank"><em class="kf">echarts _ Flutter</em></a><em class="kf">。</em></h2></div><p id="de7f" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">对于任何使用WebView的小部件，页面加载总是性能的关键部分。<a class="ae kg" href="https://github.com/entronad/flutter_echarts" rel="noopener ugc nofollow" target="_blank"> echarts_flutter </a>，其基础是用WebView渲染<a class="ae kg" href="https://echarts.apache.org/en/index.html" rel="noopener ugc nofollow" target="_blank"> echarts </a>的本地页面，也不例外。</p><p id="d115" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae kg" href="https://github.com/entronad/flutter_echarts" rel="noopener ugc nofollow" target="_blank"> echarts_flutter </a>加载的内容可以分为以下几部分:</p><ul class=""><li id="5f2a" class="ld le iq kj b kk kl kn ko kq lf ku lg ky lh lc li lj lk ll bi translated">模板HTML</li><li id="8fae" class="ld le iq kj b kk lm kn ln kq lo ku lp ky lq lc li lj lk ll bi translated">电子艺术脚本</li><li id="3abc" class="ld le iq kj b kk lm kn ln kq lo ku lp ky lq lc li lj lk ll bi translated">echarts扩展脚本</li><li id="aced" class="ld le iq kj b kk lm kn ln kq lo ku lp ky lq lc li lj lk ll bi translated">图表的逻辑代码</li></ul><p id="3ac0" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">模板HTML和图表的逻辑代码相当小，所以重点是加载echarts脚本和echarts扩展脚本。</p><p id="a74a" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">echarts最好的特性之一是它有许多令人敬畏的扩展，如WebGL 3D图表、GIS地图等。随着数据可视化需求变得越来越复杂，这些扩展变得不亚于echarts本身。因此，必须允许用户方便地导入扩展。此外，为了避免麻烦的资产管理，我们希望将HTML和JavaScript都作为字符串处理，这样WebView将把所有资源作为URI加载。</p><p id="7814" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">会有一些问题:</p><ul class=""><li id="7997" class="ld le iq kj b kk kl kn ko kq lf ku lg ky lh lc li lj lk ll bi translated">脚本应该放在HTML内部还是之后注入？</li><li id="f4d7" class="ld le iq kj b kk lm kn ln kq lo ku lp ky lq lc li lj lk ll bi translated">URI有一些字符限制，它需要一种安全的编码形式。</li></ul><h1 id="4721" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">原始方法</h1><p id="08af" class="pw-post-body-paragraph kh ki iq kj b kk mj jr km kn mk ju kp kq ml ks kt ku mm kw kx ky mn la lb lc ij bi translated">一开始，我们认为最好把所有东西都放在HTML中，然后一起加载。考虑到JavaScript中存在大量非法的URI字符，我们应该在合成后将HTML转换为Base64。我们不知道用户将导入什么扩展脚本，编码将由函数动态执行:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f08f" class="mx ls iq mt b gy my mz l na nb">String _getHtml(<br/>  String echartsScript,<br/>  List&lt;String&gt; extensions,<br/>  String extraScript,<br/>) {<br/>  ... // Compose and return all HTML and scripts<br/>}<br/>​<br/>​<br/>  @override<br/>  void initState() {<br/>    super.initState();<br/>    // Convert to Base64 in init<br/>    _htmlBase64 = 'data:text/html;base64,' + base64Encode(<br/>      const Utf8Encoder().convert(_getHtml(<br/>        echartsScript,<br/>        widget.extensions ?? [],<br/>        widget.extraScript ?? '',<br/>      ))<br/>    );<br/>    _currentOption = widget.option;<br/>  }<br/>​<br/>​<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return WebView(<br/>      // Load all of them<br/>      initialUrl: _htmlBase64,<br/>      ...<br/>    );<br/>  }</span></pre><h1 id="09e5" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">特性试验</h1><p id="f497" class="pw-post-body-paragraph kh ki iq kj b kk mj jr km kn mk ju kp kq ml ks kt ku mm kw kx ky mn la lb lc ij bi translated">让我们对羽毛分析进行一个简单的性能测试。测试用例有三个图表，包括一个WebGL 3D图表和一个液体动画图表:</p><figure class="mo mp mq mr gt nd gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1676ed705f1882ea4838e96af8e4736e.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*xnqF3A6nq68HHxTpMOtMHQ.jpeg"/></div></figure><p id="113c" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">使用Flutter Dev工具，我们可以得到CPU时间占用的火焰图:</p><figure class="mo mp mq mr gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/eb716d033b561feccffb7cc087ce20c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_b5BOpoUpjUY_MaiManxvQ.png"/></div></div></figure><h1 id="f2db" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">最佳化</h1><p id="ae5b" class="pw-post-body-paragraph kh ki iq kj b kk mj jr km kn mk ju kp kq ml ks kt ku mm kw kx ky mn la lb lc ij bi translated">电子海图及其扩展图的容量很大。因此，在运行时编写和转换字符串将花费大量时间。然而，这些都是获得合法URI字符串的必要步骤，那么如何解决这个问题呢？</p><p id="049e" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">抛弃“什么都一起加载”的想法，通过<code class="fe nl nm nn mt b">evaluateJavascript</code>注入动态部分，只把静态部分放在HTML里，怎么样？这可以节省一些转换工作。</p><p id="f20b" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">为了确定可行性，我们先做一个实验:只把HTML中的所有脚本都移出来，注入<code class="fe nl nm nn mt b">evaluateJavascript</code>，检查性能:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9178" class="mx ls iq mt b gy my mz l na nb">@override<br/>  void initState() {<br/>    super.initState();<br/>    _htmlBase64 = 'data:text/html;base64,' + base64Encode(<br/>      const Utf8Encoder().convert(_getHtml(<br/>        // remove all scripts form the convert function<br/>        // echartsScript,<br/>        // widget.extensions ?? [],<br/>        // widget.extraScript ?? '',<br/>      ))<br/>    );<br/>    _currentOption = widget.option;<br/>  }<br/>  <br/>  <br/>  void init() async {<br/>    final extensionsStr = this.widget.extensions.length &gt; 0<br/>    ? this.widget.extensions.reduce(<br/>        (value, element) =&gt; (value ?? '') + '\n' + (element ?? '')<br/>      )<br/>    : '';<br/>    await _controller?.evaluateJavascript('''<br/>      // inject after the page is loaded<br/>      $echartsScript<br/>      $extensionsStr<br/>      const chart = echarts.init(document.getElementById('chart'), null);<br/>      ${this.widget.extraScript}<br/>      chart.setOption($_currentOption, true);<br/>    ''');<br/>  }</span></pre><p id="4a33" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">结果是:</p><figure class="mo mp mq mr gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi no"><img src="../Images/5d6896be3cf6172e1a095369f780a183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwttEytW64Ig9zW2Ae-31Q.png"/></div></div></figure><p id="f894" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们可以看到加载HTML的时间减少了，而包含脚本注入的<code class="fe nl nm nn mt b">onPageFinished</code>的时间增加了。总时间减少了。</p><p id="46ec" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">所以看起来转换大字符串是相当耗费成本的。用<code class="fe nl nm nn mt b">evaluateJavascript</code>代替才是正道。</p><p id="04e8" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">因此，我们然后删除所有的动态转换部分，并加载模板HTML作为一个常量字符串。由于HTML现在是静态的和简短的，我们可以手动转义非法字符并直接输入UTF-8字符串，这不需要dart:convert库，看起来更简单:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5628" class="mx ls iq mt b gy my mz l na nb">const htmlUtf8 = 'data:text/html;UTF-8,&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;style type="text/css"&gt;body,html,%23chart{height: 100%;width: 100%;margin: 0px;}div {-webkit-tap-highlight-color:rgba(255,255,255,0);}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="chart" /&gt;&lt;/body&gt;&lt;/html&gt;';<br/>​<br/>​<br/>  @override<br/>  void initState() {<br/>    super.initState();<br/>    _currentOption = widget.option;<br/>  }<br/>  <br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return WebView(<br/>      initialUrl: htmlUtf8,<br/>      ...<br/>    );<br/>  }</span></pre><p id="4c50" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">测试结果是:</p><figure class="mo mp mq mr gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/2c94f1ed0d8fb338c0b1db8d71bed592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqhxwrGj8I9eSKNg97auvA.png"/></div></div></figure><p id="a0a4" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们可以看到时间进一步减少，尤其是在装载方面。</p><p id="53f3" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">因此，与原始版本相比，性能提高了很多。</p><p id="6624" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">Echarts脚本也是静态的，如果我们事先转换它并将其放入HTML:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2d88" class="mx ls iq mt b gy my mz l na nb">const echartsHtmlBase64 = '...';<br/>​<br/>  <br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return WebView(<br/>      initialUrl: echartsHtmlBase64,<br/>      ...<br/>    );<br/>  }<br/>​</span></pre><p id="e6bd" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">结果是:</p><figure class="mo mp mq mr gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nq"><img src="../Images/6a2228ec56015052d786f33f70b058ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWj8H69Gen-bbE3_-2c0fw.jpeg"/></div></div></figure><p id="07a4" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">反之，则需要更多的时间。</p><p id="750d" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">所以我们可以看到“把脚本放在HTML中”并不一定比“通过<code class="fe nl nm nn mt b">evaluateJavascript</code>注入”更好，甚至因为一些编码原因会花费更多的时间。</p><h1 id="57cd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="6917" class="pw-post-body-paragraph kh ki iq kj b kk mj jr km kn mk ju kp kq ml ks kt ku mm kw kx ky mn la lb lc ij bi translated">综上，最终的优化方案是:在UTF-8 URI字符串中加载模板HTML，用<code class="fe nl nm nn mt b">evaluateJavascript</code>注入所有脚本和逻辑代码。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="152c" class="pw-post-body-paragraph kh ki iq kj b kk kl jr km kn ko ju kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><em class="ny">注意:webview_flutter有一个问题</em> <code class="fe nl nm nn mt b"><em class="ny">onPageFinished</em></code> <em class="ny">在IOS中无法工作，所以上述优化暂时不适用于发布版本。你可以在</em> <a class="ae kg" href="https://github.com/entronad/flutter_echarts/tree/db0a452b5f6652d2b9070aa0daeae995da13cb3e" rel="noopener ugc nofollow" target="_blank"> <em class="ny">这个提交</em> </a> <em class="ny">中看到它的源代码。</em></p></div></div>    
</body>
</html>