<html>
<head>
<title>Understanding the Sliding Window Technique in Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解算法中的滑动窗口技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-the-sliding-window-technique-in-algorithms-c6c3bf8226da?source=collection_archive---------4-----------------------#2020-09-29">https://levelup.gitconnected.com/understanding-the-sliding-window-technique-in-algorithms-c6c3bf8226da?source=collection_archive---------4-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a5f1126656d5598de80951514452b0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LkJaCNC1y8fF7juq"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@mooo3721?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> R莫</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="5315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了在我之前的帖子中展示的<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/using-two-pointer-technique-to-optimize-algorithm-solutions-49271becb34d">双指针技术</a>，我一直在探索另一个流行的算法心智模型:滑动窗口<strong class="ki iu"/>。</p><p id="7b8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你从未听说过滑动窗口技术，我强烈推荐你在深入下面的例子之前看一下这个视频教程。即使你没有36分钟的空闲时间，也一定要观看前8分钟，其中包含多个执行良好的动画。</p><h1 id="b12e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是滑动窗口技术？</h1><p id="aa8c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">顾名思义，这种技术包括从给定的数组或字符串中提取数据子集，扩展或收缩该子集以满足某些条件，因此产生了<strong class="ki iu">滑动</strong>效应。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/dec3e9f0fe42a1429b7f87cca82103c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*80T-H4ETYfHvRH6o.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="mm"> via </em> <a class="ae kf" href="https://www.youtube.com/watch?v=MK-NZ4hN7rs" rel="noopener ugc nofollow" target="_blank"> <em class="mm">简单工程师视频</em> </a></figcaption></figure><h1 id="bf55" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们什么时候能使用它？</h1><p id="961f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">一般来说，当您需要跟踪一个<strong class="ki iu">连续的</strong>元素序列时，滑动窗口技术是有用的，比如对子数组中的值求和。</p><p id="a930" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个经典的例子(由柯尔特·斯蒂尔的Udemy课程提供):</p><blockquote class="mn mo mp"><p id="7f33" class="kg kh mq ki b kj kk kl km kn ko kp kq mr ks kt ku ms kw kx ky mt la lb lc ld im bi translated"><em class="it">给定一个正整数数组和一个正整数，<br/>写一个函数，返回一个连续子数组的</em> <strong class="ki iu"> <em class="it">最小长度</em> </strong> <em class="it">，<br/>，其中和大于等于传入的整数。如果没有，返回0。</em></p></blockquote><p id="96cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是一些测试案例:</p><pre class="mi mj mk ml gt mu mv mw mx aw my bi"><span id="c261" class="mz lf it mv b gy na nb l nc nd">minSubArrayLen([2, 3, 1, 2, 4, 3], 7) // 2 -&gt; [4, 3] is the smallest subarray<br/>minSubArrayLen([3, 1, 7, 8, 62, 18, 9], 52) // 1 -&gt; [62] is the smallest subarray<br/>minSubArrayLen([1, 4, 16, 22, 5], 95) // 0</span></pre><p id="8f4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现这个挑战的滑动窗口技术，我们需要首先确定窗口的范围。在这种情况下，我们从左边“打开”窗口。</p><p id="40ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们需要将值的总和存储在封闭的子数组/窗口中，并将其与目标整数进行比较。</p><p id="5b93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果总和满足条件(大于或等于整数)，我们记录当前窗口范围的长度并不断缩小窗口，因为我们需要找到最小的<strong class="ki iu">长度。</strong></p><p id="c4bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果总和不满足条件，那么我们继续扩展窗口的右边面板(因为我们从左边开始迭代)。</p><p id="7f22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果总和没有达到目标，我们就跳出循环，返回0。</p><p id="ee68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">综合起来看:</p><pre class="mi mj mk ml gt mu mv mw mx aw my bi"><span id="ec95" class="mz lf it mv b gy na nb l nc nd">function minSubArrayLen(arr, target) {<br/>  let minLength = Infinity<br/>  let sum = 0<br/>  let left = 0<br/>  let right = 0</span><span id="2ec2" class="mz lf it mv b gy ne nb l nc nd">  while (left &lt; arr.length) {</span><span id="7cdb" class="mz lf it mv b gy ne nb l nc nd">    if (sum &gt;= target) {<br/>      // store the current minimal length<br/>      minLength = Math.min(minLength, (right - left))<br/>      // shrink the window: <br/>      // (1) subtract the value at left idx<br/>      // (2) move the left panel one index further to the right<br/>      sum -= arr[left]<br/>      left++<br/>    } else if (sum &lt; target &amp;&amp; right &lt; arr.length) {<br/>      // expand the window:<br/>      // (1) sum up the current value<br/>      // (2) move the right panel one index further to the right<br/>      sum += arr[right]<br/>      right++<br/>    } else {<br/>      break<br/>    }</span><span id="9f9a" class="mz lf it mv b gy ne nb l nc nd">  }</span><span id="0bb0" class="mz lf it mv b gy ne nb l nc nd">  return minLength === Infinity ? 0 : minLength<br/>}</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="2e82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用滑动窗口技术，我们能够以O(n)时间复杂度解决上述问题，消除了重复迭代的需要。向发明这个强大工具的人/团队致敬！</p></div></div>    
</body>
</html>