<html>
<head>
<title>Flutter — Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter —认证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-authentication-adb8df7cf673?source=collection_archive---------5-----------------------#2022-12-01">https://levelup.gitconnected.com/flutter-authentication-adb8df7cf673?source=collection_archive---------5-----------------------#2022-12-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/2ec9f527f92f0f8a270a01bbce878fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JF2y6JzBqzGKLAn6NymTNg.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated"><a class="ae jh" href="/@simbu/membership" rel="noopener ugc nofollow" target="_blank">加入媒体</a>查看我所有的<a class="ae jh" href="https://medium.com/@simbu/simbus-articles-d9b999b115a7" rel="noopener">文章</a>。</figcaption></figure><div class=""/><blockquote class="kh ki kj"><p id="7977" class="kk kl km kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated"><strong class="kn jl">认证</strong>(来自希腊语:αὐθεντικός·authentikos，“真实的，真实的”，来自αὐθέντης·奥森特斯，“作者”)</p><p id="9e57" class="kk kl km kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated"><a class="ae jh" href="https://en.wikipedia.org/wiki/Authentication" rel="noopener ugc nofollow" target="_blank">维基</a></p></blockquote><p id="61ae" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">如果我相信我知道你是谁，那么我可以给你访问你的个人申请数据。</p><p id="3f90" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">身份验证可能是应用程序必须处理的最大的交叉问题。</p><p id="7ffa" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">将它作为一个特性添加到<a class="ae jh" href="https://gitlab.com/simbu-mobile/digestableprologue" rel="noopener ugc nofollow" target="_blank"> DigestablePrologue </a>中，通过更新一组代码，我们可以多次提取和重用它，并减少维护。</p><p id="6211" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">让我们从一个高层次的、有意模糊的业务需求开始:</p><blockquote class="kh ki kj"><p id="a301" class="kk kl km kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">应用程序将能够使用现代身份认证来保护对屏幕和API的访问</p><p id="4cc1" class="kk kl km kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">命题部的朱莉娅</p></blockquote><p id="02e2" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">在最初的对话之后，我们决定在一定程度上接受需求:</p><ul class=""><li id="2ac8" class="lm ln jk kn b ko kp ks kt lj lo lk lp ll lq li lr ls lt lu bi translated">向上滑动登录屏幕。</li><li id="b1e9" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated">使用微软AD或谷歌Firebase进行认证。</li><li id="3fcc" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated">在设置中注销。</li></ul><p id="86f4" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">然后，我们举办了一个研讨会，通过示例创建规范:</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/4ddef2e6b329253831acc14f2426238e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Jwti843U7_vUWcRs4BNN2A.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">登录向上滑动规范</figcaption></figure><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/842aa714eb868f98d7c351b512651bf7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9biWb6pyUezkF0V6YpleYQ.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">授权服务规范</figcaption></figure><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/1efa696914e6e06089d2ac09f571e312.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4C0iKOQ71mDIdsyLyadC-w.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">注销设置规范</figcaption></figure><p id="2664" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">并将它们转换成可执行的规范:</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/7dd2bb9112777c6df14659984db99420.png" data-original-src="https://miro.medium.com/v2/format:webp/1*iPWw7_S9ohU2mf32YGY1-w.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">登录屏幕功能测试</figcaption></figure><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/76c07b9dbbfa1c2006eed8b2b3f1018d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_FWnd9Rt8Um5-Swn2zxIgQ.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">认证服务功能测试</figcaption></figure><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/32a29534246df615a05aef15a7a6ca69.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-ZDA4gcjosI5in2kCYA5jA.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">注销设置功能测试</figcaption></figure><p id="d852" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">为了减少这篇文章的长度，我已经部分实现了注销设置，跳过了即将添加的实现AD &amp; Firebase认证服务。</p><p id="d0b7" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">结果，特性测试的结果不再完全反映最初的规格，但是一旦你陷入细节中，范围或方向的改变是正常的。</p><p id="5f7f" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">我发表的所有关于身份验证和数据访问的文章将很快被汇总成一篇摘要文章，即一个迷你系列。</p><h2 id="f519" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">哒哒</h2><p id="a8fd" class="pw-post-body-paragraph kk kl jk kn b ko my kq kr ks mz ku kv lj na ky kz lk nb lc ld ll nc lg lh li in bi translated">该环境是从app_config.json文件中读取的，该文件是在应用程序启动时加载的，并由用于live和UAT的<a class="ae jh" href="https://codemagic.io" rel="noopener ugc nofollow" target="_blank"> CodeMagic </a>集成构建注入:</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/9745219c4768e27d8bdfb9db93da83c9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*juR6z7wFsANwlaiJsFY40A.png"/></div></figure><p id="40f7" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">基于环境选择身份验证服务:</p><pre class="ma mb mc md gu nd ne nf ng aw nh bi"><span id="12f5" class="mf mg jk ne b gz ni nj l nk nl">AuthenticationServiceStateNotifier selectAuthenticationServiceByEnvironment() {<br/>  var environment = GlobalEnvironmentValues.instance.environment;<br/><br/>  AuthenticationService authenticationService = environment == Environments.live<br/>      ? LiveAuthenticationService()<br/>      : environment == Environments.uat<br/>          ? UatAuthenticationService()<br/>          : StubbedAuthenticationService();<br/><br/>  return AuthenticationServiceStateNotifier(authenticationService);<br/>}<br/><br/>final authenticationServiceProvider = StateNotifierProvider&lt;<br/>    AuthenticationServiceStateNotifier, AuthenticationService&gt;(<br/>  (ref) =&gt; selectAuthenticationServiceByEnvironment(),<br/>);</span></pre><p id="ff2f" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">当应用程序启动时，它会检测存根验证服务并自动验证用户:</p><pre class="ma mb mc md gu nd ne nf ng aw nh bi"><span id="7f17" class="mf mg jk ne b gz ni nj l nk nl">if (ref.read(authenticationServiceProvider).typeName ==<br/>        AuthenticationService.authenticationServiceTypeNameStubbed) {<br/>        ref.read(authenticationProvider.notifier).setIsAuthenticated(true);<br/>}</span></pre><p id="12c8" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">设置屏幕是使用一个很棒的包<a class="ae jh" href="https://pub.dev/packages/settings_ui" rel="noopener ugc nofollow" target="_blank"> settings_ui </a>添加的，它允许用户注销，并调用认证服务上的注销方法:</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/b8581b5f7cc6832e1f54d1d8310efa02.png" data-original-src="https://miro.medium.com/v2/format:webp/1*eJkk7GuyMpilFwpsWAgbig.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">注销设置</figcaption></figure><p id="f5a9" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">所有这些都包含在我们的自动化功能测试中:</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/bc1f9351210e2e34e3157fee59f04333.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ru7HkB4CRJ7RJnJnupGH9g.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">登录功能测试报告</figcaption></figure><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/2aacb9c8d29689fb17529c85e1704cc5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*tnc801WIbqpVErQF47JuMg.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">认证功能测试报告</figcaption></figure><p id="2e87" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">在未来的帖子中，当我们添加UAT和实时环境时，它将在未经身份验证时路由到登录屏幕，并调用真正的身份验证服务来获取访问令牌，这些令牌将由<a class="ae jh" href="https://flutterdata.dev" rel="noopener ugc nofollow" target="_blank"> Flutter Data </a>用来发出安全的API请求。</p><p id="17c5" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">登录屏幕和认证服务已添加到<a class="ae jh" href="https://gitlab.com/simbu-mobile/digestableprologue" rel="noopener ugc nofollow" target="_blank">digestable prolog</a>和<a class="ae jh" href="https://gitlab.com/simbu-mobile/digestibleme" rel="noopener ugc nofollow" target="_blank"> DigestableMe </a>的设置屏幕。</p><h2 id="53dd" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">经验值</h2><h2 id="52c8" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">引发导航事件</h2><p id="2a22" class="pw-post-body-paragraph kk kl jk kn b ko my kq kr ks mz ku kv lj na ky kz lk nb lc ld ll nc lg lh li in bi translated">为了响应导航，我在GoRouter上增加了一个观察者</p><pre class="ma mb mc md gu nd ne nf ng aw nh bi"><span id="7143" class="mf mg jk ne b gz ni nj l nk nl">MaterialApp.router(<br/>	...<br/>    navaigationObservers: [<br/>       NavigationEventsObserver(ref.read(eventStoreProvider))<br/>    ],<br/>	...<br/>)</span></pre><p id="388f" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">每次导航发生时，它都会在事件总线上引发一个导航事件:</p><pre class="ma mb mc md gu nd ne nf ng aw nh bi"><span id="c513" class="mf mg jk ne b gz ni nj l nk nl">/// Raises Nativigated events when the GoRouter navigates.<br/>class NavigationEventsObserver extends NavigatorObserver {<br/>  final EventStore eventStore;<br/>  NavigationEventsObserver(this.eventStore);<br/>  <br/><br/>  @override<br/>  void didPush(Route&lt;dynamic&gt; route, Route&lt;dynamic&gt;? previousRoute) {<br/>    raiseNavigatedEvent(route.settings.name ?? "");<br/>  }<br/><br/>  @override<br/>  void didPop(Route&lt;dynamic&gt; route, Route&lt;dynamic&gt;? previousRoute) {<br/>    raiseNavigatedEvent(route.settings.name ?? "");<br/>  }<br/><br/>  @override<br/>  void didReplace({ Route&lt;dynamic&gt;? newRoute, Route&lt;dynamic&gt;? oldRoute }) {<br/>    raiseNavigatedEvent(newRoute?.settings.name ?? "");<br/>  }<br/>  <br/>  void raiseNavigatedEvent(String routeName) {<br/>    even(fn)tStore.bus.fire(Navigated(routeName));<br/>  }<br/>}</span></pre><p id="d85e" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">然后，测试可以用它来证明一个导航动作已经发生，目前事件存储只保存最后一个导航事件。</p><p id="2630" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">很可能我会扩展它，通过监听事件并记录它们来添加应用程序监控。</p><h2 id="c666" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">Flutter应用生命周期</h2><p id="7a9e" class="pw-post-body-paragraph kk kl jk kn b ko my kq kr ks mz ku kv lj na ky kz lk nb lc ld ll nc lg lh li in bi translated">为了在唤醒时执行所需的身份验证，我需要用一个覆盖来捕获应用程序状态(<a class="ae jh" href="https://api.flutter.dev/flutter/dart-ui/AppLifecycleState.html" rel="noopener ugc nofollow" target="_blank">applifecyclast</a>)。</p><pre class="ma mb mc md gu nd ne nf ng aw nh bi"><span id="b89b" class="mf mg jk ne b gz ni nj l nk nl">@override<br/>  void didChangeAppLifecycleState(AppLifecycleState state) {<br/>    ref.read(appLifecycleStateProvider.notifier)<br/>		.setLifecycleState(state);<br/>    ref.read(authenticationServiceProvider.notifier)<br/>		.checkAuthenticated();<br/>  }</span></pre><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/dd08ccaf62d505e34c031a6348d4ce91.png" data-original-src="https://miro.medium.com/v2/format:webp/1*baQbacdiWjJIu9Vjd__0lw.png"/></div></figure><p id="42a1" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">可观察的生命周期事件(AppLifecycleState):</p><ul class=""><li id="3226" class="lm ln jk kn b ko kp ks kt lj lo lk lp ll lq li lr ls lt lu bi translated"><strong class="kn jl">非活动</strong> —应用程序处于非活动状态，不接收用户输入。这个事件只在iOS上有效，因为在Android上没有对应的事件</li><li id="4bc2" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated"><strong class="kn jl">暂停</strong> —应用程序当前对用户不可见，不响应用户输入，在后台运行。这相当于Android中的onPause()</li><li id="8dcd" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated"><strong class="kn jl">恢复</strong> —应用程序可见并响应用户输入。这相当于Android中的onPostResume()</li><li id="009a" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated"><strong class="kn jl">暂停</strong> —应用程序暂时暂停。这相当于Android中的onStop它不会在iOS上触发，因为在iOS上没有对应的事件</li></ul><h2 id="b3ed" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">特性测试支持你</h2><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/83f8039dd7ec14cb9d58ee9c739833d7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*O_A89vay0OdsoZcGET3gaw.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">功能测试让我们知道我们已经破坏了其他功能</figcaption></figure><p id="0b3a" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">这很好，我做了一些相当大的改变，但我知道我需要修复什么来避免任何回归错误。</p><p id="9e83" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">测试契约确保了应用程序仍然能够完成早期功能的目标。</p><h2 id="4ae9" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">功能测试认证</h2><p id="420a" class="pw-post-body-paragraph kk kl jk kn b ko my kq kr ks mz ku kv lj na ky kz lk nb lc ld ll nc lg lh li in bi translated">事实证明，通过特性测试非常棘手，但是为了确保身份验证按计划进行，让它们就位是值得的。</p><p id="b565" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">主要问题是环境是在测试步骤运行之前从文件加载的，这意味着我们已经运行了逻辑来检查身份验证并重定向到登录屏幕。</p><p id="d24d" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">在几次通过代码改变环境的尝试失败后，我选择了一套独立的特性测试:</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/23bbe288d68c879b8b365d5ef8fa6e92.png" data-original-src="https://miro.medium.com/v2/format:webp/1*cezC6_NojWRFevBIp1NxVA.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">加载实时配置值文件的Gherkin特性测试配置。</figcaption></figure><p id="4cd6" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">加载不同的环境配置文件:</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/8ea60aac7a107235be339fec63690128.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Q0jcn6ImpPzH4jQWpLMuXA.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">实时配置值文件</figcaption></figure><p id="bf10" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">这需要更多的维护，但也是必要的，因为我们将在集成和部署构建中注入配置文件，以保护机密值。</p><h2 id="500c" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">使用事件来解决难以实现的功能测试步骤</h2><p id="38f2" class="pw-post-body-paragraph kk kl jk kn b ko my kq kr ks mz ku kv lj na ky kz lk nb lc ld ll nc lg lh li in bi translated">一些登录功能步骤很难测试，因为该功能将在使用微应用<a class="ae jh" href="https://gitlab.com/simbu-mobile/digestableprologue" rel="noopener ugc nofollow" target="_blank"> DigestablePrologue </a>的父应用<a class="ae jh" href="https://gitlab.com/simbu-mobile/digestibleme" rel="noopener ugc nofollow" target="_blank"> DigestableMe </a>中实现:</p><pre class="ma mb mc md gu nd ne nf ng aw nh bi"><span id="6028" class="mf mg jk ne b gz ni nj l nk nl">When: Making an API request</span></pre><p id="6a5e" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">这意味着我们不能在<a class="ae jh" href="https://gitlab.com/simbu-mobile/digestableprologue" rel="noopener ugc nofollow" target="_blank">digestable prolog</a>中导航到屏幕或发出API请求。</p><p id="1176" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">这是一个耦合问题，我们可以使用事件总线来解决。</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/61ca11f7260c4b4c4c1c75e30808f2a7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CGedgO0TsouLEvbq62n7rw.png"/></div></figure><p id="6912" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">应用程序现在只是监听事件并采取适当的行动，允许我们只在步骤中引发事件，而不是实际的导航或API调用。</p><p id="c24e" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">何时:生成API请求事件:API请求</p><p id="1ee3" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">使用EventBus还有其他好处，我们可以在以后添加，比如记录引发的事件。</p><h2 id="2b54" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">规程—实施特征步骤</h2><p id="ec8b" class="pw-post-body-paragraph kk kl jk kn b ko my kq kr ks mz ku kv lj na ky kz lk nb lc ld ll nc lg lh li in bi translated">使用Flutter Gherkin最繁琐的部分是创建所有的步骤方法，我将尝试使用构建器来自动完成这一工作，创建包含要填写的基本步骤的文件。</p><p id="c566" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">与此同时，我使用可视化代码中的突出显示来手动执行这些操作，以规范所需的步骤，例如:</p><figure class="ma mb mc md gu iw gi gj paragraph-image"><div class="ab gv cl me"><img src="../Images/f4af896f9aaf85091aabb6ffd922a159.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OD-hh8ohb9jwXgV8O3aB-Q.png"/></div></figure><p id="c426" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">对此:</p><pre class="ma mb mc md gu nd ne nf ng aw nh bi"><span id="c275" class="mf mg jk ne b gz ni nj l nk nl">Given: Always on authentication<br/>And: Not authenticated<br/>And: authenticated<br/><br/>When: The application is started<br/>When: The application awakes<br/>When: Making an API request <br/>When: Displaying a restricted screen<br/>When: Displaying an unrestricted screen<br/><br/>Then: The application routes to the 'Login Screen'<br/>And: Records the current screen for redirection</span></pre><p id="1239" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">然后将框架方法添加到step文件中</p><h2 id="fd12" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">不重要的</h2><h2 id="3a14" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">路线授权</h2><p id="eab3" class="pw-post-body-paragraph kk kl jk kn b ko my kq kr ks mz ku kv lj na ky kz lk nb lc ld ll nc lg lh li in bi translated">用自定义属性赋予路由角色，那么就可以实现基于非角色，每个人都有，但是可以扩展。</p><p id="f0d3" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated">没有实现与登录/id/认证的限制屏幕，因为它的一些不同的东西，它的授权和路线警卫，需要时通过GoRouter重定向作为警卫。</p><h2 id="68c7" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">链接</h2><ul class=""><li id="075a" class="lm ln jk kn b ko my ks mz lj nm lk nn ll no li lr ls lt lu bi translated"><a class="ae jh" href="https://jimmybogard.com/message-naming-conventions/" rel="noopener ugc nofollow" target="_blank">消息命名约定</a></li><li id="32bb" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated"><a class="ae jh" href="https://richygreat.medium.com/how-to-name-events-in-event-driven-architecture-cc962d93ed60%0A" rel="noopener">如何在事件驱动架构中命名事件</a></li><li id="ed27" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated"><a class="ae jh" href="https://medium.com/jay-tillu/interface-in-dart-5da3b139a3ea" rel="noopener">飞镖:接口</a></li><li id="b12f" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated"><a class="ae jh" href="https://medium.com/pharos-production/flutter-app-lifecycle-4b0ab4a4211a" rel="noopener"> Flutter App生命周期</a></li><li id="db55" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated"><a class="ae jh" href="https://api.flutter.dev/flutter/dart-ui/AppLifecycleState.html" rel="noopener ugc nofollow" target="_blank">应用循环地产</a></li></ul><h2 id="9f2b" class="mf mg jk bd mh mi mj dn mk ml mm dp mn lj mo mp mq lk mr ms mt ll mu mv mw mx bi translated">包装</h2><ul class=""><li id="bb15" class="lm ln jk kn b ko my ks mz lj nm lk nn ll no li lr ls lt lu bi translated"><a class="ae jh" href="https://pub.dev/packages/event_bus" rel="noopener ugc nofollow" target="_blank">事件_总线</a></li><li id="6256" class="lm ln jk kn b ko lv ks lw lj lx lk ly ll lz li lr ls lt lu bi translated"><a class="ae jh" href="https://pub.dev/packages/settings_ui" rel="noopener ugc nofollow" target="_blank">设置_ui </a></li></ul></div><div class="ab cl np nq hy nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="in io ip iq ir"><p id="6674" class="pw-post-body-paragraph kk kl jk kn b ko kp kq kr ks kt ku kv lj kx ky kz lk lb lc ld ll lf lg lh li in bi translated"><a class="ae jh" href="https://medium.com/@simbu/membership" rel="noopener">订阅</a>查看所有<a class="ae jh" href="/@simbu/flutter-digestableme-articles-4b39de2d82fc" rel="noopener ugc nofollow" target="_blank">文章</a>，或者查看<a class="ae jh" href="/@simbu/flutter-digestableme-code-ecb5027fb7b1" rel="noopener ugc nofollow" target="_blank">代码</a>。</p></div></div>    
</body>
</html>