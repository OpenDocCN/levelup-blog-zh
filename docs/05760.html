<html>
<head>
<title>2 Ways to Execute MVVM iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">执行MVVM iOS的两种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/2-ways-to-execute-mvvm-ios-5c47d60ebcd0?source=collection_archive---------5-----------------------#2020-09-29">https://levelup.gitconnected.com/2-ways-to-execute-mvvm-ios-5c47d60ebcd0?source=collection_archive---------5-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b35f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MVVM不必与RxSwift绑定，但最好是这样。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a51a5f70a3d0c83ef937600e2384abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wWHqBLHozU1DYi_c"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@coinviewapp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CoinView App </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于移动应用程序开发，MVVM是现代建筑。它执行了更好的关注点分离，使代码更加清晰。正如我们在上一篇文章中所讨论的，MVVM通过将ViewModel中的变量绑定到ViewController元素来改进业务逻辑和视图之间的通信。本文将介绍两种实现MVVM的方法。</p><h1 id="06c6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">MVVM和斯威夫特</h1><p id="32e1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要执行没有依赖的双向绑定，我们需要创建自己的可观察对象。下面是代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="16b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">Observable&lt;T&gt;</code>是一个自定义类，可以保存类型为<code class="fe mu mv mw mx b">T</code>的值。如果值改变了，那么我们触发<code class="fe mu mv mw mx b">didSet</code>，它调用绑定函数，将值传递回调用者。举个具体的例子，让我们来看看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们关注第1部分，我们将<code class="fe mu mv mw mx b">cellViewModels</code>绑定到<code class="fe mu mv mw mx b">reloadTableViewClosure</code> , <code class="fe mu mv mw mx b">isLoading</code>绑定到<code class="fe mu mv mw mx b">updateLoadingStatus</code>,<code class="fe mu mv mw mx b">alertMessage</code>绑定到<code class="fe mu mv mw mx b">showAlertClosure</code>。</p><p id="fce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ViewController中，我们将闭包与UI元素绑定在一起，然后我们可以在ViewModel中触发任何异步请求。在上面的代码中，它是3号<code class="fe mu mv mw mx b">initFetch()</code>。它请求API，如果发生错误，它更新<code class="fe mu mv mw mx b">alertMessage</code>变量，如果请求成功，它更新<code class="fe mu mv mw mx b">cellViewModels</code>变量。这两个变量的更改都将更新ViewController中的UI。</p><p id="096d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有双向绑定。</p><h1 id="c4bf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">MVVM与RxSwift</h1><p id="1643" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有了RxSwift，双向绑定变得更加容易。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们可以很容易地识别出<code class="fe mu mv mw mx b">Input</code>持有可观察变量以接受来自ViewController的事件，而<code class="fe mu mv mw mx b">Output</code>持有可观察变量以绑定ViewController中的UI元素。init函数初始化依赖关系，处理来自API的数据，初始化输入和输出。</p><p id="c77b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是ViewController代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mu mv mw mx b">ViewDidLaod()</code>中，我们应用<code class="fe mu mv mw mx b">setupBinding() </code>和<code class="fe mu mv mw mx b">setupErrorBinding()</code>将UI元素与ViewModel中的observables绑定。当所有的绑定都准备好了，我们有<code class="fe mu mv mw mx b">self.articleViewModel.input.reload.accept(())</code>来拉动数据流触发器。然后，来自Api的异步数据可以自动反映在ViewController上。</p><h1 id="620b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后的想法</h1><p id="0f38" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面的图表展示了双向绑定是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0c4cf46a4d74c84490d0616c9217eecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*zvGl3_cAeCqXQFn16RAHuw.png"/></div></figure><p id="a288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在请求数据之前，UI元素必须首先在ViewModel中绑定输出和输入。就像隧道已经建成。</p><p id="69ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以触发数据流，这是图表。ViewController可以将多个UI元素绑定到多个输入和输出。有了这种数据流，代码将更易读、更简短。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/eb1afa5c644c610adfb5f999720cbfb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lm9KaevEm3Fcbz_F584OHQ.png"/></div></figure><p id="7ea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">配备Rxswift的MVVM并不完美，以下是使Rxswift无法成为最佳选择的缺点。</p><ul class=""><li id="614b" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">学习曲线:陡峭的学习曲线使得新开发人员加入项目变得困难(并且在项目接近尾声时，完全不切实际)。这是我们应该考虑避免RxSwift的首要原因:当关键时刻到来时，我们将无法向项目添加开发人员，除非他们已经是Rx老手了。</li><li id="3204" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">调试Rx数据转换是可怕的。当Rx按预期工作时，它是不可思议的。当它出现问题时，调试过程会困难得多。您在数据流中遇到的任何断点都将呈现一个40多个条目的回溯堆栈，其中有几十个难以理解的内部Rx方法，用于分隔和隐藏我们实际编写的代码。</li></ul><p id="3a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxSwift可能不会大幅缩短总体开发时间。它只是把问题转化为一些新的问题。如果团队没有为Rx做好准备，并且市场上很难找到RxSwift开发人员，那么Rx可能不是最佳选择。就我个人而言，我总是用MVP混合MVVM和Rxswift。我相信Rxswift可以顺利解决异步问题，但我们有很多没有异步请求的情况。在这种情况下，MVP完全没问题。</p><p id="e0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章对你自己的应用程序架构有所启发。欢迎你对这篇文章留下任何意见。我感谢任何建议。</p></div></div>    
</body>
</html>