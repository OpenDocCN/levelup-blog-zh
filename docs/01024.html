<html>
<head>
<title>Docker for Go Development with Hot Reload</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有热重装功能的Go开发Docker</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-for-go-development-a27141f36ba9?source=collection_archive---------0-----------------------#2019-10-22">https://levelup.gitconnected.com/docker-for-go-development-a27141f36ba9?source=collection_archive---------0-----------------------#2019-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker太牛逼了！它是轻量级的，确保您的所有环境完全相同，易于设置。</p><p id="a9e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇博文中，我将创建一个Docker容器来保存一个简单的Go API。每当源代码发生变化时，Go服务器都会立即重新加载。</p><p id="44fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样我就不必在开发过程中无数次地重建Docker图像。🚀</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b7b8cef6bc3215ed41d7678a207b90e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZmWmTa3zFgX078wSwXpdA.png"/></div></div></figure><h1 id="32a6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建Go模块</h1><p id="c424" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在1.13版本中，引入了模块。这意味着我再也不用把所有的项目放在同一个Go工作区了。</p><p id="b325" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我创建了一个名为<code class="fe md me mf mg b">go-docker</code>的新目录来保存所有文件。</p><p id="b888" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我初始化一个Git存储库并创建Go模块。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="a0d2" class="ml lb it mg b gy mm mn l mo mp">git init<br/>git remote add origin git@github.com:Dirk94/go-docker.git<br/>go mod init github.com/dirk94/go-docker</span></pre><p id="9776" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您会注意到在我们的目录中有一个<code class="fe md me mf mg b">go.mod</code>文件。这个文件将保存这个模块的所有依赖项，类似于节点开发中的<code class="fe md me mf mg b">package.json</code>文件。</p><h1 id="022e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">构建API</h1><p id="4884" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">模块已经设置好了，现在是时候构建我们简单的API了。</p><p id="954b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将为API使用<code class="fe md me mf mg b">gorilla/mux</code>路由包。我可以只使用标准的Go路由器，但我想确保依赖关系在Go模块中按预期工作，并在应用程序变得更复杂时利用mux的优势。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="39f5" class="ml lb it mg b gy mm mn l mo mp">go get -u github.com/gorilla/mux</span></pre><p id="5eb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行该命令后，您会看到它作为一个依赖项被添加到了<code class="fe md me mf mg b">go.mod</code>文件中。</p><p id="c204" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我创建主Go文件<code class="fe md me mf mg b">commands/runserver.go</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="322c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该API所做的只是返回消息“欢迎使用这个改变生活的API。”</p><p id="d74a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在深入Docker容器之前，让我们测试一下这个程序是否有效。为了运行服务器，我使用了<code class="fe md me mf mg b">go run</code>命令。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="1fee" class="ml lb it mg b gy mm mn l mo mp">go run commands/runserver.go<br/>Server listening!</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/ee4ed9fbf343b25c4790372cf69f9f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6KspzGnMq8EyT00fatpMIA.png"/></div></div></figure><p id="c0dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API工作正常，棒极了🎉</p><h1 id="11bc" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置Docker</h1><p id="dbc3" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我首先为这个项目创建一个定制的Docker图像。Docker映像包含一组指令，告诉Docker创建什么样的环境。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2661" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用<code class="fe md me mf mg b">golang:latest</code>图像作为这个新的自定义图像的基础。通过这种方式，我确信Go已经正确地建立在我的映像上。</p><p id="7a49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将整个项目复制到image <code class="fe md me mf mg b">/app</code>目录中。然后，我通过运行<code class="fe md me mf mg b">go mod download</code>下载依赖项。</p><p id="baa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我告诉Docker运行<code class="fe md me mf mg b">go run commands/runserver.go</code>命令。</p><p id="ce4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了构建这个映像，我运行以下命令。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="ddfa" class="ml lb it mg b gy mm mn l mo mp">docker build -t go-docker-image .</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="e4a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我有了构建Docker映像的指令，现在我实际上需要用Docker运行它。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="f2e2" class="ml lb it mg b gy mm mn l mo mp">docker run go-docker-image<br/>Server listening!</span></pre><p id="5f9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务器在Docker容器中监听，但是当我在浏览器中访问<code class="fe md me mf mg b">localhost</code>时，我得到一个“拒绝连接”错误。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/6586c53fd5576648a75897bd41e1ffca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6b-yqzGeDphqnJB6-K_wAA.png"/></div></div></figure><p id="10cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发生的情况是Docker容器在端口80上监听传入的请求。但是，主机操作系统没有监听端口80。因此，当我向<code class="fe md me mf mg b">localhost</code>发送GET请求时，它找不到正在运行的服务器。</p><p id="43d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我画了一张图来概括这个问题——我为我的绘画技巧道歉。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/62bdb3e0f18d1bd8c5648c8b579a5c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*WtJJZP3tjhSi5srns9Pg6A.png"/></div></div></figure><p id="2671" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我可以将<em class="nc">容器的</em>端口80映射到<em class="nc">主机的</em>端口80。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="046b" class="ml lb it mg b gy mm mn l mo mp">docker run -p 80:80 go-docker-image</span></pre><p id="9449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从概念上讲，图表现在看起来应该是这样的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/b6a682713235c11c97e43f070de55030.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*0IZD5Ve-xm9D8Lon5tx7LA.png"/></div></div></figure><p id="ae28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我进入<code class="fe md me mf mg b">localhost</code>时，我看到“欢迎使用这个改变生活的API。”消息。🤖</p><h1 id="9611" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">更改源代码</h1><p id="f886" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我想对API进行更改。我的一些朋友告诉我，这并没有改变他们的生活，所以是时候升级了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1c1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在API中添加了新的一行。让我们旋转一个新的Docker容器。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="b54d" class="ml lb it mg b gy mm mn l mo mp">docker run -p 80:80 go-docker-image</span></pre><p id="f8d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，如果我现在去<code class="fe md me mf mg b">localhost</code>，我仍然会看到旧的消息。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nd"><img src="../Images/1019ea0c5f9895678b778be363f58fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05l6Z6B-dArY9sxmO2K9HQ.png"/></div></div></figure><p id="9f74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为<em class="nc"> Docker图像</em>没有改变。因此，我们必须<em class="nc">重建</em>映像，以使更改生效。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="d523" class="ml lb it mg b gy mm mn l mo mp">docker build -t go-docker-image .<br/>docker run -p 80:80 go-docker-image</span></pre><p id="d4ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我确实看到了更新的消息。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ne"><img src="../Images/2abf63b8fd644b37332969bcb2c47bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1J_WsNIsAs8hkPiZcbE4vg.png"/></div></div></figure><h1 id="5bfe" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置热重装</h1><p id="d3e4" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在每次修改源代码后重新构建Docker映像花费的时间太长。让我们建立一个更好的系统。</p><p id="5ece" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将使用<a class="ae nf" href="https://github.com/githubnemo/CompileDaemon" rel="noopener ugc nofollow" target="_blank">编译守护进程</a>包。如果任何Go源文件发生变化，这个包将自动重新构建并重新启动Go应用程序。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b7e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我更新了<code class="fe md me mf mg b">Dockerfile</code>来下载CompileDaemon包。</p><p id="971a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我改变入口点启动<code class="fe md me mf mg b">CompileDaemon</code>程序。我给程序指定了一个构建和运行命令。每次Go文件发生变化时，都会执行这些操作。</p><p id="ae4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我通过跑步重建了形象。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="11b9" class="ml lb it mg b gy mm mn l mo mp">docker build -t go-docker-image .</span></pre><p id="b586" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行Docker时，我添加了<code class="fe md me mf mg b">-v ~/projects/go-docker:/app</code>标志。这将把主机的<code class="fe md me mf mg b">go-docker</code>目录挂载到Docker容器的<code class="fe md me mf mg b">/app</code>目录中。</p><p id="b582" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当我在我的<code class="fe md me mf mg b">go-docker</code>目录中进行更改时，containers <code class="fe md me mf mg b">/app</code>目录中的文件也会更改。</p><p id="3df9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后的命令如下所示。<em class="nc">注意</em> <code class="fe md me mf mg b"><em class="nc">-v</em></code> <em class="nc">路径不能是相对的。</em></p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="19f9" class="ml lb it mg b gy mm mn l mo mp">docker run -v ~/projects/go-docker:/app -p 80:80 go-docker-image</span></pre><p id="6de1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当容器运行时，对源代码进行更改，您会看到它会自动更新。🔥🚀</p><h1 id="0e14" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Docker撰写</h1><p id="106b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">现在我必须键入很长的<code class="fe md me mf mg b">docker run -v ~/projects/go-docker:/app -p 80:80 go-docker-image</code>命令来启动我的容器。</p><p id="1e35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在这个项目中是可行的，因为我只需要一个容器。但是假设我有一个项目，我需要旋转多个容器。运行所有的<code class="fe md me mf mg b">docker run</code>命令会很快变得很累。</p><p id="d035" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方法是使用Docker Compose。这个工具允许您在运行<code class="fe md me mf mg b">docker-compose up</code>命令时指定要启动的容器。</p><p id="d5fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了设置它，我创建了一个<code class="fe md me mf mg b">docker-compose.yml</code>文件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7fee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我指定我想要创建一个名为<code class="fe md me mf mg b">go-docker-image</code>的图像。应该使用<code class="fe md me mf mg b">./</code>目录中的<code class="fe md me mf mg b">Dockerfile</code>来构建图像。</p><p id="968c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我映射端口并设置音量——这次我可以使用相对路径。</p><p id="37e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了启动在<code class="fe md me mf mg b">docker-compose.yml</code>文件中指定的容器，我运行<code class="fe md me mf mg b">docker-compose up</code>。</p><p id="1388" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样，我在Docker中有一个工作API，当文件改变时，它会自动重新加载！🙌</p><p id="f236" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在这里查看源代码—<a class="ae nf" href="https://github.com/dirk94/go-docker" rel="noopener ugc nofollow" target="_blank">https://github.com/dirk94/go-docker</a></p></div></div>    
</body>
</html>