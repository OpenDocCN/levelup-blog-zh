<html>
<head>
<title>JavaScript Tips — Reset File Input, Format Date, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript提示—重置文件输入、格式化日期等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-tips-reset-file-input-format-date-and-more-1d3516c8d0fb?source=collection_archive---------15-----------------------#2020-07-08">https://levelup.gitconnected.com/javascript-tips-reset-file-input-format-date-and-more-1d3516c8d0fb?source=collection_archive---------15-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/822061fd7dc4bc52a8c8fd90b732d3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V9a9AnL6E5Rp9WEr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@zibik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">齐比克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9eef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="e4ad" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重置文件输入</h1><p id="3dc6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过将输入的<code class="fe mh mi mj mk b">value</code>属性设置为空字符串来重置文件输入。</p><p id="a2d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6521" class="mt lf it mk b gy mu mv l mw mx">document.getElementById("file-input").value = "";</span></pre><h1 id="c44e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript中只比较日期部分而不比较时间</h1><p id="cbcf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们将日期的时间设置为相同的话，我们可以在不比较时间的情况下比较日期。</p><p id="2b10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以将两者设置为相同的时间:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="840c" class="mt lf it mk b gy mu mv l mw mx">const date1 = new Date();<br/>const date2 = new Date(2011,8,20);<br/>date1.setHours(0, 0, 0, 0);<br/>date2.setHours(0, 0, 0, 0);</span></pre><p id="db4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mh mi mj mk b">date1</code>和<code class="fe mh mi mj mk b">date2</code>都设置为午夜。</p><p id="1443" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们只能通过日期来比较两者。</p><h1 id="6e6f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">手动触发onchange事件</h1><p id="2159" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用<code class="fe mh mi mj mk b">Event</code>构造函数来触发变更事件。</p><p id="e933" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1431" class="mt lf it mk b gy mu mv l mw mx">const event = new Event('change');<br/>element.dispatchEvent(event);</span></pre><p id="bd86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mh mi mj mk b">Event</code>构造函数创建事件。</p><p id="6f11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">event</code>对象作为参数调用元素上的<code class="fe mh mi mj mk b">dispatchEvent</code>。</p><h1 id="6ae6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从JavaScript日期对象中获取YYYYMMDD格式的字符串</h1><p id="6681" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要获得YYYYMMDD格式的字符串形式的日期，我们可以使用内置的date方法来实现。</p><p id="d85a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="05c5" class="mt lf it mk b gy mu mv l mw mx">const mm = date.getMonth() + 1; <br/>const dd = date.getDate();<br/>const yyyymmdd = [date.getFullYear(), `${mm &gt; 9 ? '' : '0'}mm`,<br/>`${dd &gt; 9 ? '' : '0'}dd`].join('');</span></pre><p id="72fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们称<code class="fe mh mi mj mk b">getFullYear</code>为4位数年份。</p><p id="a44d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">getMonth</code>大半夜的。我们必须加上1，因为在JavaScript日期中，月份是从零开始的。</p><p id="6c57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">getDate</code>返回当天。</p><p id="b84b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们就把它们都放在数组里，调用<code class="fe mh mi mj mk b">join</code>把它们组合在一起。</p><h1 id="be1e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript属性访问的点符号与括号</h1><p id="ac1b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用点或括号符号来访问JavaScript属性。</p><p id="70df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a50d" class="mt lf it mk b gy mu mv l mw mx">const foo = form["foo"];</span></pre><p id="423d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ea06" class="mt lf it mk b gy mu mv l mw mx">const foo = form.foo;</span></pre><p id="3bee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们对于字符串键也是一样的。</p><p id="1616" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点符号更快更容易阅读。</p><p id="1642" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是方括号符号允许我们使用特殊字符访问属性，或者使用变量访问属性。</p><h1 id="4b9e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象扩散与对象分配</h1><p id="3e60" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用扩展语法或<code class="fe mh mi mj mk b">Object.assign</code>来复制或合并对象。</p><p id="68c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">扩展语法更短，但不是动态的。</p><p id="4a72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0e13" class="mt lf it mk b gy mu mv l mw mx">const obj = {...a, ...b};</span></pre><p id="db45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将对象<code class="fe mh mi mj mk b">a</code>和<code class="fe mh mi mj mk b">b</code>的条目分散到一个新对象中，并将其分配给<code class="fe mh mi mj mk b">obj</code>。</p><p id="5016" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也仅在ES2018或更高版本中可用。</p><p id="0494" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要更动态的东西，我们可以使用<code class="fe mh mi mj mk b">Object.assign</code>。</p><p id="ddcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它在旧版本的JavaScript中也可用。</p><p id="0b2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="73e8" class="mt lf it mk b gy mu mv l mw mx">const obj = Object.assign({}, a, b);</span></pre><p id="7d5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">做和以前一样的事情。</p><p id="db89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，这比使用spread语法要长。</p><p id="e707" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果对象在一个数组中，我们还可以使用spread运算符组合动态数量的对象:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f4f7" class="mt lf it mk b gy mu mv l mw mx">const obj = Object.assign({}, ...objs);</span></pre><p id="2c41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<code class="fe mh mi mj mk b">objs</code>是一个对象数组。</p><h1 id="35d8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JSON和JSONP的区别</h1><p id="6574" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JSON和JSONP的区别在于，尽管有同源策略，我们还是可以使用JSONP。</p><p id="f443" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JSON通过JSONP传递到回调中。</p><p id="69fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但JSON却不是这样。</p><p id="10dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，JSON响应是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="da1c" class="mt lf it mk b gy mu mv l mw mx">{ "name": "james", "id": 5 }</span></pre><p id="387a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是JSONP被传递到一个回调函数中，我们用查询参数<code class="fe mh mi mj mk b">callback</code>指定这个回调函数。</p><p id="f9a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="14fa" class="mt lf it mk b gy mu mv l mw mx">?callback=func</span></pre><p id="cb04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在URL的查询字符串中，我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f8bb" class="mt lf it mk b gy mu mv l mw mx">function func(json){<br/>  console.log(json.name);<br/>}</span></pre><p id="dbfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来获取JSONP响应。</p><p id="94d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">json</code>是也:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6bd9" class="mt lf it mk b gy mu mv l mw mx">{ "name": "james", "id": 5 }</span></pre><h1 id="d45b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Object.create()和new构造函数()之间的区别</h1><p id="707c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.create</code>让我们创建一个直接继承自另一个对象的对象。</p><p id="df3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用构造函数来创建一个对象，那么我们就创建了一个从构造函数的原型继承的对象。</p><p id="ed01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fa24" class="mt lf it mk b gy mu mv l mw mx">const foo = Object.create(bar);</span></pre><p id="9517" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mh mi mj mk b">foo</code>继承<code class="fe mh mi mj mk b">bar</code>的属性。</p><p id="7c46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8409" class="mt lf it mk b gy mu mv l mw mx">const foo = new Foo();</span></pre><p id="773a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mh mi mj mk b">foo</code>继承了<code class="fe mh mi mj mk b">Foo</code>的原型。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/c82f425b1a5a0939352e3c0a932520eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wTWDbgS4VbT4e4RL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sonniehiles?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sonnie Hiles </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="22e5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f5eb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过将文件的<code class="fe mh mi mj mk b">valuye</code>属性设置为空字符串来重置文件输入。</p><p id="f50b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Spread和<code class="fe mh mi mj mk b">Object.assign</code>可以做类似的事情。</p><p id="9a61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.create</code>和构造函数也不同。</p><p id="33fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以调用date方法来获取日期的一部分。</p></div></div>    
</body>
</html>