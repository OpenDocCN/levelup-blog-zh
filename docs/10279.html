<html>
<head>
<title>Difference between ==, ===, equal and eql in chai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">chai中==、===、equal和eql之间的差异</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/difference-between-equal-and-eql-in-chai-162754a935c5?source=collection_archive---------7-----------------------#2021-11-17">https://levelup.gitconnected.com/difference-between-equal-and-eql-in-chai-162754a935c5?source=collection_archive---------7-----------------------#2021-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a61" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这些看起来非常相似，但有细微的差别。跟着这个教程去理解吧。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54416417579fb5ee58897cbbd94fbcc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_QWgtfJBwHbfEate"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">韦斯·希克斯在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="a796" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="31d0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">看看堆栈溢出，我们可能会发现很多程序员发现<code class="fe mn mo mp mq b">equal</code>和<code class="fe mn mo mp mq b">eql</code>之间的区别令人困惑。特别是，<code class="fe mn mo mp mq b">eql</code>看起来就像是<code class="fe mn mo mp mq b">equal</code>的缩写。此外，在某些情况下，两种断言的工作方式完全相同！</p><p id="aa19" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">读完这篇教程，你会明白其中的细微差别。</p><h1 id="13f5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简单测试</h1><p id="1b0e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们用<code class="fe mn mo mp mq b">mocha</code>和<code class="fe mn mo mp mq b">chai</code>开始一些非常简单的测试:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="a05d" class="na la it mq b gy nb nc l nd ne">'use strict';</span><span id="71d8" class="na la it mq b gy nf nc l nd ne">const { expect } = require('chai');</span><span id="e7c5" class="na la it mq b gy nf nc l nd ne">describe('expect', () =&gt; {<br/>    it('it should equal', () =&gt; {<br/>        const value1 = 1;<br/>        const value2 = 1;</span><span id="3593" class="na la it mq b gy nf nc l nd ne">        expect(value1).to.equal(value2);<br/>    });<br/>});</span></pre><p id="e36e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">显然<code class="fe mn mo mp mq b">1</code>等于<code class="fe mn mo mp mq b">1</code>，因此测试将通过。数字是JavaScript中的原始数据类型，因此如果我们实际使用<code class="fe mn mo mp mq b">==</code>(等式运算符)、<code class="fe mn mo mp mq b">===</code>(严格等式运算符)或<code class="fe mn mo mp mq b">eql</code>，结果将是相同的:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="2152" class="na la it mq b gy nb nc l nd ne">describe('expect', () =&gt; {<br/>    it('it should equal', () =&gt; {<br/>        const value1 = 1;<br/>        const value2 = 1;</span><span id="abaf" class="na la it mq b gy nf nc l nd ne">        const result = value1 == value2;<br/>        const strictResult = value1 === value2;</span><span id="db4d" class="na la it mq b gy nf nc l nd ne">        expect(value1).to.equal(value2);<br/>        expect(value1).to.eql(value2);<br/>        expect(result).to.equal(true);<br/>        expect(strictResult).to.equal(true);<br/>   });<br/>});</span></pre><p id="3d47" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这种特殊情况下，我们使用哪个运算符并不重要。<strong class="lt iu">测试会通过</strong>，没有区别。</p><h1 id="a7ad" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">比较对象</h1><p id="648b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们想要比较JavaScript中的两个对象时，我们必须更加小心。简单等式和严格等式都会导致<code class="fe mn mo mp mq b">false</code>结果:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="86fd" class="na la it mq b gy nb nc l nd ne">const obj1 = { foo: 'bar' };<br/>const obj2 = { foo: 'bar' };</span><span id="ae45" class="na la it mq b gy nf nc l nd ne">const result = obj1 == obj2;         // false<br/>const strictResult = obj1 === obj2;  // false</span></pre><p id="5157" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在JavaScript中有很多方法可以比较两个对象，但是让我们把重点放在<code class="fe mn mo mp mq b">chai</code>库和单元测试上。</p><p id="d600" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当我们查阅<a class="ae ky" href="https://www.chaijs.com/api/bdd/#method_equal" rel="noopener ugc nofollow" target="_blank">柴的文献资料</a>时我们可以发现<code class="fe mn mo mp mq b">equal</code>的区别在于:</p><blockquote class="nh ni nj"><p id="b7ef" class="lr ls ng lt b lu mr ju lw lx ms jx lz nk mt mc md nl mu mg mh nm mv mk ml mm im bi translated">断言目标严格(<code class="fe mn mo mp mq b">===</code>)等于给定的<code class="fe mn mo mp mq b">val</code>。</p></blockquote><p id="cdc8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">而<code class="fe mn mo mp mq b">eql</code>则是:</p><blockquote class="nh ni nj"><p id="70cf" class="lr ls ng lt b lu mr ju lw lx ms jx lz nk mt mc md nl mu mg mh nm mv mk ml mm im bi translated">断言目标深度等于给定的<code class="fe mn mo mp mq b">obj</code>。</p></blockquote><p id="b3b9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们来注意四个关键词:<em class="ng">严格</em>，<em class="ng">深入</em>，<em class="ng"> val </em>和<em class="ng"> obj </em>。</p><p id="f970" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，简单的规则是:当我们想要比较对象时，使用<code class="fe mn mo mp mq b">eql</code>。否则，使用<code class="fe mn mo mp mq b">equal</code>比较<em class="ng">值</em>。</p><p id="1a83" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">示例:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="8d66" class="na la it mq b gy nb nc l nd ne">it('should equal', () =&gt; {<br/>    expect({ a: 1 }).to.equal({ a: 1 }); // This fails as...<br/>    <br/>    const obj1 = { foo: 'bar' };<br/>    const obj2 = { foo: 'bar' };<br/>    const result = obj1 === obj2; // ...two objects are not strictly equal.</span><span id="d2d2" class="na la it mq b gy nf nc l nd ne">    expect(result).to.equal(true); // Thus result is false.<br/>});</span></pre><p id="d8af" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这个测试失败了，因为我们使用了严格比较两个值的<code class="fe mn mo mp mq b">equal</code>。它相当于<code class="fe mn mo mp mq b">===</code>运算符，也给出了<code class="fe mn mo mp mq b">false</code>。</p><p id="a669" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">它能与object一起工作的唯一方式是当我们将同一个对象与其自身进行比较时(这有点无意义):</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="a3e8" class="na la it mq b gy nb nc l nd ne">it('pointless comparison', () =&gt; {<br/>   const object1 = { foo: 'bar' };<br/>   const object2 = object1;</span><span id="aa72" class="na la it mq b gy nf nc l nd ne">   expect(object1).to.equal(object2);<br/>});</span></pre><p id="e8b6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这种情况下，我们检查一个对象<code class="fe mn mo mp mq b">object1</code>是否等于我们分配给<code class="fe mn mo mp mq b">object1</code>的<code class="fe mn mo mp mq b">object2</code>引用</p><p id="fcab" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们甚至可以将它改写为:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="7585" class="na la it mq b gy nb nc l nd ne">const object = { foo: 'bar' };<br/>const result = object === object; // Even strict equal is true!</span></pre><h1 id="bc29" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">深度相等</h1><p id="7605" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们必须承认在<code class="fe mn mo mp mq b">chai</code>中使用的命名约定不是最好的，因为<code class="fe mn mo mp mq b">eql</code>检查两个对象是否<em class="ng">完全相等</em>。因此，像<code class="fe mn mo mp mq b">deeplyEqual</code>这样更好的名字会更容易混淆，事实上它就在那里！</p><p id="a03c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">不使用<code class="fe mn mo mp mq b">eql</code>，我们可以使用:<code class="fe mn mo mp mq b">deep.equal</code> —这两个是一样的:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="0b45" class="na la it mq b gy nb nc l nd ne">it('should eql', () =&gt; {<br/>    expect({ b: 2 }).to.eql({ b: 2 }); // Two objects are deeply equal. Test will pass.<br/>});</span><span id="f91b" class="na la it mq b gy nf nc l nd ne">it('should deeply equal', () =&gt; {<br/>    expect({ c: 3 }).to.deep.equal({ c: 3 }); // Test will pass<br/>});</span></pre><p id="fe28" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">深度相等意味着两个对象具有相同的属性和相同的值。</p><h1 id="3381" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="c47b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关键区别在于<em class="ng">不同</em>用法。使用<code class="fe mn mo mp mq b">equal</code>严格比较<em class="ng">值</em>，如果要比较<em class="ng">对象</em>则使用<code class="fe mn mo mp mq b">eql</code>，相当于深度相等。</p><p id="4b82" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">eql</code>的命名具有误导性和迷惑性。相反，你总是可以使用:<code class="fe mn mo mp mq b">deep.equal</code>。请记住，基本数据类型不需要深度相等！</p><p id="479c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">感谢阅读！</p><p id="c9c3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如果你觉得这个教程有帮助和有趣，请鼓掌并跟我来。</p></div></div>    
</body>
</html>