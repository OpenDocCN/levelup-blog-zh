<html>
<head>
<title>Creating Web Components — Lifecycle Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Web组件—生命周期回调</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-web-components-lifecycle-callbacks-5b6ffa48a8d5?source=collection_archive---------14-----------------------#2020-02-04">https://levelup.gitconnected.com/creating-web-components-lifecycle-callbacks-5b6ffa48a8d5?source=collection_archive---------14-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/abc918f41a0d86212d68b6954bde204b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QbhPnV2uGBfHTy5h"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@genuinemex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Magnus eng</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="dfe7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着web应用变得越来越复杂，我们需要某种方式将代码分成易于管理的块。为此，我们可以使用Web组件来创建可重用的UI块，以便在多个地方使用。</p><p id="1cff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看Web组件的生命周期挂钩以及我们如何使用它们。</p><h1 id="df9d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">生命周期挂钩</h1><p id="7313" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Web组件有自己的生命周期。Web组件的生命周期中会发生以下事件:</p><ul class=""><li id="3afa" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">元素插入到DOM中</li><li id="22fa" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">当触发UI事件时更新</li><li id="668a" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">从DOM中删除的元素</li></ul><p id="2662" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Web组件具有生命周期挂钩，是捕获这些生命周期事件并让我们相应地处理它们的回调函数。</p><p id="efef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们让我们处理这些事件，而不需要创建我们自己的系统来这样做。大多数JavaScript框架提供相同的功能，但是Web组件是一个标准，所以我们不需要加载额外的代码就可以使用它们。</p><p id="cdbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">web组件中有以下生命周期挂钩:</p><ul class=""><li id="fe83" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">constructor()</code></li><li id="7e1e" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">connectedCallback()</code></li><li id="8e16" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">disconnectedCallback()</code></li><li id="28c4" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">attributeChangedCallback(name, oldValue, newValue)</code></li><li id="5d63" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">adoptedCallback()</code></li></ul><h2 id="55a0" class="mz lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">构造函数()</h2><p id="7b87" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">创建Web组件时会调用<code class="fe mv mw mx my b">constructor()</code>。它在我们创建影子DOM时被调用，用于设置监听器和初始化组件的状态。</p><p id="76a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，不建议我们在这里运行渲染和获取资源之类的操作。<code class="fe mv mw mx my b">connectedCallback</code>更适合这类任务。</p><p id="20fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于ES6类来说，定义一个构造函数是可选的，但是如果没有定义，就会创建一个空的构造函数。</p><p id="fb04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当创建构造函数时，我们必须调用<code class="fe mv mw mx my b">super()</code>来调用Web组件类扩展的类。</p><p id="3fb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在那里使用<code class="fe mv mw mx my b">return</code>语句，但不能在那里使用<code class="fe mv mw mx my b">document.write()</code>或<code class="fe mv mw mx my b">document.open()</code>。</p><p id="ca2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不能在构造函数方法中获得属性或子元素。</p><h2 id="75a1" class="mz lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">connectedCallback()</h2><p id="0848" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx my b">connectedCallback()</code>当一个元素被添加到DOM时，方法被调用。我们可以确定当这个方法被调用时，这个元素对DOM是可用的。</p><p id="9556" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以安全地设置属性、获取资源、运行设置代码或呈现模板。</p><h2 id="3579" class="mz lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">disconnectedCallback()</h2><p id="d577" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当从DOM中移除元素时调用这个函数。因此，这是添加清理逻辑和释放资源的理想场所。我们还可以使用这个回调来:</p><ul class=""><li id="2e62" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">通知应用程序的另一部分，该元素已从DOM中移除</li><li id="e7b6" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">释放不会被自动垃圾收集的资源，比如取消订阅DOM事件，停止间隔计时器，或者取消注册所有已注册的回调</li></ul><p id="fd6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户关闭标签页时，这个钩子永远不会被调用，在它的生命周期中它可以被触发多次。</p><h2 id="4b1f" class="mz lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">attributeChangedCallback(attrName，oldVal，newVal)</h2><p id="8ca5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以像传递任何其他属性一样，将带有值的属性传递给Web组件:</p><pre class="nl nm nn no gt np my nq nr aw ns bi"><span id="0692" class="mz lf it my b gy nt nu l nv nw">&lt;custom-element <br/>  foo="foo" <br/>  bar="bar" <br/>  baz="baz"&gt;<br/>&lt;/custom-element&gt;</span></pre><p id="4783" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个回调中，我们可以获得在代码中分配的属性值。</p><p id="9adb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以添加一个<code class="fe mv mw mx my b">static get observedAttributes()</code>钩子来定义我们观察的属性值。例如，我们可以写:</p><pre class="nl nm nn no gt np my nq nr aw ns bi"><span id="88ee" class="mz lf it my b gy nt nu l nv nw">class CustomElement extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    const shadow = this.attachShadow({<br/>      mode: 'open'<br/>    });<br/>  }</span><span id="1ca4" class="mz lf it my b gy nx nu l nv nw">  static get observedAttributes() {<br/>    return ['foo', 'bar', 'baz'];<br/>  }</span><span id="7226" class="mz lf it my b gy nx nu l nv nw">  attributeChangedCallback(name, oldValue, newValue) {<br/>    console.log(`${name}'s value has been changed from ${oldValue} to ${newValue}`);<br/>  }<br/>}</span><span id="4c3a" class="mz lf it my b gy nx nu l nv nw">customElements.define('custom-element', CustomElement);</span></pre><p id="446f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该从<code class="fe mv mw mx my b">console.log</code>中得到以下内容:</p><pre class="nl nm nn no gt np my nq nr aw ns bi"><span id="609e" class="mz lf it my b gy nt nu l nv nw">foo's value has been changed from null to foo<br/>bar's value has been changed from null to bar<br/>baz's value has been changed from null to baz</span></pre><p id="df0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有下面的HTML:</p><pre class="nl nm nn no gt np my nq nr aw ns bi"><span id="c202" class="mz lf it my b gy nt nu l nv nw">&lt;custom-element foo="foo" bar="bar" baz="baz"&gt;<br/>&lt;/custom-element&gt;</span></pre><p id="6246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到这个是因为我们给HTML中的<code class="fe mv mw mx my b">foo</code>、<code class="fe mv mw mx my b">bar</code>和<code class="fe mv mw mx my b">baz</code>属性分配了相同名称的值。</p><h2 id="95f0" class="mz lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">已采用回调()</h2><p id="113f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们用传入的元素调用<code class="fe mv mw mx my b">document.adoptNode</code>时，就会调用<code class="fe mv mw mx my b">adoptedCallback</code>。它只发生在我们处理iframes的时候。</p><p id="802e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法用于将一个节点从一个文档转移到另一个文档。iframe有另一个文档，所以可以用iframe的document对象调用它。</p><figure class="nl nm nn no gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/54114adc09dc6404919c9c647688041a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*srVZx0NxhqUaXNCT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Matthew Cabret 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d04e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">例子</h1><p id="9fba" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用它来创建一个带有如下闪烁文本的元素:</p><pre class="nl nm nn no gt np my nq nr aw ns bi"><span id="f669" class="mz lf it my b gy nt nu l nv nw">class BlinkElement extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>  }</span><span id="030e" class="mz lf it my b gy nx nu l nv nw">  connectedCallback() {<br/>    const shadow = this.attachShadow({<br/>      mode: 'open'<br/>    });<br/>    this.span = document.createElement('span');<br/>    this.span.textContent = this.getAttribute('text');<br/>    const style = document.createElement('style');<br/>    style.textContent = 'span { color: black }';<br/>    this.intervalTimer = setInterval(() =&gt; {<br/>      let styleText = this.style.textContent;<br/>      if (style.textContent.includes('red')) {<br/>        style.textContent = 'span { color: black }';<br/>      } else {<br/>        style.textContent = 'span { color: red }';<br/>      }</span><span id="63a9" class="mz lf it my b gy nx nu l nv nw">}, 1000)<br/>    shadow.appendChild(style);<br/>    shadow.appendChild(this.span);<br/>  }</span><span id="a874" class="mz lf it my b gy nx nu l nv nw">  disconnectedCallback() {<br/>    clearInterval(this.intervalTimer);<br/>  }</span><span id="bd47" class="mz lf it my b gy nx nu l nv nw">  static get observedAttributes() {<br/>    return ['text'];<br/>  }</span><span id="2bd3" class="mz lf it my b gy nx nu l nv nw">  attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name === 'text') {<br/>      if (this.span) {<br/>        this.span.textContent = newValue;<br/>      }</span><span id="1a4a" class="mz lf it my b gy nx nu l nv nw">    }<br/>  }<br/>}</span><span id="4ae6" class="mz lf it my b gy nx nu l nv nw">customElements.define('blink-element', BlinkElement);</span></pre><p id="1bbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mv mw mx my b">connectedCallback</code>中，我们有初始化元素的所有代码。它包括为我们传递给属性<code class="fe mv mw mx my b">text</code>的文本添加一个<code class="fe mv mw mx my b">span</code>作为它的值，以及闪烁文本的样式。样式从创建<code class="fe mv mw mx my b">style</code>元素开始，然后我们添加了<code class="fe mv mw mx my b">setInterval</code>代码，通过将<code class="fe mv mw mx my b">span</code>的颜色从红色变为黑色来闪烁文本，反之亦然。</p><p id="b51a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将节点附加到我们在开始时创建的影子DOM。</p><p id="9381" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有<code class="fe mv mw mx my b">observedAttributes</code>静态方法来设置要监视的属性。这被<code class="fe mv mw mx my b">attributeChangedCallback</code>用来监视文本属性的值，并通过获取<code class="fe mv mw mx my b">newValue</code>来相应地设置它。</p><p id="e455" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要查看<code class="fe mv mw mx my b">attributeChangedCallback</code>的运行情况，我们可以动态创建元素，并按如下方式设置其属性:</p><pre class="nl nm nn no gt np my nq nr aw ns bi"><span id="59c7" class="mz lf it my b gy nt nu l nv nw">const blink2 = document.createElement('blink-element');<br/>document.body.appendChild(blink2);<br/>blink2.setAttribute('text', 'bar');<br/>blink2.setAttribute('text', 'baz');</span></pre><p id="894e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们应该<code class="fe mv mw mx my b">bar</code>和<code class="fe mv mw mx my b">baz</code>，如果我们在<code class="fe mv mw mx my b">attributeChangedCallback</code>钩子中记录<code class="fe mv mw mx my b">newValue</code>。</p><p id="f2f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们有<code class="fe mv mw mx my b">disconnectedCallback</code>，它在组件被移除时运行。例如，当我们用下面的代码删除一个带有<code class="fe mv mw mx my b">removeChild</code>的元素时:</p><pre class="nl nm nn no gt np my nq nr aw ns bi"><span id="e3a1" class="mz lf it my b gy nt nu l nv nw">const blink2 = document.createElement('blink-element');<br/>document.body.appendChild(blink2);<br/>blink2.setAttribute('text', 'bar');<br/>document.body.removeChild(blink2);</span></pre><p id="bdbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生命周期挂钩允许我们处理影子DOM内部和外部的各种DOM事件。Web组件有用于初始化、移除和属性更改的钩子。我们可以选择观察哪些属性的变化。</p><p id="183f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在另一个文档中也有采用元素的挂钩。</p></div></div>    
</body>
</html>