<html>
<head>
<title>Redux Gotchas — useSelector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux Gotchas —使用选择器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/redux-gotchas-useselector-8f2aeb8973c9?source=collection_archive---------7-----------------------#2022-12-16">https://levelup.gitconnected.com/redux-gotchas-useselector-8f2aeb8973c9?source=collection_archive---------7-----------------------#2022-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3b39" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">防止意外的重新渲染和潜在的错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b19500857d1ddb7ccfeaf9f0738727a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pnp2sY7ctt6yFXapx5eFw.jpeg"/></div></div></figure><h2 id="2735" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">介绍</h2><p id="42c8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">Redux自2015年以来一直存在，多年来一直是事实上的状态管理解决方案。它伴随着React生态系统从基于类到函数的时代，并从v7.1.0开始通过引入redux挂钩来适应新的标准。</p><p id="e800" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">本文将指出使用<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>时的一些常见陷阱和技巧。</p><h2 id="3519" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">样品反应应用</h2><p id="0a17" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这是一个简单的react应用程序，我已经建立来演示这个问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/f23e59387be284f22d2b5b585e90ab9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/1*7CjbjKlzJCUcz7SxGcMAmA.gif"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">用Redux provider包装组件的应用程序容器</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">呈现最新计数器并监听redux存储的显示容器</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">在这个例子中使用的根缩减器</figcaption></figure><p id="edd6" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">这个简单的应用程序有2个按钮，用于更新计数器状态并发出信号<strong class="ls iu"><em class="mz">display container . tsx</em></strong>进行UI渲染。</p><p id="f594" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">注意状态属性<strong class="ls iu"> randomArray </strong>默认为<strong class="ls iu"> undefined </strong>，默认为<strong class="ls iu"> </strong>选择器函数中的<strong class="ls iu">空数组</strong></p><p id="252b" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">我们还在<strong class="ls iu"><em class="mz">display container . tsx</em></strong>中创建了一个<code class="fe mo mp mq mr b"><strong class="ls iu">useEffect()</strong></code>钩子，用于在生命周期钩子检测到变化时打印出一些文本。</p><h2 id="6422" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">问题是</h2><p id="8cad" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">现在，你可能想知道为什么<strong class="ls iu"> randomArray </strong>会触发<code class="fe mo mp mq mr b"><strong class="ls iu">useEffect()</strong></code>钩子，如果状态不会被任何redux动作更新的话。让我们看看控制台:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/808ce282338c18b720c036dcb02f129e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dW5Uj4IoNFGo6qtoFl_0Gg.gif"/></div></div></figure><p id="1088" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">我们已经观察到，在增量和/或减量按钮点击时:</p><ol class=""><li id="b25b" class="nb nc it ls b lt mj lw mk ld nd lh ne ll nf mi ng nh ni nj bi translated">每当订阅的属性发生状态变化时，就会调用选择器函数<strong class="ls iu"> stateSelector </strong>。</li><li id="600b" class="nb nc it ls b lt nk lw nl ld nm lh nn ll no mi ng nh ni nj bi translated">状态属性— <strong class="ls iu">计数器</strong> —因重复操作而更新。</li><li id="ec3e" class="nb nc it ls b lt nk lw nl ld nm lh nn ll no mi ng nh ni nj bi translated">状态属性<strong class="ls iu"> randomArray </strong>的值没有变化，但是它向<code class="fe mo mp mq mr b"><strong class="ls iu">useEffect()</strong></code>发出信号表示已经有了更新。</li></ol><p id="638d" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">对于第2点，这并不奇怪，因为这是预期的行为。基于<a class="ae np" href="https://react-redux.js.org/api/hooks#useselector" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu"> <em class="mz"> useSelector文档</em> </strong> </a>，一开始就指出我们应该预料到<strong class="ls iu"> stateSelector </strong>函数会被多次调用<strong class="ls iu"/>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/810d0cedfac9c70f16277a23e0a2bf15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHDoqenvQRC-DJPic1Dl2g.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">用户选择器文档中信息部分的屏幕裁剪</figcaption></figure><blockquote class="nr"><p id="dff8" class="ns nt it bd nu nv nw nx ny nz oa mi dk translated"><code class="fe mo mp mq mr b">useSelector()</code>也将订阅Redux store，并在一个动作被调度时运行您的选择器——Redux Team</p></blockquote><p id="164d" class="pw-post-body-paragraph lq lr it ls b lt ob ju lv lw oc jx ly ld od ma mb lh oe md me ll of mg mh mi im bi translated">这里有趣的是<strong class="ls iu">随机数组</strong>导致<code class="fe mo mp mq mr b"><strong class="ls iu">useEffect()</strong></code>重新运行。但是这种行为的原因是什么呢？让我们再次参考文档中的一些相关信息:</p><ul class=""><li id="7daa" class="nb nc it ls b lt mj lw mk ld nd lh ne ll nf mi og nh ni nj bi translated"><code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>将对之前的选择器结果值和当前结果值进行参考比较。</li><li id="c691" class="nb nc it ls b lt nk lw nl ld nm lh nn ll no mi og nh ni nj bi translated"><strong class="ls iu"/><code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>默认使用严格的<code class="fe mo mp mq mr b">===</code>引用等式检查，而不是浅等式。</li></ul><h2 id="84d1" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">罪犯已确认</h2><p id="ccc6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">基于这些指示，基于对<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>如何工作的理解，我们可以推断出以下代码行是罪魁祸首:</p><pre class="kj kk kl km gt oh mr oi bn oj ok bi"><span id="d95e" class="ol kv it mr b be om on l oo op">...<br/>return {<br/>    counter: state.counter,<br/><strong class="mr iu">    randomArray: state.randomArray ?? [],<br/></strong>};</span></pre><p id="c00d" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">鉴于<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>中订阅的状态改变将导致<strong class="ls iu">状态函数</strong>被重新求值，并且<strong class="ls iu"> state.randomArray </strong>在整个过程中是<strong class="ls iu">未定义的</strong>，回退到空数组<code class="fe mo mp mq mr b">[ ]</code>赋值是这里的根本原因。</p><blockquote class="nr"><p id="a0d0" class="ns nt it bd nu nv oq or os ot ou mi dk translated">每当调用state函数时，都会创建一个新的数组对象并将其分配给属性。</p></blockquote><p id="702f" class="pw-post-body-paragraph lq lr it ls b lt ob ju lv lw oc jx ly ld od ma mb lh oe md me ll of mg mh mi im bi translated">尽管数组的值是相同的，但我们不应该忘记这一点</p><blockquote class="nr"><p id="be31" class="ns nt it bd nu nv oq or os ot ou mi dk translated"><strong class="ak">数组是JavaScript世界中的一个对象</strong>。新对象的创建将导致不同的引用</p></blockquote><p id="234a" class="pw-post-body-paragraph lq lr it ls b lt ob ju lv lw oc jx ly ld od ma mb lh oe md me ll of mg mh mi im bi translated">当redux比较先前和当前状态函数的结果时，这将导致<strong class="ls iu">falsy</strong>T7】参考相等检查。</p><h2 id="3151" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">快速修复-全局范围默认变量</h2><p id="ebc7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这个问题的快速解决方法是简单地分配一个默认的回退值，这个值是在<strong class="ls iu">全局作用域</strong>中创建的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">更新了回退值，以使用在全局范围内创建的空数组</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/71d4c803d3bdabe3168e80dc04f62585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*08IJvDkUpeIt_OiGYD2jXw.gif"/></div></div></figure><p id="7ce5" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">最后，未改变的属性不再在每个不相关的状态改变时触发<code class="fe mo mp mq mr b"><strong class="ls iu">useEffect()</strong></code>。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="097f" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">多用途和小用途选择器用途</h2><p id="b64e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">将所有需要的状态组织到一个状态函数中，并用一个<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>返回，这看起来很方便，但这并不是redux团队推荐的方法</p><blockquote class="nr"><p id="51ad" class="ns nt it bd nu nv oq or os ot ou mi dk translated">我们可以在一个组件中多次调用<code class="fe mo mp mq mr b">useSelector</code>。事实上，这实际上是一个好主意——每次调用<code class="fe mo mp mq mr b">useSelector</code>应该总是返回尽可能少的状态——Redux Team</p></blockquote><div class="pc pd pe pf pg ph"><a href="https://redux.js.org/tutorials/fundamentals/part-5-ui-react#using-multiple-selectors-in-a-component" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">基础知识，第5部分:UI和React</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">在第4部分:存储中，我们看到了如何创建一个Redux存储、分派动作以及读取当前状态。我们还看了…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">redux.js.org</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks ph"/></div></div></a></div><p id="2b8f" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">让我们重构前面的代码示例，使用多个<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>,看看这在处理状态函数评估问题时是否有所不同——</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="5df5" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">全局范围默认值的替代</h2><p id="e679" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">那么前面的multiple <code class="fe mo mp mq mr b"><strong class="ls iu">useSelector(</strong></code> <strong class="ls iu"> ) </strong>方法解决对象引用问题了吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/2d2a41324df9624e01302db9297e16a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*otfKJiA3KAKJ57MclXEHpQ.gif"/></div></div></figure><p id="4a88" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">我们仍然观察到<code class="fe mo mp mq mr b"><strong class="ls iu">useEffect()</strong></code>再次被触发。让我们尝试另一种方法— <code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>有第二个可选参数<code class="fe mo mp mq mr b"><strong class="ls iu">equalityFn</strong></code>，它允许传递一个定制的等式函数。</p><p id="42fc" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">对于像<strong class="ls iu"> randomArray </strong>这样的简单对象，我们可以传入一个自定义的等式函数，比如<strong class="ls iu"> shallowEqual </strong>，它是由redux:</p><pre class="kj kk kl km gt oh mr oi bn oj ok bi"><span id="f8ec" class="ol kv it mr b be om on l pw op">import { shallowEqual } from 'react-redux';<br/>...<br/>const randomArray = useSelector(randomArrStateSelector, shallowEqual);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/194bb883f16597103022fccda14073e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iFb8rlvrEsm6m63we4cxWg.gif"/></div></div></figure><p id="1e77" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">更改后，在<strong class="ls iu">计数器</strong>更新时，我们看到<strong class="ls iu"> randomArray </strong>状态函数被多次调用。这很好，因为最重要的是<strong class="ls iu">随机数组</strong>对象不再导致<code class="fe mo mp mq mr b"><strong class="ls iu">useEffect()</strong></code>被触发。</p><h2 id="6ec4" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">具有嵌套属性的对象</h2><p id="5a0c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">接下来，让我们看看另一个类似下面的例子，我们用另一个具有嵌套属性的对象来替换<strong class="ls iu">random array</strong>—<strong class="ls iu">randomDeepObject</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="14a9" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">注意，我们为<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>提供了<strong class="ls iu"> shallowEqual </strong>函数</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/2bfd25bb716d689aaafa01bf37b50bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mjnloWTHeLwgATGl8VhSIA.gif"/></div></div></figure><p id="f24d" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><strong class="ls iu">浅相等</strong>检查对复杂对象不起作用，会导致每个求值周期都将其视为状态变化。在寻找快速解决这个问题的方法之前，我们应该记住redux文档建议——</p><blockquote class="nr"><p id="ac9c" class="ns nt it bd nu nv oq or os ot ou mi dk translated">对<code class="fe mo mp mq mr b">useSelector</code>的每次调用应该总是返回尽可能少的状态— Redux Team</p></blockquote><p id="6a9a" class="pw-post-body-paragraph lq lr it ls b lt ob ju lv lw oc jx ly ld od ma mb lh oe md me ll of mg mh mi im bi translated">所以，我们应该后退一步，看看我们的组件，看看我们是否正确地设计了状态函数。</p><p id="5ad0" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">如果没有其他办法，我们可以再次使用<strong class="ls iu">全局默认变量</strong>，或者在<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>中提供<strong class="ls iu">深度相等</strong>检查函数，例如——</p><pre class="kj kk kl km gt oh mr oi bn oj ok bi"><span id="05f5" class="ol kv it mr b be om on l pw op">import { isEqual } from 'lodash';<br/>...<br/>const randomDeepObject = useSelector(randomDeepObjectStateSelector, isEqual);</span></pre><h2 id="173f" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">回到单用户选择器场景</h2><p id="d0ea" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">现在，你可能想知道我们是否可以在单个<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>案例中使用类似的等式函数方法来避免错误信号</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/8361a9bf9a1e434b66c877561df77d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RykFRlMAyBzYPvQGjXvxDQ.gif"/></div></div></figure><p id="16ac" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">遗憾的是，即使使用深度相等检查，仍然无法防止<code class="fe mo mp mq mr b"><strong class="ls iu">useEffect()</strong></code>的意外触发。</p><p id="21ef" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">这是因为等式检查是在状态函数的结果上执行的。状态属性计数器确实正在更新，这将导致另外两个对象属性被重新评估，因为这三个属性是从单个状态函数返回的。</p><h2 id="b4cc" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">拿走</h2><blockquote class="py pz qa"><p id="eaf8" class="lq lr mz ls b lt mj ju lv lw mk jx ly qb ml ma mb qc mm md me qd mn mg mh mi im bi translated">使用多重<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>，返回尽可能少的数据</p><p id="b8af" class="lq lr mz ls b lt mj ju lv lw mk jx ly qb ml ma mb qc mm md me qd mn mg mh mi im bi translated">预计状态函数会被多次调用，所以我们应该避免在状态函数中意外创建对象</p><p id="1e12" class="lq lr mz ls b lt mj ju lv lw mk jx ly qb ml ma mb qc mm md me qd mn mg mh mi im bi translated">3避免错误信号的快速方法:<br/> —全局默认变量<br/> —浅层等式函数(如来自redux) <br/> —深层等式检查函数(如来自lodash)</p></blockquote><p id="33a3" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">请随意使用我在本文中引用的示例项目——</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qe mu l"/></div></figure></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="c901" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">以上是使用<code class="fe mo mp mq mr b"><strong class="ls iu">useSelector()</strong></code>时一个常见问题的快速浏览，希望本文能帮助您识别现有问题，避免将潜在的错误引入您的代码库。</p><blockquote class="nr"><p id="d6cb" class="ns nt it bd nu nv oq or os ot ou mi dk translated">如果你觉得这篇文章很有帮助，请分享给你的朋友，并给他们一些掌声。请随意查看我的其他文章:</p></blockquote><div class="pc pd pe pf pg ph"><a href="https://medium.com/javarevisited/do-more-with-less-java-lombok-and-experimental-features-8d71d0bcb27c" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">用更少的Java做更多的事— Lombok和实验性特性</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">Lombok让Java再次变酷</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">medium.com</p></div></div><div class="pq l"><div class="qf l ps pt pu pq pv ks ph"/></div></div></a></div><div class="qg qh gp gr qi ph"><a href="https://medium.com/javarevisited/generate-typescript-interfaces-from-java-classes-d53f8c590500" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">从Java类生成TypeScript接口</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">当你可以享受一杯午后的平淡无奇时，为什么还要花时间写界面呢？</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">medium.com</p></div></div><div class="pq l"><div class="qj l ps pt pu pq pv ks ph"/></div></div></a></div></div></div>    
</body>
</html>