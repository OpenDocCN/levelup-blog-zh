<html>
<head>
<title>Driving Towards a Universal Navigation Strategy in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中实现通用导航策略</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/driving-towards-a-universal-navigation-strategy-in-react-a01152e6617c?source=collection_archive---------20-----------------------#2020-05-25">https://levelup.gitconnected.com/driving-towards-a-universal-navigation-strategy-in-react-a01152e6617c?source=collection_archive---------20-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3ade3cffb42aef47acbe246fc05404ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcQbRQMK7poABDne-vTHnQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="9e34" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">当我加入STRV时，他们为我准备了一个具体的要求:为iOS、Android和Web开发一个前端应用程序，在所有平台之间共享组件和业务逻辑。</h2></div><p id="5bad" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因为我是一个喜欢探索新领域的前端开发人员，所以我抓住了这个机会。</p><p id="bf2d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我最终面临着各种各样的挑战——比如缺乏与React Native Web相关的真实场景内容，意外缺乏流行项目的文档，以及努力构建一些特定于平台的模块。</p><p id="fb2e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">本文重点关注这个旅程中的一个关键部分:构建导航解决方案。</p><p id="8c35" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是首先…</p><h1 id="dd98" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">一点背景知识</h1><p id="6b42" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">我之前只做过一个React原生应用的例子(未编译和未发布)。在这个项目的时候，老实说，我对React Native了解不多。</p><p id="6ded" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我第一次听说<a class="ae mm" href="https://expo.io/" rel="noopener ugc nofollow" target="_blank"> Expo </a>和它的实验性网络支持，但我决定不去尝试，主要是因为我喜欢控制项目堆栈并了解正在发生的事情；我希望能够自定义安装，安装模块的自定义版本，并对项目的依赖性有更多的控制。</p><p id="c82d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后我听说了GitHub上的另外两个项目:<a class="ae mm" href="https://github.com/necolas/react-native-web" rel="noopener ugc nofollow" target="_blank"> React Native for Web </a>和<a class="ae mm" href="https://github.com/microsoft/reactxp" rel="noopener ugc nofollow" target="_blank"> ReactXP </a>。两者目标相似，但方法不同。正如ReactXP的官方文件所述:</p><blockquote class="mn mo mp"><p id="8fde" class="kt ku mq kv b kw kx kf ky kz la ki lb mr ld le lf ms lh li lj mt ll lm ln lo im bi translated">ReactXP是一个位于React Native和React之上的层，而React Native for Web是React Native的并行实现——它是React Native for iOS和Android的兄弟。</p></blockquote><p id="f574" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这篇文章不会着重讨论这两者之间的区别，但是，在浏览了一些技术博客文章和演讲之后，我们最终选择了ReactNative for Web。</p><p id="0421" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在深入研究了一些文章并尝试在各自的领域中实现每个环境后，我发现对我来说，最好的起点是一个伟大的模板，名为<a class="ae mm" href="https://github.com/brunolemos/react-native-web-monorepo" rel="noopener ugc nofollow" target="_blank">react-native-we b-monorepo</a>，它使用<a class="ae mm" href="https://yarnpkg.com/lang/en/docs/workspaces/" rel="noopener ugc nofollow" target="_blank"> Yarn Workspaces </a>的一点帮助来支持通用应用程序。</p><p id="100c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是，在开始将这种方法实现到您的项目中之前，我建议您审查您的需求，并检查这些工具是否能解决您的所有需求。</p><h1 id="47bc" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">我们在外面有什么</h1><p id="07e9" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">React.js生态系统上一些流行的路由解决方案并不支持DOM和本地环境；<code class="fe mu mv mw mx b">&lt;div&gt;</code> s不同于<code class="fe mu mv mw mx b">&lt;View&gt;</code>，<code class="fe mu mv mw mx b">&lt;ul&gt;</code> s不同于<code class="fe mu mv mw mx b">&lt;FlatList&gt;</code> s，并且大多数网络原语不同于移动原语——这使得很难提出一个通用的解决方案。<a class="ae mm" href="https://reach.tech/router" rel="noopener ugc nofollow" target="_blank"> @reach/router </a>是选择不面对支持两种环境的挑战的web解决方案的一个例子。</p><p id="190f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不过，截至目前(2020年1月)，我们已经有了一些现成的通用web/native公式。但是它们都没有完全满足我们的需求:</p><ul class=""><li id="5c7d" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">react-router 对于网络来说是一个很好的选择，但是在<a class="ae mm" href="https://reacttraining.com/react-router/native" rel="noopener ugc nofollow" target="_blank"> mobile </a>上，它缺少屏幕转换、模态、导航栏、后退按钮支持和其他基本的导航原语。</li><li id="a964" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated"><a class="ae mm" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> react-navigation </a>非常适合移动设备，但是鉴于其<a class="ae mm" href="https://reactnavigation.org/docs/en/web-support.html" rel="noopener ugc nofollow" target="_blank"> web </a>支持仍被认为是试验性的——尚未在生产中广泛使用——很可能您将面临一些与历史和查询参数相关的问题。此外，它缺少TypeScript类型——这让我自己编写部分定义，因为TypeScript是该项目的必备工具。</li></ul><p id="42ce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就把我们带到了下一部分！</p><h1 id="4848" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">思考解决方案</h1><blockquote class="mn mo mp"><p id="a1b5" class="kt ku mq kv b kw kx kf ky kz la ki lb mr ld le lf ms lh li lj mt ll lm ln lo im bi translated"><em class="je">这篇文章的代码可以在GitHub上找到:</em><a class="ae mm" href="https://github.com/ythecombinator/react-native-web-monorepo-navigation" rel="noopener ugc nofollow" target="_blank"><em class="je">ythe combinator/react-native-we B- monorepo-navigation</em></a></p></blockquote><p id="0b71" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我承认，当我们开始这段旅程时，最令人困惑的事情之一是无法发现使用React Native for Web的流行应用程序(例如Twitter、Uber Eats和这里提到的所有其他<a class="ae mm" href="https://github.com/necolas/react-native-web#react-native-for-web" rel="noopener ugc nofollow" target="_blank"/>)是如何进行导航的——以及它们如何面临像我之前提到的挑战。</p><p id="3fce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以，我们必须自己努力！</p><p id="94ef" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的新解决方案基于对react-router-dom⁴和react-navigation⁵.最新版本的抽象两者都发展了很多，现在他们两个似乎有一些共同的目标，我认为这些目标是在React中正确进行导航/路由的关键决策:</p><ul class=""><li id="16da" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">钩子-第一API</li><li id="19b7" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated">实现导航的声明式方法</li><li id="a5e2" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated">带有TypeScript的一级类型</li></ul><p id="871e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">鉴于此，我们提出了几个实用程序和组件，旨在实现通用导航策略:</p><h2 id="5360" class="nm lq je bd lr nn no dn lv np nq dp lz lc nr ns mb lg nt nu md lk nv nw mf nx bi translated"><code class="fe mu mv mw mx b"><a class="ae mm" href="https://github.com/ythecombinator/react-native-web-monorepo-navigation/blob/master/packages/components/src/utils/navigation" rel="noopener ugc nofollow" target="_blank">utils/navigation</a></code></h2><p id="5959" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">暴露两个挂钩:</p><ul class=""><li id="1fe2" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated"><code class="fe mu mv mw mx b">useNavigation</code>:返回一个<code class="fe mu mv mw mx b">navigate</code>函数，该函数获取一条路线作为第一个参数，其他参数作为其他参数。</li></ul><p id="8b4c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它可以这样使用:</p><pre class="ny nz oa ob gt oc mx od oe aw of bi"><span id="c880" class="nm lq je mx b gy og oh l oi oj">import { useNavigation } from "../utils/navigation";</span><span id="a8c2" class="nm lq je mx b gy ok oh l oi oj">// Our routes mapping – we'll be discussing this one in a minute</span><span id="506b" class="nm lq je mx b gy ok oh l oi oj">import { routes } from "../utils/router";</span><span id="ada7" class="nm lq je mx b gy ok oh l oi oj">const { navigate } = useNavigation();</span><span id="96e8" class="nm lq je mx b gy ok oh l oi oj">// Using the `navigate` method from useNavigation to go to a certain route</span><span id="72e6" class="nm lq je mx b gy ok oh l oi oj">navigate(routes.features.codeSharing.path);</span></pre><p id="0bc8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它还为您提供了一些其他已知的路由实用程序，如<code class="fe mu mv mw mx b">goBack</code>和<code class="fe mu mv mw mx b">replace</code>。</p><ul class=""><li id="1461" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated"><code class="fe mu mv mw mx b">useRoute</code>:返回当前路线的一些数据(例如传递给该路线的<code class="fe mu mv mw mx b">path</code>和<code class="fe mu mv mw mx b">params</code>)。</li></ul><p id="6c96" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就是如何使用它来获得电流<code class="fe mu mv mw mx b">path</code>:</p><pre class="ny nz oa ob gt oc mx od oe aw of bi"><span id="4b77" class="nm lq je mx b gy og oh l oi oj">import { useRoute } from "../utils/navigation";</span><span id="6e74" class="nm lq je mx b gy ok oh l oi oj">const { path } = useRoute();</span><span id="0f04" class="nm lq je mx b gy ok oh l oi oj">console.log(path);</span><span id="a0b4" class="nm lq je mx b gy ok oh l oi oj">// This will log:</span><span id="f445" class="nm lq je mx b gy ok oh l oi oj">// '/features/code-sharing' on the web</span><span id="238b" class="nm lq je mx b gy ok oh l oi oj">// 'features_code-sharing' on mobile</span></pre><h2 id="e5b8" class="nm lq je bd lr nn no dn lv np nq dp lz lc nr ns mb lg nt nu md lk nv nw mf nx bi translated"><code class="fe mu mv mw mx b"><a class="ae mm" href="https://github.com/ythecombinator/react-native-web-monorepo-navigation/tree/master/packages/components/src/utils/router" rel="noopener ugc nofollow" target="_blank">utils/router</a></code></h2><p id="e5a9" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">这基本上包含了一个<code class="fe mu mv mw mx b">routes</code>对象——它包含了每个平台的不同路径和实现——可用于:</p><ul class=""><li id="6d47" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">使用<code class="fe mu mv mw mx b">useNavigation</code>导航</li><li id="13d8" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated">使用<code class="fe mu mv mw mx b">useRoute</code>基于当前路径的切换逻辑</li><li id="a5f5" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated">指定由<code class="fe mu mv mw mx b">Router</code>组件呈现的每条路线的<code class="fe mu mv mw mx b">path</code>和一些额外数据</li></ul><h2 id="39e5" class="nm lq je bd lr nn no dn lv np nq dp lz lc nr ns mb lg nt nu md lk nv nw mf nx bi translated"><code class="fe mu mv mw mx b"><a class="ae mm" href="https://github.com/ythecombinator/react-native-web-monorepo-navigation/tree/master/packages/components/src/Link" rel="noopener ugc nofollow" target="_blank">components/Link</a></code></h2><p id="fab2" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">它提供了应用程序的声明性导航。它是从网上的<code class="fe mu mv mw mx b">react-router-dom</code> <a class="ae mm" href="https://github.com/ythecombinator/react-native-web-monorepo-navigation/blob/master/packages/components/src/Link/index.web.tsx" rel="noopener ugc nofollow" target="_blank">和移动</a>上的<code class="fe mu mv mw mx b">TouchableOpacity</code> + <code class="fe mu mv mw mx b">useNavigation</code>吊钩<a class="ae mm" href="https://github.com/ythecombinator/react-native-web-monorepo-navigation/blob/master/packages/components/src/Link/index.native.tsx" rel="noopener ugc nofollow" target="_blank">建立在<code class="fe mu mv mw mx b">Link</code>之上。</a></p><p id="5d0f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">就像<code class="fe mu mv mw mx b">react-router-dom</code>里的<code class="fe mu mv mw mx b">Link</code>，可以这样用:</p><pre class="ny nz oa ob gt oc mx od oe aw of bi"><span id="f9de" class="nm lq je mx b gy og oh l oi oj">import { Text } from "react-native";</span><span id="ea91" class="nm lq je mx b gy ok oh l oi oj">import { Link } from "../Link";<br/>import { routes } from "../utils/router";</span><span id="a1ec" class="nm lq je mx b gy ok oh l oi oj">&lt;Link path={routes.features.webSupport.path}&gt;<br/>  &lt;Text&gt;Check "Web support via react-native-web"&lt;/Text&gt;<br/>&lt;/Link&gt;</span></pre><h2 id="4c28" class="nm lq je bd lr nn no dn lv np nq dp lz lc nr ns mb lg nt nu md lk nv nw mf nx bi translated"><code class="fe mu mv mw mx b"><a class="ae mm" href="https://github.com/ythecombinator/react-native-web-monorepo-navigation/tree/master/packages/components/src/Router" rel="noopener ugc nofollow" target="_blank">components/Router</a></code></h2><p id="886c" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">这是路由器本身。在网络上，它基本上是一个<code class="fe mu mv mw mx b">BrowserRouter</code>，使用<code class="fe mu mv mw mx b">Switch</code>来选择一条路线。在手机上，它是<code class="fe mu mv mw mx b">Stack</code>和<code class="fe mu mv mw mx b">BottomTab</code>导航仪的组合。</p><p id="a3a9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">综上所述，你得到的是浏览应用程序的每个<a class="ae mm" href="https://github.com/ythecombinator/react-native-web-monorepo-navigation/tree/master/packages/components/src/screens" rel="noopener ugc nofollow" target="_blank">屏幕</a>，看看<code class="fe mu mv mw mx b">useRoute()</code>、<code class="fe mu mv mw mx b">useNavigation()</code>和<code class="fe mu mv mw mx b">&lt;Link /&gt;</code>如何在任何平台上使用。</p><p id="298a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果有人问我未来在这方面的工作，我会提到接下来的步骤:</p><ol class=""><li id="d4a0" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo ol ne nf ng bi translated">添加更多的实用程序——例如，一个<code class="fe mu mv mw mx b">Redirect</code>组件，旨在提供更具声明性的导航approach⁶.</li><li id="86f6" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo ol ne nf ng bi translated">在两个平台上处理边缘案例。</li><li id="dabb" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo ol ne nf ng bi translated">重组导航库中的大部分内容，只留下主要的<code class="fe mu mv mw mx b">Router</code>组件和<code class="fe mu mv mw mx b">utils/router</code>组件在应用程序端编写。</li></ol><h1 id="0611" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">结论</h1><p id="dfd8" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">我的感觉是，web、移动web和原生应用程序环境都需要特定的设计和用户experience⁷——顺便说一下，这符合React Native背后提到的<em class="mq">“一次学习，随处编写】</em> <a class="ae mm" href="https://reactjs.org/blog/2015/03/26/introducing-react-native.html" rel="noopener ugc nofollow" target="_blank">哲学。</a></p><p id="5037" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">虽然代码共享对于React和React Native来说是一个很大的优势，但我要说的是，共享的跨平台代码很有可能应该是:</p><ul class=""><li id="2aaa" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">业务逻辑</li><li id="aee6" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated">配置文件、翻译文件和大多数常量数据——那些不特定于渲染环境的数据</li><li id="9d63" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated">API /格式化；例如API调用、请求和响应数据的认证和格式化</li></ul><p id="153f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该应用程序的其他几层，如路由，应该使用最适合该平台的库，例如，<code class="fe mu mv mw mx b">react-router-dom</code>用于web，而<code class="fe mu mv mw mx b">react-navigation</code>或类似的用于native。</p><p id="fa83" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">也许在未来，我们可以有一个真正统一的代码库，但现在，感觉技术还没有准备好，这里分享的方法似乎是最合适的。</p><h1 id="bb43" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">脚注</h1><p id="047a" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">1)在今年的Reactive Conf大会上，Evan Bacon在Web 博览会上发表了一篇精彩的<a class="ae mm" href="https://www.youtube.com/watch?v=k1FdrhA2sCY" rel="noopener ugc nofollow" target="_blank">演讲——如果你还没有看过，我强烈建议你去看看。</a></p><p id="9c28" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">2)这是布鲁诺·莱默斯创作并使用的，他是<a class="ae mm" href="https://devhubapp.com/" rel="noopener ugc nofollow" target="_blank"> DevHub </a>的作者，这是一个GitHub客户端，可以在Android、iOS、Web和桌面上运行，95%以上的代码在它们之间共享。如果你对他如何想出这个解决方案感兴趣，请查看<a class="ae mm" href="https://dev.to/brunolemos/tutorial-100-code-sharing-between-ios-android--web-using-react-native-web-andmonorepo-4pej" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="1e6e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">3)这些问题包括:</p><p id="8568" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">功能范围:</p><ul class=""><li id="709e" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">来自URL的查询参数未传递(此处为<a class="ae mm" href="https://github.com/react-navigation/web/issues/45" rel="noopener ugc nofollow" target="_blank"/>)</li><li id="35f3" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated">推回不起作用(此处<a class="ae mm" href="https://github.com/react-navigation/web/issues/22" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae mm" href="https://github.com/react-navigation/web/issues/41" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="fbd7" class="my mz je kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated">为了方便起见，将一些参数从一个路由推到另一个路由，并编码到URL中</li></ul><p id="efdc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">开发者体验:</p><ul class=""><li id="8fd5" class="my mz je kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">缺少打字稿打字(<a class="ae mm" href="https://github.com/react-navigation/web/issues/34" rel="noopener ugc nofollow" target="_blank">这里是</a>)——这让我自己写部分定义</li></ul><p id="08a1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">4) <a class="ae mm" href="https://reacttraining.com/blog/react-router-v5/" rel="noopener ugc nofollow" target="_blank"> React Router v5 </a>主要致力于引入结构改进和一些新功能。但是随后<a class="ae mm" href="https://reacttraining.com/blog/react-router-v5-1/" rel="noopener ugc nofollow" target="_blank"> v5.1 </a>带来了一些有用的钩子，允许我们为web实现上面提到的钩子。</p><p id="0e3b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">5) <a class="ae mm" href="https://blog.expo.io/announcing-react-navigation-5-0-bd9e5d45569e" rel="noopener ugc nofollow" target="_blank"> React Navigation v5 </a>也做了很多努力来带来一个现代的、钩子优先的API，允许我们为移动设备实现上面提到的API。</p><p id="926f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">6)这里有一个关于用<code class="fe mu mv mw mx b">&lt;Redirect /&gt;</code> <a class="ae mm" href="https://tylermcginnis.com/react-router-programmatically-navigate/" rel="noopener ugc nofollow" target="_blank">做声明式可组合导航的极好的帖子</a>。</p><p id="6496" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">7)如果你对这个话题感兴趣，在<a class="ae mm" href="https://www.ythecombinator.space/talks/code-sharing-at-scale-one-codebase-for-web-mobile-and-desktop" rel="noopener ugc nofollow" target="_blank">这个演讲</a>中，我分享了在构建一个以代码共享为主要目标的应用程序时学到的一些经验——从项目设置，通过共享基础设施，一直到共享组件和样式——以及你如何才能实现同样的事情。</p></div></div>    
</body>
</html>