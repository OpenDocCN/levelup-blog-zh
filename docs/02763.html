<html>
<head>
<title>Single Number Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一数字算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/single-number-algorithm-7384f74422?source=collection_archive---------6-----------------------#2020-04-03">https://levelup.gitconnected.com/single-number-algorithm-7384f74422?source=collection_archive---------6-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d08f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用XOR按位运算符</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7a86e6325151f681c1616be175f13a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1kWgo0dPS80uoE430hqSQ.jpeg"/></div></div></figure><p id="b02e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">寻找数组中的单个数字是算法中的常见任务。下面我们来看看怎么做。</p><p id="0376" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">给定一个</em> <strong class="kw iu"> <em class="lq">非空的</em> </strong> <em class="lq">整数数组，除一个元素外，每个元素都出现两次。找到那个单身的。</em></p><p id="5c81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="fa08" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">Input:</strong> [2,2,1]<br/><strong class="ls iu">Output:</strong> 1</span></pre><p id="d1d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决方案是:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a377" class="lw lx it ls b gy ly lz l ma mb"><em class="lq">const singleNumber = function(nums) {<br/>return nums.reduce((accumulator, value)=&gt;accumulator^value)<br/>}</em></span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="53dd" class="lw lx it bd mj mk ml dn mm mn mo dp mp ld mq mr ms lh mt mu mv ll mw mx my mz bi translated">为什么和如何？</h2><p id="20fe" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">让我们检查一下建议的解决方案。</p><p id="e0c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用reduce函数并返回累加器，与数组中的每个元素进行比较。</p><p id="5abe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对比？……没错，这个小符号<strong class="kw iu"> <em class="lq"> ^ </em> </strong>被称为“异或”位运算符。</p><p id="725f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，我们来谈谈<strong class="kw iu">【按位运算符】</strong></p><p id="dded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与逻辑运算符比较基元值的方式相同，按位运算符也用于比较，但方式不同。</p><p id="61d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据文件:</p><p id="74c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lq">按位运算符</em> </strong> <em class="lq">将其操作数视为32位序列(零和一)，而不是十进制、十六进制或八进制</em> <code class="fe nf ng nh ls b"><a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="noopener ugc nofollow" target="_blank"><em class="lq">numbers</em></a><em class="lq">.</em></code></p><p id="dd17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着每个操作数都被转换为32位整数，表示为一系列位。你记得二进制吗？</p><p id="30d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我给你看一个例子:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6987" class="lw lx it ls b gy ly lz l ma mb">decimal system: 2 <br/>32 bits system : 00000000 00000000 00000000 00000010</span></pre><p id="2f95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，当我们使用按位运算符时，每个操作数都与另一个操作数的相应位成对出现。因此，在<em class="lq">位</em>和<em class="lq">位</em>之间进行比较。</p><p id="98eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了逻辑运算符，最常见的按位运算符还有AND (&amp;)或(|) XOR (^).<strong class="kw iu"> <em class="lq">没错就一个&amp;或者|或者^ </em> </strong>当然每个按位运算符都有自己的真值表。</p><p id="19c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_AND" rel="noopener ugc nofollow" target="_blank">按位AND </a> <code class="fe nf ng nh ls b">a &amp; b</code>在每个位位置返回一个<code class="fe nf ng nh ls b">1</code>，两个操作数的对应位都是<code class="fe nf ng nh ls b">1</code> s</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="cdde" class="lw lx it ls b gy ly lz l ma mb">                       ╔═══╦═══╦═════════╗<br/>                       ║ a ║ b ║ a <strong class="ls iu">AND</strong> b ║<br/>                       ╠═══╬═══╬═════════╣<br/>                       ║ 0 ║ 0 ║    0    ║<br/>                       ║ 1 ║ 0 ║    0    ║<br/>                       ║ 0 ║ 1 ║    0    ║<br/>                       ║ 1 ║ 1 ║    1    ║<br/>                       ╚═══╩═══╩═════════╝</span></pre><p id="78c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b584" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">&gt;&gt; 1 &amp; 2</strong><br/><em class="lq">1</em> -&gt; 0001<br/><em class="lq">2</em> -&gt; 0010<br/>R -&gt; 0000</span><span id="5c37" class="lw lx it ls b gy nj lz l ma mb">Decimal: 0</span></pre><p id="68d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_OR" rel="noopener ugc nofollow" target="_blank">按位OR </a> <code class="fe nf ng nh ls b">a | b</code>在每个位位置返回一个<code class="fe nf ng nh ls b">1</code>，其中一个或两个操作数的对应位为<code class="fe nf ng nh ls b">1</code> s</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="ecd9" class="lw lx it ls b gy ly lz l ma mb">                       ╔═══╦═══╦═════════╗<br/>                       ║ a ║ b ║ a <strong class="ls iu">OR</strong> b  ║<br/>                       ╠═══╬═══╬═════════╣<br/>                       ║ 0 ║ 0 ║    0    ║<br/>                       ║ 1 ║ 0 ║    1    ║<br/>                       ║ 0 ║ 1 ║    1    ║<br/>                       ║ 1 ║ 1 ║    1    ║<br/>                       ╚═══╩═══╩═════════╝</span></pre><p id="9722" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b4a8" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">&gt;&gt; 1 | 2</strong></span><span id="2bb0" class="lw lx it ls b gy nj lz l ma mb">1 -&gt; 0001<br/>2 -&gt; 0010<br/>R -&gt; 0011<br/>Decimal -&gt; 3</span></pre><p id="bb8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR" rel="noopener ugc nofollow" target="_blank">按位异或</a> <code class="fe nf ng nh ls b">a ^ b</code>在每个位位置返回一个<code class="fe nf ng nh ls b">1</code>，其中任一操作数而非两个操作数的对应位为<code class="fe nf ng nh ls b">1</code></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="15ae" class="lw lx it ls b gy ly lz l ma mb">                       ╔═══╦═══╦═════════╗<br/>                       ║ a ║ b ║ a <strong class="ls iu">XOR</strong> b ║<br/>                       ╠═══╬═══╬═════════╣<br/>                       ║ 0 ║ 0 ║    0    ║<br/>                       ║ 1 ║ 0 ║    1    ║<br/>                       ║ 0 ║ 1 ║    1    ║<br/>                       ║ 1 ║ 1 ║    0    ║<br/>                       ╚═══╩═══╩═════════╝</span></pre><p id="71be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例子</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="badf" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">&gt;&gt; 1 ^ 2</strong><br/>1 -&gt; 0001<br/>2 -&gt; 0010<br/>R -&gt; 0011<br/>Decimal -&gt; 3</span></pre><p id="16da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，按位运算符在二进制表示中执行运算，但它们返回标准的JavaScript数值。</p><p id="2741" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们回到我们的问题。使用XOR运算符，我们可以排除那些相等的值。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a9d9" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">Input:</strong> [2,2,1]</span><span id="f7b8" class="lw lx it ls b gy nj lz l ma mb">First time: 2 XOR 2 </span><span id="b1e6" class="lw lx it ls b gy nj lz l ma mb">2 -&gt; 0010<br/>2 -&gt; 0010<br/>R -&gt; 0000</span><span id="a427" class="lw lx it ls b gy nj lz l ma mb">Now our accumulator has 0 as value.</span><span id="121f" class="lw lx it ls b gy nj lz l ma mb">Second time: 0 XOR 1</span><span id="90de" class="lw lx it ls b gy nj lz l ma mb">0 -&gt; 0000<br/>1 -&gt; 0001<br/>R -&gt; 0001 </span><span id="2d56" class="lw lx it ls b gy nj lz l ma mb">Now our accumulator has 1 and return that value</span></pre><p id="64c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的，这个很简单，让我们试试另一个例子。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d7d2" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">Input:</strong> [4,1,2,1,2]</span><span id="4920" class="lw lx it ls b gy nj lz l ma mb">First time 4 XOR 1</span><span id="f781" class="lw lx it ls b gy nj lz l ma mb">4 -&gt; 0100<br/>1 -&gt; 0001<br/>R -&gt; 0101   -----&gt;  Now our accumulator has 5 as value.</span><span id="402d" class="lw lx it ls b gy nj lz l ma mb">Second time: 5 XOR 2</span><span id="23a8" class="lw lx it ls b gy nj lz l ma mb">5 -&gt; 0101<br/>2 -&gt; 0010<br/>R -&gt; 0111  -----&gt;  Now our accumulator has 7 as value.</span><span id="c6ea" class="lw lx it ls b gy nj lz l ma mb">Third time: 7 XOR 1 </span><span id="9a8b" class="lw lx it ls b gy nj lz l ma mb">7 -&gt; 0111<br/>1 -&gt; 0001<br/>R -&gt; 0110  -----&gt;  Now our accumulator has 6 as value.</span><span id="4168" class="lw lx it ls b gy nj lz l ma mb">Fourth time: 6 XOR 2</span><span id="b592" class="lw lx it ls b gy nj lz l ma mb">6 -&gt; 0110<br/>2 -&gt; 0010<br/>R -&gt; 0100  -----&gt;  Now our accumulator has 4 as value.</span><span id="0a8a" class="lw lx it ls b gy nj lz l ma mb"><br/>Return 4</span></pre><p id="ca85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。现在，您可以使用按位运算符来执行其他逻辑比较。</p><p id="682f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续编码！</p></div></div>    
</body>
</html>