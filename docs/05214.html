<html>
<head>
<title>Multi-Threading and MultiProcessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多线程和多重处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/multi-threading-and-multiprocessing-in-python-3d5662f4a528?source=collection_archive---------3-----------------------#2020-08-12">https://levelup.gitconnected.com/multi-threading-and-multiprocessing-in-python-3d5662f4a528?source=collection_archive---------3-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d17" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python中何时以及如何使用多重处理和多线程</h2></div><p id="7202" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，您将了解到</p><ul class=""><li id="6957" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">多线程和多处理的区别以及何时使用它们</li><li id="afe4" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用<strong class="kk iu"> <em class="ls">多重处理</em> </strong>和<strong class="kk iu"> <em class="ls">并发处理</em> </strong>在Python中实现多重处理</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/86486043e114134a200a52ee6228eec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpEZPRAZY5x-Q0Kc4xwkWw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">照片由<a class="ae mj" href="https://unsplash.com/@lazycreekimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Michael Dziedzic </a>在<a class="ae mj" href="https://unsplash.com/s/photos/computer-processor?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="baa9" class="mk ml it bd mm mn mo dn mp mq mr dp ms kr mt mu mv kv mw mx my kz mz na nb nc bi translated">什么是多重处理？</h2><ul class=""><li id="0eba" class="le lf it kk b kl nd ko ne kr nf kv ng kz nh ld lj lk ll lm bi translated">多重处理允许你在一个程序中产生多个进程。</li><li id="a34a" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">它允许你在你的机器上利用多个CPU内核</li><li id="6a9a" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">一个程序内的多个进程不共享内存</strong></li><li id="9b5e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">避开了Python </strong>的GIL(全局解释器锁)限制，只允许一个线程控制Python解释器</li><li id="30b3" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">用于计算或CPU密集型程序</strong></li></ul><p id="12d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="ls">那么什么是多线程，什么时候使用？</em>T25】</strong></p><p id="b1be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">一根线就是</strong></p><ul class=""><li id="bdde" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">程序中执行的最小独立命令集</strong></li><li id="425a" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">一个应用中的多个线程可以在一个CPU上同时执行，称为<strong class="kk iu">多线程</strong></li><li id="ab35" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">总是在程序</strong>中运行，不能独立运行</li><li id="fe41" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">当程序受限于网络或有大量I/O操作时使用</strong></li><li id="be3c" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">内存在进程</strong>中的多个线程之间共享，因此具有较低的资源消耗</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ni"><img src="../Images/bbbe19cdb962fe4bce1718842c1517f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Y7JWcTJUS4v4_CVHx8CCA.png"/></div></div></figure><p id="0053" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码演示了多重处理不共享内存，而多线程共享内存。T41】</p><p id="cb7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ls">在下面这段代码中，我们检查列表中传递的数字是否是质数。我们将同时使用多线程和多处理来实现这一点</em></p><h2 id="0954" class="mk ml it bd mm mn mo dn mp mq mr dp ms kr mt mu mv kv mw mx my kz mz na nb nc bi translated">使用多线程共享全局变量</h2><p id="be6b" class="pw-post-body-paragraph ki kj it kk b kl nd ju kn ko ne jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">我们创建了一个全局列表变量，<strong class="kk iu"> <em class="ls"> prime_list，</em> </strong>来存储所有素数。</p><p id="1c8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">遍历所有的<strong class="kk iu"> <em class="ls"> list_of_num </em> </strong>，检查数字是否为质数。</p><pre class="lu lv lw lx gt nm nn no np aw nq bi"><span id="2f98" class="mk ml it nn b gy nr ns l nt nu">import threading<br/>import time</span><span id="d39b" class="mk ml it nn b gy nv ns l nt nu">prime_list=[]<br/><strong class="nn iu">def get_prime_numbers(numbers):<br/>    for num in numbers:<br/>        time.sleep(1)<br/>        if check_if_prime(num)==True:<br/>            prime_list.append(num)<br/>    return prime_list</strong></span><span id="5296" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">def check_if_prime(num):<br/>    if num &gt; 1:<br/>       # check for factors<br/>       for i in range(2,num):<br/>           if (num % i) == 0:<br/>               return False<br/>               break<br/>       else:<br/>           return True<br/>           <br/>    # if input number is less than or equal to 1,then not a prime<br/>    else:<br/>       return False</strong></span><span id="1aea" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">def main():</strong><br/>    start_time=time.perf_counter()<br/>    <strong class="nn iu">list_of_num=[9,13,12312, 121, 1913, 97, 57, 34, 37, 89, 81 , 87, 23, 27]</strong><br/>    <br/>    <strong class="nn iu">t1 = threading.Thread(target=get_prime_numbers, args=[list_of_num])<br/>    t1.start()<br/>    t1.join()</strong><br/>    end_time=time.perf_counter()<br/>    <br/>    <strong class="nn iu">print(f"Total time of Thread execution {round(end_time- start_time,4)} for the function ")<br/>    print(f'Prime numbers  {prime_list} from {list_of_num}')</strong></span><span id="13b9" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">if __name__=='__main__':<br/>    main()</strong></span></pre><p id="bc58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="ls">由于线程共享内存或全局变量，所以值是持久的，我们可以在程序的输出中看到这一点。</em>T55】</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nw"><img src="../Images/a3c0b271b72b45bde3cb45d8418a985c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFTVuF7ClXIVUNuoc5I-eQ.png"/></div></div></figure><h2 id="dcad" class="mk ml it bd mm mn mo dn mp mq mr dp ms kr mt mu mv kv mw mx my kz mz na nb nc bi translated">使用多重处理的共享全局变量</h2><p id="d10f" class="pw-post-body-paragraph ki kj it kk b kl nd ju kn ko ne jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">它与上面的功能相同，但是我们使用了<strong class="kk iu"> <em class="ls">多处理</em> </strong>库，而不是<strong class="kk iu"> <em class="ls">线程</em>。</strong></p><p id="64ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于多重处理，创建一个流程实例，并将要执行的函数传递给target，并将所有参数传递给args。这与多线程中的情况相同。</p><p id="9e80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<strong class="kk iu"> <em class="ls"> process.start()启动流程。</em>T12】</strong></p><p id="9e53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主流程使用<strong class="kk iu"> <em class="ls"> join() </em> </strong>等待子流程完成</p><p id="8060" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点击<a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/implementing-threading-in-python-3e2e0858ad07">此处</a>了解更多关于多线程的信息。</p><pre class="lu lv lw lx gt nm nn no np aw nq bi"><span id="93c8" class="mk ml it nn b gy nr ns l nt nu"><strong class="nn iu">import multiprocessing</strong><br/>import time</span><span id="c9a0" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">prime_list=[]</strong></span><span id="f3ed" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">def get_prime_numbers(numbers):<br/>    for num in numbers:<br/>        time.sleep(1)<br/>        if check_if_prime(num)==True:<br/>            prime_list.append(num)<br/>    return prime_list</strong></span><span id="f946" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">def check_if_prime(num):<br/>    if num &gt; 1:<br/>       # check for factors<br/>       for i in range(2,num):<br/>           if (num % i) == 0:<br/>               return False<br/>               break<br/>       else:<br/>           return True<br/>           <br/>    # if input number is less than or equal to 1 else  not prime<br/>    else:<br/>       return False</strong></span><span id="2254" class="mk ml it nn b gy nv ns l nt nu">def main():<br/>    start_time=time.perf_counter()<br/>    <strong class="nn iu">list_of_num=[9,13,12312, 121, 1913, 97, 57, 34, 37, 89, 81 , 87, 23, 27]<br/>    print("No. of CPU's ", multiprocessing.cpu_count())<br/>    p1 = multiprocessing.Process(target=get_prime_numbers, args=[list_of_num])<br/>    p1.start()<br/>    p1.join()</strong><br/>    end_time=time.perf_counter()<br/>    <br/>    <strong class="nn iu">print(f"Total time of Thread execution {round(end_time- start_time,4)} for the function ")<br/>    print(f'Prime numbers  {prime_list} from {list_of_num}')</strong></span><span id="7b74" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">if __name__=='__main__':<br/>    main()</strong></span></pre><p id="101e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="ls">由于每个进程都有其全局变量的副本，我们看到，全局变量prime_list是空的</em> </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nx"><img src="../Images/a5c348c30c12b48da5a1c43efe05b1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPTw6AvvOT9Ne8riGonOBQ.png"/></div></div></figure><p id="f56b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以转到任务管理器，并在“详细信息”选项卡下查看正在运行的多个python.exe</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ny"><img src="../Images/facb48fe55a3336a2bef3c0705577775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Wej67rhxHAWQlq9YK511w.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">显示多个python进程的任务管理器</figcaption></figure><h1 id="6810" class="nz ml it bd mm oa ob oc mp od oe of ms jz og ka mv kc oh kd my kf oi kg nb oj bi translated">进程池执行器</h1><p id="13c5" class="pw-post-body-paragraph ki kj it kk b kl nd ju kn ko ne jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">ProcessPoolExector是一种使用<code class="fe ok ol om nn b"><a class="ae mj" href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">concurrent.futures</strong></a><strong class="kk iu">.</strong></code>实现和产生多个进程的简单方法</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi on"><img src="../Images/f6e23a542f3a53278a89c1cfee69ba46.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/0*-XifLJHXf5f-tfxf.png"/></div></figure><p id="bd2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">concurrent.futures有一个抽象类Executor，它有两个具体的子类</p><ul class=""><li id="7d9a" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">线程池执行器:用于多线程</strong></li><li id="f834" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu"> ProcessPoolExecutor:用于多重处理</strong></li></ul><p id="2290" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面，我们使用了<strong class="kk iu"><em class="ls">ProcessPoolExecutor</em></strong>来读取CSV文件，然后打印文件中的记录数。</p><pre class="lu lv lw lx gt nm nn no np aw nq bi"><span id="c5d3" class="mk ml it nn b gy nr ns l nt nu">import concurrent.futures<br/>import time<br/>import pandas as pd<br/><strong class="nn iu">def read_data(file):<br/>    t1= time.perf_counter()<br/>    data= pd.read_csv(file)<br/>    #data = data.sort_index(ascending=False)<br/>    time.sleep(1)<br/>    t2= time.perf_counter()<br/>    print(f"Took {round(t2-t1,4)} (sec) time to read data in {file}" )<br/>    return f' No. of Records in file {file} are {len(data)}'</strong></span><span id="f76c" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">def main():</strong><br/>    start_time=time.perf_counter()<br/>    <br/>    <strong class="nn iu">with concurrent.futures.ThreadPoolExecutor() as executor:<br/>        file_list=['pollution.csv', 'good_inpu.csv', 'iris.csv']<br/>        return_results=[executor.submit(read_data, file) for file in file_list]</strong><br/>        <br/>    <br/>  <strong class="nn iu">  for f in concurrent.futures.as_completed(return_results):<br/>        print(f.result())</strong><br/>        <br/>    end_time=time.perf_counter()<br/>    <strong class="nn iu">print(f"Total time of execution {round(end_time- start_time,4)} for the function")</strong></span><span id="6111" class="mk ml it nn b gy nv ns l nt nu"><strong class="nn iu">if __name__=='__main__':<br/>    main()</strong></span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/9bbcad796d9d0903aabef2313bc6d613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*RvnJaAckbyEzDrilWVeVgg.png"/></div></figure><h2 id="bab5" class="mk ml it bd mm mn mo dn mp mq mr dp ms kr mt mu mv kv mw mx my kz mz na nb nc bi translated">结论:</h2><p id="fcfb" class="pw-post-body-paragraph ki kj it kk b kl nd ju kn ko ne jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">对于I/O或网络密集型程序，使用多线程使用<strong class="kk iu"> <em class="ls">线程</em> </strong>类或<strong class="kk iu"><em class="ls">ThreadPoolExecutor</em></strong>。对于Python中的计算或CPU密集型程序，为了避开GIL限制，使用多处理，使用<strong class="kk iu"> <em class="ls">多处理</em> </strong>或<strong class="kk iu"> ProcessPoolExecutor。</strong></p></div></div>    
</body>
</html>