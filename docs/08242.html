<html>
<head>
<title>The Open-Closed principle made simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开闭原理变得简单</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-open-closed-principle-made-simple-cc3d0ed70553?source=collection_archive---------3-----------------------#2021-04-14">https://levelup.gitconnected.com/the-open-closed-principle-made-simple-cc3d0ed70553?source=collection_archive---------3-----------------------#2021-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fcd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在向现有代码添加新特性时，遵循这一原则可以避免新的错误。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16052570419af112c2a33f21640bf20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDuO4HcI6aPlxMozRNQO8w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">米海三都</figcaption></figure><p id="6105" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">卡车是一种多功能设备。根据拖车的类型，他们可以执行不同的任务。我们甚至可以用链条拴住拖车(如果载重允许的话)。</p><p id="9ffa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，卡车<strong class="la iu">开放</strong>用于扩展不同的拖车，但<strong class="la iu">关闭</strong>用于修改(如发动机或驾驶室)。编写可扩展代码应该就像交换卡车上的拖车一样简单。</p><h1 id="cd29" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">冰淇淋机的问题</h1><p id="ff45" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">假设我们必须为Ted&amp;Kelly冰淇淋公司编写一个制作可可冰淇淋的程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8653" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码虽然很基础，但是看起来还可以。似乎没有原则被打破。我们将软件交付给客户，客户很满意。</p><p id="0110" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我们正在编写真实世界的应用程序。这意味着需求会不断变化，新的特性会不断出现。</p><h2 id="36ea" class="mt lv it bd lw mu mv dn ma mw mx dp me lh my mz mg ll na nb mi lp nc nd mk ne bi translated">第一个需求变化——添加新口味</h2><p id="8194" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">最初的项目非常成功，Ted&amp;Kelly想要扩展。他们要求我们增加对香草冰淇淋的支持。</p><p id="4d24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">经过一番思考，我们得出了以下解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d7c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们修改原始代码，添加一个参数来指定所需的味道，并添加一个“if”语句来在逻辑之间切换。由于我们已经更新了原始的方法签名，调用我们代码的方法将被破坏，但至少从现在开始，我们应该支持额外的风格而不破坏更改。</p><h2 id="54a4" class="mt lv it bd lw mu mv dn ma mw mx dp me lh my mz mg ll na nb mi lp nc nd mk ne bi translated">第二个需求变化——创建可可和香草组合</h2><p id="bebc" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">生意很好，所以客户想添加一种组合冰淇淋，一种由可可和香草制成的冰淇淋。事情开始变得复杂，但我们能处理好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fb78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们添加了另一个if语句，在这种情况下,“逻辑”被复制到每个if中。在现实世界的应用程序中，我可能会在单独的服务中提取逻辑。但是正如我们将会看到的，提取服务并不总是最好的主意。</p><p id="281d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当Ted&amp;Kelly公司要求更多口味时会发生什么？如果他想进一步结合呢？仅仅添加if子句并不是理想的解决方案。</p><h2 id="444b" class="mt lv it bd lw mu mv dn ma mw mx dp me lh my mz mg ll na nb mi lp nc nd mk ne bi translated">此解决方案的问题</h2><p id="eaf2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">每当我们添加一个新的口味或组合，我们必须更新IceCreamMachine类。这意味着:</p><ul class=""><li id="db6a" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">我们更新已经部署的代码</li><li id="f8fd" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">这堂课变得越来越难读了。想象一下，如果我们有100种口味。这个类很容易膨胀到5000多行代码</li><li id="6201" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">我们可以打破现有的单元测试</li></ul><p id="2758" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回想一下卡车的比喻。你会在每次换拖车的时候换引擎吗？大概不会。让我们看看如何修复它。</p><h1 id="5ca5" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">传统的可扩展性方法</h1><p id="249c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Bertrand Meyer是开闭原则的创始人，他将其定义为“软件实体(类、模块、函数等)”。)应该对扩展开放，但对修改关闭。</p><p id="9122" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，每当我们需要向旧对象添加新行为时，根据需要继承和更新它们。开闭原则是那些易于理解但难以应用的原则之一。</p><p id="c706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们按照这种方法重写代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="118e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">发生了什么事？最初的类被分成四个，每种口味一个，外加一个基础对象。有了这个解决方案，我们解决了所有最初的问题:</p><ul class=""><li id="a36c" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">班级很小，所以更容易理解和管理</li><li id="6b96" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">每当需要一种新的口味时，我们就添加一个新的类</li><li id="88ea" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">现有的单元测试不受影响</li></ul><p id="d226" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理论上看起来一切正常，我们可以就此打住，但是这个解决方案存在一些<strong class="la iu">问题:</strong></p><ul class=""><li id="eb8e" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">不能继承多个类。因此，对于两种风格的组合，我们必须复制一些代码或将逻辑提取到服务中</li><li id="c1f7" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">如果基类中的代码被更新，所有的子类都会受到影响。假设基类有一些通过构造函数注入的依赖项，每次我们添加一个新的依赖项时，所有的子类都必须将那个参数解析到基类构造函数中</li></ul><h1 id="ff1b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">可扩展性的现代方法</h1><p id="f137" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当Robert C. Martin重申Meyer的原则时，他更新为<strong class="la iu">偏好组合而非继承</strong>。</p><p id="4d16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们合成对象时，我们可以自由地按照自己的意愿合成任意多的对象。如果我们针对抽象(接口)编程，我们就有能力改变现有代码的行为而无需修改。让我们看看最终的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d6d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经将原始类分成了三个对象:</p><ul class=""><li id="6eb6" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><strong class="la iu">imakeecream</strong>接口定义了制作冰淇淋的通用抽象</li><li id="312a" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="la iu">实现IMakeIceCream的CacaoIceCream </strong>类</li><li id="ebf2" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="la iu">实现IMakeIceCream的香草冰淇淋</strong>类</li></ul><p id="ad59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用接口，我们将类和实现解耦。接口对于修改是封闭的，所以一旦我们定义了一个接口，它就不能被改变。但是我们可以为新特性定义新接口并继承它们。这使得代码具有可扩展性。</p><p id="a227" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么我给每个构造函数都加了一个“imakeecream”<strong class="la iu"/>参数？新代码是否具有旧方法或遗留方法的所有特性？</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="4cef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答案是肯定的。可可香草组合仍然存在，但我们不需要if子句或专门用于它的类。我们可以利用构造函数参数。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="93f0" class="mt lv it oc b gy og oh l oi oj">var cacaoVanillaIceCream = new CacaoIceCream(new VanillaIceCream());</span><span id="d6ea" class="mt lv it oc b gy ok oh l oi oj">cacaoVanillaIceCream.Make();</span></pre><p id="f4be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。构图的美妙之处在于，我们可以随心所欲地构图。需要4种口味？写一串构造函数就行了。这被称为<strong class="la iu">装饰器</strong>模式。你可以在这里了解更多信息<a class="ae ol" href="https://refactoring.guru/design-patterns/decorator/csharp/example" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0373" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，IMakeIceCream参数是可选的。这允许我在写作中或者单独使用这个类。</p><p id="2dd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像这样写代码会导致插件架构。这很好，因为我们可以通过编写代码来添加新功能，而不会改变现有的功能。任务完成。</p><h1 id="a757" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">外卖食品</h1><ul class=""><li id="a1c7" class="nf ng it la b lb mm le mn lh om ll on lp oo lt nk nl nm nn bi translated">避免更新已部署的代码</li><li id="8c7b" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">设计您的代码，使其易于扩展</li><li id="a941" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">重构图轻继承；它提供了继承的所有好处，没有任何缺点</li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="80b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">坚实的原理制作简单的系列:</strong></p><ul class=""><li id="f3fb" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><a class="ae ol" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-made-simple-4e1597a44d7d">单一责任原则</a></li><li id="9b8e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">开闭原则</li><li id="a964" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae ol" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-made-simple-5e69165e7ab5">里斯科夫替代原理</a></li><li id="f857" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae ol" rel="noopener ugc nofollow" target="_blank" href="/interface-segregation-principle-made-simple-990da495441c">界面偏析原理</a></li><li id="9d83" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae ol" rel="noopener ugc nofollow" target="_blank" href="/the-dependency-inversion-principle-made-simple-70108b88dc76">依存倒置原则</a></li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="3043" class="lu lv it bd lw lx op lz ma mb oq md me jz or ka mg kc os kd mi kf ot kg mk ml bi translated">进一步阅读</h1><div class="ou ov gp gr ow ox"><a href="http://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html#:~:text=The%20Open%20Closed%20Principle%20%28OCP,it%20is%20available%20for%20extension." rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">清洁编码器博客</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">1988年，Bertrand Meyer定义了软件工程最重要的原则之一。开闭原则…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">blog.cleancoder.com</p></div></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://stackify.com/solid-design-open-closed-principle/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">坚实的设计原则解释:开放/封闭原则与代码示例</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">开放/封闭原则是罗伯特……描述的面向对象软件开发的五个设计原则之一</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">stackify.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>