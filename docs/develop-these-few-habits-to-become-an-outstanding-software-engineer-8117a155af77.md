# 养成这几个习惯，成为一名优秀的软件工程师

> 原文：<https://levelup.gitconnected.com/develop-these-few-habits-to-become-an-outstanding-software-engineer-8117a155af77>

## 你所需要的只是纪律。

![](img/58e95f62eb03b02f7ab08e594460feed.png)

照片由[布鲁斯·马斯](https://unsplash.com/@brucemars?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

在过去的十年里，我和大约一百名软件工程师一起工作过。都是各有各的优缺点。

和我一起工作的软件工程师中，大约有一半是拥有良好软技能的技术人员。然而，从我的角度来看，他们中只有少数人是杰出的工程师，因为他们有效地应用了其他工程师部分或完全忽视的几种极其有用的方法。

杰出的软件工程师经常使用这些方法，这已经成为一种习惯。做以下 3 件事的习惯:

# 执行权衡分析

软件工程是一个庞大而复杂的话题，所以通常几乎每个问题都有几种解决方法。例如，在 C#中至少有 [5 种方法来克隆一个对象](/5-ways-to-clone-an-object-in-c-d1374ec28efa)或 [5 种方法来实现一个存储库模式](/5-ways-to-implement-repository-pattern-in-c-e12565e4d4a2)。

虽然为数不多的可用方法中的每一种都可以解决一个编码问题，但您不应该只是随机选择一种或最奇特的一种。您应该执行权衡分析，因为这是为给定问题找到最佳解决方案的唯一可靠方法。

让我们看看这在实践中是如何工作的。

假设您创建了两个简单的类，其中包含一些逻辑:

现在您面临着下一个任务——让这两个类一起工作，因为报告应该在创建后立即发送。在开始编写代码之前，您应该在这里收集完成该任务的不同方法，并进行权衡分析。

权衡分析是写下解决问题的所有方法并指出每种方法的利弊的过程。

权衡分析可能是这样的:

**1。**使用 new 关键字在`GenerateReport`方法的末尾创建一个`ReportSender`类的实例，并调用`Send`方法。

优点:最简单的方法，需要最少的时间来实现。

缺点:两个类将紧密耦合，因为`new`关键字是粘合剂。类`GenerateReport`不能与`ReportSender.`分开重用，`GenerateReport`也不能单独进行单元测试。

**2。**使用依赖注入技术将`ReportSender`类的接口注入到`GenerateReport`类的构造函数中，并在`Generate`方法的末尾调用`Send`方法。

优点:两个类是松散耦合的。这两个类都可以单独测试。

缺点:如果应用程序除了`ReportSender`类之外还有几十个类，这些类需要在报表创建后对其进行处理，该怎么办？`GenerateReport`的逻辑会被一堆通知各利益方的责任污染。

**3。**使用观察者设计模式。`GenerateReport`类应该定义一个事件`ReportGenerationCompleted`，每个感兴趣的对象都可以订阅该事件并做出适当的反应。

优点:订阅者列表可以在运行时更改。此外，这两个类是松散耦合的，因为`GenerateReport`甚至不需要知道`ReportSender`类或其接口的存在。

缺点:需要记得及时退订，避免内存泄露。

**4。**使用中介设计模式…

**5。**使用事件聚合器设计模式…

在确定了所有方法的利弊后，毫不犹豫地选择唯一的一种方法会容易得多。

定期的权衡分析会让你成为一个非常自信和有经验的软件工程师，因为这种方法需要你从不同的角度来看待问题。

# 考虑性能

代码不仅应该工作，还应该工作得很快。这是客户在提供验收标准时可能不会告诉团队的事情，但这绝对不意味着代码运行的任何毫秒或秒数都是可以接受的。

代码通常很慢，原因如下:

*   选择了不适当的数据结构或算法来解决任务。
*   代码经常“修改”不可变的数据类型，所以会导致大量的分配。
*   应用程序从数据库中获取小块数据，而不是一次获取大块数据，因此性能会受到影响，因为对数据库的每次调用都是开销很大的操作。

如果您在完成编码后立即问自己，大量的性能问题可能永远不会出现在测试或生产环境中:

> 我的代码处理大型数据集的速度有多快？

通常程序员使用本地数据库进行开发。本地数据库模式对应于测试或生产数据库。但是，本地的数据量可能会更少，因为在测试或生产环境中，大量数据是由许多活动用户生成的。这意味着你的代码可以一直在本地快速运行，即使是非常低效的算法。

假设您已经实现了检查用户是否有权访问任何内容的逻辑:

第 12 行的代码对于多用户可以很快工作，但是对于数百万用户，性能会差很多，因为列表数据结构只支持线性搜索。如果多次调用`HasAccess`方法，情况会变得更糟，因为复杂度将是 **O(n )** 。

在这种情况下，一个解决方案是使用一个 HashSet 数据结构，在固定时间内执行搜索。

但是不要浪费时间为一个永远不会超过 100 个条目的集合实现一个高效的算法，因为没有人会看到性能差异。明智地管理你的时间。

# 编码前进行深入分析

一个程序员在开始写代码之前，往往需要分析很多东西。分析越全面，编写代码就越容易，代码也就越可靠。编码本身是容易的，分析是困难的。

分析阶段可以分为三个主要部分:

## 分析需求

您应该确保票证中陈述的业务要求对您有意义。还要考虑它们的完整性，如果您觉得描述中缺少一些边缘案例，请与您的业务分析师或产品负责人交谈。

## 分析设计

在这个阶段，您应该决定接口、设计模式和计划功能的集成点。功能越大，在这个阶段犯错误的代价就越高。权衡分析在这里很有帮助，因为通常在设计阶段有几个选项可用，而不仅仅是一个。

## 分析影响区域

对现有代码的任何更改都会破坏其他功能。这些被称为回归问题。优秀的工程师通常遵循如何通过执行影响区域的分析来最小化回归问题风险的策略。我已经在我的另一篇文章中描述了这一点:

[](/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a) [## 如何在不破坏应用程序的情况下修复 Bug

### 更改源代码时更自信的步骤。

levelup.gitconnected.com](/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a) 

简而言之，您应该找到您将要修改的类的输出依赖项(其他类)。任何传出依赖项的行为都会受到您的更改的影响。在收集了输出依赖项之后，您应该理解它们所指的是系统的什么功能。然后将功能列表传递给 QA 工程师，以便他们可以对应用程序中所有可能受影响的位置执行回归测试。

# 最后的想法

如果你需要尽快完成一项任务，遵循这三种方法可能并不容易，因为它们非常耗时。但是永远要把长远放在心上。在你的日常工作中经常应用这些方法，一定会让你成为一个更强大、更有价值的软件工程师。只要养成这三个习惯，你就会受益匪浅。

**感谢阅读！你可能也想看我的其他文章:**

[](/how-to-design-reusable-software-components-213e05119796) [## 开发人员编写可重用代码的两个简单技巧

### 加快发展应遵循的两个基本原则

levelup.gitconnected.com](/how-to-design-reusable-software-components-213e05119796) [](/how-to-avoid-the-headache-with-non-deterministic-bugs-in-software-e24457f05c9b) [## 如何避免软件中令人头痛的非确定性错误

### 再现性:有时

levelup.gitconnected.com](/how-to-avoid-the-headache-with-non-deterministic-bugs-in-software-e24457f05c9b)