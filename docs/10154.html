<html>
<head>
<title>Methods, Algorithms, and Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">方法、算法和泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/methods-algorithms-and-generics-a02dbfa3396b?source=collection_archive---------16-----------------------#2021-10-30">https://levelup.gitconnected.com/methods-algorithms-and-generics-a02dbfa3396b?source=collection_archive---------16-----------------------#2021-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="19dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将方法重新定义为泛型扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/91e6af87a27827c87f2e23c6eeb76df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1F8Sw7Mdhm9eEEm0STFrKA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mfrazi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法鲁尔·拉齐</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发表了一系列关于构建绘画应用程序的文章，其中的最后一篇文章可以在这里找到。</p><div class="lv lw gp gr lx ly"><a href="https://betterprogramming.pub/embracing-algorithms-in-your-swiftui-painting-app-652f8b8cd604" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">在SwiftUI绘画应用中采用算法</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">完成构建我们的iOS paint应用程序的旅程</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">better编程. pub</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="1b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我一直在想这个系列最后一篇论文的主题，拥抱算法。我用肖恩·帕伦特在他关于使用STK算法的C++调味演讲中提倡的原则重新定义了大多数方法；但是我能做更多吗？许多上述方法有一个共同的主题，它们都改变了表示形状的结构上的一个或多个属性。我能开发一个通用版本，有效地减少我的代码库吗？我可以在其他地方使用的代码。</p><h2 id="97aa" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">编码</h2><p id="e511" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这是我第一次尝试去替换一个在画布上取消选择每一个形状的盲循环。它工作得很好，但是非常具体，使用了三个函数——枚举、过滤和映射。我最终在许多方法中使用了这个组合，我能做得更好吗。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是第二个解决方案，虽然它有更多的代码行，但我认为它更好，只使用了一个函数和一个片段——尽管我不得不承认这里有一个循环，说实话——有点难看，不是吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我用递归替换了这个循环——一个代码行更少的解决方案——使用一个函数和片。是的，我知道递归使用堆栈，这可能会溢出——但嘿，现在是2021年，拥有干净的代码在这里肯定是优先的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="dcb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，赋值和比较我可以一气呵成。所以我这么做了，让它少了一行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="de01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有比这更好的了——或者说我做到了。你看，这仍然是一段非常特殊的代码，它将我的Shapes结构上的selected属性设置为false —我想做更多，我需要更通用的东西。所以在等式上加了一个句号。你可以在这里阅读我写的一篇关于闭包的文章。</p><div class="lv lw gp gr lx ly"><a rel="noopener  ugc nofollow" target="_blank" href="/4-custom-closures-syntax-and-semantics-illustrated-using-swiftui-c48db97e4210"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用SwiftUI展示了4个自定义闭包、语法和语义</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在Swift中处理延迟</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mh l"><div class="nn l mj mk ml mh mm ks ly"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要调用deselectEA5，您现在需要在ContentView.swift中使用类似这样的代码。现在，这要灵活得多，因为没有什么可以阻止我向那个trailing方法添加额外的设置。仅用这个方法，我就可以重写几乎所有其他的方法来改变我的形状的属性。方法都有相同的核心代码。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7615" class="mn mo it np b gy nt nu l nv nw">cords.deselectEA5(predecessor: 0) { feed in<br/>  cords.objects[feed].selected = false<br/>}</span></pre><p id="0d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我想了更多，但我决定如果我把它重建成一个扩展，然后可以添加到各种各样的库中，它可能会更有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我无意中发现了一个问题。因为insideMethod不会在主线程上执行，除非您明确告诉编译器这样做。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9b72" class="mn mo it np b gy nt nu l nv nw">cords.objects.deselectEA6(0) { feed in<br/>  DispatchQueue.main.async {<br/>    cords.objects[feed].selected = false<br/>  }<br/>}</span></pre><p id="3fe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经从绘画的角度完成了，但是我还没有完成。我能实现一个更通用的解决方案吗？如果我可以发送一个谓词作为参数，那肯定会更有用，即使它是“选择形状，选择=真”。所以我试了一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然需要一个令人难以置信的电话，但它是超级灵活的。现在我有了一个扩展，可以在其上添加任何谓词，后跟对Shapes结构的任何操作。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a89d" class="mn mo it np b gy nt nu l nv nw">cords.objects.deselectEA7(elementsSatisfying:\.selected, predecessor: cords.objects.startIndex, insideMethod: { feed in<br/>  DispatchQueue.main.async {<br/>    cords.objects[feed].selected = false<br/>  }<br/>})</span></pre><p id="0ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，到了最后的修订版，事实上我根本不应该称之为取消选择8，因为它与形状没有任何联系。这是一个通用扩展，您可以在任何可变集合上使用它来选择所述集合的成员，并在所选成员上执行任意一段代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要用这个代码来调用它。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="aa7c" class="mn mo it np b gy nt nu l nv nw">cords.objects.deselectEA8(elementsSatisfying:\.selected, successor: cords.objects.startIndex, insideMethod: { feed in<br/>  DispatchQueue.main.async {<br/>    cords.objects[feed].selected = false<br/>  }<br/>})</span></pre><p id="7a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这差不多把我带到了结尾…因为在看了<a class="ae ky" href="https://www.youtube.com/watch?v=PcViAYLPWCQ" rel="noopener ugc nofollow" target="_blank"> Wayne的</a>视频后，我承认递归可能不是最好的前进方式，所以必须在列表中再添加一个，一个在循环中运行的通用例程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用这段代码调用的方法。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5153" class="mn mo it np b gy nt nu l nv nw">cords.objects.deselectEA9(elementsSatisfying:\.selected, insideMethod: { feed in<br/>  DispatchQueue.main.async {<br/>    cords.objects[feed].selected = false<br/>  }<br/>})</span></pre><p id="747e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些促使我结束这篇论文。我希望你喜欢读它，就像我喜欢写它一样。如果你喜欢这篇文章/觉得它有用，请给它几个掌声让我知道，更好的是多读几篇我在过去18个月里张贴到medium.com的170多篇论文，并给其中一些投上你的票。</p></div></div>    
</body>
</html>