<html>
<head>
<title>The Dos and Don’ts of Unit Testing in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中单元测试的注意事项</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-testing-68e64eb9bc87?source=collection_archive---------7-----------------------#2022-12-08">https://levelup.gitconnected.com/react-testing-68e64eb9bc87?source=collection_archive---------7-----------------------#2022-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jq jr js jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi gj"><img src="../Images/852fe304954a1b593d453dfe95f337d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*surYbnPCagNX9fESkA1cEQ.png"/></div></div></figure><p id="87f0" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">单元测试是React应用程序开发过程中必不可少的部分。通过为React组件编写单元测试，您可以确保组件按预期工作，并在开发过程的早期发现错误。</p><p id="8013" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">但并不是React组件的所有部分都应该被测试。重要的是将单元测试集中在组件的核心功能上，并避免测试可能随时间而改变的实现细节。</p><p id="4bbb" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">以下是为React组件编写单元测试时需要考虑的一些关键事项，以及代码示例:</p><h1 id="bdd9" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试组件的核心功能:</h1><p id="97ab" class="pw-post-body-paragraph ka kb it kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx im bi translated">这包括测试组件的属性和状态，以及呈现给DOM的输出。例如，您可以测试您的组件是否根据其属性和状态呈现了正确的HTML元素，以及当属性或状态改变时是否正确地更新了DOM。</p><pre class="mb mc md me gt mf mg mh bn mi mj bi"><span id="442f" class="mk kz it mg b be ml mm l mn mo">// This is an example of a unit test that tests the core<br/>// functionality of a React component using the<br/>// `react-testing-library`<br/><br/>import React from 'react';<br/>import { render, fireEvent } from 'react-testing-library';<br/>import MyComponent from './MyComponent';<br/><br/>describe('MyComponent', () =&gt; {<br/>  it('should update the DOM when the props or state change', () =&gt; {<br/>    // Render the component<br/>    const { getByTestId } = render(<br/>      &lt;MyComponent<br/>        title="Hello World"<br/>        showTitle={true}<br/>      /&gt;<br/>    );<br/><br/>    // Check if the component renders the correct HTML elements<br/>    expect(getByTestId('title')).toHaveTextContent('Hello World');<br/>    expect(getByTestId('title')).toBeVisible();<br/><br/>    // Change the props or state of the component<br/>    render(<br/>      &lt;MyComponent<br/>        title="Goodbye World"<br/>        showTitle={false}<br/>      /&gt;<br/>    );<br/><br/>    // Check if the component updates the DOM correctly<br/>    expect(getByTestId('title')).toHaveTextContent('Goodbye World');<br/>    expect(getByTestId('title')).not.toBeVisible();<br/>  });<br/>});</span></pre><h1 id="0b48" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">避免测试实现细节:</h1><p id="7668" class="pw-post-body-paragraph ka kb it kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx im bi translated">重要的是要避免测试可能随时间而改变的实现细节。例如，您不应该测试应用于组件的确切CSS样式，或者呈现的DOM元素的确切顺序。相反，集中测试组件的整体结构和行为。</p><pre class="mb mc md me gt mf mg mh bn mi mj bi"><span id="7ff0" class="mk kz it mg b be ml mm l mn mo">// This is an example of a unit test that the developer<br/>// should avoid writing, because it tests implementation<br/>// details that are likely to change over time<br/><br/>import React from 'react';<br/>import MyComponent from './MyComponent';<br/><br/>describe('MyComponent', () =&gt; {<br/>  it('should apply the correct CSS styles', () =&gt; {<br/>    // Create a shallow wrapper for the component<br/>    const wrapper = shallow(<br/>      &lt;MyComponent<br/>        title="Hello World"<br/>        showTitle={true}<br/>      /&gt;<br/>    );<br/><br/>    // Check if the component applies the correct CSS styles<br/>    expect(wrapper.find('h1').props().style).toEqual({<br/>      color: 'red',<br/>      fontSize: '24px'<br/>    });<br/>    expect(wrapper.find('p').props().style).toEqual({<br/>      color: 'black',<br/>      fontSize: '18px'<br/>    });<br/>  });<br/>});</span></pre><p id="3754" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">在这个例子中，单元测试检查应用于组件中的<code class="fe mp mq mr mg b">h1</code>和<code class="fe mp mq mr mg b">p</code>元素的CSS样式。这是一个可能随时间而改变的实现细节，所以开发人员应该避免编写这个测试。相反，开发人员可以专注于测试组件的整体结构和行为，例如通过使用<code class="fe mp mq mr mg b">toMatchSnapshot</code>工具或者通过测试组件的属性和状态。</p><h1 id="4c06" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为边缘情况和错误条件编写测试</h1><p id="69bf" class="pw-post-body-paragraph ka kb it kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx im bi translated">除了测试组件的核心功能，您还应该编写针对边缘情况和错误条件的测试。这可以帮助您捕捉错误，并确保您的组件在异常或意外的情况下正确运行。</p><pre class="mb mc md me gt mf mg mh bn mi mj bi"><span id="e5bb" class="mk kz it mg b be ml mm l mn mo">import React from 'react';<br/>import { render, fireEvent } from '@testing-library/react';<br/>import MyComponent from './MyComponent';<br/><br/>// test that an error is shown when the input is empty<br/>test('shows an error when input is empty', () =&gt; {<br/>  const { getByLabelText, getByText } = render(&lt;MyComponent /&gt;);<br/>  const input = getByLabelText('Enter your name:');<br/>  fireEvent.change(input, { target: { value: '' } });<br/>  expect(getByText('Please enter a name')).toBeInTheDocument();<br/>});<br/><br/>// test that the component handles special characters in the input<br/>test('handles special characters in the input', () =&gt; {<br/>  const { getByLabelText, getByText } = render(&lt;MyComponent /&gt;);<br/>  const input = getByLabelText('Enter your name:');<br/>  fireEvent.change(input, { target: { value: 'John Doe!' } });<br/>  expect(getByText('Your name is: John Doe!')).toBeInTheDocument();<br/>});</span></pre><p id="09fc" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">在本例中，第一个测试是检查当输入为空时，是否向用户显示一条错误消息。第二个测试是检查组件能否处理输入中的特殊字符(例如感叹号)并正确显示输入。</p><h1 id="6d7c" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用模拟测试您的请求</h1><p id="5ed6" class="pw-post-body-paragraph ka kb it kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx im bi translated">在React测试库中，模拟请求是一个模拟的请求，允许您测试组件如何响应外部API调用，而无需实际发出请求。这是很有用的，原因有很多，包括隔离测试中的组件，避免发出真实网络请求的开销。</p><p id="6e0d" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">为了在React测试库中创建一个模拟请求，您可以使用一个类似于<code class="fe mp mq mr mg b">jest.mock</code>的模拟库来创建一个您在组件中使用的API客户端的模拟版本。例如，如果您的组件向<code class="fe mp mq mr mg b">fetch</code> API发出一个请求，您可以使用<code class="fe mp mq mr mg b">jest.mock</code>创建一个<code class="fe mp mq mr mg b">fetch</code>的模拟版本，在被调用时返回一个预先确定的响应。</p><p id="caab" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">下面是这种情况的一个例子:</p><pre class="mb mc md me gt mf mg mh bn mi mj bi"><span id="ea0c" class="mk kz it mg b be ml mm l mn mo">import React from 'react';<br/>import { fetchData } from './apiClient';<br/>import { MyComponent } from './MyComponent';<br/><br/>// Mock the `fetchData` function to return a pre-determined response<br/>jest.mock('./apiClient', () =&gt; {<br/>  return {<br/>    fetchData: jest.fn().mockResolvedValue('mock response'),<br/>  };<br/>});<br/><br/>it('makes a request to the API and displays the response', async () =&gt; {<br/>  // Render the component<br/>  const { getByTestId } = render(&lt;MyComponent /&gt;);<br/><br/>  // Wait for the mocked API response to be returned<br/>  await waitForElement(() =&gt; getByTestId('api-response'));<br/><br/>  // Assert that the component renders the mocked API response<br/>  expect(getByTestId('api-response')).toHaveTextContent('mock response');<br/>});</span></pre><p id="46ee" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">在这个例子中，我们使用<code class="fe mp mq mr mg b">jest.mock</code>来创建一个被<code class="fe mp mq mr mg b">MyComponent</code>使用的<code class="fe mp mq mr mg b">fetchData</code>函数的模拟版本。这允许我们测试组件的行为，而不需要真正的网络请求。然后我们渲染组件并使用React测试库中的<code class="fe mp mq mr mg b">waitForElement</code>来等待被模仿的API响应被返回。最后，我们断言组件正确地显示了模拟的响应。</p><h1 id="7cb0" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">处理时间戳和日期</h1><p id="931f" class="pw-post-body-paragraph ka kb it kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx im bi translated">当测试包含时间戳的组件时，为了确保测试的一致性和可靠性，模拟当前时间是很有用的。在React测试库中，您可以使用<code class="fe mp mq mr mg b">jest.spyOn</code>函数来模拟<code class="fe mp mq mr mg b">Date</code>构造函数，并控制测试中的当前时间。</p><p id="fde5" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">下面是这种情况的一个例子:</p><pre class="mb mc md me gt mf mg mh bn mi mj bi"><span id="f96c" class="mk kz it mg b be ml mm l mn mo">import { MyTimestampComponent } from './MyTimestampComponent';<br/><br/>it('renders the current time', () =&gt; {<br/>  // Mock the current time to be a fixed value<br/>  const fixedDate = new Date('2022-12-08T11:01:58.135Z');<br/>  jest.spyOn(global, 'Date').mockImplementation(() =&gt; fixedDate);<br/><br/>  // Render the component and assert that it renders the mocked time<br/>  const { getByText } = render(&lt;MyTimestampComponent /&gt;);<br/>  expect(getByText('11:01:58')).toBeInTheDocument();<br/>});</span></pre><p id="621f" class="pw-post-body-paragraph ka kb it kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx im bi translated">在这个例子中，我们使用<code class="fe mp mq mr mg b">jest.spyOn</code>来模拟<code class="fe mp mq mr mg b">Date</code>构造函数，这允许我们在测试中控制当前时间。然后我们渲染<code class="fe mp mq mr mg b">MyTimestampComponent</code>并断言它渲染了被嘲笑的时间。这种方法允许我们以一致和可靠的方式测试组件相对于时间戳的行为。</p></div></div>    
</body>
</html>