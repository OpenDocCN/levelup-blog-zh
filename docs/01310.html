<html>
<head>
<title>Assert.IsNotNull() Should Be Constrained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">断言。应该约束IsNotNull()</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/assert-isnotnull-should-be-constrained-3da531537b94?source=collection_archive---------11-----------------------#2019-12-13">https://levelup.gitconnected.com/assert-isnotnull-should-be-constrained-3da531537b94?source=collection_archive---------11-----------------------#2019-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88130bed723f42095d32b85a0c47e13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c9FdZqBXlz_oq9jD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@grakozy" rel="noopener ugc nofollow" target="_blank">格雷格·拉科齐</a>在<a class="ae kc" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7add" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几天前，我在我目前从事的项目中看到了一些代码。我的一个同事写过这样的东西:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e119" class="lk ll iq lg b gy lm ln l lo lp">int x = GetSomeIntegerValue();<br/>Assert.IsNotNull(x);</span></pre><p id="88d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe lq lr ls lg b">int</code>和<code class="fe lq lr ls lg b">NotNull</code>立刻引起了我的注意。</p><p id="d2ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我考虑了一下，意识到这绝对不会产生一个<code class="fe lq lr ls lg b">Exception</code>。</p><p id="ecb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我问同事为什么写这个他说是为了测试<code class="fe lq lr ls lg b">GetSomeIntegerValue()</code>不返回0。</p><p id="6efd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我向他解释如下:</p><ul class=""><li id="3adc" class="lt lu iq kf b kg kh kk kl ko lv ks lw kw lx la ly lz ma mb bi translated"><code class="fe lq lr ls lg b">IsNotNull()</code>方法中的参数属于<code class="fe lq lr ls lg b">Object</code>类型。</li><li id="8f4a" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated"><code class="fe lq lr ls lg b">int</code>是值类型。</li><li id="dc6b" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">当传递给需要一个<code class="fe lq lr ls lg b">Object</code>的方法时，任何值类型都将被装箱到一个<code class="fe lq lr ls lg b">Object </code>中。</li><li id="6849" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">装箱的值类型永远不能是<code class="fe lq lr ls lg b">null</code>。</li></ul><p id="14fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后他明白了为什么他的测试永远不会失败，并相应地改变了它<strong class="kf ir">(旁注——总是确保你的测试可以通过也可以失败，否则，测试还有什么意义？).</strong></p><p id="9142" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个很好的例子，说明很好地理解较低层次的概念是多么重要，比如拳击。</p><h1 id="d1bb" class="mh ll iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">它应该(或者说“可能”)是什么样子</h1><p id="35fa" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">该方法的全名是:</p><p id="8b7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lq lr ls lg b">Microsoft.VisualStudio.TestTools.UnitTesting.Assert.IsNotNull()</code></p><p id="f531" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法签名是:</p><p id="5974" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lq lr ls lg b">public static void IsNotNull(Object value)</code></p><p id="9e9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我很好奇为什么微软没有使用以下方法将参数约束为引用类型:</p><p id="258f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lq lr ls lg b">public static void IsNotNull&lt;T&gt;(T value) where T : class</code></p><p id="4a52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<a class="ae kc" href="https://www.reddit.com/r/csharp/comments/m6kiyl/assertisnotnull_should_be_constrained/gr7v37d/?context=8&amp;depth=9" rel="noopener ugc nofollow" target="_blank">重载</a>来允许可空值类型:</p><p id="4c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lq lr ls lg b">public void IsNotNull&lt;T&gt;(T? v) where T : struct</code></p><p id="7a1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我在StackOverflow.com上发了一个<a class="ae kc" href="https://stackoverflow.com/questions/32555937/assert-isnotnull-should-constrain-parameter-to-class" rel="noopener ugc nofollow" target="_blank">问题</a></p><p id="1829" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，微软没有使用参数约束的原因是因为泛型在C# 1.0中并不存在</p><p id="20b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果他们把它改成使用泛型和参数约束，就会破坏用C# 1.0编写的代码。</p><p id="c587" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是你必须忍受的事情之一，因为这不是世界末日，也不会破坏旧代码。只要你保持对幕后发生的事情的了解，你就会是对的。</p><p id="23bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">更新:</strong>自从我写了这篇文章，我就被告知答案是使用流畅的断言(fluentassertions.com)，当我有时间的时候，我必须看看这个。</p><p id="498f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果参数是值类型，则使用约束的替代方法是测试失败:</p><p id="a0e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lq lr ls lg b">if(typeof(obj).IsValueType) /* fail the test… */</code></p></div></div>    
</body>
</html>