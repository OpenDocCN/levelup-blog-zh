<html>
<head>
<title>Setting up a Full-Stack TypeScript Application: featuring Express and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置全栈类型脚本应用程序:以Express和React为特色</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/setting-up-a-full-stack-typescript-application-featuring-express-and-react-ccfe07f2ea47?source=collection_archive---------0-----------------------#2019-01-29">https://levelup.gitconnected.com/setting-up-a-full-stack-typescript-application-featuring-express-and-react-ccfe07f2ea47?source=collection_archive---------0-----------------------#2019-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3391" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">非常适合任何规模的项目…初创公司和企业！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/09b1c52e15424b8c6de0a171a69bdf68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Jzkk7h4cxLf_yBXVF54NQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">打字稿的世界是无限的</figcaption></figure><p id="7658" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">许多人会告诉你NodeJS更适合小型项目，而Java/C#这样的静态编译语言更适合大型企业应用程序。这就是TypeScript派上用场的地方；它为您提供了结合静态语言类型安全的脚本语言的快速开发。如果你已经知道JavaScript，那么对于TypeScript的学习曲线是非常小的。TypeScript只是在开始时需要一点额外的设置，因为它是一个超集，而不是技术上的语言。</p><blockquote class="lr ls lt"><p id="42a1" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">只是为了指出这一点，我确信网上到处都有教程向您展示如何为React或NodeJS设置TypeScript。但是我遇到的都是相当零碎的，我从来没有真正读过一个足够全面的。本文的重点是向您展示如何为前端和后端开发设置TypeScript，以及调试、单元测试，然后为生产构建一切。</p></blockquote><h1 id="c5e6" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">编辑2019年6月</h1><p id="6b40" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">现在有一个npm应用程序可以为我们处理本教程的大部分后端部分。它叫做<em class="lu">express-generator-typescript</em>。</p><div class="mv mw gp gr mx my"><a href="https://www.npmjs.com/package/express-generator-typescript" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">快速生成器类型脚本</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">生成类似于express-generate的新的Express应用程序，但是将其设置为使用TypeScript</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.npmjs.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm kp my"/></div></div></a></div><p id="0e8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有的源代码都可以在下面的资源库中找到。在阅读本文时，您应该观察回购中相应的文件/文件夹。</p><div class="mv mw gp gr mx my"><a href="https://github.com/seanpmaxwell/TypeScriptFullStackShell" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">seanpmaxwell/TypeScriptFullStackShell</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">为全栈类型脚本开发设置web应用程序-seanp Maxwell/TypeScriptFullStackShell</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">github.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm kp my"/></div></div></a></div></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="edbb" class="ly lz iq bd ma mb nv md me mf nw mh mi jw nx jx mk jz ny ka mm kc nz kd mo mp bi translated">文件夹层次结构</h1><p id="e38e" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">为了保持有序，我们将把后端的所有配置和依赖项放在目录的根目录下。我们将使用<em class="lu"> create-react-app </em> npm模块生成前端所需的一切，并将其嵌套在<strong class="kx ir"> src/public/react/ </strong>文件夹中。将我们的react应用程序放在这里而不是放在单独的根目录文件夹中的原因是，随着您的web应用程序的增长，您可能最终会提供一些不属于主React应用程序的页面，或者您甚至可能会提供多个React应用程序。</p><p id="ac2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">举个例子，你可能最终让普通用户可以访问的所有前端内容都包含在一个React应用程序中的一条快速路线上。同时，网站管理员使用的内容可以在另一个React应用程序中以不同的快速路线提供。但是对于本教程，我们将只设置一个React项目。</p><p id="f84a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个文件夹作为根目录，并给它起一个你的应用程序的名字。我就叫我的根吧。在里面运行<code class="fe oa ob oc od b">npm init</code>把它变成一个npm包，生成一个<strong class="kx ir"> package.json </strong>文件。创建另一个名为<strong class="kx ir"> src/ </strong>的文件来保存我们的前端和后端代码，创建另一个名为<strong class="kx ir"> util/ </strong>的文件来保存我们用于生产构建的文件。</p><pre class="kg kh ki kj gt oe od of og aw oh bi"><span id="ace4" class="oi lz iq od b gy oj ok l ol om">root/<br/>  src/<br/>    public/<br/>      react/<br/>        demo-react/<br/>  util/<br/>  package.json</span></pre></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="0d28" class="ly lz iq bd ma mb nv md me mf nw mh mi jw nx jx mk jz ny ka mm kc nz kd mo mp bi translated">后端的打字稿</h1><h2 id="e5b8" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">设置ts节点</h2><p id="3a7b" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">要开始在TypeScript中编码，我们需要安装将转换我们的代码的依赖项，然后创建配置文件(尽管它们不是严格必需的),为如何转换它们设置规则。在应用程序的根目录下安装<em class="lu"> ts-node和nodemon </em>，它们运行我们的。ts文件，也可以在检测到更改时重新启动我们的服务器，以及<em class="lu">类型脚本</em>，来调用我们的<em class="lu">。<em class="lu">中的ts </em>文件。js </em>文件。这些模块用于开发，因此请确保使用<code class="fe oa ob oc od b">-D</code>选项。</p><ul class=""><li id="e716" class="oy oz iq kx b ky kz lb lc le pa li pb lm pc lq pd pe pf pg bi translated"><code class="fe oa ob oc od b">npm i -D ts-node nodemon typescript tslint</code></li></ul><p id="5658" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了指定编译规则，在<strong class="kx ir"> root/ </strong>下创建一个名为<strong class="kx ir"> tsconfig.json </strong>的文件，并粘贴以下内容。如果您计划使用Webstorm或VsCode之类的IDE进行调试，我们需要生成<strong class="kx ir"> .js.map </strong>文件，这就是第8行的“sourcemap”的用途。</p><p id="e4a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们最终创建的单元测试测试文件将以. test.ts结尾，并且不需要用于生产，因此确保除了任何前端文件夹之外还排除那些文件，前端文件夹将有它们自己的构建脚本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="db42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了对您的TypeScript实施一套编码标准，创建另一个名为<strong class="kx ir"> tslint.json </strong>的文件。我倾向于把我的设置得非常严格，因为我喜欢遵循惯例，但是如果你愿意的话，你可以随意地摆弄这些设置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="0825" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">创建服务器</h2><p id="9a75" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">现在我们终于可以开始写一些打字稿了。在<strong class="kx ir"> src/ </strong>下创建一个将配置和运行Express的服务器文件。我们可以单独使用plain <em class="lu"> express </em>模块，但是我认为我们应该利用我们使用TypeScript的事实。OvernightJS是一个简单的库，它将decoratorss封装在Express <code class="fe oa ob oc od b">Router</code>对象周围，因此您不必为您创建的每个API实例化一个decorator。它不是Express之上的抽象，也不意味着改变你与它交互的方式。这就是为什么我喜欢它胜过一些大型框架，如<em class="lu"> NestJS </em>或<em class="lu">typescript-express-decorator</em>。</p><div class="mv mw gp gr mx my"><a href="https://www.npmjs.com/package/@overnightjs/core" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">@overnightjs/core</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">Express web服务器的TypeScript decorators。OvernightJS项目的一部分。</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.npmjs.com</p></div></div><div class="nh l"><div class="pj l nj nk nl nh nm kp my"/></div></div></a></div><p id="7c3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装@overnightjs/core，创建一个服务器文件，并从您命名的服务器类扩展<code class="fe oa ob oc od b">Server</code>类。</p><ul class=""><li id="24fe" class="oy oz iq kx b ky kz lb lc le pa li pb lm pc lq pd pe pf pg bi translated"><code class="fe oa ob oc od b">npm i -s overnightjs/core</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="aa65" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">创建start.ts文件</h2><p id="d52c" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我相信你已经准备好看到你的代码运行了…但是首先！！为了让运行/构建我们的应用程序更快一点，让我们创建一个<strong class="kx ir"> start.ts </strong>文件，它可以启动一切。注意我们的<strong class="kx ir"> package.json </strong>文件中的“scripts”键。“脚本”中的每个属性就像一个迷你bash脚本，我们可以用<code class="fe oa ob oc od b">npm run “whatever the key is”</code>运行它。这连同<strong class="kx ir"> start.ts </strong>文件将使我们能够仅用一小组<code class="fe oa ob oc od b">npm run …</code>命令来运行/测试/构建我们的代码。</p><p id="44f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">向<strong class="kx ir"> root/ </strong>添加另一个名为<strong class="kx ir"> start.ts </strong>的文件，并给它一些<code class="fe oa ob oc od b">if-else</code>语句来检查我们是在运行开发/生产还是测试。现在，让我们启动服务器。我们将通过不同的部分来完成这个文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="6620" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了避免每次代码更改时都必须启动和停止Express，让我们使用<em class="lu"> nodemon </em>在源文件发生更改时重启ts-node。nodemon可以直接从命令行或文件导入it设置:文件更简单，所以我们就用它吧。将文件<strong class="kx ir"> nodemon.json </strong>放在<strong class="kx ir"> util/ </strong>下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="6cb5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以其他开发者不用每次都输入很长的命令，我们把nodemon作为属性添加到<strong class="kx ir"> package.json </strong>的“脚本”中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="8409" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第7行的命令将使用<strong class="kx ir"> tsconfig.json </strong>文件中的设置启动ts-node，并在每次运行时以<code class="fe oa ob oc od b">development</code>模式重启服务器:</p><ul class=""><li id="747b" class="oy oz iq kx b ky kz lb lc le pa li pb lm pc lq pd pe pf pg bi translated"><code class="fe oa ob oc od b">npm run start-dev</code></li></ul><p id="a9a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">继续运行该命令，您应该会看到控制台输出的<code class="fe oa ob oc od b">SERVER_START_MSG</code>。对服务器文件(端口或启动消息)进行更改，您应该立即看到Express服务器重新启动和更改。</p><p id="8d9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">恭喜你。！您已经看到了Express/TypeScript开发服务器。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="3023" class="ly lz iq bd ma mb nv md me mf nw mh mi jw nx jx mk jz ny ka mm kc nz kd mo mp bi translated">制作API</h1><p id="8e68" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">拥有一个不做任何事情的Express服务器并不好玩，所以使用OvernightJS让我们制作一个简单的API，它只打印一些文本并发回一个JSON响应。在<strong class="kx ir"> src/ </strong>下创建一个名为<strong class="kx ir"> controllers/ </strong>的文件夹，添加一个控制器文件，随便你怎么命名:我命名为mine <strong class="kx ir"> DemoController.ts </strong>。现在使用OvernightJS的route decorators给它一个API(以后可以添加更多),并给路由一个处理错误响应的<code class="fe oa ob oc od b">try/catch</code>块。这将有助于稍后向您展示如何进行单元测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="e935" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到服务器文件，setup Express解析JSONs并导入/激活我们刚刚创建的控制器。所以我们在浏览器中访问<strong class="kx ir"> localhost:3001 </strong>时不会触发错误，让我们在开发模式下运行服务器时也设置一个默认响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="9aec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">重启nodemon，使用您选择的API调用工具(比如Postman)向<strong class="kx ir">localhost:3001/API/say-hello/:name</strong>发出GET请求。确保您得到一个返回值，并且当您将<code class="fe oa ob oc od b">makeitfail</code>作为参数传入时，Express route触发一个错误。</p><p id="97bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一切顺利，我们可以继续我们的前端！</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="c01c" class="ly lz iq bd ma mb nv md me mf nw mh mi jw nx jx mk jz ny ka mm kc nz kd mo mp bi translated">创建React应用程序</h1><p id="80e9" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">这将需要更少的配置，因为<em class="lu"> create-react-app </em>将为我们的项目旋转一个shell并导入所有必要的依赖项。我们所要做的就是将前端和后端连接起来，这样我们就可以分别开发每一个，同时仍然可以从React内部激活Express APIs。</p><p id="628f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">全局下载<em class="lu"> create-react-app </em>(或者使用<em class="lu"> npx </em>，导航到<strong class="kx ir"> src/public/react/ </strong>，<strong class="kx ir"> </strong>，新建一个TypeScript React项目:</p><pre class="kg kh ki kj gt oe od of og aw oh bi"><span id="ac6a" class="oi lz iq od b gy oj ok l ol om">cd src/public/react/<br/>npx create-react-app demo-react --typescript</span></pre><p id="1b42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">导航到<strong class="kx ir"> demo-react/ </strong>，运行npm start，在<strong class="kx ir"> localhost:3000 </strong>处，您应该会看到react示例页面。</p><h2 id="aaa9" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">在开发过程中将前端和后端连接在一起</h2><p id="3227" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">现在我们已经有了前端和后端，我们需要设置一个代理，这样您的http请求将转到Express，而不是React开发服务器。为了确保我们的配置有效，让我们在React中放一些代码，向我们的“say-hello”API发送请求。为了简单起见，只需添加一些现在自动触发的东西。如果您想在浏览器中显示响应，您需要将响应转换成JSON格式(参见下面的第12行)。使用<em class="lu"> fetch </em>，我在<strong class="kx ir"> demo-react/src/App.tsx </strong>中添加了一个get请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="daba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，为了将我们的请求传送到后端，将<code class="fe oa ob oc od b">proxy</code>属性添加到React应用程序的<strong class="kx ir"> package.json </strong>文件中，并将值设置为运行Express的url:port。请参见下面的第21行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="b9fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果React的开发服务器当前正在运行，保存文件(您应该会看到浏览器自动刷新)，并且应该会出现一个带有API响应的警告。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="edc8" class="ly lz iq bd ma mb nv md me mf nw mh mi jw nx jx mk jz ny ka mm kc nz kd mo mp bi translated">后端单元测试</h1><p id="ecef" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">恭喜，您已经获得了用于开发的全栈Express/React应用程序设置。测试前端所需的工具已经打包在<em class="lu"> create-react-app </em>，<em class="lu"> </em>中，但是因为我们已经从头开始测试后端，所以让我们来看看如何开始测试。有很多测试工具可以使用，但我最喜欢的是<em class="lu"> Jasmine </em>和<em class="lu"> Supertest </em>。Jasmine允许你用<code class="fe oa ob oc od b">describe()</code>和<code class="fe oa ob oc od b">it()</code>编写业务驱动开发测试。Supertest使我们能够在TypScript代码中发出API调用，传递我们想要的任何数据，并为我们进行测试断言的响应提供回调。</p><p id="5b96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装用于测试的两个依赖项及其对应的<em class="lu"> @types/ </em>包:</p><ul class=""><li id="31c5" class="oy oz iq kx b ky kz lb lc le pa li pb lm pc lq pd pe pf pg bi translated"><code class="fe oa ob oc od b">npm i -D jasmine @types/jasmine supertest @types/supertest</code></li></ul><h2 id="c30b" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">测试服务器</h2><p id="34d2" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在<strong class="kx ir">控制器/演示</strong>文件夹中创建另一个文件，其名称与您上一个控制器文件相同，但附加了<strong class="kx ir"> .test.ts </strong>。为了进行API调用，Supertest需要获得我们的Express应用程序的一个实例。不过，我们实际上并不想用<code class="fe oa ob oc od b">this.app.listen</code>来启动我们的服务器，所以我们不使用主<strong class="kx ir"> DemoServer.ts </strong>配置，而是创建一个新的服务器文件来进行测试。它需要做的只是激活一个控制器并返回Express实例。哦，还有一件事，我们仍然需要传递它，不管我们在主服务器文件中做了什么中间件。将该文件放在<strong class="kx ir"> controllers/shared/ </strong>文件夹中，并在测试文件的顶部导入服务器类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><blockquote class="lr ls lt"><p id="16c3" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">这是另一件让通宵如此伟大的事情。为测试目的开发新的Express应用程序是微不足道的。</p></blockquote><h2 id="ef33" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">你的第一个单元测试</h2><p id="8f4b" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在您的测试文件中，在<code class="fe oa ob oc od b">beforeall()</code>方法中配置Supertest，并为每个控制器路由设置一个单元测试。确保为用户在每个单元测试中可以触发的每个可能的路径添加一个断言。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="5cd9" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">配置Jasmine</h2><p id="73ec" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们可以使用<code class="fe oa ob oc od b">jasmine</code>从命令行直接运行Jasmine，但是如果我们想像调试任何其他节点脚本一样调试我们的测试文件，我们需要从<strong class="kx ir">运行Jasmine。js </strong>文件。为此，让我们在<strong class="kx ir"> start.ts </strong>中为Jasmine添加一个配置。</p><p id="3f74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们使用<code class="fe oa ob oc od b">test</code>参数运行<strong class="kx ir"> start.ts </strong>，配置Jasmine从<strong class="kx ir"> src/ </strong>目录加载测试文件(第15-22行)。当编写测试时，您可能不想一次运行所有的测试；您可能只想运行一个测试文件。这就是为什么我们检查第二个参数(这将是一个测试文件的路径)，如果它存在的话，把它传递给Jasmine的<code class="fe oa ob oc od b">execute</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="0419" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将以下属性赋予<strong class="kx ir"> package.json </strong> <code class="fe oa ob oc od b">“scripts”</code>，这样我们就可以用<code class="fe oa ob oc od b">npm run test</code>运行我们的单元测试。</p><ul class=""><li id="47f8" class="oy oz iq kx b ky kz lb lc le pa li pb lm pc lq pd pe pf pg bi translated"><code class="fe oa ob oc od b">“test”: "ts-node ./src/start.ts test"</code></li></ul><p id="a8b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您想通过单元测试，您只需要运行:</p><ul class=""><li id="7269" class="oy oz iq kx b ky kz lb lc le pa li pb lm pc lq pd pe pf pg bi translated"><code class="fe oa ob oc od b">npm test -- "path to the unit-test file" (i.e. controllers/DemoController)</code></li></ul></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="98c5" class="ly lz iq bd ma mb nv md me mf nw mh mi jw nx jx mk jz ny ka mm kc nz kd mo mp bi translated">生产建筑</h1><p id="c0fb" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">开发和测试完代码后，您会想要构建它。ts-node应该只在开发期间使用，所以我们需要生成。用于生产的js文件。</p><h2 id="ed3c" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">自动化构建过程</h2><p id="fda8" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">要为生产构建后端和前端，我们不想每次准备好生产时都必须手动传输我们的类型脚本、构建我们的代码、导航到前端目录、构建代码，然后将捆绑的React应用程序移动到我们的顶级构建文件夹。因此，让我们创建一个脚本来完成所有这些工作，然后配置该应用程序，使其只需一个命令即可运行。</p><p id="b1d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">配置这个脚本来传输我们的后端代码(跳过测试文件)，导航到React应用程序，构建它，给输出文件夹取与React应用程序的文件夹相同的名称(记住要保持一致性)，然后将它移动到构建后端代码的位置。源地图只在开发时需要，所以使用下面第9行的<code class="fe oa ob oc od b">sourceMap false</code>选项，这样我们就不会生成一堆<strong class="kx ir"> .js.map </strong>文件。我用Linux开发，所以用Bash但是，如果您使用的是Windows，您必须查找等效的批处理或PowerShell命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="2f42" class="oi lz iq bd ma on oo dn me op oq dp mi le or os mk li ot ou mm lm ov ow mo ox bi translated">修改服务器文件以服务于前端生产</h2><p id="8d33" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在开发模式中，Express只是向浏览器发送一行代码，告诉我们Express运行在哪个端口上。但是在生产中，Express需要从运行它的同一个端口提供React服务。因为我们的整个前端现在都包含在一个单独的React应用程序中，所以我们可以将静态和视图目录都放在那里。</p><p id="a30d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">向服务器文件添加另一个方法，并在构造函数中添加<code class="fe oa ob oc od b">if</code>语句，该语句在生产模式下为Express设置<strong class="kx ir">视图/ </strong>和<strong class="kx ir">静态/ </strong>目录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="0a90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了激活我们的构建脚本，并使在生产模式下启动我们的整个应用程序变得容易，让我们最后一次修改<strong class="kx ir"> package.json </strong>文件来运行我们的构建脚本，并通过在环境设置为生产的情况下运行构建的启动脚本来启动生产代码。</p><p id="e76f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意下面代码片段中的第7行和第10行。我们可以用<code class="fe oa ob oc od b">npm run build</code>进行生产构建，用<code class="fe oa ob oc od b">npm start</code>开始生产模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="5bb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，当您在生产模式下启动Express服务器，并在浏览器中导航到启动它的同一路径时，您应该会看到React应用程序的显示。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="3939" class="ly lz iq bd ma mb nv md me mf nw mh mi jw nx jx mk jz ny ka mm kc nz kd mo mp bi translated">如果你觉得这篇文章有帮助，请在GitHub上启动repo和OvernightJS repo。祝网络设计愉快:)</h1></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi kf"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="mv mw gp gr mx my"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">18大TypeScript教程-免费学习TypeScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">gitconnected.com</p></div></div><div class="nh l"><div class="pk l nj nk nl nh nm kp my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">gitconnected.com</p></div></div><div class="nh l"><div class="pl l nj nk nl nh nm kp my"/></div></div></a></div></div></div>    
</body>
</html>