<html>
<head>
<title>Explaining error detection and correction codes with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python解释错误检测和纠正代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/explaining-error-detection-and-correction-codes-with-python-be517596d42f?source=collection_archive---------4-----------------------#2021-09-01">https://levelup.gitconnected.com/explaining-error-detection-and-correction-codes-with-python-be517596d42f?source=collection_archive---------4-----------------------#2021-09-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="8ac8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">校验和与汉明码的工作原理</h2></div><p id="2fba" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">不久前，我在玩二维码，写了一些应用程序，基本上是在摆弄它们。我之前没有对二维码做过任何认真的工作，所以我没有意识到它们可以自我纠正。这意味着即使部分二维码丢失，它仍然是可扫描的，您可以从中提取正确的信息！这解释了如何在它上面添加一个图片，屏蔽部分代码，它仍然可以工作。</p><p id="0556" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你不相信或者看不出这有多酷，就试试这个小实验吧。下图二维码部分被撕。试着扫描一下。你会发现，即使它的某些部分丢失了，它仍然可以被扫描。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj lf"><img src="../Images/8f4a6528e8ce21a1ec1f5926861db1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plDtL4R6BNBZMdTF98v74w.jpeg"/></div></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">由于纠错，部分被阻挡或破坏的QR码仍然可以被扫描</figcaption></figure><p id="b570" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">自我校正的能力不在你的二维码扫描软件中，而是在二维码的一部分的一组错误校正码中。</p><h1 id="d7d2" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">误差检测</h1><p id="90df" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">当通过不可靠的信道(大多数信道都是不可靠的)传输和接收信息时，通常需要检查传输的信息是否正确。这些检查通常分为两类——错误检测，用于检查传输过程中是否出现错误；错误纠正，用于检测并纠正错误。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj ms"><img src="../Images/7136bb0c42fda2231a0ffbb1a99eaed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*poXRRZdZAElrrP9C3ZQLoQ.jpeg"/></div></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">泰勒·维克在<a class="ae mt" href="https://unsplash.com/s/photos/sending-data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9382" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">错误检测并不是什么新东西。在公元7世纪到10世纪之间，一群犹太抄写员创造了<a class="ae mt" href="https://www.bl.uk/hebrew-manuscripts/articles/to-read-or-not-to-read-is-not-the-question" rel="noopener ugc nofollow" target="_blank">数字Masorah </a>来确保希伯来圣经被正确抄写。这是通过写下一行、一节、一本书等的字数以及页边空白处的用词统计来完成的。</p><p id="9087" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在软件和硬件中，错误检测和纠正几乎是多余的，这有时使它不可见。例如，在TCP/IP堆栈中，每个以太网帧都使用CRC-32错误检测。IPv4报头有一个校验和来保护其内容。纠错码用于CD播放器、高速调制解调器、深空通信、RAM模块、数据存储、QR码以及许多需要以某种方式传输、存储或验证数据的场合。</p><h2 id="8984" class="mu lw iu bd lx mv mw dn mb mx my dp mf ks mz na mh kw nb nc mj la nd ne ml nf bi translated">校验和</h2><p id="f178" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">有许多错误检测策略。其中一些是如此常用，以至于我们几乎不再注意到它。以<a class="ae mt" href="https://en.wikipedia.org/wiki/Checksum" rel="noopener ugc nofollow" target="_blank">校验和</a>为例，它是从一个较大的数据块中派生出来的一个小数据块，用来验证数据是否正确。这种叫做<a class="ae mt" href="https://en.wikipedia.org/wiki/Luhn_algorithm" rel="noopener ugc nofollow" target="_blank">卢恩算法</a>的版本在很多日常场合都有使用。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj ng"><img src="../Images/b1b1a5d6ae91bd6d87dc09112114a1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yt8vTh_qKXifpCCz-5gR_w.jpeg"/></div></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">图片由<a class="ae mt" href="https://unsplash.com/@cardmapr?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> CardMapr.nl </a>在<a class="ae mt" href="https://unsplash.com/@cardmapr?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3452" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">例如，我们的信用卡号码是16位，最后一位是校验和位。这就是Luhn算法对信用卡号码的工作原理。我们来拿签证(考)号<code class="fe nh ni nj nk b">4001 5900 0000 0001</code>。最后一个数字是<code class="fe nh ni nj nk b">1</code> —这是校验和数字。让我们看看这是如何工作的。</p><p id="a447" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们用剩下的15个数字来处理。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="51c3" class="mu lw iu nk b gz np nq l nr ns">4  0  0  1  5  9  0  0  0  0  0  0  0  0  0  </span></pre><p id="3bee" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">从第一个数字开始，我们将第二个数字加倍。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="8b02" class="mu lw iu nk b gz np nq l nr ns">8  0  0  1 10  9  0  0  0  0  0  0  0  0  0</span></pre><p id="0ef8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">每当你有一个2位数时，我们将这些数字相加得到一个位数(在下面的例子中，我们得到<code class="fe nh ni nj nk b">10</code>，所以我们将它们相加<code class="fe nh ni nj nk b">1 + 0</code>得到<code class="fe nh ni nj nk b">1</code>。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="0521" class="mu lw iu nk b gz np nq l nr ns">8  0  0  1  1  9  0  0  0  0  0  0  0  0  0</span></pre><p id="2861" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">把所有的数字加在一起。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="8624" class="mu lw iu nk b gz np nq l nr ns">8 + 0 + 0 + 1 + 1 + 9 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 19</span></pre><p id="a971" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们把这个数加到校验位上。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="832e" class="mu lw iu nk b gz np nq l nr ns">19 + 1 = 20</span></pre><p id="ce9e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果该数字是10的倍数，则该数字有效。因此，有时这种算法也被称为<a class="ae mt" href="https://en.wikipedia.org/wiki/Modular_arithmetic" rel="noopener ugc nofollow" target="_blank">模数</a> 10算法。</p><p id="4143" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">除了信用卡，校验和还被用于IMEI号码、身份证号码(新加坡的NRIC号码使用模数11校验和算法)、汽车牌照号码等等。</p><h1 id="dc19" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">平价</h1><p id="3e60" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">在数学中，术语<em class="nt">奇偶性</em>是一个整数的属性，无论它是奇数还是偶数。例如，3的奇偶性是奇数，402的奇偶性是偶数。奇偶位或校验位是添加到二进制代码串中使其成为奇数或偶数的位(记住一位是0或1的二进制数)。奇偶校验位是最早也是最常用的错误检测方法之一。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj nu"><img src="../Images/0d2958e24b9c70603e40cd2a5f913018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dATOK0xU-Nmp-Guzv8uF9g.jpeg"/></div></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">照片由<a class="ae mt" href="https://unsplash.com/@nadinmario?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">纳丁·马里奥</a>在<a class="ae mt" href="https://unsplash.com/s/photos/balanced?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5b0a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">基本思想很简单。假设Alice想要使用奇数奇偶校验向Bob发送一条7位数据<code class="fe nh ni nj nk b">1001101</code>。为了计算奇偶校验位，Alice将所有数字加在一起。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="69d9" class="mu lw iu nk b gz np nq l nr ns">1 + 0 + 0 + 1 + 1 + 0 + 1 = 4</span></pre><p id="6a38" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">总和<code class="fe nh ni nj nk b">4</code>是偶数，为了使其成为奇数奇偶校验，Alice需要添加一个奇偶校验位<code class="fe nh ni nj nk b">1</code>使其成为<code class="fe nh ni nj nk b"><strong class="kl iv">1</strong>1001101</code>。请注意，奇偶校验位添加在数字的前面。爱丽丝然后把<code class="fe nh ni nj nk b">11001101</code>发给鲍勃。</p><p id="9dff" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当Bob收到<code class="fe nh ni nj nk b">11001101</code>(即没有错误)时，他检查奇偶校验:</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="025f" class="mu lw iu nk b gz np nq l nr ns">1 + 1 + 0 + 0 + 1 + 1 + 0 + 1 = 5</span></pre><p id="6e96" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这很奇怪，所以他知道数据发送正确。假设Bob接收到<code class="fe nh ni nj nk b">1100110<strong class="kl iv">0</strong></code>，其中一位(最后一位)被翻转。他检查奇偶校验:</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="3ca0" class="mu lw iu nk b gz np nq l nr ns">1 + 1 + 0 + 0 + 1 + 1 + 0 + 0 = 4</span></pre><p id="1430" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是偶数，但是因为奇偶应该是奇数，他知道有误差，尽管他不知道在哪里。</p><p id="2d29" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是宇称的本质。事实上，这正是ASCII对错误检测的作用。ASCII使用7位来表示其数据，对于错误检测，它使用第8位。在移动数据时，奇偶校验是检测错误的一种很好的方式，使用1/8或12.5%的容量进行错误检测也不错。</p><p id="b008" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是等等，如果有2位出错了呢？简而言之，奇偶校验位错误检测不再有效。</p><p id="9ef4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是在我们翻表之前，让我们先来看看一些概率。假设n = 8位，每一位的误差概率为p = 0.01 (1%)。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="a4f2" class="mu lw iu nk b gz np nq l nr ns">Probability of no errors for a single bit = (1–p)<br/>Probability of no errors for n bits = (1-p)^n<br/>Probability of error for at least 1 bit = 1 - (1-p)</span></pre><p id="3874" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这意味着对于n = 8和p = 0.01，误差概率为:</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="ad92" class="mu lw iu nk b gz np nq l nr ns">Probability of error for at least 1 bit = 1 — (1–0.01)⁸ = 0.077 or 7.7%</span></pre><p id="ab44" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">只有1比特的错误概率怎么样？</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="d8d6" class="mu lw iu nk b gz np nq l nr ns">Probability of 1 bit with error and 7 bits no error = p x (1-p)^(n-1)</span></pre><p id="7916" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">因为有n个比特位置:</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="f064" class="mu lw iu nk b gz np nq l nr ns">Probability just 1 bit with error = n x p x (1-p)^(n-1)</span></pre><p id="f0bf" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">同样，对于n = 8和p = 0.01，这是:</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="19fb" class="mu lw iu nk b gz np nq l nr ns">Probability just 1 bit with error = 8 x 0.01 x (1 - 0.01)⁷ = 0.074 or 7.4%</span></pre><p id="d9f2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这应该已经告诉我们一些事情了，但是让我们继续讨论m = 2比特有误差的概率。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="8ded" class="mu lw iu nk b gz np nq l nr ns">Probability of m bits with error and n - m bits with no error = p^m x (1 — p)^(n-2)</span></pre><p id="e00c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">对于m = 2位，我们讨论的是组合，即8位中有2位有错误。不用算，8选2的组合是28(你可以自己算)。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="32bc" class="mu lw iu nk b gz np nq l nr ns">Probability of 2 bits with error and 6 bits with no error = 28 x 0.01² x (1–0.01)⁶ = 0.0026 or 0.26%</span></pre><p id="d46b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你可以自己算m &gt; 3，但是我们来盘点一下。如果我们有一个8位数据块，并且该数据块中某一位出错的概率为1%:</p><ol class=""><li id="4ad0" class="nv nw iu kl b km kn kp kq ks nx kw ny la nz le oa ob oc od bi translated">块中的错误概率是7.7%</li><li id="71ce" class="nv nw iu kl b km oe kp of ks og kw oh la oi le oa ob oc od bi translated">8位中只有1位有错误的概率是7.4%</li><li id="8b95" class="nv nw iu kl b km oe kp of ks og kw oh la oi le oa ob oc od bi translated">8位中有2位出错的概率为0.26%</li></ol><p id="923a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这回答了我们之前的问题:如果数据块中有2个以上的位出错，会发生什么情况。奇偶校验不起作用，但发生这种情况的概率相对较低。</p><p id="58c6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但在我们变得过于兴奋之前，我们先来看看区块是否变大了。假设n = 16，其中15位数据由1位奇偶校验保护，或者6.25%的容量用于错误检测。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="a8fd" class="mu lw iu nk b gz np nq l nr ns">Probability of error for at least 1 bit = 1 — (1–0.01)¹⁶ = 0.148 or 14.8%<br/>Probability just 1 bit with error = 16 x 0.01 x (1 - 0.01)¹⁵ = 0.138 or 13.8%<br/>Probability of 2 bits with error and 6 bits with no error = 120 x 0.01² x (1–0.01)¹⁴ = 0.01 or 1%</span></pre><p id="c752" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如你所见，如果位数变为16，2位出错的概率变为1%。单个奇偶校验位保护的数据越多，它的用处就越小。</p><p id="7406" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">到目前为止，我们只讨论了错误检测，那么错误纠正呢？纠错码是我们添加的嵌入在数据中的代码，这样它们不仅可以用来检测错误，还可以用来定位错误。</p><p id="d0e8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来我们来看看这个。</p><h1 id="1340" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">纠错</h1><p id="e577" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">一种最简单的纠错方法是多次发送数据。这是<a class="ae mt" href="https://en.wikipedia.org/wiki/Repetition_code" rel="noopener ugc nofollow" target="_blank">重复代码</a>的基础。通过多次发送相同的数据，接收器可以检测是否发生了错误(当3个消息不相同时)以及错误发生在哪里(简单多数获胜)。这意味着发送代码的次数不应该是偶数。</p><p id="0538" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们再举一个和之前一样的例子。爱丽丝想把<code class="fe nh ni nj nk b">1001101</code>发送给鲍勃。为了纠错，她使用长度为3的重复码。对数据进行编码，我们得到这个:</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="4ae0" class="mu lw iu nk b gz np nq l nr ns">111 000 000 111 111 000 111</span></pre><p id="c6c4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果我们发送这个，Bob看到相同的重复代码，那么就没有错误。假设鲍勃收到了不同的东西。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="b6aa" class="mu lw iu nk b gz np nq l nr ns"><strong class="nk iv">110</strong> 000 000 111 111 <strong class="nk iv">100</strong> 111</span></pre><p id="b55c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">使用简单多数我们看到<code class="fe nh ni nj nk b">110</code>是错误的，应该是<code class="fe nh ni nj nk b">111</code>，而<code class="fe nh ni nj nk b">100</code>也是错误的，应该是<code class="fe nh ni nj nk b">000</code>。</p><p id="edb5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如你所知，重复代码不是很有效。</p><h2 id="fb33" class="mu lw iu bd lx mv mw dn mb mx my dp mf ks mz na mh kw nb nc mj la nd ne ml nf bi translated">汉明码</h2><p id="c175" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">理查德·海明是一位美国数学家，他的工作在计算机工程和电信方面有很多应用。他是洛斯阿拉莫斯实验室的<a class="ae mt" href="https://www.history.com/topics/world-war-ii/the-manhattan-project" rel="noopener ugc nofollow" target="_blank">曼哈顿计划</a>(是的，那个曼哈顿计划)的一部分，也是贝尔电话实验室<a class="ae mt" href="https://en.wikipedia.org/wiki/Bell_Labs" rel="noopener ugc nofollow" target="_blank">的一部分。当他在贝尔实验室工作的时候，他研究了</a><a class="ae mt" href="https://en.wikipedia.org/wiki/Model_V" rel="noopener ugc nofollow" target="_blank">V型</a>，这是一台机电计算机，它在穿孔纸带上输入信息。当在磁带上检测到错误时，机器会停止并警告操作人员，以便纠正错误。</p><p id="c24e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">海明认为，既然机器能检测出错误，它当然也能定位错误的位置并加以纠正。他的挫败感驱使他研究可以纠错的算法。他设计了术语来描述算法，例如，在ASCII奇偶算法中可以描述为(8，7)码，共有8位，7位是数据位。<em class="nt">码率</em>，即数据位与所有位的比率，为7/8 (87.5%的位为数据)。我们前面讲的重复码是(3，1)码，其中只有33.33%的比特是数据。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj oj"><img src="../Images/a85277f8933849ecc7d6434228518b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyPHuhbDVhIkG21w0vj8pw.png"/></div></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">贝尔实验室的V型机电计算机(由美军照片—<a class="ae mt" href="http://ftp.arl.mil/ftp/historic-computers/" rel="noopener ugc nofollow" target="_blank">http://ftp.arl.mil/ftp/historic-computers/</a>，公共领域，<a class="ae mt" href="https://commons.wikimedia.org/w/index.php?curid=40237251" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=40237251</a>)</figcaption></figure><p id="def2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">他还设计了著名的汉明码，这是最早发明的纠错码之一。它使用奇偶校验来确定错误的位置。</p><h2 id="2aa8" class="mu lw iu bd lx mv mw dn mb mx my dp mf ks mz na mh kw nb nc mj la nd ne ml nf bi translated">汉明码</h2><p id="54e2" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">用一个例子来解释算法更容易。让我们再来看一下之前Alice想要发送给Bob的7位数据<code class="fe nh ni nj nk b">1001101</code>,看看汉明码是如何工作的。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj ok"><img src="../Images/e01be0898df0633e16d49d87e98b12ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOs_OV-iZTy0aEf0dBeoow.png"/></div></div></figure><p id="3cf1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为了对这个数据包进行编码，我们需要将2的幂的比特位置(也就是说，在它们的位置的二进制形式中有一个1比特)作为奇偶校验位，而其余的是数据位。所以这里的奇偶校验位在比特位置1、2、4和8，在二进制中是<code class="fe nh ni nj nk b">0001</code>、<code class="fe nh ni nj nk b">0010</code>、<code class="fe nh ni nj nk b">0100</code>和<code class="fe nh ni nj nk b">1000</code>。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj ol"><img src="../Images/ea96dcb40df00d54225e5c855049a768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nI4oaROw5wfqdBEwiIQuw.png"/></div></div></figure><p id="26fb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">每个奇偶校验位覆盖由其位位置的二进制形式确定的位位置。例如，对于位1，它覆盖具有最低有效位设置的所有位位置，例如3 (11)、5 (101)、7(111)、9 (1001)和11 (1011)。注意，最后一个有效位是1。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj om"><img src="../Images/e92e229ad89e72147f1250168c27494b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNS-1d0CZA4K4i6Ow7aAHQ.png"/></div></div></figure><p id="17c6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我们的例子中，位位置3是1，位位置5是0，位位置7是1，位位置9是1，位11也是1。我们加在一起是4。假设我们想要偶数奇偶校验(奇偶校验并不重要，只要我们在编码和解码时保持一致)，那么奇偶校验位1就被设置为0。</p><p id="94ed" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">对于奇偶校验位2，它将覆盖设置了第二个最低有效位的所有位位置。这意味着奇偶校验位2将覆盖位位置3 (0011)、6 (0110)、7 (0111)、10 (1010)和11 (1011)。如果我们检查这些位置，那么你可以看到相应的位是1，0，1，0，1，加起来是3。为了使它偶校验，我们需要使奇偶校验位2为1。</p><p id="26c0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">同样，奇偶校验位4将覆盖为0、0和1的位位置5、6和7，因此奇偶校验位4需要为1。奇偶校验位8覆盖为1、0和1的位位置9、10和11，因此奇偶校验位8需要为0。</p><p id="efad" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">最终编码的(11，7)码是这样的:</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj on"><img src="../Images/c7ff6cf26c695828b8116f6891bb2f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2A93OxmLamDX5grJnpzRQ.png"/></div></div></figure><p id="e918" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">爱丽丝然后发送<code class="fe nh ni nj nk b">01110010101</code>给鲍勃。当鲍勃收到这个代码时，他需要解码它。为了解码并确定数据是否正确，我们采用二进制形式的位位置，该位位置具有其位设置(即它是1)，然后对其进行XOR运算。</p><p id="02c0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您还记得您的计算机基础知识，XOR或exclusive-or运算是一种逻辑运算，只有当它的参数不相同时才返回true (1)。所以如果你对1和1或者0和0进行异或运算，你会得到0。根据下面的真值表，如果你对1和0或者0和1进行异或运算，你将得到1。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj oo"><img src="../Images/242928f23a6792fb6b95257496d1d0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-q5rvNUQkYgYCnNZ1Sg3Ww.png"/></div></div></figure><p id="96f1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您对设置了位的位位置进行异或运算，并且没有错误，结果将为0！</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj op"><img src="../Images/5e23d0ce20f3867158ebb0d179b080e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pI-I8bApP1uFvNcmYsAGaA.png"/></div></div></figure><p id="569b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">事实上，你也可以选择未置位(0)的位位置，这并不重要。无论哪种情况，如果是0，就意味着没有错误。这看起来很神奇，但是仔细想想，异或的结果基本上就是自变量的奇偶性。</p><p id="d790" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">事实上，如果我们回顾一下我们之前所做的，看看我们是如何得到奇偶校验位的，我们可以使用一个捷径。在设置奇偶校验位之前，我们先来看看数据位的位置。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj ol"><img src="../Images/ea96dcb40df00d54225e5c855049a768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nI4oaROw5wfqdBEwiIQuw.png"/></div></div></figure><p id="964e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在，让我们取已经设置了位的位位置，并对它们进行异或运算。记住，这是在之前<em class="nt">我们设置奇偶校验位。</em></p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj op"><img src="../Images/b7cebeb4c3bae5577970c7ba203b177b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmdmzLDEhoz9P5UK8Rsh3A.png"/></div></div></figure><p id="be3c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">异或的结果基本上是奇偶校验位的设置！这是编码奇偶校验位的快速方法。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj oq"><img src="../Images/4a14c3086dcb2fc59cac19dadc7eeeee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RX1RtuG_YkYUY-ft9_Uuww.png"/></div></div></figure><p id="54b1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是派对的诀窍。如果在传输的信息中有一个错误，当你解码(即做异或)你会得到错误的位置！例如，比特位置10处的值被翻转，而不是0，并且现在被设置为1。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj op"><img src="../Images/ebdd7a494f689f7aa28cbe22bb06776c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpGwPjNjoRzQn4weEA3eiw.png"/></div></div></figure><p id="5f7e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您现在对设置的位位置进行异或运算，而不是对0进行异或运算，您将得到错误发生的位置！这是因为在XOR运算中，除了错误的位之外，其他的都相互抵消了！</p><p id="b986" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果Bob得到这样的结果，他将立即知道错误的位置，并可以将其翻转回来，使代码自我更正。这就是汉明码的工作原理。</p><p id="b2b5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当错误率低时，通常使用汉明码。消息块的大小取决于奇偶校验位的数量<code class="fe nh ni nj nk b">p</code>:</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="030d" class="mu lw iu nk b gz np nq l nr ns">block size n = 2^p - 1</span></pre><p id="6b06" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">例如，对于4个奇偶校验位(1，2，4，8)，在我们的示例中，我们可以达到15位的块大小(即使我们最终只得到n = 11的块大小)。</p><p id="e2c8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">消息块中数据的大小为:</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="cca2" class="mu lw iu nk b gz np nq l nr ns">data k = 2 ^p - 1 - p</span></pre><p id="78c8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我们的示例中，可以表示的最大数据量是15–4，即11(在我们的示例中，我们只有7位)。</p><p id="6f87" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">因此，在我们的例子中，我们使用了(15，11)码和码率，然后<code class="fe nh ni nj nk b">k/n</code>是11/15，这意味着73.7%的消息块是数据。</p><h1 id="5500" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">密码</h1><p id="ff06" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">我们来看一些代码！为此我使用了Python，并且只使用了最基本的Python，没有导入库。您可以很容易地将它移植到大多数语言中。</p><p id="dba2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们从一些基本的助手函数开始。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="7b14" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我将使用与之前相同的汉明(15，11)码。我定义了一个<code class="fe nh ni nj nk b">hamming()</code>函数，它接收奇偶校验位的数量，并返回奇偶校验位位置的列表。例如，如果我将<code class="fe nh ni nj nk b">4</code>传递给函数，我将得到<code class="fe nh ni nj nk b">[1, 2, 4, 8]</code>。这将有助于以后找到奇偶校验位的位置。</p><p id="e576" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">XOR是纠错码的关键，所以我需要一个<code class="fe nh ni nj nk b">xor()</code>函数，它将接受一系列数字并对它们进行XOR运算，然后返回结果。</p><h2 id="5195" class="mu lw iu bd lx mv mw dn mb mx my dp mf ks mz na mh kw nb nc mj la nd ne ml nf bi translated">编码</h2><p id="9e86" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">我们先来看编码！</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="9458" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们从一些数据输入开始。这些步骤是:</p><ol class=""><li id="6e63" class="nv nw iu kl b km kn kp kq ks nx kw ny la nz le oa ob oc od bi translated">获取数据，计算出奇偶校验位的位置，并在这些位置向数据中插入零。这是使用<code class="fe nh ni nj nk b">setup()</code>函数完成的，该函数调用<code class="fe nh ni nj nk b">insert_zeroes()</code>函数来插入0</li><li id="20af" class="nv nw iu kl b km oe kp of ks og kw oh la oi le oa ob oc od bi translated">之后，使用<code class="fe nh ni nj nk b">pos()</code>功能找到设置了位的位位置(即设置为1的位位置)</li><li id="c3cf" class="nv nw iu kl b km oe kp of ks og kw oh la oi le oa ob oc od bi translated">使用<code class="fe nh ni nj nk b">xor()</code>函数对这些位位置编号进行异或运算，以获得我们应该在这些位置设置的奇偶校验位值</li><li id="65a1" class="nv nw iu kl b km oe kp of ks og kw oh la oi le oa ob oc od bi translated">最后，使用<code class="fe nh ni nj nk b">set_parity()</code>功能，获取位值，并将其设置到奇偶校验位位置</li></ol><p id="7df5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们快速看一下这是如何使用的。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="e7a9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们采用与之前相同的数据块示例— <code class="fe nh ni nj nk b">1001101</code>。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="f340" class="mu lw iu nk b gz np nq l nr ns">original: 0b1001101<br/>encoded : 0b10011100101</span></pre><p id="b37a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">奇偶校验位的位置分别为1、2、4和8，值分别为1、0、0和1，因此我们的编码是正确的！</p><h2 id="db25" class="mu lw iu bd lx mv mw dn mb mx my dp mf ks mz na mh kw nb nc mj la nd ne ml nf bi translated">解码</h2><p id="e32c" class="pw-post-body-paragraph kj kk iu kl b km mn jv ko kp mo jy kr ks mp ku kv kw mq ky kz la mr lc ld le in bi translated">接下来我们来看解码。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="410a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">解码基本上颠倒了步骤:</p><ol class=""><li id="d78b" class="nv nw iu kl b km kn kp kq ks nx kw ny la nz le oa ob oc od bi translated">我们使用<code class="fe nh ni nj nk b">pos()</code>函数找到设置了位的位位置(即设置为1的位位置)，然后使用<code class="fe nh ni nj nk b">xor()</code>函数对它们进行异或运算</li><li id="01fd" class="nv nw iu kl b km oe kp of ks og kw oh la oi le oa ob oc od bi translated">如果结果为0，则没有错误，我们继续下一步。</li><li id="b281" class="nv nw iu kl b km oe kp of ks og kw oh la oi le oa ob oc od bi translated">如果结果不为0，那么结果会显示该位出错的位置，我们需要翻转它。使用<code class="fe nh ni nj nk b">flip()</code>功能完成此操作。<code class="fe nh ni nj nk b">flip()</code>函数实际上再次使用XOR来翻转具有错误值的位位置处的位</li><li id="9a73" class="nv nw iu kl b km oe kp of ks og kw oh la oi le oa ob oc od bi translated">一旦我们确定值是正确的，我们需要使用<code class="fe nh ni nj nk b">remove_bit()</code>函数删除奇偶校验位。删除比添加容易，但我们需要以相反的顺序删除位。为什么？这是因为，如果我们按升序删除这些位，位的位置将会改变！</li></ol><p id="3783" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">就是这样！现在让我们看看这是如何一起工作的。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="fc0b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们通过翻转其中一位来模拟误差。</p><pre class="lg lh li lj gu nl nk nm nn aw no bi"><span id="bb7f" class="mu lw iu nk b gz np nq l nr ns">original: 0b1001101<br/>encoded : 0b10011100101<br/>flipped : 0b10001100101<br/>decoded : 0b1001101</span></pre><p id="3c59" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">就是这样！</p><p id="49c7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">代码看起来相当冗长，事实上也的确如此。我们可能会优化它，并做更多的错误捕捉，所以如果你想直接使用它，请考虑自己添加这些。我也没有实现我们如何使用另一个奇偶校验位来进行多达2位的错误检测(尽管汉明只能进行1位纠错)。</p><p id="ec6e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">希望这本书和我写的一样有趣！</p><p id="9270" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是一个笔记本里的全部要点。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="or os l"/></div></figure></div></div>    
</body>
</html>