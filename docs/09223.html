<html>
<head>
<title>Recursion for Dummies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">假人递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/recursion-for-dummies-bb66f0e60a9e?source=collection_archive---------4-----------------------#2021-07-19">https://levelup.gitconnected.com/recursion-for-dummies-bb66f0e60a9e?source=collection_archive---------4-----------------------#2021-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3472" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">递归是计算中的一个基本构造。你不应该因为看到它而惊慌失措。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ce65c90e0bfb74ec142256fe30360649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wOk2ZiBX1V4VQ2INJe6y-Q.gif"/></div></div></figure><p id="51a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有些问题很难。为这些人建立一个心智模型是很有挑战性的。然而，我们有一个强有力的工具。递归！这是一个稳健的想法。</p><p id="f1ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设你正在解决一个问题。你心里有想法。这是一种迭代但模糊的东西——不那么清晰。尽管如此，你觉得这可能是解决办法。但是，你不能实施。这个解很有可能是递归的。</p><p id="3db6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章是为那些到处学习循环和函数的初学者准备的。如果你已经了解了递归的概念，但你不觉得它太直观，那就更好了。</p><p id="c6ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将在这里使用python，因为几乎每个人都这么做。我要你做的是运行你看到的每一段代码。我更喜欢你全部打出来，而不是复制粘贴。</p><p id="c0c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">读完这篇文章后，你会有所收获</p><ol class=""><li id="9509" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">对什么是递归的理解</li><li id="b733" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">通过解决四个递归问题来练习</li><li id="77c0" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">优雅与性能</li><li id="0f8e" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">为什么需要写递归函数</li></ol><h2 id="21bd" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">递归到底是什么意思？</h2><p id="01f3" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">非正式地说，递归函数有一个<code class="fe mz na nb nc b">base case</code>和一个<code class="fe mz na nb nc b">recursive call</code>，这意味着调用函数本身。就是这样。不多不少。</p><h2 id="f0e8" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">问题1</h2><p id="2f34" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">编写一个函数<code class="fe mz na nb nc b">power</code>，它接受一个数字<code class="fe mz na nb nc b">num</code>和一个正整数<code class="fe mz na nb nc b">pow</code>——它返回将<code class="fe mz na nb nc b">num</code>提升到<code class="fe mz na nb nc b">pow</code>的幂的值。</p><p id="f1de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了说明，</p><ol class=""><li id="3c7f" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><code class="fe mz na nb nc b">power(2, 3)</code>会返回<code class="fe mz na nb nc b">8</code></li><li id="2b7a" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><code class="fe mz na nb nc b">power(5, 5)</code>会返回<code class="fe mz na nb nc b">3125</code></li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="41c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了发现<code class="fe mz na nb nc b">base case</code>，让我们首先理解将<code class="fe mz na nb nc b">num</code>提升到<code class="fe mz na nb nc b">pow</code>的幂在形式上意味着什么。</p><p id="b0ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，</p><p id="0053" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">num * num * num * num (pow times)</code>。例如，<code class="fe mz na nb nc b">5 ^ 3 = 5 * 5 * 5 = 125</code></p><p id="692c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是有一个问题。任何数字的幂<code class="fe mz na nb nc b">0</code>都等于<code class="fe mz na nb nc b">1</code>。完美！这可能是一个非常可靠的消息。在代码中，我们会说当用值为<code class="fe mz na nb nc b">0</code>的<code class="fe mz na nb nc b">pow</code>调用函数时，我们将返回<code class="fe mz na nb nc b">1</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">它只说当p为0时返回1</figcaption></figure><p id="e44a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们必须用相同的函数来定义函数。</p><p id="e9c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">5 ^ 3 = 5 * 5 ^ 2</code>或<code class="fe mz na nb nc b">pow(5, 3) = 5 * pow(5, 2)</code>。</p><p id="f0b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">n ^ p = n * n ^ (p-1)</code>总的来说。</p><p id="70f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们已经根据函数本身定义了函数，现在我们可以对它进行编码了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8063" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，你自己写吧。运行它。在进入下一个问题之前，试着理解它。或者，你可以试试这个漂亮的<a class="ae nj" href="http://pythontutor.com/visualize.html" rel="noopener ugc nofollow" target="_blank">可视化工具</a>。</p><h2 id="0332" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">问题2</h2><p id="161c" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">定义一个接受正整数<code class="fe mz na nb nc b">num</code>并返回其阶乘的函数。</p><p id="20f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你在<a class="ae nj" href="https://www.mathsisfun.com/numbers/factorial.html" rel="noopener ugc nofollow" target="_blank">之前从未听说过阶乘，看看这篇关于阶乘</a>的很棒的初级读本。</p><p id="3296" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正整数的阶乘<code class="fe mz na nb nc b">N</code>定义如下，</p><p id="f24a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">N! = N * (N-1) * (N-2) * … * 2 * 1</code></p><p id="a4f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，为了进行递归调用，我们需要根据函数本身来定义函数。在阶乘的情况下，就像<code class="fe mz na nb nc b">N! = N * (N-1)!</code>一样简单。同样，如果你没有得到这个，请检查上面链接的阶乘指南。</p><p id="3db9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你能想到基本情况吗？它直接来自定义，因为<code class="fe mz na nb nc b">zero</code>的阶乘被定义为<code class="fe mz na nb nc b">one</code>。(<code class="fe mz na nb nc b">0! = 1</code>)</p><p id="9206" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您尝试使用第一个问题的信息和示例自己编写代码，将会令人印象深刻。</p><p id="82bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">步骤1:编写基本案例</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="78ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">步骤2:进行递归调用</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><a class="ae nj" href="http://pythontutor.com/visualize.html#code=%23%20factorial%285%29%20%3D%20120%0A%0Adef%20factorial%28num%29%3A%0A%20%20%0A%20%20%23%20the%20base%20case%0A%20%20if%20num%20%3D%3D%200%3A%0A%20%20%20%20return%201%0A%20%20%0A%20%20%23%20the%20recursive%20call%0A%20%20return%20num%20*%20factorial%28num%20-%201%29%0A%20%0Afactorial%285%29&amp;cumulative=false&amp;curInstr=26&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="noopener ugc nofollow" target="_blank"> Pythontutor可视化</a></figcaption></figure><p id="de0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你已经走了这么远，恭喜你！现在，你对编写递归函数更有信心了。让我们试着多写一些递归函数来固化你的理解。</p><h2 id="a36a" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">更加结构化的思维框架</h2><p id="c54d" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">正如我之前说过的，递归实际上是一种数学构造。因此，它有一些正式的定义和证明。为了让你可爱的小脑袋免于困惑，每当你解决递归问题时，你可以遵循以下步骤。</p><p id="6046" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第一步:基础案例</strong></p><p id="ca89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本情况是递归函数最关键的部分。它必须坚如磐石。如果其中有任何漏洞——也就是说如果你的递归调用没有命中基本用例——你就冒着代码抛出一个被广泛称为<strong class="kt ir"> StackOverflow </strong>异常的风险。在幕后，您的程序进行无限的递归调用，因此为每个调用创建一个堆栈。堆栈内存有限。因此，基本情况是递归函数的关键。</p><p id="24da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第二步:递归调用</strong></p><p id="638a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">递归调用很难正确。在你的头脑中运行递归调用将是痛苦的。</p><p id="95c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，您可以简单地这样做，</p><ol class=""><li id="b126" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">假设该函数适用于所有其他输入。这意味着你必须假设你的递归调用是有效的。</li><li id="f4d3" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">现在，让函数为当前输入工作</li></ol><p id="c585" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这实际上是递归证明的工作方式。称之为<strong class="kt ir">归纳法证明。</strong>不过递归解题不一定要学。</p><h2 id="fea8" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">问题3</h2><p id="e8f9" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">定义一个接受正整数<code class="fe mz na nb nc b">num</code>的函数，并返回一个包含该范围<code class="fe mz na nb nc b">[N,1]</code>中元素的列表。</p><p id="6d0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">举个例子，</p><ol class=""><li id="fc5e" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><code class="fe mz na nb nc b">makeList(5)</code>将返回<code class="fe mz na nb nc b">[5, 4, 3, 2, 1]</code></li><li id="3421" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><code class="fe mz na nb nc b">makeList(1)</code>将返回<code class="fe mz na nb nc b">[1]</code></li></ol><p id="1682" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你能看到这里的基本情况吗？这是第二个例子。每当使用参数<code class="fe mz na nb nc b">1</code>调用我们的函数时，它将简单地返回一个包含该参数的列表，即<code class="fe mz na nb nc b">[1]</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5419" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本情况是可靠的。无论该函数抛出什么有效输入，如果递归调用被准确构造，它将不可避免地求助于基本情况，从而避免<strong class="kt ir"> StackOverflow </strong>异常。</p><p id="6286" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于递归调用，我们将采用稍微不同的方法。首先，我们将把递归调用的结果存储在一个变量中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7380" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按照我上面提到的递归心理框架，在这一点上，我们完成了<code class="fe mz na nb nc b">base-case</code>和<code class="fe mz na nb nc b">recursive-call</code>。我们假设递归调用完成了它的工作，因为我们已经假设该函数对所有其他输入都有效。</p><p id="cf94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们必须只让它为当前输入工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6210" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们完了。</p><h2 id="598a" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">问题4</h2><p id="59c1" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">这将是我们今天看到的最后一个问题。和上一个差不多。所以，你，如果还没有的话，可以试着把你的手弄脏。</p><p id="420d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">定义一个函数，该函数将整数列表<code class="fe mz na nb nc b">lst</code>和长度<code class="fe mz na nb nc b">l</code>作为参数，并将返回列表中所有元素的总和。</p><p id="e1ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了说明，</p><ol class=""><li id="63f0" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><code class="fe mz na nb nc b">sumList([1, 2, 3, 4, 5], 5)</code>将返回<code class="fe mz na nb nc b">15</code></li><li id="101b" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><code class="fe mz na nb nc b">sumList([9], 1)</code>将返回<code class="fe mz na nb nc b">9</code></li></ol><p id="969e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本情况很简单，因为我已经在示例中向您展示了这一点。每当列表的长度为1时，函数将简单地返回列表的第一个元素，实际上是唯一的元素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="43f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们考虑一下递归调用。这样想，长度为<code class="fe mz na nb nc b">N</code>的整数列表中所有元素的总和等于列表中的第一个元素加上列表中其余元素的总和。这是构造递归调用的关键。根据相同的函数定义函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="f4c3" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">优雅与性能</h2><p id="65ae" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">一旦你熟悉了递归函数的编写，你就会真正体会到与迭代实现相比，递归实现是多么优雅。如果你遵循所说的心理框架，递归代码将非常容易阅读。</p><p id="0839" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，递归函数的性能不如迭代函数。因为它涉及到为每个递归调用创建一个堆栈框架。虽然，有一种编写尾递归函数的惯用方法。尾递归在命令式范式中并不常见，但在函数式语言中有一流的支持。尾递归函数只用一个堆栈就能完成任务，因此与迭代函数的性能相当。</p><h2 id="3512" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">需要写递归函数吗？</h2><p id="a17e" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">你可能想到的一个明显的问题是，你是否需要写递归函数。因为到目前为止，我展示的所有代码都可以通过一个简单的for循环轻松实现。实际上，所有这些例子都是用<code class="fe mz na nb nc b">sequential</code>数学函数或<code class="fe mz na nb nc b">linear data structures</code>运算的。的确，在这些特定的用例中，迭代实现是不错的。</p><p id="1fda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，让我提醒你，这些是递归函数的基本实例，让你了解这个概念。只有在操作<code class="fe mz na nb nc b">tree-like</code>数据结构时，你才会意识到递归的真正威力。树状数据结构基本上被设计成递归的。</p><p id="e013" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我偶然发现经典的河内塔问题时，我第一次欣赏了递归。我强烈建议你看看下面的视频。这是一个看似简单，实则极其困难的问题的迷人表现。在了解解决方案之后，确保考虑迭代实现。我都不敢想象会有多难看。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk ne l"/></div></figure><h2 id="d10f" class="mb mc iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">摘要</h2><p id="6225" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">这是整首曲子的总结，</p><ol class=""><li id="c3c8" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">递归是强大的</li><li id="beed" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">任何迭代构造都可以递归实现</li><li id="a239" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">递归函数需要坚实的基础。否则，您可能会遇到StackOverflow异常。</li><li id="0e70" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对于递归调用，你必须根据同一个函数来定义函数。</li><li id="7c1f" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">编写递归调用时，假设该函数适用于所有其他输入。然后让它为当前输入工作。</li><li id="23a5" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">可以说，递归比迭代更优雅。</li><li id="cfb5" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">与迭代相比，递归的性能较差，因为它涉及到为每个操作创建一个新的堆栈。</li><li id="dd05" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">通过编写一个名为<code class="fe mz na nb nc b">tail-recursion</code>的惯用结构，可以避免性能问题。它在函数范式中得到了广泛的支持。</li><li id="d5ea" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对于<code class="fe mz na nb nc b">sequential math functions</code>和<code class="fe mz na nb nc b">linear data structures</code>来说，迭代实现通常是可读和简单的。</li><li id="2759" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对于<code class="fe mz na nb nc b">tree-like</code>数据结构，递归更适合，因为这些数据结构基本上是递归的。</li><li id="b8de" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">为了欣赏递归，第一次，你可以检查河内 问题的<a class="ae nj" href="https://www.youtube.com/watch?v=rf6uf3jNjbo&amp;t=1s" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">塔。</strong></a></li></ol><p id="c31b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我很高兴你已经做到了。希望现在你对<code class="fe mz na nb nc b">recursive-constructs</code>更加熟悉了，你可能已经回避很久了。享受递归之旅。</p><p id="1d85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我真的希望你能就你的想法说几句话。✏️</p><p id="6fe4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以给我买杯咖啡来支持我的工作。☕</p><div class="nl nm gp gr nn no"><a href="https://www.buymeacoffee.com/nilTheDev" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">尼兰詹🌱🌱正在写编程相关的文章</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">嘿👋我写编程相关的文章。我还是个学生。你可以请我喝杯咖啡，让我开心一天。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">www.buymeacoffee.com</p></div></div></div></a></div></div></div>    
</body>
</html>