<html>
<head>
<title>ProtoServer: Implementing Elixir’s GenServer from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ProtoServer:从头开始实现Elixir的GenServer</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/protoserver-implementing-an-elixir-genserver-from-scratch-d8948c5bba77?source=collection_archive---------11-----------------------#2022-07-24">https://levelup.gitconnected.com/protoserver-implementing-an-elixir-genserver-from-scratch-d8948c5bba77?source=collection_archive---------11-----------------------#2022-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="090d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从Erlang流程开始，一路揭开Elixir GenServers背后的神秘面纱</h2></div><p id="624c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">Elixir最显著的特性之一是将<em class="ll">进程</em>作为核心抽象，这要归功于它基于Erlang和<a class="ae lk" href="https://www.erlang.org/blog/a-brief-beam-primer/" rel="noopener ugc nofollow" target="_blank"> BEAM </a> VM。</p><p id="a5dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Elixir通过<a class="ae lk" href="https://hexdocs.pm/elixir/1.12/GenServer.html" rel="noopener ugc nofollow" target="_blank"> GenServer </a>提高原始流程的可用性，然后通过<a class="ae lk" href="https://hexdocs.pm/elixir/1.13.2/Agent.html" rel="noopener ugc nofollow" target="_blank">代理、</a> <a class="ae lk" href="https://hexdocs.pm/elixir/Application.html" rel="noopener ugc nofollow" target="_blank">应用</a>和<a class="ae lk" href="https://hexdocs.pm/gen_stage/GenStage.html" rel="noopener ugc nofollow" target="_blank"> GenStage </a>将其提升到更高的水平。</p><p id="7388" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我开始使用长生不老药的时候，发电机似乎对我有魔力。虽然我最终广泛地使用了它们，但它们实际上是如何工作的，以及它们与<a class="ae lk" href="https://www.erlang.org/doc/man/supervisor.html" rel="noopener ugc nofollow" target="_blank">监督树</a>的关系是一个谜。</p><p id="a07c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在这里，我们将尝试从Erlang进程开始，通过构建一个关于如何实现Elixir GenServers <em class="ll">的近似模型，来解开它们是如何工作的。我们不会涵盖关于流程、管理器或Elixir应用程序的所有内容——仅仅是为了更好地理解GenServers在幕后是如何工作的。</em></p><p id="dd54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本练习的最后，我们将编写一个“原型GenServer”模块，我们称之为<code class="fe lm ln lo lp b">ProtoServer</code>，我们可以将它<code class="fe lm ln lo lp b">use</code>为常规的GenServer，并提供基本的<code class="fe lm ln lo lp b">GenServer.call</code>语法和功能。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="eb35" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">处理</h1><p id="7d40" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">Erlang <a class="ae lk" href="https://www.erlang.org/doc/reference_manual/processes.html" rel="noopener ugc nofollow" target="_blank">进程</a>是它实现大规模、可靠的并发的方式。</p><p id="779b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个教科书示例，看看它们是如何用Erlang编写的，然后我们将从这个示例切换到Elixir。</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="9535" class="nc ly iq lp b gy nd ne l nf ng">-module(spawn).<br/>-export([start/0, greet/1]).</span><span id="f1d0" class="nc ly iq lp b gy nh ne l nf ng">greet(Arg1) -&gt;<br/>   io:format("Hello, ~p!~n", [Arg1]).<br/>start() -&gt;<br/>   Pid = spawn(?MODULE, greet, ["world"]),<br/>   io:fwrite("~p",[Pid]).</span></pre><p id="0945" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将上面的代码写到<code class="fe lm ln lo lp b">spawn.erl</code>，我们可以使用<code class="fe lm ln lo lp b">erl</code> shell来执行它:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="678a" class="nc ly iq lp b gy nd ne l nf ng">$ erl<br/>Erlang/OTP 24 [erts-12.2] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [jit]</span><span id="f6a6" class="nc ly iq lp b gy nh ne l nf ng">Eshell V12.2  (abort with ^G)<br/>1&gt; c('spawn').<br/>{ok,spawn}<br/>2&gt; spawn:start().<br/>&lt;0.86.0&gt;Hello, "world"!<br/>ok</span></pre><p id="3dcc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，<code class="fe lm ln lo lp b">spawn</code>可以接受一个模块、一个函数名和一个参数列表。然后，它作为一个独立的进程执行指定的函数(向其传递参数列表)。</p><p id="7a94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在酏剂中，与上述内容相当的是:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="9a52" class="nc ly iq lp b gy nd ne l nf ng">defmodule Spawn do<br/>  def greet(name), do: IO.puts "Hello, #{name}"<br/>end</span><span id="dfd0" class="nc ly iq lp b gy nh ne l nf ng">:erlang.spawn(Spawn, :greet, ["world"])</span></pre></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="0c15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Elixir提供了一个简单得多的<code class="fe lm ln lo lp b"><a class="ae lk" href="https://elixir-lang.org/getting-started/processes.html#spawn" rel="noopener ugc nofollow" target="_blank">spawn/1</a></code>函数，如果我们只想在后台执行一些代码(又名“启动并忘记”)，就可以使用这个函数:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="aba6" class="nc ly iq lp b gy nd ne l nf ng">spawn(fn -&gt; IO.puts("Hello in the background!") end)</span></pre><p id="9665" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们让它等待几毫秒，我们可以看到它在后台:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="f479" class="nc ly iq lp b gy nd ne l nf ng">iex&gt; spawn(fn -&gt; :timer.sleep(500); IO.puts("Hello in the background!") end)<br/>#PID&lt;0.107.0&gt;<br/>Hello in the background!</span></pre><blockquote class="ni nj nk"><p id="eeca" class="kf kg ll kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated"><code class="fe lm ln lo lp b"><a class="ae lk" href="https://elixir-lang.org/getting-started/processes.html#links" rel="noopener ugc nofollow" target="_blank">spawn_link/1</a></code>是<code class="fe lm ln lo lp b">spawn/1</code>的替代，它将错误传播或冒泡到父进程。我们不会在这里深入讨论，但是只知道用<code class="fe lm ln lo lp b">spawn_link</code>在父进程和产生的子进程之间创建一个“链接”,这样如果父进程失败(或者产生一个错误),错误就会“冒泡”到父进程。</p></blockquote><p id="e1cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过编写一个调用自身(递归无限循环)的函数来进一步说明这一点:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="bfea" class="nc ly iq lp b gy nd ne l nf ng">iex&gt; defmodule Loop do<br/>  def loop() do<br/>    IO.puts("Looping...")<br/>    :timer.sleep(1000)<br/>    loop()<br/>  end<br/>end</span><span id="6452" class="nc ly iq lp b gy nh ne l nf ng">iex&gt; pid_loop = spawn(&amp;Loop.loop/0)<br/>Looping...<br/>#PID&lt;0.117.0&gt;<br/>Looping...<br/>Looping...<br/>Looping...<br/>...</span></pre><p id="8c63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，<code class="fe lm ln lo lp b">spawn/1</code>返回一个PID或<em class="ll">进程标识符</em>。</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="873a" class="nc ly iq lp b gy nd ne l nf ng">iex&gt; inspect(pid_loop)<br/>"#PID&lt;0.118.0&gt;"</span></pre><p id="30da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们所能做的就是在后台执行代码，那么我们就不会有太多裸露的<a class="ae lk" href="https://en.wikipedia.org/wiki/Thread_(computing)" rel="noopener ugc nofollow" target="_blank">线程</a>。</p><blockquote class="ni nj nk"><p id="9efd" class="kf kg ll kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">如果您所需要的是在后台执行代码，并且可能确定它是否成功完成或者检查和处理任何失败，那么您应该使用Tasks而不是<code class="fe lm ln lo lp b"><em class="iq">spawn/1</em></code>。参见<a class="ae lk" href="https://elixir-lang.org/getting-started/processes.html#tasks" rel="noopener ugc nofollow" target="_blank">https://elixir-lang . org/getting-started/processes . html # tasks</a></p></blockquote><h1 id="89f3" class="lx ly iq bd lz ma no mc md me np mg mh jw nq jx mj jz nr ka ml kc ns kd mn mo bi translated">进程间通信</h1><p id="7ea3" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">Elixir进程让我们比低级线程做得更多，因为进程不仅仅是并发执行代码的手段——它们还提供了<em class="ll">消息传递</em>(在Erlang中是<em class="ll">信号</em>)。</p><p id="0bc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更早地退出无限循环函数，我们只需向它发送退出信号:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="ecce" class="nc ly iq lp b gy nd ne l nf ng">Looping...<br/>Looping...<br/>iex&gt; Process.exit(pid_loop, 0)<br/>true</span><span id="aa93" class="nc ly iq lp b gy nh ne l nf ng">iex&gt;</span></pre><p id="55d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们编写另一个无限循环的函数，但这次我们将演示如何发送和接收有意义的消息:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="1453" class="nc ly iq lp b gy nd ne l nf ng">iex&gt; defmodule Receiver do<br/>  def loop() do</span><span id="a693" class="nc ly iq lp b gy nh ne l nf ng">    # receive blocks, awaiting a message<br/>    receive do<br/>      {:greet, name} -&gt; IO.puts("Hello, #{name}")<br/>      msg -&gt; IO.puts "Received unknown message: #{inspect(msg)}"<br/>    end<br/>    loop()<br/>  end<br/>end</span><span id="2c7d" class="nc ly iq lp b gy nh ne l nf ng">iex&gt; pid = spawn(&amp;Receiver.loop/0)<br/>#PID&lt;0.119.0&gt;</span></pre><p id="2f9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当执行<code class="fe lm ln lo lp b">receive</code>块时，流程等待，直到有消息发送给它，模式匹配收到的消息，然后执行匹配分支。然后，接收器自行循环，等待下一条消息:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="4a18" class="nc ly iq lp b gy nd ne l nf ng">iex&gt; send(pid, {:greet, "world"})<br/>Hello, world<br/>{:greet, "world"}</span><span id="c4f6" class="nc ly iq lp b gy nh ne l nf ng">iex&gt; send(pid, "foo")<br/>Received unknown message: "foo"<br/>"foo"</span></pre><p id="7db5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有了一个持久的、有背景的演员的开端。</p><h2 id="9a13" class="nc ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">邮筒</h2><p id="ce5b" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">灵药信号不仅仅是一些在后台调用函数的精心设计的方法。当我们说Elixir有消息传递时，我们的意思是每个进程实际上都有一个可以充当消息队列的<em class="ll">邮箱</em>！</p><p id="30f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过在接收器中添加人工延迟，然后一个接一个地发送几条消息来看到这一点:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="16e8" class="nc ly iq lp b gy nd ne l nf ng">iex&gt; defmodule Mailbox do<br/>  def loop() do<br/>    receive do<br/>      {:greet, name} -&gt; greet(name)<br/>      msg -&gt; IO.puts "Received unknown message: #{inspect(msg)}"<br/>    end<br/>    loop()<br/>  end<br/>  def greet(name) do<br/>    IO.puts("Hello, #{name}")<br/>    :timer.sleep(1000)<br/>  end<br/>end</span><span id="a94d" class="nc ly iq lp b gy nh ne l nf ng">iex&gt; Enum.each(1..5, fn i -&gt; send(pid, {:greet, ["world #{i}"]}) end)<br/>Hello, world 1<br/>:ok<br/>Hello, world 2<br/>Hello, world 3<br/>Hello, world 4<br/>Hello, world 5</span></pre><p id="5d5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里我们可以看到，即使在发送完所有消息后,<code class="fe lm ln lo lp b">Enum.each/2</code>循环已经返回，这些消息仍然保存在邮箱中，直到<code class="fe lm ln lo lp b">receive</code>被调用。一旦接收到所有的消息，下一个对<code class="fe lm ln lo lp b">receive</code>的调用将等待另一个消息。</p><h1 id="ac89" class="lx ly iq bd lz ma no mc md me np mg mh jw nq jx mj jz nr ka ml kc ns kd mn mo bi translated">状态</h1><p id="649c" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在面向对象编程中，持久对象用于在堆中保存状态，直到它们被显式释放、垃圾回收或程序退出。</p><p id="29f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为Elixir是功能性的，而不是让持久的“对象”占用堆上的内存并响应方法调用，我们有并发运行并响应消息的进程。但是持久状态呢？</p><p id="4d3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单。函数调用可以带参数，函数没有理由不能带参数递归调用自己！</p><p id="a464" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先让我们编写一个简单的倒计时函数:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="907a" class="nc ly iq lp b gy nd ne l nf ng">defmodule Count do<br/>  # call the loop with initial state<br/>  def down do<br/>    IO.puts("Counting down...")<br/>    loop(5)<br/>  end</span><span id="cecc" class="nc ly iq lp b gy nh ne l nf ng">  # this recursively calls itself with its own 'state'<br/>  def loop(n) do<br/>    if n &gt; 0 do<br/>      IO.puts("#{n}")<br/>      :timer.sleep(1000)<br/>      loop(n-1)<br/>    end<br/>  end<br/>end</span><span id="5de4" class="nc ly iq lp b gy nh ne l nf ng">pid = spawn(&amp;Count.down/0)<br/>IO.puts("spawn(&amp;Count.down/0) -&gt; #{inspect(pid)}")<br/>:timer.sleep(5000)</span></pre><p id="1f85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把它写到<code class="fe lm ln lo lp b">count_down.exs</code>，然后用<code class="fe lm ln lo lp b">elixir count_down.exs</code>运行它，我们得到的输出是:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="0e6b" class="nc ly iq lp b gy nd ne l nf ng">elixir count_down.exs<br/>Counting down...<br/>5<br/>spawn(&amp;Count.down/0) -&gt; #PID&lt;0.100.0&gt;<br/>4<br/>3<br/>2<br/>1</span></pre><p id="1bef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，即使进程在后台循环，它也保持一个不断减少的计数作为“状态”。</p><p id="f78d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看一个更有用的例子，一个可以接收有意义的消息并修改自身状态的计数器:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="6d2e" class="nc ly iq lp b gy nd ne l nf ng">defmodule Counter do<br/>  # call the loop with initial state of 0<br/>  def init do<br/>    IO.puts("Initial state: 0")<br/>    message_loop(0)<br/>  end</span><span id="ed06" class="nc ly iq lp b gy nh ne l nf ng">  # Recursively calls itself with its own 'state', and receive messages<br/>  def message_loop(n) do<br/>    receive do<br/>      :inc -&gt; IO.puts("#{n} + 1 -&gt; #{n + 1}"); message_loop(n+1)<br/>      :dec -&gt; IO.puts("#{n} - 1 -&gt; #{n - 1}"); message_loop(n-1)<br/>      :print -&gt; IO.puts("Current state: #{n}"); message_loop(n)<br/>      msg -&gt; raise "Received unknown message: #{inspect(msg)}"<br/>    end<br/>  end<br/>end</span><span id="e09f" class="nc ly iq lp b gy nh ne l nf ng">pid = spawn(&amp;Counter.init/0)<br/>IO.puts("spawn(&amp;Counter.init/0) -&gt; #{inspect(pid)}")<br/>send(pid, :inc) # 0 + 1 -&gt; 1<br/>send(pid, :inc) # 1 + 1 -&gt; 2<br/>send(pid, :inc) # 2 + 1 -&gt; 3<br/>send(pid, :dec) # 3 - 1 -&gt; 2<br/>send(pid, :inc) # 2 + 1 -&gt; 3<br/>send(pid, :print) # Current state: 3</span></pre><p id="ed33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用<code class="fe lm ln lo lp b">elixir counter.exs</code>运行时，我们得到了预期的输出:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="2209" class="nc ly iq lp b gy nd ne l nf ng">Initial state: 0<br/>spawn(&amp;Counter.init/0) -&gt; #PID&lt;0.100.0&gt;<br/>0 + 1 -&gt; 1<br/>1 + 1 -&gt; 2<br/>2 + 1 -&gt; 3<br/>3 - 1 -&gt; 2<br/>2 + 1 -&gt; 3<br/>Current state: 3</span></pre><h1 id="914c" class="lx ly iq bd lz ma no mc md me np mg mh jw nq jx mj jz nr ka ml kc ns kd mn mo bi translated">接收响应</h1><p id="0cee" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">如果我们的后台进程只能打印出它自己的状态，那么它就不如一个合适的对象有用，对吗？我们还需要一种方法让我们的对象响应消息，并且可能返回它自己的状态(或者与它的内部状态相关的东西)。</p><p id="6a2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回想一下，我们可以<code class="fe lm ln lo lp b">send/2</code>将消息发送到后台进程的邮箱。嗯，当前进程或调用者也有邮箱，也可以接收消息！</p><p id="2e76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我们收到对已发送邮件的回复，我们需要:</p><ol class=""><li id="d05b" class="oe of iq kh b ki kj kl km ko og ks oh kw oi la oj ok ol om bi translated">通过发送调用者的进程id，告诉接收者如何向调用者发回消息。我们可以使用<code class="fe lm ln lo lp b">self/0</code>检索当前的进程id。</li><li id="fc15" class="oe of iq kh b ki on kl oo ko op ks oq kw or la oj ok ol om bi translated">在调用过程中设置一个接收块来等待和处理发回的消息。</li></ol><p id="2ad4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们基于我们的<code class="fe lm ln lo lp b">Counter</code>例子来看看这是如何进行的。首先，我们将修改我们的<code class="fe lm ln lo lp b">receive_loop</code>,以便它可以用<code class="fe lm ln lo lp b">{:get, pid}</code>的<em class="ll">元组</em>来响应消息，其中<code class="fe lm ln lo lp b">pid</code>是调用者的进程id:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="d6c1" class="nc ly iq lp b gy nd ne l nf ng">  def receive_loop(n) do<br/>    receive do<br/>      :inc -&gt; IO.puts("#{n} + 1 -&gt; #{n + 1}"); receive_loop(n+1)<br/>      :dec -&gt; IO.puts("#{n} - 1 -&gt; #{n - 1}"); receive_loop(n-1)<br/>      {:get, caller} -&gt; send(caller, {:counter, n}); receive_loop(n)<br/>      msg -&gt; raise "Received unknown message: #{inspect(msg)}"<br/>    end<br/>  end</span></pre><p id="1b45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们不只是发送<code class="fe lm ln lo lp b">:print</code>，而是发送<code class="fe lm ln lo lp b">{:get, self()}</code>。在发送消息之后，在调用过程中，我们还设置了一个<code class="fe lm ln lo lp b">receive</code>块来等待来自<code class="fe lm ln lo lp b">Counter</code>的响应:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="34a8" class="nc ly iq lp b gy nd ne l nf ng">send(pid, {:get, self()})<br/>receive do<br/>  {:counter, n} -&gt; IO.puts("Got response from counter: #{n}")<br/>  msg -&gt; raise "Received unknown message: #{inspect(msg)}"<br/>end</span></pre><p id="38fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们运行修改后的计数器时，输出如预期的那样是:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="6c34" class="nc ly iq lp b gy nd ne l nf ng">Initial state: 0<br/>spawn(&amp;Counter.init/0) -&gt; #PID&lt;0.100.0&gt;<br/>0 + 1 -&gt; 1<br/>1 + 1 -&gt; 2<br/>2 + 1 -&gt; 3<br/>3 - 1 -&gt; 2<br/>2 + 1 -&gt; 3<br/>Got response from counter: 3</span></pre><p id="6db9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表明<code class="fe lm ln lo lp b">Counter</code>确实在向调用它的主进程发送回复<em class="ll">返回</em>。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="a8df" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">抽象</h1><p id="c3e0" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们现在已经有了一个适当的发送和接收框架的开端。但是在我们将它提取到一个可重用的模块之前，让我们抽象掉<code class="fe lm ln lo lp b">spawn</code>、<code class="fe lm ln lo lp b">send</code>和<code class="fe lm ln lo lp b">receive</code>位，因为调用者只与<code class="fe lm ln lo lp b">Counter</code>交互。</p><p id="1d32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们给<code class="fe lm ln lo lp b">Counter</code>添加一个<code class="fe lm ln lo lp b">start()</code>函数，它只调用<code class="fe lm ln lo lp b">spawn</code>并返回计数器的PID:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="a5c6" class="nc ly iq lp b gy nd ne l nf ng">  # spawn the Counter in the background and return its pid<br/>  def start() do<br/>    spawn(&amp;init/0)<br/>  end</span></pre><p id="136e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们一般化Counter的<code class="fe lm ln lo lp b">receive_loop</code>并让它期望<em class="ll">所有的</em>消息都是调用者的PID和实际消息的元组。收到消息后，它会将处理委托给一个<code class="fe lm ln lo lp b">handle_msg</code>函数，该函数将返回新的状态。然后，它将发送新的状态作为对调用者的回复，然后递归地循环回自身。</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="acc9" class="nc ly iq lp b gy nd ne l nf ng">  def receive_loop(state) do<br/>    receive do<br/>      {from, msg} -&gt;<br/>        new_state = handle_msg(msg, state)<br/>        send(from, new_state)<br/>        receive_loop(new_state)<br/>      msg -&gt; raise "Received unknown message: #{inspect(msg)}"<br/>    end<br/>  end</span></pre><p id="e6e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以在<code class="fe lm ln lo lp b">handle_msg</code>中更清楚地表达计数器的逻辑。我们真正做的是从<code class="fe lm ln lo lp b">Counter</code>的核心中抽象出<code class="fe lm ln lo lp b">send</code>和<code class="fe lm ln lo lp b">receive</code>逻辑。</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="fa14" class="nc ly iq lp b gy nd ne l nf ng">  def handle_msg(:inc, n), do: n + 1<br/>  def handle_msg(:dec, n), do: n - 1<br/>  def handle_msg(:get, n), do: n</span></pre><p id="ea42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将为计数器添加“包装”函数，这样调用者也不需要编写<code class="fe lm ln lo lp b">receive</code>块:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="3b86" class="nc ly iq lp b gy nd ne l nf ng">  # Increment the counter and get the new count<br/>  def inc(pid) do<br/>    send(pid, {self(), :inc})<br/>    receive do<br/>      resp -&gt; IO.puts("Counter.inc() -&gt; #{resp}")<br/>    end<br/>  end</span><span id="943f" class="nc ly iq lp b gy nh ne l nf ng">  # Decrement the counter and get the new count<br/>  def dec(pid) do<br/>    send(pid, {self(), :inc})<br/>    receive do<br/>      resp -&gt; IO.puts("Counter.dec() -&gt; #{resp}")<br/>    end<br/>  end</span><span id="0b1d" class="nc ly iq lp b gy nh ne l nf ng">  # Just get the current count<br/>  def get(pid) do<br/>    send(pid, {self(), :inc})<br/>    receive do<br/>      resp -&gt; IO.puts("Counter.get() -&gt; #{resp}")<br/>    end<br/>  end</span></pre><p id="6373" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个版本的<code class="fe lm ln lo lp b">Counter</code>中，调用代码现在被简化了:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="eb89" class="nc ly iq lp b gy nd ne l nf ng">pid = Counter.start()<br/>IO.puts("Counter.start() -&gt; #{inspect(pid)}")<br/>Counter.inc(pid) # 1<br/>Counter.inc(pid) # 2<br/>Counter.inc(pid) # 3<br/>Counter.dec(pid) # 2<br/>Counter.inc(pid) # 3<br/>Counter.get(pid) # 3</span></pre><h2 id="dcc7" class="nc ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">命名流程</h2><p id="26d7" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">从呼叫者的角度来看，唯一剩下的事情是我们仍然在处理PID。幸运的是，有一种使用<a class="ae lk" href="https://hexdocs.pm/elixir/1.12/Process.html#register/2" rel="noopener ugc nofollow" target="_blank">Process.register/2</a>为PID注册名称的方法。</p><p id="2270" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们重写我们的<code class="fe lm ln lo lp b">Counter.start</code>,使用模块名(方便地称为<code class="fe lm ln lo lp b">__MODULE__</code>)作为进程的注册名:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="4c6e" class="nc ly iq lp b gy nd ne l nf ng">  # spawn the Counter in the background and return its pid<br/>  def start() do<br/>    pid = spawn(&amp;init/0)<br/>    Process.register(pid, __MODULE__)<br/>    pid<br/>  end</span></pre><p id="d8c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们现在可以通过使用<code class="fe lm ln lo lp b">Process.whereis/1</code>检索PID来简化所有的<code class="fe lm ln lo lp b">inc</code>、<code class="fe lm ln lo lp b">dec</code>和<code class="fe lm ln lo lp b">get</code>调用，如下所示:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="ec0e" class="nc ly iq lp b gy nd ne l nf ng">  def inc() do<br/>    pid = Process.whereis(__MODULE__)<br/>    send(pid, {self(), :inc})<br/>    receive do<br/>      resp -&gt; IO.puts("Counter.inc() -&gt; #{resp}")<br/>    end<br/>  end</span></pre><p id="8181" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们的调用代码就大大简化了！</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="1765" class="nc ly iq lp b gy nd ne l nf ng">Counter.start() # We can discard the returned PID<br/>Counter.inc() # 1<br/>Counter.inc() # 2<br/>Counter.inc() # 3<br/>Counter.dec() # 2<br/>Counter.inc() # 3<br/>Counter.get() # 3</span></pre><h1 id="4b72" class="lx ly iq bd lz ma no mc md me np mg mh jw nq jx mj jz nr ka ml kc ns kd mn mo bi translated">原型服务器</h1><p id="86fb" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">让我们总结一下我们所学的一切，将底层的<code class="fe lm ln lo lp b">Process</code>调用和消息发送与接收抽象到一个可重用的模块中。</p><p id="47a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望我们的原型服务器的行为就像一个GenServer。含义:</p><ul class=""><li id="e15e" class="oe of iq kh b ki kj kl km ko og ks oh kw oi la os ok ol om bi translated">当我们调用<code class="fe lm ln lo lp b">ProtoServe.start_link/3</code>(或<code class="fe lm ln lo lp b">start/3</code>)时，我们想要传入我们的模块，初始状态，并接受一些选项</li><li id="d1d3" class="oe of iq kh b ki on kl oo ko op ks oq kw or la os ok ol om bi translated">如果给定了<code class="fe lm ln lo lp b">name:</code>选项，就用它作为进程名，这样我们就不必跟踪PID了</li><li id="ad9d" class="oe of iq kh b ki on kl oo ko op ks oq kw or la os ok ol om bi translated">当进程启动时，用初始状态调用我们模块的<code class="fe lm ln lo lp b">init/1</code>回调</li><li id="8c64" class="oe of iq kh b ki on kl oo ko op ks oq kw or la os ok ol om bi translated">允许<code class="fe lm ln lo lp b">init/1</code>返回<code class="fe lm ln lo lp b">:ok</code>和初始状态，或者<code class="fe lm ln lo lp b">:error</code>和一些错误。在<code class="fe lm ln lo lp b">:ok</code>上，进入信息循环。在<code class="fe lm ln lo lp b">:error</code>上，立即出现<code class="fe lm ln lo lp b">raise</code>错误</li><li id="4d00" class="oe of iq kh b ki on kl oo ko op ks oq kw or la os ok ol om bi translated">在消息循环中，在一个<code class="fe lm ln lo lp b">:call</code>消息上，用消息、调用者PID和当前状态调用我们的<code class="fe lm ln lo lp b">handle_call/3</code>回调</li></ul><p id="0b1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">咻！这需要展开很多工作，但是不要担心，它实际上很容易实现和遵循。</p><p id="f9fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望我们的模块照顾到所有必要的“样板文件”，并且简单易用。</p><p id="5058" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Elixir中，当我们<code class="fe lm ln lo lp b">use</code>另一个模块时，我们允许该模块使用Elixir <a class="ae lk" href="https://elixir-lang.org/getting-started/meta/macros.html" rel="noopener ugc nofollow" target="_blank">宏</a>将任何代码“注入”当前模块。全面解释elixir宏超出了现在的范围——知道要使<code class="fe lm ln lo lp b">use</code>工作，我们只需要实现一个<code class="fe lm ln lo lp b">__using__</code>宏就足够了！</p><p id="02b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始编写我们的<code class="fe lm ln lo lp b">ProtoServer</code>并实现<code class="fe lm ln lo lp b">start_link/3</code>:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="7f9a" class="nc ly iq lp b gy nd ne l nf ng"># A prototype GenServer<br/>defmodule ProtoServer do</span><span id="a3c3" class="nc ly iq lp b gy nh ne l nf ng">  # Just link GenServer.start_link/3, spawns the calling<br/>  # calling module, and returns the PID. Also, support the<br/>  # optional `name:` option <br/>  def start_link(module, state, options \\ %{}) do<br/>    pid = spawn_link(module, :on_spawn, [state])</span><span id="b3ee" class="nc ly iq lp b gy nh ne l nf ng">    if Keyword.has_key?(options, :name) do<br/>      Process.register(pid, options[:name])<br/>    end<br/>    pid<br/>  end</span></pre><p id="4adb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe lm ln lo lp b">start_link</code>仅仅调用了<code class="fe lm ln lo lp b">spawn_link</code>，但是我们提供了自己的<code class="fe lm ln lo lp b">on_spawn</code>函数，它将实现调用模块的<code class="fe lm ln lo lp b">init/1</code>回调的“魔法”。我们还支持可选的<code class="fe lm ln lo lp b">name:</code>选项，并使用该名称注册进程，以便以后更容易调用我们的<code class="fe lm ln lo lp b">ProtoServer</code>模块。</p><p id="a111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们不能只在<code class="fe lm ln lo lp b">ProtoServer</code>本身中传递<code class="fe lm ln lo lp b">def on_spawn</code>，因为当我们<code class="fe lm ln lo lp b">spawn_link</code>时我们需要在调用模块中传递。否则，我们将编写<code class="fe lm ln lo lp b">spawn_link(ProtoServer, :on_spawn, ...)</code>，这将使得调用我们模块的<code class="fe lm ln lo lp b">init/1</code>回调函数变得困难！</p><p id="10c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，这是我们依靠<code class="fe lm ln lo lp b">__using__</code>宏在调用模块本身中写<code class="fe lm ln lo lp b">on_spawn</code>的地方！展示比解释容易:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="f7a9" class="nc ly iq lp b gy nd ne l nf ng">  defmacro __using__(_opts) do<br/>    quote do<br/>      def on_spawn(args) do<br/>        case init(args) do<br/>          {:ok, initial_state} -&gt; receive_loop(initial_state)<br/>          {:error, reason} -&gt; raise reason<br/>        end<br/>      end</span></pre><p id="ef2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lm ln lo lp b">ProtoServer.__using__</code>中，我们使用一个<code class="fe lm ln lo lp b">quote</code>块来编写<code class="fe lm ln lo lp b">on_spawn/1</code>启动函数<em class="ll">，就好像我们是在调用模块本身中编写一样！</em></p><p id="15a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，当我们写作时，例如:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="1d58" class="nc ly iq lp b gy nd ne l nf ng">defmodule Counter do<br/>  use ProtoServer</span></pre><p id="2ea3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就好像我们写道:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="49de" class="nc ly iq lp b gy nd ne l nf ng">defmodule Counter do<br/>  def on_spawn(args) do...</span></pre><p id="9014" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lm ln lo lp b">on_spawn/1</code>中，我们用相同的初始参数调用<code class="fe lm ln lo lp b">init/1</code>，然后根据<code class="fe lm ln lo lp b">init/1</code>是返回<code class="fe lm ln lo lp b">:ok</code>还是<code class="fe lm ln lo lp b">:error</code>，我们要么继续调用<code class="fe lm ln lo lp b">receive_loop</code>要么失败。</p><p id="4bfe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe lm ln lo lp b">__using__</code>宏中使用相同的<code class="fe lm ln lo lp b">quote</code>块写出<code class="fe lm ln lo lp b">receive_loop/1</code>，就像我们在调用模块中写一样:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="76ab" class="nc ly iq lp b gy nd ne l nf ng">      # Recursively calls itself with its own 'state', <br/>      # and receive messages<br/>      def receive_loop(state) do<br/>        receive do<br/>          {:call, from, msg} -&gt; case handle_call(msg, from, state) do<br/>            {:reply, response, new_state} -&gt; send(from, response); receive_loop(new_state)<br/>            {:no_reply, new_state} -&gt; receive_loop(new_state)<br/>            result -&gt; raise "Received unknown result: #{inspect(result)}"<br/>          end<br/>          msg -&gt; raise "Received unknown message: #{inspect(msg)}"<br/>        end<br/>      end</span></pre><p id="094a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了这次我们处理<code class="fe lm ln lo lp b">:call</code>消息并委托给模块的<code class="fe lm ln lo lp b">handle_call/3</code>回调之外，<code class="fe lm ln lo lp b">receive_loop</code>与我们之前写的几乎相似。然后我们发回一个响应，什么都不做，或者根据<code class="fe lm ln lo lp b">handle_call/3</code>是返回<code class="fe lm ln lo lp b">:reply</code>、<code class="fe lm ln lo lp b">:no_reply</code>还是一个未知的返回值来引发一个错误。</p><p id="1d1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们在<code class="fe lm ln lo lp b">__using__</code>宏中所需要的！现在我们只需要实现<code class="fe lm ln lo lp b">ProtoServer.call/2</code>。对于<code class="fe lm ln lo lp b">call/2</code>，我们提供了一种方便的方法来传入一个符号(模块名)而不是一个PID，我们自己使用<code class="fe lm ln lo lp b">Process.whereis/1</code>:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="bda4" class="nc ly iq lp b gy nd ne l nf ng">def call(to, msg) do<br/>    case to do<br/>      pid when is_pid(pid) -&gt; send(pid, {:call, self(), msg})<br/>      name when is_atom(name) -&gt; send(Process.whereis(name), {:call, self(), msg})<br/>    end<br/>    receive do<br/>      resp -&gt; resp<br/>    end<br/>  end</span></pre></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="8a6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的全功能<code class="fe lm ln lo lp b">Counter</code>的最终实现可以用<code class="fe lm ln lo lp b">use ProteServer</code>精确地写成<em class="ll">，就好像</em>我们用了一个<code class="fe lm ln lo lp b">GenServer</code>来代替。您可以在下面的代码中将<code class="fe lm ln lo lp b">ProtoServer</code>替换为<code class="fe lm ln lo lp b">GenServer</code>，亲自尝试一下！</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="571a" class="nc ly iq lp b gy nd ne l nf ng">defmodule Counter do<br/>  use ProtoServer</span><span id="cce3" class="nc ly iq lp b gy nh ne l nf ng">  def start_link() do<br/>    ProtoServer.start_link(__MODULE__, 0, name: __MODULE__)<br/>  end</span><span id="0d9d" class="nc ly iq lp b gy nh ne l nf ng">  def init(initial_value) do<br/>    IO.puts("init(#{initial_value})")<br/>    {:ok, initial_value}<br/>  end</span><span id="6594" class="nc ly iq lp b gy nh ne l nf ng">  def handle_call(msg, _from, state) do<br/>    resp = handle_msg(msg, state)<br/>    {:reply, resp, resp}<br/>  end</span><span id="2da4" class="nc ly iq lp b gy nh ne l nf ng">  def handle_msg(:inc, n), do: n + 1<br/>  def handle_msg(:dec, n), do: n - 1<br/>  def handle_msg(:get, n), do: n</span><span id="9dcf" class="nc ly iq lp b gy nh ne l nf ng">  def inc() do<br/>    resp = ProtoServer.call(__MODULE__, :inc)<br/>    IO.puts("Counter.inc() -&gt; #{resp}")<br/>  end</span><span id="678e" class="nc ly iq lp b gy nh ne l nf ng">  def dec() do<br/>    resp = ProtoServer.call(__MODULE__, :dec)<br/>    IO.puts("Counter.inc() -&gt; #{resp}")<br/>  end</span><span id="2845" class="nc ly iq lp b gy nh ne l nf ng">  def get() do<br/>    resp = ProtoServer.call(__MODULE__, :get)<br/>    IO.puts("Counter.inc() -&gt; #{resp}")<br/>  end<br/>end</span></pre><blockquote class="ni nj nk"><p id="5839" class="kf kg ll kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated"><code class="fe lm ln lo lp b">ProtoServer.cast/2</code>的实现留给读者作为练习。</p></blockquote></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="ad01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章比我想的要长一点，并且涵盖了很多主题——但是我希望您能够跟上，并且现在对<code class="fe lm ln lo lp b">GenServer</code>有了更深的理解，并且在使用它时有了更大的信心！</p><p id="863e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯！</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="7e75" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">分级编码</h1><p id="fbe7" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="f8b9" class="oe of iq kh b ki kj kl km ko og ks oh kw oi la os ok ol om bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="70de" class="oe of iq kh b ki on kl oo ko op ks oq kw or la os ok ol om bi translated">📰查看<a class="ae lk" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="7dab" class="oe of iq kh b ki on kl oo ko op ks oq kw or la os ok ol om bi translated">🔔关注我们:<a class="ae lk" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae lk" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lk" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="50b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">🚀👉<a class="ae lk" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>