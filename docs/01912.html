<html>
<head>
<title>Recursion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/recursion-in-javascript-5c49b722f1d6?source=collection_archive---------12-----------------------#2020-02-05">https://levelup.gitconnected.com/recursion-in-javascript-5c49b722f1d6?source=collection_archive---------12-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/7f3e4288f0eea6a48b4ae7fcbfcfe87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*tR_mebCsH0otQMlZV4Ym8Q.png"/></div></figure><p id="f371" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你刚刚开始学习递归，它看起来是如此的费解和复杂。但是当你一步一步地分解它，并试图理解引擎盖下发生的事情时，你就会明白了。一旦你得到了它，它将永远伴随着你；).</p><p id="c82a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那么简单来说什么是递归呢？</p><p id="5cbf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是一个函数调用自身的过程。换句话说，您在每次迭代中使用不同的值调用同一个函数，直到您到达一个基本情况。这也意味着你<strong class="jz iu">总是</strong>需要有使用递归的基本情况。</p><p id="23c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在的问题是<strong class="jz iu">递归</strong>的基本情况是什么？</p><p id="b044" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">基本上，基本情况是你用来告诉你的函数停止的条件。如果没有一个基本用例，你的函数将无限循环，这是不好的。</p><p id="a2f0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用递归的一个著名例子是寻找<strong class="jz iu">阶乘(！)</strong>。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ac3b" class="le lf it la b gy lg lh l li lj"><strong class="la iu">n! = n × (n−1)!, where 0! = 1.</strong></span><span id="3b09" class="le lf it la b gy lk lh l li lj">To find 4! we need to find 3! then 2! then 1!</span><span id="b920" class="le lf it la b gy lk lh l li lj">4! = 4 × 3!</span><span id="bda0" class="le lf it la b gy lk lh l li lj">3! = 3 × 2!;</span><span id="064d" class="le lf it la b gy lk lh l li lj">2! = 2 × 1!;</span><span id="2b9d" class="le lf it la b gy lk lh l li lj">1! = 1</span><span id="5f42" class="le lf it la b gy lk lh l li lj">4! = 4 × 3 × 2 × 1 =&gt; <strong class="la iu">24</strong></span></pre><p id="f50e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以下是使用递归查找阶乘的解决方案:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4448" class="le lf it la b gy lg lh l li lj"><strong class="la iu">function factorial(num){<br/>  </strong>//base case of recursion to stop calling itself<strong class="la iu"><br/>  if(num === 1 || num === 0) return 1;</strong></span><span id="2b84" class="le lf it la b gy lk lh l li lj"><strong class="la iu">  </strong>//recursivly calling itself with new value <strong class="la iu"><br/>  return num * factorial(num - 1)<br/>}</strong></span><span id="d354" class="le lf it la b gy lk lh l li lj">factorial(4) // =&gt; 24</span></pre><p id="e3f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="ll">递归的时间复杂度为O(n)，空间复杂度为O(n)。</em></p><p id="ae25" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们试着理解在我们函数的每次迭代中发生了什么，例如factorial(4)。如果我们数到4！答案是24，所以函数应该返回24。</p><p id="70e0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用浏览器中的调试器，我们可以检查每个调用中num的值。</p><blockquote class="lm ln lo"><p id="d656" class="jx jy ll jz b ka kb kc kd ke kf kg kh lp kj kk kl lq kn ko kp lr kr ks kt ku im bi translated">调用#1，num = 4，那么我们的函数应该用值num-1调用自己。</p></blockquote><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="f0a5" class="le lf it la b gy lg lh l li lj">function <strong class="la iu">factorial(4)</strong>{<br/>//base case of recursion to stop calling itself<br/>if(4 === 1 || 4 === 0) return 1; // =&gt;false<br/>  return 4 * <strong class="la iu">factorial(3)</strong><br/>}</span></pre><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/32dee9a04ffc136766d795437d00a17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUt6SUw-EPMQ4a1krCFyng.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">调用函数factorial(4)</figcaption></figure><p id="3c64" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当我们从阶乘(3)中得到结果时，阶乘(4)被搁置。</p><blockquote class="lm ln lo"><p id="15cd" class="jx jy ll jz b ka kb kc kd ke kf kg kh lp kj kk kl lq kn ko kp lr kr ks kt ku im bi translated">Call #2，factorial(3)调用factorial(2)，当我们从factorial(2)中获取结果时，它处于暂停状态。</p></blockquote><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="608d" class="le lf it la b gy lg lh l li lj">function <strong class="la iu">factorial(3)</strong>{<br/> if(3 === 1 || 3 === 0) return 1; // =&gt; false<strong class="la iu"><br/> </strong>return 3 * <strong class="la iu">factorial(2) </strong><br/>}</span></pre><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mb"><img src="../Images/87fb1b8f981687bf1b878ae6bd680327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DsPjhHH-erMzIVp9wztSrA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">函数用阶乘(3)调用自身</figcaption></figure><blockquote class="lm ln lo"><p id="1169" class="jx jy ll jz b ka kb kc kd ke kf kg kh lp kj kk kl lq kn ko kp lr kr ks kt ku im bi translated">在调用factorial(1)之后，调用#3，factorial(2)。</p></blockquote><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6613" class="le lf it la b gy lg lh l li lj">function <strong class="la iu">factorial(2)</strong>{<br/> if(2 === 1 || 2 === 0) return 1; // =&gt; false<strong class="la iu"><br/> </strong>return 2 * <strong class="la iu">factorial(1) </strong><br/>}</span></pre><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mc"><img src="../Images/01541b759d562e575c4313b1f3ea122c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpRDCbkgI_rC2BCfjU6ZEQ.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">函数用阶乘(2)调用自身</figcaption></figure><blockquote class="lm ln lo"><p id="2f86" class="jx jy ll jz b ka kb kc kd ke kf kg kh lp kj kk kl lq kn ko kp lr kr ks kt ku im bi translated">调用#4时，最后一个调用被factorial(1)调用返回1，因为基本情况已经这样设置了。</p></blockquote><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ad35" class="le lf it la b gy lg lh l li lj">function <strong class="la iu">factorial(1)</strong>{<br/> if(1 === 1 || 1=== 0) return 1; // =&gt; true<strong class="la iu"><br/> </strong>return 1 * <strong class="la iu">factorial(0) </strong><br/>}<br/>// =&gt; 1</span></pre><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi md"><img src="../Images/2d12ab9735ac949c4a21b796ca41b450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8BSQVdFBstef1MuPNVsbg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">函数用阶乘(1)调用自身</figcaption></figure><blockquote class="lm ln lo"><p id="5770" class="jx jy ll jz b ka kb kc kd ke kf kg kh lp kj kk kl lq kn ko kp lr kr ks kt ku im bi translated">让我们想象一下调用factorial(4)时发生了什么。</p></blockquote><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="e858" class="le lf it la b gy lg lh l li lj">//Visualization of invoking function factorial(4)</span><span id="984d" class="le lf it la b gy lk lh l li lj">function factorial(4){<br/>//base case of recursion to stop calling itself<br/>if(4 === 1 || 4 === 0) return 1; // =&gt; false<br/> <br/> return 4 * factorial(3){ // =&gt; 4 * 3 * 2 * 1<br/>            if(3 === 1 || 3 === 0) return 1; // =&gt; false<br/>            <br/>              return 3 * factorial(2){ // =&gt; 3 * 2 * 1<br/>                  <br/>                  if(2 === 1 || 4 === 0) return 1;<br/>                  <br/>                     return 2 * factorial(1){ // =&gt; 2 * 1<br/>                     <br/>                      if(1 === 1 || 1 === 0) return 1; // =&gt; true<br/>                       return 1 * factorial(0)}<br/>                  }<strong class="la iu"><br/>            </strong>}<br/>}</span><span id="6db3" class="le lf it la b gy lk lh l li lj">// factorial(4) = 4 * factorial(3) = 4 * (3 * factorial(2)) =<br/>// 4 * (3 *(2 * factirial(1))) = 4 * (3 * (2 * (1))) = <br/>// 4 * (3 * (2)) = 4 * (6) = 24 </span><span id="aba3" class="le lf it la b gy lk lh l li lj"><strong class="la iu">// =&gt; 4 * 3 * 2 * 1 =&gt; 24</strong></span></pre><p id="b595" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">阶乘(4) = 4 * 3 * 2 * 1 = 24，是正确答案。</p><p id="2f05" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正如您所看到的，递归函数创建了n个临时值，直到它到达基本情况。一旦迭代是在基本情况下，存储的值被用来计算答案。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="e8bb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">寻找阶乘的非递归解决方案可以使用for循环迭代:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6b5a" class="le lf it la b gy lg lh l li lj"><strong class="la iu">function factorial(num){<br/>   let result = 1;<br/>   if(num === 0) return 1;<br/>   while(num){<br/>      result = result * num;<br/>      num--;<br/>   }<br/>   return result;<br/>}</strong></span></pre><p id="9599" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里时间复杂度为O(n)；空间复杂度为O(1)。</p><p id="1310" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">递归需要更少的编码行，代价是占用空间。所以如果你关心空间的话，递归并不好。因此，根据具体情况，你应该决定是否使用递归。</p><p id="9e87" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">希望这篇帖子对你理解递归有帮助。我将感谢任何反馈！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="8080" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="ll">更具体的资源:</em></p><div class="ml mm gp gr mn mo"><a href="https://www.mathsisfun.com/numbers/factorial.html" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">阶乘！</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">例子:我们通常说(比如)4！作为“4阶乘”，但有些人说“4尖叫”或“4爆炸”,我们可以很容易…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">www.mathsisfun.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jv mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">递归(计算机科学)</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">计算机科学中的递归是一种解决问题的方法，它的解依赖于更小的…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">en.wikipedia.org</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc jv mo"/></div></div></a></div></div></div>    
</body>
</html>