<html>
<head>
<title>Symptoms of Single Responsibility Principle (SRP) violation in your code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码中违反单一责任原则(SRP)的症状</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/symptoms-of-single-responsibility-principle-srp-violation-in-your-code-dd14a7bd1698?source=collection_archive---------4-----------------------#2022-12-11">https://levelup.gitconnected.com/symptoms-of-single-responsibility-principle-srp-violation-in-your-code-dd14a7bd1698?source=collection_archive---------4-----------------------#2022-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8334bf4998f5dcf54a2079f105a26325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iAH10n-Ye_UBXO_a.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">违反单一责任原则(SRP)也会给你和你的代码带来麻烦</figcaption></figure><p id="e3d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="la"/></strong>单一责任原则(SRP)是贯穿编程的最重要、众所周知和实践的原则之一[1]。尽管这个概念看起来很简单，但是实践SRP的重要性怎么强调都不为过。SRP的简单性也导致了多年来对它的误解。这就是为什么知道你什么时候违反SRP是很重要的。</p><p id="0ae1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我们将讨论你的代码向你暗示的四种症状，它<strong class="ke ir">可能</strong>违反了单一责任原则。下面提到的要点是通过总结我多年来阅读的一些非常著名的编程书籍以及基于我的经验收集的。以下是四点。我们走吧！！🚶</p><h2 id="d41c" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated"><strong class="ak"> 1。你的模块体积很大</strong></h2><p id="3ecd" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">在这里，我们在计算容量时引用的度量是<em class="la">行代码</em> (LOC)。Robert C. Martin在他的书<a class="ae lz" href="https://www.oreilly.com/library/view/clean-code-a/9780136083238/" rel="noopener ugc nofollow" target="_blank"> Clean Code </a>中明确提到<em class="la">函数的第一条规则是它们应该很小</em>【2】。一个函数应该讲述一个故事，一个简短的故事。就是这样！虽然没有硬性规定函数应该有多长才能确认SRP，但平均来说，任何5-6行长的函数都足够了。SRP的定义足以断言一个函数应该非常小。</p><blockquote class="ma mb mc"><p id="56ae" class="kc kd la ke b kf kg kh ki kj kk kl km md ko kp kq me ks kt ku mf kw kx ky kz ij bi translated">一个软件模块应该只做一件事。</p></blockquote><p id="1194" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么课程呢？对于班级，其体积不应以LOC计量，而应由<strong class="ke ir"><em class="la"/></strong>计量。</p><blockquote class="ma mb mc"><p id="651b" class="kc kd la ke b kf kg kh ki kj kk kl km md ko kp kq me ks kt ku mf kw kx ky kz ij bi translated">一个软件模块应该只对一个角色负责。</p></blockquote><p id="50c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这意味着，一个类应该只负责一件事。当一个类倾向于为多个参与者做多件事情时，这是该类需要重构的好迹象。关于这一点，我们将在文章的后面详细介绍。</p><h2 id="9d2f" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">2.你不能用一句话来描述你的功能。你也不能不用‘和’，‘或’等词来描述它。😏</h2><p id="0bbc" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">现在，试着用一句话来描述你的源代码中的函数是做什么的。如果您倾向于编写长句，或者倾向于编写使用诸如'<strong class="ke ir"> <em class="la">或</em> </strong>'以及'<strong class="ke ir"> <em class="la">和</em> </strong>'等词语的句子，则该功能可能违反SRP。去试试吧！</p><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="5752" class="mp lc iq ml b be mq mr l ms mt">function login(string $email, string $password) <br/>{<br/>  try {<br/>    if(isEmailValid($email) and isPasswordValid($password)) {<br/>      $user = User::findFromEmail($email, $password);<br/><br/>      if($user) {<br/>        // do something else like logging login event<br/>        //return success with token<br/>      }<br/>      else {<br/>        throw new Exception('No user found with given credentials');<br/>      }<br/>    }<br/>    else {<br/>    throw new Exception ('Invalid email or password')<br/>    }<br/>  }<br/>  catch(Exception $e) {<br/>    throw new Exception ('Exception occured');<br/>  }<br/>}</span></pre><p id="7a68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们试着描述一下上面源代码中的<code class="fe mu mv mw ml b">login</code>函数。这个<code class="fe mu mv mw ml b">login</code>函数是做什么的？</p><p id="3d2d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">登录函数以邮箱和密码为参数。如果电子邮件和密码的格式有效，并且凭据与数据库匹配，则该函数返回带有令牌的成功。如果用户不在数据库中，它会抛出一个异常，指出电子邮件或密码不正确。</em></p><p id="1b1e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">类似这样的描述暗示了这个函数可能在做多件事情。存在将该功能分成更短的功能的范围。</p><h2 id="2c33" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">3.为您的函数或类编写测试似乎非常困难</h2><p id="bf22" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">当您为一个函数编写单元测试时，您可能会在同一个测试中编写多个断言。或者，您可能会编写许多测试来测试一个功能。这也可能表明该函数违反了SRP，因为该函数做了许多事情，因此测试也必须断言所有这些事情。顺便说一下，这也有助于我们理解为什么<em class="la">测试驱动开发(TDD) </em>的实践有助于我们设计更模块化的代码，但这是另一篇文章的主题。</p><p id="1aea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对另一个类有太多依赖的类也很难测试。你最可能遇到的一个问题是，由于所有这些依赖关系，构造函数可能很难初始化[4]。对一个类注入太多的依赖也是这个类做了太多事情的好迹象。</p><h2 id="b92e" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">4.你的类有服务于不同角色的函数</h2><p id="9c42" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">这一点只是<code class="fe mu mv mw ml b">class</code>具体，而不是<code class="fe mu mv mw ml b">functions</code>。让我们从参与者的角度再看一下SRP的定义。</p><blockquote class="ma mb mc"><p id="7146" class="kc kd la ke b kf kg kh ki kj kk kl km md ko kp kq me ks kt ku mf kw kx ky kz ij bi translated">一个软件模块应该只对一个角色负责。</p></blockquote><p id="6ba1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当一个类有多个函数为系统的不同参与者服务时，其中一个函数(或多个函数)内部的代码迟早会发生变化。因为归根结底，是系统的参与者决定了系统应该如何运行。像业务需求和用户行为这样的事情往往会一直改变软件的行为。</p><p id="e65c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们以罗伯特·马丁书中的<code class="fe mu mv mw ml b">Employee</code>类为例:<a class="ae lz" href="https://www.oreilly.com/library/view/clean-architecture-a/9780134494272/" rel="noopener ugc nofollow" target="_blank">干净的架构</a>【3】。</p><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="5301" class="mp lc iq ml b be mq mr l ms mt">class Employee<br/>{<br/>  function calculatePay() { ... }<br/>  function reportHours() { ... }<br/>  function save() { ... }<br/>}</span></pre><p id="286d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设类<code class="fe mu mv mw ml b">Employee</code>的所有功能都简单、简短，并且只做一件事——那太完美了。所以这些函数当然都遵循SRP。所以，自动类<code class="fe mu mv mw ml b">Employee</code>应该遵循SRP。对吗？可惜，<strong class="ke ir"> <em class="la">没有</em> </strong>。</p><p id="7cc6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">类<code class="fe mu mv mw ml b">Employee</code>违反了SRP，因为这三个函数负责服务三个不同的参与者。</p><ul class=""><li id="ea6b" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated"><code class="fe mu mv mw ml b">calculatePay()</code>负责<em class="la">会计部门</em>及其政策的职能。</li><li id="2ec4" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><code class="fe mu mv mw ml b">reportHours()</code>负责<em class="la">人力资源部</em>及其政策的职能。</li><li id="f59c" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><code class="fe mu mv mw ml b">save()</code>功能负责<em class="la">数据库管理员</em>。</li></ul><p id="bbc2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样，由于任何软件的行为都是由其用户决定的，或者说最终是由参与者决定的，所以参与者可以负责改变软件的行为。例如——如果会计部门明天改变了应该如何支付雇员的政策，这种改变应该反映在<code class="fe mu mv mw ml b">calculatePay()</code>函数中。同样在同一天，DBA团队更改了他们数据库中的<em class="la">用户</em>表结构，这也应该反映在同一类的<code class="fe mu mv mw ml b">save()</code>函数中。像这样的场景给这个类带来了额外的复杂性，因为开发人员单独处理这些函数会给文件带来不必要的合并错误。此外，两个完全不相关的功能之间不必要的协作在这里也很明显。在PHP这样的语言中，<code class="fe mu mv mw ml b">calculatePay()</code>函数中的语法错误肯定会影响到函数<code class="fe mu mv mw ml b">save()</code>，因为函数<code class="fe mu mv mw ml b">save()</code>的客户端在调用<code class="fe mu mv mw ml b">save()</code>时也会出错。</p><h1 id="73ac" class="nl lc iq bd ld nm nn no lg np nq nr lj ns nt nu lm nv nw nx lp ny nz oa ls ob bi translated">结论</h1><p id="595b" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">保持单一责任很重要，非常重要。在编写代码时，有许多危险信号是你应该注意的。从项目开始就坚持单一责任原则来维护一个良好的代码库是非常重要的，因为随着代码库的增长，增加不必要的依赖和代码重复的机会也会增加，结果是代码的可维护性、成本和时间也会增加。</p><p id="a80d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">干杯！！这是给你的咖啡，感谢你坚持到最后。☕️</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="2167" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">参考文献</strong></p><p id="4ddd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">[1] <strong class="ke ir"> <em class="la">单一责任原则</em></strong><a class="ae lz" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Single-respons ibility _ Principle</a></p><p id="ea1d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">清洁码</em> </strong>作者<em class="la">罗伯特·塞西尔·马丁</em></p><p id="3e55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">[3] <strong class="ke ir"> <em class="la">干净的架构:软件结构和设计的工匠指南</em> </strong>作者<em class="la">罗伯特·塞西尔·马丁</em></p><p id="5dd9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">[4] <strong class="ke ir"> <em class="la">有效地与遗留代码</em> </strong>一起工作</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="3dda" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="17e1" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="10ee" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">📰查看<a class="ae lz" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="a84f" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">🔔关注我们:<a class="ae lz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae lz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lz" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="7e22" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">🚀👉<a class="ae lz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>