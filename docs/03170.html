<html>
<head>
<title>Learning About Advanced Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解高级正则表达式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-about-advanced-regular-expressions-94fd346819a0?source=collection_archive---------7-----------------------#2020-04-23">https://levelup.gitconnected.com/learning-about-advanced-regular-expressions-94fd346819a0?source=collection_archive---------7-----------------------#2020-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/44d94f7c292c700ee28ca7b4fae44032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nJ_W_6Ohy20Q4ohN"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">莎伦·麦卡琴在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><div class=""><h2 id="ccd0" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">深入了解作为程序员最难学习的东西之一</h2></div><p id="3bb3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正则表达式经常被忽视，大多数程序员认为它们很难学。虽然基础知识可以很快学会，但是更高级的正则表达式概念可能很难理解。</p><p id="eb78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管正则表达式非常强大，但很多程序员并不真正了解正则表达式。</p><p id="0c46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将回顾一些更高级的正则表达式概念。我最近<a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/read-this-if-you-dont-know-enough-about-regex-73141bb0e1a7">发表了一篇文章</a>，讲述了正则表达式的基础知识。</p><p id="b5af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您不太熟悉正则表达式，并且希望了解更多关于正则表达式的知识，那么这篇文章是一个很好的起点。我建议你先读那篇文章，然后再看这篇文章。</p><p id="92d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文深入探讨了更高级的正则表达式，是介绍基础知识的文章的后续。所以事不宜迟，让我们更深入地研究正则表达式吧！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4e26" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">匹配A或B</h1><p id="ced6" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">正则表达式有可能匹配A或b。例如，当您想要查找<em class="my">颜色</em>时，这很方便。或者颜色，这是一些人喜欢的写法。</p><p id="17ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了匹配A或B，您可以使用管道。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/fbd6c459a82de93cf6070c4c9fd76932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDRZ-j-8ojiUMAeyefmkyQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">这是正则表达式:/(colour|color)/g的结果</figcaption></figure><p id="b3bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您愿意，可以添加更多选项。要添加选项C，只需添加另一个管道和必须与之匹配的值。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/a0fc884c5a02f3b25004452c93c09b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ld4W0TzvNE7sFRHd1NpS_Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">这是regex: /(colour|color|clr)/g的结果</figcaption></figure><p id="2fc4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，大多数时候需要将正则表达式放在括号中。如果你这样做，这至少是一个好习惯，因为它使你的正则表达式可读性更好。这些括号称为捕获组。如果您还不知道什么是捕获组，请不要担心，我们接下来将讨论捕获组。</p><h2 id="4ac4" class="nf mc jj bd md ng nh dn mh ni nj dp ml lh nk nl mn ll nm nn mp lp no np mr nq bi translated">摘要</h2><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="b0d7" class="nf mc jj ns b gy nw nx l ny nz"><em class="my">(Jon|John) </em>            Match either Jon or John<br/><em class="my">(Jon|John|Johnny) </em>     Match either Jon, John or Johnny</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="adb6" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">捕获组</h1><p id="a5d1" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">捕获组是更高级的正则表达式的基本部分，因为它们允许我们提取正则表达式匹配的一部分。</p><p id="64c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了创建一个捕获组，您必须将正则表达式的一部分括在括号中。通过这种方式，您可以将正则表达式的这一部分组合在一起，这允许您对整个组应用量词等。</p><p id="fea5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们想要匹配一些没有扩展名的pdf的文件名。我们可以使用一个捕捉组来捕捉比赛的这一部分。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/0868f16369bbaf174aace75ecc9ff669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCFhjPCt572cYAN-lzl6KQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">这是正则表达式的结果:/^(.*)\.pdf美元/克</figcaption></figure><p id="7c8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，所有的PDF文件都得到匹配。目前没什么特别的。但是当我们看一看被捕的那群人。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/ab61149a402d991607bbee155df737ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTlp8btwrPaU39TV1SF8hA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">使用捕获组的结果</figcaption></figure><h2 id="7a81" class="nf mc jj bd md ng nh dn mh ni nj dp ml lh nk nl mn ll nm nn mp lp no np mr nq bi translated">摘要</h2><p id="b89e" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">将正则表达式的一部分用括号括起来，以提取正则表达式匹配的部分。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="abf3" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">非捕获组</h1><p id="629a" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">就像捕获组一样，非捕获组也存在。非捕获组是您可以定义不想捕获的组。差不多都在名字里了。</p><p id="77be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要定义非捕获组，您可以使用<code class="fe ob oc od ns b">(?:)</code>。以此为前缀的组不会被捕获，因此不会显示在匹配项中。在处理复杂的正则表达式时，您会经常用到这个特性。</p><p id="d5bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们正在寻找史密斯家族的成员。大多数家庭成员都有中间名，但是我们想把这些从匹配中排除。为此，我们可以使用非捕获组。</p><p id="b514" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用下面的正则表达式:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="7018" class="nf mc jj ns b gy nw nx l ny nz">/(Frank|Jimmmy|Jeff)\s(?:.*)\s(Smith|Smithy)/g</span></pre><p id="4c9c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在第一个捕获组中寻找<em class="my"> Frank </em>、<em class="my"> Jimmy </em>和<em class="my"> Jeff </em>，后面跟着一个空白字符。接下来是非捕获组，可以包含任何字符。注意，这个组以<code class="fe ob oc od ns b">?:</code>开始，这使它成为一个非捕获组。这个非捕获组后面还有一个空白字符。在最后一个捕获组中，我们寻找姓氏<em class="my"> Smith </em>和<em class="my">Smith</em>。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/a9b2b65622f62b009b4c64c812740796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwJ-Ryk-5miyBrzOCv-62w.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">regex的结果:/(Frank|Jimmmy|Jeff)\s(？:.*)\s(Smith|Smithy)/g</figcaption></figure><p id="1f58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个正则表达式只产生两个匹配—一个是名，一个是姓。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/35bfc5c5673f04095230086fd1e4d5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53gXMPafxQR8iRHFROhfGg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">非捕获组从匹配中排除了中间的名字</figcaption></figure><h2 id="1c09" class="nf mc jj bd md ng nh dn mh ni nj dp ml lh nk nl mn ll nm nn mp lp no np mr nq bi translated">摘要</h2><p id="a29c" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">使用<code class="fe ob oc od ns b">(?:)</code>创建一个非捕获组。这将从匹配中排除该组。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="dd5b" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">前瞻</h1><p id="fa0a" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">有时，我们只需要为一个模式寻找那些在另一个模式之前或之后的匹配。您可以在正则表达式中使用lookaheads来实现这一点。</p><p id="84d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<em class="my"> B </em>紧跟在<em class="my"> A </em>之后，Lookaheads可以用来匹配<em class="my">A</em>。它的语法看起来像<code class="fe ob oc od ns b">A(?=B)</code>。</p><p id="9504" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看下面的正则表达式。这个正则表达式使用正向前瞻。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="bebe" class="nf mc jj ns b gy nw nx l ny nz">/banana(?=pear)/g</span></pre><p id="307d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果直接跟进<em class="my">梨</em>就会搭配<em class="my">香蕉</em>。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/5e4f315dbafafec77a70581457a50b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajezG36gjsAQ2da4p6sqYg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">regex: /banana(？=梨)/g</figcaption></figure><p id="4c54" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前面的例子是一个积极前瞻的例子。另一方面，也有消极的展望。如果在它的正前方没有<em class="my"> B </em>，则负前视匹配<em class="my"> A </em>。</p><p id="db09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像这样的否定前瞻的语法应该是:<code class="fe ob oc od ns b">A(?!B)</code>。回到前面的例子，让我们检查下面的正则表达式:</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="fe79" class="nf mc jj ns b gy nw nx l ny nz">/banana(?!pear)/g</span></pre><p id="a864" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">会搭配<em class="my">香蕉</em><strong class="la jk">T5】如果是<strong class="la jk">不是</strong>直接跟进<em class="my">梨</em>。</strong></p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/527c52fd300f7a6b098a58250ff99689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKI0z_3L-jihkaXFDzCBug.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">regex: /banana(？！梨)/克</figcaption></figure><h2 id="00d5" class="nf mc jj bd md ng nh dn mh ni nj dp ml lh nk nl mn ll nm nn mp lp no np mr nq bi translated">摘要</h2><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="272b" class="nf mc jj ns b gy nw nx l ny nz"><strong class="ns jk">Positive lookahead</strong><br/><em class="my">banana(?=apple) </em>          Match <em class="my">banana</em> that is directly followed up by <em class="my">apple</em></span><span id="a630" class="nf mc jj ns b gy oh nx l ny nz"><strong class="ns jk">Negative lookahead</strong><em class="my"><br/>banana(?!apple)           </em>Match <em class="my">banana</em> that is <strong class="ns jk">not</strong> directly followed up by <em class="my">apple</em></span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5882" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">向后看</h1><p id="473b" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">后视与前视的工作方式相同，只有一个主要区别——它看的是后面而不是前面。</p><p id="bdec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<em class="my"> B </em>在前面，Lookbehinds可用于匹配<em class="my"> A </em>。其语法类似于<code class="fe ob oc od ns b">(?&lt;=B)A</code>。</p><p id="3bca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看下面的正则表达式，它使用了一个肯定的lookbehind。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="6462" class="nf mc jj ns b gy nw nx l ny nz">/(?&lt;=strawberry)banana/g</span></pre><p id="245f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这个正则表达式前面直接有<em class="my">草莓</em>，它将匹配<em class="my">香蕉</em>。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/db7b92cb17a9675d26efae55451ebd25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zm6mR2h1ilxi4-62gfn1og.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">正则表达式的结果:/(？&lt;=strawberry)banana/g</figcaption></figure><p id="6db4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">There’s also a negative lookbehind which matches <em class="my"> A </em>如果它没有<em class="my"> B </em> <strong class="la jk"> <em class="my"> </em> </strong>就直接在它前面。否定后视的语法类似于<code class="fe ob oc od ns b">(?&lt;!B)A</code>。</p><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="c9fe" class="nf mc jj ns b gy nw nx l ny nz">/(?&lt;!strawberry)banana/g</span></pre><p id="05d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<strong class="la jk">而不是</strong>前面有<em class="my">草莓</em>，这个正则表达式将匹配<em class="my">香蕉</em>。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/4bc873fc6d1f847c8de30d083dd53add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQ-1U1zvXGiuDG3MyTX6Ng.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">正则表达式的结果:/(？</figcaption></figure><h2 id="b0ef" class="nf mc jj bd md ng nh dn mh ni nj dp ml lh nk nl mn ll nm nn mp lp no np mr nq bi translated">摘要</h2><pre class="na nb nc nd gt nr ns nt nu aw nv bi"><span id="dee4" class="nf mc jj ns b gy nw nx l ny nz"><strong class="ns jk">Positive lookbehind<br/></strong><em class="my">(?&lt;=apple)banana</em>          Matches the <em class="my">banana</em> that has <em class="my">apple</em> right in front of it</span><span id="a9ed" class="nf mc jj ns b gy oh nx l ny nz"><strong class="ns jk">Negative lookbehind<br/></strong><em class="my">(?&lt;!apple)banana          </em>Matches the <em class="my">banana</em> that <strong class="ns jk">doesn't</strong> have <em class="my">apple</em> right in front of it</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="cc41" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">包装它</h1><p id="08bd" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">既然我们已经讨论了这些更高级的正则表达式主题，我希望您已经了解了一些东西。到目前为止，您可能比一般开发人员更了解正则表达式——这很好。</p><p id="af50" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是为了保持领先，您需要练习并获得正则表达式的实践经验。例如，您可以将它们构建到您的下一个应用程序中。</p><p id="64eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">摆弄你刚刚学到的所有新的正则表达式概念。</p><p id="0d64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码快乐！</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div></div>    
</body>
</html>