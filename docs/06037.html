<html>
<head>
<title>Microservices with PHP and Lumen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PHP和Lumen的微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/microservices-with-php-and-lumen-d9af0b915a71?source=collection_archive---------3-----------------------#2020-10-21">https://levelup.gitconnected.com/microservices-with-php-and-lumen-d9af0b915a71?source=collection_archive---------3-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">与PHP的过去决裂，而不破坏现有的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d25ec91f69fec57e87f688196f18f38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXctFJDoH3I3i-v7J9OEdQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@mimithian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米米·蒂安</a>拍摄的照片</figcaption></figure><p id="7119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PHP是由拉斯马斯·勒德尔夫在1994年开发的，作为一种混合在服务器上执行的代码和标准HTML的简单方法。它在服务器上被翻译成纯HTML，并作为对HTTP请求的响应发送出去。它在早期网络中被广泛采用，是脸书的原始语言。随着时间的推移，开发了许多框架来形式化模型视图控制器(MVC)系统，以允许表达现代web应用程序的更可控的方式。</p><p id="b6b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我以前的系列文章，从<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/modern-php-df3d3bf343f8">现代PHP </a>开始，在Symfony框架中使用了这种方法。我能够在相对较短的时间内运行一个不错的web应用程序，甚至将其部署到web上。但是这种方法并不是没有缺点。最大的问题是其他应用程序无法以受控的方式使用这些数据。</p><p id="cd14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将把我创建的应用程序的一些后端部分用PHP重写为一个微服务。这将使其与前端完全分离，并允许其他实体(比如移动设备)使用相同的数据。我并不是说PHP是编写微服务的最佳语言(我不会去争论什么是微服务)。我用PHP写这篇文章是因为很多开发人员在PHP上投入了很多知识，这可能会帮助他们从MVC的世界过渡到微服务的世界。</p><p id="3142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于本文将建立在我在文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/modern-php-df3d3bf343f8"> Modern PHP </a>和后续两篇文章(所有链接都在文章末尾)中所做的工作之上，所以您应该回去通读并理解它们。他们将设置部署框架、数据库，并创建我们将在这里使用的数据库对象。因为许多服务可能使用同一个数据库，所以必须将数据库初始化从服务中分离出来。在本文结束时，您将拥有一个部署到Google云平台(或任何具有基本虚拟机的云平台)的部分REST API</p><p id="9fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么什么是微服务，为什么你会想使用它们呢？顾名思义，它们是最小的、集中的服务，只处理一小部分后端逻辑。为什么要将服务分解到这个层次？这是我们使用数据的本质；我们倾向于读取现有数据，而不是写入新数据。因此，我们可能希望增加十几个读服务，而只有几个写服务。我们可能还想在写入服务之前添加一个消息队列缓冲区来处理峰值负载。</p><p id="135e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个原因是脱钩。我们可能需要一个读取服务来获取一些存在于不同数据库中的数据。我们可以调用另一个读取服务来处理数据，而不是在一个读取服务中添加多个数据库。这也将保留数据如何存储在一个被调用的单一读取服务中的细节，而不是直接的数据库访问，并允许可能的流行数据的缓存。</p><p id="cf22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://lumen.laravel.com/" rel="noopener ugc nofollow" target="_blank"> Lumen </a>，它是Laravel框架的一个子集。Lumen使用Compose作为依赖管理器。如果你还没有安装Compose，再次回到我的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/modern-php-df3d3bf343f8"> Modern PHP </a>，它会帮助你安装你需要的东西。完成创作后，您可以开始一个新项目:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8ebc" class="ma mb it lw b gy mc md l me mf">composer create-project --prefer-dist laravel/lumen phprest</span></pre><p id="66f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用测试服务器启动它:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ef3d" class="ma mb it lw b gy mc md l me mf">php -S localhost:8000 -t public</span></pre><p id="ee7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浏览到<a class="ae ky" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a>，您应该可以在浏览器中看到Lumen版本。</p><p id="3e25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该服务处理的所有路由都将在routes/web.php中定义。目前它有一个用于打印版本的<code class="fe mg mh mi lw b">/</code>的路由。我们的微服务只是读取一个已经存在的数据库。将有两个端点，<code class="fe mg mh mi lw b">/api</code>和<code class="fe mg mh mi lw b">/api/{id}</code>。我们不会在服务级别将对象名称添加到路径中，这可以由反向代理来完成。编辑<code class="fe mg mh mi lw b">routes/web.php</code>并添加两条路线(替换现有路线)</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3dab" class="ma mb it lw b gy mc md l me mf">$router-&gt;get('/api', function () {<br/>    return 'Get All';<br/>});</span><span id="9b0c" class="ma mb it lw b gy mj md l me mf">$router-&gt;get('/api/{id}', function ($id) {<br/>  return 'Get '.$id;<br/>});</span></pre><p id="4dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动和停止服务器，您应该能够浏览到<a class="ae ky" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/API/</a>和<a class="ae ky" href="http://localhost:8000/1" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/API/1</a>，并在浏览器中看到“Get All”和“Get 1”。</p><p id="0df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在这里评论一下，看看项目树，它看起来不像是所有的流明都是轻量级的。在很多目录中有很多文件，我希望我们不会有很多未使用的功能。所有这些额外的代码让我紧张，它增加了本该如此简单的东西的攻击面吗？也许有另一个更紧凑的框架，但我将把它留到以后再说。</p><p id="9938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将数据库添加到组合中。我们将使用<a class="ae ky" href="https://laravel.com/docs/5.0/eloquent" rel="noopener ugc nofollow" target="_blank">雄辩的ORM </a>处理数据库。在<code class="fe mg mh mi lw b">bootstrap/app.php</code>中，您可以在创建了<code class="fe mg mh mi lw b">$app</code>对象之后取消Facades和雄辩行的注释</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5d38" class="ma mb it lw b gy mc md l me mf">$app = new Laravel\Lumen\Application(<br/>    dirname(__DIR__)<br/>);</span><span id="ebfa" class="ma mb it lw b gy mj md l me mf">$app-&gt;withFacades();</span><span id="f99a" class="ma mb it lw b gy mj md l me mf">$app-&gt;withEloquent();</span></pre><p id="f60f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建模型了。因为我们已经有了将要读取的数据库，所以我们知道模式。该数据库是葡萄酒和奶酪配对的数据库之一。编辑<code class="fe mg mh mi lw b">app/Models/WinePairing.php</code></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3391" class="ma mb it lw b gy mc md l me mf">&lt;?php</span><span id="5de2" class="ma mb it lw b gy mj md l me mf">namespace App\Models;</span><span id="c7f7" class="ma mb it lw b gy mj md l me mf">use Illuminate\Database\Eloquent\Model;</span><span id="029d" class="ma mb it lw b gy mj md l me mf">class WinePairing extends Model<br/>{    <br/>   protected $table = 'wine_pairing';<br/>   protected $fillable = [<br/>        'id', <br/>        'wine', <br/>        'wine_description', <br/>        'cheese', <br/>        'cheese_description', <br/>        'pairing_notes'<br/>   ];</span><span id="0b4c" class="ma mb it lw b gy mj md l me mf">   protected $hidden = [];<br/>}</span></pre><p id="0e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不设置<code class="fe mg mh mi lw b">$table</code>变量，它将使用类名的复数。因为在这个服务中，我们将使用一个已经定义的数据库，我们需要专门定义它来匹配。此外，您可能会在同一个目录中删除<code class="fe mg mh mi lw b">User.php</code>模型。我们绝对不想在我们的数据库中存储用户和密码。如果我们决定添加身份验证，我们将使用无状态身份验证方法。</p><p id="4dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在文件<code class="fe mg mh mi lw b">app/Http/Controllers/WinePairingController.php</code>中创建控制器:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9ec7" class="ma mb it lw b gy mc md l me mf">&lt;?php</span><span id="d5b9" class="ma mb it lw b gy mj md l me mf">namespace App\Http\Controllers;</span><span id="6e1b" class="ma mb it lw b gy mj md l me mf">use App\Models\WinePairing;<br/>use Illuminate\Http\Request;</span><span id="26f5" class="ma mb it lw b gy mj md l me mf">class WinePairingController extends Controller<br/>{</span><span id="fc4f" class="ma mb it lw b gy mj md l me mf">  public function showAllWinePairings()<br/>  {<br/>    return response()-&gt;json(WinePairing::all());<br/>  }</span><span id="a6ce" class="ma mb it lw b gy mj md l me mf">  public function showOneWinePairing($id)<br/>  {<br/>    return response()-&gt;json(WinePairing::find($id));<br/>  }</span><span id="ebe3" class="ma mb it lw b gy mj md l me mf">}</span></pre><p id="a9d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以重写路线以使用控制器:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8bbe" class="ma mb it lw b gy mc md l me mf">$router-&gt;group(['prefix' =&gt; 'api'], function () use ($router) {<br/>  $router-&gt;get('/',  ['uses' =&gt;<br/>    'WinePairingController@showAllWinePairings']);</span><span id="69f2" class="ma mb it lw b gy mj md l me mf">  $router-&gt;get('/{id}', ['uses' =&gt;<br/>    'WinePairingController@showOneWinePairing']);</span><span id="f6bc" class="ma mb it lw b gy mj md l me mf">});</span></pre><p id="9359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的服务端点是完整的。您可以再次启动它，但是您得到的只是错误消息，因为没有数据库。那么我们如何得到一个数据库呢？我们会用Docker Compose提出来。创建一个<code class="fe mg mh mi lw b">docker-compose.yml</code>并添加这个:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3f15" class="ma mb it lw b gy mc md l me mf">version: '3.1'<br/>services:<br/>  mariadb:<br/>    image: mariadb<br/>    restart: always<br/>    environment:<br/>      MYSQL_ROOT_PASSWORD: example<br/>    ports:<br/>      - 3306:3306<br/>  adminer:<br/>    image: adminer<br/>    restart: always<br/>    ports:<br/>      - 7000:8080</span></pre><p id="cfa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要告诉应用程序。环境文件:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e216" class="ma mb it lw b gy mc md l me mf">APP_NAME=WinePairing<br/>APP_ENV=local<br/>APP_KEY=<br/>APP_DEBUG=true<br/>APP_URL=<a class="ae ky" href="http://localhost" rel="noopener ugc nofollow" target="_blank">http://localhost</a><br/>APP_TIMEZONE=UTC</span><span id="64c7" class="ma mb it lw b gy mj md l me mf">LOG_CHANNEL=stack<br/>LOG_SLACK_WEBHOOK_URL=</span><span id="3501" class="ma mb it lw b gy mj md l me mf">DB_CONNECTION=mysql<br/>DB_HOST=mariadb<br/>DB_PORT=3306<br/>DB_DATABASE=winelist<br/>DB_USERNAME=root<br/>DB_PASSWORD=example</span><span id="aec6" class="ma mb it lw b gy mj md l me mf">CACHE_DRIVER=file<br/>QUEUE_CONNECTION=sync</span></pre><p id="6269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密码只是用于测试，我们将在部署的应用程序中使用真实的密码。现在我们可以启动数据库了:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="367e" class="ma mb it lw b gy mc md l me mf">docker-compose up -d</span></pre><p id="18ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不使用-d，您可以看到所有的日志记录，但是您必须打开一个新的终端来运行其他命令。</p><p id="70b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库中还没有任何东西，但是<code class="fe mg mh mi lw b">docker-compose.yml</code>包含了<code class="fe mg mh mi lw b">adminer</code>应用程序，它将允许您设置数据库。要访问它，请浏览到<a class="ae ky" href="http://localhost:7000/." rel="noopener ugc nofollow" target="_blank"> http://localhost:7000/。</a>当出现登录屏幕时，您可以使用服务器名<code class="fe mg mh mi lw b">mariadb</code> (Docker Compose使用自己的网络并将服务名设置为主机名)和用户名/密码root/example。这应该会将您带到以下屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/4f5cbb32b25efa1bdf9afd5fd4851420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HeKXSZmG5di9WW0JkZSN6w.png"/></div></div></figure><p id="1729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用“SQL命令”链接，执行以下代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0a55" class="ma mb it lw b gy mc md l me mf">CREATE DATABASE IF NOT EXISTS winelist;<br/>USE winelist;<br/>CREATE TABLE IF NOT EXISTS wine_pairing<br/>  (id INT AUTO_INCREMENT NOT NULL,<br/>   wine VARCHAR(255) NOT NULL,<br/>   wine_description VARCHAR(255) NOT NULL,<br/>   cheese VARCHAR(255) NOT NULL,<br/>   cheese_description VARCHAR(255) NOT NULL,<br/>   pairing_notes VARCHAR(255) NOT NULL,<br/>   PRIMARY KEY(id))<br/>   DEFAULT CHARACTER SET utf8mb4<br/>   COLLATE `utf8mb4_unicode_ci`<br/>   ENGINE = InnoDB;</span></pre><p id="580a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您的数据库应该有wine_pairing表，它与我们将在最终应用程序中读取的表完全相同。点击它，你可以使用“新项目”链接来添加一个项目。现在您可以启动应用程序，并且<a class="ae ky" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000/ </a>和<a class="ae ky" href="http://localhost:8000/1" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/1</a>将作为JSON显示您添加的新项目。如果是的话，那么恭喜你，你的REST API成功了！</p><p id="fda9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以创建一个Docker映像，并将其部署在我们的原始应用程序旁边，作为读取其他服务、不同前端或移动设备可能使用的数据的一种方式。因为它只是一个read应用程序，没有个人数据，所以我们不用担心身份验证。任何人都可以阅读我们的葡萄酒搭配清单。</p><p id="6598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建Docker映像，我们需要确保它拥有所有的依赖项。我将从<code class="fe mg mh mi lw b">phpapp</code>存储库中复制我之前使用的Dockerfile文件。这是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="32a6" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">部署到GCP</h2><p id="de9d" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">本节再次假设您已经阅读了我在本系列中的前几篇文章，并且已经设置了GCP来托管主应用程序。基本上，我们用最小的CPU在GCP上创建了一个VM，安装了git和Docker Compose，并克隆了<code class="fe mg mh mi lw b">phpappprod</code>库。我们还将必需的证书和配置文件复制到主目录中，该目录是<code class="fe mg mh mi lw b">phpappprod</code>存储库的父目录，这样Docker Compose就可以从那里挂载所有必需的文件。要继续，您需要让该虚拟机运行并可以从SSH访问。</p><p id="edb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们必须构建和部署映像，以便它可以在生产中使用:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="871b" class="ma mb it lw b gy mc md l me mf">docker build -t &lt;yourdockerhubname&gt;/phprest .<br/>docker push &lt;yourdockerhubname&gt;/phprest</span></pre><p id="9b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个可以在容器中运行的映像，并将其推送到Docker Hub，以便您的云虚拟机可以使用它。但是数据库密码呢？我们不能在我们的云虚拟机中使用“example ”(尽管我们没有公开数据库，但为了安全起见)。我们要去。env文件，并将其添加到虚拟机的安全目录中，特别是存储库目录的父目录。打开虚拟机的SSH终端，运行<code class="fe mg mh mi lw b">vi phprest.env</code>并将<code class="fe mg mh mi lw b">.env</code>文件的内容复制到其中。然后编辑数据库密码，使其与虚拟机上现有的<code class="fe mg mh mi lw b">phpapp.env</code>文件中的密码相匹配。</p><p id="9895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将新服务添加到现有的生产服务中，并添加一个反向代理路由。我有一个生产脚本的特定存储库，<code class="fe mg mh mi lw b">phpappprod</code>，我将修改它们。这里是新的<code class="fe mg mh mi lw b">docker-compose.yml</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="79f3" class="ma mb it lw b gy mc md l me mf">version: '3.1'<br/>services:<br/>  nginx:<br/>    image: nginx<br/>    restart: always<br/>    volumes:<br/>     - ./nginx.conf:/etc/nginx/nginx.conf<br/>     - ..:/etc/certs<br/>    ports:<br/>     - "443:443"<br/>  mariadb:<br/>    image: mariadb<br/>    restart: always<br/>    volumes:<br/>     - ./data:/var/lib/mysql<br/>     - ./init:/docker-entrypoint-initdb.d<br/>    env_file:<br/>      - ../phpapp.env<br/>    ports:<br/>      - 3306:3306<br/>  phpapp:<br/>    image: rlkamradt/phpapp<br/>    env_file:<br/>      - ../phpapp.env<br/>    ports:<br/>      - 8000:8000<br/>  phprest:<br/>    image: rlkamradt/phprest<br/>    env_file:<br/>      - ../phprest.env<br/>    ports:<br/>      - 8001:8000<br/>  vouch:<br/>    image: voucher/vouch-proxy<br/>    volumes:<br/>      - ..:/config<br/>    ports:<br/>      - 9090:9090</span></pre><p id="3b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在我的<code class="fe mg mh mi lw b">nginx.conf</code>中添加一个新的虚拟主机:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="df08" class="ma mb it lw b gy mc md l me mf">server {<br/>    listen 443 ssl;<br/>    server_name phprest.yourdomain.com;<br/>    ssl_certificate /etc/certs/yourdomain.com.pem;<br/>    ssl_certificate_key /etc/certs/yourdomain.com.key;<br/>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br/>    ssl_ciphers HIGH:!aNULL:!MD5;<br/>    location / {<br/>        proxy_pass <a class="ae ky" href="http://phprest:8000" rel="noopener ugc nofollow" target="_blank">http://phprest:8000</a>;<br/>    }<br/>}</span></pre><p id="03d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里假设您从<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/modern-php-part-2-4973f48a90c0">现代PHP(第2部分)</a>中创建了证书和密钥。注意，<code class="fe mg mh mi lw b">proxy_pass</code>行使用容器端口8000，而不是主机端口8001。</p><p id="8362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在确保您的主机<code class="fe mg mh mi lw b">phprest.yourdomain.com</code>存在，并指向您的VM的IP地址，再次遵循现代PHP(第2部分)的说明。</p><p id="f423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，提交并推送<code class="fe mg mh mi lw b">phpappprod</code>存储库中的所有更改，以便它们对云VM可用。回到云虚拟机SSH终端，在<code class="fe mg mh mi lw b">phpappprod</code>存储库克隆中，运行<code class="fe mg mh mi lw b">git pull</code>将所有更改上传到虚拟机。然后运行<code class="fe mg mh mi lw b">sudo docker-compose up -d</code>将启动一切，包括你的新微服务。你可以用Postman来测试它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/55fd0673152bf14618e8aae9fdcccd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trjMTFG2uyYS16txN1iPFA.png"/></div></div></figure><p id="c6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您有了一个微服务，它将从您的主应用程序返回所有数据。也许在我的下一篇文章中，我会创建一个使用这些数据的Android应用程序。</p><p id="eb49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真诚地希望这将帮助所有PHP开发人员了解微服务的方法和原因。您不必仅仅为了创建可能赋予您的应用程序新生命的新端点而干扰您现有的应用程序。最终，您可能希望替换您的应用程序，并使用React这样的现代前端，但是您可以一部分一部分地完成，而不是试图一次重写所有内容。感谢您的阅读！</p><p id="e9b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中使用的存储库:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/rkamradt/phprest/tree/v0.1" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">rkamradt/phprest</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Laravel Lumen是一个速度惊人的PHP微框架，用于构建具有丰富、优雅语法的web应用程序…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://github.com/rkamradt/phpappprod/tree/v0.3" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">rkamradt/PHP pprod</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob ks nn"/></div></div></a></div><p id="e207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提到的其他文章:</p><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/modern-php-df3d3bf343f8"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">现代PHP</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">使用Upstart上最需要的项目语言之一开始你的自由职业生涯。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="od l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/modern-php-part-2-4973f48a90c0"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">现代PHP(第2部分)</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">部署到web</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="oe l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/modern-php-part-3-1f5b78b3371d"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">现代PHP(第3部分)</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">所有web应用程序的单点登录。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="of l ny nz oa nw ob ks nn"/></div></div></a></div></div></div>    
</body>
</html>