<html>
<head>
<title>DRY Your Unit Tests with Dynamic Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用动态测试来干燥你的单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dry-your-unit-tests-with-dynamic-testing-d6df8c8bb83a?source=collection_archive---------12-----------------------#2020-03-09">https://levelup.gitconnected.com/dry-your-unit-tests-with-dynamic-testing-d6df8c8bb83a?source=collection_archive---------12-----------------------#2020-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1271" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">JavaScript和类型脚本测试</h2><div class=""/><div class=""><h2 id="c3a2" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">动态测试很容易设置和理解，但是更高级的用法经常被忽略。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/efd0ac0d6787c3170a707b13b89907ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-qVeZFSpOMabsNunSzBJqQ.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">什么是动态测试？</figcaption></figure><p id="a845" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">动态测试很容易设置和理解，但是更高级的用法经常被忽略。在这篇文章中，我们将探索动态测试的基础，然后我们将继续讨论真正的回报；坚持不要在测试和你用于测试的数据中重复你自己(干)的能力。对于代码示例，我将使用TypeScript和Mocha。</p><h1 id="79c7" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">入门指南</h1><p id="7a09" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">Mocha.js文档对生成动态测试的基础有一个简洁的概述。这个想法是，您要用简单的数据建立一个JSON对象数组，然后编写一个常规的JavaScript循环，其中包含一个或多个使用数组中每个对象的测试。这可能是您在正常代码中为避免重复而反复使用的模式。您也可以在几乎所有的单元测试中这样做！当您对一个被测函数进行多次测试时，最常见的就是这样做。您只需要函数输入和结果输出的数据，并且通常可以消除测试。举个例子吧。<a class="ae mt" href="https://www.medium.com/p/d6df8c8bb83a#11a6" rel="noopener">T3】</a></p><h1 id="208e" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">测试舒适度</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/3fa4f6eebc73b78d217bc80f27feb52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*TjFSh0LR5EVEETH-2nHkPQ.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">写完测试后能够放松</figcaption></figure><p id="7104" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有时你只想确保任何可能出错的东西都经过测试，即使它不太可能出错。当我有测试中的边缘案例时，我开始对我的代码准备好了感到舒服。在这个例子中，我们将使用UUIDs。UUID有一个<a class="ae mt" href="https://tools.ietf.org/html/rfc4122" rel="noopener ugc nofollow" target="_blank">详细规范</a>，当使用UUID时，您可能需要确保您传递的值满足那些要求。对于正则表达式来说，这是一个很好的问题。这里有一个<a class="ae mt" href="https://github.com/Rolias/blog-posts/blob/master/src/DRY-tests-pt1/uuid.ts" rel="noopener ugc nofollow" target="_blank">方法，它使用正则表达式来验证UUID </a>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/9de89f2ccaa3dede319bf4cca88be950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5qxf592wcpB6nNhyAAUZA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">isValidUuid方法</figcaption></figure><h2 id="07a8" class="na lx iq bd ly nb nc dn mc nd ne dp mg lj nf ng mi ln nh ni mk lr nj nk mm iw bi translated"><sidebar title="”dissecting" this="" regular="" expression=""/></h2><p id="e3fb" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">如果不使用正则表达式，这个函数有点难以理解，所以这里有一个简单的概要。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nl"><img src="../Images/7195b0e5590d4d0970b7cec88f1f4dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtVkKHg1NPwNx20miq7n4w.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">带注释的正则表达式</figcaption></figure><p id="eb8b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下列各组(最后一组除外)后面必须跟一个连字符。</p><ol class=""><li id="0f6e" class="nm nn iq lc b ld le lg lh lj no ln np lr nq lv nr ns nt nu bi translated">允许0和9(包括0和9)之间的任何数字或a和f(包括0和9)之间的任何字母，也就是任何十六进制数字。它允许八个这样的。</li><li id="ef4c" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">允许多四个十六进制数字。</li><li id="3b9c" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">允许一个介于0和5之间的数字，后跟3个十六进制数字。</li><li id="d0df" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">允许0或8和b之间的十六进制数字，后跟三个十六进制数字。</li><li id="f0ed" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">允许12个十六进制数字。</li></ol><p id="f843" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="oa">如果想要更详细的解释，取正则表达式粘贴到一个</em> <a class="ae mt" href="https://regex101.com/r/eyN89F/1" rel="noopener ugc nofollow" target="_blank"> <em class="oa">在线正则表达式分析器</em> </a> <em class="oa">。</em></p><h2 id="1aed" class="na lx iq bd ly nb nc dn mc nd ne dp mg lj nf ng mi ln nh ni mk lr nj nk mm iw bi translated"/><h1 id="402c" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">典型的湿法</h1><p id="030d" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">这里有一个湿的<a class="ae mt" href="https://www.medium.com/p/d6df8c8bb83a#85f4" rel="noopener"> </a>，但是<a class="ae mt" href="https://github.com/Rolias/blog-posts/blob/master/src/DRY-tests-pt1/uuid-wet.unit.test.ts" rel="noopener ugc nofollow" target="_blank">完全可以接受的方法</a>，测试一个有效的UUID，和一个无效的UUID。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8db89524b7dd5c003e88ba5a07d1d48d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*lnA4wZW-3Zez1OGQ2QKlEg.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">isValidUuid()方法的湿单元测试</figcaption></figure><p id="dddd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是可行的，但是它只包含两个测试用例:一个用于好的UUID，另一个用于坏的UUID，即一个简单的字符串。你或许可以想出更多的测试方法。然而，即使只有这两个测试，你也开始闻到重复的味道。有时候，在气味真正渗入你的代码之前，除臭更容易。这就是动态测试可以发挥作用的地方。</p><h1 id="bf59" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">干法</h1><p id="cbf0" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">这个版本的测试探索了5个条件，而不是2个，测试代码的长度只增加了一行，尽管我不得不添加测试数据。让我们从测试数据开始浏览这个例子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oc"><img src="../Images/5c06caba56e621cc35ef0996374deca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZ9Noj0jYJSxq1w-lRJRww.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">isValidUuid的单元测试的干版本</figcaption></figure><h2 id="b2f6" class="na lx iq bd ly nb nc dn mc nd ne dp mg lj nf ng mi ln nh ni mk lr nj nk mm iw bi translated">测试数据</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi od"><img src="../Images/0e04bdd105a7bd4469fa4ef506e81770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpOq8fJjZBe482uRHemWrg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">带注释的测试数据</figcaption></figure><ol class=""><li id="5881" class="nm nn iq lc b ld le lg lh lj no ln np lr nq lv nr ns nt nu bi translated">属性允许我们给每个<code class="fe oe of og oh b">it()</code>一个自定义名称</li><li id="30e2" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated"><code class="fe oe of og oh b">value</code>属性是被测单元的输入。</li><li id="b99b" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">从被测单元返回的<code class="fe oe of og oh b">expected</code>值。</li></ol><p id="2765" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">甚至在不理解测试代码的情况下，我怀疑你们中的许多人现在可以通过向这个数组添加额外的对象来编写更多的测试用例。但是，要成功实现动态测试，您确实需要理解代码，所以让我们来探索一下。</p><h2 id="0800" class="na lx iq bd ly nb nc dn mc nd ne dp mg lj nf ng mi ln nh ni mk lr nj nk mm iw bi translated">测试代码</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oi"><img src="../Images/d2bc5e729dde35467f79cdec0242439e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJnvLXjrkGmSzJ-qOZg-ng.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">干单元测试的代码部分</figcaption></figure><ol class=""><li id="cb2e" class="nm nn iq lc b ld le lg lh lj no ln np lr nq lv nr ns nt nu bi translated">测试代码现在在<code class="fe oe of og oh b">it()</code>周围包装了一个标准的JavaScript <code class="fe oe of og oh b">foreach</code>语句，并使用变量名<code class="fe oe of og oh b">test</code>传入我们测试数据的每一行</li><li id="263c" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated"><code class="fe oe of og oh b">it()</code>的描述使用来自传递的<code class="fe oe of og oh b">test</code>变量的<code class="fe oe of og oh b">condition</code>字段和<code class="fe oe of og oh b">expected</code>字段，给测试一个有意义的名称。</li><li id="9fba" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">被测试的方法从我们的测试数据中被传递给<code class="fe oe of og oh b">value</code>字段，并且<code class="fe oe of og oh b">should</code>断言针对数据中的<code class="fe oe of og oh b">expected</code>值进行测试。</li></ol><h2 id="7ebf" class="na lx iq bd ly nb nc dn mc nd ne dp mg lj nf ng mi ln nh ni mk lr nj nk mm iw bi translated">测试结果</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f89501881885779a5df170c837179e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*7kwE91AQyHDXh0kL99mhCA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">干单元测试结果</figcaption></figure><p id="ffa0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">动态测试结果同样具有表现力，只需要很少的输入。</p><h1 id="0e9d" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">摘要</h1><p id="8a4f" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">一旦你理解并适应了这个习语测试，理解五个(或二十个)测试的认知负荷和理解一个测试的代价是一样的。复制和粘贴错误仅限于数据数组，在这里它们更容易被发现。为边缘情况和异常值添加更多的测试变得不那么痛苦了。没有编写代码的团队成员可以快速轻松地添加新的测试，而没有风险。</p><h1 id="9314" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">后续步骤</h1><p id="740a" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">动态测试可以做的不仅仅是自动调用单个函数。你可以用单个测试阵列测试:</p><ul class=""><li id="8db2" class="nm nn iq lc b ld le lg lh lj no ln np lr nq lv ok ns nt nu bi translated">多重功能</li><li id="7e68" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv ok ns nt nu bi translated">带有匹配器的expect子句</li><li id="d60e" class="nm nn iq lc b ld nv lg nw lj nx ln ny lr nz lv ok ns nt nu bi translated">解析函数特定结果的存根</li></ul></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="0d55" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="oa">更有</em><a class="ae mt" href="https://gentille.us/b3601fb73472?sk=0dc73c81df810c0f181c432c9db3e085" rel="noopener ugc nofollow" target="_blank"><em class="oa">JavaScript/TypeScript测试</em> </a> <em class="oa">提示文章。</em></p><p id="7113" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">平静地编码。</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><h2 id="7988" class="na lx iq bd ly nb nc dn mc nd ne dp mg lj nf ng mi ln nh ni mk lr nj nk mm iw bi translated">脚注</h2><p id="11a6" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">本文中显示的所有代码都可以在GitHub 上的<a class="ae mt" href="https://github.com/Rolias/blog-posts/tree/master/src/DRY-tests-pt1" rel="noopener ugc nofollow" target="_blank">公共存储库中获得。<code class="fe oe of og oh b">npm run test:unit</code>将执行单元测试。</a><a class="ae mt" href="https://www.medium.com/p/d6df8c8bb83a#208e" rel="noopener"> <em class="oa">回条</em> </a></p><p id="85f4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">湿:与无关的测试——因为世界需要更多的缩写。😎<a class="ae mt" href="https://www.medium.com/p/d6df8c8bb83a#030d" rel="noopener"> <em class="oa">回条</em> </a></p></div></div>    
</body>
</html>