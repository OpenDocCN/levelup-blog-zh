<html>
<head>
<title>Golang, Opentelemetry, and Sentry — The Underrated Distributed Tracing Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang、Opentelemetry和Sentry——被低估的分布式跟踪堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-opentelemetry-and-sentry-the-underrated-distributed-tracing-stack-69dcda886ffe?source=collection_archive---------1-----------------------#2021-06-21">https://levelup.gitconnected.com/golang-opentelemetry-and-sentry-the-underrated-distributed-tracing-stack-69dcda886ffe?source=collection_archive---------1-----------------------#2021-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="20f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL；博士🚶<br/> </strong>我做了一个迷你仪器示例，演示了如何配置golang应用程序来使用opentelemetry并将获得的轨迹推送到sentry后端。下面是Github的链接(您可以在那里找到运行示例的步骤)</p><div class="kl km gp gr kn ko"><a href="https://github.com/uds5501/sentry-opentelemetry-example" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">uds 5501/sentry-open遥测-示例</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">要运行这个例子，您需要一个kubernetes集群。这个例子已经在Minikube AWS Elastic上进行了测试…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">github.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/e214fce975b99d12c2b393c2bb1eec3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4AJY1EhZxYCNDjuAQODqw.png"/></div></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="b641" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">简介<strong class="ak">👋</strong></h1><p id="7e78" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">还在吗？厉害！</p><p id="ddcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分布式跟踪是微服务架构的可观察性、跟踪和分析的重要组成部分。我不会深入探究跟踪的基本含义及其工作原理，因为有大量的相关资源，如果您需要关于分布式跟踪工作原理的具体内容，我推荐Open Tracing关于<a class="ae mz" href="https://opentracing.io/docs/overview/what-is-tracing/" rel="noopener ugc nofollow" target="_blank">分布式跟踪</a>的文章，以获得基本概述，并推荐Alois关于W3跟踪上下文的博文<a class="ae mz" href="https://aloisreitbauer.medium.com/trace-context-and-the-road-toward-trace-tool-interoperability-d4d56932369c" rel="noopener"/>，以更好地阐述分布式跟踪的工作原理。</p><h1 id="44f5" class="lw lx iq bd ly lz na mb mc md nb mf mg mh nc mj mk ml nd mn mo mp ne mr ms mt bi translated">这么多跟踪后端造成的混乱<strong class="ak">🤔</strong></h1><p id="82d2" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">但是在整个追踪难题中有一个小小的矛盾。虽然跟踪上下文规范和指南可能已经声明，但应用程序的插装仍然是广泛的“后端特定”问题。我的意思是，我们有各种各样的后端可以可视化跟踪，如哨兵，耶格，谷歌云跟踪，新遗迹，弹性等等。他们每个人都有自己的仪器SDK。</p><p id="2100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在假设，今天你决定使用弹性APM，并使用他们的SDK为你的微服务提供工具，后来你决定，嘿，这太重了，我们改用更轻的东西怎么样，比如说Jaeger / Sentry？</p><p id="9449" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哎呦！你必须使用sentry / Jaeger特定的SDK重新安装整个应用程序，因此，会产生巨大的技术开销。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nf"><img src="../Images/c647b2364f612d68bdbbe391844214b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xr0_gruRvbsP07XHWJzt8Q.png"/></div></div></figure><h1 id="e1d2" class="lw lx iq bd ly lz na mb mc md nb mf mg mh nc mj mk ml nd mn mo mp ne mr ms mt bi translated">这就是OpenTelemetry的用武之地<strong class="ak">🚀</strong></h1><p id="a95d" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">有了<a class="ae mz" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"> opentelemetry </a>，人们就不必重新测试他们的整个应用。相反，我们需要使用OpenTelemetry对我们的应用程序进行一次检测，这个SDK会将这些跟踪发送到一个“Open Telemetry Collector ”,该Collector会收集这些跟踪并将它们一次导出到多个后端。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ng"><img src="../Images/ff06d82e0e9e9cb067ad3159dbf41762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPhOfasedCAw8VuQjQtGdg.png"/></div></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="123e" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">为什么是哨兵？👀</h1><p id="0d7e" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">像每一个可观察性堆栈一样，Sentry有它的优点和缺点。但是具体来看Sentry作为一个分布式跟踪用户界面，下面是我特别喜欢的优点。</p><ul class=""><li id="9717" class="nh ni iq jp b jq jr ju jv jy nj kc nk kg nl kk nm nn no np bi translated">它相对紧凑，资源密集程度较低。我们的组织过去一直在使用New Relic和Elastic APM，虽然它们本身完全支持日志记录+跟踪+指标，但它们是资源密集型的，如果您真的在寻找一个可靠的ol，我会选择托管在简单EC2机器上的sentry，而不是完全成熟的k8s集群。</li><li id="7509" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">哨兵是无与伦比的错误管理和警报能力。</li></ul><p id="84cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">T4也有一些缺点:</p><ul class=""><li id="a6f8" class="nh ni iq jp b jq jr ju jv jy nj kc nk kg nl kk nm nn no np bi translated">要对错误使用堆栈跟踪捕获，您需要使用他们的官方SDK，因为目前，opentelemetry本身不支持完美的堆栈跟踪捕获。</li><li id="9261" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">Opentelemetry自己的日志目前处于测试阶段，并且在多个语言特定的SDK中处于冻结的开发状态，因此这种组合在这方面是一种缺失。</li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="fcc9" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">理论已经讲得够多了，现在我该如何检测我的Golang应用程序呢？⚒️</h1><p id="28a3" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">我使用了github上的openetelemetry的go sdk ,并在golang 中使用了它们的文档。</p><p id="b5cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个工具可以在最初提到的github存储库中的<code class="fe nv nw nx ny b">main.go</code>文件中找到。让我一步一步地告诉你，你是如何对你的应用程序进行检测的。</p><h2 id="e240" class="nz lx iq bd ly oa ob dn mc oc od dp mg jy oe of mk kc og oh mo kg oi oj ms ok bi translated">初始化跟踪器</h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ol"><img src="../Images/549d7556a8c50300da4ba20718b44604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ha6PRlandTTTheMMwL9NFA.png"/></div></div></figure><p id="1105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先必须初始化在<code class="fe nv nw nx ny b">initTracer()</code>方法中处理的跟踪器。它首先创建一个<strong class="jp ir">新导出器</strong> (OLTP导出器)，它通过GRPC协议连接到我们收集器的端口4317。(嘶...我们通过<strong class="jp ir">otel-collector . observability . SVC . cluster . local:4317</strong>连接到收集器，这意味着它在端口4317连接到observability名称空间中的otel-collector服务</p><p id="4d71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们创建一个新的<strong class="jp ir">资源</strong>来建立我们的服务名(在本例中，它是test-service)。</p><p id="ce91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后获取一个Span处理器，最后我们创建一个<strong class="jp ir"> TracerProvider </strong>，然后在我们的应用程序中对其进行全局设置。值得注意的一件有趣的事情是，我们可以决定我们应该采样多少条轨迹，目前通过<code class="fe nv nw nx ny b">AlwaysSample()</code>，我们命令我们的跟踪提供者总是采样轨迹。</p><p id="ef57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能对开发环境有好处，但是在生产中，我建议采用10-20%的采样率，这样就不会在系统中产生任何技术债务(痕迹通常很重)。</p><h2 id="52e7" class="nz lx iq bd ly oa ob dn mc oc od dp mg jy oe of mk kc og oh mo kg oi oj ms ok bi translated">开始吧。停下来。传播。</h2><p id="276e" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">现在，我们的基本追踪器提供程序已经准备好了，让我们开始了解我们到底是如何开始、停止和记录事件的。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi om"><img src="../Images/a7bcf30157ad3a2fe12dbad986381fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CV0EVlvPs2oCzoevVJUZCw.png"/></div></div></figure><p id="ae93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在<code class="fe nv nw nx ny b">somework/service.go</code>里找到这个函数。追踪器。Start()方法标记一个span和span的开始。End()结束一个跨度。我们可以分别使用<code class="fe nv nw nx ny b">span.AddEvent()</code>和<code class="fe nv nw nx ny b">span.RecordError()</code>在一个时间跨度内添加事件和记录错误。</p><p id="cf67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将跨度上下文传递给其他函数，您需要做的就是将当前的跨度上下文(在本例中为<code class="fe nv nw nx ny b">ctx2</code>)传递给下一个函数。下面是如何在<code class="fe nv nw nx ny b">ErrorWork()</code>函数中完成的。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi om"><img src="../Images/3fbdd3cb725f11eff3821aebe56ebe88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TboODiJRLWDh9QiFE00CFA.png"/></div></div></figure><h1 id="9fe2" class="lw lx iq bd ly lz na mb mc md nb mf mg mh nc mj mk ml nd mn mo mp ne mr ms mt bi translated">设置opentelemetry收集器和导出器。🚢</h1><p id="4e15" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">这实际上是容易的部分，你需要在一个配置文件中设置3件事。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi on"><img src="../Images/46b41e518c16d0c3f3117e1c8f8b53fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1m7ijZ-ohA4iyDY1GAVNQ.png"/></div></div></figure><p id="a7bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们配置<strong class="jp ir">接收器，</strong>也就是说，这是SDK导出器将跟踪信息推送到的地方。在这里，我们允许oltp接收器使用grpc和http协议(默认端口为4317，如果没有提到的话)</p><p id="08e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后你需要一些<strong class="jp ir">处理器和扩展</strong>，我已经使用了memory_limiter和batch处理器来确保我的收集器不会超过512 mib的峰值和1500 mib的内存限制。</p><p id="951b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，你设置你的<strong class="jp ir">出口。</strong>您可以一次配置多个导出器，就像这里，我已经配置了一个日志导出器(它将跟踪导出到pod的终端)和一个sentry导出器，它将跟踪同时导出到sentry UI。</p><p id="ef83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">搞定这三个了吗？现在我们要做的就是创建一个<strong class="jp ir">管道</strong>，它有一个接收器、处理器、输出器和Tada！</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="345d" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">资源🔖</h1><ul class=""><li id="4cad" class="nh ni iq jp b jq mu ju mv jy oo kc op kg oq kk nm nn no np bi translated"><a class="ae mz" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank">打开遥测文档</a></li><li id="c9aa" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae mz" href="https://github.com/open-telemetry/opentelemetry-collector" rel="noopener ugc nofollow" target="_blank">打开遥测采集器Github </a></li><li id="d818" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae mz" href="https://docs.sentry.io/product/sentry-basics/tracing/distributed-tracing/" rel="noopener ugc nofollow" target="_blank">哨兵分布式追踪</a></li><li id="7d8f" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae mz" href="https://github.com/uds5501/sentry-opentelemetry-example" rel="noopener ugc nofollow" target="_blank"> Github仪器库</a></li></ul></div></div>    
</body>
</html>