<html>
<head>
<title>5 Ways to Simplify Your React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化React挂钩的5种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-ways-to-simplify-your-react-hooks-fbedb406eee0?source=collection_archive---------4-----------------------#2020-05-22">https://levelup.gitconnected.com/5-ways-to-simplify-your-react-hooks-fbedb406eee0?source=collection_archive---------4-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/bb8daa1467a901fca53fdac4dc91c7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oq4ou8spPBXjo1XvDpUMrA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">在<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jd" href="https://unsplash.com/@richtervet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Rich Tervet </a>拍摄的照片</figcaption></figure><div class=""/><p id="ee5f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当编写一个定制的钩子时，很容易导致一个过于复杂的解决方案。这有时会导致不稳定的行为，创建无用的重新渲染，或者只是使其更难维护。考虑到这一点，我想分享我发现的5种帮助简化我的定制钩子的方法。</p><h1 id="6c81" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">减少您的“使用状态”计数</h1><p id="b256" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当你使用钩子进行开发时，很容易使用太多的“使用状态”调用，或者将所有状态简化为一个过于复杂的“使用状态”。提高钩子可读性的最好方法之一是对你的“使用状态”调用进行优先级排序。在我写的钩子中，我喜欢遵循一些关于状态实现的规则。</p><h2 id="d063" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">优先考虑易读性</h2><p id="69bf" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我更喜欢将状态作为一个对象来读取，而不是多个带有简单值的“useState”命令。使用更少的“useState”命令也会使钩子的返回更容易，并使组件的实现更简单。虽然这是我的偏好，但是代码是一个非常个人化和表达性的东西。我写代码的首要原则是<strong class="kf jh">优先考虑易读性</strong>。遵循这条规则将使你的代码更容易维护，迫使你思考你写的东西，并使你的代码更容易被别人理解。如果这是你从这篇文章中得到的唯一的东西，我已经完成了我的工作。</p><h2 id="574c" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">评估状态对象的内容</h2><p id="293f" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个组件从一开始就没有完美的计划。随着组件的增长，您的“使用状态”中的属性也可能变得复杂。在整个开发周期中，我强烈建议评估您的“useState”调用的内容，以确定将状态的各个部分分成附加的“useState”调用是否有意义。您可能希望按函数或类型对状态值进行分组。通常，我喜欢按照我认为通常会一起更新的属性，或者按照状态属性的功能，比如数据和视图属性，对状态数据进行分组。</p><h1 id="e053" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">利用你的回钩</h1><p id="1bd4" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我第一次开始编写定制钩子时，很容易遵循类似于默认的“useState”钩子的返回风格。虽然这并不坏，但是在函数之上使用一个返回数组来返回多个状态变量可能会很麻烦。想象一个钩子，除了处理数据选择的函数之外，它还返回两个不同的状态变量(一个用于数据，一个用于视图状态),以数组的形式返回，它可能看起来像这样。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">带有数组回车的钩子示例</figcaption></figure><p id="2c69" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看一下这个钩子，很容易看出如果在返回中添加额外的函数或变量，钩子的实现会很快失控。如果您不按顺序或者使用不正确的名称来析构数组，这会导致额外的混乱和可能的错误。我们可以通过更新钩子返回一个对象来避免这种情况，就像这样。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">带有对象返回的挂钩示例</figcaption></figure><p id="cd68" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将该回报转换为对象还有其他好处，包括:</p><ul class=""><li id="2c53" class="mw mx jg kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">如果钩子在多个组件之间共享，或者作为一个库，</li><li id="75b8" class="mw mx jg kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">当使用钩子在组件顶部提供相同级别的钩子API易读性时，您仍然可以解构对象</li></ul><p id="cf68" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以用钩子返回做的另一件很酷的事情是在你的状态中创建基于小状态的组件工厂函数。这提供了一个很好的方法来共享一个组件构建器给实现钩子的组件，而不暴露组件的状态。</p><h1 id="0440" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用合并钩子简化你的“setState”调用</h1><p id="0335" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在React中使用类而不是基于函数的组件进行开发，在状态管理方面确实有一些现成的优势，对我来说，最主要的优势是旧状态和新状态的合并。<a class="ae jd" href="https://gist.github.com/StMotorSpark/aecc76d7b589fdb3808f369e14f5261a" rel="noopener ugc nofollow" target="_blank"> React Docs for State </a>提供了React.Component内置的状态合并功能的很好的例子。虽然该功能没有直接内置到钩子中，但我们可以用一个简单的定制钩子来复制该行为，该钩子可以替换我们的“useState”调用，给我们提供相同的行为。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="0371" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">考虑分开你的钩子</h1><p id="a61d" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/why-i-always-use-custom-hooks-ce52b35b528">不管一个组件有多复杂，我总是推荐使用定制钩子</a>；然而，当构建一个定制的钩子时，将一个过于复杂的钩子分成多个简单的钩子是非常有用的。在我的项目中，我喜欢根据功能来划分钩子逻辑，例如，将钩子划分为状态的逻辑子集可能是有益的，比如一个钩子用于数据/web API交互，另一个钩子用于显示状态。回头看看<strong class="kf jh">钩子返回</strong>一节中的钩子示例，像这样把它分开可能会有用。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">拆分后的挂钩示例</figcaption></figure><h1 id="89f8" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">评估您的“useEffect”调用，以防止不必要的重新渲染</h1><p id="4414" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">“useEffect”钩子非常有用，但是如果使用不当，它会导致过多的重渲染。当查看您的自定义钩子时，评估您的“useEffect”调用是值得的。我喜欢遵守以下经验法则:</p><ul class=""><li id="0bc9" class="mw mx jg kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">如果“useEffect”在同一个挂钩范围内侦听状态变量，则该效果永远不会更新状态本身。</li><li id="9e37" class="mw mx jg kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">如果您有多个“useEffect”语句监听同一组变量，请考虑将它们组合起来。</li><li id="a3fb" class="mw mx jg kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">虽然结合“useEffects”有助于减少重新渲染次数，但首先要保证代码的可读性。</li></ul><h1 id="328d" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0b15" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是我在构建大量组件和挂钩的经验中发现的一些有用的东西的简短列表。我希望这能为您的React组件提供一些帮助，并让您有所思考。正如编程中的所有事情一样，做任何事情都有无数种方法，但是我希望这些技巧能够帮助您简化钩子，并为您编写更简洁的代码提供一些见解。</p></div></div>    
</body>
</html>