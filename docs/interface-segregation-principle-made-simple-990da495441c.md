# 界面分离原理变得简单

> 原文：<https://levelup.gitconnected.com/interface-segregation-principle-made-simple-990da495441c>

## 粒度将如何提高您的代码对现实应用程序中不断变化的需求的弹性。

![](img/d51924a31d0be7c28f9d69c23829d7d4.png)

米海三都

上面的两幅图像都是由相同数量的像素组成的，但是一幅看起来像一只熊，另一幅看起来更像一个震惊的正方形。这不是数量的差别，而是粒度的差别。用更小的片段创作更容易。

同样的逻辑也适用于编写优秀的、有弹性的代码。不应该强迫客户端代码实现它不使用的方法。这就是罗伯特·c·马丁定义的界面分离原理。

代码应该足够灵活，允许客户端代码只使用所需的抽象。这使得类更容易理解和构建。

# 自动驾驶系统问题

在 Liskov 替换[文章](/the-liskov-substitution-principle-made-simple-5e69165e7ab5)中，我们必须构建两个模块来控制一辆普通的汽车。这些模块是:

*   将汽车转化为“可驾驶”物体的模块。该模块支持四个简单的命令:前进或后退，左转或右转。
*   自动驾驶模块计算路线，并在可驾驶模块显示的四个命令的帮助下驾驶汽车。

在构建好软件之后，我们已经将它安装在轿车和卡车上。一切都很顺利，直到公司决定扩展到火车市场。这是我们遇到的第一个减速带。

![](img/fa8a9ff6726455176a134a338e1ea587.png)

火车不能左转或右转。米海三都

因为我们基于 Car 类的第一个实现定义了 IDrivable 接口，所以我们最终得到了一个包含四个方法的接口。虽然对汽车和卡车来说不成问题，但对火车来说却是个大问题。我们需要重新构想解决方案。

## 隔离接口

因为问题出在右转或左转上，我们可以将接口分为可右转和不可右转接口。现在，对象可以选择它们做什么，并且只实现需要的方法。

好的，这看起来是一个很好的抽象，对吗？在继续阅读之前，想想我们是否能发现任何问题。

## 绘图扭曲-平面自主模块

我们的软件非常棒，公司想在另一个市场——飞机市场——扩张。这就产生了另一个问题:飞机可以前进和转弯，但不能后退(至少在飞行时不能)。

我们再次打破了[利斯科夫替代原则](/the-liskov-substitution-principle-made-simple-5e69165e7ab5)。因为 IDrivable 定义了 GoForward()和 GoBackward()方法，所以我们必须为 GoBackward 抛出一个 NotImplementedException。

# 在现实世界中，你不可能总是有完美的抽象

有时候，根本不可能预见客户需要什么。所以有时候过去的抽象被证明是错误的。我们能做什么？

别管它们，创造新的。把你的代码想象成一个只追加的系统。因此，每当我们在生产中有一些错误的抽象时，就让它们去吧。此时，可能其他客户端已经在使用这些接口，对它们的任何更改都会产生一连串的问题。

![](img/14a289c8333c81f3b8c537f6bd153fef.png)

你的代码可以像扼杀者一样运行

相反，**使用扼杀者模式**。扼杀者无花果是一种生长在树周围的植物。慢慢地，这种植物长得如此之大，以至于它覆盖了整个寄主树，从土壤中吸取阳光和养分。最后，树会死去，无花果会变成树一样。它会保留原来的树形，但没有宿主的痕迹。

在真实世界的代码中也可以做同样的事情。回到 IDrivable 问题，我们可以离开原来的接口，创建两个新的接口，IForwardDrivable 和 IBackwardDrivable。

然后，将旧接口标记为不推荐使用。Java，C#，Javascript，Python 都支持信令弃用的方法。这允许客户端代码按照自己的时间表进行更新。至少一年后，您可以假设代码已经更新，并安全地“杀死”原来的接口。这种方法类似于延迟执行。

# 当心

理想的接口应该只有一个方法，也称为角色接口。这是最精细的界面，它将提供最大的灵活性。正如我们在自动驾驶问题中看到的，从一开始就打破 GoForward()和 GoBackward()可以为我们节省一次重构。

那么，为什么我没有破坏 ITurnable 接口呢？我可以定义一个 ITurnRight 和 ITurnLeft 接口。但是这有意义吗？有没有只能往一个方向转而不能往另一个方向转的机动车？个人觉得一个都想不出来。

将方法分成两个接口会增加代码的复杂性，但没有任何好处。这就是为什么这个原则会使你的代码库过于细粒度化。所以要小心。分开但是如果有一些方法离不开其中一个，也许最好把它们放在一起。

不要把这个原则和单一责任原则混淆。乍一看，它们似乎很相似，但是它们针对不同的问题。单一责任原则试图帮助您围绕变更的单一原因定义一个类别。接口分离原则是如何定义接口的蓝图。一个类可以实现任意多的接口。

# 外卖食品

*   不惜一切代价避免提取基于类的接口。接口不是由类定义的，而是由客户的需求定义的。
*   接口中的方法越少越好。但是不要过度。例如，如果你实现一个存储库接口，不要写一个 Add 接口，一个 Update 接口，一个 Get 接口，等等。但是像 IReadOnlyRepository 和 IFullAccessRepository 这样的东西可能有意义。
*   生产代码应该是只追加的(并最终删除)。使用扼杀者模式。每当一个已部署的接口需要更改时，就离开它。创建新的抽象，并将旧的抽象标记为已弃用。仅在至少一年后，删除已弃用的接口。
*   当这项原则与其他坚实的原则一起应用时，它的全部好处就会被收获

**坚实的原理制作简单的系列:**

*   [单一责任原则](/the-single-responsibility-principle-made-simple-4e1597a44d7d) (SRP)
*   [开合原理](/the-open-closed-principle-made-simple-cc3d0ed70553) (OCP)
*   [利斯科夫替代原理](/the-liskov-substitution-principle-made-simple-5e69165e7ab5) (LSP)
*   接口隔离原则(ISP)
*   [依存倒置原则](/the-dependency-inversion-principle-made-simple-70108b88dc76) (DIP)

# 进一步阅读

[](https://www.baeldung.com/java-interface-segregation) [## Java | Baeldung 中的接口分离原则

### 在本教程中，我们将讨论固体原理之一的界面分离原理。代表…

www.baeldung.com](https://www.baeldung.com/java-interface-segregation) [](https://stackify.com/interface-segregation-principle/) [## 坚实的设计原则解释:界面分离与代码示例

### 与单一责任原则相似，界面分离原则的目标是减少副作用

stackify.com](https://stackify.com/interface-segregation-principle/)