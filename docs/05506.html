<html>
<head>
<title>Save the queries, cache your objects! Optimizing Django: Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保存查询，缓存您的对象！优化Django:第5部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/save-the-queries-cache-your-objects-optimizing-django-part-5-f49325f0e9fd?source=collection_archive---------2-----------------------#2020-09-04">https://levelup.gitconnected.com/save-the-queries-cache-your-objects-optimizing-django-part-5-f49325f0e9fd?source=collection_archive---------2-----------------------#2020-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="afdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，在本系列中，我们已经介绍了在Django服务器的各个部分减少SQL内存占用的技巧和诀窍。例如，我们已经处理了<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e"/><code class="fe km kn ko kp b"><a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e">n+1</a></code><a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e">问题</a>，<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/speed-up-your-django-admin-by-removing-sql-counts-optimizing-django-part-2-f5e09da667c?source=friends_link&amp;sk=339d71c0b8a06c281d8b18a21c587d5b">删除了管理列表页面</a>中不必要的SQL计数，并且<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-multiple-massive-tables-in-a-single-admin-optimizing-django-part-3-2c4ee2fec142?source=friends_link&amp;sk=96a35d8e435719670b356ca4c4606c1c">修复了显示相关数据库表中数据的Django管理页面，否则这些页面将无法使用。</a>然而，我们还没有介绍缓存，为了纠正这个明显的遗漏，本文将解释如何使用它来尽可能地节省响应时间。</p></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><h1 id="28ce" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在我们深入研究之前，先简单介绍一下缓存…</h1><p id="33c0" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">通过使用缓存，可以减少大量冗余的数据库查询。我不会试图解释缓存的内部机制，因为有大量的文章解释缓存是如何工作的。好的一面是Django支持多种类型的缓存，从小规模的基于文件的缓存到企业级Redis，出于本指南的目的，我将跳过实现这些缓存的细节。</p><p id="73a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多关于如何在Django中设置Redis的信息，请查看这篇文章。Django还有一个<a class="ae kl" href="https://docs.djangoproject.com/en/3.1/topics/cache/#" rel="noopener ugc nofollow" target="_blank">指南，用于设置你的服务器访问自定义缓存</a>等等。</p><h1 id="a56b" class="kx ky iq bd kz la ma lc ld le mb lg lh li mc lk ll lm md lo lp lq me ls lt lu bi translated">缓存能帮你什么呢？</h1><p id="3835" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们从每个站点的缓存开始。每站点缓存是可以为您的服务器网站进行的最简单的一种缓存。如果您的服务器提供静态网页，这非常适合您。</p><p id="6138" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每个站点的缓存，在简单的用例场景中没有太多的SQL可言，所以我没有太多的东西来添加每个站点的缓存。然而，每站点缓存确实消除了从内存甚至从CDN加载文件的I/O工作负载，允许服务器从缓存加载所述网页。</p><p id="db03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，Django还提供了每视图缓存，这可以在SQL前端产生切实的节约。如果您的视图提供相对静态的数据，这对性能非常有利，尤其是在视图被频繁访问的情况下。此外，如果您的视图为每个登录用户提供一个定制结果，您可以包含一个<code class="fe km kn ko kp b">vary_on_headers</code>装饰器来缓存每个用户，尽管这有其缺点(对于常见的使用场景来说，这是非常多余的)。</p><p id="16e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，您可以访问Django的低级缓存来缓存响应，这是相当强大和直接适用的，足以探索…</p><h1 id="2ed5" class="kx ky iq bd kz la ma lc ld le mb lg lh li mc lk ll lm md lo lp lq me ls lt lu bi translated">说够了！是时候读一些代码了</h1><p id="6bc7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们看一下这个视图，它接受一个用户ID并返回关于用户的一些细节。</p><pre class="mf mg mh mi gt mj kp mk ml aw mm bi"><span id="9dea" class="mn ky iq kp b gy mo mp l mq mr">class UserSerializer(ModelSerializer):<br/>    class Meta:<br/>        model = User<br/>        fields = ('first_name', 'last_name', 'is_active', 'gender')<br/><br/>class UserView(APIView):<br/>    def get(self, request, user_id):<br/>        user_obj = User.objects.get(id=user_id)<br/>        serializer = UserSerializer(user_obj)<br/>        return Response(serializer.data, status=status.HTTP_200_OK)</span></pre><p id="2861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图非常简单、公开，不应该有太大变化。非常适合缓存！尽管我们可以使用per_view缓存来很好地处理这个问题，但我们将继续演示如何使用低级缓存来为自己缓存结果并将其返回。</p><p id="c94f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们所要做的就是记住以下几点来设置视图:</p><ol class=""><li id="7ccc" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">检查用户数据是否在缓存中。如果我们找不到它，我们就像平常一样收集数据，并保存到缓存中。</li><li id="7256" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">无论哪种方式，我们现在都应该有来自缓存或SQL的数据，所以我们正常地提供数据。</li></ol><p id="e499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果应该是这样的:</p><pre class="mf mg mh mi gt mj kp mk ml aw mm bi"><span id="bcd7" class="mn ky iq kp b gy mo mp l mq mr"># This is the default low-level cache.<br/>from django.core.cache import cache</span><span id="0a33" class="mn ky iq kp b gy ng mp l mq mr">class UserView(APIView):<br/>    def get(self, request, user_id):<br/>    # try to get cached data<br/>    user_data = cache.get(USER_CACHE_KEY.format(user_id))<br/>    if not user_data:<br/>         user_obj = User.objects.get(id=user_id)<br/>         serializer = UserSerializer(user_obj)<br/>         user_data = dict(serializer.data)<br/>         cache.set(USER_CACHE_KEY.format(user_id),<br/>                   user_data,<br/>                   timeout=TIMEOUT)</span><span id="a48c" class="mn ky iq kp b gy ng mp l mq mr">    return Response(user_data, status=status.HTTP_200_OK)</span></pre><p id="cf3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在测试服务器上尝试这样做，您会注意到在第一次调用端点之后，大部分SQL似乎都消失了。在这里，我会告诉你:</p><figure class="mf mg mh mi gt ni gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ca536d0f950608954983d71207b8a9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*J80PQojmxJdkpoyW70krjg.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">我们的第一个请求包含3个SQL查询，</figcaption></figure><p id="bf33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">API调用在第一次执行时需要3个查询，但在后续调用中:</p><figure class="mf mg mh mi gt ni gh gi paragraph-image"><div class="gh gi np"><img src="../Images/7330e33c89963b4aedaff47bef532654.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*uTTM6pOHOR4WHBAMRHrJGg.png"/></div></figure><p id="2a60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">零查询！这是因为查询结果是从缓存中提供的，而不是从数据库中收集的。当您频繁提供本质上是静态的数据时，这非常方便。</p></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><h1 id="fdf3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">伙计们，现在就这样吧！</h1><p id="e5f7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">感谢您阅读本文！</p><p id="13ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想知道更多关于如何使你的Django管理员可用的技巧，<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/speed-up-your-django-admin-by-removing-sql-counts-optimizing-django-part-2-f5e09da667c?source=friends_link&amp;sk=339d71c0b8a06c281d8b18a21c587d5b">看看这篇关于如何从你的Django变更列表中删除SQL计数的文章</a>。或者看看在Django 中使用串行化器时如何<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e">解决</a> <code class="fe km kn ko kp b"><a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e">n+1</a></code> <a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e">问题！</a></p></div></div>    
</body>
</html>