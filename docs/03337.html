<html>
<head>
<title>How to use Kubernetes Cron Jobs to Periodically Read the News</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kubernetes Cron Jobs定期阅读新闻</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-kubernetes-cron-jobs-to-periodically-read-the-news-8b3b4513f8b7?source=collection_archive---------2-----------------------#2020-05-04">https://levelup.gitconnected.com/how-to-use-kubernetes-cron-jobs-to-periodically-read-the-news-8b3b4513f8b7?source=collection_archive---------2-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4461" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看新闻的微服务。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c813a2acd39feb250b7f5e06bd8e9c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1PTg7bBdQMou2Y87iWByw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/StockSnap-894430/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2566677" rel="noopener ugc nofollow" target="_blank"> StockSnap </a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2566677" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="107e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大约二十年前，我发现我的股票经纪人查尔斯·施瓦布发布了一个API来获取报价。文档很少，据我所知，请求的数量没有限制。我不相信我必须使用我的在线凭证来访问它。所以我构建了一个小的Java应用程序，它可以读取API，并每五分钟在一个小窗口中给我提供报价，我可以把它放在屏幕的角落里。</p><p id="fda1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这样的数据现在已经被锁定了。Schwab API早已不复存在，大多数经纪公司都不会免费提供API(有传言称罗宾汉经纪公司有一个秘密API)。这并不是说没有任何公共API。我最近看了看，发现了几个提供免费服务但有收费限制的新闻来源。你也可以找到免费天气和有不同程度限制的股票的来源，但我们今天要看新闻。</p><p id="8dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将选择一个新闻API，编写一个小型Node.js微服务来读取它，并将其转储到MongoDB数据库中。我还将创建一个小的Java微服务来读取数据库，这样我就可以阅读新闻了。最后，我将把服务部署到Kubernetes。这将展示一些东西；首先，微服务可以用不同的表达语言来完成，这取决于它所做的工作类型。我不想为定期读取API的服务启动Java/Spring，所以我使用Node.js。但是我想为我的读取服务提供Java/Spring Boot附带的附加功能。还将演示在Node.js和Java中创建微服务的异同。</p><p id="3a0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可能会决定在这个想法的基础上，创建其他服务来筛选收集的数据或更好地呈现数据，但是对于本文，我将重点关注上面描述的两个服务。为了能够跟上，您应该对Java、JavaScript、Docker和Kubernetes有所精通。所有开发的代码将在我的<a class="ae ky" href="https://github.com/rkamradt" rel="noopener ugc nofollow" target="_blank"> GitHub </a>账户上可用。如果你想跳过软件开发，你可以直接进入本文的第三部分“在Kubernetes上运行一切”,它将使用我发布到<a class="ae ky" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>的图片。我打算把所有的事情都挤在一个周末，所以我最好停止喋喋不休，开始开发。</p><p id="9565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择的新闻API是NewsAPI.org。我需要通过注册从他们那里获得一个密钥。给他们你的电子邮件地址和密码来创建一个帐户，他们会给你一个密钥。将它保存在某个地方，因为您稍后将需要它来访问API。</p><h1 id="2392" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建新闻阅读器微服务</h1><p id="945c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Node.js最大的优点之一就是没有脚手架和样板文件。我们应该能够在三个主文件中完成这个应用程序，<code class="fe ms mt mu mv b">app.js</code>、<code class="fe ms mt mu mv b">package.json</code>和<code class="fe ms mt mu mv b">Dockerfile</code>。第一个文件是我们的应用程序代码，第二个文件描述了项目，第三个文件描述了如何将它构建成一个映像。还会有一些类似自述文件的文件，以及各种忽略文件，但应该就是这样了。我将在GitHub中创建一个名为<code class="fe ms mt mu mv b">newsreader</code>的新存储库，并从一个类似的Node.js项目中复制文件。</p><p id="5605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来看看我为<code class="fe ms mt mu mv b">app.js</code>想出了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<a class="ae ky" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>用于HTTP客户端和官方的MongoDB Node.js客户端。两者都使用基于承诺的API，可以使用async/await模式。这给人一种“做这做那”编程的自然感觉，而不是多层回调，但仍然保持非阻塞，这在单线程JavaScript中始终是关键。</p><p id="0195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没什么，读取NewsAPI URL，将响应插入MongoDB。大约50行我认为是不言自明的代码。大部分内容原封不动地复制自axios和MongoDB参考指南中的示例。应用程序代码应该是这样的，简单明了。</p><p id="578e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的年轻读者可能不熟悉这本书，但是Brian Kernigham和Rob Pike的书<em class="my">Unix编程环境(Prentice-Hall软件系列)</em>不仅仅是关于编程环境，而是一种哲学。其中一个核心理念是，一个程序应该做一件事，并把它做好。他们讨论了如何将<code class="fe ms mt mu mv b">cat</code>、<code class="fe ms mt mu mv b">ls</code>和<code class="fe ms mt mu mv b">grep</code>这样的命令组合在一个命令或脚本中，以执行更复杂的功能。我在微服务上看到了同样的理念。你的微服务要做好一件事，把它做好。</p><p id="bfc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以把它们打包成一个<code class="fe ms mt mu mv b">package.json</code>文件。这个文件应该描述我们正在生产的应用程序，包括所有的外部依赖。在我们的例子中，我们依赖于axios、MongoDB和NPM。当构建应用程序时，这个文件将被读取，外部包将被复制到<code class="fe ms mt mu mv b">node_modules</code>目录，在运行时可以在那里读取它们。下面是我想到的<code class="fe ms mt mu mv b">package.json</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以用Docker创建一个图像文件。<code class="fe ms mt mu mv b">Dockerfile</code>看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a4bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建Node.js应用程序的Docker映像有一个技巧。命令<code class="fe ms mt mu mv b">npm install</code>可能会创建二进制代码，或者使用特定于平台的模块。因此，与其从命令行构建然后只是复制<code class="fe ms mt mu mv b">node_modules</code>目录，还不如将<code class="fe ms mt mu mv b">package*.json</code>复制到映像中，然后在Docker构建中运行<code class="fe ms mt mu mv b">npm install</code>，以便它为Docker的平台Linux创建特定于平台的项目。事实上，您应该创建一个专门排除本地<code class="fe ms mt mu mv b">node_modules</code>目录的<code class="fe ms mt mu mv b">.dockerignore</code>文件，以防它存在。</p><p id="6294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，仅出于测试目的，我将创建一个<code class="fe ms mt mu mv b">docker-compose.yaml</code>文件。它将允许我快速构建和部署应用程序以及MongoDB，这样我就可以在将映像提交给Kubernetes之前看到它的运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试它，首先<code class="fe ms mt mu mv b">export</code>您从newapi.org获得的密钥，构建映像，启动MongoDB，然后运行应用程序</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="3dfd" class="nd lw it mv b gy ne nf l ng nh">export NEWSAPI_KEY=&lt;your-newsapi-key&gt;<br/>docker-compose build<br/>docker-compose up -d mongodb<br/>docker-compose up app</span></pre><p id="8013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到类似如下的日志:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="f92d" class="nd lw it mv b gy ne nf l ng nh">app_1      | Connecting to mongodb://admin:admin@mongodb:27017<br/>app_1      | Connected correctly to server<br/>app_1      | Reading https://newsapi.org/v2/top-headlines<br/>app_1      | Inserting news to server<br/>app_1      | Closing mongoDB connection<br/>app_1      | Ending</span></pre><p id="daf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须单独启动MongoDB，因为应用程序会在开始监听之前寻找它。通常，在输入命令启动应用程序之前，MongoDB已经启动了。但是它们必须在同一个<code class="fe ms mt mu mv b">docker-compose.yaml</code>文件中，这样它们才能共享一个内部网络。经过测试，可以用<code class="fe ms mt mu mv b">docker-compose down</code>停止MongoDB。</p><p id="d0a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何知道API被正确读取？在我最初的实现中，我将输出转储到日志中，因此我对连接正确返回感到满意。我清理了日志，因为我不想用我粘在数据库中的东西来填充它们。但是请随意记录您自己看到的回复。</p><p id="5c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到没有单元测试。随着我的服务变得越来越简单，我越来越少使用单元测试。像我们刚刚创建的这样的服务，几乎所有的代码都在库中，我希望它们都经过了很好的测试。因此，如果axios和MongoDB驱动程序有90%的代码覆盖率，那么整个应用程序也是如此。为拥有一个90%代码覆盖率的应用程序而自豪吧！一般来说，库应该进行单元测试，应用程序和服务应该在环境中运行时进行集成测试。</p><p id="973d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，把图片放到DockerHub或者你最喜欢的图片库中。如果你运行了<code class="fe ms mt mu mv b">docker-compose build</code>命令，它已经为你创建了一个图像。运行<code class="fe ms mt mu mv b">docker images</code>找到它，应该是你所在目录的名称和<code class="fe ms mt mu mv b">docker-compose.yaml</code>中服务的名称。我的情况是<code class="fe ms mt mu mv b">newsreader_app</code>。所以我可以贴标签:<code class="fe ms mt mu mv b">docker tag newsreader_app rlkamradt/newsreader</code>。然后我可以推:<code class="fe ms mt mu mv b">docker push rlkamradt/newsreader</code>。我稍后使用的所有图片都将引用<code class="fe ms mt mu mv b">rlkamradt/*</code>。如果您正在编码，您可以用您的存储库和存储库用户名替换<code class="fe ms mt mu mv b">rlkamradt</code>。</p><h1 id="301a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建readnews微服务</h1><p id="0b9b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Java read服务将使用基于<a class="ae ky" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">项目反应器</a>的Spring Boot和WebFlux HTTP控制器。我将引入日期参数，这样我就可以基于日期进行过滤，但除此之外，它只会从MongoDB中转储数据，这只是来自新闻API的原始数据。</p><p id="ce4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要拿出我的老朋友<a class="ae ky" href="https://netbeans.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache NetBeans </a>来做开发。我更喜欢NetBeans，因为它与Maven紧密集成。我更喜欢Maven，因为如果你只是从Java构建jar，它非常简洁。如果你能原谅丑陋的XML。幸运的是，使用NetBeans来创建和修改您的项目，您不必过多地处理XML。你可以使用任何你觉得舒服的IDE，但是当我使用NetBeans完成某件事情时，你可能必须弄清楚如何应用我正在做的事情。</p><p id="7bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开NetBeans后，从“文件”菜单中选择“新建项目”。这将把你带到一个“新项目”对话框。在那里，我选择“Java with Maven/Java Application ”,单击“next ”,输入一个项目名“readnews ”,它会计算出其余字段的合理值。到目前为止，一切顺利，还没有接触过XML。它创建了填充了几项的<code class="fe ms mt mu mv b">pom.xml</code>文件，并创建了Maven使用的目录结构。</p><p id="dd15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用Spring Boot作为这个应用程序的平台。因此，我要做的第一件事是将该模块的父模块设置为Spring Boot启动器父模块。这将使所有版本协调一致，使它们能够很好地协同工作。不幸的是，NetBeans没有GUI工具来设置模块的父模块，这意味着我必须使用XML。打开pom.xml(在NetBeans中，它隐藏在“项目文件”文件夹中)并添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f3d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导致您的pom.xml从Spring parent继承所有内容，这主要是依赖关系管理，因此您不必填写您作为依赖关系列出的任何内容的版本。因为这只是依赖关系管理，它不会引入任何依赖关系——您仍然可以进行挑选。但是你会知道你所有的依赖都在一个版本上，它们应该一起工作。</p><p id="5701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经打开了<code class="fe ms mt mu mv b">pom.xml</code>文件，我们可以添加一些依赖项，以及Spring Boot运行所需的其他项目。以下是依赖关系:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d5f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以添加的另一件事是一些构建插件。Spring Boot需要一个插件来制作一个有阴影的罐子。我们还将使用插件来创建Docker图像，并从Git获取信息以在服务中使用。这是构建部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8d9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不知道你是否真的需要<code class="fe ms mt mu mv b">spring-boot-maven-plugin</code>,因为<code class="fe ms mt mu mv b">jib</code>插件用原始片段而不是阴影罐子构建图像。但是我会把它放在那里，以防万一我们想把服务作为测试用的jar来运行。</p><p id="6b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Google 的<code class="fe ms mt mu mv b"><a class="ae ky" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank">jib</a></code> <a class="ae ky" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank">插件创建了一个Docker镜像，没有使用Docker(也没有<code class="fe ms mt mu mv b">Dockerfile</code>)。如果您打算在容器中进行构建，这一点很重要，就像在Kubernetes中运行的Jenkins管道一样，这样您就不必处理docker-in-docker。它还为依赖jar、应用程序类和资源文件创建了单独的层。这意味着如果你不改变你的依赖关系，你不必构建第一层，这一层几乎总是最大的。这使得后续构建速度更快。</a></p><p id="ab95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b"><a class="ae ky" href="https://github.com/git-commit-id/git-commit-id-maven-plugin" rel="noopener ugc nofollow" target="_blank">git-commit-id-plugin</a></code>获取关于构建和最后一次提交的信息，并将其放入Spring Boot知道的属性文件中。稍后我们会看到更多。</p><p id="2844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常完整的<code class="fe ms mt mu mv b">pom.xml</code>，它不到一百行。在我看来，从Java代码构建jar文件(现在是图像文件)没有比Maven更好的工具了。诚然，XML有点难看，但它也很容易被其他工具解析和使用来收集信息。当NetBeans创建Maven项目时，它没有其他配置文件。一切都储存在<code class="fe ms mt mu mv b">pom.xml</code>里。它自动知道如何插入依赖关系，以及如何运行目标。它创建了一个<code class="fe ms mt mu mv b">nbaction.xml</code>文件来存储不同的Maven目标和参数，比如在IDE中运行、调试或分析时使用的主类文件。但是它不像其他ide那样必须创建自己的项目文件，然后努力确保它们与<code class="fe ms mt mu mv b">pom.xml</code>同步，而后者应该是构建项目的真实来源。</p><p id="1b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看代码。因为这个微服务做的不多，所以只有几块。这是主控制器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中的主要部分是第17–21行:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="5ad0" class="nd lw it mv b gy ne nf l ng nh">return newsReactiveRepository<br/>                .findAll()<br/>                .flatMap(r -&gt; Flux.fromIterable(r.getArticles()))<br/>                .filter(r -&gt; filterByDate(r, from, to))<br/>                .limitRequest(actualLimit);</span></pre><p id="d237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">newsReactiveRepositoy</code>是MongoDB集合的主要访问点，我不小心将其命名为<code class="fe ms mt mu mv b">inserts</code>，因为这是我在编写Node.js部分时复制的示例中集合的名称。好吧，就叫它<code class="fe ms mt mu mv b">inserts</code>我会把它留在那里让我保持谦逊。集合名是从类名中推断出来的，所以为了访问<code class="fe ms mt mu mv b">inserts</code>集合，我们使用了一个<code class="fe ms mt mu mv b">Inserts</code>类，我将在后面描述。</p><p id="7d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">newsReactiveRepository.findAll()</code>返回一个<code class="fe ms mt mu mv b">Flux&lt;Inserts&gt;</code>。这是<a class="ae ky" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">项目反应器</a>的一部分，对于那些熟悉Java流的人来说，你会发现<code class="fe ms mt mu mv b">Flux</code>有点类似于<code class="fe ms mt mu mv b">Stream</code>。你有一套类似的方法，比如<code class="fe ms mt mu mv b">map</code>和<code class="fe ms mt mu mv b">filter</code>。它的作用是允许你设计一个分解成函数的流程，然后这些函数由调度程序执行。</p><p id="1048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键是，没有一个函数可以阻塞，因此调度程序可以预期，如果它调用一个函数，它将几乎立即返回，调度程序可以调度其他函数。这样，整个流程和所有请求处理都可以在单个线程(或者任意数量的小线程)上进行。事实证明线程是相对昂贵的，每个请求一个线程，这是Java中的传统路线，在处理大量请求时会成为一个很大的瓶颈。尽管Node.js是单线程的，但这种非阻塞的特性使得它具有令人惊讶的良好性能。现在同样的概念在Java中很容易实现。</p><p id="c7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段显示了我们正在对从MongoDB返回的<code class="fe ms mt mu mv b">Inserts</code>对象流做三件事。首先，我们将它分成不同的文章，因为新闻阅读器服务将数据作为单个对象与文章集合一起插入数据库。其次，我们根据URL的<code class="fe ms mt mu mv b">from</code>和<code class="fe ms mt mu mv b">to</code>参数传递的日期进行过滤。最后，我们将根据最少的<code class="fe ms mt mu mv b">limit</code>参数限制返回的文章数量，如果没有限制参数，则返回1000篇文章。</p><p id="2482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应该注意到这个订单的一个问题；因为我们是最后限制，如果过滤器丢弃了所有东西(比如过去有一个<code class="fe ms mt mu mv b">to</code>参数),我们将扫描整个<code class="fe ms mt mu mv b">inserts</code>集合并且不返回任何东西。有许多方法可以解决这个问题，但是由于我们的数据集现在只有几个项目，我将把它推迟到以后。</p><p id="5150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用Lombok库创建了一个名为<code class="fe ms mt mu mv b">Inserts</code>的bean类。Lombok产生所有需要的getters和setters、constructors和builders。它在类前使用一个注释<code class="fe ms mt mu mv b">@Data</code>,并通过Maven magic自动生成带有已填充类的文件。任何严肃的Java程序员都必须使用的库。上课来了</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="63b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在插入过程中没有指定一个<code class="fe ms mt mu mv b">id</code>，所以<code class="fe ms mt mu mv b">id</code>字段是由MongoDB生成的。从数据库中读取行需要一个<code class="fe ms mt mu mv b">Repository</code>接口，Spring会在运行时为您填写这个接口。这就是你所需要的:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="6628" class="nd lw it mv b gy ne nf l ng nh">@Repository<br/>public interface InsertsReactiveRepository extends<br/>            ReactiveMongoRepository&lt;Inserts, String&gt; { }</span></pre><p id="68dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，您只需要一些样板Spring类，就有了一个完整的应用程序。你可以在这里找到所有的源代码。</p><p id="db43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我创建了一个<code class="fe ms mt mu mv b">docker-compose.yaml</code>用于测试目的。它会打开MongoDB和我们的新闻阅读器应用程序，只是这次新闻阅读器应用程序是从现在存储在DockerHub中的图像中提取的。这里是新的<code class="fe ms mt mu mv b">docker-compose.yaml</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a2ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要额外的构建步骤，因为我们正在使用之前创建的映像。所以我们只需要这两步</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="c92a" class="nd lw it mv b gy ne nf l ng nh">docker-compose up -d mongodb<br/>docker-compose up app</span></pre><p id="46e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行启动MongoDB，最后一行将在数据库中插入一行。</p><p id="4542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库启动后，您可以从命令行作为jar运行应用程序，也可以从您的IDE运行应用程序。然后，您可以使用Postman点击URL <code class="fe ms mt mu mv b">http://localhost:8080/v1/headlines?limit=50&amp;to=2021-01-01T00:00:00Z</code>，并将<code class="fe ms mt mu mv b">Accept</code>头设置为<code class="fe ms mt mu mv b">text/event-stream</code>(这是我们的控制器设置为产生的唯一内容)。你应该看到一堆新闻吐槽。您也可以在浏览器中查看它。只是为了好玩，你也可以浏览到<code class="fe ms mt mu mv b">http://localhost:8080/actuator/health</code>端点和<code class="fe ms mt mu mv b">http://localhost:8080/actuator/info</code>端点。您可以从最后一个端点看到我们如何使用来自<code class="fe ms mt mu mv b">git-commit-id-plugin</code>的信息。</p><p id="355e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成测试后，运行<code class="fe ms mt mu mv b">docker-compose down</code>来停止MongoDB。</p><p id="cda1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要构建映像，您可以运行<code class="fe ms mt mu mv b">mvn</code>命令:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="1b8f" class="nd lw it mv b gy ne nf l ng nh">mvn clean install jib:build</span></pre><p id="4eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把你的新镜像安装到DockerHub。</p><h1 id="d99b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在Kubernetes上运行一切</h1><p id="afe6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">本文的其余部分将放在主主机上，我使用主主机通过<code class="fe ms mt mu mv b">kubectl</code>命令访问Kubernetes。我将为描述文件创建一个新的GitHub存储库，我将用它来将所有这些部署到Kubernetes。您可能会认为我喜欢创建这么多小的存储库，但是这是有目的的。您希望您的微服务彼此完全独立，最好的方法是创建单独的存储库。您还希望您的微服务独立于它们的部署方式，因此需要一个新的部署脚本存储库。明天，一种新的容器编排服务可能会席卷全球，并且您会很高兴部署文件没有包含在代码库中。在主主机上克隆新的空存储库，并将<code class="fe ms mt mu mv b">cd</code>复制到新目录中。</p><p id="da48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先需要在Kubernetes上运行一个MongoDB实例。如果你一直在关注我，你可能读过我的系列文章<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-4691283e3995" rel="noopener"> Kubernetes From Scratch </a>，其中我构建了一个Kubernetes系统，而没有使用像minikube或microk8s这样的预打包设置。在我的文章<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-part-2-e30b48f7ca6b" rel="noopener"> Kubernetes From Scratch第二部分</a>中，我提到了一个MongoDB数据库，所以如果您遵循这个方法，您已经有了一个MongoDB的实例。如果没有，我将带您完成一个非常基本的MongoDB设置。</p><p id="8d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们的许多部署都是在<code class="fe ms mt mu mv b">default</code>名称空间中进行的。这是一个不好的习惯，我们真的应该创建名称空间来给自己一点隔离，并组织我们的微服务系统。在一个经过深思熟虑的系统中，我们将为名称空间以及如何组织它们创建一个计划，按项目、按环境或两者都按。但出于本文的目的，我将只为微服务及其所需的外部服务创建一个。我将为newreader/readnews创建一个名为<code class="fe ms mt mu mv b">nr</code>的。我喜欢短的名称空间名称，因为除非您设置一个指定名称空间的上下文，否则您必须在每个<code class="fe ms mt mu mv b">kubectl</code>命令后面添加<code class="fe ms mt mu mv b">-n &lt;namespacename&gt;</code>。</p><p id="3dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe ms mt mu mv b">namespace.yaml</code>的文件，并输入以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个名称空间，我们必须创建一个密码，MongoDB和访问它的应用程序可以使用它作为根用户名/密码。要创建它，请运行以下命令:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="2dc4" class="nd lw it mv b gy ne nf l ng nh">kubectl create secret generic mongo-secret -n nr \<br/>    --from-literal=username=mongo \<br/>    --from-literal=password=ognom</span></pre><p id="0a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保在你的生产系统中使用更好的密码，哈哈。</p><p id="b720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您阅读了我的文章Kubernetes From Scratch Part II，那么您已经有了一个名为<code class="fe ms mt mu mv b">gluster-pv</code>的持久卷。但是我们需要在新的名称空间下创建一个新的。如果您不明白，您可以跳过这一部分，我们将为您的MongoDB使用临时存储。删除<code class="fe ms mt mu mv b">PersistentVolume</code>和<code class="fe ms mt mu mv b">PersistentVolumeClaim</code>以及<code class="fe ms mt mu mv b">Endpoints</code>，如果它们存在于上一篇文章中。我们将在<code class="fe ms mt mu mv b">nr</code>名称空间中重新创建它们，但略有不同。假设您有一个GlusterFS集群在运行(参见我的文章<a class="ae ky" href="https://medium.com/better-programming/build-your-own-in-home-cloud-storage-1aa74b5c6397" rel="noopener">构建您自己的家庭云存储</a>)，下面是<code class="fe ms mt mu mv b">endpoints.yaml</code>、<code class="fe ms mt mu mv b">pv.yaml</code>和<code class="fe ms mt mu mv b">pvc.yaml</code>的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ms mt mu mv b">endpoints.yaml</code>中，确保将IP地址更改为GlusterFS集群的IP地址。将它们按顺序应用到我们的新名称空间中:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="fc5a" class="nd lw it mv b gy ne nf l ng nh">kubectl apply -f endpoints.yaml -n nr<br/>kubectl apply -f pv.yaml -n nr<br/>kubectl apply -f pvc.yaml -n nr </span></pre><p id="1a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果您没有GlusterFS集群，您仍然可以稍加修改继续。</p><p id="bb90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用下面的<code class="fe ms mt mu mv b">mongodb.yaml</code>部署一个单节点MongoDB实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b2ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有GlusterFS并跳过了上述关于设置永久卷声明的说明，您可以将<code class="fe ms mt mu mv b">spec.template.spec.volumes</code>从<code class="fe ms mt mu mv b">persistenVolumeClaim</code>更改为<code class="fe ms mt mu mv b">emptyDir: {}</code>并移除<code class="fe ms mt mu mv b">claimName</code>。<code class="fe ms mt mu mv b">emptyDir</code>卷只是pod空间中的一个空目录。如果pod消失了，卷及其所有数据也会消失。</p><p id="ddd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令应用名称空间为<code class="fe ms mt mu mv b">nr</code>的<code class="fe ms mt mu mv b">mongodb.yaml</code></p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="edef" class="nd lw it mv b gy ne nf l ng nh">kubectl apply -f mongodb.yaml -n nr</span></pre><p id="95b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行<code class="fe ms mt mu mv b">kubectl get all -n nr</code>以查看一切都在运行:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="e25b" class="nd lw it mv b gy ne nf l ng nh">rkamradt@beast:~/news-deploy$ kubectl get all -n nr<br/>NAME            READY   STATUS    RESTARTS   AGE<br/>pod/mongodb-0   1/1     Running   0          9s</span><span id="9291" class="nd lw it mv b gy ni nf l ng nh">NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE<br/>service/glusterfs-cluster   ClusterIP   10.107.89.123   &lt;none&gt;        1/TCP       131m<br/>service/mongodb             ClusterIP   None            &lt;none&gt;        27017/TCP   9s</span><span id="89c0" class="nd lw it mv b gy ni nf l ng nh">NAME                       READY   AGE<br/>statefulset.apps/mongodb   1/1     9s</span></pre><p id="3f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了拥有多个副本，需要一个更加动态的卷供应系统，这就要求我们的存储解决方案更加复杂。如果您通过云提供商运行，他们应该有动态卷供应，并且可以添加更多副本。但是我们会处理一个复制品。</p><p id="b359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MongoDB服务是“无头”服务，因为它没有ClusterIP。它为您做的是为每个pod创建DNS名称，因为所有的pod都需要可访问。这对我们来说并不重要，因为我们只有一个副本集。单个pod的DNS名称应该是<code class="fe ms mt mu mv b">mongodb-0.mongodb</code></p><p id="c575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要为<code class="fe ms mt mu mv b">newsreader</code>服务创建一个<code class="fe ms mt mu mv b">CronJob</code>，这样它将收集整点的所有新闻。但是首先，我将把它部署为一个裸pod来进行测试。创建一个名为<code class="fe ms mt mu mv b">newsreader-pod.yaml</code>的文件，并添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="764e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在部署它之前，我们需要为API密钥创建秘密。</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="2f06" class="nd lw it mv b gy ne nf l ng nh">kubectl create secret generic newsapi-key -n nr \<br/>    --from-literal=key=&lt;your-newsapi-key&gt;</span></pre><p id="b092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用以下工具部署pod:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="03ce" class="nd lw it mv b gy ne nf l ng nh">kubectl apply -f newsreader-pod.yaml -n nr</span></pre><p id="ff0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后(假设它起作用了，在几个运行/编辑周期后它对我起作用了)，您可以检查日志:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="4e80" class="nd lw it mv b gy ne nf l ng nh">rkamradt@beast:~/news-deploy$ kubectl logs pod/newsreader-pod -n nr<br/>Connecting to mongodb://mongo:ognom@mongodb-0.mongodb:27017<br/>Connected correctly to server<br/>Reading <a class="ae ky" href="https://newsapi.org/v2/top-headlines" rel="noopener ugc nofollow" target="_blank">https://newsapi.org/v2/top-headlines</a><br/>Inserting news to server<br/>Closing mongoDB connection<br/>Ending</span></pre><p id="4904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">糟糕，这指出了一个问题—密码在日志中是可见的。我将不得不回到<code class="fe ms mt mu mv b">newsreader</code>微服务，并纠正这一点。但除此之外，它非常有效！注意，pod名称直接取自<code class="fe ms mt mu mv b">metadata.name</code>字段，没有附加任何随机字符串。我们可以用<code class="fe ms mt mu mv b">kubectl delete -f newsreader-pod.yaml -n nr</code>移除吊舱。</p><p id="fe11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建文件<code class="fe ms mt mu mv b">newsreader-cronjob.yaml</code>，其中大部分来自于<code class="fe ms mt mu mv b">newsreader-pod.yaml</code>。以下是我想到的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在整点运行作业。然后以正常方式部署它:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="1002" class="nd lw it mv b gy ne nf l ng nh">kubectl apply -f newsreader-cronjob.yaml -n nr</span></pre><p id="4b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到正在运行的内容:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="b0b5" class="nd lw it mv b gy ne nf l ng nh">rkamradt@beast:~/news-deploy$ kubectl get all -n nr<br/>NAME            READY   STATUS    RESTARTS   AGE<br/>pod/mongodb-0   1/1     Running   0          55m</span><span id="b3ed" class="nd lw it mv b gy ni nf l ng nh">NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE<br/>service/glusterfs-cluster   ClusterIP   10.107.89.123   &lt;none&gt;        1/TCP       3h7m<br/>service/mongodb             ClusterIP   None            &lt;none&gt;        27017/TCP   55m</span><span id="5f7e" class="nd lw it mv b gy ni nf l ng nh">NAME                       READY   AGE<br/>statefulset.apps/mongodb   1/1     55m</span><span id="94b4" class="nd lw it mv b gy ni nf l ng nh">NAME                               SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE<br/>cronjob.batch/newsreader-cronjob   0 * * * *   False     0        &lt;none&gt;          11s</span></pre><p id="ee74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还没有创建任何工作或pod，我们必须等到整点。默认情况下,<code class="fe ms mt mu mv b">CronJob</code>会保留最近三个成功的作业和最近一个失败的作业，以便您可以查看日志。</p><p id="72d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要部署<code class="fe ms mt mu mv b">readnews</code>服务。这应该很简单，除了我们还需要为它创建一个<code class="fe ms mt mu mv b">Ingress</code>。我们将从创建一个<code class="fe ms mt mu mv b">readnews.yaml</code>开始，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我本来可以添加一个健康检查，因为该服务有健康检查端点，但是我将把它留给另一篇文章。我们可以通过端口转发来测试它:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="918a" class="nd lw it mv b gy ne nf l ng nh">kubectl port-forward service/readnews-service 8080:8080 -n nr</span></pre><p id="fa0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在另一个终端窗口中(也是在主机上),看看是否可以访问它</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="1602" class="nd lw it mv b gy ne nf l ng nh">curl http://localhost:8080/v1/headlines</span></pre><p id="7656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果作业已经运行过一次，您应该会看到一串标题流过。如果看不到任何内容，请检查作业是否已运行。</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="d2d9" class="nd lw it mv b gy ne nf l ng nh">rkamradt@beast:~/news-deploy$ kubectl get all -n nr<br/>NAME                                       READY   STATUS      RESTARTS   AGE<br/>pod/mongodb-0                              1/1     Running     0          140m<br/>pod/newsreader-cronjob-1588525200-w9j9s    0/1     Completed   0          56m<br/>pod/readnews-deployment-84774799cf-44nzx   1/1     Running     0          12m</span><span id="4e69" class="nd lw it mv b gy ni nf l ng nh">NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE<br/>service/glusterfs-cluster   ClusterIP   10.107.89.123   &lt;none&gt;        1/TCP       4h31m<br/>service/mongodb             ClusterIP   None            &lt;none&gt;        27017/TCP   140m<br/>service/readnews-service    ClusterIP   10.99.135.171   &lt;none&gt;        8080/TCP    61m</span><span id="8c55" class="nd lw it mv b gy ni nf l ng nh">NAME                                  READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/readnews-deployment   1/1     1            1           61m</span><span id="f4c5" class="nd lw it mv b gy ni nf l ng nh">NAME                                             DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/readnews-deployment-84774799cf   1         1         1       12m<br/>replicaset.apps/readnews-deployment-d886f5f75    0         0         0       61m</span><span id="2fa4" class="nd lw it mv b gy ni nf l ng nh">NAME                       READY   AGE<br/>statefulset.apps/mongodb   1/1     140m</span><span id="b2ca" class="nd lw it mv b gy ni nf l ng nh">NAME                                      COMPLETIONS   DURATION   AGE<br/>job.batch/newsreader-cronjob-1588525200   1/1           11s        56m</span><span id="64b5" class="nd lw it mv b gy ni nf l ng nh">NAME                               SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE<br/>cronjob.batch/newsreader-cronjob   0 * * * *   False     0        56m             84m</span></pre><p id="0af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该看到带有1/1完成的<code class="fe ms mt mu mv b">job.batch</code>。如果没有，您将不得不等待它运行的整点。</p><p id="46ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个<code class="fe ms mt mu mv b">Ingress</code>，您必须为新的名称空间创建一个<code class="fe ms mt mu mv b">Issuer</code>。如果您阅读了我的文章<a class="ae ky" href="https://medium.com/better-programming/how-to-expose-your-services-with-kubernetes-ingress-7f34eb6c9b5a" rel="noopener">如何使用Kubernetes Ingress </a>来公开您的服务，您将已经拥有一个证书和一个私钥。如果没有，并且您不想回去阅读，您可以跳过创建<code class="fe ms mt mu mv b">Issuer</code>，而<code class="fe ms mt mu mv b">Ingress</code>将为您创建一个假证书。</p><p id="2df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您仍然有文件<code class="fe ms mt mu mv b">ca.key</code>、<code class="fe ms mt mu mv b">ca.unencrypted.key</code>和<code class="fe ms mt mu mv b">ca.crt</code>，您可以将证书密钥对添加到我们新名称空间中的一个秘密中:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="a9ab" class="nd lw it mv b gy ne nf l ng nh">kubectl create secret tls ca-key-pair -n nr \<br/>    --cert=ca.crt \<br/>    --key=ca.unencrypted.key</span></pre><p id="3c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用文件<code class="fe ms mt mu mv b">issuer.yaml</code>为这个名称空间创建一个<code class="fe ms mt mu mv b">Issuer</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将其应用于新的名称空间</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="1945" class="nd lw it mv b gy ne nf l ng nh">kubectl apply -f issuer.yaml -n nr</span></pre><p id="1b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在用名为<code class="fe ms mt mu mv b">vhosts-ingress.yaml</code>的文件创建一个<code class="fe ms mt mu mv b">Ingress</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c5fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个名为<code class="fe ms mt mu mv b">readnews.local</code>的虚拟主机，并将所有请求转发给readnews服务。它还会为新的主机名生成一个证书，这样你的浏览器就不会变得古怪。将其添加到命名空间中:</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="703e" class="nd lw it mv b gy ne nf l ng nh">kubectl apply -f vhost-ingress.yaml -n nr</span></pre><p id="5c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够在您的浏览器上看到它，您应该在<code class="fe ms mt mu mv b">/etc/hosts</code>文件中添加主主机的同义词(我的名为beast ):</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="bae5" class="nd lw it mv b gy ne nf l ng nh">192.168.0.225 beast readnews.local</span></pre><p id="a237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你应该可以在浏览器中查看http://readnews.local/v1/headlines的网址了。瞧啊。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/e8b5f822b6d68718d28101381ad557ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HmSgwuf3UlD3_r2YasY_Kg.png"/></div></div></figure><p id="4a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你厌倦打字了吗？您可以将名称空间添加到您的上下文中，使其成为默认名称空间。</p><pre class="kj kk kl km gt mz mv na nb aw nc bi"><span id="a8d8" class="nd lw it mv b gy ne nf l ng nh">kubectl config set-context --current --namespace=nr</span></pre><p id="6672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈哈，你不希望我一开始就告诉你吗？有时有一个默认的名称空间是很好的，特别是当名称空间特定于您的工作角色时。但是其他时候，明确地命名它是好的，这是一个好习惯。</p><p id="d48f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我又浪费了一个周末去做一个毫无用处的应用程序。但我学到了很多新技能，磨练了一些老技能，当我终于有所收获时，我仍然会兴奋不已。我想这就是我三十多年后仍在这个行业的原因。我希望你和我一样喜欢学习，这会让你在计算机世界里走得更远。谢谢你又陪我度过了一个周末。你可以在这里找到这篇文章的代码<a class="ae ky" href="https://github.com/rkamradt/newsreader/tree/v1.1" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到<a class="ae ky" href="https://github.com/rkamradt/readnews/tree/v1.0" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到<a class="ae ky" href="https://github.com/rkamradt/news-deploy/tree/v1.0" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>