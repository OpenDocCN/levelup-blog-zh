<html>
<head>
<title>How to Create AWS Cloud Native CI CD Setup for Serverless Lambda Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为无服务器Lambda函数创建AWS云本机CI CD设置</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-aws-cloud-native-ci-cd-pipeline-for-lambda-acdf6f7fccd?source=collection_archive---------7-----------------------#2022-09-06">https://levelup.gitconnected.com/how-to-create-aws-cloud-native-ci-cd-pipeline-for-lambda-acdf6f7fccd?source=collection_archive---------7-----------------------#2022-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a3056e34bc30dc6b00048b7cfa6c9829.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*nrrCYdOuI3jUXFna6WI-Cw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">缩略图*叹息*的强制标志</figcaption></figure><p id="1aed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AWS Lambda是一种无服务器的事件驱动计算服务，允许您运行代码，而无需担心基础设施管理或供应。作为功能即服务(FaaS)的一部分，它的按使用付费模式提供了无限的可能性，尤其是在AWS环境中。</p><p id="924b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，没有明确的方法为AWS Lambda这样的无服务器设置设置CI/CD解决方案。在本文中，我们的目标是使用原生AWS服务:Codepipeline和Cloudformation为AWS Lambda等无服务器服务创建CI/CD解决方案。类似的步骤也可以复制到GCP和Azure。</p><p id="7a92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将首先看一下关于我们正在做什么的一些理论。然后，我们将创建适当的代码和设置。然后，我们将创建管道，最后，我们将端到端地测试管道。</p><h1 id="1f8d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤0:我们实际在做什么？</h1><p id="b857" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">请转到本步骤的末尾查看简明摘要。请继续阅读我们做这些事情背后的详细原因:)。</p><p id="e06b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何CI/CD设置，如AWS Codepipeline、Jenkins等。由3个主要部分组成:</p><ul class=""><li id="6597" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">我们提交代码和维护回购的源代码仓库。这也将触发我们的渠道。例如:代码提交，饭桶。</li><li id="6bde" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">一个构建解决方案，它根据提供的指令从repo构建源代码。也叫CI。代码构建，詹金斯。</li><li id="ad7d" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">部署构建代码的部署解决方案。它使用某种部署代理。也称为CD。通常，它是CI解决方案的一部分。例如:代码部署，詹金斯。</li></ul><p id="0d4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个解决方案中，对于源代码回购，我们将使用CodeCommit。对于构建解决方案，我们将使用CodeBuild。最后，对于部署解决方案，我们将使用带有Cloudformation的CodeDeployment作为部署代理。</p><p id="acd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么是云形成？这是因为Lambda的部署方式。根据官方的<a class="ae mn" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-deploy-functions.html" rel="noopener ugc nofollow" target="_blank">文档</a>，你可以通过上传一个zip文件档案，或者通过创建和上传一个容器映像来将代码部署到你的Lambda函数中。</p><p id="c1b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您使用Lambda控制台或工具包创作函数时，Lambda会自动为您的代码创建一个. zip文件存档。</p><p id="5d32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您使用Lambda API、命令行工具或AWS SDKs创建函数时，您必须创建一个部署包。如果函数使用编译语言，或者要向函数添加依赖项，还必须创建部署包。要部署您的函数代码，您可以从亚马逊简单存储服务(亚马逊S3)或您的本地机器上传部署包。</p><p id="d52d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的可以引用一个Python包构建的例子<a class="ae mn" href="https://docs.aws.amazon.com/lambda/latest/dg/python-package.html" rel="noopener ugc nofollow" target="_blank">。因此，很明显会创建一个包。所以，我们可以使用Cloudformation打包并上传到Lambda。</a></p><p id="9347" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果你想更新你现有的Lambda函数呢？如果现有功能是使用Cloudformation或无服务器应用程序模型(SAM)模板创建的，您可以将构建步骤放在CodeBuild中。然而，如果它是使用Lambda控制台而不是使用任何包来完成的，您将需要使用<a class="ae mn" href="https://docs.aws.amazon.com/cli/latest/reference/lambda/update-function-code.html" rel="noopener ugc nofollow" target="_blank"> update-function-code </a> API调用来更新Lambda函数的源代码(在构建包之后)。</p><p id="4263" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，综上所述，建议使用Cloudformation或SAM来部署Lambda功能。否则，在第一次创建函数时，您将需要一个<a class="ae mn" href="https://docs.aws.amazon.com/cli/latest/reference/lambda/create-function.html" rel="noopener ugc nofollow" target="_blank"> create-function </a> API调用，然后在随后的更新中更新函数代码。通过使用Cloudformation，您可以简单地定义包，Cloudformation会完成剩下的工作。</p><p id="b310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果您希望节省成本(和复杂性)，请使用控制台或AWS CLI首次创建您的函数，然后在构建文件中使用以下命令进行后续更新:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="16ba" class="mx kx iq mt b gy my mz l na nb">aws lambda update-function-code --function-name MyLambdaFunction --zip-file fileb://my-deployment-package.zip</span></pre><p id="5ef6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">所以长话短说(TL；CodeCommit将存储我们的代码。CodeBuild将创建zip包并构建Cloudformation工件。CodeDeploy将部署这个云形成人工制品。所有这些步骤都将使用CodePipeline捆绑在一起。现在，随着理论的方式，让我们建立！</strong></p><h1 id="4aa8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤1:完成先决条件</h1><p id="8fdb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从前面的步骤可以清楚地看出，我们需要以下三样东西:</p><ul class=""><li id="6de7" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">λ码(咄！).</li><li id="db60" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">IAM授权Cloudformation访问Lambda。</li><li id="3ca0" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">部署Lambda代码的Cloudformation模板。</li><li id="6c7b" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">Buildspec.yaml文件来指导CodeBuild构建和打包我们的Lambda代码。</li></ul><p id="8ee1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们逐一完成:</p><h2 id="cd91" class="mx kx iq bd ky nc nd dn lc ne nf dp lg kj ng nh lk kn ni nj lo kr nk nl ls nm bi translated">a)λ代码:</h2><p id="4db1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对于代码部分，我们将使用默认的Python代码，没有从AWS文档<a class="ae mn" href="https://docs.aws.amazon.com/lambda/latest/dg/python-package.html#python-package-create-package-with-dependency" rel="noopener ugc nofollow" target="_blank">引用的依赖项，这里是</a>。然而，这个演示也适用于任何其他代码，包括依赖关系。仅包含依赖项(如请求包等。)，您需要对文件夹的结构更加小心，以创建正确的。zip文件。否则你会得到导入错误。</p><p id="85d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不需要增加这篇文章的长度。按照这里提到的所有步骤<a class="ae mn" href="https://docs.aws.amazon.com/lambda/latest/dg/python-package.html#python-package-create-package-no-dependency" rel="noopener ugc nofollow" target="_blank">创建。部署包的zip文件。我在这个演示中使用了相同的文件夹名称和相同的代码。仅供参考，我们这个演示的包名是:<em class="nn">my-deployment-package . zip</em>。</a></p><h2 id="68c2" class="mx kx iq bd ky nc nd dn lc ne nf dp lg kj ng nh lk kn ni nj lo kr nk nl ls nm bi translated">b) IAM授权Cloudformation访问Lambda:</h2><p id="55ba" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">由于Cloudformation将直接访问Lambda并进行更改，我们需要创建适当的角色来允许Cloudformation访问。</p><p id="df85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进入IAM-&gt;Roles-&gt;Create Role，选择Cloudformation作为可信实体。在策略中，附加:<em class="nn"> AWSLambdaExecute </em>托管策略。现在，单击“<em class="nn">创建策略</em>，并创建以下自定义策略:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dbdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将此自定义策略也附加到您在上一步中的角色。</p><p id="49fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定一个合适的名称并创建这个角色。记住这个名字，因为我们以后会用到它。</p><h2 id="d045" class="mx kx iq bd ky nc nd dn lc ne nf dp lg kj ng nh lk kn ni nj lo kr nk nl ls nm bi translated">c)部署Lambda代码的Cloudformation模板</h2><p id="8748" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在有两种使用Cloudformation定义Lambda函数的方法。首先是通过使用<code class="fe nq nr ns mt b"><a class="ae mn" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html" rel="noopener ugc nofollow" target="_blank">AWS::Lambda::Function</a></code> <em class="nn">。</em>其次是通过使用<code class="fe nq nr ns mt b"><a class="ae mn" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-function.html" rel="noopener ugc nofollow" target="_blank">AWS::Serverless::Function</a></code>，它在内部使用SAM模板。</p><p id="0b8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以使用其中任何一个。对于本教程，我选择了<code class="fe nq nr ns mt b">AWS::Serverless::Function</code>,仅仅是因为它不太复杂，还因为如果将来我们想扩展到SAM模板，我们不需要重新定义模板。</p><p id="f5e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地说明缩放部分，请注意我们将使用<code class="fe nq nr ns mt b">AWS::Serverless </code> transform <em class="nn"> </em>宏。用AWS自己的<a class="ae mn" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-aws-serverless.html" rel="noopener ugc nofollow" target="_blank">话来说</a>:CloudFormation托管的宏<code class="fe nq nr ns mt b">AWS:Serverless</code> transform，采用AWS无服务器应用模型(AWS SAM)语法编写的整个模板，将其转换和扩展为兼容的cloud formation模板。</p><p id="9069" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，对于我们来说，使用SAM模板来进一步扩展会容易得多。</p><p id="e98a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住这一点，请在下面找到标题为unpacked.yaml的云信息模板:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ef90" class="mx kx iq mt b gy my mz l na nb">Transform: AWS::Serverless-2016-10-31<br/>Resources:<br/>  DemoServerless:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>        Runtime: python3.8<br/>        Handler: lambda_function.lambda_handler<br/>        CodeUri: ./my-deployment-package.zip<br/>        PackageType: Zip</span></pre><p id="417a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">适当地选择运行时和处理程序。函数处理程序反映了函数名(<code class="fe nq nr ns mt b">lambda_handler</code>)和存储处理程序代码的文件(<code class="fe nq nr ns mt b">lambda_function.py</code>)。更多细节可以在官方文件<a class="ae mn" href="https://docs.aws.amazon.com/lambda/latest/dg/python-handler.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="b977" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CodeUri将与您在上一步中创建的部署包相同。请注意，我们没有引用S3的位置，而是使用S3的本地参考，并将使用Cloudformation <a class="ae mn" href="https://docs.aws.amazon.com/cli/latest/reference/cloudformation/package.html" rel="noopener ugc nofollow" target="_blank"> package </a>命令来引用它们。</p><p id="8c84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，用AWS自己的<a class="ae mn" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-cli-package.html" rel="noopener ugc nofollow" target="_blank">话来说</a>:您可以在模板中指定本地引用，称为本地工件，然后使用<code class="fe nq nr ns mt b">package</code>命令快速上传它们，而不是手动将文件上传到S3桶中，然后将位置添加到您的模板中。</p><p id="3e05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果您指定了一个文件，<code class="fe nq nr ns mt b">package</code>命令会直接将它上传到S3存储桶。上传工件之后，该命令返回您的模板的副本，用该命令上传工件的S3位置替换对本地工件的引用。然后，您可以使用返回的模板来创建或更新堆栈。在我们下一步构建Buildspec.yaml文件时，会有更多的细节。</p><h2 id="fab3" class="mx kx iq bd ky nc nd dn lc ne nf dp lg kj ng nh lk kn ni nj lo kr nk nl ls nm bi translated">d) Buildspec.yaml文件来指示CodeBuild构建并打包我们的Lambda代码。</h2><p id="9a0c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们已经准备好了云层模板。我们已经准备好了Lambda压缩文件。现在是时候创建命令来创建Lambda堆栈了。</p><p id="7e30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<em class="nn"> buildspec </em>是构建命令和相关设置的集合，采用YAML格式，代码构建使用它来运行构建。它分为诸如预构建、构建等阶段。我们不会深入它的细节，但是你可以在这里找到完整的语法和更多可用的信息。</p><p id="0b69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用以下文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f40b" class="mx kx iq mt b gy my mz l na nb">version: 0.2<br/>phases:<br/>  pre_build:<br/>    commands:<br/>      - zip my-deployment-package.zip lambda_function.py<br/>  build:<br/>    commands:<br/>      - aws cloudformation package --template-file unpacked.yaml --s3-bucket &lt;bucketname&gt; --output-template-file packed.yaml<br/>artifacts:<br/>  files:<br/>  - unpacked.yaml<br/>  - packed.yaml</span></pre><p id="d804" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nq nr ns mt b">pre_build</code>阶段用于为Cloudformation模板创建zip文件。为什么我们要再次创建zip？这是因为，如果您只是对代码进行任何更改，CodeBuild将确保自动创建zip文件，并且您不需要在每次更改代码时手动创建zip文件。</p><p id="18ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe nq nr ns mt b">Build</code>阶段，如前所述，我们使用<code class="fe nq nr ns mt b">package</code>命令引用之前创建的Cloudformation模板中给出的本地zip文件(<code class="fe nq nr ns mt b">unpacked.yaml</code>)。<code class="fe nq nr ns mt b">packed.yaml</code>将是输出文件。请确保在工件部分引用了这两者。</p><h1 id="04f6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤2:建立管道</h1><p id="22ce" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一切准备就绪，现在让我们来建造管道吧！</p><h2 id="8a10" class="mx kx iq bd ky nc nd dn lc ne nf dp lg kj ng nh lk kn ni nj lo kr nk nl ls nm bi translated">代码提交</h2><p id="110e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，转到CodeCommit-&gt;Repositories并创建一个存储库。按照前提条件和给出的步骤在您的本地系统中克隆repo。我在用HTTPS。</p><p id="232f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">把上一步创建的文件(<code class="fe nq nr ns mt b">lambda_function.py and my-deployment-package.zip</code>)。另外，放上之前创建的云形成模板(<code class="fe nq nr ns mt b">unpacked.yaml</code>)和<code class="fe nq nr ns mt b">buildspec.yml</code>文件。</p><p id="5e26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">办手续:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c2dc" class="mx kx iq mt b gy my mz l na nb">git add .<br/>git commit -m "first commit"<br/>git push origin master</span></pre><p id="0093" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码现在会上传到我们的回购。</p><p id="6720" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，随着我们的repo启动并准备就绪，我们将创建一个使用CodeBuild和CodeDeploy的端到端CI/CD管道。</p><h2 id="8913" class="mx kx iq bd ky nc nd dn lc ne nf dp lg kj ng nh lk kn ni nj lo kr nk nl ls nm bi translated"><strong class="ak">具有代码构建的代码管道:</strong></h2><p id="022f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，我们构建我们的项目。转到CodePipeline，然后单击New Service Role。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/c27c867554a61bf88773127fa7fae7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*li3PdbWphVi1XH_RxPu5wQ.png"/></div></div></figure><p id="bbe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一部分中，选择source provider作为AWS CodeCommit，选择您的repo和分支，并将其余内容保持默认:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ny"><img src="../Images/5f7ed43bbb37363204089767192e64de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuweybZttLtRVogbmSuccg.png"/></div></div></figure><p id="f58b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Build Provider部分，选择AWS CodeBuild，并点击Create a New Project(如果还没有创建的话)。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nz"><img src="../Images/18cd7c6bd71f98a45790295fc498b49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZBB5VBI2D9_n1tov_UDiw.png"/></div></div></figure><p id="c7d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在打开的弹出窗口中，输入以下设置:</p><ul class=""><li id="69ea" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir">环境图像</strong>:管理图像</li><li id="7fe5" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">操作系统</strong>:亚马逊Linux 2</li><li id="8fae" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">运行时</strong>:标准</li><li id="a1c5" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">图片</strong>:AWS/code build/amazonlinux 2-x84 _ 64-标准:3.0</li><li id="22eb" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">镜像版本</strong>:总是使用这个运行时版本的最新镜像</li><li id="104c" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">环境类型</strong> : Linux</li><li id="4d54" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">服务角色</strong>:新服务角色</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oa"><img src="../Images/33833ba0c377d9a1a0e47d1be02c3007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLZesMlgkRzzIwvJoP93kA.png"/></div></div></figure><ul class=""><li id="be82" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">保留附加配置。转到Buildspec。</li><li id="44d9" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">构建规范:使用一个构建规范文件。</li><li id="7c26" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir"> Buildspec Name </strong>(可选):如果您的Buildspec文件使用不同于buildspec.yaml的名称，或者位于不同于存储库根目录的位置，请在此处输入其来自源根目录的路径(例如，buildspec-two.yml或configuration/buildspec.yml)。</li><li id="9fa8" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">日志</strong>:选择Cloudwatch日志(可选)。请注意，这将花费一点额外的费用，但对调试非常有用。</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ob"><img src="../Images/e371d0ee06151fcf26390e809b58e14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aLZLeMZEgBBrN2lndgQ8g.png"/></div></div></figure><p id="83a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击“继续到代码管道”继续。您应该会看到“在CodeBuild中成功创建”消息和所选的项目名称。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oc"><img src="../Images/c329e073966ef7077815bd846ef9cd20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrlgB7GuqVNwdpqLKhffug.png"/></div></div></figure><p id="3516" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，这是步骤的一半。记住，在构建步骤中，Cloudformation将引用本地包。但是，它会将包放入我们在“s3-bucket”参数中指定的S3桶中。因此，如果我们不向S3 putObjects提供代码构建权限，我们将得到S3访问被拒绝错误。</p><p id="84f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，打开一个新的选项卡，然后在AWS控制台中进入CodeBuild。选择您创建的构建项目，并选择“构建细节”选项卡。在环境部分向下滚动，并单击ServiceRole。</p><p id="f169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在IAM中打开一个新标签。这里，要么为buildspec.yml中指定的目标bucket添加S3 putObjects权限(从AddPermissions选项卡)，要么如果您像我们大多数人一样懒惰，只需添加S3FullAccess托管策略。这将是一个安全警告！</p><p id="e941" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们回到我们离开的代码管道选项卡。选择“构建类型”为“单一”,然后单击“下一步”转到部署。</p><h2 id="eb32" class="mx kx iq bd ky nc nd dn lc ne nf dp lg kj ng nh lk kn ni nj lo kr nk nl ls nm bi translated">使用CodeDeploy的代码管道:</h2><p id="6c5e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在，我们使用CodeDeploy进入部署阶段。使用以下设置:</p><ul class=""><li id="b786" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir">部署提供者</strong> : AWS Cloudformation</li><li id="f35c" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">动作模式:</strong>创建或更新堆栈</li><li id="644d" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">堆栈名称:</strong>输入将由Cloudformation <strong class="ka ir">创建的堆栈名称。</strong>如果您正在更新现有堆栈，选择该堆栈名称。</li><li id="515e" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir"> Template: </strong>选择工件名称作为BuildArtifact，并在文件名中提供我们在buildspec.yml中指定的Cloudformation构建步骤文件的输出，在本例中，它将是packed.yaml。</li><li id="2281" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">能力</strong>:选择“能力_IAM”和“能力_自动_扩展”。</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi od"><img src="../Images/8e611c552570fcd928726dd5386f8f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVisDpPrtHQC_JkB9f0v6g.png"/></div></div></figure><ul class=""><li id="e1b3" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir">角色</strong>:选择我们在步骤1: IAM授权Cloudformation访问Lambda步骤中创建的角色。点击下一步。</li></ul><p id="c29c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">做最后一次检查，然后点击创建管道。</p><h1 id="61d1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤3:测试管道</h1><p id="ff01" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">第一次创建管道后，默认情况下，您会在管道窗口中看到正在进行的第一次构建。可以查看详情，建立日志等。您可以单击部署阶段的详细信息来检查Cloudformation堆栈本身。如果一切顺利，你将在这三个阶段都获得成功！</p><p id="49e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要验证它是否成功，请转到您的Lambda控制台，在那里，您应该会看到一个名为的新函数，其格式为:<pipelinename> - <cloudformationtemplatename> - <somerandomid>。</somerandomid></cloudformationtemplatename></pipelinename></p><p id="c056" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">恭喜你走到这一步！</p><p id="0ab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将测试从源代码到部署的管道。对代码做一些小的修改，然后提交到为CodeCommit创建的github repo中。</p><p id="1505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的管道现在应该会自动开始一个新的构建。在Cloudformation事件中，您会看到它正在更新现有的堆栈。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oe"><img src="../Images/7c92835294ca369e0c37c937ec83cfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fN8DEU4Riq1ZyHHCOmLHUQ.png"/></div></div></figure><p id="7b0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您现在在同一个函数中检查您的代码，您会看到这些更改已经被更新了！</p><p id="efc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧，从源代码到生产Lambda，全部使用AWS原生CI/CD解决方案。</p><h1 id="14a8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="5398" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用Lambda的本地AWS服务创建CI/CD解决方案的步骤到此结束。</p><p id="ac9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先研究了Lambda如何为其代码使用zip包的理论。然后，我们通过创建buildspec.yml、Cloudformation模板并创建适当的角色来完成先决条件。</p><p id="3b0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们使用CodePipeline从AWS存储库CodeCommit获取代码，使用CodeBuild构建和打包我们的Cloudformation模板，最后使用CodeDeploy部署我们的Cloudformation模板堆栈。</p><p id="39a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们最后从源代码到产品测试了我们的Lambda代码，看到任何提交更改都会自动启动管道，Cloudformation通过更新现有堆栈无缝地部署它。</p><p id="1b8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我真诚地相信，无服务器很快就会赶上容器世界，容器和无服务器将携手走向DevOps的未来，用于无服务器的云原生CI/CD解决方案将更加普遍。</p><p id="80cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AWS EKS·法盖特是这种容器和无服务器融合的先行者之一。如果您对这些感兴趣，请点击此处查看在EKS法盖特<a class="ae mn" href="https://medium.com/@shrut_terminator/how-to-deploy-a-multi-container-two-tier-go-application-in-eks-fargate-6266494f5bcf" rel="noopener">部署2层多容器解决方案(带CI/CD)的步骤。</a></p><p id="fdf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你喜欢这篇文章和演示。请随意放弃任何疑问和评论。拍手取乐:)。</p></div></div>    
</body>
</html>