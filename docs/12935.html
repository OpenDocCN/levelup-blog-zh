<html>
<head>
<title>Start Implementing Your Own Typescript Property Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始实现您自己的Typescript属性装饰器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/start-implementing-your-own-typescript-property-decorators-ae1e7025fefe?source=collection_archive---------6-----------------------#2022-07-24">https://levelup.gitconnected.com/start-implementing-your-own-typescript-property-decorators-ae1e7025fefe?source=collection_archive---------6-----------------------#2022-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fd85a8c35f4208d6c1838111f7b83de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a5AS7CRGGuBFvc2y.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">物业装饰</figcaption></figure><h1 id="4b09" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是室内设计师？</h1><p id="c697" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">它是一种结构设计模式，通过将这些对象放在包含行为的特殊包装器对象中，允许您将新的行为附加到这些对象上(<a class="ae ly" href="https://refactoring.guru/design-patterns/decorator" rel="noopener ugc nofollow" target="_blank">引用</a>)。</p><h1 id="b6d0" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是物业装饰？</h1><p id="85fa" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在Typescript文档中没有对属性修饰符的具体定义，您可以在那里找到以下内容:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7895" class="mi kd iq me b gy mj mk l ml mm">A <em class="mn">Property Decorator</em> is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context</span></pre><p id="12c5" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">在文档的一个注释中，您可以找到这个，它为我们提供了更多信息:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="bc05" class="mi kd iq me b gy mj mk l ml mm">A property decorator can only be used to observe that a property of a specific name has been declared for a class.</span></pre><p id="6d67" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">我们将使用的模式是为当前对象设置一些元数据，并在其他功能中使用它们。</p><h1 id="794f" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">幕后是怎么回事？</h1><p id="dd84" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">您的属性装饰器实际上是一个简单的函数，在运行时作为函数调用，它有两个参数:</p><ul class=""><li id="1739" class="mt mu iq lc b ld mo lh mp ll mv lp mw lt mx lx my mz na nb bi translated">如果属性是<em class="mn">静态</em>，则为类的构造函数，如果属性是<em class="mn">实例</em>成员，则为类原型</li><li id="37eb" class="mt mu iq lc b ld nc lh nd ll ne lp nf lt ng lx my mz na nb bi translated">成员的姓名</li></ul><p id="aad9" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">你知道我们无权访问<code class="fe nh ni nj me b">property</code>吗？我们在这个函数中返回的内容也将被忽略！这就是为什么我们之前说这个装饰器只是用来观察的。</p><h1 id="7aca" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置</h1><p id="cee1" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">为了运行Typescript代码，我们需要使用Typescript编译器来编译它们。</p><p id="9d0e" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">我们需要一个<code class="fe nh ni nj me b">tsconfig.json</code>文件:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">tsconfig.json</figcaption></figure><p id="5684" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">我们必须启用<code class="fe nh ni nj me b">experimentalDecorators</code>。还有，目标不能少于<code class="fe nh ni nj me b">ES5</code>。也使用<code class="fe nh ni nj me b">reflect-metadata</code>类型，否则你会得到一些类型错误。</p><p id="92c0" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">如果您不想使用<code class="fe nh ni nj me b">tsconfig</code>文件，您可以直接传递这些选项:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="266f" class="mi kd iq me b gy mj mk l ml mm">tsc --experimentalDecorators // If you installed tsc globaly<br/>npx tsc --experimentalDecorators // If you installed tsc in your current directory</span></pre><p id="66b6" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">现在，通过在当前目录中运行<code class="fe nh ni nj me b">tsc</code>，typescript文件将被编译成Javascript文件，我们可以使用Node运行它们。(<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/start-writing-your-own-typescript-method-decorators-c921cdc3d1c1">参考</a>)</p><h1 id="41bd" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">定义我们的属性装饰器</h1><h2 id="7b6f" class="mi kd iq bd ke nm nn dn ki no np dp km ll nq nr kq lp ns nt ku lt nu nv ky nw bi translated">1-示例:只记录参数</h2><p id="02e3" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">让我们首先记录一个简单示例中的参数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">日志属性参数</figcaption></figure><p id="7af1" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">我们有一个拥有三个成员的用户，其中一个成员是静态的:<code class="fe nh ni nj me b">maxDailyUsage</code>。让我们看看运行这段代码后的日志:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7e8c" class="mi kd iq me b gy mj mk l ml mm">{ firstArgument: {}, propertyName: 'email' } // line 10<br/>{<br/>  firstArgument: [class User] { maxDailyUsage: 12 }, // line 13<br/>  propertyName: 'maxDailyUsage'<br/>}</span></pre><p id="46db" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">在静态情况下，我们可以看到<strong class="lc ir">用户类构造函数</strong>和<strong class="lc ir">初始化值</strong>。如果我们在别的地方初始化这个静态成员的值，我们会在日志中看到undefined。</p><p id="7c7f" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">例如member，我们可以看到属性和类原型的名称，它在控制台中显示一个空对象，但是类成员在这个对象中是可用的。</p><p id="4756" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">下一个例子是真实用法。</p><h2 id="6a2f" class="mi kd iq bd ke nm nn dn ki no np dp km ll nq nr kq lp ns nt ku lt nu nv ky nw bi translated">2-示例:审查用户的敏感数据</h2><p id="2867" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在这个例子中，我们有一个用户，它有一些敏感的字段，如密码和卡号。当有人在用户对象上调用<code class="fe nh ni nj me b">toString()</code>函数时，我们想要审查一些字段。</p><p id="8e77" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">对于这个例子，我们使用<strong class="lc ir">反射API </strong>来设置元数据并读取元数据。</p><p id="2c39" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">它被称为反射，因为它反映了关于对象的信息。它仍然没有在原生Javascript中实现，有一个为ES7添加decorators和reflect API的<a class="ae ly" href="https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md" rel="noopener ugc nofollow" target="_blank">提议。由于不受支持，Typescript团队为反射API </a>构建了一个<a class="ae ly" href="https://github.com/rbuckton/reflect-metadata" rel="noopener ugc nofollow" target="_blank"> polyfill，现在通过启用实验特性，它可以在Typescript中使用。</a></p><p id="4e73" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">让我们来看看实现:</p><p id="4477" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">我们需要构建的第一件事是我们的属性描述符:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">属性描述符</figcaption></figure><p id="ba12" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">我们在这个描述符中所做的只是设置元数据。</p><p id="a264" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">为了在对象上设置元数据，我们使用了<code class="fe nh ni nj me b">Reflect.defineMetadata </code>,我们可以向该函数传递3个参数:</p><ul class=""><li id="6152" class="mt mu iq lc b ld mo lh mp ll mv lp mw lt mx lx my mz na nb bi translated"><strong class="lc ir">键</strong>:我们使用了一个模式，后来我们使用了同样的模式来获取元数据<code class="fe nh ni nj me b">sensitive:${propertyName}</code></li><li id="74fa" class="mt mu iq lc b ld nc lh nd ll ne lp nf lt ng lx my mz na nb bi translated"><strong class="lc ir">值</strong>:我们将其设为true，以了解该属性是否敏感。</li><li id="10d4" class="mt mu iq lc b ld nc lh nd ll ne lp nf lt ng lx my mz na nb bi translated">这是目标对象，我们传递属性装饰器的第一个参数，它是类的实例。</li></ul><p id="04ee" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">现在我们可以轻松地在我们的字段前使用<code class="fe nh ni nj me b">@sensitive</code>。</p><p id="ad9f" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">让我们一起来看看整个实现:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">属性装饰器—完整的实现</figcaption></figure><p id="f117" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">两个领域是敏感的。我们不想在<code class="fe nh ni nj me b">toString</code>函数中暴露它们，所以我们应该检查它们。我们在第31行用同样的模式使用<code class="fe nh ni nj me b">Reflect.getMetadata</code>来检查它是否是敏感字段。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="34ef" class="mi kd iq me b gy mj mk l ml mm">const isSensetiveField = Reflect.getMetadata(`sensitive:${iterator}` , this)</span></pre><p id="3a04" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">如果字段不敏感，我们不会将其添加到<code class="fe nh ni nj me b">userJSON</code>对象，因此，这些字段不会被暴露。让我们看看日志结果:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/fdcc585ed221f7242ca35c6e9107fd3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RarV1mzxSqzmoms5eC-5Tg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">日志结果</figcaption></figure><p id="9cd4" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">正如我们所料，带有<code class="fe nh ni nj me b">@sensitive</code>装饰的字段没有被暴露。</p><p id="f241" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated"><strong class="lc ir"> ***重要的是要明白，我们用另一种方法实现了我们的逻辑，我们使用了属性装饰器来设置元数据，后来我们使用了那个元数据。我们无法在属性装饰器中访问属性值。*** </strong></p><h2 id="348c" class="mi kd iq bd ke nm nn dn ki no np dp km ll nq nr kq lp ns nt ku lt nu nv ky nw bi translated"><strong class="ak">有没有办法摆脱我们用的</strong> <code class="fe nh ni nj me b">sensitive:${iterator} </code>这种模式？</h2><p id="18fd" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">是的，我们使用的两个函数都有另一个重载来为特定的<code class="fe nh ni nj me b">property</code>而不是整个对象定义元数据。让我们来看看实现:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">属性描述符</figcaption></figure><p id="68b0" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">函数<code class="fe nh ni nj me b">defineMetadata</code>现在有4个参数，最后一个是属性名。此外，键不需要在整个对象中是唯一的，它只需要在这个属性中是唯一的。</p><p id="5bf3" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">函数<code class="fe nh ni nj me b">getMetadata</code>现在有3个参数，最后一个是属性名key。</p><h2 id="0058" class="mi kd iq bd ke nm nn dn ki no np dp km ll nq nr kq lp ns nt ku lt nu nv ky nw bi translated">3-打字稿文档示例的说明</h2><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Typescript doc属性示例</figcaption></figure><h2 id="a515" class="mi kd iq bd ke nm nn dn ki no np dp km ll nq nr kq lp ns nt ku lt nu nv ky nw bi translated">为什么从这个例子中很难理解property decorator？</h2><p id="d280" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在跳到这个例子之前，你需要知道一些概念。</p><p id="a85a" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated"><strong class="lc ir"> 1-什么是</strong> <strong class="lc ir">符号？</strong> Symbol是一个内置对象，其构造函数返回一个符号原语，也称为符号值或符号，它保证是唯一的(<a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">参考</a>)</p><p id="c774" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated"><strong class="lc ir"> 2-为什么装饰函数的参数只有一个，而且是一个字符串？</strong>这是因为这个函数不是装饰器，它只是创建一个装饰器<em class="mn">。</em> <code class="fe nh ni nj me b">Reflect.metadata(…)</code>本身返回一个函数，可以用作我们的装饰器。这些函数被称为<strong class="lc ir">装饰工厂</strong>，因为它们可以用来创建装饰器。在这种情况下，它返回一个具有这些参数的函数:<code class="fe nh ni nj me b">(target: Object, propertyKey: string | symbol)</code>。</p><p id="a101" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated"><strong class="lc ir"> 3-同一个键如何用于设置元数据？它在不同的领域工作吗？</strong>是的，它正在工作，原因是它使用了<code class="fe nh ni nj me b">Reflect.metadata</code>，并且它只为那个<em class="mn">特定属性</em>自动定义元数据。我们使用的函数也有另一个重载，只为该属性定义元数据。在这种情况下，当我们想要获取元数据时，我们将使用函数<code class="fe nh ni nj me b">getMetadata</code>的另一个重载，我们可以传递包含该元数据的<em class="mn">属性键</em>。</p><p id="bda5" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">我认为有了这些答案，问题就像我们在第2部分中解决的一样。</p><h1 id="2712" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="986a" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">属性描述符只能让我们知道这个装饰器是用在特定的字段上的，我们不能访问字段值，也不能改变它(在某些情况下，我们可以改变字段值，但这可能会导致错误的代码，查看<a class="ae ly" href="https://dev.to/danywalls/using-property-decorators-in-typescript-with-a-real-example-44e" rel="noopener ugc nofollow" target="_blank">这篇文章和评论</a>)。</p><p id="e4a5" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">使用它的一种方法是设置元数据，并在其他地方使用该元数据。</p><p id="8edd" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">另一个使用示例是根据属性定义一些函数。<a class="ae ly" href="https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/" rel="noopener ugc nofollow" target="_blank">查这篇文章找那个</a>。</p><p id="e3d2" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">如果你想了解更多关于装饰者的知识，你可以看看我的其他文章:</p><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/start-implementing-your-own-typescript-class-decorators-84a49f560dea"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">开始实现你自己的类型脚本类装饰器</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">什么是班级装饰者？</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op jw ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/start-writing-your-own-typescript-method-decorators-c921cdc3d1c1"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">开始编写自己的类型脚本方法装饰器</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">什么是室内设计师？</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op jw ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">文档-装饰者</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">TypeScript装饰程序概述</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.typescriptlang.org</p></div></div><div class="ok l"><div class="or l om on oo ok op jw ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="http://blog.wolksoftware.com/decorators-metadata-reflection-in-typescript-from-novice-to-expert-part-4" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">装饰者&amp;TypeScript中的元数据反射:从新手到专家(第四部分)* Wolk软件</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">深入了解decorators的TypeScript实现，以及它们如何使令人兴奋的新JavaScript成为可能…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">blog.wolksoftware.com</p></div></div><div class="ok l"><div class="os l om on oo ok op jw ob"/></div></div></a></div></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><h1 id="48c3" class="kc kd iq bd ke kf pa kh ki kj pb kl km kn pc kp kq kr pd kt ku kv pe kx ky kz bi translated">分级编码</h1><p id="77f0" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="0b34" class="mt mu iq lc b ld mo lh mp ll mv lp mw lt mx lx my mz na nb bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="509c" class="mt mu iq lc b ld nc lh nd ll ne lp nf lt ng lx my mz na nb bi translated">📰更多内容请查看<a class="ae ly" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="a83c" class="mt mu iq lc b ld nc lh nd ll ne lp nf lt ng lx my mz na nb bi translated">🔔关注我们:<a class="ae ly" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ly" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae ly" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="d294" class="pw-post-body-paragraph la lb iq lc b ld mo lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx ij bi translated">🚀👉<a class="ae ly" href="https://jobs.levelup.dev/jobs?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">软件工程师的热门职位</strong> </a></p></div></div>    
</body>
</html>