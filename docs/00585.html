<html>
<head>
<title>Visual Regression Testing with Puppeteer using Create React App, TypeScript, and Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Create React App、TypeScript和Jest进行可视化回归测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-react-app-jest-enzyme-typescript-jsdom-visual-regression-testing-89f102c29e7?source=collection_archive---------1-----------------------#2019-05-19">https://levelup.gitconnected.com/create-react-app-jest-enzyme-typescript-jsdom-visual-regression-testing-89f102c29e7?source=collection_archive---------1-----------------------#2019-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6ebfe87a3b3029ec4ba3e56d35b27ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlbSAGTb07rCrieg_lFV6A.jpeg"/></div></div></figure><p id="baf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我广泛地使用Typescript做任何事情，包括React。当我想学习使用上面给出的堆栈进行测试时，令人惊讶的是我找不到任何可以从中受益的资源或博客帖子。在做了大量的研究和代码阅读后，我从其他开发人员的努力中创建了一个混合解决方案，也许它只是将他们的代码翻译成打字稿和修剪一下，但要点是理解过程的基础。在这篇文章的开头，我们将使用Jest framework测试一个组件，从设置它开始。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="cc12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在做任何事情之前，我们需要安装所需的软件包作为开发者依赖:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="a238" class="lm ln iq li b gy lo lp l lq lr">npm install connect enzyme enzyme-adapter-react-16 enzyme-to-json finalhandler jest-image-snapshot puppeteer -D</span></pre><p id="813e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以及它们的类型定义:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="2914" class="lm ln iq li b gy lo lp l lq lr">npm install <a class="ae ls" href="http://twitter.com/types/enzyme" rel="noopener ugc nofollow" target="_blank">@types/enzyme</a> <a class="ae ls" href="http://twitter.com/types/enzyme-adapter-react-16" rel="noopener ugc nofollow" target="_blank">@types/enzyme-adapter-react-16</a> <a class="ae ls" href="http://twitter.com/types/jest-image-snapshot" rel="noopener ugc nofollow" target="_blank">@types/jest-image-snapshot</a> <a class="ae ls" href="http://twitter.com/types/puppeteer" rel="noopener ugc nofollow" target="_blank">@types/puppeteer</a> @types/connect @types/finalhandler -D</span></pre><p id="8475" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在该配置了。首先，我们将在根目录下创建我们的Jest配置文件，它通常在<code class="fe lt lu lv li b">src</code>目录的上一级:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="2cb5" class="lm ln iq li b gy lo lp l lq lr">module.exports <em class="lw">=</em> {<br/>"roots": [<br/>  "&lt;rootDir&gt;/src"<br/>],<br/>"transform": {<br/>  "^.+\\.tsx?$": "ts-jest"<br/>},<br/>"testRegex": "(/__tests__/.*|(\\.|/)(test|spec))\\.tsx?$",<br/>"moduleFileExtensions": [<br/>  "ts",<br/>  "tsx",<br/>  "js",<br/>  "jsx",<br/>  "json",<br/>  "node"<br/>],<br/>"snapshotSerializers": ["enzyme-to-json/serializer"],<br/>}</span></pre><p id="162b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个配置将你的根目录设置为<code class="fe lt lu lv li b">src</code>目录，用<code class="fe lt lu lv li b">ts-jest</code>模块运行<code class="fe lt lu lv li b">.tsx</code>文件，并在<code class="fe lt lu lv li b">src</code>目录的任何子目录下寻找<code class="fe lt lu lv li b">.ts, .tsx, .js, .jsx, .json</code>文件。</p><p id="88be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还使用<code class="fe lt lu lv li b">enzyme-to-json</code>序列化器作为JSON来制作组件的快照，而不是使用酶的默认方式。</p><p id="ec63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们必须在<code class="fe lt lu lv li b">src</code>目录下创建一个名为<code class="fe lt lu lv li b">setupTests.js</code>的文件。这个文件名很特别，因为由create-react-app创建的应用程序会查找这个文件名。这是一个在所有测试文件中全局导入的文件。因此，我们在这里的每个测试中反复添加我们需要导入的内容，以节省时间。下面是<code class="fe lt lu lv li b">setupTests.js</code>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="1d30" class="lm ln iq li b gy lo lp l lq lr"><em class="lw">import</em> { <em class="lw">configure</em> } <em class="lw">from</em> 'enzyme';<br/><em class="lw">import</em> <em class="lw">Adapter</em> <em class="lw">from</em> 'enzyme-adapter-react-16';<br/><em class="lw">import</em> { <em class="lw">toMatchImageSnapshot</em> } <em class="lw">from</em> "jest-image-snapshot";</span><span id="6904" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">expect</em>.<em class="lw">extend</em>({ <em class="lw">toMatchImageSnapshot</em> });</span><span id="0ece" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">configure</em>({ adapter: <em class="lw">new</em> <em class="lw">Adapter</em>() });</span></pre><p id="47b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们准备好测试了。挑选你最喜欢的组件，尝试浅层渲染:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="59a8" class="lm ln iq li b gy lo lp l lq lr">import React from "react";<br/>import { shallow } from "enzyme";<br/>import FavComponent from "./FavComponent";</span><span id="698a" class="lm ln iq li b gy lx lp l lq lr">test(`should render`, () =&gt; {<br/>  const wrapper = shallow(&lt;FavComponent /&gt;);<br/>  expect(wrapper).toMatchSnapshot();<br/>});</span></pre><p id="91f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将这个测试文件保存到组件所在的目录中。命名为<code class="fe lt lu lv li b">FavComponent.test.tsx</code>这些扩展对Jest找到这些测试文件很重要。</p><p id="b84f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们可以继续我们的视觉回归测试，因为我们已经看到了基础知识。为了测试我们组件的截图，我们将编写自己的实用程序，我将向您解释它，以便您可以创建自己的解决方案。</p><p id="f307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们看看我们在测试文件中要求什么:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="7ff8" class="lm ln iq li b gy lo lp l lq lr"><em class="lw">import</em> <em class="lw">React</em> <em class="lw">from</em> "react";<br/><em class="lw">import</em> <em class="lw">ReactDOM</em> <em class="lw">from</em> "react-dom";<br/><em class="lw">import</em> FavComponent <em class="lw">from</em> "./FavComponent";<br/><em class="lw">import</em> <em class="lw">getComponentImage</em> <em class="lw">from</em> "../utils/getComponentImage";</span><span id="6ce2" class="lm ln iq li b gy lx lp l lq lr">test(`should match screenshot`, async () =&gt; {<br/>  const div = document.createElement("div");<br/>  document.body.appendChild(div);<br/>  ReactDOM.render(&lt;FavComponent /&gt;, div);<br/>  <br/>  const screenshot = await getComponentImage();<br/>  expect(screenshot).toMatchImageSnapshot();<br/>  <br/>  ReactDOM.unmountComponentAtNode();<br/>  document.body.removeChild(div);<br/>});</span></pre><p id="63ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们导入<code class="fe lt lu lv li b">React</code>以获得JSX的支持。然后<code class="fe lt lu lv li b">ReactDOM</code>在一个元素中安装组件，并在一个容器元素中呈现它，这个容器元素是我们创建的<code class="fe lt lu lv li b">div</code>常量。我们可以使用<code class="fe lt lu lv li b">document.createElement("div")</code> like语法，因为JSDOM内置了create-react-app。我们向我们的实用程序请求截图。一会儿你会看到它的代码，但是你会注意到我们没有传递任何参数给<code class="fe lt lu lv li b">getComponentImage()</code>。这是因为它从全局JSDOM对象获取组件的HTML内容。完成所有工作后，我们卸载组件并移除容器元素，以防止与其他测试冲突。</p><p id="8b7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在……什么是<code class="fe lt lu lv li b">getComponentImage</code>?基本上，它是一个创建HTTP服务器的实用程序，该服务器用我们组件的HTML进行响应，并通过<code class="fe lt lu lv li b">puppeteer</code>连接到该HTTP服务器以获取其屏幕截图。然后它返回这个截图。我们开始写吧。</p><p id="8883" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要一个服务器来服务组件的HTML:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="6f5f" class="lm ln iq li b gy lo lp l lq lr"><em class="lw">import</em> <em class="lw">connect</em> <em class="lw">from</em> "connect";<br/><em class="lw">import</em> <em class="lw">finalhandler</em> <em class="lw">from</em> "finalhandler";<br/><em class="lw">import</em> <em class="lw">http</em> <em class="lw">from</em> "http";<br/><em class="lw">import</em> <em class="lw">puppeteer</em> <em class="lw">from</em> "puppeteer";<br/><em class="lw">import</em> { <em class="lw">AddressInfo</em> } <em class="lw">from</em> "net";</span><span id="bb7e" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">const</em> <em class="lw">createServer</em> <em class="lw">=</em> <em class="lw">async</em> (<em class="lw">html:</em> string) <em class="lw">=&gt;</em> {</span><span id="4dd8" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">const</em> <em class="lw">app</em> <em class="lw">=</em> <em class="lw">connect</em>();</span><span id="8beb" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">app</em>.<em class="lw">use</em>((<em class="lw">request:</em> any, <em class="lw">response:</em> any, <em class="lw">next:</em> <em class="lw">connect</em>.<em class="lw">NextFunction</em>) <em class="lw">=&gt;<br/>  request</em>.<em class="lw">url</em> <em class="lw">===</em> "/" <em class="lw">?</em> <em class="lw">response</em>.<em class="lw">end</em>(<em class="lw">html</em>) <em class="lw">:</em> <em class="lw">next</em>()<br/>);</span><span id="bced" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">app</em>.<em class="lw">use</em>(<em class="lw">finalhandler</em>);</span><span id="db35" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">const</em> <em class="lw">server</em> <em class="lw">=</em> <em class="lw">http</em>.<em class="lw">createServer</em>(<em class="lw">app</em>);</span><span id="b9f3" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">await</em> <em class="lw">new</em> <em class="lw">Promise</em>((<em class="lw">resolve</em>, <em class="lw">reject</em>) <em class="lw">=&gt;</em> {<br/>  <em class="lw">const</em> <em class="lw">startServer</em> <em class="lw">=</em> () <em class="lw">=&gt;</em> {<br/>    <em class="lw">server</em>.<em class="lw">once</em>("error", (<em class="lw">e:</em> <em class="lw">NodeJS</em>.<em class="lw">ErrnoException</em>) <em class="lw">=&gt;</em> {<br/>      <em class="lw">if</em> (<em class="lw">e</em>.<em class="lw">code</em> <em class="lw">===</em> "EADDRINUSE") {<br/>        <em class="lw">server</em>.<em class="lw">close</em>(<em class="lw">startServer</em>);<br/>      }<br/>      });<br/>      <em class="lw">server</em>.<em class="lw">listen</em>(0, (<em class="lw">err?</em>) <em class="lw">=&gt;</em> (<em class="lw">err</em> <em class="lw">?</em> <em class="lw">reject</em>(<em class="lw">err</em>) <em class="lw">:</em> <em class="lw">resolve</em>()));<br/>    };<br/>    <em class="lw">startServer</em>();<br/>  });<br/>  <em class="lw">return</em> <em class="lw">server</em>;<br/>};</span></pre><p id="e1b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从导入必要的模块开始。让我们了解一下模块:</p><p id="5054" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lt lu lv li b">connect</code> : Connect是一个支持中间件的HTTP服务器模块。你一眼就能看出express.js用法的相似之处。</p><p id="301d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lt lu lv li b">http</code>:这是一个原生模块。它创建了一个HTTP服务器，您可以在特定的端口和IP上监听它。</p><p id="c399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lt lu lv li b">puppeteer</code>:木偶师提供高级API控制铬或铬。它通常用于无头模式，但也可以用于无头模式。</p><p id="4876" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lt lu lv li b">finalhandler</code>:它是最后一步中调用的最后一个函数，用来响应HTTP请求。</p><p id="45ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建了我们的<code class="fe lt lu lv li b">connect</code>对象，并在中间件的支持下拥有了一个框架。然后我们安装一个中间件，如果它在根资源路径“/”上，它用我们的组件的HTML进行响应，如果没有，通过让请求<code class="fe lt lu lv li b">next()</code>到<code class="fe lt lu lv li b">finalhandler</code>用404进行响应。然后，我们创建一个HTTP服务器，并在等待它完成的承诺中监听它的事件。</p><p id="c051" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出错时，它抛出<code class="fe lt lu lv li b">EADDRINUSE</code>——意味着该端口被另一个服务或程序使用。如果发生这种情况，我们的实用程序将停止，不会继续进行。为了克服这一点，我们每次遇到错误时都要重新启动服务器。服务器通过将端口参数设置为0来监听一个随机端口，但是它仍然可能与另一个程序冲突，我们需要监听错误。一切结束后，我们归还服务器。</p><p id="1860" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们提供了组件的HTML，现在我们需要“看到”它。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="f9de" class="lm ln iq li b gy lo lp l lq lr"><em class="lw">const</em> <em class="lw">takeScreenshot</em> <em class="lw">=</em> <em class="lw">async</em> (<em class="lw">url:</em> string) <em class="lw">=&gt;</em> {<br/>  <em class="lw">const</em> <em class="lw">browser</em> <em class="lw">=</em> <em class="lw">await</em> <em class="lw">puppeteer<br/>    </em>.<em class="lw">launch</em>(<br/>      {<br/>        args: ["--disable-lcd-text"],<br/>        defaultViewport: { width: 1920, height: 1080 },<br/>      },<br/>    );<br/>  <br/>  <em class="lw">const</em> <em class="lw">page</em> <em class="lw">=</em> <em class="lw">await</em> <em class="lw">browser</em>.<em class="lw">newPage</em>();<br/>  <br/>  <em class="lw">await</em> <em class="lw">page</em>.<em class="lw">goto</em>(<em class="lw">url</em>, { waitUntil: "load" });</span><span id="2c13" class="lm ln iq li b gy lx lp l lq lr"><em class="lw">  const</em> <em class="lw">image</em> <em class="lw">=</em> <em class="lw">await</em> <em class="lw">page</em>.<em class="lw">screenshot</em>();<br/>  <em class="lw">browser</em>.<em class="lw">close</em>();<br/>  <br/>  <em class="lw">return</em> <em class="lw">image</em>;<br/>};</span></pre><p id="d007" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从导入的木偶师对象调用launch来创建chromium实例。我们推出了两个重要的选项属性。首先是<code class="fe lt lu lv li b">args: ["--disable-lcd-text"]</code>。这是为了禁用反走样，使铬在每一个不同的显示器给出不同的截图。此外，我们需要组件的尺寸一致，可能会有不同分辨率的媒体查询，所以我们设置了一个固定的视口尺寸。这些安排将确保我们在任何地方和每次测试时都得到相同的结果。</p><p id="afa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在浏览器中打开一个新页面，并将其重定向到我们的服务器，稍后它将作为参数传递给<code class="fe lt lu lv li b">url</code>。我们制作木偶师来截取页面的截图。</p><p id="da50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了防止内存泄漏，我们关闭浏览器，然后返回图像供以后使用。</p><p id="e487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除非我们调用这些函数，否则它们不会启动，所以最后一个函数就是这样做的:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="187f" class="lm ln iq li b gy lo lp l lq lr">const generateImage = async () =&gt; {<br/>  const html = document.documentElement.outerHTML;  <br/>  <br/>  const server = await createServer(html);<br/>  const address = server.address()! as AddressInfo;<br/>  const port = address.port;<br/>  <br/>  const url = `http://localhost:${port}`;</span><span id="6db8" class="lm ln iq li b gy lx lp l lq lr">  const screenshot = await takeScreenshot(url);<br/>  await new Promise((resolve) =&gt; server.close(resolve));<br/>  <br/>  return screenshot<br/>};</span><span id="3b55" class="lm ln iq li b gy lx lp l lq lr">export default generateImage;</span></pre><p id="1eee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从JSDOM的全局对象中获取HTML，用给定的HTML创建我们的服务器，将它响应回<code class="fe lt lu lv li b">takeScreenshot()</code>的木偶浏览器实例。为了重定向并从这个函数中获取图像，我们传递一个指向localhost的URL参数。"!"在地址变量中意味着<code class="fe lt lu lv li b">server.address()</code>不为空。我们称它为<code class="fe lt lu lv li b">AddressInfo</code>,因为它也可以是一个字符串。我们通过将resolve传递给它的事件处理程序来等待服务器关闭。在函数的结尾，我们返回截图，在文件的结尾，我们导出这个函数用于测试文件。</p><p id="a5f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你知道我们如何在我们最喜欢的组件的测试文件中使用它。现在你有了自己解决问题的想法。</p><p id="00f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以阅读<a class="ae ls" href="https://github.com/dferber90/jsdom-screenshot/blob/master/generateImage.js" rel="noopener ugc nofollow" target="_blank">这个回购</a>来获得我们<code class="fe lt lu lv li b">getComponentImage</code>实用程序的更高级和原始版本。它包含更多的功能，如服务静态文件，并让您能够使用不同的选项，感谢它的开发者帮助我们。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="115b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这篇文章对你有帮助或启发，谢谢阅读。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><div class="ld le lf lg gt ly"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">前50名React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">gitconnected.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm jw ly"/></div></div></a></div></div></div>    
</body>
</html>