<html>
<head>
<title>Fluttering Dart: OOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">飞舞的飞镖:噢</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fluttering-dart-oop-8b92cd89a7f0?source=collection_archive---------0-----------------------#2019-12-08">https://levelup.gitconnected.com/fluttering-dart-oop-8b92cd89a7f0?source=collection_archive---------0-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="68e7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener ugc nofollow" target="_blank" href="https://levelup.gitconnected.com/fluttering-dart/home">飘动的飞镖</a></h2><div class=""/><div class=""><h2 id="e6ba" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">类、对象、接口等等</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/22d79f6dcd1ad9be19edfa5db034538a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqqArYF_xyAaZtyGWfDtkw.png"/></div></div></figure><p id="c34b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://flutter.dev" rel="noopener ugc nofollow" target="_blank"> Flutter </a>项目可以使用特定于平台和跨平台的代码。后者是用<a class="ae lz" href="https://dart.dev" rel="noopener ugc nofollow" target="_blank"> Dart </a>写的，而且，构建Flutter apps，需要一些Dart的基础知识。</p><p id="50dc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://medium.com/tag/fluttering-dart/archive" rel="noopener"/></p><p id="5647" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在本系列的前几部分中，我们浏览了Dart<a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-9a3e74b0d9c5" rel="noopener"><strong class="lf jd"/></a><strong class="lf jd"/><a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-b37110f4d1bf" rel="noopener"><strong class="lf jd">函数</strong></a><strong class="lf jd"/><a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-ee493f4b0440" rel="noopener"><strong class="lf jd">运算符</strong> </a>和<a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-the-flow-7be2080763ad" rel="noopener"> <strong class="lf jd">控制流语句</strong> </a>。</p><p id="92c2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这一部分，我们将发现Dart是真正的面向对象编程语言。</p><p id="25f3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">可以使用<a class="ae lz" href="https://dartpad.dev" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd"/></a>试一试一些代码示例。</p><h1 id="8eff" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated">类别和对象</h1><p id="325e" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">还记得我们在旅程开始时讨论过的<a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-9a3e74b0d9c5" rel="noopener">内置数据类型</a>吗？类允许我们定义自己的数据类型！这样我们就可以对程序中需要使用的对象进行建模。</p><p id="de24" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">类</strong>是用户定义的数据类型，在示例中，到目前为止我们已经定义了一些类，最令人难忘的可能是Cat类。</p><p id="f987" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在Dart中，每个对象都是一个类的实例，所有的类都是从<strong class="lf jd">对象</strong>派生出来的。Dart也有一个基于<strong class="lf jd"> mixin的继承</strong>，这有助于减少多重继承。这种继承类型允许重用多个类体，并且只存在一个超类。</p><p id="c16f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">类定义<strong class="lf jd">成员</strong>:函数和数据(<strong class="lf jd">方法</strong>和<strong class="lf jd">实例变量</strong>)。<strong class="lf jd">在对象上调用</strong>方法就是调用方法的行为。公共方法可以访问该对象的成员。</p><p id="9b2b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">点运算符<code class="fe mx my mz na b"><strong class="lf jd">.</strong></code>用于引用变量或方法。</p><p id="384b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以使用一个定义的<strong class="lf jd">类</strong>的<strong class="lf jd">构造函数</strong>来创建一个<strong class="lf jd">对象</strong>。</p><p id="8ca1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">构造函数名可以是类名<code class="fe mx my mz na b">ClassName</code>或<code class="fe mx my mz na b">ClassName.identifier</code>。例如，我们将使用<code class="fe mx my mz na b">Cat()</code>或<code class="fe mx my mz na b">Cat.copyCat()</code>构造函数创建一个<code class="fe mx my mz na b">Cat</code>。</p><p id="962e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">构造函数可以有参数来提供初始化新对象所需的值，有几种类型:</p><ul class=""><li id="5b03" class="nb nc it lf b lg lh lj lk lm nd lq ne lu nf ly ng nh ni nj bi translated"><strong class="lf jd">默认</strong> —当我们不声明构造函数时，提供一个没有参数的默认构造函数，调用超类中的无参数构造函数；请注意，如果您声明了一个构造函数，将不会有默认的构造函数，如果您扩展了一个类，它的构造函数不会被继承；</li></ul><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="d7f6" class="no mb it na b gy np nq l nr ns">class <strong class="na jd">Cat</strong> {<br/>  DateTime birthday;</span><span id="f0d4" class="no mb it na b gy nt nq l nr ns">  // default<br/>  // it's here<br/>  // even if<br/>  // you can't see it<br/>}</span></pre><ul class=""><li id="e1bf" class="nb nc it lf b lg lh lj lk lm nd lq ne lu nf ly ng nh ni nj bi translated"><strong class="lf jd">命名为</strong>——当我们需要为一个类实现多个构造函数时使用，或者提供额外的清晰性；</li></ul><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="af73" class="no mb it na b gy np nq l nr ns">class Cat {<br/>  DateTime birthday;</span><span id="4e67" class="no mb it na b gy nt nq l nr ns">  // named<br/>  <strong class="na jd">Cat.baby()</strong> {<br/>    birthday = DateTime.now();<br/>  }<br/>}</span></pre><ul class=""><li id="44fb" class="nb nc it lf b lg lh lj lk lm nd lq ne lu nf ly ng nh ni nj bi translated"><strong class="lf jd">重定向</strong> —当我们只想重定向同一个类中的某个构造函数时；它的主体是空的，构造函数调用出现在<code class="fe mx my mz na b">:</code>之后；</li></ul><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="ad3f" class="no mb it na b gy np nq l nr ns">class Cat {<br/>  DateTime birthday;<br/> <br/>  // main cosntructor<br/>  Cat(this.birthday);</span><span id="c065" class="no mb it na b gy nt nq l nr ns">  // delegating to main constructor<br/>  <strong class="na jd">Cat.withBirthday(DateTime birthday) : this(birthday);</strong><br/>}</span></pre><ul class=""><li id="3b44" class="nb nc it lf b lg lh lj lk lm nd lq ne lu nf ly ng nh ni nj bi translated"><strong class="lf jd">常量</strong> —当我们需要永远不变的对象时使用；当调用这样的构造函数时，我们应该使用关键字<code class="fe mx my mz na b">const</code>，否则我们不会创建常量；</li></ul><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="61b4" class="no mb it na b gy np nq l nr ns">class CatTreat {<br/>  static final CatTreat catTreat = const CatTreat(1);<br/>  <br/>  final num quantity;</span><span id="baac" class="no mb it na b gy nt nq l nr ns">  // constant<br/>  <strong class="na jd">const CatTreat(this.quantity);</strong><br/>}</span></pre><ul class=""><li id="588d" class="nb nc it lf b lg lh lj lk lm nd lq ne lu nf ly ng nh ni nj bi translated"><strong class="lf jd">工厂</strong> —当实现一个不总是创建其类的新实例的构造函数时；工厂构造函数可能返回一个缓存的实例，进行对象池，或者返回一个子类型的实例；工厂构造者没有访问<code class="fe mx my mz na b">this</code>的权限。</li></ul><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="504b" class="no mb it na b gy np nq l nr ns">import 'dart:math';</span><span id="f5d6" class="no mb it na b gy nt nq l nr ns">class Cat extends Pet {<br/>  DateTime birthday;<br/>  Cat(this.birthday);<br/>  // delegating to main constructor<br/>  Cat.withBirthday(DateTime birthday) : this(birthday);<br/>}<br/>class Dog extends Pet {<br/>  DateTime birthday;<br/>  Dog(this.birthday);<br/>  // delegating to main constructor<br/>  Dog.withBirthday(DateTime birthday) : this(birthday);<br/>}<br/>// factory<br/>class <strong class="na jd">Pet</strong> {<br/>  Pet();<br/>  <strong class="na jd">factory</strong> Pet.withBirthday(DateTime birthday) {<br/>    bool isCat = Random.secure().nextBool();<br/>    return isCat?Cats(birthday):Dog(birthday);<br/>  }<br/>}</span></pre><p id="866d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">上面的Pet factory构造函数会随机返回一只猫或一只狗(Pet的子类)。</p><h2 id="6f22" class="no mb it bd mc nu nv dn mg nw nx dp mk lm ny nz mm lq oa ob mo lu oc od mq iz bi translated"><strong class="ak">可调用类</strong></h2><p id="8c94" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">Dart类也可以表现得像函数一样(它们可以被调用、接受参数并返回某些内容)。</p><p id="a424" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了实现这一点，我们必须在类中定义<code class="fe mx my mz na b">call()</code>方法。</p><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="1261" class="no mb it na b gy np nq l nr ns">class Cat {<br/>  DateTime birthday;</span><span id="159c" class="no mb it na b gy nt nq l nr ns">  Cat(this.birthday);</span><span id="1532" class="no mb it na b gy nt nq l nr ns">  String call() {<br/>    print('Meow!');<br/>  }<br/>}<br/>void main() {<br/>  var cat = Cat(DateTime.now());<br/>  cat(); <br/>  // prints<br/>  // Meow!<br/>}</span></pre><h2 id="b907" class="no mb it bd mc nu nv dn mg nw nx dp mk lm ny nz mm lq oa ob mo lu oc od mq iz bi translated">发电机</h2><p id="fbb1" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">当我们需要延迟产生一系列值时，就会用到生成器。Dart支持两种类型的生成器函数:</p><ul class=""><li id="c7ca" class="nb nc it lf b lg lh lj lk lm nd lq ne lu nf ly ng nh ni nj bi translated">返回可迭代对象的同步生成器</li><li id="8b1b" class="nb nc it lf b lg oe lj of lm og lq oh lu oi ly ng nh ni nj bi translated">以及返回流对象的异步生成器</li></ul><p id="98d5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了实现<strong class="lf jd">同步</strong>生成器，我们将函数体标记为<code class="fe mx my mz na b">sync*</code>，并使用<code class="fe mx my mz na b">yield</code>语句返回值:</p><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="0e13" class="no mb it na b gy np nq l nr ns">Iterable&lt;Cat&gt; kittens(int toSpawn) sync* {<br/>  int kittenIndex = 0;<br/>  while(kittenIndex &lt; n) {<br/>    kittenIndex++;<br/>    yield Cat.baby();<br/>  }<br/>}</span></pre><p id="6111" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了实现一个<strong class="lf jd">异步</strong>生成器，我们将函数体标记为<code class="fe mx my mz na b">async*</code>，并使用<code class="fe mx my mz na b">yield</code>语句返回值:</p><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="0f35" class="no mb it na b gy np nq l nr ns">Stream&lt;Cat&gt; kittens(int toSpawn) async* {<br/>  int kittenIndex = 0;<br/>  while(kittenIndex &lt; n) {<br/>    kittenIndex++;<br/>    yield Cat.baby();<br/>  }<br/>}</span></pre><p id="b91a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们使用递归调用，可以通过使用<code class="fe mx my mz na b">yield*</code>来提高性能:</p><pre class="ks kt ku kv gt nk na nl nm aw nn bi"><span id="007d" class="no mb it na b gy np nq l nr ns">Iterable&lt;Cat&gt; kittens(int toSpawn) sync* {<br/>  if(toSpawn &gt; 0) {<br/>    yield Cat.baby;<br/>    yield* kittens(toSpawn - 1);<br/>  }<br/>}</span></pre><h2 id="bbcd" class="no mb it bd mc nu nv dn mg nw nx dp mk lm ny nz mm lq oa ob mo lu oc od mq iz bi translated">变量</h2><p id="6605" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">有两种风格:<strong class="lf jd">实例</strong>和<strong class="lf jd">类</strong>变量。</p><p id="b4ab" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">默认情况下，所有未初始化的变量都有值<code class="fe mx my mz na b">null</code>。此外，所有非final的变量都会生成一个隐式的getter和setter。最后一个不会生成setter。</p><p id="1218" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">默认情况下，变量是实例变量。如果在声明时初始化(而不是在构造函数或方法中)，它们的值在创建实例时设置，这是在构造函数及其初始值设定项列表执行之前。</p><p id="2555" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了创建一个类变量，我们将使用<code class="fe mx my mz na b">static</code>关键字。这些对于类范围的状态和常量很有用。它们在被使用之前不会被初始化。</p><h2 id="1192" class="no mb it bd mc nu nv dn mg nw nx dp mk lm ny nz mm lq oa ob mo lu oc od mq iz bi translated">方法</h2><p id="929a" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">方法是为对象提供行为的函数。</p><p id="1968" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">与变量的情况一样，这里也有两种风格:<strong class="lf jd">实例</strong>和<strong class="lf jd">类</strong>方法。</p><p id="1269" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对象上的实例方法可以访问实例变量和<code class="fe mx my mz na b">this</code>。</p><p id="3da3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">静态方法(类方法)不对实例进行操作，因此不能访问<code class="fe mx my mz na b">this</code>。它们最好用作编译时常数(例如，作为参数传递给常数构造函数)。对于常见或广泛使用的实用程序和功能，我们应该使用顶级函数，而不是静态方法。</p><h1 id="fea3" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated"><strong class="ak">封装</strong></h1><p id="31f4" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">Dart不包含用于限制访问的关键字，像Java中使用的<code class="fe mx my mz na b">public</code>、<code class="fe mx my mz na b">protected</code>或<code class="fe mx my mz na b">private</code>。封装发生在库级，而不是类级。</p><p id="d216" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有一个简单的规则:任何以下划线<code class="fe mx my mz na b">_</code>开头的标识符(类、类成员、顶级函数或变量)对其库都是私有的。</p><h1 id="ead1" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated">继承和构成</h1><p id="431c" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated"><strong class="lf jd">继承</strong>允许将一个类扩展到该类的一个特殊版本。如前所述，所有的类都继承自对象类型，只需声明一个类，我们就扩展了对象类型。Dart允许单个直接继承，并对<strong class="lf jd"> mixins </strong>有特殊支持，可用于扩展类功能，无需直接继承，模拟多个继承，重用代码。这就是<strong class="lf jd">构图</strong>的实现方式。</p><p id="3d7c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">混合是在多个类层次结构中重用类代码的一种方式。要使用mixin，使用关键字<code class="fe mx my mz na b">with</code>后跟一个或多个mixin名称。要指定只有某些类型可以使用mixin——例如，因此您的mixin可以调用它没有定义的方法——使用<code class="fe mx my mz na b">on</code>来指定所需的超类。</p><p id="6811" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">没有<code class="fe mx my mz na b">final class</code>，所以一个类总是可以被扩展的。</p><h1 id="0ed3" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated">抽象</h1><p id="639e" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated"><strong class="lf jd">抽象</strong>是我们定义一个类及其本质特征的过程，把实现留给它的子类。</p><p id="845a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了声明一个抽象类，我们使用了<code class="fe mx my mz na b">abstract</code>关键字。这些类不能被实例化，但对定义接口很有用。抽象类可以有抽象方法。</p><p id="0d29" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">没有接口关键字。它的工作方式是每个声明的类定义一个<strong class="lf jd">隐式接口</strong>，包含一个类和它实现的任何接口的所有实例成员。这意味着任何类都可以由其他人实现，而无需扩展它。</p><p id="dad2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一个类可以通过使用<code class="fe mx my mz na b">implements</code>关键字实现一个或多个接口。</p><h1 id="7875" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated">多态性</h1><p id="ed4a" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated"><strong class="lf jd">多态性</strong>通过继承实现，代表一个对象复制另一个对象行为的能力(int<strong class="lf jd">int</strong>或double 也是一个<strong class="lf jd"> num </strong>)。</p><p id="13ba" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以使用<code class="fe mx my mz na b">extends</code>创建一个<strong class="lf jd">子类</strong>和<code class="fe mx my mz na b">super</code>来引用<strong class="lf jd">超类</strong>。</p><p id="a9f8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">子类通常覆盖实例方法、getters和setters。我们可以使用<code class="fe mx my mz na b">@override</code>注释来表明我们正在覆盖一个成员。</p><p id="74a1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Dart不允许<strong class="lf jd">过载</strong>。为了克服这一点，我们可以使用灵活的参数定义(<strong class="lf jd">可选</strong>和<strong class="lf jd">位置</strong>)。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="8353" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">总的来说，Dart提供了我们使用OOP范例所需的所有功能。</p><p id="6f99" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在<a class="ae lz" href="https://medium.com/tag/fluttering-dart/archive" rel="noopener"> <strong class="lf jd">飞舞的Dart </strong> </a>系列的下一部分，我们将深入研究<a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-futures-and-isolates-6b4bce6d804b" rel="noopener">的未来并隔离</a>以发现如何克服Dart的单线程缺点。</p><div class="oq or gp gr os ot"><a href="https://medium.com/@constanting/fluttering-dart-futures-and-isolates-6b4bce6d804b" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd jd gy z fp oy fr fs oz fu fw jc bi translated">飞舞的飞镖:未来与孤立</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">如何克服单线程的缺点</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph lb ot"/></div></div></a></div><p id="f25e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">就这些！</p></div></div>    
</body>
</html>