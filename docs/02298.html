<html>
<head>
<title>How We Use Our Typescript Type Information at Runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何在运行时使用Typescript类型信息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-we-use-our-typescript-type-information-at-runtime-6e95b801cfeb?source=collection_archive---------3-----------------------#2020-03-04">https://levelup.gitconnected.com/how-we-use-our-typescript-type-information-at-runtime-6e95b801cfeb?source=collection_archive---------3-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e43" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从您的类型生成一个JSON模式，世界就是您的了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/bdaad7eaf32a5818da8a7ea5137d7a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*bTI1rr7d_UfWyTzDB3wOTg.jpeg"/></div></figure><p id="74b0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我第一次听说Typescript的时候——老实说——我是一个普通的新手，我可能会问这样一个问题‘我可以在程序运行的时候使用这些类型吗？’</p><p id="29e7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">无论如何，这听起来像是编程新手可能会问的问题。事实是，而且永远是，你不能在运行时使用你的类型。为什么不呢？你们中的大多数人可能已经知道了，但是为了完整起见，你们不能知道，因为Javascript(Typescript编译成的运行时语言)不<em class="lm">包含任何关于你的类型的信息。使用不存在的信息有点困难。</em></p><h2 id="2ca4" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">输入，JSON模式</h2><p id="9b3a" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">在这里，我趁机无耻地插入了一个<strong class="ks iu">极其</strong>方便的库，名为<a class="ae ml" href="https://github.com/vega/ts-json-schema-generator" rel="noopener ugc nofollow" target="_blank"> ts-json-schema-generator </a>(无耻是因为它不是我写的)。如果你点击这个链接，你会发现它是由<a class="ae ml" href="https://github.com/mrix" rel="noopener ugc nofollow" target="_blank"> mrix </a>发起的，大部分内容是由<a class="ae ml" href="https://github.com/domoritz" rel="noopener ugc nofollow" target="_blank"> domoritz </a>贡献的。他们值得一提，因为他们写了这么棒的工具(也因为domoritz接受了我的几个拉请求，谢谢伙计！).</p><p id="b818" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么<a class="ae ml" href="https://github.com/vega/ts-json-schema-generator" rel="noopener ugc nofollow" target="_blank">ts-JSON-schema-generator</a>到底是什么，我们为什么需要它？嗯，从这个库的名字就可以看出，它接受您的Typescript类型信息，并转换成一个<a class="ae ml" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON模式</a>。什么是JSON模式？很高兴你问了。下面是一个JSON模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d84f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它是一个普通的老式JSON对象，根据JSON模式规范(见上面的链接)具有特定的结构。对于那些在家玩的人来说，JSON对象<em class="lm">可以在运行时使用。</em></p><p id="dc82" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您最终得到的JSON模式是您的Typescript类、接口、属性、类型别名等的准确表示。不仅如此，您还可以向上面的任何内容添加<a class="ae ml" href="https://jsdoc.app/about-getting-started.html" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>注释，它们也将被带到您的模式中。下面是一个Typescript输入和生成的JSON模式的快速示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">ts-json-schema-generator的Typescript输入</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">上述类型和注释产生的JSON模式输出</figcaption></figure><h2 id="1f87" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">纯粹的魔法</h2><p id="47fa" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">是不是很不可思议？看着这个模式，你可能已经对一些可能的用例垂涎三尺了，但是我将介绍一些我和我的团队在<a class="ae ml" href="https://www.nightlife.com.au/" rel="noopener ugc nofollow" target="_blank"> Nightlife Music </a>(好吧，那是一个无耻的插件)已经实现或计划实现的功能，JSON模式是功能的核心:</p><ol class=""><li id="477b" class="ms mt it ks b kt ku kw kx kz mu ld mv lh mw ll mx my mz na bi translated"><strong class="ks iu">验证</strong>——使用另一个同样棒的工具，另一个JSON模式验证器或<a class="ae ml" href="https://github.com/epoberezkin/ajv" rel="noopener ugc nofollow" target="_blank"> ajv </a>，我们可以在运行时简单地通过传入对象和我们的模式来验证任何对象。我们甚至可以得到某种格式的错误输出，这种格式可以通过编程来实现，比如在表单上显示针对无效字段的错误，自动修复无效属性，等等。</li><li id="bb87" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="ks iu">授权</strong> —如上，但是我们传入的模式包含一个对象可以包含的所有可能的有效值。例如，如果我们的用户只允许在一个api调用中发送1、2或3(如模式中所指定的),但是他们发送了4，那么请求将被拒绝。</li><li id="26c0" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="ks iu">动态</strong>表单生成——因为模式只是简单的JSON对象，所以您可以使用它们作为生成动态表单的输入，比如Angular的<a class="ae ml" href="https://angular.io/guide/reactive-forms" rel="noopener ugc nofollow" target="_blank">反应式表单</a>。使用上面描述的验证方法，您已经有了一个在前端<strong class="ks iu">和后端<strong class="ks iu">进行全面验证的机制。</strong></strong></li><li id="da26" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="ks iu"> API文档</strong> —以JSON模式为例，它不仅包含关于属性类型的信息，还包含描述、最小/最大值、正则表达式模式等。并在网站或本地手机应用程序中进行像样的标记。</li><li id="51bf" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="ks iu"> API测试工具</strong> —将您的动态表单与您的API文档模式相结合，您就拥有了一个成熟的API测试工具，您可以在其中尝试各种输入并验证响应。您甚至可以将它与一个模式相结合，该模式已经填充了基于用户授权的有效值，并且只显示他们有权访问的API请求的表单。</li><li id="a962" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="ks iu">带<a class="ae ml" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates" rel="noopener ugc nofollow" target="_blank">类型谓词</a>的type guards</strong>——在将变量转换为特定类型时，您不再需要硬编码属性名或属性值，您可以根据一个全面的模式来验证它！示例:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">使用JSON模式验证的泛型类型保护示例</figcaption></figure><p id="9ec9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">7.<strong class="ks iu"> NoSQL数据库模式</strong>——像<a class="ae ml" href="https://docs.mongodb.com/manual/core/schema-validation/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>这样的文档数据库可以采用JSON模式进行数据库级验证。当多个代码库写入同一个文档存储时，这可以使您不必在多个代码库中编写验证逻辑。</p><p id="bf00" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">8.<strong class="ks iu">您的类型的组织范围的真实来源</strong> —您现在有了您的类型脚本类型的相对语言不可知的表示，因此该模式可以在不同语言的不同代码库中用于这里列出的所有功能。潜在地，你的整个组织类型的真实来源可以用Typescript编写，并在不同的项目之间共享——web应用(后端和前端)、本地移动应用、本地PC应用，你能想到的。我认为这非常强大。</p><p id="80ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">9.可能性实际上是无穷无尽的。</p><p id="3cee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上面的每一个用例可能都值得单独发表一篇文章，所以如果你想了解关于上面任何一个的更多信息，请留下评论，我会写一篇更详细的文章。</p><p id="e291" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您或您的团队对您所看到的感兴趣，请帮自己一个忙，查看一下<a class="ae ml" href="https://github.com/vega/ts-json-schema-generator" rel="noopener ugc nofollow" target="_blank"> ts-json-schema-generator </a>和<a class="ae ml" href="https://github.com/epoberezkin/ajv" rel="noopener ugc nofollow" target="_blank"> ajv </a>。你的世界将永远改变！</p><p id="dcae" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢阅读。</p><h2 id="f64c" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">资源</h2><ol class=""><li id="933e" class="ms mt it ks b kt mg kw mh kz ng ld nh lh ni ll mx my mz na bi translated"><a class="ae ml" href="https://github.com/vega/ts-json-schema-generator" rel="noopener ugc nofollow" target="_blank">ts-JSON-schema-generator</a></li><li id="4e47" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><a class="ae ml" href="https://github.com/epoberezkin/ajv" rel="noopener ugc nofollow" target="_blank">另一个JSON模式验证器</a></li><li id="181e" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><a class="ae ml" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON模式</a></li><li id="96f7" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated">角度的<a class="ae ml" href="https://angular.io/guide/reactive-forms" rel="noopener ugc nofollow" target="_blank">反应形式</a></li><li id="43b5" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><a class="ae ml" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates" rel="noopener ugc nofollow" target="_blank">类型谓词</a></li><li id="4253" class="ms mt it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated">MongoDB <a class="ae ml" href="https://docs.mongodb.com/manual/core/schema-validation/" rel="noopener ugc nofollow" target="_blank">模式验证</a></li></ol></div></div>    
</body>
</html>