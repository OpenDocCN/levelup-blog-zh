<html>
<head>
<title>GitOps: CI/CD using GitHub Actions and ArgoCD on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitOps:在Kubernetes上使用GitHub操作和ArgoCD的CI/CD</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/gitops-ci-cd-using-github-actions-and-argocd-on-kubernetes-909d85d37746?source=collection_archive---------0-----------------------#2021-12-27">https://levelup.gitconnected.com/gitops-ci-cd-using-github-actions-and-argocd-on-kubernetes-909d85d37746?source=collection_archive---------0-----------------------#2021-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d8f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用ArgoCD和GitOps在自动气象站EKS集群上部署舵图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06606fe7463cac3360e72e67a0782ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzsMOm_iHwlmgD0Rlka5tQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">约瑟夫·巴里恩托斯在<a class="ae ky" href="https://unsplash.com/s/photos/ship-steering-wheel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bdf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> G </span>更简单地说，GitOps是实现云原生应用程序持续部署的一种方式。</p><p id="3ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在当今的<strong class="lb iu">敏捷</strong>世界中，现代应用程序的开发都考虑到了速度和规模，而在现实世界中，我们每天都要将代码部署到生产环境中数百次，因此，为了实现这一点，我们需要获得DevOps最佳实践，比如<strong class="lb iu"> GitOps就是其中之一，因为它采用声明式方法。</strong></p><p id="9979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我不会过多讨论什么是GitOps，而是向您展示如何通过设置一个真实的<strong class="lb iu"> CI/CD </strong>工作流来实现它，该工作流包含<strong class="lb iu"> GitHub Actions </strong>和<strong class="lb iu"> ArgoCD </strong>，这是一个非常著名的<strong class="lb iu"> GitOps工具，用于将应用程序部署到Kubernetes </strong>。这是实现GitOps的另一种方式。</p><p id="fbf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在这篇文章中，我使用了AWS EKS集群，如果你不知道如何创建一个集群，那么你可以参考我的这篇文章 。</p><h2 id="140b" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">工作流程</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/50e823be8e92abc018452505aa3159b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmfZlifjlBzqka4heoRg-w.png"/></div></div></figure><p id="719c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图中，你可以看到我正在使用<strong class="lb iu"> GitHub Actions </strong>来构建应用程序的Docker映像，然后将该映像推送到私有的<strong class="lb iu"> ECR(弹性容器映像)</strong>存储库。然后在Git repo中的Helm图表中更新新映像的版本。</p><p id="9a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦掌舵图发生变化，<strong class="lb iu"> ArgoCD </strong>就会检测到，并开始在Kubernetes集群中推出和部署新的掌舵图。支持GitOps的一个关键因素是将CI与CD分开。<strong class="lb iu">CI执行完成后，工件将被推送到存储库，ArgoCD将负责保管CD。最棒的是一切都将是私人的。</strong></p><h1 id="68d5" class="my mf it bd mg mz na nb mj nc nd ne mm jz nf ka mp kc ng kd ms kf nh kg mv ni bi translated">履行</h1><p id="a462" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们首先必须创建一个私有的GitHub存储库，并将应用程序源代码放入其中，或者您可以使用任何现有的存储库。这里只是为了演示，我使用Nginx服务器，所以在GitHub repo中放了一个简单的HTML网页和docker文件。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5963" class="me mf it np b gy nt nu l nv nw">## index.html<br/>&lt;Html&gt;<br/>&lt;body&gt;<br/>&lt;center&gt;<br/>&lt;h1&gt;This is the demo for Continuous Deployment on Kubernetes with GitOps and ArgoCD&lt;/h1&gt; &lt;br&gt;<br/>&lt;br&gt;<br/>&lt;img src='<a class="ae ky" href="https://raw.githubusercontent.com/Ajaypathak372/cloud-task2/master/task2.jpg'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/Ajaypathak372/cloud-task2/master/task2.jpg'</a> width=600 height=480&gt;<br/>&lt;/center&gt;<br/>&lt;/body&gt;<br/>&lt;/Html&gt;</span><span id="563d" class="me mf it np b gy nx nu l nv nw">## Dockerfile<br/>From nginx:latest<br/>COPY index.html <!-- -->/usr/share/nginx/html</span></pre><h2 id="883b" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">设置GitHub操作</h2><p id="4899" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">接下来，我们必须在存储库中设置<strong class="lb iu"> GitHub Actions </strong>以从repo中的docker文件构建docker映像，然后将映像推送到AWS ECR私有存储库。这实际上是我们工作流程中的<strong class="lb iu"> GitOps </strong>部分。</p><p id="a805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在GitHub库中点击<strong class="lb iu">动作</strong>并选择<strong class="lb iu">自己建立一个工作流，</strong>它会在路径<strong class="lb iu">下创建一个YAML文件。github/workflows/main.yml。这是我们在GitOps部分需要创建和修改的唯一文件。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/a9d44c0ccd74d306091885bbb2f9cc4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMNDxt-_o9z7dXckPrVwyQ.png"/></div></div></figure><p id="35c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们在这个工作流程中需要的文件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">。github/workflows/main.yml </strong></figcaption></figure><p id="aba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的文件中，你可以清楚地看到，我已经给了我的AWS帐户IAM密钥和访问密钥，以便GitHub能够访问我的ECR存储库并推送图像。此外，我没有直接给出AWS凭证(即明文)，如果您在团队中工作，那么强烈建议您将凭证存储在GitHub存储库中的秘密位置，然后在文件中给出这些秘密环境变量的名称。</p><blockquote class="ob oc od"><p id="12a1" class="kz la oe lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">在Github repo中创建秘密非常简单，只需转到存储库<strong class="lb iu">设置</strong>选择<strong class="lb iu">秘密、</strong>并点击<strong class="lb iu">新建存储库秘密</strong>，然后给你的秘密变量和值起个名字。然后，您可以在存储库中的任何地方使用该变量。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/3b3320dc9e135ba7a312a94819ecbd3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kp5b5o8VdwP8cpwkBVGj0g.png"/></div></div></figure><p id="0771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，在上面的main.yml文件中，请注意我是如何更新<strong class="lb iu">舵图</strong>的<strong class="lb iu"> Values.yml </strong>文件中新图像的版本的。我在这个演示中使用了一个样本舵图，你可以在我的<a class="ae ky" href="https://github.com/Ajaypathak372/gitops-argocd.git" rel="noopener ugc nofollow" target="_blank">库</a>中找到。或者你可以创建自己的舵图，并上传到Github库。</p><p id="d0d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<strong class="lb iu"> GitOps CI </strong>部分已经准备好了，所以当我们提交到主分支时，该文件将自动被触发，开始构建和推送映像，并更新Helm Chart中新映像的版本，最终触发ArgoCD在Kubernetes集群中部署Helm Chart。在下图中，你可以看到我们的构建是成功的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/b52afd08a0045f0a10bafadce2223df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAKRDIiyxcTX0JLBqzkpUA.png"/></div></div></figure><h2 id="9c0b" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">在Kubernetes集群中安装ArgoCD</h2><p id="e675" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这里，我们正在EKS集群中安装ArgoCd及其舵图。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0516" class="me mf it np b gy nt nu l nv nw">helm repo add argo <a class="ae ky" href="https://argoproj.github.io/argo-helm" rel="noopener ugc nofollow" target="_blank">https://argoproj.github.io/argo-helm</a><br/>helm install argocd argo/argo-cd --set server.service.type=LoadBalancer</span></pre><p id="f3db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经公开了带有HTTP负载平衡器服务的ArgoCD，只是为了演示的目的，你可以用HTTPS的<strong class="lb iu">入口</strong>来公开它，如果你愿意，我可以展示给你看。</p><p id="28ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以看到ArgoCD已经成功安装并运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/c9ef22911b0ec060664c4b1c301e0132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zovy3YaoX9C6wctC9554lQ.png"/></div></div></figure><p id="ba5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们必须在ArgoCD中创建一个应用程序，在这个应用程序中，我们基本上定义了我们的应用程序的舵图位于哪里，部署在哪里，以及一些其他的小配置。</p><p id="5f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是由于我们的头盔图所在的GitHub存储库是私有的，所以我们首先需要将存储库与ArgoCD连接起来。这非常简单，只需进入ArgoCD中的<strong class="lb iu">设置&gt;存储库</strong>并选择您想要的连接方式，这里我使用HTTPS进行连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/3fa60cf8919a18b6d11621d65cce6c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yScekyS6Y9jVEpQlJfLLAg.png"/></div></div></figure><p id="49cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们必须放置<strong class="lb iu">个人访问令牌(PAT) </strong>而不是密码，因为密码现在被GitHub禁用，你可以在这里看到如何创建PAT的<a class="ae ky" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e1ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在YAML文件中声明所有内容或从WebUI创建应用程序，这里我从WebUI创建应用程序。这就是我们如何在ArgoCD中创建应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/ac944d9422b16943d688373ec1409704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0jPgJF4Mpo3XfzBeVQ2cg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图1:在ArgoCD中创建应用程序</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/66379f0ccfbd7def4099337184d22353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A--BZNLXqiDj8hD4vj85Cw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图2:在ArgoCD中创建应用程序</figcaption></figure><p id="55f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图2中，请注意我已经定义了GitHub库和我的应用程序导航图的路径。现在，当应用程序成功创建时，它看起来像这样</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/0de672f114dd117cd22c5043389cf4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yqd8ekexebxWtjgRZMOnQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ArgoCD应用程序</figcaption></figure><p id="f55f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以从浏览器访问我们的WebApp</p><p id="ec08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BooooooM！！！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b73721a2454af92ce1502f4b98fe61c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdcnk2Ox1pQd_ZW5WUcB-w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Nginx webapp输出</figcaption></figure><p id="3864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的CI/CD工作流已经完全准备好，完全自动化，所以当开发人员在主分支提交时，更改将自动反映在主站点上，我们不必做任何事情，一切都将完全自动化。是不是看起来很酷:)</p><p id="4fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简短的视频，描述了这个工作流程是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol oa l"/></div></figure><p id="6f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想现在您已经理解了如何通过使用GitHub Actions作为CI的一部分和ArgoCD作为CD的一部分来实现GitOps，从而创建一个完全自动化的CI/CD工作流。以及如何在Kubernetes中用ArgoCD部署舵图。最棒的是，我们的Github repo和图像注册表都是私有的。</p><p id="17ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">但这只是实现GitOps工作流的一种方法，正如我已经说过的，GitOps不只是关于CI/CD和IaC，它是非常先进的……</strong></p><p id="cdc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那都是我这边的…..</p><p id="a65e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，并了解一些有趣的概念。请与我一起关注更多这样的文章。</p><p id="62b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！！</p><p id="fd08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里 找到完整的资源库<a class="ae ky" href="https://github.com/Ajaypathak372/gitops-argocd.git" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">。</strong></a></p><p id="5816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/ajay-pathak372" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上与我联系</p></div></div>    
</body>
</html>