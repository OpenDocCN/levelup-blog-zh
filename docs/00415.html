<html>
<head>
<title>React Hooks and D3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩和D3</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-and-d3-39be1d900fb?source=collection_archive---------0-----------------------#2019-02-13">https://levelup.gitconnected.com/react-hooks-and-d3-39be1d900fb?source=collection_archive---------0-----------------------#2019-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6d68" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React钩子如何使D3数据可视化更具可伸缩性，更易于维护。</h2></div><p id="dffe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">TL；博士</strong></p><p id="5ae9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用React作为D3的容器来管理SVG和其中的一切，应用程序级的管理应该由React来完成。有关最少的可行示例，请参见本文底部的代码清单。</p><h1 id="16ae" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated"><strong class="ak">走近</strong></h1><p id="a21e" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">已经有很多文章写了React和D3的世界是如何一起工作的。就我个人而言，我找到的最好的概述是由<a class="ly lz ep" href="https://medium.com/u/4607b4069d83?source=post_page-----39be1d900fb--------------------------------" rel="noopener" target="_blank"> Shirley Wu </a>在<a class="ae ma" href="http://slides.com/shirleywu/deck#/4" rel="noopener ugc nofollow" target="_blank">这个演讲</a>中以及由<a class="ly lz ep" href="https://medium.com/u/93931cb7e345?source=post_page-----39be1d900fb--------------------------------" rel="noopener" target="_blank"> Thibaut Tiberghien </a>在<a class="ae ma" href="https://medium.com/@tibotiber/react-d3-js-balancing-performance-developer-experience-4da35f912484" rel="noopener">这篇文章</a>中做出的。如果你想知道更多关于这个问题的背景，我鼓励你看看这些文章。</p><p id="f404" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，有了React钩子，事情变得简单了，但是我们需要稍微调整一下我们的方法，所以让我们从如何让React和D3一起工作的新想法开始。</p><p id="2dea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的做法是在“React world”和“D3 world”之间设置一个清晰的边界。这条边界线是一个SVG(或Canvas)元素，是所有d3可视化的根。根元素和它里面的任何东西都属于D3世界，它上面的所有东西都属于React世界。</p><p id="5350" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种解决方案的优点是:</p><ul class=""><li id="767f" class="mb mc iq kh b ki kj kl km ko md ks me kw mf la mg mh mi mj bi translated">我们不在一个React组件中混合D3和React逻辑，更干净的代码=快乐的开发。</li><li id="99c6" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">我们可以利用D3转换和D3更新模式的全部能力，</li><li id="65ee" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">我们可以利用React状态管理的全部功能，并可以连接必要的外部功能(如获取调用或其他React组件的交互)，</li><li id="1704" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated">我们可以为非react项目重用D3组件，因为它是独立的模块。</li></ul><h1 id="9cd7" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated"><strong class="ak">反应元件</strong></h1><p id="5bc6" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">React组件呈现SVG容器(通常是一个div元素),用<code class="fe mp mq mr ms b">useRef</code>钩子传递给D3 world。React不会关心SVG内部的内容和它的任何变化，直到被D3组件调用明确触发。React只是给了一个SVG容器，并说‘嘿，D3，在这里施展你的魔法，如果你需要什么，请告诉我’。</p><p id="f436" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，同一个React组件也可以为我们的可视化呈现额外的控件(比如下拉菜单和按钮),但是为了保持我们的例子简单，我们现在将省略这一部分。</p><p id="2de8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">空React组件的初始设置如下所示:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ea37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只返回<div>作为我们可视化的容器，并保留ref以备将来使用。</div></p><h1 id="0a78" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated"><strong class="ak"> D3组件</strong></h1><p id="9f07" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">接下来，我们有D3组件。这是我们的视觉化，最小的设置可以只是一个函数(但会有一堆函数)，比如:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">D3组件最小设置</figcaption></figure><p id="5263" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将很好地工作，但对于更复杂的可视化，我们可能希望更好地布局我们的函数——将它们包装在一个类中，像这样:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">D3组件作为一个类别</figcaption></figure><p id="867c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于如何布局更复杂的D3组件的一些有用的提示可以在文章<a class="ae ma" href="http://www-cs-students.stanford.edu/~amitp/" rel="noopener ugc nofollow" target="_blank"> Amit Patel </a> <a class="ae ma" href="https://www.redblobgames.com/making-of/line-drawing/#steps" rel="noopener ugc nofollow" target="_blank">“制作:线条画教程”</a>中找到。它包含了为D3组件构建类的例子，以及如何将D3功能方法与OOP原则结合起来。</p><h1 id="1924" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated"><strong class="ak">将元件接线在一起</strong></h1><p id="e0c3" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">有了上面的D3组件，我们现在可以回到React世界了。</p><p id="8270" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们需要的是向D3组件提供渲染SVG所需的一切。通常这些至少是:我们已经拥有的容器元素引用(通过<code class="fe mp mq mr ms b">useRef</code>钩子)，数据，宽度和高度可视化(通过<code class="fe mp mq mr ms b">useState</code>钩子)。</p><p id="db8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了连接所有这些状态，我们将使用<code class="fe mp mq mr ms b">useEffect</code>钩子。看看下面的代码:</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">反应元件用钩子钩住d3元件。</figcaption></figure><p id="1c43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每一个动作，我们都建立新的<code class="fe mp mq mr ms b">useEffect</code>钩子。我们将把它们提取为独立的函数，这样代码会更容易阅读。</p><p id="adc3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们很可能想要在D3和React之间建立双向连接。</p><h1 id="4160" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated"><strong class="ak">对D3通信做出反应</strong></h1><p id="8752" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">类似于处理resize事件。我们将创建另一个<code class="fe mp mq mr ms b">useEffect</code>钩子来监听窗口调整事件，并更新React组件的宽度和高度状态(我已经添加了一些去抖动功能，所以更新不会太频繁)。</p><pre class="mt mu mv mw gt ne ms nf ng aw nh bi"><span id="70b4" class="ni lc iq ms b gy nj nk l nl nm">useEffect(() =&gt; {</span><span id="64c4" class="ni lc iq ms b gy nn nk l nl nm">  let resizeTimer; <br/>  const handleResize = () =&gt; {<br/>    clearTimeout(resizeTimer); <br/>    resizeTimer = setTimeout(function() {<br/>      setWidth(window.innerWidth);<br/>      setHeight(window.innerHeight);<br/>    }, 300);<br/>  };</span><span id="8201" class="ni lc iq ms b gy nn nk l nl nm">  window.addEventListener(‘resize’, handleResize);</span><span id="5a88" class="ni lc iq ms b gy nn nk l nl nm">  return () =&gt; {<br/>    window.removeEventListener(‘resize’, handleResize);<br/>  };</span><span id="ef4b" class="ni lc iq ms b gy nn nk l nl nm">}, []);</span></pre><p id="66ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，当组件将被卸载时，我们使用<code class="fe mp mq mr ms b">return</code>语句来删除事件监听器。</p><p id="ed7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，为了让D3组件响应React状态更新，我们只需要在每个<code class="fe mp mq mr ms b">width</code>或<code class="fe mp mq mr ms b">height</code>状态改变时调用适当的方法:</p><pre class="mt mu mv mw gt ne ms nf ng aw nh bi"><span id="c2bd" class="ni lc iq ms b gy nj nk l nl nm">useEffect(() =&gt; {</span><span id="b429" class="ni lc iq ms b gy nn nk l nl nm">  vis &amp;&amp; vis.resize(width, height);</span><span id="08c2" class="ni lc iq ms b gy nn nk l nl nm">}, [ width, height ]);</span></pre><p id="f075" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在调用<code class="fe mp mq mr ms b">vis.resize</code>之前使用<code class="fe mp mq mr ms b">vis &amp;&amp;</code>，因为resize事件可能在<code class="fe mp mq mr ms b">vis</code>被创建(数据被加载)之前发生。</p><h1 id="22a2" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated"><strong class="ak"> D3反应过来通讯</strong></h1><p id="b0fe" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">假设我们的D3可视化有可点击的数据点，这些数据点触发了React world中的一些视图更新。</p><p id="3c5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在D3组件中，我们可能有这样的东西:</p><pre class="mt mu mv mw gt ne ms nf ng aw nh bi"><span id="7f98" class="ni lc iq ms b gy nj nk l nl nm">d3.selectAll(‘.datapoint’)<br/>  .on(‘mouseup’, d =&gt; this.setActiveDatapoint(d));</span></pre><p id="5e79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe mp mq mr ms b">setActiveDatapoint</code>为箭头函数:</p><pre class="mt mu mv mw gt ne ms nf ng aw nh bi"><span id="6c3c" class="ni lc iq ms b gy nj nk l nl nm">setActiveDatapoint = (d) =&gt; {<br/>  // some internal code here<br/>  this.props.onDatapointClick(d);<br/>}</span></pre><p id="d9e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么用箭头函数？类中的箭头函数自动绑定到该类的实例。这很重要，因为我们在mouseup回调中使用了<code class="fe mp mq mr ms b">this</code>关键字。</p><p id="796d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在这里使用普通的类方法，那么<code class="fe mp mq mr ms b">this.setActiveDatapoint(d)</code>中的<code class="fe mp mq mr ms b">this</code>将引用<code class="fe mp mq mr ms b">.datapoint</code>选择而不是我们的<code class="fe mp mq mr ms b">vis</code>对象。</p><p id="f636" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有箭头函数(<a class="ae ma" href="https://medium.com/@charpeni/arrow-functions-in-class-properties-might-not-be-as-great-as-we-think-3b3551c440b1" rel="noopener">可能不如类方法</a>)也能工作的另一种方法是使用类方法，并用(最常见的)表达式将其绑定在构造函数中:</p><p id="8a05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mp mq mr ms b">this.setActiveDataPoint = this.setActiveDataPoint.bind(this);</code></p><p id="1c5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们可能只有一个D3组件的实例，所以我认为在这里使用箭头没有问题。</p><p id="127c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做的最后一件事是将适当的道具传递给React世界中的D3组件。参见下面的代码最终版本，<code class="fe mp mq mr ms b">onDatapointClick</code>属性包含在React组件的<code class="fe mp mq mr ms b">initVis</code>函数中。</p><h1 id="74fe" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated"><strong class="ak">代码清单</strong></h1><p id="0f39" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">下面是D3和React组件的代码。如上所述，对于React组件，我从useEffect钩子中提取了函数。</p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="4b55" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">放弃</h1><p id="31a7" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">在写这篇文章的时候，React hooks还是一个实验性的提议，请参考<a class="ae ma" href="https://reactjs.org/hooks" rel="noopener ugc nofollow" target="_blank">官方文档</a>任何可能发生的变化。</p><p id="65e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>