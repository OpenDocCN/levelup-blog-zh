<html>
<head>
<title>Flutter Navigator 2.0 for Authentication and Bootstrapping — Part 2: User Interaction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于认证和引导的Flutter Navigator 2.0第2部分:用户交互</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-2-user-interaction-5dc043e7e44a?source=collection_archive---------1-----------------------#2021-03-28">https://levelup.gitconnected.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-2-user-interaction-5dc043e7e44a?source=collection_archive---------1-----------------------#2021-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/da5d1de75a02a38bc4636482334dc915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k81aU7AypC7E76pIHPuxhw.png"/></div></div></figure><ul class=""><li id="4eca" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-1-introduction-d7b6dfdd0849" rel="noopener">第一部分:简介</a></li><li id="7301" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><strong class="ka ir">第二部分:用户互动</strong></li><li id="8a7d" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-3-authentication-93dbcb5f0f0a" rel="noopener">第3部分:认证</a></li><li id="c467" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-4-bootstrapping-6ff60c845331" rel="noopener">第4部分:引导</a></li><li id="4c6f" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">第5部分:网络</a></li></ul><p id="98e3" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在本系列的<a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-1-introduction-d7b6dfdd0849" rel="noopener">第一部分中，</a>我们简要介绍了Navigator 2.0 API，并解释了我们将逐步构建的示例应用程序。在本文中，我们将介绍<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件和<a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">页面API </a>。然后我们将解释如何根据应用程序状态的变化来构建导航堆栈。我们将关注以下导致应用状态变化的用户交互:</p><ul class=""><li id="8ea2" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">通过按列表中的按钮选择颜色和形状边框类型</li><li id="bb16" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">按下应用程序栏中的后退按钮</li><li id="a815" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">按下系统返回按钮(仅限Android)</li></ul><p id="693c" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在介绍<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件和<a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">页面API </a>之前，我们先快速回顾一下在引入Navigator 2.0 API之前我们已经知道的东西，即<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>小部件、<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件和<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>类。</p><h1 id="8b86" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">覆盖部件</h1><p id="61d2" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated">在Flutter应用程序的整个导航系统中，我们有一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>小部件。<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>小部件是一个特殊的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Stack-class.html" rel="noopener ugc nofollow" target="_blank">Stack</a></code>小部件，我们在应用程序的小部件树中多次使用。<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>小部件的子部件浮动在其他小部件上。</p><p id="21c7" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>小工具有一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>对象列表。我们通过<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry/builder.html" rel="noopener ugc nofollow" target="_blank">builder</a></code>属性向<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>小部件提供子小部件。</p><p id="a0c1" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">要在<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>中插入或删除一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>，我们需要在小部件树中找到离小部件最近的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>。在许多情况下，最接近的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>是由<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件创建的。因此，我们不需要在应用程序中构建一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>小部件。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">一种在滑块控件上显示数值指示器的方法</figcaption></figure><h1 id="9186" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">导航器部件</h1><p id="80be" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件通常放在小部件树的顶部附近。它使用堆栈规则管理路由。每个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>都有自己的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>对象列表，这些对象由<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Overlay-class.html" rel="noopener ugc nofollow" target="_blank">Overlay</a></code>小部件管理。</p><p id="3504" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在引入Navigator 2.0 API之前，路线一直以强制的方式从<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件中推送和弹出。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/0553a656967a786af842a591ad20a1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnJtZL5Xftsu3fBE83122A.png"/></div></div></figure><h1 id="6a21" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">途径</h1><p id="9f62" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated">虽然很多时候我们说一切都是Flutter里的widget，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>不是widget。这是一个由<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件管理的条目。在Flutter框架中，我们可以对两种类型的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>进行分组:在过渡时替换整个屏幕的路径，以及窗口小部件覆盖在前一个路径上的弹出路径。</p><p id="6339" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">路由可以有<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteSettings-class.html" rel="noopener ugc nofollow" target="_blank">RouteSettings</a></code>对象，它可能有一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteSettings/name.html" rel="noopener ugc nofollow" target="_blank">name</a></code>(否则是匿名的)和<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteSettings/arguments.html" rel="noopener ugc nofollow" target="_blank">arguments</a></code>，后者有时很有用。</p><p id="ba2f" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">如前所述，每个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>都有自己的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>对象列表。假设我们的主页上有一个标签栏或底部导航栏。如果我们在其中一个选项卡中添加一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>，当您在选项卡之间切换时，它仍然可见，因为<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>被添加到主屏幕顶部的当前路线的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>列表中。当我们在选项卡之间切换时，我们应该添加或删除<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/OverlayEntry-class.html" rel="noopener ugc nofollow" target="_blank">OverlayEntry</a></code>,或者在主屏幕中为每个选项卡设置单独的路径。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/b0acb009f3923c525d830b48e1b42bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HxZC0va1xIlYMkhCxczqQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">颤振框架中的路线</figcaption></figure><h1 id="ecb4" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">页</h1><p id="bba5" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated">在命令式API中，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>对象是通过调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件的静态方法来处理的，比如<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/push.html" rel="noopener ugc nofollow" target="_blank">push</a></code>、<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/pop.html" rel="noopener ugc nofollow" target="_blank">pop</a></code>、<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/replace.html" rel="noopener ugc nofollow" target="_blank">replace</a></code>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="852e" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">声明式API引入了<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>类。作为开发人员，我们的责任是在堆栈规范中向<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件提供一系列<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>对象。然后，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件将<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>对象转换成<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>对象。类似于<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>类，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>类也不是一个小部件，而是一个扩展<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteSettings-class.html" rel="noopener ugc nofollow" target="_blank">RouteSettings</a></code>类的类。</p><blockquote class="ne"><p id="3c09" class="nf ng iq bd nh ni nj nk nl nm nn kl dk translated"><a class="ae kq" href="https://docs.google.com/document/d/1Q0jx0l4-xymph9O6zLaOY4d_f7YFpNWX_eGbzYxr9wY/edit#heading=h.b3dp08v2w2u" rel="noopener ugc nofollow" target="_blank">“页面基本上是一个固定的路由设置，因为页面本质上描述了一个路由的配置”</a></p></blockquote><p id="f9bc" class="pw-post-body-paragraph kw kx iq ka b kb no ky kz kd np la lb kf nq ld le kh nr lg lh kj ns lj lk kl ij bi translated">导航栈是基于列表中<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>对象的顺序构建的。当列表改变时，触发导航栈的更新。注意，每个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>对象都有一个对应的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>对象。然而，如果路由是在静态命令式方法中实例化的，它将不会有一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>对象。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/7252d9ea700ca00749969fc4ca45fceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jozI8Y109HjVwtKxUppJ0A.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">提供给导航器小部件的页面列表</figcaption></figure><p id="4559" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">我们也可以通过扩展<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>类来定制页面列表中的类。在本系列的示例应用中，所有的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>类都是定制的。</p><p id="eea4" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件使用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>对象的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page/key.html" rel="noopener ugc nofollow" target="_blank">key</a></code>属性来确定列表中的每个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>是否与相应的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>中已经膨胀的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>相同或不同。如果<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page/key.html" rel="noopener ugc nofollow" target="_blank">key</a></code>不同或者<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>不在列表中，则调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page-class.html" rel="noopener ugc nofollow" target="_blank">Page</a></code>类的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Page/createRoute.html" rel="noopener ugc nofollow" target="_blank">createRoute</a></code>方法。</p><p id="cd4f" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在我们的示例应用程序中，<em class="nu">颜色</em>页面的唯一性由颜色代码定义，而<em class="nu">形状</em>页面的唯一性由颜色代码和形状边框类型的组合定义。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="81cf" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">路由信息</h1><p id="ecf0" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">RouteInformation</a></code>是包含路线信息的数据保持器。它有两个字段:<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>和<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformation/state.html" rel="noopener ugc nofollow" target="_blank">state</a></code>。<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformation/location.html" rel="noopener ugc nofollow" target="_blank">location</a></code>字段相当于一个URL字符串，而<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformation/state.html" rel="noopener ugc nofollow" target="_blank">state</a></code>字段保存关于该路由的应用程序状态的信息。</p><p id="a729" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">正如我们将在本系列的<a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener"> Web部件</a>中看到的，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">RouteInformation</a></code>对象在<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件内部用于与操作系统通信。</p><h1 id="0643" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">路由器部件</h1><p id="40fa" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated">小部件是导航的大脑。它封装了<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件，并根据用户与应用程序的交互、系统后退按钮的按下、应用程序启动时的初始路线以及操作系统(OS)的新意图来配置导航历史。</p><p id="131b" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件将其任务委托给它的组件，我们将在本系列中逐一探讨这些组件:</p><ul class=""><li id="8b65" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>负责根据应用状态构建<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code> widget，并处理pop请求。根据<a class="ae kq" href="https://docs.google.com/document/d/1Q0jx0l4-xymph9O6zLaOY4d_f7YFpNWX_eGbzYxr9wY/edit" rel="noopener ugc nofollow" target="_blank"> Flutter团队</a>的说法，这个代理是<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件的核心。考虑到没有心脏<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>不能被实例化是有意义的，因为人类没有心脏不能生存。</li><li id="9ddc" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code> delegate负责解析来自操作系统的路由信息，以便<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>可以更新应用状态。它还可以根据应用程序状态的变化恢复路线信息，从而使操作系统保持最新的导航历史记录。我认为这是手臂，因为一个人没有手臂也可以生活，但在日常生活中仍然会感到缺少手臂。类似地，我们可以实例化一个没有<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件，但是当我们不能恢复和解析浏览器地址栏上的URL时，我们将缺乏完整的Web应用程序体验。</li><li id="18b9" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">代表处理从操作系统意图创建路线信息。例如，当我们在Web浏览器的地址栏中输入时，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformationProvider-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationProvider</a></code>的任务是将URL解释给一个实体，这个实体是<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件内部使用的代理。这个委托更像是嘴和耳朵，因为它是<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件的耳朵，解释来自操作系统的新意图信号，而嘴在应用程序状态改变时将更新的路由信息告诉操作系统。</li><li id="e2c2" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://master-api.flutter.dev/flutter/widgets/BackButtonDispatcher-class.html" rel="noopener ugc nofollow" target="_blank">BackButtonDispatcher</a></code>代表负责报告具有平台后退按钮或手势的平台上的系统级pop事件。同样，这个代理更像是一只耳朵，用来监听来自操作系统的信号。</li></ul><p id="db2d" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">有两种方法可以使用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/WidgetsApp/WidgetsApp.html" rel="noopener ugc nofollow" target="_blank">WidgetsApp</a></code>中的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件:</p><ol class=""><li id="d287" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl nv kn ko kp bi translated">使用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/WidgetsApp/WidgetsApp.router.html" rel="noopener ugc nofollow" target="_blank">WidgetsApp.router</a></code>构造函数，我们将<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件委托作为构造函数参数传递。注意，使用这个方法需要将<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>委托作为构造函数参数传递。在前三个示例中，我们不会解析和恢复路由。因此，在第四个示例应用程序之前，我们不会使用这种方法。</li><li id="0cdd" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl nv kn ko kp bi translated">实例化<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件，并将其作为<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/WidgetsApp-class.html" rel="noopener ugc nofollow" target="_blank">WidgetApp</a></code>的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/WidgetsApp/home.html" rel="noopener ugc nofollow" target="_blank">home</a></code>属性传递。在这种情况下，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>应该是<code class="fe ll lm ln lo b">non-null</code>。当构建<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件时，我们不必提供其他委托，除非我们想要定制默认行为<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformationProvider-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationProvider</a></code>或者利用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouteInformationParser-class.html" rel="noopener ugc nofollow" target="_blank">RouteInformationParser</a></code>和<code class="fe ll lm ln lo b"><a class="ae kq" href="https://master-api.flutter.dev/flutter/widgets/BackButtonDispatcher-class.html" rel="noopener ugc nofollow" target="_blank">BackButtonDispatcher</a></code>的功能。</li></ol><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">将路由器注入应用程序</figcaption></figure><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1ab2b23703fa0db6148937235e1c94e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*Y_h705PH02WLwIr7.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">小部件树</figcaption></figure><h1 id="5ac4" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">路由器代表</h1><p id="61a9" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件最重要的组件是<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>类，因为它告诉<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件如何构建<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件。如果我们使用Navigator 2.0 API和<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件，我们的责任是定制<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>来实现导航逻辑。</p><ul class=""><li id="69ed" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>类实现了<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" rel="noopener ugc nofollow" target="_blank">ChangeNotifier</a></code> <a class="ae kq" href="https://dart.dev/guides/language/language-tour#adding-features-to-a-class-mixins" rel="noopener ugc nofollow" target="_blank"> mixin </a>，这使得它自己成为可列表的。调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>中的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" rel="noopener ugc nofollow" target="_blank">notifyListeners</a></code>方法将通知<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件。</li><li id="2ce7" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">得到通知后，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/build.html" rel="noopener ugc nofollow" target="_blank">build()</a></code>方法。</li><li id="b2da" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>在<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/build.html" rel="noopener ugc nofollow" target="_blank">build()</a></code>方法中构造并向<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>返回一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件。</li></ul><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/b4c07f13f4d0f45fee93c2e9b8893ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vQMWPBJWwTmoEA-h.png"/></div></div></figure><p id="b97f" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" rel="noopener ugc nofollow" target="_blank">notifyListeners</a></code>并不是创建导航历史的唯一方式。在这篇由<a class="nx ny ep" href="https://medium.com/u/940c22f73489?source=post_page-----5dc043e7e44a--------------------------------" rel="noopener" target="_blank"> Lulupointu </a>撰写的<a class="ae kq" href="https://lucasdelsol01.medium.com/flutter-navigator-2-0-for-mobile-dev-bloc-state-management-integration-3a180b4d25b3" rel="noopener">文章</a>中，你可以看到一个用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://bloclibrary.dev/#/" rel="noopener ugc nofollow" target="_blank">Bloc</a></code>模式处理导航状态的例子。</p><p id="b22a" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>类中监听应用程序状态的一种非常典型但不是唯一的方式是向页面传递回调方法。在页面的小部件内部，当回调方法被用户交互触发时，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>通知<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件进行导航栈更新。注意，随着应用程序的发展，传递给子部件的回调方法的数量会增加。跟踪这种回调方法会让人不知所措。我们应该总是寻找好的架构模式来避免这种风险。</p><p id="48c5" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">我们还需要通过响应操作系统事件来更新<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>中的应用状态。当操作系统请求弹出当前路线时，我们需要想出如何更新<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>中的应用状态，并相应地重建一个新的导航堆栈。</p><p id="50cb" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">现在，让我们分析第一个样本的自定义<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>。定制<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>内的app状态用两个字段表示:<code class="fe ll lm ln lo b">selectedColorCode</code>和<code class="fe ll lm ln lo b">selectedShape</code>。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/926651b7d6b511faac4e94d3919e0a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*AxLpP_Nq_WsEiO7HiXgCAQ.gif"/></div></figure><ul class=""><li id="f1c2" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">如果<code class="fe ll lm ln lo b">selectedColorCode</code>和<code class="fe ll lm ln lo b">selectedShape</code>字段都是<code class="fe ll lm ln lo b">null</code>(未设置)，那么我们应该在<code class="fe ll lm ln lo b">HomePage</code>中。导航堆栈中没有其他内容。如果操作系统告诉应该弹出当前路线(例如，按下后退按钮)，导航堆栈将为空，整个应用程序将被弹出。</li><li id="dea2" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">如果<code class="fe ll lm ln lo b">selectedColorCode</code>被设置，而<code class="fe ll lm ln lo b">selectedShape</code>没有被设置，这意味着我们点击了列表中的一个颜色按钮。导航历史将包括<code class="fe ll lm ln lo b">HomePage</code>和<code class="fe ll lm ln lo b">ColorPage</code>。页面列表的顺序很重要，因为列表中的最后一页将是用户可见的当前页面。当按下后退按钮时，<code class="fe ll lm ln lo b">ColorPage</code>弹出，<code class="fe ll lm ln lo b">HomePage</code>可见。</li><li id="5ee9" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">如果<code class="fe ll lm ln lo b">selectedColorCode</code>和<code class="fe ll lm ln lo b">selectedShape</code>都被设置，这意味着我们为该颜色选择了颜色代码和形状边框类型。导航堆栈将包括<code class="fe ll lm ln lo b">HomePage</code>、<code class="fe ll lm ln lo b">ColorPage</code>和<code class="fe ll lm ln lo b">ShapePage</code>。当按下返回按钮时，会弹出列表的最后一页，即<code class="fe ll lm ln lo b">ShapePage</code>，app会显示<code class="fe ll lm ln lo b">ColorPage</code>。</li></ul><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1f46" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">注意，我们为<code class="fe ll lm ln lo b">_selectedColorCode</code>和<code class="fe ll lm ln lo b">_selectedShape</code>状态实现了getter和setter。setter方法调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" rel="noopener ugc nofollow" target="_blank">notifyListeners</a></code>，这样当这些状态的值被更新时，就会通知<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件。然而，我们不必总是在每次设置状态时通知<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件。在这种情况下，它可以工作并使状态处理更容易。有时我们可能需要跳过或延迟通知，所以向setters添加<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" rel="noopener ugc nofollow" target="_blank">notifyListeners</a></code>调用没有意义。</p><h1 id="b6b5" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">处理Pop请求</h1><p id="6e4c" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated">当<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件收到来自操作系统的弹出请求时，它通过调用其<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/popRoute.html" rel="noopener ugc nofollow" target="_blank">popRoute</a></code>方法将更新导航堆栈的责任委托给<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>。</p><p id="323b" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">如果<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>想要处理<code class="fe ll lm ln lo b">pop</code>事件，这个方法应该返回<code class="fe ll lm ln lo b">true</code>。如果该方法返回<code class="fe ll lm ln lo b">false</code>，将弹出整个app。</p><p id="5b5d" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated"><code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>可以实现<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/PopNavigatorRouterDelegateMixin-mixin.html" rel="noopener ugc nofollow" target="_blank">PopNavigatorRouterDelegateMixin</a></code>。当这个mixin被实现时，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/popRoute.html" rel="noopener ugc nofollow" target="_blank">popRoute</a></code>调用将调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/maybePop.html" rel="noopener ugc nofollow" target="_blank">maybePop</a></code>方法。在这种情况下，我们不需要覆盖<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>中的<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate/popRoute.html" rel="noopener ugc nofollow" target="_blank">popRoute</a></code>方法。相反，我们必须向<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件提供<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/onPopPage.html" rel="noopener ugc nofollow" target="_blank">onPopPage</a></code>回调作为构造函数参数。</p><p id="007f" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">我们需要处理<code class="fe ll lm ln lo b">ShapePage</code>或<code class="fe ll lm ln lo b">ColorPage</code>的弹出。当接收到pop事件时:</p><ul class=""><li id="9280" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">如果<code class="fe ll lm ln lo b">selectedShape</code>是<code class="fe ll lm ln lo b">null</code>，那么我们当前显示的是需要弹出的<code class="fe ll lm ln lo b">ColorPage</code>。因此，我们将清除通知<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件的<code class="fe ll lm ln lo b">selectedColorCode</code>状态。</li><li id="e7ff" class="jy jz iq ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated">如果<code class="fe ll lm ln lo b">selectedShape</code>是<code class="fe ll lm ln lo b">non-null</code>，那么可见页面就是<code class="fe ll lm ln lo b">ShapePage</code>，需要弹出。我们应该只将<code class="fe ll lm ln lo b">selectedShape</code>设置为<code class="fe ll lm ln lo b">null</code>，因为我们想在弹出<code class="fe ll lm ln lo b">ShapePage</code>后用<code class="fe ll lm ln lo b">selectedColorCode</code>显示<code class="fe ll lm ln lo b">ColorPage</code>。</li></ul><p id="297e" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在处理pop事件之前，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>应该确保路由确实被弹出。如果路径没有弹出，<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/onPopPage.html" rel="noopener ugc nofollow" target="_blank">onPopPage</a></code>应该返回<code class="fe ll lm ln lo b">false</code>，告诉<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小工具<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>不关心弹出事件。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9e6a" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在下列情况下调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/onPopPage.html" rel="noopener ugc nofollow" target="_blank">onPopPage</a></code>回调方法:</p><ul class=""><li id="5ba1" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ka ir"> <em class="nu">返回按钮按下:</em> </strong></li></ul><p id="e3e9" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">按下<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/material/BackButton-class.html" rel="noopener ugc nofollow" target="_blank">BackButton</a></code>小工具可能会弹出路线。我们通常不需要添加特定的小部件来弹出导航堆栈中的最后一条路线，因为<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/material/Scaffold-class.html" rel="noopener ugc nofollow" target="_blank">Scaffold</a></code>小部件在<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/material/AppBar-class.html" rel="noopener ugc nofollow" target="_blank">AppBar</a></code>小部件中包含了一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/material/BackButton-class.html" rel="noopener ugc nofollow" target="_blank">BackButton</a></code>。这个小部件适应操作系统，这意味着它的图标将是特定于操作系统的。如果<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件包含多个页面，那么<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/material/BackButton-class.html" rel="noopener ugc nofollow" target="_blank">BackButton</a></code>将在<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/material/AppBar-class.html" rel="noopener ugc nofollow" target="_blank">AppBar</a></code>小部件中可见。</p><ul class=""><li id="a8c7" class="jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ka ir"> <em class="nu">系统返回按钮按下:</em> </strong></li></ul><p id="f423" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">与iOS手机和桌面应用不同，Android手机有一个专用的系统后退按钮或手势来弹出最后一条路线。如果我们希望<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件接收来自操作系统的pop请求，我们应该为<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件提供一个<code class="fe ll lm ln lo b"><a class="ae kq" href="https://master-api.flutter.dev/flutter/widgets/BackButtonDispatcher-class.html" rel="noopener ugc nofollow" target="_blank">BackButtonDispatcher</a></code>委托。</p><p id="27c3" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在下面的记录中，我们看到当弹出请求来自Android操作系统时，整个应用程序都被弹出，因为我们没有向<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件提供后退按钮调度器委托</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f84fd45a001cc66d5ab980881dbac102.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*tE76EXJ1ux-BrIaRuJuA9A.gif"/></div></figure><p id="6c1e" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">现在让我们提供<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/RootBackButtonDispatcher-class.html" rel="noopener ugc nofollow" target="_blank">RootBackButtonDispatcher</a></code>到<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件。该类是后退按钮调度程序的默认实现。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7998" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在下面的屏幕记录中，我们现在看到了预期的行为，因为在Android手机中点击系统后退按钮时会调用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/onPopPage.html" rel="noopener ugc nofollow" target="_blank">onPopPage</a></code>回调。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2b009c02620d830a20c9f424f757e363.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*4JknL5kMBf2vkyBDriirBQ.gif"/></div></figure><blockquote class="ne"><p id="690e" class="nf ng iq bd nh ni oa ob oc od oe kl dk translated">正如我们将在本系列的Web部分更详细讨论的那样，在Web浏览器上按back按钮不会调用<code class="fe ll lm ln lo b">onPopPage</code>回调。</p></blockquote><ul class=""><li id="080b" class="jy jz iq ka b kb no kd np kf of kh og kj oh kl km kn ko kp bi translated"><strong class="ka ir"> <em class="nu">显式弹出调用:</em> </strong></li></ul><p id="91c8" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">使用<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件的静态命令式<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/pop.html" rel="noopener ugc nofollow" target="_blank">pop</a></code>、<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/maybePop.html" rel="noopener ugc nofollow" target="_blank">maybePop</a></code>、<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/popUntil.html" rel="noopener ugc nofollow" target="_blank">popUntil</a></code>、<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/popAndPushNamed.html" rel="noopener ugc nofollow" target="_blank">popAndPushNamed</a></code>、<code class="fe ll lm ln lo b"><a class="ae kq" href="https://api.flutter.dev/flutter/widgets/Navigator/restorablePopAndPushNamed.html" rel="noopener ugc nofollow" target="_blank">restorablePopAndPushNamed</a></code>方法也会导致弹出导航堆栈中的最后一条路线。</p><h1 id="5703" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="3f1c" class="pw-post-body-paragraph kw kx iq ka b kb mn ky kz kd mo la lb kf mp ld le kh mq lg lh kj mr lj lk kl ij bi translated">在本文中，我们介绍了声明式导航API，并从一个非常简单的导航逻辑开始。你可以在<a class="ae kq" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/tree/develop/lib/002-navigator-2/002-01-mobile-only" rel="noopener ugc nofollow" target="_blank"> Github页面</a>找到源代码。该项目包括多个<code class="fe ll lm ln lo b">main.dart</code>文件。运行示例应用程序最简单的方法是右键单击<code class="fe ll lm ln lo b">main_002_01.dart</code>文件，然后单击<code class="fe ll lm ln lo b">Run</code>命令。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/808c3fa64bd845f48bdc4aeb3798664d.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/0*gUq0Gy6LQNMuFPRm.png"/></div></figure><p id="7b5f" class="pw-post-body-paragraph kw kx iq ka b kb kc ky kz kd ke la lb kf lc ld le kh lf lg lh kj li lj lk kl ij bi translated">在下一篇文章的<a class="ae kq" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-3-authentication-93dbcb5f0f0a" rel="noopener">中，我们将身份验证用例添加到这个示例应用程序中。特别感谢</a><a class="nx ny ep" href="https://medium.com/u/6b5de6766f88?source=post_page-----5dc043e7e44a--------------------------------" rel="noopener" target="_blank"> Jon Imanol Durán </a>审阅了本系列的所有文章，并给了我有用的反馈。如果你喜欢这篇文章，请按下拍手按钮，启动<a class="ae kq" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/tree/develop/002-navigator2" rel="noopener ugc nofollow" target="_blank"> Github库</a>。</p></div></div>    
</body>
</html>