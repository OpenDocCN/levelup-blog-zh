<html>
<head>
<title>Finding the Shortest Path in Javascript: Dijkstra’s Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Javascript中寻找最短路径:Dijkstra算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/finding-the-shortest-path-in-javascript-dijkstras-algorithm-8d16451eea34?source=collection_archive---------0-----------------------#2020-04-11">https://levelup.gitconnected.com/finding-the-shortest-path-in-javascript-dijkstras-algorithm-8d16451eea34?source=collection_archive---------0-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6fb98dc94919efdb7250a1192aa8f9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*-MpmvcyfJbxvI_1jIt5lJA.png"/></div></figure><blockquote class="ju"><p id="9ffa" class="jv jw iq bd jx jy jz ka kb kc kd ke dk translated">在图中找到两个节点之间的一条<strong class="ak">路径</strong>，使得其组成边的权重之和最小。</p></blockquote></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h2 id="35a1" class="km kn iq bd ko kp kq dn kr ks kt dp ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><a class="ae li" href="https://github.com/noamsauerutley/shortest-path" rel="noopener ugc nofollow" target="_blank"> GitHub回购，已完成解决方案代码</a></h2><p id="0399" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kv lu lv lw kz lx ly lz ld ma mb mc ke ij bi translated"><strong class="ll ir">注:</strong>这是我就这个话题写的第二篇文章。在<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/finding-the-shortest-path-in-javascript-pt-1-breadth-first-search-67ae4653dbec">之前的文章</a>中，我实现了一个<a class="ae li" href="https://www.cs.bu.edu/teaching/c/tree/breadth-first/" rel="noopener ugc nofollow" target="_blank">广度优先搜索</a>来从二叉树的一个节点遍历到另一个节点。如果您对基于节点的数据结构不太熟悉，想要快速刷新，或者想要查看大量不必要的黏液霉菌gif，我建议您在深入了解这个解决方案之前先查看一下！</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi md"><img src="../Images/8f34c1e02986a8b6cf7f4a390d867285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6eyB7JKPDzsXI6C4PQHH5g.gif"/></div></div></figure><p id="97be" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">然而，我在上一篇文章中探索的二叉树深度优先搜索有很多限制。它只适用于非常特殊类型的二叉树结构，这并不使它成为映射点集的最佳工具，比如存储在更复杂的<a class="ae li" href="http://courses.cs.vt.edu/~cs3114/Fall10/Notes/T22.WeightedGraphs.pdf" rel="noopener ugc nofollow" target="_blank">加权图</a>中的实际IRL数据。</p><p id="7a6f" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">因此，已经开发了几种不同的算法，这些算法修改和扩展了广度优先搜索模式，以便使其能够映射能够有效表示现实生活价值和挑战的图形类型。</p><p id="103f" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">所以，我从广度优先二叉树搜索转移到Edsger W. Dijkstra设计的算法。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mr"><img src="../Images/5599217626d8c32c71efe37beb5ca0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvxI5D_ENJ1ca65-XhZLxA.jpeg"/></div></div></figure><p id="0da2" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">Edsger W. Dijkstra是系统开发、编程和计算科学的基础领导者，也是开发结构化编程的关键人物。他生于1930年，卒于2002年，一生中大部分时间都在大学教书。像许多其他重要算法的开发者一样，他是一个博学的人——他的早期教育是化学，然后是理论物理，尽管他考虑过进入法律领域。20世纪50年代初，一个熟人给他提供了一份在阿姆斯特丹数学中心计算部门的工作，他才偶然接触到电子计算机。在那里，他成为了荷兰的第一个程序员，尽管在相当长的一段时间里他一直专注于理论物理。</p><p id="fe12" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">他努力使编程方法和结构在任何时候都尽可能简单易懂，这在理论性很强的早期编程世界中是不常见的。他深受他的数学家母亲的影响，说“她在处理公式方面有很大的灵活性，在寻找非常优雅的解决方案方面有很好的天赋”。</p><p id="4628" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我想知道他当老师的那些年是否也影响了他对编程代码可理解和可用的重视。不管怎样，作为一个图论新手，他的算法是我最容易理解的。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/de05c885ee56d421742b8cb26ff313c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*fVwc8J5aH1lrImKqc4M5lw.jpeg"/></div></figure><p id="3273" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">Dijkstra谈到算法时说:</p><blockquote class="mt mu mv"><p id="f5ed" class="lj lk mw ll b lm mm lo lp lq mn ls lt mx mo lv lw my mp ly lz mz mq mb mc ke ij bi translated">一般来说，从<a class="ae li" href="https://en.wikipedia.org/wiki/Rotterdam" rel="noopener ugc nofollow" target="_blank">鹿特丹</a>到<a class="ae li" href="https://en.wikipedia.org/wiki/Groningen" rel="noopener ugc nofollow" target="_blank">格罗宁根</a>的最短旅行方式是什么:从一个城市到另一个城市。<a class="ae li" href="https://en.wikipedia.org/wiki/Shortest_path_problem" rel="noopener ugc nofollow" target="_blank">这是最短路径</a>的算法，我花了大约二十分钟设计的。一天早上，我和年轻的未婚妻在<a class="ae li" href="https://en.wikipedia.org/wiki/Amsterdam" rel="noopener ugc nofollow" target="_blank">阿姆斯特丹</a>购物，累了，我们坐在咖啡厅露台上喝咖啡，我在想我是否可以这样做，然后我设计了最短路径的算法。正如我所说，这是一个20分钟的发明。事实上，它是在三年后的59年出版的。该出版物仍然可读，事实上，相当不错。它如此漂亮的原因之一是我没有用铅笔和纸来设计它。我后来才知道，不用铅笔和纸进行设计的一个好处是，你几乎是被迫避免所有可以避免的复杂性。最终，令我大为惊讶的是，这个算法成了我成名的基石之一。</p></blockquote><p id="e4cf" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">那么，这个算法的步骤是什么呢？</p><ul class=""><li id="0a86" class="na nb iq ll b lm mm lq mn kv nc kz nd ld ne ke nf ng nh ni bi translated">从一组节点开始，所有节点都没有被访问过。</li><li id="943a" class="na nb iq ll b lm nj lq nk kv nl kz nm ld nn ke nf ng nh ni bi translated">创建一组未访问的节点，称为由所有节点组成的未访问集。</li><li id="970e" class="na nb iq ll b lm nj lq nk kv nl kz nm ld nn ke nf ng nh ni bi translated">为每个节点指定一个初始距离值。对于起始节点，它将被设置为零，对于所有其他节点，它将被设置为无穷大。</li><li id="7dfc" class="na nb iq ll b lm nj lq nk kv nl kz nm ld nn ke nf ng nh ni bi translated">将起始节点设置为当前节点。</li><li id="9aa6" class="na nb iq ll b lm nj lq nk kv nl kz nm ld nn ke nf ng nh ni bi translated">对于每个当前节点，计算到其每个未访问的相邻节点的暂定距离。将从当前节点到邻居节点的距离与从起始节点到邻居节点的距离相加。</li><li id="defe" class="na nb iq ll b lm nj lq nk kv nl kz nm ld nn ke nf ng nh ni bi translated">当当前节点的所有未访问的相邻节点都被映射后，将当前节点标记为已访问，将其从未访问集中移除。将不会再次检查已访问的节点。</li><li id="b00f" class="na nb iq ll b lm nj lq nk kv nl kz nm ld nn ke nf ng nh ni bi translated">如果特定目的地节点已经被标记为已访问(当规划两个特定节点之间的路线时)，或者如果从开始节点到未访问集合中的节点的最小暂定距离是无穷大(意味着开始节点和剩余的未访问节点之间没有连接)，则停止。算法已经完成。</li><li id="41b4" class="na nb iq ll b lm nj lq nk kv nl kz nm ld nn ke nf ng nh ni bi translated">否则，选择具有最小暂定距离的未访问节点，将其设置为新的“当前节点”，并重复计算到其每个未访问邻居节点的暂定距离的过程。</li></ul><p id="7618" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">如果目的节点在所有“未访问的”节点中具有最小的试探性距离(因此可以被选择为下一个“当前的”)，那么算法可以停止。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/37ddff76084695ec7c019880c0ed83be.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/1*15KkonMRnHdbzGhFw0PXCA.gif"/></div></figure><p id="5a5c" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">好的，那么我们从哪里开始把它翻译成JavaScript代码呢？</p><p id="09ca" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我将从创建一个名为<strong class="ll ir"> <em class="mw">的<a class="ae li" href="https://www.w3schools.com/js/js_objects.asp" rel="noopener ugc nofollow" target="_blank"> JavaScript对象</a>开始，图</em> </strong>填充有<a class="ae li" href="https://searchenterprisedesktop.techtarget.com/definition/key-value-pair" rel="noopener ugc nofollow" target="_blank">键值对</a>。每个键代表图上的一个节点。每个值对象包含表示节点的直接邻居和节点&amp;邻居(即“边”)之间路径的距离或权重的键-值对。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3525" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">这给了我一个可以导航的测试图。</p><p id="9494" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">首先，我们需要能够识别最近的相邻节点。我们将需要重复这样做，所以我将使这个功能成为它自己单独的帮助器函数，我们可以根据需要调用它。</p><p id="ec4e" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">它将接受两个参数——一个由存储在键值对中的节点及其距离组成的对象，以及一个访问过的节点的数组列表。</p><p id="51af" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我们可以遍历对象的节点键，找到距离值最短的节点。如果距离最短的节点在未访问的集合中，那么这就是我们应该访问的下一个节点。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="823f" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">好了，现在我们已经写好了我们的工作助手方法，我们可以深入到更大的函数中，它将处理完整的图形导航过程。</p><p id="a721" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我们的函数将接受三个参数:我们之前制作的图形对象、期望的开始节点和期望的结束节点。</p><p id="eb81" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">为了使用Dijkstra算法遍历我们的图形对象并找到从开始节点到结束节点的最短路径，我已经伪代码化了我想要采取的步骤。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a0e0" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">那可是很多步啊！我们从头开始吧。</p><p id="b4ee" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">首先，我们需要一个hash对象来跟踪每个节点到起始节点的距离。按照Dijkstra算法的指示，我们首先将暂定距离值“无穷大”赋给结束节点。我们还想将分配给我们的<strong class="ll ir"> <em class="mw">图</em> </strong>中任一节点的子节点的键-值对复制到<strong class="ll ir"> <em class="mw">距离</em> </strong>中。</p><p id="37b7" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">因此，我们现在有了一个跟踪散列对象，它有一个键值对，包含key: <strong class="ll ir"> <em class="mw"> endNode </em> </strong>和值“infinity ”,以及用于<strong class="ll ir"> <em class="mw"> startNode </em> </strong>的子节点的其他键值对。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2981" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">太好了！现在我们有了一个hash对象，它可以跟踪一个节点到起始节点的距离。我们将在遍历节点时继续跟踪这些数据，并在最终到达结束节点时返回开始节点到结束节点的距离。</p><p id="007a" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">好了，现在我们需要另一个hash对象来跟踪我们以后需要的数据——我们有一个对象来跟踪我们的距离，我们需要另一个对象来跟踪路径。当我们到达终点时，我们希望不仅能够返回从起点到终点的距离，还能够返回从起点到终点的路径。</p><p id="5dcb" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我们将通过跟踪父子节点关系来创建这条路径。我在之前的<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/finding-the-shortest-path-in-javascript-pt-1-breadth-first-search-67ae4653dbec">帖子</a>中探讨了这些关系，所以如果你想重温这些结构，请随意阅读。</p><p id="350f" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">由于我们目前不知道结束节点的父节点，我们将为它指定一个空的父节点值。但是，我们可以遍历开始节点的所有子节点，并为它们分配一个父值<strong class="ll ir"> <em class="mw"> startNode </em> </strong>。这就足够开始跟踪父节点了！</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="819a" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">接下来，我们需要收集一个已访问节点的列表——为此，我将创建一个名为<strong class="ll ir"> <em class="mw"> visited </em> </strong>的空数组。</p><p id="de4c" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">现在我们有了一个<strong class="ll ir"> <em class="mw">距离</em> </strong>对象和一个<strong class="ll ir"> <em class="mw">访问过的</em> </strong>数组，这是我们需要传递到前面创建的<strong class="ll ir"><em class="mw">shortestDistanceNode</em></strong>助手函数中的两个参数。所以，现在我们可以在包含我们的开始节点的子节点的<strong class="ll ir"> <em class="mw">距离</em> </strong>对象中，找出哪一个是离<strong class="ll ir"> <em class="mw">开始节点</em> </strong>最近的。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="453b" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">现在，我们将利用一个<a class="ae li" href="https://www.w3schools.com/js/js_loop_while.asp" rel="noopener ugc nofollow" target="_blank"> while循环</a>来开始处理每个节点&amp;的子节点。这个循环将一直运行，直到我们访问完所有的节点。</p><p id="0431" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">对于每个节点，我们将通过在<strong class="ll ir"> <em class="mw">图</em> </strong>和<strong class="ll ir"> <em class="mw">距离</em> </strong>散列对象中查找与当前节点匹配的键所配对的值，从找到当前节点与其子节点的距离开始。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e8ae" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">现在我们可以遍历每个子节点。</p><p id="cbf7" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">在对子节点做任何事情之前，我们希望确保它不是开始节点。我们不想绕圈子，所以如果一个子节点是开始节点，我们将跳到下一个子节点。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b80f" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">现在我们将使用几分钟前为当前父节点创建的<strong class="ll ir"> <em class="mw">距离</em> </strong>变量。</p><p id="f8b7" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我们将创建一个名为<strong class="ll ir"> <em class="mw"> newDistance </em> </strong>的新变量，并将它的值指定为<strong class="ll ir"> <em class="mw"> distance </em> </strong> +子节点的值—它与其父节点的距离。通过将起始节点到父节点的距离加上父节点到子节点的距离，这将给出子节点到起始节点的距离。</p><p id="8ffd" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">(不幸的是，在这一点上，我的代码对于我的<a class="ae li" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">语法高亮代码片段生成器</a>来说有点太长了😔所以我转而使用普通的旧标记代码片段。我希望这不会对可读性造成太大的影响！)</p><pre class="me mf mg mh gt nr ns nt nu aw nv bi"><span id="bbc7" class="km kn iq ns b gy nw nx l ny nz">let findShortestPath = (graph, startNode, endNode) =&gt; {<br/> <br/><strong class="ns ir"><em class="mw"> // track distances from the start node using a hash object<br/></em></strong>   let distances = {};<br/> distances[endNode] = "Infinity";<br/> distances = Object.assign(distances, graph[startNode]);</span><span id="48e7" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// track paths using a hash object<br/></em></strong> let parents = { endNode: null };<br/> for (let child in graph[startNode]) {<br/>  parents[child] = startNode;<br/> }<br/>  <br/><strong class="ns ir"><em class="mw"> // collect visited nodes<br/></em></strong>   let visited = [];</span><span id="225a" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// find the nearest node<br/></em></strong>   let node = shortestDistanceNode(distances, visited);<br/> <br/><strong class="ns ir"><em class="mw"> // for that node:<br/></em></strong> while (node) {<br/><strong class="ns ir"><em class="mw"> // find its distance from the start node &amp; its child nodes<br/></em></strong>  let distance = distances[node];<br/>  let children = graph[node]; <br/>      <br/><strong class="ns ir"><em class="mw"> // for each of those child nodes:<br/></em></strong>      for (let child in children) {<br/>  <br/><strong class="ns ir"><em class="mw">  // make sure each child node is not the start node<br/></em></strong>        if (String(child) === String(startNode)) {<br/>          continue;<br/>       } else {<br/><strong class="ns ir"><em class="mw">          // save the distance from the start node to the child node<br/></em></strong>          let newdistance = distance + children[child];</span><span id="6c30" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// if there's no recorded distance from the start node to the child node in the distances object<br/>// or if the recorded distance is shorter than the previously stored distance from the start node to the child node<br/>         <br/>// save the distance to the object<br/>          <br/>// record the path<br/>   <br/>// move the current node to the visited set</em></strong></span><span id="e4b9" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// move to the nearest neighbor node<br/>  <br/>// using the stored paths from start node to end node<br/>// record the shortest path</em></strong></span><span id="9257" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">//this is the shortest path</em></strong></span><span id="e365" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// return the shortest path &amp; the end node's distance from the start node</em></strong><br/>};</span></pre><p id="aff6" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">如果我们还没有在距离对象中保存这个子节点，记录它与开始节点的距离，或者，如果先前记录的距离比<strong class="ll ir"> <em class="mw"> newDistance </em> </strong>值长(意味着我们刚刚找到了一条更短的路径，耶！)然后我们将<strong class="ll ir"> <em class="mw"> newDistance </em> </strong>值赋给匹配<strong class="ll ir"><em class="mw">distance</em></strong>散列对象中当前子节点的键。</p><p id="d3be" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">为了保持记录的准确性，我们还在<strong class="ll ir"> <em class="mw"> parents </em> </strong>对象中记录了当前子节点的父节点。这样，我们就可以一直追踪到起始节点。</p><pre class="me mf mg mh gt nr ns nt nu aw nv bi"><span id="87b0" class="km kn iq ns b gy nw nx l ny nz">let findShortestPath = (graph, startNode, endNode) =&gt; {<br/> <br/><strong class="ns ir"><em class="mw"> // track distances from the start node using a hash object<br/></em></strong>   let distances = {};<br/> distances[endNode] = "Infinity";<br/> distances = Object.assign(distances, graph[startNode]);</span><span id="4bfc" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// track paths using a hash object</em></strong><br/> let parents = { endNode: null };<br/> for (let child in graph[startNode]) {<br/>  parents[child] = startNode;<br/> }<br/>  <br/><strong class="ns ir"><em class="mw"> // collect visited nodes<br/></em></strong>   let visited = [];</span><span id="cd74" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// find the nearest node<br/></em></strong>   let node = shortestDistanceNode(distances, visited);<br/> <br/><strong class="ns ir"><em class="mw"> // for that node:<br/></em></strong> while (node) {<br/><strong class="ns ir"><em class="mw"> // find its distance from the start node &amp; its child nodes<br/></em></strong>  let distance = distances[node];<br/>  let children = graph[node]; <br/>      <br/><strong class="ns ir"><em class="mw"> // for each of those child nodes:<br/></em></strong>      for (let child in children) {<br/>  <br/><strong class="ns ir"><em class="mw">  // make sure each child node is not the start node<br/></em></strong>        if (String(child) === String(startNode)) {<br/>          continue;<br/>       } else {<br/><strong class="ns ir"><em class="mw">          // save the distance from the start node to the child node<br/></em></strong>          let newdistance = distance + children[child];</span><span id="8842" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// if there's no recorded distance from the start node to the child node in the distances object<br/>// or if the recorded distance is shorter than the previously stored distance from the start node to the child node</em></strong><br/>          if (!distances[child] || distances[child] &gt; newdistance) {<br/><strong class="ns ir"><em class="mw">     // save the distance to the object<br/></em></strong>     distances[child] = newdistance;<br/><strong class="ns ir"><em class="mw">     // record the path<br/></em></strong>     parents[child] = node;<br/>           } <br/>         }<br/>       }  <br/><strong class="ns ir"><em class="mw"> // move the current node to the visited set</em></strong></span><span id="77f6" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw"> // move to the nearest neighbor node<br/>  <br/> // using the stored paths from start node to end node<br/> // record the shortest path</em></strong></span><span id="390c" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">//this is the shortest path</em></strong></span><span id="7e2e" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// return the shortest path &amp; the end node's distance from the start node</em></strong><br/>};</span></pre><p id="596e" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">接下来，我们将当前父节点添加到<strong class="ll ir"> <em class="mw">已访问过的</em> </strong>数组中，将其添加到已访问过的集合中，这样当我们遍历未来的节点时就不会重复了。</p><p id="ae5d" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">现在，我们可以重复这个过程，通过使用我们的<strong class="ll ir"><em class="mw">shortestDistanceNode</em></strong>助手函数来查找最近的节点，这将重新开始while循环的下一次迭代。我们的while循环将继续运行，重复这个过程，直到<strong class="ll ir"><em class="mw">shortestDistanceNode</em></strong>找不到新的未访问节点。</p><pre class="me mf mg mh gt nr ns nt nu aw nv bi"><span id="4d49" class="km kn iq ns b gy nw nx l ny nz">let findShortestPath = (graph, startNode, endNode) =&gt; {<br/> <br/><strong class="ns ir"><em class="mw"> // track distances from the start node using a hash object<br/></em></strong>   let distances = {};<br/> distances[endNode] = "Infinity";<br/> distances = Object.assign(distances, graph[startNode]);</span><span id="5ed8" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// track paths using a hash object<br/></em></strong> let parents = { endNode: null };<br/> for (let child in graph[startNode]) {<br/>  parents[child] = startNode;<br/> }<br/>  <br/> <strong class="ns ir"><em class="mw">// collect visited nodes</em></strong><br/>   let visited = [];</span><span id="538b" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// find the nearest node<br/></em></strong>   let node = shortestDistanceNode(distances, visited);<br/> <br/><strong class="ns ir"><em class="mw"> // for that node:<br/></em></strong> while (node) {<br/><strong class="ns ir"><em class="mw"> // find its distance from the start node &amp; its child nodes<br/></em></strong>  let distance = distances[node];<br/>  let children = graph[node]; <br/>      <br/><strong class="ns ir"><em class="mw"> // for each of those child nodes:<br/></em></strong>      for (let child in children) {<br/>  <br/><strong class="ns ir"><em class="mw">  // make sure each child node is not the start node<br/></em></strong>        if (String(child) === String(startNode)) {<br/>          continue;<br/>       } else {<br/><strong class="ns ir"><em class="mw">          // save the distance from the start node to the child node<br/></em></strong>          let newdistance = distance + children[child];</span><span id="07d4" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// if there's no recorded distance from the start node to the child node in the distances object<br/>// or if the recorded distance is shorter than the previously stored distance from the start node to the child node<br/></em></strong>          if (!distances[child] || distances[child] &gt; newdistance) {<br/><strong class="ns ir"><em class="mw">             // save the distance to the object<br/></em></strong>     distances[child] = newdistance;<br/><strong class="ns ir"><em class="mw">                // record the path<br/></em></strong>     parents[child] = node;<br/>    } <br/>         }<br/>       }  <br/><strong class="ns ir"><em class="mw">      // move the current node to the visited set<br/></em></strong>      visited.push(node);</span><span id="4f44" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// move to the nearest neighbor node<br/></em></strong>      node = shortestDistanceNode(distances, visited);<br/>    }<br/>  <br/><strong class="ns ir"><em class="mw"> // using the stored paths from start node to end node<br/> // record the shortest path</em></strong></span><span id="1695" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">//this is the shortest path</em></strong></span><span id="7843" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// return the shortest path &amp; the end node's distance from the start node</em></strong><br/>};</span></pre><p id="0519" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">好的，我们的while循环将一直运行，直到所有的节点都被访问和映射。解决之后我们做什么？</p><p id="03b4" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我们可以创建一个名为<strong class="ll ir"> <em class="mw"> shortestPath </em>，</strong>的数组变量，它最初只包含结束节点。但是，我们可以通过<strong class="ll ir"> <em class="mw"> parents </em> </strong> hash对象中的键查找结束节点的parent，并将其推入<strong class="ll ir"> <em class="mw"> shortestPath </em> </strong>数组。请记住，我们仅在从开始节点找到节点&amp;之间的最短距离后，才记录该对象的父子对，因此从结束节点追溯到我们记录为其父节点的节点将沿着特定路径(最短路径)后退一步。</p><p id="bf0d" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">因为我们存储了我们访问的每个节点的最短距离父节点的记录，所以我们可以开始一个新的while循环，并找到每个父节点的父节点，这最终将追踪一条路径回到开始节点。</p><p id="8642" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">然而这并不是我们想要的——我们想要从起点到终点的最短路径，而不是从终点到起点的最短路径！</p><p id="0db9" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">谢天谢地，JavaScript提供了一个方便的<a class="ae li" href="https://www.w3schools.com/jsref/jsref_reverse.asp" rel="noopener ugc nofollow" target="_blank"> array.reverse() </a> <a class="ae li" href="https://www.geeksforgeeks.org/javascript-basic-array-methods/" rel="noopener ugc nofollow" target="_blank">数组方法</a>。因此，如果我们反转我们的<strong class="ll ir"> <em class="mw"> shortestPath </em> </strong>数组，我们将得到一个节点数组，如果遍历该数组，将得到从开始节点到结束节点的最短路径。</p><pre class="me mf mg mh gt nr ns nt nu aw nv bi"><span id="d524" class="km kn iq ns b gy nw nx l ny nz">let findShortestPath = (graph, startNode, endNode) =&gt; {<br/> <br/><strong class="ns ir"><em class="mw">  // track distances from the start node using a hash objec</em></strong>t<br/>    let distances = {};<br/>    distances[endNode] = “Infinity”;<br/>    distances = Object.assign(distances, graph[startNode]);</span><span id="5d5f" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">    // track paths using a hash object</em></strong><br/>    let parents = { endNode: null };<br/>    for (let child in graph[startNode]) {<br/>      parents[child] = startNode;<br/>    }<br/> <br/><strong class="ns ir"><em class="mw">   // collect visited nodes<br/></em></strong>   let visited = [];</span><span id="3380" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">   // find the nearest node</em></strong><br/>   let node = shortestDistanceNode(distances, visited);<br/> <br/>    <strong class="ns ir"><em class="mw">// for that node:</em></strong><br/>    while (node) {<br/>       <strong class="ns ir"><em class="mw">// find its distance from the start node &amp; its child nodes</em></strong><br/>       let distance = distances[node];<br/>       let children = graph[node]; <br/> <br/><strong class="ns ir"><em class="mw">       // for each of those child nodes:</em></strong><br/>       for (let child in children) {<br/> <br/>          <strong class="ns ir"><em class="mw">// make sure each child node is not the start node</em></strong><br/>          if (String(child) === String(startNode)) {<br/>             continue;<br/>          } else {<br/><strong class="ns ir"><em class="mw">             // save the distance from start node to child node</em></strong><br/>             let newdistance = distance + children[child];</span><span id="5030" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">             // if there’s no recorded distance from the start node to the child node in the distances object</em></strong><br/>             <strong class="ns ir"><em class="mw">// or if the recorded distance is shorter than the previously stored distance from the start node to the child node</em></strong><br/>             if (!distances[child] || distances[child] &gt; newdistance) {<br/>                <strong class="ns ir"><em class="mw">// save the distance to the object</em></strong><br/>                distances[child] = newdistance;<br/>                <strong class="ns ir"><em class="mw">// record the path</em></strong><br/>                parents[child] = node;<br/>            } <br/>         }<br/>      } <br/>    <strong class="ns ir"><em class="mw">// move the current node to the visited set</em></strong><br/>    visited.push(node);</span><span id="e164" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">   // move to the nearest neighbor node</em></strong><br/>   node = shortestDistanceNode(distances, visited);<br/>   }<br/> <br/><strong class="ns ir"><em class="mw">   // using the stored paths from start node to end node<br/>   // record the shortest path</em></strong><br/>   let shortestPath = [endNode];<br/>   let parent = parents[endNode];<br/>   while (parent) {<br/>      shortestPath.push(parent);<br/>      parent = parents[parent];<br/>   }<br/>   shortestPath.reverse();<br/> <br/><strong class="ns ir"><em class="mw">   //this is the shortest path</em></strong></span><span id="3132" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// return the shortest path &amp; the end node’s distance from the start node</em></strong><br/>};</span></pre><p id="59da" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我们做到了！我们找到了最短的路径！</p><p id="aef7" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">让我们格式化我们收集的信息，以便我们的函数可以很好地返回它。</p><p id="e064" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我们可以创建最后一个hash对象，这一次使用who键:“distance”和“path”。</p><p id="b1c2" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">“距离”的值将是实际的数字距离值，它是从开始节点到结束节点的总距离，是从沿着最短路径的节点之间的边的所有距离值(即，边权重)的总和。我们可以通过在<strong class="ll ir"><em class="mw"/></strong>散列对象中找到我们保存在与<strong class="ll ir"> <em class="mw"> endNode </em> </strong>匹配的键下的距离值来找到它。</p><p id="c4df" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">“path”的值将是我们刚刚创建并填充的<strong class="ll ir"> <em class="mw"> shortestPath </em> </strong>数组，该数组可以提供一个路线图，该路线图可以准确地列出要遍历哪些节点，以便从起始节点到结束节点&amp;覆盖最少的距离。</p><pre class="me mf mg mh gt nr ns nt nu aw nv bi"><span id="4747" class="km kn iq ns b gy nw nx l ny nz">let findShortestPath = (graph, startNode, endNode) =&gt; {<br/> <br/> <strong class="ns ir"><em class="mw">// track distances from the start node using a hash object</em></strong><br/>   let distances = {};<br/> distances[endNode] = "Infinity";<br/> distances = Object.assign(distances, graph[startNode]);</span><span id="8b84" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// track paths using a hash object</em></strong><br/> let parents = { endNode: null };<br/> for (let child in graph[startNode]) {<br/>  parents[child] = startNode;<br/> }<br/>  <br/><strong class="ns ir"><em class="mw"> // collect visited nodes</em></strong><br/>   let visited = [];</span><span id="d30c" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// find the nearest node</em></strong><br/>   let node = shortestDistanceNode(distances, visited);<br/> <br/><strong class="ns ir"><em class="mw"> // for that node:</em></strong><br/> while (node) {<br/> <strong class="ns ir"><em class="mw">// find its distance from the start node &amp; its child nodes</em></strong><br/>  let distance = distances[node];<br/>  let children = graph[node]; <br/>      <br/><strong class="ns ir"><em class="mw"> // for each of those child nodes:</em></strong><br/>      for (let child in children) {<br/>  <br/><strong class="ns ir"><em class="mw">  // make sure each child node is not the start node<br/></em></strong>        if (String(child) === String(startNode)) {<br/>          continue;<br/>       } else {<br/><strong class="ns ir"><em class="mw">          // save the distance from the start node to the child node<br/></em></strong>          let newdistance = distance + children[child];</span><span id="df16" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// if there's no recorded distance from the start node to the child node in the distances object<br/>// or if the recorded distance is shorter than the previously stored distance from the start node to the child node</em></strong><br/>          if (!distances[child] || distances[child] &gt; newdistance) {<br/><strong class="ns ir"><em class="mw">// save the distance to the object<br/></em></strong>     distances[child] = newdistance;<br/><strong class="ns ir"><em class="mw">// record the path<br/></em></strong>     parents[child] = node;<br/>    } <br/>         }<br/>       }  <br/><strong class="ns ir"><em class="mw">      // move the current node to the visited set<br/></em></strong>      visited.push(node);</span><span id="8279" class="km kn iq ns b gy oa nx l ny nz"><strong class="ns ir"><em class="mw">// move to the nearest neighbor node<br/></em></strong>      node = shortestDistanceNode(distances, visited);<br/>    }<br/>  <br/><strong class="ns ir"><em class="mw"> // using the stored paths from start node to end node<br/> // record the shortest path</em></strong><br/> let shortestPath = [endNode];<br/> let parent = parents[endNode];<br/> while (parent) {<br/>  shortestPath.push(parent);<br/>  parent = parents[parent];<br/> }<br/> shortestPath.reverse();<br/>  <br/><strong class="ns ir"><em class="mw"> //this is the shortest path<br/></em></strong> let results = {<br/>  distance: distances[endNode],<br/>  path: shortestPath,<br/> };<br/><strong class="ns ir"><em class="mw"> // return the shortest path &amp; the end node's distance from the start node<br/></em></strong>   return results;<br/>};</span></pre><p id="7caa" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">让我们在控制台中进行几轮测试，看看会有什么结果:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dca6" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">太好了！🌟</p><p id="7b48" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我们的函数输出从一个给定的起始节点到一个给定的结束节点的最短路径，并且还有益地提供节点之间的加权边的总距离值。</p><p id="316c" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">在包含完整解决方案代码的GitHub repo中，我包含了一个额外的文件，其中包含了在算法执行过程中记录更新消息的替代代码。如果可视化过程很棘手，我建议运行该代码并观察日志进度！</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/27293dcdf2921f6b3e69ed6057535da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/1*O3E5bj4FfWSVc48jc26sPA.gif"/></div></figure><p id="b248" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kv mo lv lw kz mp ly lz ld mq mb mc ke ij bi translated">我希望你在寻找两点间最短路径的尝试中像这只柯基一样成功！</p></div></div>    
</body>
</html>