<html>
<head>
<title>An Algorithmic Comparison of 5 Popular Programming Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5种流行编程语言的算法比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-algorithmic-comparison-of-5-popular-programming-languages-d2ca4e834b17?source=collection_archive---------16-----------------------#2021-02-15">https://levelup.gitconnected.com/an-algorithmic-comparison-of-5-popular-programming-languages-d2ca4e834b17?source=collection_archive---------16-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1ee651f694f3a257655ebdc6db950214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qyxD6FGNIrhvmZP9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@radowanrehan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉多万·纳基夫·雷汉</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="728e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将使用唐纳德·克努特(Donald Knuth)首次为一篇论文<a class="ae kf" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjtmovl29_uAhWHhK0KHWWUDggQFjAAegQIARAC&amp;url=https%3A%2F%2Fapps.dtic.mil%2Fdtic%2Ftr%2Ffulltext%2Fu2%2Fa032123.pdf&amp;usg=AOvVaw30IWpnQYn99ECRvC9gqJZV" rel="noopener ugc nofollow" target="_blank"/>开发的算法来比较五种现代计算机编程语言(C、C++、Java、JavaScript和Python)，这篇论文是他和路易斯·特拉布·帕尔多(Luis Trabb Pardo)一起写的，内容是关于编程语言的早期发展。</p><p id="0a14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Knuth将该算法命名为TPK (Trabb Pardo Knuth)算法。下面是算法的伪代码:</p><p id="3399" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">从用户处获取11个数字<br/>对于从最后一个元素开始的序列中的每个项目:<br/>以该项目为参数调用函数F<br/>显示函数返回值</em></p><p id="83d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数F的定义如下:</p><p id="48cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">函数F(number): <br/>返回number +的绝对值的平方根(5次<br/>数的3次幂)</em></p><p id="d7e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最初的TPK算法也检查了接收函数返回值的变量的溢出，但是我把它去掉了，因为它不像克努特在1977年写文章时那样相关。此外，检查溢出并没有真正增加我对各种编程语言的比较。</p><p id="2260" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该算法为程序员提供了演示编程语言以下特征的机会:</p><ul class=""><li id="9f07" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">数据类型</li><li id="f99b" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">数据存储</li><li id="f2ca" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">函数定义</li><li id="5e9d" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">重复</li></ul><p id="dbc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些都是学习任何编程语言的学生在课程的第一个学期要学习的特征。</p><p id="6c3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将使用<a class="ae kf" href="https://repl.it" rel="noopener ugc nofollow" target="_blank">的语言系统https://repl.it </a>来执行我的编程语言比较。使用这个网站可以让我保持编程环境尽可能的恒定，同时在不同的语言之间切换进行比较。</p><p id="0887" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从在c语言中实现TPK算法开始。</p><h1 id="2eb3" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">C语言中的TPK算法</h1><p id="ff16" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">下面是TPK算法的一个实现，以及一个测试程序，用C:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9742" class="nf lu it nb b gy ng nh l ni nj">#include &lt;stdio.h&gt;<br/>#include &lt;math.h&gt;</span><span id="11d2" class="nf lu it nb b gy nk nh l ni nj">double f(double num) {<br/>  return sqrt(fabs(num) + (5 * pow(num, 3)));<br/>}</span><span id="d089" class="nf lu it nb b gy nk nh l ni nj">int main(void) {<br/>  const int N = 11;<br/>  double numbers[N];<br/>  for (int i = 0; i &lt; N; i++) {<br/>    printf("Enter a number: ");<br/>    scanf("%d", &amp;numbers[i]);<br/>  }<br/>  for (int j = N-1; j &gt;= 0; j--) {<br/>    double result = f(numbers[j]);<br/>    printf("%d\n", result);<br/>  }<br/>  return 0;<br/>}</span></pre><p id="bb36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，任何学过使用C风格语法的语言(如Java、C#和JavaScript)的程序员都很容易读懂这个程序。这个程序中唯一不熟悉的部分是使用<code class="fe nl nm nn nb b">scanf</code>函数的输入行。</p><p id="d9c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有些程序员可能不熟悉<code class="fe nl nm nn nb b">printf </code>函数，所以你可能也需要对它做一些研究。</p><p id="7a35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，我要比较的许多语言主要在它们如何执行输入和输出以及如何处理数据结构方面有所不同，尤其是类似C的语法语言。</p><p id="079e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看这个程序在C的姐姐语言C++中是什么样子的。</p><h1 id="1499" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">C++中的TPK算法</h1><p id="82a4" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">下面是TPK算法的一个实现和一个C++测试程序:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e04f" class="nf lu it nb b gy ng nh l ni nj">#include &lt;iostream&gt;<br/>#include &lt;cmath&gt;<br/>using namespace std;</span><span id="efa7" class="nf lu it nb b gy nk nh l ni nj">double f(double num) {<br/>  return sqrt(fabs(num) + (5 * pow(num, 3)));<br/>}</span><span id="115b" class="nf lu it nb b gy nk nh l ni nj">int main() {<br/>  const int N = 11;<br/>  double numbers[N];<br/>  for (int i = 0; i &lt; N; i++) {<br/>    cout &lt;&lt; "Enter a number: ";<br/>    cin &gt;&gt; numbers[i];<br/>  }<br/>  for (int i = N-1; i &gt;= 0; i--) {<br/>    double result = f(numbers[i]);<br/>    cout &lt;&lt; result &lt;&lt; endl;<br/>  }<br/>}</span></pre><p id="afc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序和我之前写的C程序之间的主要区别在于输入和输出是如何处理的。但还有另一个更微妙的区别。在上面的C程序中，第二个<code class="fe nl nm nn nb b">for</code>循环必须用与第一个<code class="fe nl nm nn nb b">for</code>循环不同的索引变量来编写，而在C++版本中，我可以对两个循环使用相同的索引变量。这是因为C++有块级作用域，而C没有。</p><p id="52ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们用Java运行TPK算法。</p><h1 id="3651" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Java中的TPK算法</h1><p id="d2be" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">在Java中运行TPK算法和在C++中运行该算法之间有一些不同，尽管这些不同主要是语法上的不同。你可以看看Java程序，看它的轮廓和C++程序相似。下面是Java代码:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="97f9" class="nf lu it nb b gy ng nh l ni nj">import java.util.Scanner;<br/>import java.lang.Math;</span><span id="9790" class="nf lu it nb b gy nk nh l ni nj">class Main {<br/>  static double f(double number) {<br/>    return Math.sqrt(Math.abs(number) + (5 * Math.pow(number, 3)));<br/>  }</span><span id="e44f" class="nf lu it nb b gy nk nh l ni nj">  public static void main(String[] args) {<br/>    final int N = 11;<br/>    double [] numbers = new double[N];<br/>    Scanner userInput = new Scanner(System.in);<br/>    for (int i = 0; i &lt; N; i++) {<br/>      System.out.print("Enter a number: ");<br/>      numbers[i] = userInput.nextDouble();<br/>    }<br/>    userInput.close();<br/>    for (int i = N-1; i &gt;= 0; i--) {<br/>      double result = f(numbers[i]);<br/>      System.out.println(result);<br/>    }<br/>  }<br/>}</span></pre><p id="719e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最明显的区别在于主程序是一个类。Java中的一切都是一个对象，所以即使是一个命令式程序也必须作为一个类来编写。这意味着<code class="fe nl nm nn nb b">f</code>函数必须写成静态方法，因为它是从一个类中调用的。我使用术语<em class="le">方法</em>，尽管<code class="fe nl nm nn nb b">f</code>实际上只是一个函数，因为它并不真正附属于一个类对象。</p><p id="5648" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java中没有关键字<code class="fe nl nm nn nb b">const</code>；常数用<code class="fe nl nm nn nb b">final</code>声明。数组在Java中是一个对象，所以它必须用构造函数调用来实例化。</p><p id="53c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java程序比前两个程序长几行。一个原因是<code class="fe nl nm nn nb b">Scanner</code>类比C++中的<code class="fe nl nm nn nb b">iostream</code>库需要使用更多的编码。例如，我必须实例化一个<code class="fe nl nm nn nb b">Scanner</code>对象，并在完成后关闭它，但是在C++中，我只需要使用<code class="fe nl nm nn nb b">cout</code>而不需要所有的实例化和关闭。</p><p id="cfc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些都是主要的区别，但是如果你以前从未见过Java程序，但是知道C或C++，你应该可以理解这个程序的功能。</p><p id="0033" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们从静态类型的编译语言转换到两种动态类型的解释语言，JavaScript和Python，看看TPK程序在这些语言中与C、C++和Java有什么不同。我将从JavaScript开始。</p><h1 id="bfbb" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">JavaScript中的TPK算法</h1><p id="4b56" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">对于这个测试，我没有使用repl.it中的JavaScript语言，因为该站点使用Node.js，并且Node.js中的用户输入比我在本文中想要的更复杂。我使用的是Mozilla的Spidermonkey版本的JavaScript，它提供了一种更简单的用户输入方式。</p><p id="3c41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">乍一看，用JavaScript实现并测试TPK算法看起来与我们的C、C++和Java版本没有太大区别，因为JavaScript借用了太多C语法。以下是JavaScript代码:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="4c88" class="nf lu it nb b gy ng nh l ni nj">function f(number) {<br/>  return Math.sqrt(Math.abs(number) + (5 * Math.pow(number, 3)));<br/>}</span><span id="d305" class="nf lu it nb b gy nk nh l ni nj">let numbers = []; // let numbers = new Array();<br/>const N = 11;<br/>for (let i = 0; i &lt; N; i++) {<br/>  putstr("Enter a number: ");<br/>  numbers[i] = parseFloat(readline());<br/>}<br/>for (let i = N-1; i &gt;= 0; i--) {<br/>  let result = f(numbers[i]);<br/>  print(result);<br/>}</span></pre><p id="e1b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先要注意的是没有显式类型。JavaScript在幕后处理所有的输入。空数组可以用空方括号声明，尽管我也可以这样写:</p><p id="be1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nl nm nn nb b">let numbers = new Array();</code></p><p id="fcf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可能会在更正式的程序中这样做。</p><p id="3962" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还要注意，我不必导入数学库。我可以在需要的地方引用JavaScript的<code class="fe nl nm nn nb b">Math</code>库，这使得程序更短一些。事实上，这个程序的Java版本有21行代码，不包括空格，而JavaScript版本只有13行代码。我并不是说简洁是最重要的因素，但是这个例子突出了使用解释型语言比编译型语言的优势之一。</p><p id="46c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们转到最后一种编程语言——Python。</p><h1 id="635c" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Python中的TPK算法</h1><p id="2c82" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">Python将是所有这些语言中最不同的，因为Python不使用C语言语法。许多人吹捧这是将Python作为第一语言学习的一个优势，我不会在这里争论这一点，除了说如果你计划成为一门专业语言，你最终将不得不学习一门使用C语法的语言，你可以争辩说，当你转向C++或Java时，在诸如JavaScript之类的语言中早期学习它会给你带来优势。</p><p id="fdc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，让我们继续，看看TPK算法及其测试程序是如何用Python实现的。代码如下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="2e68" class="nf lu it nb b gy ng nh l ni nj">import math</span><span id="ac65" class="nf lu it nb b gy nk nh l ni nj">def f(number):<br/>  return math.sqrt(math.fabs(number) + (5 * math.pow(number, 3)))</span><span id="eacf" class="nf lu it nb b gy nk nh l ni nj">numbers = []<br/>N = 11<br/>for i in range(0, N):<br/>  numbers.append(float(input("Enter a number: ")))<br/>for i in range(N-1, -1,-1):<br/>  print(f(numbers[i]))</span></pre><p id="23d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于语法上的差异，Python版本看起来与其他版本有些不同。语法上的差异也会导致程序更短。与Java版本的21行代码相比，Python程序只使用了9行代码。</p><p id="a35c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，数组被称为列表，虽然Python列表允许对列表元素进行索引访问，但它不允许索引赋值，所以append方法用于向列表添加数字。</p><p id="8432" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python中没有常量，所以<code class="fe nl nm nn nb b">N</code>只是被赋了一个值。Python通常将常用的常量(如<code class="fe nl nm nn nb b">PI</code>)放在模块中，这样它们可以被使用但不能被更改。</p><p id="d71a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nl nm nn nb b">for</code>Python中的循环看起来有点不同，因为它们使用<code class="fe nl nm nn nb b">range</code>函数来指定循环控制变量的起始值和终止值。</p><p id="9168" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python对循环块使用缩进而不是花括号，冒号用于标记块的开始。当人们说Python没有太多语法时，我反驳说Python只是有不同的语法。编程语言必须有语法，否则就无法解析。</p><h1 id="1272" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="4dd3" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">我写这篇文章的目的并不是要将这些语言中的一种提升到另一种之上，而是使用一种可以在每种语言中表达的算法来指出它们之间的相似之处和不同之处。</p><p id="54dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将让您选择一种最喜欢的语言，或者决定哪种语言最适合这种类型的编程。在以后的文章中，我将着眼于其他算法进行比较，比如字符串算法和最好用对象解决的问题。</p><p id="86d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请回复这篇文章或发邮件给我，告诉我您的意见和建议。</p></div></div>    
</body>
</html>