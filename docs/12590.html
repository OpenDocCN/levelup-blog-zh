<html>
<head>
<title>Code Smell 142 — Queries in Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码味道142 —构造函数中的查询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/code-smell-142-queries-in-constructors-c61e359567b1?source=collection_archive---------8-----------------------#2022-06-21">https://levelup.gitconnected.com/code-smell-142-queries-in-constructors-c61e359567b1?source=collection_archive---------8-----------------------#2022-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9c55" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在域对象中访问数据库是一种代码味道。在构造函数中这样做是一个双重的味道</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/bf5e25c4ff5c5713193a589e4c2ec9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aawGiXl4sMkO80QfidPLA.jpeg"/></div></div></figure><blockquote class="ks kt ku"><p id="b109" class="kv kw kx ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="iq">TL；DR:构造函数应该构造(并且可能初始化)对象。</em></p></blockquote><h1 id="6719" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题</h1><ul class=""><li id="b346" class="mk ml iq ky b kz mm lc mn mo mp mq mr ms mt lr mu mv mw mx bi translated"><a class="ae my" href="https://codeburst.io/coupling-the-one-and-only-software-design-problem-869e293a9f04" rel="noopener" target="_blank">联轴器</a></li><li id="4a35" class="mk ml iq ky b kz mz lc na mo nb mq nc ms nd lr mu mv mw mx bi translated">副作用</li></ul><h1 id="8c72" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">解决方法</h1><ol class=""><li id="271e" class="mk ml iq ky b kz mm lc mn mo mp mq mr ms mt lr ne mv mw mx bi translated">将基本的业务逻辑从偶然的持久性中分离出来</li><li id="8b69" class="mk ml iq ky b kz mz lc na mo nb mq nc ms nd lr ne mv mw mx bi translated">在持久性类中，在构造函数/析构函数之外的函数中运行查询</li></ol><h1 id="b5f5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">语境</h1><p id="d6af" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo nf lh li mq ng ll lm ms nh lp lq lr ij bi translated">在遗留代码中，数据库没有正确地与业务对象分离。</p><p id="5e4e" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">构造函数不应该有副作用。</p><p id="4ab2" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">根据单一责任原则，他们应该只构建<em class="kx">有效的</em>对象</p><h1 id="a024" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">示例代码</h1><h2 id="bde8" class="ni lt iq bd lu nj nk dn ly nl nm dp mc mo nn no me mq np nq mg ms nr ns mi nt bi translated">错误的</h2><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="cade" class="ni lt iq nv b gy nz oa l ob oc">public class Person {<br/>  int childrenCount; </span><span id="5897" class="ni lt iq nv b gy od oa l ob oc">  public Person(int id) {<br/>    childrenCount = database.sqlCall("SELECT COUNT(CHILDREN) FROM PERSON WHERE ID = " . id); <br/>  }<br/>}</span></pre><h2 id="7757" class="ni lt iq bd lu nj nk dn ly nl nm dp mc mo nn no me mq np nq mg ms nr ns mi nt bi translated">对吧</h2><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="9d34" class="ni lt iq nv b gy nz oa l ob oc">public class Person {<br/>  int childrenCount; </span><span id="5662" class="ni lt iq nv b gy od oa l ob oc">  // Create a class constructor for the Main class<br/>  public Person(int id, int childrenCount) {<br/>    childrenCount = childrenCount; <br/>    // We can assign the number in the constructor<br/>    // Accidental Database is decoupled<br/>    // We can test the object<br/>  }<br/>}</span></pre><h1 id="9322" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">侦查</h1><p id="09ec" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo nf lh li mq ng ll lm ms nh lp lq lr ij bi translated">[X]半自动</p><p id="200b" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">我们的linters可以发现构造函数上的SQL模式并警告我们。</p><h1 id="f099" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">标签</h1><ul class=""><li id="0478" class="mk ml iq ky b kz mm lc mn mo mp mq mr ms mt lr mu mv mw mx bi translated">连接</li></ul><h1 id="c281" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="450b" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo nf lh li mq ng ll lm ms nh lp lq lr ij bi translated">在设计健壮的软件时，关注点的分离是关键，耦合是我们的主要敌人。</p><h1 id="98f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更多信息</h1><ul class=""><li id="0f5a" class="mk ml iq ky b kz mm lc mn mo mp mq mr ms mt lr mu mv mw mx bi translated"><a class="ae my" href="https://codeburst.io/coupling-the-one-and-only-software-design-problem-869e293a9f04" rel="noopener" target="_blank">耦合:唯一的软件问题</a></li></ul><h1 id="c56f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">信用</h1><p id="2f6b" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo nf lh li mq ng ll lm ms nh lp lq lr ij bi translated">照片由<a class="ae my" href="https://unsplash.com/@inkyhills" rel="noopener ugc nofollow" target="_blank">卡勒姆希尔</a>在<a class="ae my" href="https://unsplash.com/s/photos/no" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><blockquote class="ks kt ku"><p id="ea0f" class="kv kw kx ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的信念仍然是，如果你得到了正确的数据结构和它们的不变量，大部分代码会自己写出来。</p></blockquote><p id="16ba" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">彼得·德乌斯奇</p><div class="ol om gp gr on oo"><a href="https://blog.devgenius.io/software-engineering-great-quotes-3af63cea6782" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">软件工程名言</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">有时一个简短的想法可以带来惊人的想法。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">blog.devgenius.io</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kq oo"/></div></div></a></div></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="c75b" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">本文是CodeSmell系列的一部分。</p><div class="ol om gp gr on oo"><a href="https://blog.devgenius.io/how-to-find-the-stinky-parts-of-your-code-fa8df47fc39c" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">如何找到你的代码中有问题的部分</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">代码很难闻。让我们看看如何改变香味。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">blog.devgenius.io</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc kq oo"/></div></div></a></div></div></div>    
</body>
</html>