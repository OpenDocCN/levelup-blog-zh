<html>
<head>
<title>A deeper look at object-oriented programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解JavaScript中的面向对象编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-deeper-look-at-object-oriented-programming-in-javascript-6ab7761131a2?source=collection_archive---------16-----------------------#2020-06-02">https://levelup.gitconnected.com/a-deeper-look-at-object-oriented-programming-in-javascript-6ab7761131a2?source=collection_archive---------16-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b1d3033393fddf1a2491fcddd7cd75e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haMEQHfMceoIpoEs30wzuA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@grakozy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">格雷格·拉科齐</a>在<a class="ae kf" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="91e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种无类编程语言。如你所知，在Java等其他语言中，类在JavaScript中是不存在的。</p><p id="345f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管JavaScript没有提供对类的支持，但是JavaScript中现有概念(构造函数和原型继承)的巧妙使用使得开发人员能够成功地模拟这种行为。因此，ES6更新后，您可以在JavaScript中找到的关键字<code class="fe le lf lg lh b">class</code>是使用现有JavaScript概念模拟类所需步骤的语法抽象。在这篇文章中，我们将看到class关键字背后的基本概念。</p><p id="ee6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是首先，让我们看看创建对象的两种最简单的方法</p><h1 id="2e8e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">对象构造函数和对象文字</h1><p id="96ac" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript允许您使用<code class="fe le lf lg lh b">Object()</code>构造函数创建对象。对象构造函数为给定值创建一个对象包装。如果值为null，它将创建并返回一个空对象。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="754b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，通过调用带有空参数的对象构造函数，我们初始化了一个空对象，并把它赋给了变量dog。然后我们简单地在<code class="fe le lf lg lh b">dog</code>变量的帮助下添加对象属性</p><p id="9a93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript的最初几年后，对象文字成为创建对象的首选方式。我们可以将前面的例子改写为:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ec9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然使用<code class="fe le lf lg lh b">Object Constructor</code>和<code class="fe le lf lg lh b">Object literal</code>非常简单，但在创建对象时也有一些缺点。用同一个接口创建多个对象需要大量的代码复制。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="eba3" class="li lj it bd lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb nc md me mf bi translated">创建对象</h1><p id="ce0e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以简单地使用<code class="fe le lf lg lh b">class</code>来创建对象，这是自从ES6引入类以来的首选方式。但是要理解Javascript中的OOP是如何工作的，我们必须理解被类取代的底层概念。所以我们应该看看用接口实现对象创建的一些方法。</p><h2 id="1415" class="nd lj it bd lk ne nf dn lo ng nh dp ls kr ni nj lw kv nk nl ma kz nm nn me no bi translated"><strong class="ak">函数构造器模式</strong></h2><p id="00a4" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript对象可以使用构造函数来创建。JavaScript中有一些现成的本地构造函数，比如<code class="fe le lf lg lh b">Object</code>和<code class="fe le lf lg lh b">Array</code>。可以使用定义属性和方法的函数来定义自定义构造函数。所以让我们从创建一个名为<code class="fe le lf lg lh b">dog</code>的对象开始。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9d3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，使用<code class="fe le lf lg lh b">dog</code>函数作为构造函数来创建一个对象，我们在行号<code class="fe le lf lg lh b">10</code>中使用了<code class="fe le lf lg lh b">new</code>操作符。当执行第<code class="fe le lf lg lh b">10</code>行时，发生以下步骤:</p><ol class=""><li id="5eb5" class="np nq it ki b kj kk kn ko kr nr kv ns kz nt ld nu nv nw nx bi translated">在内存中创建了一个新对象</li><li id="2d66" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated">它将这个新对象的内部不可访问的<code class="fe le lf lg lh b">[[prototype]]</code>属性设置为构造函数的外部可访问的<em class="od">原型</em>对象(每个函数对象自动具有一个<em class="od">原型</em>属性)。</li><li id="f69d" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><code class="fe le lf lg lh b">this</code>值被分配给新创建的对象。</li><li id="90fa" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated">每当提到<code class="fe le lf lg lh b">this</code>时，它就使用新创建的对象执行构造函数。</li><li id="5d09" class="np nq it ki b kj ny kn nz kr oa kv ob kz oc ld nu nv nw nx bi translated">除非构造函数返回一个<code class="fe le lf lg lh b">non-null</code>对象引用，否则将返回新创建的对象。在这种情况下，将返回该对象引用。</li></ol><p id="d62d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构造函数和其他函数的唯一区别是它们被调用的方式。任何用<code class="fe le lf lg lh b">new</code>操作符调用的函数都充当构造函数。</p><p id="ad18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用构造函数创建对象时，值得注意的一点是<code class="fe le lf lg lh b">tuffy</code>对象在<code class="fe le lf lg lh b">dog</code>构造函数中有自己的属性副本。即。更改与一个对象关联的属性不会影响构造函数的属性。让我们来看一个例子:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5803" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的例子可以看出，改变<code class="fe le lf lg lh b">tuffy</code>对象中的玩具属性对<code class="fe le lf lg lh b">tyson</code>对象中的<code class="fe le lf lg lh b">toys</code>属性没有影响。因为<code class="fe le lf lg lh b">tuffy</code>和<code class="fe le lf lg lh b">tyson</code>都有自己的构造函数属性副本。</p><p id="34e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是由于对象有自己的属性副本，我们可能会面临内存相关的问题。因为同一属性的多个副本会占用大量空间。这是函数构造模式的主要缺点。</p><h2 id="6d60" class="nd lj it bd lk ne nf dn lo ng nh dp ls kr ni nj lw kv nk nl ma kz nm nn me no bi translated"><strong class="ak">原型图案</strong></h2><p id="9ca9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">每当你用JavaScript创建一个函数时，你会注意到在函数的定义中附加了一个对象名prototype。在原型对象内部，我们可以添加结果对象应该继承的属性。使用原型的好处是得到的对象没有属性的副本，但是它仍然可以通过在原型对象中搜索属性和方法来访问它们。</p><p id="a36f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们举个例子:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2541" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">prototype的工作方式是，当访问一个属性时，搜索开始查找该属性。搜索首先从对象开始，如果在对象中找到属性，则返回值。就像当我们试图调用第<code class="fe le lf lg lh b">12</code>行中的<code class="fe le lf lg lh b">dog.legs</code>时，它返回值4，因为属性腿存在于对象中。并且当在对象中没有找到该属性时，搜索继续沿着原型向上。并且在原型中搜索该属性。如果在原型上找到该属性，则它将返回值。如果没有找到，则继续沿着原型链向上搜索，直到遇到该属性。就像当我们试图访问<code class="fe le lf lg lh b">boy</code>上的属性分支时，搜索移动到原型，因为对象男孩没有属性分支。因为对象boy的原型具有属性legs，所以它返回值。</p><p id="c73a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要记住的一点是，原型是动态的。因此，原型在任何时候的任何变化都会反映在对象上。</p><p id="c940" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">甚至原型图案也不完美。第一个缺点是，你不能像我们在函数构造函数中那样传递参数。但老实说，这并不是一个很大的缺点，它很不方便，但开发者可以很容易地克服它。</p><p id="24e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是引用属性带来了真正的问题。让我们举个例子来理解这个缺点:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6992" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看到<code class="fe le lf lg lh b">dog1</code>和<code class="fe le lf lg lh b">dog2</code>都有相同的属性。这是因为在<code class="fe le lf lg lh b">line 6</code>中，push函数实际上引用了返回原型中存在的<code class="fe le lf lg lh b">toys</code>属性的属性，并向<code class="fe le lf lg lh b">toys</code>数组添加了一个新值。因此，可引用的属性会导致这种不一致的行为。</p><p id="d118" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原型的这种行为对一些人来说是可取的，但对另一些人来说可能是个问题。尽管通常希望对象具有它们自己的属性副本。因此很少单独使用原型模式。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="57ac" class="li lj it bd lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb nc md me mf bi translated">遗产</h1><p id="b3fa" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript中的继承主要是通过原型链接来完成的。首先，我们应该知道什么是原型链。</p><h2 id="a7ce" class="nd lj it bd lk ne nf dn lo ng nh dp ls kr ni nj lw kv nk nl ma kz nm nn me no bi translated"><strong class="ak">原型链接</strong></h2><p id="03fc" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript只有一个构造，那就是对象。正如我们已经看到的，每个对象都有一个称为原型的属性。原型是指向构造函数的属性和方法的对象。但是原型不一定是构造函数，它也可以是一个对象。这个对象也有自己的原型，它的原型也可能有自己的原型，这种模式将继续下去，形成一个原型链，称为原型链。</p><p id="4855" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看原型链是如何实现的:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="bdb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以正如你所看到的，<code class="fe le lf lg lh b">human</code>通过将它的原型指针指向<code class="fe le lf lg lh b">animals</code>对象来继承<code class="fe le lf lg lh b">animals</code>。因此，当我们访问<code class="fe le lf lg lh b">Jon.canWalk</code>时，它在它的对象中搜索canWalk属性，然后在它的原型:<code class="fe le lf lg lh b">human</code>对象中搜索，然后搜索到达<code class="fe le lf lg lh b">animals</code>对象，最后返回它的值。</p><p id="fb96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原型链接的问题和我们面对的原型问题是一样的。当我们使用包含引用值的属性时，这些属性在对象之间共享，这就是为什么属性是使用构造函数定义的。</p><blockquote class="oe of og"><p id="ae3e" class="kg kh od ki b kj kk kl km kn ko kp kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated">属性通常在构造函数中定义，而不是使用原型。因为我们已经看到，具有参考值的属性可能会令人恼火。</p></blockquote><h2 id="5779" class="nd lj it bd lk ne nf dn lo ng nh dp ls kr ni nj lw kv nk nl ma kz nm nn me no bi translated"><strong class="ak">古典传承</strong></h2><p id="9339" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">经典继承或构造函数窃取或伪装都意味着同样的事情。经典继承背后的思想是在一个对象的构造函数内部调用另一个对象的构造函数。我们可以利用<code class="fe le lf lg lh b">apply()</code>和<code class="fe le lf lg lh b">call()</code>方法在新创建的对象上执行构造函数。让我们来看看这个例子。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9318" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用<code class="fe le lf lg lh b">call()</code>或<code class="fe le lf lg lh b">apply()</code>方法，我们实际上是从形状中窃取了构造函数。在square构造函数中调用shapes构造函数时，它正在运行shapes构造函数的代码初始化，因此每个square类型的对象都有自己颜色的副本。</p><p id="b084" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构造函数窃取(经典继承)带来了优于原型链接的好处。使用经典继承，我们能够传递参数，这在原型链中是不利的。</p><p id="eb35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，经典继承有其自身的缺点。方法必须写在构造函数内部，所以没有函数重用。构造函数窃取不会自动创建原型，因此子类型对象不能使用超类型的原型。</p><h2 id="1424" class="nd lj it bd lk ne nf dn lo ng nh dp ls kr ni nj lw kv nk nl ma kz nm nn me no bi translated">组合遗传</h2><p id="5e99" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">组合继承(也称为伪经典继承)是原型链接和经典继承的组合。因此，我们可以从原型继承属性和方法，并使用经典继承来继承实例属性。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="34d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，我们使用构造函数窃取(经典继承)来继承属性，使用原型链接来继承方法。所以我们创建了object dog的两个实例，它们有自己的属性副本，同时它们共享一个方法。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="dc2b" class="li lj it bd lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb nc md me mf bi translated">班级</h1><p id="8637" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">到目前为止，我们已经深入了解了如何在JavaScript中模拟类。但是实现这些方法可能是一项单调乏味的任务，并且会增加在代码中产生bug的可能性。所以从ES6开始<code class="fe le lf lg lh b">class</code>被引入，它抽象了JavaScript中OOPs背后的逻辑。ES6类似乎以规范的面向对象编程为特色，但是它们仍然使用原型和构造函数。</p><p id="fb16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用两种方式编写类定义:类声明和类表达式</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ccb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:默认情况下，class方法中的所有内容都在严格模式下执行。</p><p id="94da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个类可以由构造函数、get方法、set方法、方法和静态方法组成。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e8c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使用<code class="fe le lf lg lh b">class</code>创建一个对象，我们使用了<code class="fe le lf lg lh b">new</code>关键字。关键字<code class="fe le lf lg lh b">new</code>将遵循我们在前面章节中使用<code class="fe le lf lg lh b">function constructor</code>创建对象时看到的相同步骤。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5185" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，类是一等公民。这意味着类可以做其他事物可以做的一切。可以像传递任何其他对象或函数引用一样传递类。类可以在函数的任何地方使用(例如在数组和函数参数中)。</p><p id="8e0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们通常在类对象中看到的一些成员:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b625" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一个类中，所有在构造函数中定义的成员和属性都不会共享给prototype。每个实例在构造函数中都有一个所有属性和方法的副本。这些属性与我们在创建对象时使用函数构造函数时看到的属性相同。</p><p id="2e7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在构造函数之外和类体的根中定义的所有东西都被附加到原型对象上。</p><p id="35e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:原始数据类型和对象不能添加到类的根。</p><p id="0b65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">静态方法是即使没有类的实例也可以使用的方法。正如我们在第<code class="fe le lf lg lh b">16</code>行看到的，方法<code class="fe le lf lg lh b">sayHello</code>没有创建类的实例就被使用了，因为它是一个静态方法。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="2b0f" class="li lj it bd lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb nc md me mf bi translated">遗产</h1><p id="7ddd" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">ES6更新的另一个特点是继承。语法是不同的，但是类继承仍然使用原型链接来实现继承。</p><p id="c265" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键字允许从任何具有属性和原型的事物中继承。这意味着它是向后兼容的，所以你可以从另一个类继承，也可以从函数构造函数继承。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8bc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们从<code class="fe le lf lg lh b">Animal</code>类继承了<code class="fe le lf lg lh b">Dog</code>类中的属性和方法。我们已经使用了<code class="fe le lf lg lh b">super()</code>方法来调用<code class="fe le lf lg lh b">Animal</code>类的构造函数。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="5c7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的OOPs模式到此结束。我们已经看到，没有任何正式的类概念，我们仍然可以在JS中实现类和继承。我们知道JavaScript到底是如何工作的是很重要的。原型和函数构造器在JavaScript中很重要，人们应该花时间去了解它们。</p><p id="ae9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快乐编码:)</p></div></div>    
</body>
</html>