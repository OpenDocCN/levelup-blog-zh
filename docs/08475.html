<html>
<head>
<title>React Components for D3 Charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">D3图表的反应组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-components-for-d3-charts-4912942a7e1d?source=collection_archive---------7-----------------------#2021-05-05">https://levelup.gitconnected.com/react-components-for-d3-charts-4912942a7e1d?source=collection_archive---------7-----------------------#2021-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/228c41218f0cc97e988197528af489f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VdGrRvxZ-OGaSaFZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">艾萨克·史密斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d2f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">D3.js是在浏览器中制作交互式视觉效果的一个很好的工具。这也可能是一件非常棘手的事情。为了减轻这种痛苦并保持理智，我最近开始重构我以前用D3编写的一些图表——现在使用React功能组件。</p><h1 id="0b28" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将D3打包成可重用的组件</h1></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="38f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将D3和React结合起来的好处在于，您实际上将视觉效果捆绑到一个可调用的HTML样式的标签中。您可以传入参数以方便定制和更新，任何不能在服务器端进行的数据争论都可以在顶层进行。这里有一个简单的散点图，用D3写的:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/08fbd1e751c1ae20c69e29bf593466a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*Vy_o34XwluhRTM01u_CkwA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基本散点图</figcaption></figure><p id="338e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我是这样画的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8e19" class="mq lc iq mm b gy mr ms l mt mu">import React, { useState, useEffect } from “react”;<br/>import ScatterChart from “./ScatterChart”;</span><span id="7e13" class="mq lc iq mm b gy mv ms l mt mu">export default function App(props) {<br/>    const [data, setData] = useState([]);</span><span id="2a0f" class="mq lc iq mm b gy mv ms l mt mu">useEffect(() =&gt; {<br/>        setData([{‘a’:1,’b’:2},<br/>            {‘a’:4,’b’:1},<br/>            {‘a’:2,’b’:3},<br/>            {‘a’:1,’b’:3}])<br/>    },[])</span><span id="4826" class="mq lc iq mm b gy mv ms l mt mu">if (!data) {<br/>    return null<br/>    }</span><span id="4bde" class="mq lc iq mm b gy mv ms l mt mu">return (<br/>        &lt;div style={{height:’50%’,width:’50%’,marginTop:10,display:’inline-block’}}&gt;<br/>            &lt;ScatterChart data={data} xVal={‘a’} yVal={‘b’}/&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="ee99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多好的<em class="mw">啊</em>啊？将它放入一个div中，用于放置/调整大小，并将任何变量作为参数传入。不乱。太好了。</p><p id="cf2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我在<a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> useEffect() </a>钩子中硬编码了一个样本数据集。通常，我会从后端获取这些数据，并将其传递给散点图组件。如果我想要前端过滤器选项，那么我可以通过<a class="ae kc" href="https://reactjs.org/docs/faq-state.html" rel="noopener ugc nofollow" target="_blank">状态</a>处理数据变化。在第一次呈现组件之前，我们需要等待setData实际返回数据，因此如果数据为空，则返回null。</p><h1 id="611f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">编写D3图表组件</h1></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="0c00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看它是如何构造的。如果你想一起玩，你可以从你的终端使用npx create-react-app命令来生成一个游乐场环境。用“npm i d3”将d3添加到您的项目文件夹中，并将上述内容复制到您的“App.js”文件中。向“src”目录添加一个名为“ScatterChart.js”的新文件。</p><p id="cb92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先添加一些样板代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="64ed" class="mq lc iq mm b gy mr ms l mt mu">import * as d3 from ‘d3’;</span><span id="f8da" class="mq lc iq mm b gy mv ms l mt mu">import React, { useRef, useEffect } from ‘react’;</span><span id="74e7" class="mq lc iq mm b gy mv ms l mt mu">export default function ScatterChart(props) {<br/>    const ref = useRef()<br/>    const height = 460,<br/>        width = 460<br/>    return (<br/>        &lt;svg<br/>            viewBox={“0 0 “ + height + “ “ + width}<br/>            ref={ref}<br/>        /&gt;<br/>    )<br/>}</span></pre><p id="bd29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们已经定义并导出了我们的功能组件散点图，并定义了一些初始参数(高度、宽度和ref)。<a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> useRef() </a> React钩子在我们的D3代码和我们返回的渲染SVG之间提供了一个引用。后面的代码片段将按顺序放在已定义的参数和return语句之间。</p><p id="c8b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要获取我们的svg引用并设置一些初始参数。为此，添加一个useEffect挂钩。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="35b2" class="mq lc iq mm b gy mr ms l mt mu">useEffect(() =&gt; {<br/>    const svgElement = d3.select(ref.current)<br/>                         .append(“g”)<br/>                         .classed(“svgElement”, true)<br/>                         .attr(“height”, height)<br/>                         .attr(“width”, width)<br/> },[])</span></pre><p id="3675" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的数据从来没有改变，图表的其余部分可以从同一个钩子中画出。我喜欢给自己一个选项，能够更新/过滤数据集，而不必重写我的组件，因此我使用第二个useEffect挂钩来绘制我的图表的其余部分。我需要获取我在前一个钩子中引用的元素，然后再设置几个参数。请注意，我们现在引用了我们的道具。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b1cd" class="mq lc iq mm b gy mr ms l mt mu">useEffect(() =&gt; {<br/>    const svgElement = d3.select(ref.current).select(“g.svgElement”)<br/>    var margin = { top: 10, right: 10, bottom: 10, left: 30 };<br/>    var xValMax = d3.max(props.data,function(d){return     (d[props.xVal])})*1.1<br/>    var yValMax = d3.max(props.data,function(d){return (d[props.yVal])})*1.1<br/>},[props.data])</span></pre><p id="d350" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从父组件(在本例中为“App”，如App.js中所定义的)传递给我们的组件的任何参数都可以通过“props.parameterName”来访问。道具的使用使得React组件在存储D3视觉效果时非常方便。首先，我可以传递我的数据。这意味着父组件可以获取、修改数据集并将其分发给多个子组件。其次，我可能想要更改的任何属性都可以设置为变量，并通过从父级传入参数来更改。在这个例子中，我只使用了xVal和yVal(分别在x轴和y轴上测量的属性)。我也可以传入文本颜色，圆圈颜色，大小等等…我们稍后会讲到。</p><p id="093f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我想定义我的轴。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="60cd" class="mq lc iq mm b gy mr ms l mt mu">//define x axis<br/>var xScale = d3.scaleLinear()<br/>               .domain([0,scatterDomMax])<br/>               .range([margin.left, 400]);</span><span id="9571" class="mq lc iq mm b gy mv ms l mt mu">var xAxis = svgElement.append(“g”)<br/>                      .call(d3.axisBottom(xScale))<br/>                      .attr(“class”,”x-axis”)<br/>                      .attr(“transform”, “translate(0,”+(400)+“)”);<br/>//x label<br/>svgElement.append(“text”)<br/>          .attr(“class”,”scatterLabels”)<br/>          .style(“text-anchor”, “end”)<br/>          .attr(“x”, 405)<br/>          .attr(“y”, 395)<br/>          .style(“font-size”,”24px”)<br/>          .style(“fill”,”black”)<br/>          .text(props.xVal);</span><span id="8d06" class="mq lc iq mm b gy mv ms l mt mu">//define y axis<br/>var yScale = d3.scaleLinear()<br/>               .domain([0,scatterDomMax])<br/>               .range([400,0])</span><span id="a277" class="mq lc iq mm b gy mv ms l mt mu">var yAxis = svgElement.append(“g”)<br/>                      .call(d3.axisLeft(yScale))<br/>                      .attr(“class”,”y-axis”)<br/>              .attr(“transform”,“translate(“+ margin.left +“, 0)”)<br/>//y label<br/>svgElement.append(“text”)<br/>          .attr(“class”,”scatterLabels”)<br/>          .attr(“transform”, “rotate(-90)”)<br/>          .attr(“y”, margin.right + 18)<br/>          .attr(“dy”, “1em”)<br/>          .style(“text-anchor”, “end”)<br/>          .style(“font-size”,”24px”)<br/>          .style(“fill”,”black”)<br/>          .text(props.yVal);</span></pre><p id="d354" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们到了有趣的部分；更新周期。使用<a class="ae kc" href="https://observablehq.com/@d3/selection-join" rel="noopener ugc nofollow" target="_blank"> d3.join() </a>我们可以相对容易地处理数据的变化。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7886" class="mq lc iq mm b gy mr ms l mt mu">svgElement.selectAll(“circle”)<br/>          .data(props.data, d =&gt; d)<br/>          .join(enter =&gt; (<br/>              enter.append(“circle”)<br/>         .attr(“cx”, function (d) { return xScale(d[props.xVal]); })<br/>         .attr(“cy”, function (d) { return yScale(d[props.yVal]); })<br/>         .attr(“r”, function(d) {return 6})<br/>         .attr(“class”,”circles”)<br/>         .style(“stroke”, “red”)<br/>         .style(“stroke-width”, “2px”)<br/>         .style(“fill”, “green”)<br/>          .call(enter =&gt; (<br/>              enter.transition().duration(800)<br/>            ))<br/>        ),<br/>        update =&gt; (<br/>            update<br/>            .call(update =&gt; (<br/>            update.transition().duration(800)<br/>            ))<br/>        ),<br/>        exit =&gt; (<br/>            exit<br/>            .call(exit =&gt; {<br/>            exit.transition().duration(400)<br/>            .style(“opacity”,0)<br/>            .remove()<br/>            })<br/>        )<br/>    )</span></pre><p id="f25b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们抓取任何附加到svg元素的圆圈(第一次传递时将为0 ),并附加从父元素传递下来的数据。enter函数将为数据集中的每个点在svg中添加一个圆，在调用平滑过渡之前添加一些样式(可以参数化)，平滑过渡将在网页加载时播放。如果添加了数据点，它们将通过相同的enter函数传递。更新的数据点通过update函数转换，而不再存在的数据点通过exit函数传递，并转换出视图。</p><h1 id="e534" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用参数替换道具</h1></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="edc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最初的散点图函数接受了<em class="mw">道具</em>参数，这允许我们通过<em class="mw">道具传递任意数量的参数。参数名称。</em>问题是，我希望能够在不改变组件代码的情况下改变样式。我需要定义默认参数，这样我就可以<em class="mw">可选地</em>在从‘app . js’调用这个组件时使用我的样式。</p><p id="5404" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">做到这一点很简单——我们用我们希望能够更改的任何参数的默认值替换<em class="mw"> props </em>,并简单地将这些变量传递给组件中的相关点。下面是一个我们传递默认高度/宽度参数的例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2471" class="mq lc iq mm b gy mr ms l mt mu">export default function ScatterChart({<br/>                                 height = 460,<br/>                                 width = 460<br/>                                 })<br/>    return (<br/>        &lt;svg<br/>            viewBox={"0 0 " + height + " " + width}<br/>            ref={ref}<br/>        /&gt;<br/>    )<br/>}</span></pre><p id="798c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们从' App.js '调用<scatterchart/>，那么高度和宽度将默认为460。例如，如果我们调用<scatterchart height="500" width="500"/>，那么高度和宽度将分别设置为500。这非常适合搭配不同的颜色/风格。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="e186" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你知道了。将来我会在网站和我的git账户上发布新的D3组件。所以如果你感兴趣的话，请留意这些。</p><p id="b5ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那之前—</p></div></div>    
</body>
</html>