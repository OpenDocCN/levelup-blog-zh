<html>
<head>
<title>Design Patterns in Python: Factory &amp; Abstract Factory Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的设计模式:工厂和抽象工厂模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-in-python-factory-pattern-beea1da31c17?source=collection_archive---------0-----------------------#2022-05-26">https://levelup.gitconnected.com/design-patterns-in-python-factory-pattern-beea1da31c17?source=collection_archive---------0-----------------------#2022-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cf15" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python中工厂和抽象工厂模式的实现</h2></div><p id="ce98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工厂设计模式是一种创造性的设计模式。这是编程中最常用的模式之一。</p><p id="0a2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建对象是一项复杂的任务。通常，构造函数在创建对象时会带很多参数。创造性的设计模式，也就是工厂模式，使得那里的工作更容易。工厂模式也可以作为单例类来实现。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/2c5e1046fa4b1913d1c5b593ac713813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ugq7lTwd5qZ5mLJNWJyDxQ.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">西蒙·卡杜拉在<a class="ae lr" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0bcc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前情提要…</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/@okanyenigun/design-patterns-in-python-singleton-pattern-f76dc26281f8" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python中的设计模式:单例模式</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Python中Singleton设计模式的实现</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ll lv"/></div></div></a></div><p id="5027" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">项目中的许多地方都需要业务对象。因此，创建相关对象的代码片段或构造函数将在整个系统中被调用。因为这个原因，会有很多复制粘贴的重复。</p><p id="910b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工厂模式解决了在哪里创建对象的问题。它抽象了对象创建过程。它的子类接管具有不同专门化但来源相同的对象的创建控制。对象创建过程通过工厂模式与已创建对象的使用相分离。是一种放松创作和大量使用之间关系的方法。</p><p id="ee4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对象创建过程中检索状态信息的责任尽可能多地分配给创建者方法。如果可能的话，创建者应该自己获取这些信息，而不是从外部传递参数。这降低了创建对象的复杂性。</p><h2 id="1256" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">编码工厂模式</h2><h2 id="928a" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">领域问题</h2><p id="2d90" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">为了清楚起见，让我们在这个例子中考虑一个假想的业务问题。一家汽车制造公司生产三种车身的汽车:轿车、掀背车和皮卡。</p><p id="2fa4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当生产计划部门发出新的生产计划时，工厂生产线都希望准备好生产这些不同类型的汽车。</p><h2 id="256c" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">类图</h2><p id="0c03" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">让我们用工厂设计模式来解决这个问题。我有一门汽车抽象课。有不同类型的car子类实现这个car抽象类。汽车工厂根据收到的需求创建相关的汽车类别。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/5367383da8093e11617f24a87ed778be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*jrDtUsZ-Zva3kVy3uska9A.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">工厂模式类图。图片由作者提供。</figcaption></figure><h2 id="6f52" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">编码</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><pre class="lc ld le lf gt nl nm nn no aw np bi"><span id="c33d" class="mk ml iq nm b gy nq nr l ns nt">plan_list = ["Sedan", "Hatchback", "Pick-Up", "Motobike"]<br/>for p in plan_list:<br/>    car = CarFactory.build_car(p)<br/>    body = car.get_body_type()<br/>    print(body)</span><span id="a655" class="mk ml iq nm b gy nu nr l ns nt">#Out: <br/>Body Type: Sedan<br/>Body Type: Hatchback<br/>Body Type: Pick-up<br/>Car type is not valid.</span></pre><h1 id="c537" class="nv ml iq bd mm nw nx ny mp nz oa ob ms jw oc jx mv jz od ka my kc oe kd nb of bi translated">抽象工厂模式</h1><p id="0276" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">如上所示，工厂设计模式基于通过继承父类来派生子类。生成这些派生类的是一个<strong class="kh ir">方法</strong>。它只负责创建一个对象。</p><p id="4adb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，抽象工厂模式是一个<strong class="kh ir">类</strong>。它负责创建对象系列。该系列是设计用于一起使用的对象，并且适用于该系列。因此，它提供了多个要创建的对象。它可以做到这一点，因为它包含了对象系列的工厂。也就是说，抽象工厂设计模式包含许多工厂设计模式。</p><p id="be5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个也可以认为是同一个设计模式。抽象工厂设计模式可以被认为是另一种模式的定制版本。</p><h2 id="70c0" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">领域问题</h2><p id="f802" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">同一家汽车制造商根据不同的客户群生产不同的车型。营销团队将潜在客户分为4个不同的群体:<em class="og">家庭、户外、单身汉和富人</em>。</p><p id="a5e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，产品开发部门在根据这一细分创造产品时，决定汽车的两个主要部分:<em class="og">车身</em>和<em class="og">硬件</em>。</p><h2 id="16c4" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">类图</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/14c618d36b307eadaa42bf077fafb0a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*WMCdHvn5W-iMHuvq5B2ZOw.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">抽象工厂模式类图。图片由作者提供。</figcaption></figure><p id="1de1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为这些部分创建抽象类。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oi"><img src="../Images/7e27d0cab142035d80d87eeab41b8b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0WntUg1mtN3pDG4gc7pNhQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片由作者提供。</figcaption></figure><p id="39af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">车身分类总成根据客户群确定的发动机类型和车身类型。</p><p id="fdc0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产品开发部门为这两种零件开发了两种不同的选项。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oj"><img src="../Images/5d6c271bdb20ed528df6fb2256bfd01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmBWufb9J229R4QI2IJ92g.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片由作者提供。</figcaption></figure><p id="4c9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有使用低容量发动机和掀背式车身的普通车身，以及使用高容量发动机和轿车车身的运动车身。同样，我们有一个标准的硬件套件，包括一个小屏幕和普通的织物座椅。此外，我们有一个豪华的硬件套件，包括一个更大的屏幕和皮革织物座椅。</p><h2 id="7b75" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">更差的实现</h2><p id="5281" class="pw-post-body-paragraph kf kg iq kh b ki nd jr kk kl ne ju kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">让我们创建一个根据订单设计汽车的函数。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oi"><img src="../Images/de26c107857ef30c1f5c6d0805fde8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wihd-ukSsY_VYaFvfDlk5A.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片由作者提供。</figcaption></figure><p id="e621" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出将是:</p><pre class="lc ld le lf gt nl nm nn no aw np bi"><span id="0474" class="mk ml iq nm b gy nq nr l ns nt">prepare_order("Family")<br/>"""</span><span id="9b50" class="mk ml iq nm b gy nu nr l ns nt">1.2 Motor<br/>Hatchback<br/>Small Screen with Digital Speedometer<br/>Normal fabric</span><span id="9de0" class="mk ml iq nm b gy nu nr l ns nt">"""</span></pre><p id="0afc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个实现可以正常工作，没有任何问题。但是，您应该看到对象创建和使用之间的关系令人沮丧。假设产品开发部门有了新的愿景，并决定创建不同的车辆模型。或者，营销产生了新的细分。在这种情况下，创建vehicle对象和使用这些创建的对象会相互干扰，极大地增加了复杂性，并且可能会产生无尽的if-else语句和独特的对象创建过程。</p><h2 id="e979" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">编码</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="00ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建了汽车的抽象工厂类。它决定了发动机和车身。它返回一个主体实例和硬件实例。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ok"><img src="../Images/ae26e572ee3ce580ae7b04783ffadf31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwwIpRV2v4uQKGDhXQyxQQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片由作者提供。</figcaption></figure><p id="5f83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据来自市场营销的细分，现在产品开发部门可以创造无限多的汽车类型。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ol"><img src="../Images/7bf3d22c4b6c3549f48ecb4b44c12acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfQWNemEnFvKG8golgLUVA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片由作者提供。</figcaption></figure><p id="b237" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，生产新汽车更容易，也更清洁。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oi"><img src="../Images/5e8d462297c709b61bb13c25b207d181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5KurQWIBub5JCIThhyPtQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片由作者提供。</figcaption></figure><p id="081d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读。如果您有任何问题或意见，请随时写信给我！</p><h2 id="9982" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">下一集</h2><div class="ls lt gp gr lu lv"><a href="https://medium.com/@okanyenigun/design-patterns-in-python-prototype-pattern-9e520d36565e" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python中的设计模式:原型模式</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Python中原型模式的实现</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="om l mg mh mi me mj ll lv"/></div></div></a></div><h2 id="8ff0" class="mk ml iq bd mm mn mo dn mp mq mr dp ms ko mt mu mv ks mw mx my kw mz na nb nc bi translated">阅读更多内容…</h2><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/design-patterns-in-python-singleton-pattern-f76dc26281f8"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python中的设计模式:单例模式</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Python中Singleton设计模式的实现</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://towardsdev.com/solid-principles-explained-635ad3608b20" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">解释了坚实的原则</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">用Python语言举例说明坚实的原理</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdev.com</p></div></div><div class="me l"><div class="on l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://python.plainenglish.io/data-classes-abstraction-interfaces-in-python-ea107d235d3e" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python中的数据类、抽象和接口</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Python中的抽象、接口和其他类概念</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">python .平原英语. io</p></div></div><div class="me l"><div class="oo l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/@okanyenigun/polymorphism-in-python-cf3bef17f7f2" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python中的多态性</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Python中重载和重写的实现</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="op l mg mh mi me mj ll lv"/></div></div></a></div></div></div>    
</body>
</html>