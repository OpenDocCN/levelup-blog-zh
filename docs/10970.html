<html>
<head>
<title>Execute long-running jobs in the background [Node.js]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在后台执行长时间运行的作业[Node.js]</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/execute-long-running-jobs-in-the-background-node-js-e74e12163fef?source=collection_archive---------1-----------------------#2022-02-02">https://levelup.gitconnected.com/execute-long-running-jobs-in-the-background-node-js-e74e12163fef?source=collection_archive---------1-----------------------#2022-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e929" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Bull —快速教程</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/cf11e3590ffdcec5474b10d308531504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAp0Gr0B3YIgG31_RtWyuQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6948569" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae le" href="https://pixabay.com/users/pafka_zorg-14533931/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6948569" rel="noopener ugc nofollow" target="_blank"> Pafka Zorg </a></figcaption></figure><p id="cff6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我在Node.js世界中第一次遇到长时间运行的作业。不过，我在Ruby和Python世界中已经做过多次了。因此，我也将在Node.js中使用类似的工具。</p><p id="8234" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经决定使用<a class="ae le" href="https://github.com/OptimalBits/bull" rel="noopener ugc nofollow" target="_blank"> Bull </a>，这是一个非常流行的在后台异步执行长时间运行的作业/任务的包。</p><p id="2704" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是这样做的:</p><p id="a440" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[ <a class="ae le" href="https://github.com/pmatsinopoulos/try_bull" rel="noopener ugc nofollow" target="_blank">源代码在此处</a></p><h1 id="ae41" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">初始化演示项目</h1><p id="ed95" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">创建一个文件夹来处理您的演示项目。示例:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="566f" class="mn lg it mj b gy mo mp l mq mr">$ mkdir try_bull</span></pre><p id="6f21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您已经安装了<code class="fe ms mt mu mj b">node</code>和<code class="fe ms mt mu mj b">yarn</code>，运行:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="792a" class="mn lg it mj b gy mo mp l mq mr">$ yarn init</span></pre><p id="4aae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回答问题，你就可以安装<code class="fe ms mt mu mj b">bull</code>了。</p><h1 id="30fd" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">安装公牛</h1><p id="95f5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如下使用<code class="fe ms mt mu mj b">yarn</code>:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="aa19" class="mn lg it mj b gy mo mp l mq mr">$ yarn add bull</span></pre><h1 id="67ab" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Redis服务器</h1><p id="cb9b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">确保您已经在本地机器上安装并运行了<a class="ae le" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis服务器</a>。</p><p id="f060" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Bull使用Redis来存储用于后台处理的作业。我们的小演示需要您运行Redis并监听默认端口6379上的连接。</p><h1 id="856c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">演示架构</h1><p id="fedd" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这是我们将要做的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/39ad5a9bd8dff0f921b9060b770e2fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNLxHQdoL3NgKEJ34OL53Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">演示架构</figcaption></figure><h2 id="240d" class="mn lg it bd lh mw mx dn ll my mz dp lp kb na nb lt kf nc nd lx kj ne nf mb ng bi translated">队列</h2><p id="9f96" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们需要一个队列来注册异步处理的作业。这个队列将驻留在Redis db中。</p><h2 id="05e3" class="mn lg it bd lh mw mx dn ll my mz dp lp kb na nb lt kf nc nd lx kj ne nf mb ng bi translated">生产者</h2><p id="bdb9" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们需要一个能把工作放到队列中的制片人。这将是<code class="fe ms mt mu mj b">./src/producer.js</code>。</p><h2 id="b39e" class="mn lg it bd lh mw mx dn ll my mz dp lp kb na nb lt kf nc nd lx kj ne nf mb ng bi translated">消费者</h2><p id="e9f4" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们需要一个工人或消费者从队列中取出作业并执行它们。这将是<code class="fe ms mt mu mj b">./scr/consumer.js</code>。</p><h2 id="0bed" class="mn lg it bd lh mw mx dn ll my mz dp lp kb na nb lt kf nc nd lx kj ne nf mb ng bi translated">听众</h2><p id="491d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这不是必须的，但是通过引入第三个监听作业完成的进程，将结果的处理从消费者进程中分离出来是很好的。这是监听器，在<code class="fe ms mt mu mj b">./src/listener.js</code>中实现。</p><h1 id="f9b5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">代码</h1><p id="3be5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们来看看上述每个组件的代码部分:</p><h2 id="93e7" class="mn lg it bd lh mw mx dn ll my mz dp lp kb na nb lt kf nc nd lx kj ne nf mb ng bi translated">生产者</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ul class=""><li id="4d5d" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn no np nq nr bi translated">第4行:我们通过名称(<code class="fe ms mt mu mj b">processing-image</code>)来访问队列。如果Redis db中不存在该队列，将会创建它。</li><li id="81cc" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第9行和第11行:我们在队列中添加了两个作业。<code class="fe ms mt mu mj b">#add()</code>方法可以达到这个目的。您可以将任何可以序列化为字符串的JavaScript对象作为参数传递。然后，该对象将在消费者/工作者端被自动反序列化，以便消费者能够访问完全相同的数据。</li><li id="dce4" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第15行:我们只是解雇生产者，让他把作业放到队列中。</li></ul><h2 id="a60b" class="mn lg it bd lh mw mx dn ll my mz dp lp kb na nb lt kf nc nd lx kj ne nf mb ng bi translated">消费者</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ul class=""><li id="12f4" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn no np nq nr bi translated">第5行:我们通过名称(<code class="fe ms mt mu mj b">processing-image</code>)访问队列。</li><li id="cf64" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第7–14行:我们定义处理逻辑。这在一个内联定义的<code class="fe ms mt mu mj b">async</code>函数中实现，并作为参数传递给<code class="fe ms mt mu mj b">#process()</code>方法。</li><li id="ba62" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第8行:看看我们如何访问生产者传递的数据。它是<code class="fe ms mt mu mj b">job.data</code>的对象。</li><li id="a9ec" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第10行:我调用我的长时间运行的作业。</li><li id="5443" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第12行:我返回一个对象作为结果。这将由收听者访问。</li><li id="c5a5" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第16行:我只是启动消费者。它将等待作业排队。</li></ul><h2 id="aa7e" class="mn lg it bd lh mw mx dn ll my mz dp lp kb na nb lt kf nc nd lx kj ne nf mb ng bi translated">听众</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ul class=""><li id="3a2d" class="nj nk it js b jt ju jx jy kb nl kf nm kj nn kn no np nq nr bi translated">第4行:监听器访问命名队列(<code class="fe ms mt mu mj b">processing-image</code>)。</li><li id="ce46" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第6–8行:我们注册了一个全局事件处理程序来处理特定队列上作业的完成。</li><li id="9841" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第7行:监听器作业完成处理程序可以访问消费者返回的结果。</li><li id="b666" class="nj nk it js b jt ns jx nt kb nu kf nv kj nw kn no np nq nr bi translated">第11行:我们启动监听器。</li></ul><h1 id="c151" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">启动脚本</h1><p id="1e77" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">启动脚本在<code class="fe ms mt mu mj b">package.json</code>文件中定义:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="c428" class="mn lg it mj b gy mo mp l mq mr">"scripts": {<br/>  "producer": "node src/producer.js",<br/>  "consumer": "node src/consumer.js",<br/>  "listener": "node src/listener.js"<br/>},</span></pre><p id="f051" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开终端并启动消费者:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="5e57" class="mn lg it mj b gy mo mp l mq mr">npm run consumer</span></pre><p id="4a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开另一个终端并启动监听器:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="c1d0" class="mn lg it mj b gy mo mp l mq mr">npm run listener</span></pre><p id="3dbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开第三个终端来启动生成器</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="019d" class="mn lg it mj b gy mo mp l mq mr">npm run producer</span></pre><p id="fa34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将看到消费者消费和侦听器响应完成事件。</p><h1 id="c9ce" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结束语</h1><p id="2bdb" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这是一个测试Bull的快速教程，Bull是Node.js的一个非常强大的后台作业框架。</p><p id="dd44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从你身上学到的总是比你从我身上学到的多。因此，我们非常欢迎您的评论。</p></div></div>    
</body>
</html>